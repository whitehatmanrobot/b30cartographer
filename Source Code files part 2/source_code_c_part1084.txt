pressed while this window has the focus.  NT should properly
 * fake termination to all other apps connected to us.
 */
VOID MyProcessKey(
TCHAR tchCode,
LONG lKeyData)
{
    switch (tchCode) {
    case 'B':
    case 'b':
        *((PBYTE)(-1)) = 0;    // Cause GP fault!
        break;
    }
}



LONG  FAR PASCAL MainWndProc(
HWND hwnd,
UINT message,
WPARAM wParam,
LONG lParam)
{
    RECT rc;

    switch (message) {
    case WM_CREATE:
        /*
         * initially we are inactive - this reduces some of the message
         * traffic while we are initializing - but we could start active fine.
         */
        fActive = FALSE;
        break;

    case WM_RBUTTONDOWN:
        if (GetKeyState(VK_CONTROL) & 0x8000) {
            /*
             * A CTRL R_BUTTON click will cause ALL instances of this app
             * to become inactive.
             */
            BroadcastTransaction("PAUSE", 6, 0, XTYP_EXECUTE);
            MessageBeep(0);
        }
        /*
         * A R_BUTTON click makes us inactive.  Repaint to show state change.
         * We do a synchronous update in case there is too much DDE message
         * activity to allow the WM_PAINT messages through.  Remember DDE
         * messages have priority over others!
         */
        KillTimer(hwndMain, 1);
        fActive = FALSE;
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        break;

    case WM_LBUTTONDOWN:
        if (GetKeyState(VK_CONTROL) & 0x8000) {
            /*
             * A CTRL L_BUTTON click will cause ALL instances of this app
             * to become active.
             */
            BroadcastTransaction("RESUME", 7, 0, XTYP_EXECUTE);
            MessageBeep(0);
        }
        /*
         * An L_BUTTON click makes us active.  Repaint to show state change.
         */
        SetTimer(hwndMain, 1, BASE_TIMEOUT + (rand() & 0xff), NULL);
        fActive = TRUE;
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        break;

    case WM_CHAR:
        MyProcessKey((TCHAR)wParam, lParam);
        break;

    case WM_TIMER:
        /*
         * We use timers for simplicity.  On Win3.1 we could run out of
         * timers easily but we don't have this worry on NT.
         *
         * Each tick, we increment our data and call DdePostAdvise() to
         * update any links there may be on this data.  DDEML makes link
         * updates on specific items quite easy.
         */
        count++;
        DdePostAdvise(idInst, hszAppName, hszAppName);
        /*
         * Invalidate the part of ourselves that shows our data and
         * synchronously update it in case DDE message activity is blocking
         * paints.
         */
        SetRect(&rc, 0, 0, cxText, cyText);
        InvalidateRect(hwndMain, &rc, TRUE);
        UpdateWindow(hwndMain);
        break;

    case WM_PAINT:
        PaintDemo(hwnd);
        break;

    case WM_CLOSE:
        KillTimer(hwnd, 1);
        /*
         * We do DDE cleanup here.  It is best to do DDE cleanup while
         * still in the message loop to allow DDEML to recieve messages
         * while shutting down.
         */
        DdeDisconnectList(hConvList);
        DdeNameService(idInst, 0, 0, DNS_UNREGISTER);
        DdeFreeStringHandle(idInst, hszAppName);
        DdeUninitialize(idInst);
        PostQuitMessage(0);
        break;

    default:
        return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return(0);
}


VOID PaintDemo(
HWND hwnd)
{
    PAINTSTRUCT ps;
    RECT rc;
    HCONV hConv;
    CONVINFO ci;
    int cConvsOrg = cConvs;

    BeginPaint(hwnd, &ps);
    /*
     * Draw our data on top - Black for active, Grey for inactive.
     */
    SetRect(&rc, 0, 0, cxText, cyText);
    SetBkMode(ps.hdc, TRANSPARENT);
    SetTextColor(ps.hdc, 0x00FFFFFF);   // white text
    FillRect(ps.hdc, &rc, GetStockObject(fActive ? BLACK_BRUSH : GRAY_BRUSH));
    DrawText(ps.hdc, itoa(count, szT, 10), -1, &rc, DT_CENTER | DT_VCENTER);

    /*
     * Now draw the most recently recieved data from each server we are
     * connected to.
     */
    if (hConvList) {
        OffsetRect(&rc, 0, cyText);
        SetTextColor(ps.hdc, 0);    // draw black text
        cConvs = 0;
        hConv = DdeQueryNextServer(hConvList, NULL);
        while (hConv) {
            cConvs++;
            /*
             * count how many conversations are active while we're at it.
             */
            ci.cb = sizeof(CONVINFO);
            DdeQueryConvInfo(hConv, QID_SYNC, &ci);
            FillRect(ps.hdc, &rc, GetStockObject(WHITE_BRUSH));  // white bkgnd
            DrawText(ps.hdc, itoa(ci.hUser, szT, 10), -1, &rc,
                    DT_CENTER | DT_VCENTER);
            OffsetRect(&rc, 0, cyText);
            hConv = DdeQueryNextServer(hConvList, hConv);
        }
    }
    EndPaint(hwnd, &ps);
    if (cConvsOrg != cConvs) {
        /*
         * The number of active conversations changed!  Resize to fit.
         */
        SetWindowPos(hwndMain, 0, 0, 0, cxText,
                (cyText * (cConvs + 1)) + cyTitle,
                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
}



/*
 * This is the main DDEML callback proc.  It handles all interaction with
 * DDEML that is DDEML originated.
 */
HDDEDATA CALLBACK DdeCallback(
WORD wType,
WORD wFmt,
HCONV hConv,
HSZ hszTopic,
HSZ hszItem,
HDDEDATA hData,
DWORD lData1,
DWORD lData2)
{
    LPTSTR pszExec;

    switch (wType) {
    case XTYP_CONNECT:
        /*
         * Only allow connections to us.  We can always return TRUE because
         * the CBF_FILTERINITS bit given to DdeInitialize() told DDEML to
         * never bother us with connections to any service names other than
         * what we have registered.
         *
         * Note that we do not handle the XTYP_WILD_CONNECT transaction.
         * This means that no wild-card initiates to us will work.
         */
        return(TRUE);

    case XTYP_ADVREQ:
    case XTYP_REQUEST:
        /*
         * These two transactions are the only ones that require us to
         * render our data.  By using a custom format, we don't have to
         * convert our count to text form to support CF_TEXT.
         */
        return(DdeCreateDataHandle(idInst, (PBYTE)&count, sizeof(count), 0,
                hszAppName, OurFormat, 0));

    case XTYP_ADVSTART:
        /*
         * Only allow links to our Item in our format.
         */
        return((UINT)wFmt == OurFormat && hszItem == hszAppName);

    case XTYP_ADVDATA:
        /*
         * Data is comming in.  We don't bother with XTYP_POKE transactions,
         * but if we did, they would go here.  Since we only allow links
         * on our item and our format, we need not check these here.
         */
        if (DdeGetData(hData, (PBYTE)&InCount, sizeof(InCount), 0)) {
            DdeSetUserHandle(hConv, QID_SYNC, InCount);
        }
        /*
         * update ourselves to reflect the new incomming data.
         */
        InvalidateRect(hwndMain, NULL, TRUE);
        /*
         * This transaction requires a flag return value.  We could also
         * stick other status bits here if needed but its not recommended.
         */
        return(DDE_FACK);

    case XTYP_EXECUTE:
        /*
         * Another instance wants us to do something.  DdeAccessData()
         * makes parsing of execute strings easy.  Also note, that DDEML
         * will automatically give us the string in the right form
         * (UNICODE vs ASCII) depending on which form of DdeInitialize()
         * we called.
         */
        pszExec = DdeAccessData(hData, NULL);
	if (pszExec) {

#ifdef WIN16
	    if (fActive && !_fstricmp((LPSTR)"PAUSE", pszExec)) {
#else
	    if (fActive && !stricmp((LPSTR)"PAUSE", pszExec)) {
#endif
                KillTimer(hwndMain, 1);
                fActive = FALSE;
                InvalidateRect(hwndMain, NULL, TRUE);
		UpdateWindow(hwndMain);
#ifdef WIN16
	    } else if (!fActive && !_fstricmp((LPSTR)"RESUME", pszExec)) {
#else
	    } else if (!fActive && !stricmp((LPSTR)"RESUME", pszExec)) {
#endif
                SetTimer(hwndMain, 1, BASE_TIMEOUT + (rand() & 0xff), NULL);
                fActive = TRUE;
                InvalidateRect(hwndMain, NULL, TRUE);
                UpdateWindow(hwndMain);
            }
            /*
             * The beep gives good feedback on how fast the execute was.
             */
            MessageBeep(0);
        }
        break;

    case XTYP_DISCONNECT:
        /*
         * Somebody went away, repaint so we update our cConvs count.
         */
        InvalidateRect(hwndMain, NULL, TRUE);
        break;

    case XTYP_REGISTER:
        /*
         * Since a new server just arrived, lets make sure our links are
         * up to date.  Note that only one link on a
         * conversation/topic/item/format set will work anyway so we don't
         * worry about duplicate links.
         *
         * Note also that we are using hszItem - which is the InstanceSpecific
         * name of the server that is registering.  This greatly reduces the
         * number of messages that go flying around.
         */
        hConvList = DdeConnectList(idInst, hszItem, hszAppName, hConvList, NULL);
        BroadcastTransaction(NULL, 0, OurFormat, XTYP_ADVSTART);
        SetWindowPos(hwndMain, 0, 0, 0, cxText,
                (cyText * (cConvs + 1)) + cyTitle, SWP_NOMOVE | SWP_NOZORDER);
        UpdateWindow(hwndMain);
        return(TRUE);
    }
    return(0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ddeml\tests\src\server\huge.c ===
/***************************************************************************
 *                                                                         *
 *  MODULE      : huge.c                                                   *
 *                                                                         *
 *  PURPOSE     : This contains functions useful for generating and        *
 *                verifying huge text data blocks.                         *
 *                                                                         *
 ***************************************************************************/

#include <string.h>
#include <stdio.h>
#include <windows.h>
#include <port1632.h>
#include <ddeml.h>
#include "huge.h"

extern DWORD idInst;
#define BUFSZ   435

LONG lseed, lmult, ladd;
CHAR szT[BUFSZ];

VOID SetMyRand(LONG seed, LONG mult, LONG add);
CHAR MyRand(VOID);
BOOL RandTest(LONG length, LONG seed, LONG mult, LONG add);

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SetMyRand()                                                *
 *                                                                          *
 *  PURPOSE    : Transfers random sequence generation variables to globals. *
 *                                                                          *
 ****************************************************************************/
VOID SetMyRand(
LONG seed,
LONG mult,
LONG add)
{
    lseed = seed;
    lmult = mult;
    ladd = add;
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MyRand()                                                   *
 *                                                                          *
 *  PURPOSE    : Generates the next random character in a sequence.         *
 *                                                                          *
 *  RETURNS    : the character generated                                    *
 *                                                                          *
 ****************************************************************************/
CHAR MyRand()
{
    CHAR c;
    
    lseed = lseed * lmult + ladd;
    c = (CHAR)(LOWORD(lseed) ^ HIWORD(lseed));
    return((CHAR)((c & (CHAR)0x4f) + ' '));   // 0x20 - 0x6f - all printable
}


/*
 * This function allocates and fills a HUGE data handle with a verifiable
 * text string.
 *
 * The format of the text string is:
 * "<length>=<seed>*<mult>+<add>;---data of length <length>---\0"
 * all values are stored in base 16 numbers.
 */
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CreateHugeDataHandle()                                     *
 *                                                                          *
 *  PURPOSE    : Generates a huge pseudo-random sequence of printable       *
 *               characters of the length given and places then into        *
 *               a DDEML data handle.                                       *
 *                                                                          *
 *  RETURNS    : The data handle created or 0 on failure.                   *
 *                                                                          *
 ****************************************************************************/
HDDEDATA CreateHugeDataHandle(
LONG length,
LONG seed,
LONG mult,
LONG add,
HSZ hszItem,
WORD wFmt,
WORD afCmd)
{
    register WORD cb;
    HDDEDATA hData;
    DWORD cbData;
    CHAR *psz;

    wsprintf(szT, "%ld=%ld*%ld+%ld;", length, seed, mult, add);
    cb = strlen(szT);
    hData = DdeCreateDataHandle(idInst, szT, cb + 1, 0, hszItem, wFmt, afCmd);
    if (hData) 
        hData = DdeAddData(hData, NULL, 0, cb + length + 1);
    cbData = cb;
    SetMyRand(seed, mult, add);
    while (hData && (length > 0)) {
        psz = szT;
        cb = BUFSZ;
        while (cb--) 
            *psz++ = MyRand();
        hData = DdeAddData(hData, szT, min(length, BUFSZ), cbData);
        cbData += BUFSZ;
        length -= BUFSZ;
    }
    return(hData);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CheckHugeData()                                            *
 *                                                                          *
 *  PURPOSE    : Verifies the correctness of a pseudo-random character      *
 *               sequence generated by CreateHugeData.                      *
 *                                                                          *
 *  RETURNS    : TRUE if verified ok, FALSE otherwise.                      *
 *                                                                          *
 ****************************************************************************/
BOOL CheckHugeData(
HDDEDATA hData)
{
    LONG length;
    LONG seed;
    LONG mult;
    LONG add;
    CHAR *psz;
    DWORD cbOff;
    WORD cb;
    
    if (!DdeGetData(hData, szT, BUFSZ, 0))
        return(FALSE);
    szT[BUFSZ - 1] = '\0';
    psz = strchr(szT, ';');
    if (psz == NULL) 
        return(FALSE);
    *psz = '\0';
        
    if (sscanf(szT, "%ld=%ld*%ld+%ld", &length, &seed, &mult, &add) != 4)
        return(FALSE);

    if (length < 0)
        return(FALSE);
    SetMyRand(seed, mult, add);        
    cbOff = strlen(szT) + 1;
    while (length > 0) {
        DdeGetData(hData, szT, BUFSZ, cbOff);
        psz = szT;
        cb = BUFSZ;
        while (length-- && cb--) 
            if (*psz++ != MyRand())
                return(FALSE);
        cbOff += BUFSZ;
        length -= BUFSZ;
    }
    return(TRUE);
}

#if 0
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : RandTest()                                                 *
 *                                                                          *
 *  PURPOSE    : Verifies the correctness of CreateHugeDataHandle() and     *
 *               CheckHugeData().                                           *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
BOOL RandTest(
LONG length,
LONG seed,
LONG mult,
LONG add)
{
    HDDEDATA hData;
    BOOL fSuccess;

    hData = CreateHugeDataHandle(length, seed, mult, add, 0, 1, 0);
    if (!hData)
        return(FALSE);
    fSuccess = CheckHugeData(hData);
    DdeFreeDataHandle(hData);
    return(fSuccess);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ddeml\tests\src\server\server.h ===
#include <windows.h>
#include <port1632.h>
#include <ddeml.h>

#define IDM_ABOUT 100
#define IDM_BLOCKALLCBS 200
#define IDM_ENABLEONECB 201
#define IDM_BLOCKNEXTCB 202
#define IDM_TERMNEXTCB  203
#define IDM_RUNAWAY     204
#define IDM_CHANGEDATA  205
#define IDM_RENDERDELAY 206
#define IDM_SETTOPIC    207
#define IDM_SETSERVER   208
#define IDM_UNBLOCKALLCBS 209
#define IDM_HELP        210
#define IDM_CONTEXT     211
#define IDM_APPOWNED    212

#define IDS_BADLENGTH   1

#define MAX_TOPIC       20
#define MAX_COMMENT     40
#define MAX_EXEC        40
#define CCHARS          80
#define CLINES          40

#define UM_CHGDATA      (WM_USER + 435)

#define CSYSTEMITEMS 4
#define CTESTITEMS  4
#define CTOPICS     2

#include "dialog.h"

/****** Structrues ******/

// predefined format list item

typedef struct {
    ATOM atom;
    PSTR sz;
} FORMATINFO;
#define CFORMATS 3

extern FORMATINFO aFormats[];

typedef struct _XFERINFO {
    WORD wType;
    WORD wFmt;
    HCONV hConv;
    HSZ hszTopic;
    HSZ hszItem;
    HDDEDATA hData;
    DWORD lData1;
    DWORD lData2;
} XFERINFO;
typedef XFERINFO *PXFERINFO;

typedef struct _ITEMLIST {
    HSZ hszItem;
    HDDEDATA (*npfnCallback)(PXFERINFO, WORD);
    PSTR pszItem;
} ITEMLIST;

typedef struct _TOPICLIST {
    HSZ hszTopic;
    ITEMLIST *pItemList;
    WORD cItems;
    PSTR pszTopic;
} TOPICLIST;

typedef struct {    // used to passinfo to/from TextDataEntryDlgProc and
    HDDEDATA hDdeData;
    WORD wFmt;
    HSZ hszItem;
} XACT;



// GLOBALS

extern DWORD idInst;
extern CONVCONTEXT CCFilter;
extern HANDLE hInst;
extern HWND hwndServer;
extern RECT rcRand;
extern RECT rcCount;
extern RECT rcComment;
extern RECT rcExec;
extern RECT rcConnCount;
extern RECT rcRndrDelay;
extern RECT rcRunaway;
extern RECT rcAllBlock;
extern RECT rcNextAction;
extern RECT rcHugeSize;
extern RECT rcAppowned;
extern BOOL fAllBlocked;
extern BOOL fAllEnabled;
extern BOOL fEnableOneCB;
extern BOOL fBlockNextCB;
extern BOOL fTermNextCB;
extern BOOL fAppowned;
extern WORD cRunaway;
extern WORD RenderDelay;
extern DWORD count;
extern HSZ hszAppName;
extern CHAR szClass[];
extern CHAR szTopic[MAX_TOPIC];
extern CHAR szServer[MAX_TOPIC];
extern CHAR szComment[MAX_COMMENT];
extern CHAR szExec[MAX_EXEC];
extern CHAR *pszComment;
extern WORD seed;
extern WORD cyText;
extern WORD cServers;
extern HDDEDATA hDataHelp[CFORMATS];
extern HDDEDATA hDataCount[CFORMATS];
extern HDDEDATA hDataRand[CFORMATS];
extern HDDEDATA hDataHuge[CFORMATS];
extern DWORD cbHuge;

extern CHAR szDdeHelp[];
extern FORMATINFO aFormats[CFORMATS];
extern ITEMLIST SystemTopicItemList[CSYSTEMITEMS];
extern ITEMLIST TestTopicItemList[CTESTITEMS];
extern TOPICLIST topicList[CTOPICS];


// FUNCTIONS


BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, INT);
INT FAR DoDialog(LPSTR lpTemplateName, FARPROC lpDlgProc, DWORD param, BOOL fRememberFocus);
LONG  APIENTRY MainWndProc(HWND, UINT, WPARAM, LONG);
BOOL  APIENTRY About(HWND, UINT, WPARAM, LONG);
BOOL  APIENTRY RenderDelayDlgProc(HWND, UINT, WPARAM, LONG);
BOOL  APIENTRY SetTopicDlgProc(HWND, UINT, WPARAM, LONG);
BOOL  APIENTRY SetServerDlgProc(HWND, UINT, WPARAM, LONG);
BOOL  APIENTRY ContextDlgProc(HWND, UINT, WPARAM, LONG);
VOID PaintServer(HWND hwnd);
VOID DrawTextLine(HDC hdc, RECT *prcClip, RECT *prcText, PSTR psz);
HDDEDATA CALLBACK DdeCallback(WORD wType, WORD wFmt, HCONV hConv, HSZ hszTopic,
        HSZ hszItem, HDDEDATA hData, DWORD lData1, DWORD lData2);
HDDEDATA TopicListXfer(PXFERINFO pXferInfo, WORD iFmt);
HDDEDATA ItemListXfer(PXFERINFO pXferInfo, WORD iFmt);
HDDEDATA sysFormatsXfer(PXFERINFO pXferInfo, WORD iFmt);
HDDEDATA TestRandomXfer(PXFERINFO pXferInfo, WORD iFmt);
HDDEDATA TestCountXfer(PXFERINFO pXferInfo, WORD iFmt);
HDDEDATA TestHugeXfer(PXFERINFO pXferInfo, WORD iFmt);
HDDEDATA HelpXfer(PXFERINFO pXferInfo, WORD iFmt);
VOID Hszize(VOID);
VOID UnHszize(VOID);
VOID Delay(DWORD delay, BOOL fModal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\bimodint.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	BIMODINT.INC - Bimodal Interrupt Handler Equates and Structures
;
;   Version:	1.00
;
;   Date:	14-Nov-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   14-Nov-1990 RAL Original
;
;==============================================================================

Bimodal_Int_Struc	STRUC
BIS_IRQ_Number		dw	?
BIS_VM_ID		dw	0
BIS_Next		dd	?
BIS_Reserved1		dd	?
BIS_Reserved2		dd	?
BIS_Reserved3		dd	?
BIS_Reserved4		dd	?
BIS_Flags		dd	0
BIS_Mode		dw	0
BIS_Entry		dw	?
BIS_Control_Proc	dw	?
			dw	?
BIS_User_Mode_API	dd	?
BIS_Super_Mode_API	dd	?
BIS_User_Mode_CS	dw	?
BIS_User_Mode_DS	dw	?
BIS_Super_Mode_CS	dw	?
BIS_Super_Mode_DS	dw	?
BIS_Descriptor_Count	dw	?
Bimodal_Int_Struc	ENDS

BIS_Sel_Table	equ word ptr (SIZE Bimodal_Int_Struc)


EBIS_Sel_Struc STRUC
EBIS_User_Mode_Sel  dw	?
		    dw	?
EBIS_Super_Mode_Sel dw	?
EBIS_Sel_Struc ENDS


.errnz BIS_Super_Mode_API-BIS_User_Mode_API-4
.errnz BIS_Super_Mode_CS-BIS_User_Mode_CS-4
.errnz BIS_Super_Mode_DS-BIS_User_Mode_DS-4
.errnz EBIS_Super_Mode_Sel-EBIS_User_Mode_Sel-4


VPICD_API_Get_Ver	EQU	0000h
VPICD_Install_Handler	EQU	0001h
VPICD_Remove_Handler	EQU	0002h
VPICD_Call_At_Ring0	EQU	0003h


BIH_API_EOI		EQU	0000h
BIH_API_Mask		EQU	0001h
BIH_API_Unmask		EQU	0002h
BIH_API_Get_Mask	EQU	0003h
BIH_API_Get_IRR 	EQU	0004h
BIH_API_Get_ISR 	EQU	0005h
BIH_API_Call_Back	EQU	0006h


Declare_PM_BIS MACRO IRQn,CtrlP,ISRoff,APIoff,ISRcs,ISRds
LOCAL strt
strt label byte
	dw  IRQn	; BIS_IRQ_Number
	dw  0		; BIS_VM_ID
	dd  6 DUP(0)	; BIS_Next/BIS_Reserved1-BIS_Reserved4/BIS_Flags
	dw  0		; BIS_Mode
	dw  ISRoff	; BIS_Entry
	dw  CtrlP	; BIS_Control_Proc
	dw  0		; filler
	dw  APIoff	; BIS_User_Mode_API
	dw  ISRcs
	dd  0		; BIS_Super_Mode_API
	dw  ISRcs	; BIS_User_Mode_CS
	dw  ISRds	; BIS_User_Mode_DS
	dw  0		; BIS_Super_Mode_CS
	dw  0		; BIS_Super_Mode_DS
	dw  0		; BIS_Descriptor_Count
.errnz $-strt - (SIZE Bimodal_Int_Struc)
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\comdevi.h ===
/*************************************************************************
**
** qdb
** que definition block.
**
*************************************************************************/
typedef struct {
    char far    *pqRx;                  /* pointer to rx queue          */
    short       cbqRx;                  /* size of RX Queue in bytes    */
    char far    *pqTx;                  /* Pointer to TX Queue          */
    short       cbqTx;                  /* Size of TX Queue in bytes    */
    } qdb;

ushort  far pascal      inicom(DCB far *);
ushort  far pascal      setcom(DCB far *);
void    far pascal      setque();
int     far pascal      reccom();
ushort  far pascal      sndcom();
ushort  far pascal      ctx();
short   far pascal      trmcom();
ushort  far pascal      stacom();
ushort  far pascal      cextfcn();
ushort  far pascal      cflush();
ushort  far *far pascal cevt();
ushort  far pascal      cevtGet();
int     far pascal      csetbrk();
int     far pascal      cclrbrk();
DCB     far *far pascal getdcb();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\comdev.inc ===
;=========================================================================
; Communications Device Driver Definitions  -  September, 1985
;=========================================================================

.xcref

WIN31 = 1
; remove unneeded things in Windows.inc
NOGDICAPMASKS = 1
NOVK	      = 1
NOWH	      = 1
NOMST	      = 1
NORASTOPS     = 1
NOMETAFILE    = 1
NOMDI	      = 1
NOWINMESSAGES = 1
NOSYSMETRICS  = 1
NOCOLOR       = 1
include windows.inc

DCBSize 	equ	SIZE DCB
DCB_Flags	equ	byte ptr DCB_BitMask1
DCB_Flags2	equ	byte ptr DCB_BitMask2

LPTx            equ     10000000b       ;Flags an ID as being an LPT port


; DCB_BitMask1 (DCB_Flags) equates

fBinary         equ     00000001b       ;Binary mode
fRTSDisable     equ     00000010b       ;Disable RTS
fParity         equ     00000100b       ;Perform Parity Checking
fOutXCTSFlow    equ     00001000b       ;Output handshaking using CTS
fOutXDSRFlow    equ     00010000b       ;Output handshaking using DSR
fEnqAck         equ     00100000b       ;ENQ/ACK software handshaking [rkh] ...
fEtxAck         equ     01000000b       ;ETX/ACK software handshaking
fDTRDisable     equ     10000000b       ;Disable DTR


; DCB_BitMask2 (DCB_Flags2) equates

fOutX           equ     00000001b       ;Output X-ON/X-OFF
fInX            equ     00000010b       ;Input X-ON/X-OFF
fPErrChar       equ     00000100b       ;Parity Error Replacement char active
fNullStrip      equ     00001000b       ;Null Stripping
fCharEvent      equ     00010000b       ;Character event
fDTRFlow        equ     00100000b       ;Input handshaking using DTR
fRTSFlow        equ     01000000b       ;Input handshaking using RTS
;               equ     10000000b


; Values for RLSTimeout, CTSTimeout, DSRTimeout

Ignore          equ     0
Infinite        equ     0FFFFh


; COMS_BitMask1 equates

fCTSHold        equ     00000001b       ;Tx is on CTS hold
fDSRHold        equ     00000010b       ;Tx is on DSR hold
fRLSDHold       equ     00000100b       ;Tx is on RLSD hold
fXOFFHold       equ     00001000b       ;Received an X-OFF
fXOFFSent       equ     00010000b       ;Sent an X-OFF
fEOF            equ     00100000b       ;Received defined EOF character
fTxImmed        equ     01000000b       ;There's a char to transmit immediate
;               equ     10000000b



;       Event mask definitions.  Used by SetCommEventMask and GetCommEventMask
;
;       RXCHAR  - Set when any character is received and placed in the input
;                 queue.
;       RXFLAG  - Set when a particular character, as defined in the DCB,
;                 is received and placed in the input queue.
;       TXEMPTY - Set when the last character in the transmit queue is
;                 transmitted.
;       CTS     - Set when the CTS signal changes state.
;       DSR     - Set when the DSR signal changes state.
;       RLSD    - Set when the RLSD signal changes state.
;       BREAK   - Set when a break is detected on input.
;       RING    - Set when Ring Indicator is detected
;       ERR     - Set when a line status error occurs.


;=========================================================================
;
;       qdb
;       Queue definition block. Passed to setqueue, defines the location and
;       size of the transmit and receive circular queue's used for interrupt
;       transmit and recieve processing.
;
;=========================================================================

QDB struc
  QueueRxAddr   dd      ?               ;Pointer to RX Queue, Offset
  QueueRxSize   dw      ?               ;Size of RX Queue in bytes
  QueueTxAddr   dd      ?               ;Pointer to TX Queue, Offset
  QueueTxSize   dw      ?               ;Size of TX Queue in bytes
QDB ends

.cref
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\commmsg.asm ===
.xlist
include cmacros.inc
.list


sBegin	 Data

PUBLIC szMessage, pLPTByte
PUBLIC szCOMMessage, pCOMByte
PUBLIC _szTitle

szMessage   db 'The LPT'
pLPTByte    db '?'
	    db ' port is currently assigned to a DOS application.  Do you '
	    db 'want to reassign the port to Windows?',0
szCOMMessage db 'The COM'
pCOMByte    db '?'
	    db ' port is currently assigned to a DOS application.  Do you '
	    db 'want to reassign the port to Windows?',0
_szTitle    db 'Device Conflict',0

PUBLIC lpCommBase, CommBaseX
lpCommBase  db 'COM'
CommBaseX   db ?
	    db 'BASE', 0

PUBLIC lpCommIrq, CommIrqX
lpCommIrq   db 'COM'
CommIrqX    db ?
	    db 'IRQ', 0

PUBLIC lpCommFifo, CommFifoX
lpCommFifo  db 'COM'
CommFifoX   db ?
	    db 'FIFO', 0

PUBLIC lpCommDSR, CommDSRx
lpCommDSR   db 'COM'
CommDSRx    db ?
	    db 'FORCEDSR', 0

PUBLIC lpCommSection, lpSYSTEMINI

lpCommSection	db '386ENH', 0
lpSYSTEMINI	db 'SYSTEM.INI', 0

	ALIGN 2

sEnd Data

End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\ibmcom.asm ===
page,132
;---------------------------Module-Header-------------------------------;
; Module Name: IBMCOM.ASM
;
; !!!
;
; Created: Fri 06-Feb-1987 10:45:12
; Author:  Walt Moore [waltm]
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; General Description:
;
; History:
;
;   ***************************************************************
;	Tue Dec 19 1989 09:32:15   -by-  Amit Chatterjee [amitc]
;   ---------------------------------------------------------------
;   Modified the 'InitAPort' routine called from 'ReactivateOpenCommPort'.
;   If the out queue for a port has characters to send out then we must
;   restart the trasmission process by faking a comm interrupt on that
;   port.
;   ***************************************************************
;	Tue Nov 21 1989 09:46:50    -by- Amit Chatterjee [amitc]
;   ---------------------------------------------------------------
;   The base port addresses in the COMM1,COMM2,COMM3,COMM4 structures
;   are being zeroed out when the corresponding comm port is closed.
;   This is because the  'ReactivateOpenCommPort' function looks at it
;   and if the port address is not zero decides that comm ports are
;   open. 
;   ***************************************************************
;	Tue Nov 14 1989 18:42:00     ADDED TWO EXPORTED FUNCTIONS
;   ---------------------------------------------------------------
;   Added two exported functions 'SuspendOpenCommPorts' and 
;   'ReactivateOpenCommPorts' for 286 winoldap support. The first one simply 
;   releases the comm int vects and installs the originall one, the second one
;   hooks back the comm driver comm vectors and then reads the receive buffer,
;   the status and the IIR registers of all the available comm ports to 
;   remove pending interrupts. It also reprograms the PIC to enable interrupts
;   on all open comm channels.
;   ---------------------------------------------------------------
;   -by- Amit Chatterjee [amitc]    
;   ***************************************************************
;	Tue Aug 30 198? 12:52:00      MAJOR FIX TO HANDLE 8250B
;   ---------------------------------------------------------------
;   
;   8250B has the following peculiar charactersistic
;             . The very first time (after reset) the Tx Holding Empty
;               interrupt is enabled, an immediate interrupt is generated
;
;             . After the first time, switching the Tx Holding Empty
;               interrupt enable bit from disabled to enabled will NOT
;               generate an immediate interrupt (unlike in 8250)
;       Because of this the KICKTX routine fails to set the transmit cycle
;       on if the machine has a 8250B
;   
;       This has been taken care as follows:
;             . For the very first byte that is being transmitted, KICKTX
;               is used to generate the first Tx Holding Empty interrupt
;             . Subsequently, whenever we find that the transmit buffer
;		is empty, we use a SOFTWARE INT (either INT 0Bh, or INT 0Ch)
;               to force the first character out, once this is done the
;               Tx Holding Empty interrupt will be generated once the buffer
;               really is empty
;             . Now we no longer disable the Tx Holding Empty interrupt
;               in the Xmit ISR to ensure that even m/cs with 8250, use
;               the software int to kick the tx interrupt on after the
;               first time.
;             . The software interrupt is also forced whenever an X-ON 
;               character is received.   
;
;       The code that implements the above logic is marked out with a line
;       asterixes.   
;   ------------------------------------------------------------------
;   -by- Amit Chatterjee [amitc]    
;       ******************************************************************
;
;   062587   HSFlag and Evtmask in DoLPT.  These fields do not exist
;      for LPT type devices.  The code which manipulated them
;      was removed
;
;      KickTx from $SndCom - interrupts were not disabled when
;      calling KickTx.
;
;      $SetCom - added CLD at the start
;
;      $SetQue - movsw ==> stosw
;
;       111285  Changed the Timeout from 7 to 30 seconds.
;
;       110885  Forgot to set EV_RxChar event when a character
;               was received.
;
;       102985  INS8250, INS8250B bug with enabling interrupts.
;               Setting ACE_ETBEI in the Interrupt Enable Register
;               will cause an immediate interrupt regardless of
;               whether the transmitter register is empty or not.
;               The first interrupt MAY also be missed.
;
;               The first case is not a problem since we only enable
;               interrupts if the transmitter register is empty.  The
;               second problem was showing up on Microsoft System Cards
;               in PC-XTs.  The first interrupt was missed after a cold
;               boot.  National claims the fix is to write the register
;               twice, which SEEMS to work...
;
;               Added timeout code to $TRMCOM.  If the number of
;               characters in the output queue doesn't decrease
;               in "Timeout" seconds, then the port will be closed
;               anyway.  Also flushed the input queue and added a
;               discard-input flag for the data available interrupt
;               code to discard any input received while terminating
;               a port.  $TRMCOM will return an error code if it
;               discarded any output data.
;
;               Removed infinite timeout test in MSRWait routine.
;               Still bad, but it will timeout around 65 seconds
;               instead of never.
;
;       102785  LPT initialization code was jumping to InitCom90,
;               which was setting EFlags[si] to null.  Well, LPTs
;               don't have an EFlags field, so the null was getting
;               stuffed over the LSB of BIOSPortLoc of the next LPT
;               device.
;
;       101185  Save interrupt vector when opening a comm port
;               and restore it when closing.  Would you believe
;               there are actually programs that assume the
;               vector points to a non-specific 8259 ACK and
;               an IRET!
;
;       100985  Added MS-NET support to gain exclusive control
;               of an LPT port if DOS 3.x and not running in as
;               a server, receiver, or messenger.   Required to
;               keep another application, such as command.com
;               from closing the stream or mixing their output
;               with ours.
;       sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;               FCLI/FSTI macros
;-----------------------------------------------------------------------;

title   IBMCom - IBM PC, PC-XT, PC-AT, PS/2 Communications Interface

.xlist
include cmacros.inc
include comdev.inc
include ins8250.inc
include ibmcom.inc
include vint.inc
.list

externNP GetDEB
externNP DoLPT
externNP StringToLPT
externNP FindCOMPort
externNP StealPort


sBegin	 Data

externB  $MachineID

sEnd Data

sBegin Code
assumes cs,Code
assumes ds,Data

page

;----------------------------Public Routine-----------------------------;
;
; $RECCOM - Receive Characters From Device
;
; Read Byte From RS232 Input Queue If Data Is Ready
;
; LPT ports will return with an indication that no characters are
; available.
;
; Entry:
;   AH = Device ID
; Returns:
;   'Z' clear if data available
;   AL = byte
; Error Returns:
;   'Z' Set if error or no data
;   AX = error code
;   AX = 0 if no data
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $RECCOM
$RECCOM proc   near

	push	si			;Once again, save some registers
	push	di
	call	GetDEB			;Get DEB pointer in SI
	jc	RecCom10		;Invalid Port [rkh] ...
	jns	RecCom20		;COM port
	jmp	RecCom95		;LPT port, return no characters

RecCom10:
	jmp	RecCom100		; Invalid Port

; Before removing any charcters from the input queue, check to see
; if XON needs to be issued.  If it needs to be issued, set the
; flag that will force it and arm transmit interrupts.

RecCom20:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	RecCom32		;  No
	test	HSFlag[si],EnqReceived+HHSDropped ;Enq recvd or lines dropped?
        jnz      RecCom21                ;  No Enq recvd & no lines dropped
        jmp      RecCom60                ;  No Enq recvd & no lines dropped
RecCom21:
	jmp	short RecCom34

RecCom32:
	test	HSFlag[si],HSSent	;Handshake sent?
        jnz     RecCom33                ;  No XOFF sent & no lines dropped
        jmp     RecCom60                ;  No XOFF sent & no lines dropped
RecCom33:

RecCom34:
	mov	ax,QInCount[si] 	;Get current count of input chars
	cmp	ax,[si.DCB_XonLim]	;See if at XOn limit
	ja	RecCom60		;Not at XOn limit yet

; If any hardware lines are down, then raise them.  Then see
; about sending XON.

	mov	dx,Port[si]		;Get the port
	mov	ah,HHSLines[si] 	;Get hardware lines mask
        call DOCLI                             ;Handle this as a critical section
	mov	cl,HSFlag[si]		;Get handshaking flags
	or	ah,ah			;Any hardware lines to play with?
	jz	RecCom40		;  No
	add	dl,ACE_MCR		;--> Modem control register
	in	al,dx
	or	al,ah			;Turn on the hardware bits
	iodelay
	out	dx,al
	and	cl,NOT HHSDropped	;Show hardware lines back up

RecCom40:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	RecCom47		;  No
	test	cl,EnqReceived		;Did we receive Enq?
	jz	RecCom55		;  No
	and	cl,NOT EnqReceived
	jmp	short RecCom50

RecCom47:
	test	cl,XOffSent		;Did we send XOFF?
	jz	RecCom55		;  No
	and	cl,NOT XOffSent 	;Remove XOFF sent flag

RecCom50:
	or	cl,XOnPending		;Show XON or ACK must be sent
	call	KickTx			;Kick xmit if needed

RecCom55:
	mov	HSFlag[si],cl		;Store handshake flag
        call DOSTI                             ;Can allow interrupts now

; Now we can get down to the business at hand, and remove a character
; from the receive queue.  If a communications error exists, we return
; that, and nothing else.

RecCom60:
	xor	ax,ax
	or	ax,ComErr[si]		;Any Errors?
	jnz	RecCom100		;  Yes, return the error code
	or	ax,QInCount[si] 	;Get current input char count
	jz	RecCom90		;No characters in the queue
	les	di,QInAddr[si]		;Get queue pointer
	assumes es,nothing

	mov	bx,QInGet[si]		;Also get the index to head
	mov	al,es:[bx][di]		;Finally, get byte from queue
	inc	bx			;Update queue index
	cmp	bx,QInSize[si]		;See if time for wrap-around
	jc	RecCom70		;Jump if no wrap
	xor	bx,bx			;wrap by zeroing the index

RecCom70:
	mov	QInGet[si],bx		;Save new head pointer
	dec	QInCount[si]		;Dec # of bytes in queue

	mov	cx, [si.QinCount]
	cmp	cx, [si.RecvTrigger]	;Q: have we read below trigger?
	jae	RecCom80		;   N:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE ; allow timeout notify again
RecCom80:
	or	sp,sp			;Reset PSW.Z
	pop	di
	pop	si
	ret

; No characters in the input queue.  Check to see if EOF
; was received, and return it if it was.  Otherwise show
; no characters.

RecCom90:
	test	[si.DCB_Flags],fBinary	;Are we doing binary stuff?
	jnz	RecCom95		;  Yes, show no characters
	mov	al,[si.DCB_EofChar]	;Assume EOF
	test	EFlags[si],fEOF 	;Has end of file char been received?
	jnz	RecCom80		;  Yes, show end of file

RecCom95:
	xor	ax,ax			;Show no more characters

; Return with 'Z' to show error or no characters

RecCom100:
	xor	cx,cx			;Set PSW.Z
	pop	di
	pop	si
	ret

$RECCOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $RECSTR - Receive Characters From Device
;
; Read Byte From RS232 Input Queue If Data Is Ready
;
; LPT ports will return with an indication that no characters are
; available.
;
; Entry:
;   AH = Device ID
;   ES:DI -> receive buffer
;   CX max bytes to read
; Returns:
;   'Z' clear if data available
;   AX = # of bytes read
; Error Returns:
;   'Z' Set if error or no data
;   AX = error code
;   AX = 0 if no data
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	 $RECSTR
$RECSTR proc   near

	push	si			;Once again, save some registers
	push	di
	call	GetDEB			;Get DEB pointer in SI
	jc	RecStr10		;Invalid Port [rkh] ...
	jns	RecStr20		;COM port
	jmp	RecStr95		;LPT port, return no characters

RecStr10:
	jmp	RecStr100		; Invalid Port
RecStr15:
	jmp	RecStr90

RecStr20:
	xor	ax,ax
	or	ax,ComErr[si]		;Any Errors?
	jnz	RecStr10		;  Yes, return the error code
	or	ax,QInCount[si] 	;Get current input char count
	jz	RecStr15		;No characters in the queue

	cmp	cx, ax			;Q: more chars available than can read?
	jbe	short RecStr30		;   N:
	mov	cx, ax			;   Y: adjust # of chars to read
RecStr30:
	push	cx
	mov	dx, QInSize[si]
	mov	ax, QInGet[si]
	sub	dx, ax			; dx = # of bytes before end of buf
	cmp	dx, cx			;Q: more avail than can read?
	jbe	short RecStr40		;   N:
	mov	dx, cx			;   Y: adjust avail count
RecStr40:
	xchg	cx, dx			; cx = # of bytes for 1st copy
	sub	dx, cx			; dx = # of bytes for 2nd copy

	push	ds
	push	si
	lds	bx, QInAddr[si]
	mov	si, bx
	add	si, ax			; ds:si -> first char in buffer
	cld
	rep	movsb			; do first copy
	mov	cx, dx
	jcxz	short RecStr50		; jump if no 2nd copy needed
	mov	si, bx			; ds:si -> start of buffer
	rep	movsb			; do 2nd copy
RecStr50:
	sub	si, bx			; si = new QInGet
	mov	bx, si
	pop	si
	pop	ds
	pop	cx
        call DOCLI
	mov	QInGet[si], bx		; update QInGet
	sub	QInCount[si], cx	; update count
	mov	ax, QInCount[si]
        call DOSTI

	cmp	ax, [si.RecvTrigger]	;Q: have we read below trigger?
	jae	@F			;   N:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE ; allow timeout notify again
@@:

; Check to see if XON needs to be issued.  If it needs to be issued, set the
; flag that will force it and arm transmit interrupts.

	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	@F			;  No
	test	HSFlag[si],EnqReceived+HHSDropped ;Enq recvd or lines dropped?
        jnz     RecStr58                ;  No Enq recvd & no lines dropped
        jmp     RecStr80                ;  No Enq recvd & no lines dropped
RecStr58:
	jmp	short RecStr60

@@:
	test	HSFlag[si],HSSent	;Handshake sent?
        jnz     RecStr59                ;  No XOFF sent & no lines dropped
        jmp     RecStr80                ;  No XOFF sent & no lines dropped
RecStr59:

RecStr60:
					;ax = current count of input chars
	cmp	ax,[si.DCB_XonLim]	;See if at XOn limit
	ja	RecStr80		;Not at XOn limit yet

;;	  int 1
; If any hardware lines are down, then raise them.  Then see
; about sending XON.

	mov	dx,Port[si]		;Get the port
	mov	ah,HHSLines[si] 	;Get hardware lines mask
	push	cx
        call DOCLI                             ;Handle this as a critical section
	mov	cl,HSFlag[si]		;Get handshaking flags
	or	ah,ah			;Any hardware lines to play with?
	jz	@F			;  No
	add	dl,ACE_MCR		;--> Modem control register
	in	al,dx
	or	al,ah			;Turn on the hardware bits
	iodelay
	out	dx,al
	and	cl,NOT HHSDropped	;Show hardware lines back up

@@:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	@F			;  No
	test	cl,EnqReceived		;Did we receive Enq?
	jz	RecStr70		;  No
	and	cl,NOT EnqReceived
	jmp	short RecStr65

@@:
	test	cl,XOffSent		;Did we send XOFF?
	jz	RecStr70		;  No
	and	cl,NOT XOffSent 	;Remove XOFF sent flag

RecStr65:
	or	cl,XOnPending		;Show XON or ACK must be sent
	call	KickTx			;Kick xmit if needed

RecStr70:
	mov	HSFlag[si],cl		;Store handshake flag
        call DOSTI                             ;Can allow interrupts now
	pop	cx

RecStr80:
	mov	ax, cx
	or	sp,sp			;Reset PSW.Z
	pop	di
	pop	si
	ret

; No characters in the input queue.  Check to see if EOF
; was received, and return it if it was.  Otherwise show
; no characters.

RecStr90:
	test	[si.DCB_Flags],fBinary	;Are we doing binary stuff?
	jnz	RecStr95		;  Yes, show no characters
	mov	al,[si.DCB_EofChar]	;Assume EOF
	test	EFlags[si],fEOF 	;Has end of file char been received?
	jnz	RecStr80		;  Yes, show end of file

RecStr95:
	xor	ax,ax			;Show no more characters

; Return with 'Z' to show error or no characters

RecStr100:
	xor	cx,cx			;Set PSW.Z
	pop	di
	pop	si
	ret

$RECSTR endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDIMM - Send A Character Immediately
;
; This routine either sends a character to the port immediately,
; or places the character in a special location which is used by
; the next transmit interrupt to transmit the character prior to
; those in the normal transmit queue.
;
; For LPT ports, the character is always sent immediately.
;
; Entry:
;   AH = Device ID
;   AL = Character
; Returns:
;   AX = 0
; Error Returns:
;   AX = 8000H if Bad ID
;   AX = 4000H if couldn't send because another character
;        transmitted "immediately" is waiting to be sent
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;


   assumes ds,Data
   assumes es,nothing

   public   $SNDIMM
$SNDIMM proc   near

        push    si
        call    GetDEB                  ;Get pointer to the DEB
	jc	SendImm20		;Bad ID, return an error
	jns	SendImm10		;Its a COM port


;	For LPT ports, call DoLPT to do the dirty work.  If DoLPT
;       returns an error code, map it to 4000h.

	xor	ch,ch			;Show xmit character
	call	DoLPT			;Do the work here
        or      ax,ax                   ;Error occur?
	jz	SendImm20		;  No, show all is OK
	mov	ax,4000h		;  Yes, return 4000h
	jmp	short SendImm20

SendImm10:
	mov	dl, al
        mov     ax,4000h                ;In case we cannot send
        test    EFlags[si],fTxImmed     ;Another char waiting "immediately"?
	jnz	SendImm20		;  Yes, return error
	mov	ah,dl			;Set char for TXI
        call DOCLI                             ;TXI is critical section code
        call    TXI                     ;Set character to tx immediately
        call DOSTI
        xor     ax,ax                   ;Show all is OK

SendImm20:
        pop     si
        ret

$SNDIMM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDCOM - Send Byte To Port
;
; The given byte is sent to the passed port if possible.
; If the output queue is full, an error will be returned.
;
; Entry:
;   AH = Device ID
;   AL = Character
; Returns:
;   AX = 0
; Error Returns:
;   AX = error code
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $SNDCOM
$SNDCOM  proc  near

	push	si
	push	di
	call	GetDEB			;--> DEB
	jc	SendCom40		;Invalid ID
	jns	SendCom20		;Its a COM port

; Handle the transmission of a LPT character.  The ROM BIOS int 17
; call will be made to do the transmission.  The port address will
; be restored during the call, then zeroed out upon return.

SendCom10:
	xor	ch,ch			;Show xmit character
	call	DoLPT			;Do the work here
	jmp	short SendCom40 	;Return the status to caller

; Send a character to a COM port.  Return an error if control
; line timeout occurs or there is no room in the output queue.

SendCom20:
	push	ax			;Save character

	call	MSRWait 		;See if lines are correct for output
	pop	ax			;Restore char
	jnz	SendCom60		;Timeout occured, return error
	mov	cx,QOutSize[si] 	;See if queue is full
	cmp	cx,QOutCount[si]
	jle	SendCom50		;There is no room in the queue
	les	di,QOutAddr[si] 	;--> output queue
	assumes es,nothing

	mov	bx,QOutPut[si]		;Get index into queue
	mov	es:[bx][di],al		;Store the byte
	inc	bx			;Update index
	cmp	bx,cx			;Wrap time?
	jc	SendCom30		;  No
	xor	bx,bx			;Wrap-around is a new zero pointer

SendCom30:

        call DOCLI
	mov	QOutPut[si],bx		;Store updated pointer
	mov	ax,QOutCount[si]	; get the count
	inc	ax			; have the updated value in AX for test later
	mov	QOutCount[si],ax	;Update queue population
	call	KickTx			;Make sure xmit interrupt is armed
        call DOSTI

	xor	ax,ax			;Show no error (that we know of)

;****************************************************************************

SendCom40:
	pop	di
	pop	si
	ret

SendCom50:
	or	by ComErr+1[si],HIGH CE_TXFULL
	.errnz LOW CE_TXFULL

SendCom60:
	mov	ax,ComErr[si]		;Return error code to caller
	jmp	short SendCom40

$SNDCOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDCOMSTR - Send buffer To Port
;
; The given buffer is sent to the passed port if possible.
; Once the output queue is detected as being full, a CE_TXFULL error
; will be indicated and AX will be returned as the # of chars actually
; queued.
;
; Entry:
;   DS:SI --> DEB
;   ES:DI --> buffer
; Returns:
;   AX = # of bytes queued
; Registers Destroyed:
;   AX,BX,CX,DX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	$SNDCOMSTR
$SNDCOMSTR proc near

	push	cx			; save count
	call	GetDEB
	jc	cws_error		; jump if id invalid
	jns	cws_comm		; jump if COM port

	call	StringToLPT
	pop	cx			; discard saved count, ax = # transfered
	jmp	short cws_exit

cws_error:
	pop	ax
	sub	ax, cx			; ax = # transfered
cws_exit:
	ret

cws_comm:
	call	MSRWait 		;See if lines are correct for output
	pop	cx
	push	cx
	jnz	cws_error		;Timeout occured, return error

	mov	dx, QOutSize[si]	;See if queue is full
        sub     dx, QOutCount[si]       ; dx = # of chars free in queue
        jg      scs_loop
        jmp     scs_full                ;There is no room in the queue

scs_loop:
	push	cx			; save count left to send
	cmp	cx, dx			;Q: room for buffer in queue?
	jbe	@f			;   Y:
	mov	cx, dx			;   N: adjust size to send
@@:
	push	cx			; save # of chars which will be copied
	push	si
	push	ds
	push	di
	push	es
	les	bx,QOutAddr[si] 	;--> output queue
	assumes es,nothing

	mov	dx, QOutSize[si]
	mov	di, QOutPut[si] 	;Get index into queue
	sub	dx, di			; dx = # of free chars before end of queue
	cmp	dx, cx
	jbe	@f
	mov	dx, cx
@@:
	xchg	cx, dx			; cx = # of chars for 1st copy
	sub	dx, cx			; dx = # of chars for 2nd copy
	pop	ds
	pop	si			; ds:si -> src buffer
	assumes ds,nothing
	add	di, bx			; es:di -> current pos in queue
	cld
	rep	movsb			; copy first section
	mov	cx, dx
	jcxz	@F
	mov	di, bx			; circle back to start of queue
	rep	movsb			; copy 2nd section
@@:
	sub	di, bx			; di last index into queue
	mov	dx, di
	mov	di, si			; last location in src buffer
	mov	si, ds
	mov	es, si			; es:di -> last loc in src buf
	pop	ds
	pop	si			; ds:si -> ComDEB
	assumes ds,data
	pop	bx			; # of chars copied
        call DOCLI
	mov	QOutPut[si], dx 	;new index into queue
	add	QOutCount[si], bx
	call	KickTx
        call DOSTI
	pop	cx
	sub	cx, bx			; # of chars left to send
	jnz	scs_full_2		;  jump if none
scs_exit:
	pop	ax
	sub	ax, cx			; ax = # transfered
	ret

scs_full:
        call DOCLI
	call	KickTx
        call DOSTI
scs_full_2:
	or	by ComErr+1[si],HIGH CE_TXFULL
	.errnz LOW CE_TXFULL
	jmp	scs_exit

$SNDCOMSTR endp
page

;----------------------------Public Routine-----------------------------;
;
; $FLUSH - Flush The Input and Output Queues
;
; This is a hard initialization of the transmit and receive queue's,
; which immediately empties the given queue.
;
; LPT ports will just return the device error word
;
; Entry:
;   AH = Device ID
;   BH = Queue # to clear (0=Tx, 1=Rx)
; Returns:
;   AX = Device Error Word. (Not reset)
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $FLUSH
$FLUSH   proc   near

        push    si
        push    di
        call    GetDEB                  ;si --> DEB
        jc      Flush40                 ;Invalid ID
        js      Flush30                 ;LPT port, return any error

        mov     cx,QOutCount-QInCount   ;# of bytes to zero
        lea     di,QInCount[si]         ;--> receive queue data
        or      bh,bh                   ;Transmit queue?
        jnz     Flush10                 ;  No, input queue
        add     di,cx                   ;  Yes, --> xmit queue data

Flush10:
        cld
        push    ds
        pop     es
   assumes es,nothing

        xor     al,al
        call DOCLI                             ;Time to worry about critical sections
        rep     stosb
        call DOSTI
	.errnz	 QInGet-QInCount-2
	.errnz	 QInPut-QInGet-2
	.errnz	 QOutCount-QInPut-2
	.errnz	 QOutGet-QOutCount-2
	.errnz	 QOutPut-QOutGet-2

        or      bh,bh                   ;Rx queue?
        jz      Flush30                 ;  No, xmit queue


;       If the queue to be cleared is the receive queue, any
;       hardware handshake must be cleared to prevent a possible
;       deadlock situation.  Since we just zeroed the queue count,
;       a quick call to $RecCom should do wonders to clear any
;       receive handshake (i.e. send XON if needed).

Flush20:
	call   $RECCOM	     ;Take care of handshakes here

Flush30:
        mov     ax,ComErr[si]           ;And return the error word.

Flush40:
        pop     di
        pop     si
        ret

$FLUSH	 endp
page

;----------------------------Private-Routine----------------------------;
;
; TXI - Transmit A Character Immediately
;
; Set up a character to be transmitted "immediately".
; by placing the character in a location that guarantees
; it to be the next character transmitted.
;
; The check to see if the immediate character can be placed has
; already been made prior to entry.
;
; Interrupts must be disabled before entering this code
;
; Entry:
;   AH = Character
;   DS:SI --> DEB
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   L,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   TXI         ;Public for debugging
TXI   proc   near

;       call DOCLI                             ;Must be done by caller!
	or	EFlags[si],fTxImmed	;Show char to xmit
	mov	ImmedChar[si],ah	;Set character to transmit next
;	jmp	short KickTx		;Kick Xmit just in case
	errn$	KickTx

TXI   endp
page

;----------------------------Private-Routine----------------------------;
;
; KickTx - Kick Transmitter
;
; "Kick" the transmitter interrupt routine into operation.
; If the Transmitter Holding Register isn't empty, then
; nothing needs to be done.  If it is empty, then the xmit
; interrupt needs to enabled in the IER.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	 KickTx 			;Public for debugging
KickTx   proc   near

;       call DOCLI                             ;Done by caller
	test	[si.VCDflags], 1	;Q: we still own port?
	jnz	can_we_steal		;   N:

enable_int:
	mov	dx,Port[si]		;Get device I/O address
	add	dl,ACE_IER		;--> Interrupt enable register
	in	al,dx			;Get current IER state
	test	al,ACE_ETBEI		;Interrupt already enabled?
	jnz	KickTx10		;  Yes, don't reenable it
	or	al,ACE_ETBEI		;  No, enable it
	out	dx,al
	iodelay 			;8250, 8250-B bug requires
	out	dx,al			;  writting register twice

KickTx10:
;       call DOSTI                             ;Done by caller
	ret

can_we_steal:
	call	StealPort		; call VCD to see if we can steal
					;     the port back
	jnc	short enable_int	; jump, if we got it
;
; flush out queue
;
	xor	ax, ax
	mov	[si.QOutCount], ax
	mov	[si.QOutMod], ax
	mov	ax, [si.QOutGet]
	mov	[si.QOutPut], ax
	jmp	short KickTx10		;   N:

KickTx   endp
page

;----------------------------Private-Routine----------------------------;
;
; MSRWait - Modem Status Register Wait
;
; This routine checks the modem status register for CTS, DSR,
; and/or RLSD signals.   If a timeout occurs while checking,
; the appropriate error code will be returned.
;
; This routine will not check for any signal with a corresponding
; time out value of 0 (ignore line).
;
; Entry:
;   SI --> DEB
; Returns:
;   AL = error code
;   ComErr[si] updated
;   'Z' set if no timeout
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   MSRWait	  ;Public for debugging

MSRWait proc   near

        push    di

MSRRestart:
        xor     di,di                   ;Init Timer

MSRWait10:
	mov	cx,11			;Init Delay counter (used on non-ATs)

MSRWait20:
        xor     dh,dh                   ;Init error accumulator
        mov     al,MSRShadow[si]        ;Get Modem Status
        and     al,MSRMask[si]          ;Only leave bits of interest
        xor     al,MSRMask[si]          ;0 = line high
	jz	MSRWait90		;All lines of interest are high
	mov	ah,al			;ah has 1 bits for down lines

        shl     ah,1                    ;Line Signal Detect low?
	jnc	MSRWait30		;  No, it's high
	.errnz	ACE_RLSD-10000000b
	cmp	di,[si.DCB_RlsTimeout]	;RLSD timeout yet?
	jb	MSRWait30		;  No
        or      dh,CE_RLSDTO            ;Show modem status timeout

MSRWait30:
	shl	ah,1			;Data Set Ready low?
	shl	ah,1
	.errnz	ACE_DSR-00100000b
	jnc	MSRWait40		;  No, it's high
	cmp	di,[si.DCB_DsrTimeout]	;DSR timeout yet?
	jb	MSRWait40		;  No
        or      dh,CE_DSRTO             ;Show data set ready timeout

MSRWait40:
	shl	ah,1			;CTS low?
	jnc	MSRWait50		;  No, it's high
	.errnz	ACE_CTS-00010000b
	cmp	di,[si.DCB_CtsTimeout]	;CTS timeout yet?
	jb	MSRWait50		;  No
        or      dh,CE_CTSTO             ;Show clear to send timeout

MSRWait50:
        or      dh,dh                   ;Any timeout occur?
	jnz	MSRWait80		;  Yes

        cmp     [$MachineID],0FCh       ;Is this a PC-AT? [rkh debug for PS/2]
	je	MSRWait60		;  Yes, use ROM function
	loop	MSRWait20		;  No, continue until timeout
        jmp     short MSRWait70         ;Should have taken about a millisecond

MSRWait60:
        push    bx                      ;Special SALMON ROM routine to delay
        push    di
        xor     cx,cx                   ;Number of Microseconds to delay
        mov     dx,1000                 ;  in CX:DX
        mov     ah,86h
        int     15h                     ;Wait 1 millisecond
        pop     di
        pop     bx

MSRWait70:
        inc     di                      ;Timer +1
	jmp	short MSRWait10 	;Until Timeout or Good status

MSRWait80:
        xor     ah,ah
        mov     al,dh
        or      by ComErr[si],al        ;Return updated status
	.errnz	HIGH CE_CTSTO
	.errnz	HIGH CE_DSRTO
	.errnz	HIGH CE_RLSDTO

MSRWait90:
        or      al,al                   ;Set 'Z' if no timeout
        pop     di
        ret

MSRWait endp
page

;----------------------------Public Routine-----------------------------;
;
; $EVT - Set Event Mask
;
; Set up event word and mask.  Returns a pointer to a word in which
; certain bits, as enabled by the mask, will be set when certain
; events occur.
;
; Entry:
;   AH = Device ID
;   BX = Event enable mask
; Returns:
;   DX:AX --> event word.
; Error Returns:
;   AX = 0 if error
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $EVT
$EVT   proc   near

        push    si
        xor     dx,dx                   ;In case of error
        call    GetDEB                  ;Get pointer to DEB
        mov     ax,dx                   ;Finish setting error return value
        jc      Evt10                   ;Illegal id, return error
        js      Evt10                   ;LPTx, return error
        mov     EvtMask[si],bx          ;Save the new event mask
        lea     ax,EvtWord[si]          ;Get address of event word
        mov     dx,ds                   ;  into dx:ax

Evt10:
        pop     si
        ret

$EVT   endp
page

;----------------------------Public Routine-----------------------------;
;
; $EVTGET - Get Event Word
;
; Return and clear fields in the event word.  This routine MUST be used
; by applications to read the event word, as it is the ONLY way they
; can be assured that an event is not lost between reading the flags
; and resetting some.
;
; Entry:
;   AH = Device ID
;   BX = Event clear mask
; Returns:
;   AX = event word
; Error Returns:
;   None
; Registers Preserved:
;   AX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   BX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $EVTGET
$EVTGET proc   near

        push    si
        call    GetDEB
        mov     ah,0                    ;In case of error (AL already 0)
        jc      EvtGet10                ;Illegal ID
        js      EvtGet10                ;Illegal ID
        call DOCLI                             ;No interrupts allowed
        mov     ax,EvtWord[si]          ;Get the current event word
        not     bx                      ;Convert mask for our purposes
        and     bx,ax                   ;Clear events that user wants us to
        mov     EvtWord[si],bx          ;And save those results
        call DOSTI                             ;Magic over

EvtGet10:
        pop     si
        ret

$EVTGET endp
page

;----------------------------Public Routine-----------------------------;
;
; $STACOM - Return Status Information
;
; Returns the number of bytes in both queues.
;
; LPT ports will show both queues empty.
; and resetting some.
;
; Entry:
;   AH    = Device ID
;   ES:BX = Pointer to status structure to be updated.
;         = Null if not to update
; Returns:
;   AX = comm error word
;   Status Structure Updated.
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $STACOM
$STACOM proc   near

	push	si
	call	GetDEB			;Get DEB pointer in SI
	jc	StaCom30		;Invalid ID
	mov	cx,es			;Is the pointer NULL?
	or	cx,bx
	jz	StaCom25		;  Yes, just return error code
	xor	cx,cx
	xor	dx,dx
	or	ah,ah			;Set 'S' if LPT port
	mov	ax,cx			;For LPTs, everything is zero
	js	StaCom20		;LPT port

; Need to get the status for a com port.  Since not all the
; status is contained within EFlags, it has to be assembled.
; Also note that currently there is no way to specify RLSD
; as a handshaking line, so fRLSDHold is always returned false.

	mov	al,MSRShadow[si]	;Get state of hardware lines
	and	al,OutHHSLines[si]	;Mask off required bits
	xor	al,OutHHSLines[si]	;1 = line low
	mov	cl,4			;Align bits
	shr	al,cl			;al = fCTSHold + fDSRHold
	.errnz	  ACE_CTS-00010000b
	.errnz	  ACE_DSR-00100000b
	.errnz	 fCTSHold-00000001b
	.errnz	 fDSRHold-00000010b

	mov	ah,HSFlag[si]		;Get fXOffHold+fXOffSent
	and	ah,XOffReceived+XOffSent
	or	al,ah

	.errnz	 XOffReceived-fXOFFHold
	.errnz	 XOffSent-fXOFFSent

	mov	ah,EFlags[si]		;Get fEOF+fTxImmed
	and	ah,fEOF+fTxImmed
	or	al,ah

	mov	cx,QInCount[si] 	;Get input queue count
	mov	dx,QOutCount[si]	;Get tx queue count

StaCom20:
	mov	es:[bx.COMS_BitMask1],al
	mov	es:[bx.COMS_cbInQue],cx
	mov	es:[bx.COMS_cbOutQue],dx

StaCom25:
	xor	ax,ax			;Return old com error
	xchg	ax,ComErr[si]		;  and clear it out

StaCom30:
	pop	si
	ret

$STACOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SetBrk - Set Break
;
; Clamp the Tx data line low.  Does not wait for the
; transmitter holding register and shift registers to empty.
;
; LPT ports will just return the comm error word
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $SETBRK
$SETBRK proc   near

        mov     cx,0FF00h+ACE_SB        ;Will be setting break
        jmp     short ClrBrk10
	.errnz BreakSet-ACE_SB		;Must be same bits

$SETBRK endp
page

;----------------------------Public Routine-----------------------------;
;
; $CLRBRK - Clear Break
;
; Release any BREAK clamp on the Tx data line.
;
; LPT ports will just return the comm error word
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $CLRBRK
$CLRBRK proc near

	mov	cx,(NOT ACE_SB) SHL 8
	.errnz BreakSet-ACE_SB		;Must be same bits

ClrBrk10:
	push	si
	call	GetDEB			;Get DEB address
	jc	ClrBrk30		;Invalid ID
	js	ClrBrk20		;Ignored for LPT ports
        call DOCLI
	and	HSFlag[si],ch		;Set or clear the BreakSet bit
	or	HSFlag[si],cl

; ch = mask to remove bits in the Line Control Register
; cl = mask to turn bits on in the Line Control Register

	mov	dx,Port[si]		;Get comm device base I/O port
	add	dl,ACE_LCR		;Point at the Line Control Regieter
	in	al,dx			;Get old line control value
	and	al,ch			;Turn off desired bits
	or	al,cl			;Turn on  desired bits
	iodelay
	out	dx,al			;Output New LCR.
        call DOSTI

ClrBrk20:
	mov	ax,ComErr[si]		;Return Status Word

ClrBrk30:
        pop     si
        ret

$CLRBRK endp

page

;----------------------------Public Routine-----------------------------;
;
; $EXTCOM - Extended Comm Functions
;
; A number of extended functions are routed through this entry point.
;
; Functions currently implemented:
;
;   0: Ignored
;   1: SETXOFF - Exactly as if X-OFF character has been received.
;   2: SETXON  - Exactly as if X-ON character has been received.
;   3: SETRTS  - Set the RTS signal
;   4: CLRRTS  - Clear the RTS signal
;   5: SETDTR  - Set the DTR signal
;   6: CLRDTR  - Clear the DTR signal
;   7: RESET   - Yank on reset line if available (LPT devices)
;
; Entry:
;   AH = Device ID
;   BL = Function Code
;        (0-127 are MS-defined, 128-255 are OEM defined)
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;


;       Dispatch table for the extended functions

ExtTab  dw      ExtComDummy             ;Function 0: Never Mind
        dw      ExtCom_FN1              ;1: Set X-Off
        dw      ExtCom_FN2              ;2: Clear X-Off
        dw      ExtCom_FN3              ;3: Set RTS
        dw      ExtCom_FN4              ;4: Clear RTS
        dw      ExtCom_FN5              ;5: Set DSR
	dw	ExtCom_FN6		;6: Clear DSR
	dw	ExtCom_FN7		;7: Reset printer
	dw	ExtCom_FN8		;8: Get Max LPT Port
	dw	ExtCom_FN9		;9: Get Max COM Port
	dw	ExtCom_FN10		;10: Get COM Port Base & IRQ
	dw	ExtCom_FN10		;11: Get COM Port Base & IRQ
%OUT fix this for bld 32 -- GetBaseIRQ is now 10

   assumes ds,Data
   assumes es,nothing

   public   $EXTCOM
$EXTCOM proc   near

	push	si
	push	di
        call    GetDEB                  ;Get DEB pointer
        jc      ExtCom40                ;Invalid ID, return error
	mov	dx,Port[si]		; get port address
        jns     ExtCom10                ;Its a COM port
        cmp     bl,7                    ;RESET extended function?
	jne	ExtCom30		;  No, return error word
        jmp     short ExtCom20          ;  Yes, invoke the function

ExtCom10:
	cmp	bl,11			;Last fcn supported
	ja	ExtCom30		;Not an implemented function.

ExtCom20:
        xor     bh,bh
        add     bx,bx                   ;Shift for the call
        call DOCLI                             ;Consider as critical sections
	call	ExtTab[bx]		;  and perform the function
        call DOSTI
	jc	ExtCom40		; jump if sub returns data in DX:AX

ExtCom30:
        mov     ax,ComErr[si]           ;Return standard error word
	xor	dx, dx

ExtCom40:
	pop	di
        pop     si

        ret

$EXTCOM endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN1 - Extended Function Set X-Off
;
; Analagous to receiving an X-OFF character.  Bufferred transmision of
; characters is halted until an X-ON character is received, or until
; we fake that with a Clear X-Off call.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN1
ExtCom_FN1   proc   near

        or      HSFlag[si],XOffReceived
ExtComDummy:
	clc
        ret

ExtCom_FN1   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN2 - Extended Function Clear X-Off
;
; Analagous to receiving an X-ON character. Buffered
; transmission of characters is restarted.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN2
ExtCom_FN2   proc   near

        and     HSFlag[si],NOT XOffReceived
	call	KickTx			;Kick transmitter interrupts on
	clc
	ret

ExtCom_FN2   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN3 - Extended Function Set RTS
;
; Set the RTS signal active.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN3
ExtCom_FN3   proc   near

	add	dl,ACE_MCR		;Point at Modem Control Register
	in	al,dx			;Get current settings
	or	al,ACE_RTS		;Set RTS
	iodelay
	out	dx,al			;And update
	clc
	ret

ExtCom_FN3   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN4 - Extended Function Clear RTS
;
; Set the RTS signal inactive.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN4
ExtCom_FN4   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        and     al,NOT ACE_RTS          ;Clear RTS
	iodelay
	out	dx,al			;And update
	clc
        ret

ExtCom_FN4   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN5 - Extended Function Set DTR
;
; Set the DTR signal active.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN5
ExtCom_FN5   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        or      al,ACE_DTR              ;Set DTR
	iodelay
	out	dx,al			;And update
	clc
        ret

ExtCom_FN5   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN6 - Extended Function Clear DTR
;
; Set the DTR signal inactive.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN6
ExtCom_FN6   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        and     al,NOT ACE_DTR          ;Clear DTR
	iodelay
	out	dx,al			;And update
	clc
        ret

ExtCom_FN6   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN7 - Extended Function Reset Printer
;
; Assert the RESET line on an LPT port
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN7
ExtCom_FN7   proc   near

        call DOSTI                             ;Not called at interrupt time
        mov     ch,1                    ;ROM BIOS Reset Port
	call	DoLPT			;Perform the function
	clc
        ret

ExtCom_FN7   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN8 - Get Num Ports
;
; Entry:
; Returns:
;   AX = Max LPT port id
;   DX = 0
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN8
ExtCom_FN8   proc   near

	mov	ax, MAXLPT + LPTx
	xor	dx, dx
	stc
        ret

ExtCom_FN8   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN9  - Get Max COM Port
;
; Entry:
; Returns:
;   AX = Max COM port id
;   DX = 0
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN9
ExtCom_FN9    proc   near

	mov	ax, MAXCOM
	xor	dx, dx
	stc
        ret

ExtCom_FN9    endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN10 - Get COM Port Bas & IRQ
;
; Entry:
;   AH = com id
;   DS:SI -> DEB
; Returns:
;   AX = base
;   DX = irq
; Error Returns:
;   None
; Registers Preserved:
;   DS
; Registers Destroyed:
;   AX,BX,CX,DX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN10
ExtCom_FN10   proc   near

	call	FindCOMPort
	stc
	ret

ExtCom_FN10   endp
page


ifdef DEBUG
	public	RecCom40, RecCom50, RecCom60, RecCom70, RecCom80
	public	RecCom90, RecCom95, RecCom100
	public	SendImm10, SendImm20,
	public	SendCom10, SendCom20, SendCom30, SendCom40, SendCom50, SendCom60
	public	Flush10, Flush20, Flush30, Flush40
	public	KickTx10
	public	Evt10
	public	EvtGet10
	public	StaCom20, StaCom25, StaCom30
	public	ClrBrk10, ClrBrk20, ClrBrk30
	public	ExtCom10, ExtCom20, ExtCom30, ExtCom40, ExtComDummy
	public	MSRRestart, MSRWait10, MSRWait20, MSRWait30, MSRWait40
	public	MSRWait50, MSRWait60, MSRWait70, MSRWait80, MSRWait90
endif


DOSTI proc    near
      FSTI
      ret
DOSTI endp

DOCLI proc    near
      FCLI
      ret
DOCLI endp


sEnd    code
End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\comdev.h ===
/*************************************************************************
**
** Miscelaneous definitions.
*/
typedef unsigned short ushort;
typedef unsigned char uchar;

#define NULL    0
#define FALSE   0
#define TRUE    1

#define LPTx    0x80        /* Mask to indicate cid is for LPT device   */  /*081985*/
#define LPTxMask 0x7F       /* Mask to get      cid    for LPT device   */  /*081985*/

#define PIOMAX  3           /* Max number of LPTx devices in high level */  /*081985*/
#define CDEVMAX 10          /* Max number of COMx devices in high level */
#define DEVMAX  13          /* Max number of devices in high level      */  /*081985*/

/*************************************************************************
**
** device control block.
** This block of information defines the functional parameters of the
** communications software and hardware.
**
** Fields in the DCB are defined as follows:
**
**      Id              - Comm device ID, set by the device driver.
**      BaudRate        - Baud rate at which operating.
**      ByteSize        - Number of bits per transmitted/received byte. (4-8)
**                        Received data is also masked off to this size.
**      Parity          - Transmitt/Receive Parity. (0,1,2,3,4) = (None, Odd,
**                        Even, Mark, Space)
**      StopBits        - Number of stop bits. (0,1,2) = (1, 1.5, 2)
**      RlsTimeout      - Amount of time, in milleseconds, to wait for RLSD to
**                        become high. RLSD, Receive Line Signal Detect is also
**                        known as CD, Carrier Detect. RLSD flow control can be
**                        achieved by specifying infinite timeout.
**      CtsTimeout      - Amount of time, in milleseconds, to wait for CTS,
**                        Clear To Send, to become high. CTS flow control can
**                        be achieved by specifying infinite timeout.
**      DsrTimeout      - Amount of time, in milleseconds, to wait for DSR,
**                        Data Set Ready, to become high. DSR flow control can
**                        be acheived by specifying infinite timeout.
**      fBinary         - Binary Mode flag. In non-binary mode, EofChar is
**                        recognized and remembered as end of data.
**      fRtsDisable     - Disable RTS flag. If set, Request To Send is NOT
**                        used, and remains low. Normally, RTS is asserted when
**                        the device is openned, and dropped when closed.
**      fParity         - Enable Parity Checking. Parity errors are not
**                        reported when 0.
**      fOutxCtsFlow    - enable output xon/xoff(hardware)  using cts
**      fOutxDsrFlow    - enable output xon/xoff(hardware)  using dsr
**      fOutX           - Indicates that X-ON/X-OFF flow control is to be used
**                        during transmission. The transmitter will halt if
**                        an X-OFF character is received, and will start again
**                        when an X-ON character is received.
**      fInX            - Indicates that X-ON/X-OFF flow control is to be used
**                        during reception. An X-OFF character will be
**                        transmitted when the receive queue comes within 10
**                        characters of being full, after which an X-ON will be
**                        transmitted when the queue comes with 10 characters
**                        of being empty.
**      fPeChar         - Indicates that characters received with parity errors
**                        are to be replaced with the character specified in
**                        PeChar, below.
**      fNull           - Indicates that received NULL characters are to be
**                        discarded.
**      fChEvt          - Indicates that the reception of EvtChar is to be
**                        flagged as an event by cevt.
**      fDtrFlow        - Indicates that the DTR signal is to be used for
**                        receive flow control. (cextfcn can be used to set and
**                        clear DTR, overriding this definition).
**      fRtsFlow        - Indicates that the RTS signal is to be used for
**                        receive flow control. (cextfcn can be used to set and
**                        clear RTS, overriding this definition).
**      XonChar         - X-ON character for both transmit and receive
**      XoffChar        - X-OFF character for both transmit and receive
**      XonLim          - When the number of characters in the receive queue
**                        drops below this value, then an X-ON character is
**                        sent, if enabled, and DTR is set, if enabled.
**      XoffLim         - When the number of characters in the receive queue
**                        exceeds this value, then an X-OFF character is sent,
**                        if enabled, and DTR is dropped, if enabled.
**      PeChar          - Parity Error replacement character.
**      EvtChar         - Character which triggers an event flag.
**      EofChar         - Character which specifies end of input.
**      TxDelay         - Specifies the minimum amount of time that must pass
**                        between transmission of characters.
**
** Timeouts are in milleseconds. 0 means ignore the signal. 0xffff means
** infinite timeout.
**
*************************************************************************/
typedef struct {
   char     Id;                         /* Internal Device ID               */
   ushort   BaudRate;                   /* Baudrate at which runing         */
   char     ByteSize;                   /* Number of bits/byte, 4-8         */
   char     Parity;                     /* 0,1,2,3,4 = None,Odd,Even,Mark,Sp*/
   char     StopBits;                   /* 0,1,2 = 1, 1.5, 2                */
   ushort   RlsTimeout;                 /* Timeout for RLSD to be set       */
   ushort   CtsTimeout;                 /* Timeout for CTS to be set        */
   ushort   DsrTimeout;                 /* Timeout for DSR to be set        */

   uchar    fBinary: 1;                 /* CTRL-Z as EOF flag               */
   uchar    fRtsDisable:1;              /* Suppress RTS                     */
   uchar    fParity: 1;                 /* Enable parity check              */
   uchar    fOutxCtsFlow: 1;            /* Enable output xon/xoff with cts  */
   uchar    fOutxDsrFlow: 1;            /* Enable output xon/xoff with dsr  */
   uchar    fDummy: 3;

   uchar    fOutX: 1;                   /* Enable output X-ON/X-OFF         */
   uchar    fInX: 1;                    /* Enable input X-ON/X-OFF          */
   uchar    fPeChar: 1;                 /* Enable Parity Err Replacement    */
   uchar    fNull: 1;                   /* Enable Null stripping            */
   uchar    fChEvt: 1;                  /* Enable Rx character event.       */
   uchar    fDtrflow: 1;                /* Enable DTR flow control          */
   uchar    fRtsflow: 1;                /* Enable RTS flow control          */
   uchar    fDummy2: 1;

   char     XonChar;                    /* Tx and Rx X-ON character         */
   char     XoffChar;                   /* Tx and Rx X-OFF character        */
   ushort   XonLim;                     /* Transmit X-ON threshold          */
   ushort   XoffLim;                    /* Transmit X-OFF threshold         */
   char     PeChar;                     /* Parity error replacement char    */
   char     EofChar;                    /* End of Input character           */
   char     EvtChar;                    /* Recieved Event character         */
   ushort   TxDelay;                    /* Amount of time between chars     */
   } DCB;

/*************************************************************************
**
** COMSTAT
** Status record returned by GetCommError
**
*************************************************************************/
typedef struct {
   uchar        fCtsHold: 1;            /* Transmit is on CTS hold      */
   uchar        fDsrHold: 1;            /* Transmit is on DSR hold      */
   uchar        fRlsdHold: 1;           /* Transmit is on RLSD hold     */
   uchar        fXoffHold: 1;           /* Transmit is on X-Off hold    */
   uchar        fXoffSent: 1;           /* Recieve in X-Off or DTR hold */
   uchar        fEof: 1;                /* End of file character found  */
   uchar        fTxim: 1;               /* Character being transmitted  */
   uchar        fPerr:1;                /* Printer error                */  /*081985*/
   ushort       cbInQue;                /* count of characters in Rx Que*/
   ushort       cbOutQue;               /* count of characters in Tx Que*/
   } COMSTAT;

/*************************************************************************
**
** DCB field definitions.
**
*************************************************************************/
#define NOPARITY        0
#define ODDPARITY       1
#define EVENPARITY      2
#define MARKPARITY      3
#define SPACEPARITY     4

#define ONESTOPBIT      0
#define ONE5STOPBITS    1
#define TWOSTOPBITS     2

#define IGNORE          0               /* Ignore signal                */
#define INFINITE        0xffff          /* Infinite timeout             */

/*************************************************************************
**
** Comm Device Driver Error Bits.
**
*************************************************************************/
#define CE_RXOVER       0x0001          /* Receive Queue overflow       */
#define CE_OVERRUN      0x0002          /* Receive Overrun Error        */
#define CE_RXPARITY     0x0004          /* Receive Parity Error         */
#define CE_FRAME        0x0008          /* Receive Framing error        */
#define CE_CTSTO        0x0020          /* CTS Timeout                  */
#define CE_DSRTO        0x0040          /* DSR Timeout                  */
#define CE_RLSDTO       0x0080          /* RLSD Timeout                 */
#define CE_PTO          0x0100          /* LPTx Timeout                 */  /*081985*/
#define CE_IOE          0x0200          /* LPTx I/O Error               */  /*081985*/
#define CE_DNS          0x0400          /* LPTx Device not selected     */  /*081985*/
#define CE_OOP          0x0800          /* LPTx Out-Of-Paper            */  /*081985*/
#define CE_MODE         0x8000          /* Requested mode unsupported   */

/*************************************************************************
**
** Initialization Error Codes
**
*************************************************************************/
#define IE_BADID        -1              /* Invalid or unsupported id    */
#define IE_OPEN         -2              /* Device Already Open          */
#define IE_NOPEN        -3              /* Device Not Open              */
#define IE_MEMORY       -4              /* Unable to allocate queues    */
#define IE_DEFAULT      -5              /* Error in default parameters  */
#define IE_HARDWARE     -10             /* Hardware Not Present         */
#define IE_BYTESIZE     -11             /* Illegal Byte Size            */
#define IE_BAUDRATE     -12             /* Unsupported BaudRate         */
/*************************************************************************
**
** Event mask definitions. Used by SetCommEventMask and GetCommEventMask
**
** RXCHAR       - Set when any character is received and placed in the input
**                queue.
** RXFLAG       - Set when a particular character, as defined in the dcb, is
**                received and placed in the input queue.
** TXEMPTY      - Set when the last character in the transmit queue is
**                transmitted.
** CTS          - Set when the CTS signal changes state.
** DSR          - Set when the DSR signal changes state.
** RLSD         - Set when the RLSD signal changes state.
** BREAK        - Set when a break is detected on input.
** ERR          - Set when a line status error occurs.
**
*************************************************************************/
#define EV_RXCHAR       0x0001          /* Any Character received       */
#define EV_RXFLAG       0x0002          /* Received certain character   */
#define EV_TXEMPTY      0x0004          /* Transmitt Queue Empty        */
#define EV_CTS          0x0008          /* CTS changed state            */
#define EV_DSR          0x0010          /* DSR changed state            */
#define EV_RLSD         0x0020          /* RLSD changed state           */
#define EV_BREAK        0x0040          /* BREAK received               */
#define EV_ERR          0x0080          /* Line Status Error Occurred   */
#define EV_RING         0x0100          /* Ring signal detected         */
#define EV_PERR         0x0200          /* LPTx error occured           */  /*081985*/

/*************************************************************************
**
** Extended Functions
**
** SETXOFF      - Causes transmit to behave as if an X-OFF character had
**                been received. Valid only if transmit X-ON/X-OFF specified
**                in the dcb.
** SETXON       - Causes transmit to behave as if an X-ON character had
**                been received. Valid only if transmit X-ON/X-OFF specified
**                in the dcb.
*************************************************************************/
#define SETXOFF         1               /* Set X-Off for output control */
#define SETXON          2               /* Set X-ON for output control  */
#define SETRTS          3               /* Set RTS high                 */
#define CLRRTS          4               /* Set RTS low                  */
#define SETDTR          5               /* Set DTR high                 */
#define CLRDTR          6               /* Set DTR low                  */
#define RESETDEV        7               /* Reset device if possible     */  /*081985*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\ccom.asm ===
page,132

;---------------------------Module-Header-------------------------------;
; Module Name: CCOM.ASM
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; History
;
; 041786   Fixed RECCOM to return be able to return nulls

.xlist
include cmacros.inc
include comdev.inc
include ibmcom.inc
.list

sBegin  Code
assumes cs,Code
assumes ds,Data

;=========================================================================
;
;   Communications Device Driver - C language interface module.
;   This module provides an interface layer between programs written
;   in C, and the low-level OEM specific communications drivers.
;
;=========================================================================

   externNP   $CLRBRK
   externNP   $DCBPTR
   externNP   $EVT
   externNP   $EVTGET
   externNP   $EXTCOM
   externNP   $FLUSH
   externNP   $INICOM
   externNP   $RECCOM
   externNP   $RECSTR
   externNP   $SETBRK
   externNP   $SETCOM
   externNP   $SETQUE
   externNP   $SNDCOM
   externNP   $SNDIMM
   externNP   $STACOM
   externNP   $TRMCOM
   externNP   $SNDCOMSTR
   externNP   $ENANOTIFY

   externNP   GetDEB

;=========================================================================
;
;   ushort inicom(pdcb)
;   dcb far *pdcb;
;
;   returns    - 0   if no errors occured
;              - Error Code (which is reset)
;
;   Inicom is a one-time called routine to initialize. This is meant
;   to be called when a process starts, or determines that it will use
;   communications. Operating parameters are also passed on to setcom(),
;   below.
;
;   Fields within the dcb (including device id) should be set up prior to
;   calling inicom.
;
;   As a true device driver, this routine is to be called when the device
;   driver is loaded at system start-up time. The dcb reflects the
;   default operating parameters.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc inicom,<PUBLIC,FAR>
   parmD    pdcb

cBegin
   les      bx,pdcb
   assumes  es,nothing

   call     $INICOM
cEnd

page

;=========================================================================
;
;   ushort setcom(pdcb)
;   dcb far *pdcb;
;
;   returns - 0   if no errors occured
;           - Error Code (reset)
;
;   Set/alter communications operating parameters. This is a non-destructive
;   alteration of operating mode. Queues and interrupts are not affected.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc setcom,<PUBLIC,FAR>
   parmD    pdcb

cBegin
   les      bx,pdcb                    ;get pointer to dcb
   assumes  es,nothing

   call     $SETCOM
cEnd

page

;=========================================================================
;
;   void setque(cid,pqdb)
;   char   cid;
;   qdb far *pqdb;
;
;   Init the locations of the receive and transmit queues that are to be
;   used to buffer incomming and outgoing characters.
;
;   This may be called at any time by a process to use a different set
;   of queues. Characters (transmit and/or receive) may be lost if the
;   queues are changed when not empty. This allows dynamic allocation
;   of variable sized queues. Under DOS 4.0, the queues must be locked in
;   memory.
;
;   As a true device driver, the queues would be allocated at boot time,
;   and must also be locked under DOS 4.0.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc setque,<PUBLIC,FAR>
   parmB    cid
   parmD    pqdb

cBegin
   mov	    ah,cid
   les      bx,pqdb                    ;pointer to qdb
   assumes  es,nothing

   call     $SETQUE
cEnd

page

;=========================================================================
;
;   short reccom(cid)
;   char   cid;
;
;   Returns - character.
;      - -1 if error
;      - -2 if no character available
;
;   Read a byte. Extracts a byte from the receive data queue. Returns
;   immediately.
;=========================================================================


assumes ds,Data
assumes es,nothing

cProc reccom,<PUBLIC,FAR>
   parmB    cid

cBegin
   mov	    ah,cid		       ;Id Into AH

   call     $RECCOM                    ;Get char, error, or no data
   mov      cx,ax                      ;Save data
   mov      ah,0                       ;Assume valid data
   jnz      reccom5                    ;Data is valid
   mov      ax,-2                      ;Assume no data available
   jcxz     reccom5                    ;No data available
   inc      ax                         ;Show error (-1)

reccom5:
cEnd

page

;=========================================================================
;
;   short ReadCommString(cid, buf, cnt)
;   char   cid;
;   LPSTR  buf;
;   int    cnt;
;
;   Returns - ax = # of bytes read
;      - 0 if no character available or error
;
;   Read string. Extracts bytes from the receive data queue. Returns
;   immediately.
;=========================================================================


assumes ds,Data
assumes es,nothing

cProc ReadCommString,<PUBLIC,FAR>
   parmB    cid
   parmD    buf
   parmW    cnt

cBegin
   mov	    ah,cid		       ;Id Into AH
   les	    di, buf
   mov	    cx, cnt

   call     $RECSTR		       ;Get char, error, or no data
   jnz	    short recstr5	       ; jmp if no error
   xor	    ax, ax
recstr5:
cEnd

page

;=========================================================================
;
;   ushort sndcom(cid,ch)
;   char   cid;
;   char   ch;
;
;   Returns - 0 if no errors
;      - Error Code (Not removed, i.e. stacom will return this error
;        unless another occurs before the next call to stacom.)
;
;   Transmit a byte. Places a byte into the transmit queue. Negative return
;   indicates error.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc sndcom,<PUBLIC,FAR>
   parmB    cid
   parmB    chr

cBegin
   mov	    ah,cid
   mov      al,chr

   call     $SNDCOM
cEnd

page

;=========================================================================
;
;   ushort ctx(cid,ch)
;   char   cid;
;   char   ch;
;
;   Returns - 0 if no errors
;      - -1 if character could not be sent.
;
;   Transmit a byte "immediately". Places a byte into the transmit queue.
;   or other buffer such that it is the next character picked up for
;   transmission. Negative return indicates error.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc ctx,<PUBLIC,FAR>
   parmB    cid
   parmB    chr

cBegin
   mov	    ah,cid
   mov      al,chr

   call     $SNDIMM
cEnd

page

;=========================================================================
;
;   void trmcom(cid)
;   char   cid;
;
;   Terminate communications on a particular channel. Flushes the
;   buffers (waits for completion), and shuts down the comm device.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc trmcom,<PUBLIC,FAR>
   parmB    cid

cBegin
   mov	    ah,cid

   call     $TRMCOM                    ;and go for it
cEnd
page

;=========================================================================
;
;   ushort stacom(cid,pstat)
;   char   cid;
;   stat far *pstat;
;
;   Returns - 0 if no errors
;      - Error Code
;      - status structure updated.
;
;   Get device status. Returns device status and input queue status.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc stacom,<PUBLIC,FAR>,<si,di>
   parmB    cid
   parmD    pstat

cBegin
   mov	    ah,cid
   les      bx,pstat
   assumes  es,nothing

   call     $STACOM
cEnd

page

;=========================================================================
;
;   dword cextfcn(cid,fcn)
;   char   cid;
;   short   fcn;
;
;   Perform extended functions.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc cextfcn,<PUBLIC,FAR>
   parmB    cid
   parmW    fcn

cBegin
   mov	    ah,cid
   mov      bx,fcn

   call     $EXTCOM
cEnd

page

;=========================================================================
;
;   ushort cflush(cid,q)
;   ushort   cid;
;   ushort   q;
;
;   Queue flush. empties the specified queue. q=0 means transmit queue,
;   1 indicates receive queue.
;
;   Returns - 0 or -1.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc cflush,<PUBLIC,FAR>,<si,di>
   parmB    cid
   parmB    q

cBegin
   mov	    ah,cid
   mov      bh,q

   call     $FLUSH
cEnd

page

;=========================================================================
;
;   ushort far *cevt(cid,evtmask)
;   ushort   cid;
;   ushort   evtmask;
;
;   Returns the location of a word which in which certain bits will be set
;   when particular events occur. The event mask passed defines which bits
;   are to be enabled. The event byte is used primarily for speed in
;   determining if certain events have occurred. Returns 0 on success, -1
;   for an illegal handle.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc cevt,<PUBLIC,FAR>
   parmB    cid
   parmW    evt_mask

cBegin
   mov      ah,cid
   mov	    bx,evt_mask

   call     $EVT                       ;Set the event
cEnd

page

;=========================================================================
;
;   short cevtGet(cid, evtmask)
;   ushort   cid;
;   ushort   evtmask;
;
;   The event byte set up by cevt, above, is returned. This routine must be
;   used to read the event byte in order to prevent loss of an event
;   occurance. Those bits set in the event mask passed are then cleared in
;   the event byte.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc cevtGet,<PUBLIC,FAR>
   parmB    cid
   parmW    evt_mask

cBegin
   mov      ah,cid
   mov	    bx,evt_mask

   call     $EVTGET
cEnd

page

;=========================================================================
;
;   short csetbrk(cid)
;   ushort   cid;
;
;   Suspends character transmission, and places the transmission line in
;   a break state until cclrbrk is called. Returns 0 on success, -1 if
;   illegal handle.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc csetbrk,<PUBLIC,FAR>,<si,di>
   parmB    cid

cBegin
   mov      ah,cid

   call     $SETBRK
cEnd

page

;=========================================================================
;
;   short cclrbrk(cid)
;   ushort   cid;
;
;   Restores the line to a non-breaking state, and restarts character
;   transmission. Returns 0 on success, -1 if illegal handle.
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc cclrbrk,<PUBLIC,FAR>,<si,di>
   parmB    cid

cBegin
   mov      ah,cid

   call     $CLRBRK
cEnd

page

;=========================================================================
;
;   dcb far *getdcb(cid)
;   ushort cid;
;
;   Returns a pointer to the dcb associated with the given id.
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc getdcb,<PUBLIC,FAR>,<si,di>
   parmB    cid

cBegin
   mov      ah,cid

   call     $DCBPTR
cEnd

;=========================================================================
;
;   int CommWriteString(cid, lpstring, count)
;   ushort cid;
;   LPSTR  lpstring;
;   int    count;
;
;   Returns # of bytes sent
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc	CommWriteString, <FAR, PUBLIC>, <si, di>

    parmB   cid
    parmD   lpstring
    parmW   count

cBegin

	xor	ax, ax
	mov	cx, count
	jcxz	short cws_exit
	mov	ah, cid
	les	di, lpstring
	call	$SNDCOMSTR
cws_exit:
cEnd
page

;=========================================================================
;
;   bool EnableNotification(cid, hWnd, recv_trigger, send_trigger)
;   ushort cid;
;   WORD   hWnd;    /* 0, to disable notification */
;   int    recv_trigger;
;   int    send_trigger;
;
;   Returns # of bytes sent
;
;=========================================================================

assumes ds,Data
assumes es,nothing

cProc	EnableNotification, <FAR, PUBLIC>, <si, di>

    parmB   cid
    parmW   _hWnd
    parmW   recvT
    parmW   sendT

cBegin

	mov	ah, [cid]
	mov	bx, [_hWnd]
	mov	cx, [recvT]
	mov	dx, [sendT]
	call	$ENANOTIFY
cEnd
page

;-----------------------------------------------------------------------;
; WEP
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 13-Jan-1990 18:33:48  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	WEP,<PUBLIC,FAR>
cBegin nogen
	nop				; You don't want to know why.
	mov	ax,1
	ret	2
cEnd nogen

sEnd   Code

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\ibmcom.inc ===
DEBUG	 equ   1

No_DOSX_Bimodal_Services = 1
IFDEF No_DOSX_Bimodal_Services
%OUT generating code to handle ints without Bimodal Interrupt Services for DOSX
ENDIF

wo       equ   word ptr
by       equ   byte ptr

MAXLPT	 equ   2	;3 LPTs supported (LPT1,2,3)
MAXCOM	 equ   3	;4 COMs supported (COM1,2,3,4)

RS232B   equ   0h       ;RS232 Card(s) I/O addr 40:Save area.
LPTB     equ   8h       ;LPT   Card(s) I/O addr 40:Save area.

IRQ3	 equ   0bh	; Int vector for Com card @ 2xxh
IRQ4	 equ   0ch	; Int vector for Com card @ 3xxh

INTA0    equ   20h      ;X'20' 8259 Interrupt Control Port
INTA1    equ   21h      ;X'21' 8259 Interrupt Mask Port
EOI      equ   20h      ;X'20' 8259 End-of-Interrupt ack

Open     equ   0201h    ;Int 2F open request
Close    equ   0202h    ;Int 2F close request
Lock2F   equ   0203h    ;Int 2F lock request
Unlock2F equ   0204h    ;Int 2F unlock request


; COMDEB - Communications Device Equipment Block.
;
; This is essentially a superset of the DCB used outside of this
; module. The DCB is contained within the DEB as the first fields.
; The fields which follow are data and status fields which
; are unique to this implementation.
;
; AltQInAddr and AltQOutAddr are alternate queue pointers which are used when
; in "supervisor" mode.  Supervisor mode is a processor mode other than the
; one which Windows normally runs in.  In standard mode Windows, supervisor
; mode is REAL mode.  In enhanced mode Windows, supervisor mode is RING 0
; protected mode.  For more details see comments in IBMINT.ASM.

ComDEB struc                           ;RS232 Data Equip Block

  ComDCB        db      ((DCBSize+1) and 0FFFEh) DUP (0)

  ComErr        dw      0               ;Non-zero if I/O error
  Port          dw      0               ;Base I/O Address
  NotifyHandle	dw	0
  NotifyFlags	dw	0
  RecvTrigger	dw     -1		; char count threshold for calling
  SendTrigger	dw	0		; char count threshold for calling

; The following fields are specific to com ports only

  IRQhook	dw	0		; ptr to IRQ_Hook_Struc
  NextDEB	dw	0		; ptr to next DEB that is sharing IRQ
  XOffPoint     dw      0               ;Q count where XOff is sent
  EvtMask       dw      0               ;Mask of events to check for
  EvtWord       dw      0               ;Event flags
  QInAddr	dd	0		;Address of the queue
  AltQInAddr	dd	0		;   Addr of queue in "supervisor" mode
  QInSize       dw      0               ;Length of queue in bytes
  QOutAddr      dd      0               ;Address of the queue
  AltQOutAddr	dd	0		;   Addr of queue in "supervisor" mode
  QOutSize      dw      0               ;Length of queue in bytes
  QInCount      dw      0               ;Number of bytes currently in queue
  QInGet        dw      0               ;Offset into queue to get bytes from
  QInPut        dw      0               ;Offset into queue to put bytes in
  QOutCount     dw      0               ;Number of bytes currently in queue
  QOutGet       dw      0               ;Offset into queue to get bytes from
  QOutPut       dw      0               ;Offset into queue to put bytes in
  EFlags        db      0               ;Extended flags
  MSRShadow     db      0               ;Modem Status Register Shadow
  ErrorMask     db      0               ;Default error-checking mask
  RxMask        db      0               ;Character mask
  ImmedChar     db      0               ;Char to be transmitted immediately
  HSFlag        db      0               ;Handshake flag
  HHSLines      db      0               ;8250 DTR/RTS bits for handshaking
  OutHHSLines   db      0               ;Lines that must be high to output
  MSRMask       db      0               ;Mask of Modem Lines to check
  MSRInfinite   db      0               ;Mask of MSR lines that must be high
  IntVecNum     db      0               ;Interrupt vector number
  LSRShadow	db	0		;Line Status Register shadow
  QOutMod	dw	0		;characters sent mod xOnLim ENQ/ETX [rkh]
  VCD_data	dd	0
  VCDflags	db	0
  MiscFlags	db	0		;still more flags
ComDEB ends

.errnz	 (SIZE ComDEB) and 1

.errnz	MSRShadow - EvtWord - 35
; In 3.0 MSRShadow had this relationship to EvtWord and major COM apps all
; use this offset of 35 to get to MSRShadow so that they can determine the
; current status of the Modem Status bits.  We need to maintain this offset
; so that these apps will continue to run.


; The LptDEB is identical to the ComDEB structure, except
; all the COM port specific stuff has been removed (which
; convientiently was stored at the end so offsets would
; be correct).  This allows the code to act indifferently
; when accessing the strucutres for things like the port.

LptDEB struc
  xComDCB       db      ((DCBSize+1) AND 0FFFEh) dup (0)
  xComErr       dw      0               ;Non-zero if I/O error
  xPort         dw      0               ;Base I/O Address
  xNotifyHandle dw	0
  xNotifyFlags	dw	0
  xRecvTrigger	dw     -1		; char count threshold for calling
  xSendTrigger	dw	0		; char count threshold for calling

  BIOSPortLoc	dw	0		;Offset to port location (i.e. 40:0)
LptDEB ends

		.errnz	 xComDCB-ComDCB
		.errnz	 xComErr-ComErr
		.errnz	 xPort-Port

		.errnz	 xNotifyHandle-NotifyHandle
		.errnz	 xNotifyFlags-NotifyFlags
		.errnz	 xRecvTrigger-RecvTrigger
		.errnz	 xSendTrigger-SendTrigger


; flag equates in EFlags
fUseDSR     equ 00000001b		; set, if DSR is significant
fNoFIFO     equ 00000010b		; set, if no FIFO on port
fFIFOchkd   equ 00000100b		; set, if FIFO has been checked
fFIFOpre    equ 00001000b		; FIFO enabled when port opened
;fEOF	    equ 00100000b		; defined in comdev.inc
;fTxImmed   equ 01000000b		; defined in comdev.inc

fEFlagsMask equ fUseDSR OR fFIFOpre OR fFIFOchkd OR fNoFIFO ; flags which shouldn't be cleared

.errnz fEFlagsMask AND (fEOF OR fTxImmed) ;can't overlap with either of the bits
					;  that are folded into COMS_BitMask1


; Values for NotifyFlags
;
CN_RecvSent	equ CN_RECEIVE SHL 8
CN_TransSent	equ CN_TRANSMIT SHL 8

CN_Idle 	equ 10000000b
CN_Notify	equ 01000000b

NotifyFlagsLO	equ byte ptr NotifyFlags
NotifyFlagsHI	equ byte ptr NotifyFlags+1

; Values for the handshake flag
;
; BreakSet        - True if break was set - stops transmission
; XOffSent        - True if we have sent the XOff character
; XOffPending     - True if XOff character needs to be sent
; XOnPending      - True if XOn  character needs to be sent
; HHSDown         - True if host dropped required hardware lines
; HHSDropped      - True if we dropped our hardware handshake lines
; XOffReceived    - True if XOff received from host
; HSPending       - Mask to return non-zero if XOn or Xoff must be sent
; HSReceived      - Mask to return non-zero if handshake has been
;                   received from host stopping transmission
; CannotXmit      - Mask to return non-zero if any condition
;                   exists which prevents us from tranmitting.
; HSSent          - Mask to return non-zero if we sent a handshake


XOffPending     equ     00000001b       ;XOff needs to be sent
EnqPending      equ     00000001b       ;Enq needs to be sent [rkh]
EtxPending      equ     00000001b       ;Etx needs to be sent

HHSDropped      equ     00000010b       ;Our hardware handshake lines are down

XOnPending      equ     00000100b       ;XOn needs to be sent
AckPending      equ     00000100b       ;Ack needs to be sent (ENQ/ACK & ETX/ACK)

XOffReceived    equ     00001000b       ;XOff character received
EnqSent         equ     00001000b       ;Enq has been sent
EtxSent         equ     00001000b       ;Etx has been sent

XOffSent        equ     00010000b       ;XOff has been sent
EnqReceived     equ     00010000b       ;Enq character received (ENQ/ACK)
EtxReceived     equ     00010000b       ;Etx character received (ETX/ACK)

HHSDown         equ     00100000b       ;Host hardware handshake lines are down

BreakSet        equ     01000000b       ;Break has been set

HHSAlwaysDown	equ	10000000b	;set if host handshake lines were never
					;  detected high

HSPending       equ     XOffPending+XOnPending
HSReceived      equ     XOffReceived+HHSDown
HSSent          equ     XOffSent+HHSDropped
CannotXmit	equ	HSPending+HSReceived+BreakSet

; values for MiscFlags

Discard 	equ	00000001b	;Discard recevied data


iodelay macro		     ;;macro to insure that an instruction
	jmp	$+2	     ;;  fetch occurs between IN and/or OUT
	jmp	$+2	     ;;  instructions on the PC-AT machine
endm


TimeoutError   equ   -2      ;Timeout error code for $TRMCOM
Timeout        equ   30      ;30 second timeout

DELAY_TIME     equ   200     ;Delay at least 200 milliseconds


;       Status bits returned from the BIOS for LPT ports

PS_NotBusy      equ     10000000b       ;Printer not busy
PS_Ack          equ     01000000b       ;Data acknowledged
PS_PaperOut     equ     00100000b       ;Out of paper
PS_Select       equ     00010000b       ;Device is selected
PS_IOError      equ     00001000b       ;IO error
PS_Timeout      equ     00000001b       ;Timeout occured


; status bit defines for LPT

L_BITS	      equ     0F8h		  ; the status bits we want
L_BITS_INVERT equ     048h		  ; must invert to match BIOS
L_DEVBUSY     equ     080h		  ; device busy bit
L_TIMEOUT     equ     001h		  ; timeout bit

; control bit defines for LPT

L_NORMAL      equ     00Ch		  ; normal state: selected, no reset
L_RESET       equ     008h		  ; reset state
L_STROBE      equ     00Dh		  ; tell printer we have char


IRQ_Hook_Struc struc
IRQn		db  0
HookCnt 	db  0
OldMask 	db  0
VecN		db  0FFh
HandlerOff	dw  0
First_DEB	dw  0
OldIntVec	dd  0
IFDEF No_DOSX_Bimodal_Services
RM_OldIntVec	dd  0
RM_HandlerOff	dw  0
ENDIF
IRQ_Hook_Struc ends


IFDEF No_DOSX_Bimodal_Services
include int31.inc

Get_RM_IntVector equ (Int31_Int_Serv SHL 8) + Int_Get_Real_Vec
Set_RM_IntVector equ (Int31_Int_Serv SHL 8) + Int_Set_Real_Vec
ENDIF

;
; flag bits for VCDflags
;
fCOM_ignore_ints    equ 00000001b
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\ibmlpt.asm ===
page,132
;---------------------------Module-Header-------------------------------;
; Module Name: IBMLPT.ASM
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; General Description:
;
; History:
;
;-----------------------------------------------------------------------;

title	IBMLpt - IBM PC, PC-XT, PC-AT, PS/2 Parallel Communications Interface

.xlist
include cmacros.inc
include comdev.inc
include ins8250.inc
include ibmcom.inc
.list

sBegin Code
assumes cs,Code
assumes ds,Data

externFP GetSystemMsecCount

externA __0040H

;----------------------------Private-Routine----------------------------;
;
; DoLPT - Do Function To LPT port
;
; The given function (output or reset) is performed to the
; passed LPT port.
;
; Before a character is sent, a check is made to see if the device
; will be able to accept the character.  If it can, then the character
; will be sent.  If not, then an error will be returned.  If the
; printer is selected and busy and no error, then the code returned
; will be CE_TXFULL and the handshake bits will be set in HSFlag
; to simulate that a handshake was received.
;
; If the BIOS ROM code is examined, you will note that they wait for
; the busy character from the last charcater to be cleared before
; they strobe in the current character.  This can take a long time
; on the standard EPSON class printer (1 mSec to greater than
; 300 mSec if the last character actually caused printing).
;
; Because of this, several status read retrys will be made before
; declaring that the device is actually busy.  If only one status
; read is performed, the spooler will yeild, take a while to get
; back here, and things will be really slow.  What difference does
; it really make if we or the BIOS does the delay, at least we can
; break out of it at some point when it seems hopeless.
;
;   The OKIHACK: Okidata reports a 50 ns. 2.2 volt pulse on the paper
;   out signal on the trailing edge of the Busy signal.  If we see this
;   glitch then we report paper out.  So we try to get the status twice...
;   if it changes between the two tries we keep getting the status.
;   
;
; Entry:
;   AH    =  cid
;   AL    =  character to output
;   CH	  =  Function request.	0 = Output, 1 = Initialize, 2 = Status
;   DS:SI -> DEB for the port
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

	public DoLPT
DoLPT   proc   near

	mov	dx,Port[si]		;Get port address

;   DX = port address
;   CH = operation: 0 = write, 1 = init, 2 = status
;   AL = character

	or	ch, ch
	jz	LPT_OutChar
	cmp	ch, 1
	jz	LPT_Reset
	jmp	LPT_GetStatus
	ret

LPT_Reset:

	inc	dx
	inc	dx
	mov	al, L_RESET
	iodelay
	out	dx, al

	push	dx

	cCall	GetSystemMsecCount
	mov	bx, ax

LPT_ResetDelay:
	push	bx
	cCall	GetSystemMsecCount
	pop	bx
	sub	ax, bx
	cmp	ax, 300 		; 1/3 sec as good as any
	jbe	LPT_ResetDelay

	pop	dx

	mov	al, L_NORMAL
	iodelay
	iodelay
	out	dx, al
	dec	dx
	dec	dx
	jmp	LPT_GetStatus

LPT_OutChar:
	push	ax			; save character to be written

	; first check to see if printer is ready for us
	push	di

	push	dx
	call	GetSystemMSecCount
	mov	di, ax
	pop	dx

LPT_WaitReady:

	inc	dx			; point to status port
	iodelay
	in	al, dx			; get status bits
	and	al, L_BITS	      ; mask unused ones
	xor	al, L_BITS_INVERT     ; flip a couple
	xchg	al, ah

ifndef NOOKIHACK
	iodelay
	in	al, dx

	dec	dx

	and	al, L_BITS
	xor	al, L_BITS_INVERT
	cmp	al, ah			; did any bits change?
	jnz	LPT_WaitReady
else
	dec	dx
endif


	test	ah, PS_PaperOut or PS_IOError
	jnz	LPT_PrinterNotReady
	test	ah, PS_Select
	jz	LPT_PrinterNotReady
	test	ah, PS_NotBusy
	jnz	LPT_PrinterReady

	push	ax
	push	dx
	call	GetSystemMSecCount
	pop	dx
	pop	bx
	sub	ax, di
	cmp	ax, 300 	       ; 1/3 sec timeout

	jbe	LPT_WaitReady

;       The device seems to be selected and powered up, but is just
;       busy (some printers seem to show selected but busy when they
;       are taken offline).  Show that the transmit queue is full and
;       that the hold handshakes are set.  This is so the windows
;	spooler will retry (and do yields so that other apps may run).


	or	ComErr[si],CE_TXFULL	;Show queue full
	mov	ah,bh
	or	ah, L_TIMEOUT

LPT_PrinterNotReady:

	pop	di
	pop	cx			; throw away character
	jmp	short LPT_ReturnStatus

LPT_PrinterReady:
	pop	di			; get di back
	pop	ax			; get character back

	iodelay
	out	dx, al			; write character to port

	inc	dx			; access status port

LPT_Strobe:
	inc	dx			; control port
	mov	al, L_STROBE	      ; set strobe high
	iodelay
	iodelay
	iodelay
	iodelay
	out	dx, al			;   ...

	mov	al, L_NORMAL	      ;
	iodelay
	iodelay
	iodelay
	iodelay
	out	dx, al			; set strobe low

	sub	dx, 2			; point back to port base

	; FALL THRU

LPT_GetStatus:
	inc	dx			; point to status port
LPT_GS1:
	iodelay
	iodelay
	in	al, dx			; get status bits
	and	al, L_BITS	      ; mask unused ones
	xor	al, L_BITS_INVERT     ; flip a couple
	mov	ah, al

ifndef NOOKIHACK
	in	al, dx
	and	al, L_BITS
	xor	al, L_BITS_INVERT
	cmp	al, ah
	jnz	LPT_GS1 	; if they changed try again...
endif

LPT_ReturnStatus:

	assumes ds,Data
        and     ax,(PS_PaperOut+PS_Select+PS_IOError+PS_Timeout)*256
        shr     ah,1
        adc     ah,al                   ;Get back Timeout bit
        xor     ah,HIGH CE_DNS          ;Invert selected bit
   .errnz   LOW CE_DNS
        or      by ComErr+1[si],ah      ;Save comm error
        ret

   .errnz   CE_PTO-0200h
   .errnz   CE_IOE-0400h
   .errnz   CE_DNS-0800h
   .errnz   CE_OOP-1000h

DoLPT40:
	assumes ds,Data
        or      ComErr[si],CE_TXFULL    ;Show queue full
        ret

DoLPT   endp
page


CheckStatus proc    near
	in	al, dx			; get status bits
	mov	ah, al
	and	al, L_BITS	      ; mask unused ones
	xor	al, L_BITS_INVERT     ; flip a couple
	xchg	al, ah

ifndef NOOKIHACK
	iodelay
	in	al, dx

	and	al, L_BITS
	xor	al, L_BITS_INVERT
	cmp	al, ah			; did any bits change?
	jnz	CheckStatus
endif
	test	ah, PS_PaperOut or PS_IOError
	jz	@F
	stc
	ret
@@:
	test	ah, PS_Select
	jnz	@F
	stc
	ret
@@:
	and	ah, PS_NotBusy
	clc
	ret

CheckStatus endp


;----------------------------Public Routine-----------------------------;
;
; StringToLPT - Send string To LPT Port
;
; Entry:
;   DS:SI -> DEB
;   ES:DI -> string to send
;   CX = # of bytes to send
; Returns:
;   AX = # of bytes actually sent
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

PUBLIC StringToLPT
StringToLPT proc    near

	mov	dx, Port[si]		; get port address
	inc	dx			; access status port

	push	cx			; save count for later
	push	ds
	mov	bx, __0040H
	mov	ds, bx

	cld

	call	CheckStatus		; quick status check before slowness
	jc	PrinterError
	jz	PrinterBusy		; if printer not ready for first char
					;   then just return with CE_TXFULL

CharacterToLPT:
;;	  mov	  bh, 10		  ; will wait 10 clock tics (~ 1/2 sec)
	mov	bh, 3			; will wait 3 clock tics (~ 1/6 sec)
l1:
	mov	bl, ds:[006Ch]		; low byte of tic counter
l2:
	call	CheckStatus		; quick status check before slowness
	jc	PrinterError
	jnz	LPT_PrinterRdy

	cmp	bl, ds:[006Ch]
	jz	l2			; tic count hasn't changed

	dec	bh
	jz	PrinterBusy		; out of tics, timeout
	jmp	short l1

LPT_PrinterRdy:
	mov	al, es:[di]
	inc	di

	dec	dx			; point to data port

	out	dx, al			; write character to port

	add	dx, 2			; access control port
	mov	al, L_STROBE		; set strobe high
	out	dx, al			;   ...

	mov	al, L_NORMAL		;
	iodelay
	iodelay
	out	dx, al			; set strobe low

	dec	dx			; point to status port for check

	loop	CharacterToLPT
	pop	ds
	jmp	short LPT_Exit

PrinterError:
	pop	ds
	jmp	short ReturnStatus

PrinterBusy:
	pop	ds
	or	ComErr[si],CE_TXFULL	; set buffer full bit
	or	al, L_TIMEOUT		; show timeout bit

ReturnStatus:
	and	ax,(PS_PaperOut+PS_Select+PS_IOError+PS_Timeout)
	xchg	al, ah
        shr     ah,1
        adc     ah,al                   ;Get back Timeout bit
	xor	ah,HIGH CE_DNS		;Invert selected bit
	.errnz	LOW CE_DNS
	or	by ComErr+1[si],ah	;Save comm error

LPT_Exit:
	pop	ax			; get total count
	sub	ax, cx			; subtract remaining unsent charts

	ret

StringToLPT endp


IFDEF DEBUG		;Publics for debugging
    public  LPT_Reset
    public  LPT_Outchar
    public  LPT_Strobe
    public  LPT_GetStatus
    public  DoLPT40
ENDIF

sEnd    code
End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\ibmint.asm ===
page,132
;---------------------------Module-Header-------------------------------
; Module Name: IBMINT.ASM
;
; Created: Fri 06-Feb-1987 10:45:12
; Author:  Walt Moore [waltm]
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved
;
; General Description:
;   This file contains the interrupt time routines for the
;   IBM Windows communications driver.
;
;   The interrupt code is preloaded and fixed.
;
; History:
;
; **********************************************************************
;    Tue Dec 19 1989 09:35:15	-by-  Amit Chatterjee  [amitc]
; ----------------------------------------------------------------------
;    Added a far entry point 'FakeCOMIntFar' so that the routine 'FakeCOMInt'
; could be called from the 'InitAPort' routine in IBMCOM.ASM
;
;   26.Nov.90	richp
;
;   Changed interrupt routines to use new VPICD services for bi-modal/multi-
;   modal interrupt handling.  They now work in straight real mode for real
;   mode Windows, but can also handle interrupts in real mode or protected
;   mode for standard mode Windows, and handle interrupts in RING 0 protected
;   mode for enhanced mode Windows, even when the Windows VM is not currently
;   executing.
;
;   sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;           FCLI/FSTI macros
;-----------------------------------------------------------------------;

subttl  Communications Hardware Interrupt Service Routines

.xlist
include cmacros.inc
include comdev.inc
include ibmcom.inc
include ins8250.inc
include BIMODINT.INC
include vint.inc
.list

externFP GetSystemMsecCount

externW  COMptrs
externW  activeCOMs

externD  lpPostMessage

sBegin Data

PUBLIC IRQhooks
IRQhooks    label byte
DefineIRQhook MACRO num
IFDEF No_DOSX_Bimodal_Services
IRQhook&num IRQ_Hook_Struc <,,,,IntCodeOFFSET DEF_COM_INT_&num,,,, \
			    IntCodeOFFSET DEF_RM_COM_INT_&num>
ELSE
IRQhook&num IRQ_Hook_Struc <,,,,IntCodeOFFSET DEF_COM_INT_&num>
ENDIF
ENDM
??portnum = 1
REPT MAXCOM+1
	DefineIRQhook %??portnum
??portnum = ??portnum+1
ENDM

PURGE DefineIRQhook

EXTRN VCD_int_callback:fword

sEnd data

createSeg _INTERRUPT,IntCode,word,public,CODE
sBegin IntCode
assumes cs,IntCode

page

IFDEF No_DOSX_Bimodal_Services
public RM_IntDataSeg
RM_IntDataSeg	dw 0
  ; this variable is written into by a routine in inicom
  ; if the 286 DOS extender is present.  This variable
  ; contains the SEGMENT value of the data selector "_DATA"
  ; so that the real mode interrupt handler may use the
  ; data segment, and not it's selector !

PUBLIC	RM_CallBack
RM_CallBack	dd  0
ENDIF


Control proc far
	ret
Control endp


IFDEF No_DOSX_Bimodal_Services
DEF_RM_Handler proc far
	push	es
	push	di
	push	ax
	mov	es, cs:[RM_IntDataSeg]
	mov	di, es:[di.First_DEB]	    ; ES:DI -> ComDEB
	add	di, SIZE ComDEB 	    ; ES:DI -> BIS
	mov	es:[di.BIS_Mode], 4
	push	cs
	call	NEAR PTR COMHandler
	mov	es:[di.BIS_Mode], 0
	pop	ax
	pop	di			    ; ES:DI -> IRQ_Hook_Struc
	jc	short DEF_RM_chain
	pop	es
	pop	di
	add	sp, 4
	iret

DEF_RM_chain:
        call DOCLI
	push	bp
	mov	bp, sp			    ;stack frame:
					    ;	bp+8	-> OldInt CS
					    ;	bp+6	-> OldInt IP
					    ;	bp+4	-> di
					    ;	bp+2	-> es
					    ;	bp+0	-> bp
	les	di, es:[di.RM_OldIntVec]
	mov	[bp+6], di
	mov	[bp+8], es
	pop	bp
	pop	es
	pop	di
	ret				    ; far ret to OldInt handler
DEF_RM_Handler endp
ENDIF	;No_DOSX_Bimodal_Services


Define_DEF_COM_INT MACRO num
IFDEF No_DOSX_Bimodal_Services
PUBLIC DEF_RM_COM_INT_&num
DEF_RM_COM_INT_&num proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook&num
        jmp     DEF_RM_Handler
DEF_RM_COM_INT_&num endp
ENDIF
PUBLIC DEF_COM_INT_&num
DEF_COM_INT_&num proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook&num
        jmp     DEF_Handler
DEF_COM_INT_&num endp
ENDM

??portnum = 2
REPT MAXCOM
	Define_DEF_COM_INT %??portnum
??portnum = ??portnum+1
ENDM

PURGE Define_DEF_COM_INT

IFDEF No_DOSX_Bimodal_Services
PUBLIC DEF_RM_COM_INT_1
DEF_RM_COM_INT_1 proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook1
        jmp     DEF_RM_Handler
DEF_RM_COM_INT_1 endp
ENDIF

PUBLIC DEF_COM_INT_1
DEF_COM_INT_1 proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook1
IF2
.errnz $ - OFFSET DEF_Handler
ENDIF
DEF_COM_INT_1 endp

DEF_Handler proc far
	push	es
	push	di
	push	ax
	mov	ax, _DATA
	mov	es, ax
	mov	di, es:[di.First_DEB]	    ; ES:DI -> ComDEB
	add	di, SIZE ComDEB 	    ; ES:DI -> BIS
	push	cs
	call	NEAR PTR COMHandler
	pop	ax
	pop	di			    ; ES:DI -> IRQ_Hook_Struc
	jc	short DEF_chain
	pop	es
	pop	di
	add	sp, 4
	iret

DEF_chain:
        call DOCLI
	push	bp
	mov	bp, sp			    ;stack frame:
					    ;	bp+8	-> OldInt CS
					    ;	bp+6	-> OldInt IP
					    ;	bp+4	-> di
					    ;	bp+2	-> es
					    ;	bp+0	-> bp
	les	di, es:[di.OldIntVec]
	mov	[bp+6], di
	mov	[bp+8], es
	pop	bp
	pop	es
	pop	di
	ret				    ; far ret to OldInt handler
DEF_Handler endp

;------------------------------------------------------------------------------
;
;   ENTER:	ES:DI -> BIS
;
;   EXIT:	Carry set, if IRQ not handled by any com ports
;
COMHandler proc far
	push	ds
	push	si
	push	ax
	push	bx
	mov	si, es
	mov	ds, si
	mov	bh, -1
ch_chk_all:
	lea	si, [di-SIZE ComDEB]	;ds:si -> ComDEB
	mov	si, [si.IRQhook]
	mov	si, [si.First_DEB]
	mov	bl, -1
ch_next_com:
	inc	bl			; first time bl = 0
	xor	ax, ax
	xchg	ax, [di.BIS_Mode]
	lea	di, [si+SIZE ComDEB]
	mov	[di.BIS_Mode], ax
	call	CommInt
	and	al, 80h
	or	bl, al

	mov	si, [si.NextDEB]
	or	si, si
	jnz	ch_next_com

	test	bl, 7Fh 		;Q: more than 1 com port?
	jnz	short ch_shared 	;   Y: check if handled
	or	bl, bl			;Q: int handled by port?
	stc
	jns	ch_exit 		;   N:

ch_eoi:
	xor	ax, ax
.errnz BIH_API_EOI
	xor	bx, bx
	xchg	bx, es:[di.BIS_Mode]
	call	es:[bx][di.BIS_User_Mode_API]
	lea	si, [di-SIZE ComDEB]	; ds:si -> ComDEB
	mov	si, [si.IRQhook]
	mov	al, [si.OldMask]
	shr	al, 1			; shift bit 0 into Carry (0, if unmasked
	cmc				;   -1, if originally masked)

ch_exit:
	pop	bx
	pop	ax
	pop	si
	pop	ds
	ret

ch_shared:
	inc	bh			; count loop
	or	bl, bl			;Q: int handled by any port?
	js	ch_chk_all		;   Y: check all ports again
	or	bh, bh			;Q: first time thru loop?
	stc
	jz	ch_exit 		;   Y: int wasn't for a COM port, so
					;      chain to next IRQ handler
	jmp	ch_eoi

COMHandler endp


IFDEF No_DOSX_Bimodal_Services

PUBLIC Entry_From_RM
Entry_From_RM proc far

;
; Simulate the far ret
;
	cld
	lodsw
	mov	es:[di.RealMode_IP], ax
	lodsw
	mov	es:[di.RealMode_CS], ax
	add	es:[di.RealMode_SP], 4

	push	es
	push	di
.286
;
; Push far addr of Ret_To_IRET to cleanup stack and return to DPMI host
;
	push	cs
	push	IntCodeOFFSET Ret_To_IRET
;
; Push far addr of proc to call, so we can do a far ret to it
;
	push	es:[di.RealMode_CX]	; segment of callback
	push	es:[di.RealMode_DX]	; offset of callback
	mov	di, es:[di.RealMode_DI]
	ret				; far ret to cx:dx
					;   called proc will do a far ret
Ret_To_IRET:				; <- to here
	pop	di
	pop	es
	iret
.8086

Entry_From_RM endp

PUBLIC RM_APIHandler
RM_APIHandler proc far
	cmp	ax, BIH_API_Call_Back
	jne	APIHandler
	call	cs:[RM_CallBack]
	ret
RM_APIHandler endp

ENDIF

;------------------------------------------------------------------------------
;
;   ENTER:	ES:DI -> BIS
;
APIHandler proc far

	or	ax, ax
	jnz	short api_not_EOI
.errnz	BIH_API_EOI
	mov	ax, es:[di.BIS_IRQ_Number]
	cmp	al,8			;Q: slave IRQ?
	mov	al,EOI
	jb	short api_master	;   N:
	out	0A0h,al 		;   Y: EOI slave
api_master:
	out	INTA0,al		; EOI master
	ret

api_not_EOI:
	cmp	ax, BIH_API_Call_Back
	jae	short api_callme
	push	dx
	push	cx
	mov	dx, INTA1
	mov	cx,  es:[di.BIS_IRQ_Number]
	cmp	cl, 8			;Q: 2nd PIC?
	jb	@f			;   N:
	mov	dx, 0A1h		;   Y: dx = mask port
	sub	cl, 8
@@:
	cmp	al, BIH_API_Get_Mask	;Q: get IRQ mask?
	jae	api_get_mask		;   Y:
	mov	ah, al
	mov	ch, 1
	shl	ch, cl			; ch = mask byte
	pushf
        call DOCLI
	in	al, dx			; get current PIC mask state
	cmp	ah, BIH_API_Mask	;Q: mask IRQ?
	jne	@f			;   N:
	or	al, ch			;   Y: set IRQ's bit
	jmp	short api_mask_exit
@@:
	not	ch			;   N: clear IRQ's bit to unmask
	and	al, ch
api_mask_exit:
	out	dx, al
	pop	ax
	test	ah, 2			;Q: ints were enabled?
	jz	@f			;   N:
        call DOSTI
@@:
	pop	cx
	pop	dx
	ret

api_get_mask:
	in	al, dx			; get current PIC mask state
	inc	cl
	shr	al, cl			; move IRQ's bit into carry
					; Carry set, if IRQ masked
	pop	cx
	pop	dx
	ret

api_callme:
	push	cx
	push	dx
	ret				; far ret to call back, which will
					; do a far ret to our caller
APIHandler endp


;--------------------------Fake a Hardware Interrupt----------------------;
; FakeCOMInt
;
; This routine fakes a hardware interrupt to IRQ3 or IRQ4
; to clear out characters pending in the buffer
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;
; Registers Destroyed:
;   AX,DX,FLAGS
; History: glenn steffler 5/17/89
;-----------------------------------------------------------------------;

FakeCOMInt proc near

      ; call DOCLI                             ;Done by caller
;
; WARNING: jumping into the middle of CommInt, so the stack must be set
;	   properly.
;
	push	dx
	push	bx
	push	cx
	push	di
	push	es
	push	EvtWord[si]
	mov	dx,Port[si]		;Get device I/O address
	add	dl, ACE_IIDR
	push	dx
	jmp	FakeXmitEmpty		;Process the fake interrupt, DS:SI is
					;  already pointing to proper DEB
;
; FakeXmitEmpty falls in XmitEmpty which jumps back into CommInt.  When CommInt
; determines that no interrupt is pending, then it will near return back to
; FakeCOMIntFar which can far ret back to its caller.
;
FakeCOMInt endp

public	FakeCOMIntFar
FakeCOMIntFar proc far

	call	FakeCOMInt
	ret

FakeCOMIntFar endp

;--------------------------Interrupt Handler----------------------------
;
; CommInt - Interrupt handler for com ports
;
; Interrupt handlers for PC com ports.	This is the communications
; interrupt service routine for RS232 communications.  When an RS232
; event occurs the interrupt vectors here.  This routine determines
; who the caller was and services the appropriate interrupt.  The
; interrupts are prioritized in the following order:
;
;     1.  line status interrupt
;     2.  read data available interrupt
;     3.  transmit buffer empty interrupt
;     4.  modem service interrupt
;
; This routine continues to service until all interrupts have been
; satisfied.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   AL = 0, if not handled, -1, if handled
;
;-----------------------------------------------------------------------

assumes ds,Data
assumes es,nothing

;   Dispatch table for interrupt types

SrvTab label word
	dw	OFFSET ModemStatus	;[0] Modem Status Interrupt
	dw	OFFSET XmitEmpty	;[2] Tx Holding Reg. Interrupt
	dw	OFFSET DataAvail	;[4] Rx Data Available Interrupt
					;   or [C] if 16550 & 16550A
	dw	OFFSET LineStat 	;[6] Reciever Line Status Interrupt


	public	CommInt

CommInt proc near

	xor	al, al
	cmp	word ptr [VCD_int_callback+4], 0
	je	short @F			; jump if no callback (not 3.1 VCD)
	test	[si.VCDflags], fCOM_ignore_ints ;Q: we still own port?
	jnz	IntLoop40			;   N: ignore the int
.386
	push	esi
	mov	esi, [si.VCD_data]
	call	[VCD_int_callback]
	pop	esi
.8086
@@:

	push	dx
	mov	dx,Port[si]		;Get comm I/O port
	add	dl,ACE_IIDR		;--> Interrupt ID Register
	in	al, dx
	test	al, 1			;Q: interrupt pending?
	jnz	short IntLoop30 	;   N:

	push	bx
	push	cx
	push	di
	push	es
	mov	cx, EvtWord[si]
	push	cx
	jmp	short IntLoop10

InterruptLoop_ChkTx:
	cmp	QOutCount[si],0 	;Output queue empty?
	je	short InterruptLoop	;   Y: don't chk tx
	pop	dx
	push	dx
	dec	dx			; to IER
.errnz ACE_IIDR - ACE_IER - 1
	in	al, dx
	and	al,NOT ACE_ETBEI	; disable it
	iodelay
	out	dx, al
	or	al, ACE_ETBEI		; enable it again
	iodelay
	out	dx, al
	iodelay
	out	dx, al

InterruptLoop:
	pop	dx			;Get ID reg I/O address

	in	al,dx			;Get Interrupt Id
	test	al,1			;Interrupt need servicing?
	jnz	IntLoop20		;No, all done

IntLoop10:
	and	ax, 07h
	mov	di,ax
	push	dx			;Save Id register
	jmp	SrvTab[di]		;Service the Interrupt

IntLoop20:
	mov	ax,EvtMask[si]		;Mask the event word to only the
	and	ax, EvtWord[si] 	;  user specified bits
	mov	EvtWord[si], ax
	pop	bx
	test	[si.NotifyFlagsHI], CN_Notify
	jz	short ci_exit
	not	bx
	and	ax, bx			; bits set in ax are new events
	jnz	short ci_new_events

ci_exit:
	pop	es
	assumes es,nothing

	pop	di
	pop	cx
	pop	bx
	xor	al, al

IntLoop30:
	pop	dx
	and	al, 1
	dec	al			; 0->-1, 1->0
IntLoop40:
	ret

ci_new_events:
	mov	ax, CN_EVENT
	call	notify_owner
	jmp	ci_exit

CommInt endp

page

;----------------------------Private-Routine----------------------------;
;
; LineStat - Line Status Interrupt Handler
;
; Break detection is handled and set in the event word if
; enabled.  Other errors (overrun, parity, framing) are
; saved for the data available interrupt.
;
; This routine used to fall into DataAvail for the bulk of its processing.
; This is no longer the case...  A very popular internal modem seems to
; operate differently than a real 8250 when parity errors occur.  Falling
; into the DataAvail handler on a parity error caused the same character
; to be received twice.  Having this routine save the LSR status, and
; return to InterruptLoop fixes the problem, and still works on real COMM
; ports.  The extra overhead isn't a big deal since this routine is only
; entered when there is an exception like a parity error.
;
; This routine is jumped to, and will perform a jump back into
; the dispatch loop.
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,FLAGS
; History:
;-----------------------------------------------------------------------;


; assumes ds,Data
assumes es,nothing

public LineStat 			;Public for debugging
LineStat proc near

	or	by EvtWord[si],EV_Err	;Show line status error

	add	dl,ACE_LSR-ACE_IIDR	;--> Line Status Register
	in	al,dx
	test	al,ACE_PE+ACE_FE+ACE_OR ;Parity, Framing, Overrun error?
	jz	@f

	mov	LSRShadow[si],al	;yes, save status for DataAvail
@@:
	test	al,ACE_BI		;Break detect?
	jz	InterruptLoop_ChkTx	;Not break detect interrupt

	or	by EvtWord[si],EV_Break ;Show break

	jmp	short InterruptLoop_ChkTx

LineStat   endp

page

;----------------------------Private-Routine----------------------------;
;
; DataAvail - Data Available Interrupt Handler
;
; The available character is read and stored in the input queue.
; If the queue has reached the point that a handshake is needed,
; one is issued (if enabled).  EOF detection, Line Status errors,
; and lots of other stuff is checked.
;
; This routine is jumped to, and will perform a jump back into
; the dispatch loop.
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

; assumes ds,Data
assumes es,nothing

public DataAvail                       ;public for debugging
DataAvail   proc   near

	sub	dl,ACE_IIDR-ACE_RBR	;--> receiver buffer register
	in	al,dx			;Read received character

	and	[si.NotifyFlagsHI], NOT CN_Idle ; flag as not idle

	mov	ah,LSRShadow[si]	;what did the last Line Status intrpt
	mov	bh,ah			;  have to say?
	or	ah,ah
	jz	@f

	and	ah,ErrorMask[si]	;there was an error, record it
	or	by ComErr[si],ah
	mov	LSRShadow[si],0
	.errnz	ACE_OR-CE_OVERRUN	;Must be the same bits
	.errnz	ACE_PE-CE_RXPARITY
	.errnz	ACE_FE-CE_FRAME
	.errnz	ACE_BI-CE_BREAK
@@:

; Regardless of the character received, flag the event in case
; the user wants to see it.

	or	by EvtWord[si],EV_RxChar ;Show a character received
	.errnz HIGH EV_RxChar

; Check the input queue, and see if there is room for another
; character.  If not, or if the end of file character has already
; been received, then go declare overflow.

DataAvail00:

	mov	cx,QInCount[si] 	;Get queue count (used later too)
	cmp	cx,QInSize[si]		;Is queue full?
	jge	DataAvail20		;  Yes, comm overrun
	test	EFlags[si],fEOF 	;Has end of file been received?
	jnz	DataAvail20		;  Yes - treat as overflow

; Test to see if there was a parity error, and replace
; the character with the parity character if so

	test	bh,ACE_PE		;Parity error
	jz	DataAvail25		;  No
	test	[si.DCB_Flags2],fPErrChar   ;Parity error replacement character?
	jz	DataAvail25		;  No
	mov	al,[si.DCB_PEChar]	;  Yes, get parity replacement char

; Skip all other processing except event checking and the queing
; of the parity error replacement character

	jmp	short DataAvail80	;Skip all but event check, queing

DataAvail20:
	or	by ComErr[si],CE_RXOVER ;Show queue overrun
	jmp	short DataAvail50

; See if we need to strip null characters, and skip
; queueing if this is one.  Also remove any parity bits.

DataAvail25:
	and	al,RxMask[si]		;Remove any parity bits
	jnz	DataAvail30		;Not a Null character
	test	[si.DCB_Flags2],fNullStrip  ;Are we stripping received nulls?
	jnz	DataAvail50		;  Yes, put char in the bit bucket

; Check to see if we need to check for EOF characters, and if so
; see if this character is it.

DataAvail30:
	test	[si.DCB_Flags],fBinary	;Is this binary stuff?
	jnz	DataAvail60		;  Yes, skip EOF check
	cmp	al,[si.DCB_EOFChar]	;Is this the EOF character?
	jnz	DataAvail60		;  No, see about queing the charcter
	or	EFlags[si],fEOF 	;Set end of file flag
DataAvail50:
	jmp	DataAvail140		;Skip the queing process

; If output XOn/XOff is enabled, see if the character just received
; is either an XOn or XOff character.  If it is, then set or
; clear the XOffReceived flag as appropriate.

DataAvail60:
	test	[si.DCB_Flags2],fOutX	;Output handshaking?
	jz	DataAvail80		;  No
	cmp	al,[si.DCB_XoffChar]	;Is this an X-Off character?
	jnz	DataAvail70		;  No, see about XOn or Ack
	or	HSFlag[si],XOffReceived ;Show XOff received, ENQ or ETX [rkh]
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	DataAvail50		;  No
	cmp	cx,[si.DCB_XonLim]	;See if at XOn limit
	ja	DataAvail50		;  No
	and	HSFlag[si],NOT XOffReceived ;Show ENQ or ETX not received
	and	HSFlag[si], NOT XOnPending+XOffSent
	mov	al, [si.DCB_XonChar]
	call	OutHandshakingChar
	jmp	DataAvail50		;Done

DataAvail70:
	cmp	al,[si.DCB_XonChar]	;Is this an XOn character?
	jnz	DataAvail80		;  No, just a normal character
	and	HSFlag[si],NOT XOffReceived
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	DataAvail75		;  No - jump to FakeXmitEmpty to get
					;	transmitting going again
	and	HSFlag[si],NOT EnqSent

DataAvail75:
	jmp	FakeXmitEmpty		;Restart transmit

; Now see if this is a character for which we need to set an event as
; having occured. If it is, then set the appropriate event flag


DataAvail80:
	cmp	al,[si.DCB_EVTChar]	;Is it the event generating character?
	jne	DataAvail90		;  No
	or	by EvtWord[si],EV_RxFlag   ;Show received specific character

; Finally, a valid character that we want to keep, and we have
; room in the queue. Place the character in the queue.
; If the discard flag is set, then discard the character

DataAvail90:
	test	MiscFlags[si], Discard	;Discarding characters ?
	jnz	DataAvail50		;  Yes

	lea	bx, [si+SIZE ComDEB]	; DS:BX -> BIS
	mov	bx, [bx.BIS_Mode]	; mode will be either 0 or 4
	les	di,QInAddr[si][bx]	;Get queue base pointer from either
	assumes es,nothing		;   QInAddr or AltQInAddr

	mov	bx,QInPut[si]		;Get index into queue
	mov	es:[bx][di],al		;Store the character
	inc	bx			;Update queue index
	cmp	bx,QInSize[si]		;See if time for wrap-around
	jc	DataAvail100		;Not time to wrap
	xor	bx,bx			;Wrap-around is a new zero pointer

DataAvail100:
	mov	QInPut[si],bx		;Store updated pointer
	inc	cx			;And update queue population
	mov	QInCount[si],cx

; If flow control has been enabled, see if we are within the
; limit that requires us to halt the host's transmissions

	cmp	cx,XOffPoint[si]	;Time to see about XOff?
	jc	DataAvail120		;  Not yet
	test	HSFlag[si],HSSent	;Handshake already sent?
	jnz	DataAvail120		;  Yes, don't send it again

	mov	ah,HHSLines[si] 	;Should hardware lines be dropped?
	or	ah,ah			;  (i.e. do we have HW HS enabled?)
	jz	DataAvail110		;  No
	add	dl,ACE_MCR		;  Yes
	in	al,dx			;Clear the necessary bits
	not	ah
	and	al,ah
	or	HSFlag[si],HHSDropped	;Show lines have been dropped
	out	dx,al			;  and drop the lines
	sub	dl,ACE_MCR

DataAvail110:
	test	[si.DCB_Flags2],fInX	;Input Xon/XOff handshaking
	jz	DataAvail120		;  No
	or	HSFlag[si], XOffSent
	mov	al, [si.DCB_XoffChar]
	call	OutHandshakingChar

DataAvail120:
	cmp	cx, [si.RecvTrigger]	;Q: time to call owner's callback?
	jb	short DataAvail130	;   N:

	test	[si.NotifyFlagsHI], CN_RECEIVE
	jnz	short DataAvail140	; jump if notify already sent and
					;   data in buffer hasn't dropped
					;   below threshold
	mov	ax, IntCodeOFFSET DataAvail140
	push	ax
	mov	ax, CN_RECEIVE
%OUT probably should just set a flag and notify after EOI
	jmp	notify_owner

DataAvail130:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE

DataAvail140:
	pop	dx
	push	dx
	add	dl, ACE_LSR-ACE_IIDR
	in	al, dx
	test	al, ACE_DR		;Q: more data available?
	jz	@F			;   N:
	sub	dl, ACE_LSR		;   Y: go read it
	in	al, dx			;Read available character
	jmp	DataAvail00
@@:
	jmp	InterruptLoop_ChkTx

DataAvail endp


OutHandshakingChar proc near

	add	dl, ACE_LSR
	mov	ah, al
@@:
	in	al, dx
	test	al, ACE_THRE
	jz	@B
	sub	dl, ACE_LSR
	mov	al, ah
	out	dx, al
	ret

OutHandshakingChar endp


page

;----------------------------Private-Routine----------------------------;
;
; XmitEmpty - Transmitter Register Empty
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

; assumes ds,Data
assumes es,nothing

public FakeXmitEmpty
FakeXmitEmpty:
	pop	dx
	push	dx

; "Kick" the transmitter interrupt routine into operation.

	dec	dl
.errnz ACE_IIDR - ACE_IER-1
	in	al,dx			;Get current IER state
	test	al,ACE_ETBEI		;Interrupt already enabled?
	jnz	@F			;  Yes, don't reenable it
	or	al,ACE_ETBEI		;  No, enable it
	out	dx,al
	iodelay 			;8250, 8250-B bug requires
	out	dx,al			;  writting register twice
@@:
	add	dl,ACE_LSR-ACE_IER	;--> Line Status Register
	iodelay
	in	al,dx			;Is xmit really empty?
	sub	dl,ACE_LSR-ACE_THR	;--> Transmitter Holding Register
	test	al,ACE_THRE
	jnz	short XmitEmpty5	;   Y: send next char
	jmp	InterruptLoop		;   N: return to processing loop

public XmitEmpty
XmitEmpty proc near

	add	dl,ACE_LSR-ACE_IIDR	;--> Line Status Register
	in	al,dx			;Is xmit really empty?
	sub	dl,ACE_LSR-ACE_THR	;--> Transmitter Holding Register
	test	al,ACE_THRE
	jz	Xmit_jumpto90		;Transmitter not empty, cannot send

; If the hardware handshake lines are down, then XOff/XOn cannot
; be sent.  If they are up and XOff/XOn has been received, still
; allow us to transmit an XOff/XOn character.  It will make
; a dead lock situation less possible (even though there are
; some which could happen that cannot be handled).

XmitEmpty5:
	mov	ah,HSFlag[si]		;Get handshaking flag
	test	ah,HHSDown+BreakSet	;Hardware lines down or break set?
	jnz	Xmit_jumpto100		;  Yes, cannot transmit

; Give priority to any handshake character waiting to be
; sent.  If there are none, then check to see if there is
; an "immediate" character to be sent.  If not, try the queue.

XmitEmpty10:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jnz	XmitEmpty40		;  Yes

XmitEmpty15:
	test	ah,HSPending		;XOff or XOn pending
	jz	XmitEmpty40		;  No

XmitEmpty20:
	and	ah,NOT XOnPending+XOffSent
	mov	al,[si.DCB_XonChar]	;Get XOn character

XmitEmpty30:
	mov	HSFlag[si],ah		;Save updated handshake flag
	jmp	XmitEmpty110		;Go output the character

Xmit_jumpto90:
	jmp	XmitEmpty90

; If any of the lines which were specified for a timeout are low, then
; don't send any characters.  Note that by putting the check here,
; XOff and Xon can still be sent even though the lines might be low.

; Also test to see if a software handshake was received.  If so,
; then transmission cannot continue.  By delaying the software check
; to here, XOn/XOff can still be issued even though the host told
; us to stop transmission.

XmitEmpty40:
	test	ah,CannotXmit		;Anything preventing transmission?
	jz	XmitEmpty45		;  No
Xmit_jumpto100:
	jmp	XmitEmpty100		;  Yes, disarm and exit

; If a character has been placed in the single character "transmit
; immediately" buffer, clear that flag and pick up that character
; without affecting the transmitt queue.

XmitEmpty45:
	test	EFlags[si],fTxImmed	;Character to xmit immediately?
	jz	XmitEmpty515		;  No, try the queue
	and	EFlags[si],NOT fTxImmed ;Clear xmit immediate flag
	mov	al,ImmedChar[si]	;Get char to xmit
	jmp	XmitEmpty110		;Transmit the character

XmitEmpty515:
	mov	cx,QOutCount[si]	;Output queue empty?
	jcxz	Xmit_jumpto90		;  Yes, go set an event

	test	[si.DCB_Flags],fEtxAck	;Etx Ack?
	jz	XmitEmpty55		;  No
	mov	cx,QOutMod[si]		;Get number bytes sent since last ETX
	cmp	cx,[si.DCB_XonLim]	;At Etx limit yet?
	jne	XmitEmpty51		;  No, inc counter
	mov	QOutMod[si],0		;  Yes, zero counter
	or	HSFlag[si],EtxSent	;Show ETX sent
	jmp	short XE_sendXOFF

XmitEmpty51:
	inc	cx			; Update counter
	mov	QOutMod[si],cx		; Save counter
	jmp	short XmitEmpty59	; Send queue character

XmitEmpty55:
	test	[si.DCB_Flags],fEnqAck	;Enq Ack?
	jz	XmitEmpty59		;  No, send queue character
	mov	cx,QOutMod[si]		;Get number bytes sent since last ENQ
	or	cx,cx			;At the front again?
	jnz	XmitEmpty56		;  No, inc counter
	mov	QOutMod[si],1		;  Yes, send ENQ
	or	HSFlag[si],EnqSent	;Show ENQ sent
XE_sendXOFF:
	mov	al,[si.DCB_XoffChar]
	jmp	short XmitEmpty110	;Go output the character

XmitEmpty56:
	inc	cx			;Update counter
	cmp	cx,[si.DCB_XonLim]	;At end of our out buffer len?
	jne	XmitEmpty58		;  No
	xor	cx,cx			;Show at front again.

XmitEmpty58:
	mov	QOutMod[si],cx		;Save counter

XmitEmpty59:
	lea	bx, [si+SIZE ComDEB]	; DS:BX -> BIS
	mov	bx, [bx.BIS_Mode]	; mode will be either 0 or 4
	les	di,QOutAddr[si][bx]	;Get queue base pointer from either
	assumes es,nothing		;   QOutAddr or AltQOutAddr

	mov	bx,QOutGet[si]		;Get pointer into queue
	mov	al,es:[bx][di]		;Get the character

	inc	bx			;Update queue pointer
	cmp	bx,QOutSize[si] 	;See if time for wrap-around
	jc	XmitEmpty60		;Not time for wrap
	xor	bx,bx			;Wrap by zeroing the index

XmitEmpty60:
	mov	QOutGet[si],bx		;Save queue index
	mov	cx,QOutCount[si]	;Output queue empty?
	dec	cx			;Dec # of bytes in queue
	mov	QOutCount[si],cx	;  and save new population

	out	dx,al			;Send char

	cmp	cx, [si.SendTrigger]	;Q: time to call owner's callback?
	jae	short XmitEmpty70	;   N:

	test	[si.NotifyFlagsHI], CN_TRANSMIT
	jnz	short XmitEmpty80	; jump if notify already sent and
					;   data in buffer hasn't raised
					;   above threshold
	mov	ax, IntCodeOFFSET XmitEmpty80
	push	ax
	mov	ax, CN_TRANSMIT
	jmp	short notify_owner

XmitEmpty70:
	and	[si.NotifyFlagsHI], NOT CN_TRANSMIT

XmitEmpty80:
%OUT check fNoFIFO in EFlags[si] to determine if we can queue more output
	jmp	InterruptLoop


; No more characters to transmit.  Flag this as an event.

XmitEmpty90:
	or	by EvtWord[si],EV_TxEmpty

; Cannot continue transmitting (for any of a number of reasons).
; Disable the transmit interrupt.  When it's time resume, the
; transmit interrupt will be reenabled, which will generate an
; interrupt.

XmitEmpty100:
	inc	dx			;--> Interrupt Enable Register
	.errnz	ACE_IER-ACE_THR-1
	in	al,dx			;I don't know why it has to be read
	and	al,NOT ACE_ETBEI	;  first, but it works this way
XmitEmpty110:
	out	dx,al
	jmp	InterruptLoop

XmitEmpty endp

page

;----------------------------Private-Routine----------------------------;
;
; ModemStatus - Modem Status Interrupt Handler
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;


; assumes ds,Data
assumes es,nothing

public ModemStatus                     ;Public for debugging
ModemStatus proc near

; Get the modem status value and shadow it for MSRWait.

	add	dl,ACE_MSR-ACE_IIDR	;--> Modem Status Register
	in	al,dx
	mov	MSRShadow[si],al	;Save MSR data for others
	mov	ch,al			;Save a local copy

; Create the event mask for the delta signals

	mov	ah,al			;Just a lot of shifting
	shr	ax,1
	shr	ax,1
	shr	ah,1
	mov	cl,3
	shr	ax,cl
	and	ax,EV_CTS+EV_DSR+EV_RLSD+EV_Ring
	or	EvtWord[si],ax

	mov	ah,ch				       ;[rkh]...
	shr	ah,1
	shr	ah,1
	and	ax,EV_CTSS+EV_DSRS
	or	EvtWord[si],ax

	mov	ah,ch
	mov	cl,3
	shr	ah,cl
	and	ax,EV_RLSD
	or	EvtWord[si],ax

	mov	ah,ch
	mov	cl,3
	shl	ah,cl
	and	ax,EV_RingTe
	or	EvtWord[si],ax

	.errnz	   EV_CTS-0000000000001000b
	.errnz	   EV_DSR-0000000000010000b
	.errnz	  EV_RLSD-0000000000100000b
	.errnz	  EV_Ring-0000000100000000b

	.errnz	    EV_CTSS-0000010000000000b	    ;[rkh]
	.errnz	    EV_DSRS-0000100000000000b
	.errnz	   EV_RLSDS-0001000000000000b
	.errnz	  EV_RingTe-0010000000000000b

	.errnz	 ACE_DCTS-00000001b
	.errnz	 ACE_DDSR-00000010b
	.errnz	ACE_DRLSD-00001000b
	.errnz	   ACE_RI-01000000b

	.errnz	 ACE_TERI-00000100b		    ;[rkh]
	.errnz	  ACE_CTS-00010000b
	.errnz	  ACE_DSR-00100000b
	.errnz	 ACE_RLSD-10000000b

ModemStatus10:
	mov	al,OutHHSLines[si]	;Get output hardware handshake lines
	or	al,al			;Any lines that must be set?
	jz	ModemStatus40		;No hardware handshake on output
	and	ch,al			;Mask bits of interest
	cmp	ch,al			;Lines set for Xmit?
	je	ModemStatus20		;  Yes
	or	HSFlag[si],HHSDown	;Show hardware lines have dropped
ModemStatus30:
	jmp	InterruptLoop

ModemStatus40:
	jmp	InterruptLoop_ChkTx

; Lines are set for xmit.  Kick an xmit interrupt if needed

ModemStatus20:
	and	HSFlag[si],NOT (HHSDown OR HHSAlwaysDown)
					;Show hardware lines back up
	mov	cx,QOutCount[si]	;Output queue empty?
	jcxz	ModemStatus30		;  Yes, return to InterruptLoop
	jmp	FakeXmitEmpty		;Restart transmit

ModemStatus endp

page

;------------------------------------------------------------------------------
;
;   ENTER:  AX = message #
;	    DS:SI -> DEB
notify_owner proc near

	or	[si.NotifyFlags], ax
	lea	di, [si+SIZE ComDEB]
	mov	ax, ds
	mov	es, ax
	mov	ax, BIH_API_Call_Back	; call immediate, or in protected mode
	mov	bx, 1			; force SYS VM, if enhanced mode
	mov	cx, _INTERRUPT
	mov	dx, IntCodeOFFSET callback_event
%OUT use equate
	push	ds
	push	si
	mov	si, 1			; low priority boost
	push	bp
	mov	bp, es:[di.BIS_Mode]
	call	es:[bp][di.BIS_User_Mode_API]
	pop	bp
	pop	si
	pop	ds
	ret

notify_owner endp

;------------------------------------------------------------------------------
;
;   ENTER:  ES:DI -> BIS
;
callback_event proc far
	lea	si, [di-SIZE ComDEB]
	mov	ax, es
	mov	ds, ax
	mov	ax, [si.NotifyHandle]
	push	ax			; push hWnd
	mov	ax, WM_COMMNOTIFY
	push	ax			; push wMsg
	xor	ax, ax
	mov	al, [si.DCB_Id]
	push	ax			; push wParam = ComID
	xor	al, al
	push	ax			; push high word of lParam
	xchg	al, [si.NotifyFlagsLO]
	or	[si.NotifyFlagsHI], al
	push	ax			; push low word of lParam = event flags
	call	[lpPostMessage]
	ret
callback_event endp


PUBLIC TimerProc
TimerProc proc far

	push	ds
	mov	ax, _DATA
	mov	ds, ax
	assumes ds,data

	mov	ax, [activeCOMs]
	or	ax, ax
	jz	short tp_nonactive
	push	si
	mov	si, DataOFFSET COMptrs
	mov	cx, MAXCOM+1
tp_lp:
	push	si
	mov	si, [si]		; si -> ComDEB
	shr	ax, 1
	jnc	tp_lpend

	cmp	[si.RecvTrigger], -1	;Q: owner wants notification?
	je	short tp_lpend		;   N: skip notify
	cmp	[si.QInCount], 0	;Q: anything in input queue?
	je	short tp_lpend		;   N: skip notify
	test	[si.NotifyFlagsHI], CN_RECEIVE ;Q: timeout notify already given?
	jnz	short tp_lpend		;   N: skip notify

	xor	[si.NotifyFlagsHI], CN_Idle ;Q: first timer call?
	js	short tp_lpend		;   Y: skip notify

	push	ax
	push	cx
	mov	ax, CN_RECEIVE		;   N: notify owner
	call	notify_owner
	pop	cx
	pop	ax

tp_lpend:
	pop	si
	inc	si			; inc to ptr to next ComDEB
	inc	si
	or	ax, ax
	loopnz	tp_lp
	pop	si

tp_nonactive:
	pop	ds
	assumes ds,nothing
	ret

TimerProc endp
page

ifdef DEBUG
	public	Control, DEF_Handler, COMHandler, APIHandler
	public	InterruptLoop, IntLoop10, IntLoop20
	public	DataAvail25, DataAvail30, DataAvail50
	public	DataAvail60, DataAvail70, DataAvail80, DataAvail90
	public	DataAvail100, DataAvail110, DataAvail120
	public	DataAvail130, DataAvail140, OutHandshakingChar
	public	XmitEmpty10, XmitEmpty20, XmitEmpty30, XmitEmpty40
	public	XmitEmpty59, XmitEmpty60
	public	XmitEmpty90, XmitEmpty100, XmitEmpty110
	public	ModemStatus10, ModemStatus20, ModemStatus30
	public	notify_owner, callback_event
endif

DOSTI proc    near
      FSTI
      ret
DOSTI endp

DOCLI proc    near
      FCLI
      ret
DOCLI endp



sEnd   IntCode
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\ibmcom1.asm ===
page

;---------------------------Module-Header-------------------------------;
; Module Name: IBMCOM1.ASM
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
;----------------------------Private-Routine----------------------------;
;
; DoLPT - Do Function To LPT port
;
; The given function (output or reset) is performed to the
; passed LPT port.
;
; Before a character is sent, a check is made to see if the device
; will be able to accept the character.  If it can, then the character
; will be sent.  If not, then an error will be returned.  If the
; printer is selected and busy and no error, then the code returned
; will be CE_TXFULL and the handshake bits will be set in HSFlag
; to simulate that a handshake was received.
;
; If the BIOS ROM code is examined, you will note that they wait for
; the busy character from the last charcater to be cleared before
; they strobe in the current character.  This can take a long time
; on the standard EPSON class printer (1 mSec to greater than
; 300 mSec if the last character actually caused printing).
;
; Because of this, several status read retrys will be made before
; declaring that the device is actually busy.  If only one status
; read is performed, the spooler will yeild, take a while to get
; back here, and things will be really slow.  What difference does
; it really make if we or the BIOS does the delay, at least we can
; break out of it at some point when it seems hopeless.
;
;   The OKIHACK: Okidata reports a 50 ns. 2.2 volt pulse on the paper
;   out signal on the trailing edge of the Busy signal.  If we see this
;   glitch then we report paper out.  So we try to get the status twice...
;   if it changes between the two tries we keep getting the status.
;   
;
; Entry:
;   AH    =  cid
;   AL    =  character to output
;   CH	  =  Function request.	0 = Output, 1 = Initialize, 2 = Status
;   DS:SI -> DEB for the port
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;       sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;               FCLI/FSTI macros
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;


   assumes ds,Data
   assumes es,nothing

include vint.inc

externFP OutputDebugString

dbmsg	macro	msg
.286
push	cs
push	offset $ + 3 + 5 + 2	; push + far call + short jump
call	OutputDebugString
jmp	short @F
	db  msg,13,10,0
@@:
endm

iodelay macro
	jmp	$+2
	jmp	$+2
endm

   public DoLPT 	;Publics for debugging
   public LPT_Reset
   public LPT_Outchar
   public LPT_Strobe
   public LPT_GetStatus
   public DoLPT40

; status bit defines

L_BITS	      equ     0F8h		  ; the status bits we want
L_BITS_INVERT equ     048h		  ; must invert to match BIOS
L_DEVBUSY     equ     080h		  ; device busy bit
L_TIMEOUT     equ     001h		  ; timeout bit

; control bit defines

L_NORMAL      equ     00Ch		  ; normal state: selected, no reset
L_RESET       equ     008h		  ; reset state
L_STROBE      equ     00Dh		  ; tell printer we have char

DoLPT   proc   near

	mov	dx,Port[si]		;Get port address

;   DX = port address
;   CH = operation: 0 = write, 1 = init, 2 = status
;   AL = character

	or	ch, ch
	jz	LPT_OutChar
	cmp	ch, 1
	jz	LPT_Reset
	jmp	LPT_GetStatus
	ret

LPT_Reset:

	inc	dx
	inc	dx
	mov	al, L_RESET
	iodelay
	out	dx, al

	push	dx

	cCall	GetSystemMsecCount
	mov	bx, ax

LPT_ResetDelay:
	push	bx
	cCall	GetSystemMsecCount
	pop	bx
	sub	ax, bx
	cmp	ax, 300 		; 1/3 sec as good as any
	jbe	LPT_ResetDelay

	pop	dx

	mov	al, L_NORMAL
	iodelay
	iodelay
	out	dx, al
	dec	dx
	dec	dx
	jmp	LPT_GetStatus

LPT_OutChar:
	push	ax			; save character to be written

	; first check to see if printer is ready for us
	push	di

	push	dx
	call	GetSystemMSecCount
	mov	di, ax
	pop	dx

LPT_WaitReady:

	inc	dx			; point to status port
	iodelay
	in	al, dx			; get status bits
	and	al, L_BITS	      ; mask unused ones
	xor	al, L_BITS_INVERT     ; flip a couple
	xchg	al, ah

ifndef NOOKIHACK
	iodelay
	in	al, dx

	dec	dx

	and	al, L_BITS
	xor	al, L_BITS_INVERT
	cmp	al, ah			; did any bits change?
	jnz	LPT_WaitReady
else
	dec	dx
endif


	test	ah, PS_PaperOut or PS_IOError
	jnz	LPT_PrinterNotReady
	test	ah, PS_Select
	jz	LPT_PrinterNotReady
	test	ah, PS_NotBusy
	jnz	LPT_PrinterReady

	push	ax
	push	dx
	call	GetSystemMSecCount
	pop	dx
	pop	bx
	sub	ax, di
	cmp	ax, 300 	       ; 1/3 sec timeout

	jbe	LPT_WaitReady

;       The device seems to be selected and powered up, but is just
;       busy (some printers seem to show selected but busy when they
;       are taken offline).  Show that the transmit queue is full and
;       that the hold handshakes are set.  This is so the windows
;	spooler will retry (and do yields so that other apps may run).


	or	ComErr[si],CE_TXFULL	;Show queue full
	mov	ah,bh
	or	ah, L_TIMEOUT

LPT_PrinterNotReady:

	pop	di
	pop	cx			; throw away character
	jmp	LPT_ReturnStatus

LPT_PrinterReady:
	pop	di			; get di back
	pop	ax			; get character back

	iodelay
	out	dx, al			; write character to port

	inc	dx			; access status port

LPT_Strobe:
	inc	dx			; control port
	mov	al, L_STROBE	      ; set strobe high
	iodelay
	iodelay
	iodelay
	iodelay
	out	dx, al			;   ...

	mov	al, L_NORMAL	      ;
	iodelay
	iodelay
	iodelay
	iodelay
	out	dx, al			; set strobe low

	sub	dx, 2			; point back to port base

	; FALL THRU

LPT_GetStatus:
	inc	dx			; point to status port
LPT_GS1:
	iodelay
	iodelay
	in	al, dx			; get status bits
	and	al, L_BITS	      ; mask unused ones
	xor	al, L_BITS_INVERT     ; flip a couple
	mov	ah, al

ifndef NOOKIHACK
	in	al, dx
	and	al, L_BITS
	xor	al, L_BITS_INVERT
	cmp	al, ah
	jnz	LPT_GS1 	; if they changed try again...
endif

LPT_ReturnStatus:

	assumes ds,Data
        and     ax,(PS_PaperOut+PS_Select+PS_IOError+PS_Timeout)*256
        shr     ah,1
        adc     ah,al                   ;Get back Timeout bit
        xor     ah,HIGH CE_DNS          ;Invert selected bit
   .errnz   LOW CE_DNS
        or      by ComErr+1[si],ah      ;Save comm error
        ret

   .errnz   CE_PTO-0200h
   .errnz   CE_IOE-0400h
   .errnz   CE_DNS-0800h
   .errnz   CE_OOP-1000h

DoLPT40:
	assumes ds,Data
        or      ComErr[si],CE_TXFULL    ;Show queue full
        ret

DoLPT   endp
page

;----------------------------Private-Routine----------------------------;
;
; TXI - Transmit A Character Immediately
;
; Set up a character to be transmitted "immediately".
; by placing the character in a location that guarantees
; it to be the next character transmitted.
;
; The check to see if the immediate character can be placed has
; already been made prior to entry.
;
; Interrupts must be disabled before entering this code
;
; Entry:
;   AH = Character
;   DS:SI --> DEB
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AL,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   TXI         ;Public for debugging
TXI   proc   near

;        FCLI                           ;Must be done by caller!
         or       EFlags[si],fTxImmed  ;Show char to xmit
         mov      ImmedChar[si],ah     ;Set character to transmit next
;        jmp      short KickTx         ;Kick Xmit just in case
         errn$    KickTx

TXI   endp
page

;----------------------------Private-Routine----------------------------;
;
; KickTx - Kick Transmitter
;
; "Kick" the transmitter interrupt routine into operation.
; If the Transmitter Holding Register isn't empty, then
; nothing needs to be done.  If it is empty, then the xmit
; interrupt needs to enabled in the IER.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   KickTx                        ;Public for debugging
KickTx   proc   near

;        FCLI                           ;Done by caller
         mov   dx,Port[si]             ;Get device I/O address
         add   dl,ACE_LSR              ;Point at the line status reg
         pin   al,dx                   ;And get it
         and   al,ACE_THRE             ;Check transmitter holding reg status
         jz    KickTx10                ;Busy, interrupt will hit soon enough

         sub   dl,ACE_LSR-ACE_IER      ;--> Interrupt enable register
         pin   al,dx                   ;Get current IER state
         test  al,ACE_THREI            ;Interrupt already enabled?
         jnz   KickTx10                ;  Yes, don't reenable it
         or    al,ACE_THREI            ;  No, enable it
         pout  dx,al
         pause                         ;8250, 8250-B bug requires
         pout   dx,al                  ;  writting register twice

KickTx10:
;       FSTI                             ;Done by caller
         ret

KickTx   endp
page

;----------------------------Private-Routine----------------------------;
;
; GetDEB - Get Pointer To Device's DEB
;
; Returns a pointer to appropriate DEB, based on device number.
;
; Entry:
;   AH = cid
; Returns:
;   'C' clear
;   'S' set if LPT device
;   DS:SI --> DEB is valid cid
;   AH     =  cid
; Error Returns:
;   'C' set if error (cid is invalid)
;   AX = 8000h
; Registers Preserved:
;   BX,CX,DX,DI,DS,ES
; Registers Destroyed:
;   AX,SI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public GetDEB                          ;Public for debugging
GetDEB proc near

         cmp   ah,LPTx+MAXLPT          ;Within range?
         ja    GetDEB30                ;No, return invalid ID
         mov   si,DataOFFSET LPT3      ;Assume LPT3
         je    GetDEB10                ;It's LPT3
         cmp   ah,MAXCOM               ;Is cid within range for a com port?
         ja    GetDEB20                ;  No, check for a LPT port 1 and 2
         mov   si,DataOFFSET Comm4     ;Assume COM4 [rkh] ...
         je    GetDEB10                ;It was COM4
         mov   si,DataOFFSET Comm3     ;Assume COM3
         cmp   ah,MAXCOM-1             ;Is cid within range for a com port?
         je    GetDEB10                ;It was COM3
         mov   si,DataOFFSET Comm2     ;Assume COM2
         cmp   ah,MAXCOM-2             ;Is cid within range for a com port?
         je    GetDEB10                ;It was COM2
         mov   si,DataOFFSET Comm1     ;It was COM1

GetDEB10:
         or    ah,ah                   ;Set 'S' if LPT, clear 'C'
         ret
         .errnz LPTx-10000000b

GetDEB20:
         mov   si,DataOFFSET LPT1      ;Assume LPT1
         cmp   ah,LPTx
         je    GetDEB10                ;Its LPT1
         mov   si,DataOFFSET LPT2      ;Assume LPT2
         ja    GetDEB10                ;Its LPT2

GetDEB30:
         mov   ax,8000h                ;Set error code
         stc                           ;Set 'C' to show error
         ret

GetDEB endp

page

;----------------------------Public Routine-----------------------------;
;
; $SETQUE - Set up Queue Pointers
;
; Sets pointers to Receive and Transmit Queues, as provided by the
; caller, and initializes those queues to be empty.
;
; Queues must be set before $INICOM is called!
;
; Entry:
;   AH     =  Device ID
;   ES:BX --> Queue Definition Block
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = error code
; Registers Preserved:
;   BX,DX,SI,DI,DS
; Registers Destroyed:
;   AX,CX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $SETQUE
$SETQUE proc near

         push  si                      ;These will be used
         push  di
         call  GetDEB                  ;Get DEB
         jc    SetQue10                ;Invalid, ignore the call
         js    SetQue10                ;Ignore call for LPT ports
         push  ds                      ;Set ds:si --> QDB
         push  es                      ;Set es:di --> to ComDCB.QInAddr
         pop   ds
         assumes ds,nothing
         pop   es
         assumes es,Data
         lea   di,QInAddr[si]
         mov   si,bx
         mov   cx,(SIZE QDB)/2
         .errnz (SIZE QDB) AND 1
         xor   ax,ax                   ;Will do some zero filling
         cld
         FCLI                           ;No one else can play with queues
         rep   movsw
         mov   cl,(EFlags-QInCount)/2
         .errnz (EFlags-QInCount) AND 0FE01h
         rep   stosw
         FSTI
         push  es                      ;Restore the data segment
         pop   ds
         assumes ds,Data
         assumes es,nothing

SetQue10:
         pop   di                      ;Restore saved registers
         pop   si
         ret

; The above code made a few assumptions about how memory
; was allocated within the structures:

         .errnz (QueueRxSize-QueueRxAddr)-(QInSize-QInAddr)
         .errnz (QueueTxAddr-QueueRxSize)-(QOutAddr-QInSize)
         .errnz (QueueTxSize-QueueTxAddr)-(QOutSize-QOutAddr)

         .errnz QueueRxSize-QueueRxAddr-4
         .errnz QueueTxAddr-QueueRxSize-2
         .errnz QueueTxSize-QueueTxAddr-4

         .errnz QInSize-QInAddr-4
         .errnz QOutAddr-QInSize-2
         .errnz QOutSize-QOutAddr-4

         .errnz QInCount-QOutSize-2
         .errnz QInGet-QInCount-2
         .errnz QInPut-QInGet-2
         .errnz QOutCount-QInPut-2
         .errnz QOutGet-QOutCount-2
         .errnz QOutPut-QOutGet-2
         .errnz EFlags-QOutPut-2       ;First non-queue item

$SETQUE endp

page

;----------------------------Public Routine-----------------------------;
;
; $EVT - Set Event Mask
;
; Set up event word and mask.  Returns a pointer to a word in which
; certain bits, as enabled by the mask, will be set when certain
; events occur.
;
; Entry:
;   AH = Device ID
;   BX = Event enable mask
; Returns:
;   DX:AX --> event word.
; Error Returns:
;   AX = 0 if error
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $EVT
$EVT   proc   near

        push    si
        xor     dx,dx                   ;In case of error
        call    GetDEB                  ;Get pointer to DEB
        mov     ax,dx                   ;Finish setting error return value
        jc      Evt10                   ;Illegal id, return error
        js      Evt10                   ;LPTx, return error
        mov     EvtMask[si],bx          ;Save the new event mask
        lea     ax,EvtWord[si]          ;Get address of event word
        mov     dx,ds                   ;  into dx:ax

Evt10:
        pop     si
        ret

$EVT   endp
page

;----------------------------Public Routine-----------------------------;
;
; $EVTGET - Get Event Word
;
; Return and clear fields in the event word.  This routine MUST be used
; by applications to read the event word, as it is the ONLY way they
; can be assured that an event is not lost between reading the flags
; and resetting some.
;
; Entry:
;   AH = Device ID
;   BX = Event clear mask
; Returns:
;   AX = event word
; Error Returns:
;   None
; Registers Preserved:
;   AX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   BX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $EVTGET
$EVTGET proc   near

        push    si
        call    GetDEB
        mov     ah,0                    ;In case of error (AL already 0)
        jc      EvtGet10                ;Illegal ID
        js      EvtGet10                ;Illegal ID
        FCLI                             ;No interrupts allowed
        mov     ax,EvtWord[si]          ;Get the current event word
        not     bx                      ;Convert mask for our purposes
        and     bx,ax                   ;Clear events that user wants us to
        mov     EvtWord[si],bx          ;And save those results
        FSTI                             ;Magic over

EvtGet10:
        pop     si
        ret

$EVTGET endp
page

;----------------------------Public Routine-----------------------------;
;
; $STACOM - Return Status Information
;
; Returns the number of bytes in both queues.
;
; LPT ports will show both queues empty.
; and resetting some.
;
; Entry:
;   AH    = Device ID
;   ES:BX = Pointer to status structure to be updated.
;         = Null if not to update
; Returns:
;   AX = comm error word
;   Status Structure Updated.
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $STACOM
$STACOM proc   near

         push  si
         call  GetDEB                  ;Get DEB pointer in SI
         jc    StaCom30                ;Invalid ID
         mov   cx,es                   ;Is the pointer NULL?
         or    cx,bx
         jz    StaCom25                ;  Yes, just return error code
         xor   cx,cx
         xor   dx,dx
         or    ah,ah                   ;Set 'S' if LPT port
         mov   ax,cx                   ;For LPTs, everything is zero
         js    StaCom20                ;LPT port

; Need to get the status for a com port.  Since not all the
; status is contained within EFlags, it has to be assembled.
; Also note that currently there is no way to specify RLSD
; as a handshaking line, so fRLSDHold is always returned false.

         mov   al,MSRShadow[si]        ;Get state of hardware lines
         and   al,OutHHSLines[si]      ;Mask off required bits
         xor   al,OutHHSLines[si]      ;1 = line low
         mov   cl,4                    ;Align bits
         shr   al,cl                   ;al = fCTSHold + fDSRHold
         .errnz    ACE_CTS-00010000b
         .errnz    ACE_DSR-00100000b
         .errnz   fCTSHold-00000001b
         .errnz   fDSRHold-00000010b

         mov   ah,HSFlag[si]           ;Get fXOffHold+fXOffSent
         and   ah,XOffReceived+XOffSent
         or    al,ah

         .errnz   XOffReceived-fXOFFHold
         .errnz   XOffSent-fXOFFSent

         mov   ah,EFlags[si]           ;Get fEOF+fTxImmed
         and   ah,fEOF+fTxImmed
         or    al,ah

         mov   cx,QInCount[si]         ;Get input queue count
         mov   dx,QOutCount[si]        ;Get tx queue count

StaCom20:
         mov   es:StatFlags[bx],al
         mov   es:StatRxCount[bx],cx
         mov   es:StatTxCount[bx],dx

StaCom25:
         xor   ax,ax                   ;Return old com error
         xchg  ax,ComErr[si]           ;  and clear it out

StaCom30:
         pop     si
         ret

$STACOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SetBrk - Set Break
;
; Clamp the Tx data line low.  Does not wait for the
; transmitter holding register and shift registers to empty.
;
; LPT ports will just return the comm error word
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $SETBRK
$SETBRK proc   near

        mov     cx,0FF00h+ACE_SB        ;Will be setting break
        jmp     short ClrBrk10
        .errnz   BreakSet-ACE_SB    ;Must be same bits

$SETBRK endp
page

;----------------------------Public Routine-----------------------------;
;
; $CLRBRK - Clear Break
;
; Release any BREAK clamp on the Tx data line.
;
; LPT ports will just return the comm error word
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $CLRBRK
$CLRBRK proc near

         mov   cx,(NOT ACE_SB) SHL 8
         .errnz BreakSet-ACE_SB        ;Must be same bits

ClrBrk10:
         push  si
         call  GetDEB                  ;Get DEB address
         jc    ClrBrk30                ;Invalid ID
         js    ClrBrk20                ;Ignored for LPT ports
         FCLI
         and   HSFlag[si],ch           ;Set or clear the BreakSet bit
         or    HSFlag[si],cl

; ch = mask to remove bits in the Line Control Register
; cl = mask to turn bits on in the Line Control Register

         mov   dx,Port[si]             ;Get comm device base I/O port
         add   dl,ACE_LCR              ;Point at the Line Control Regieter
         pin   al,dx                   ;Get old line control value
         and   al,ch                   ;Turn off desired bits
         or    al,cl                   ;Turn on  desired bits
         pause
         pout  dx,al                   ;Output New LCR.
         FSTI

ClrBrk20:
        mov    ax,ComErr[si]          ;Return Status Word

ClrBrk30:
        pop     si
        ret

$CLRBRK endp

page

;----------------------------Public Routine-----------------------------;
;
; $EXTCOM - Extended Comm Functions
;
; A number of extended functions are routed through this entry point.
;
; Functions currently implemented:
;
;   0: Ignored
;   1: SETXOFF - Exactly as if X-OFF character has been received.
;   2: SETXON  - Exactly as if X-ON character has been received.
;   3: SETRTS  - Set the RTS signal
;   4: CLRRTS  - Clear the RTS signal
;   5: SETDTR  - Set the DTR signal
;   6: CLRDTR  - Clear the DTR signal
;   7: RESET   - Yank on reset line if available (LPT devices)
;
; Entry:
;   AH = Device ID
;   BL = Function Code
;        (0-127 are MS-defined, 128-255 are OEM defined)
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;


;       Dispatch table for the extended functions

ExtTab  dw      ExtComDummy             ;Function 0: Never Mind
        dw      ExtCom_FN1              ;1: Set X-Off
        dw      ExtCom_FN2              ;2: Clear X-Off
        dw      ExtCom_FN3              ;3: Set RTS
        dw      ExtCom_FN4              ;4: Clear RTS
        dw      ExtCom_FN5              ;5: Set DSR
        dw      ExtCom_FN6              ;6: Clear DSR
        dw      ExtCom_FN7              ;7: Reset printer

   assumes ds,Data
   assumes es,nothing

   public   $EXTCOM
$EXTCOM proc   near

        push    si
        call    GetDEB                  ;Get DEB pointer
        jc      ExtCom40                ;Invalid ID, return error
	mov	dx,Port[si]		; get port address
        jns     ExtCom10                ;Its a COM port
        cmp     bl,7                    ;RESET extended function?
	jne	ExtCom30		;  No, return error word
        jmp     short ExtCom20          ;  Yes, invoke the function

ExtCom10:
        cmp     bl,7                    ;Last fcn supported +1
        jnc     ExtCom30                ;Not an implemented function.

ExtCom20:
        xor     bh,bh
        add     bx,bx                   ;Shift for the call
        FCLI                             ;Consider as critical sections
	call	ExtTab[bx]		;  and perform the function
        FSTI

ExtCom30:
        mov     ax,ComErr[si]           ;Return standard error word

ExtCom40:
        pop     si

ExtComDummy:
        ret

$EXTCOM endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN1 - Extended Function Set X-Off
;
; Analagous to receiving an X-OFF character.  Bufferred transmision of
; characters is halted until an X-ON character is received, or until
; we fake that with a Clear X-Off call.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN1
ExtCom_FN1   proc   near

        or      HSFlag[si],XOffReceived
        ret

ExtCom_FN1   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN2 - Extended Function Clear X-Off
;
; Analagous to receiving an X-ON character. Buffered
; transmission of characters is restarted.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN2
ExtCom_FN2   proc   near

        and     HSFlag[si],NOT XOffReceived
        jmp     KickTx                  ;Kick transmitter interrupts on

ExtCom_FN2   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN3 - Extended Function Set RTS
;
; Set the RTS signal active.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN3
ExtCom_FN3   proc   near

         add   dl,ACE_MCR              ;Point at Modem Control Register
         pin   al,dx                   ;Get current settings
         or    al,ACE_RTS              ;Set RTS
         pause
         pout  dx,al                   ;And update
         ret

ExtCom_FN3   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN4 - Extended Function Clear RTS
;
; Set the RTS signal inactive.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN4
ExtCom_FN4   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
   pin   al,dx         ;Get current settings
        and     al,NOT ACE_RTS          ;Clear RTS
        pause
   pout   dx,al         ;And update
        ret

ExtCom_FN4   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN5 - Extended Function Set DTR
;
; Set the DTR signal active.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN5
ExtCom_FN5   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
   pin   al,dx         ;Get current settings
        or      al,ACE_DTR              ;Set DTR
        pause
   pout   dx,al         ;And update
        ret

ExtCom_FN5   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN6 - Extended Function Clear DTR
;
; Set the DTR signal inactive.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN6
ExtCom_FN6   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
   pin   al,dx         ;Get current settings
        and     al,NOT ACE_DTR          ;Clear DTR
        pause
   pout   dx,al         ;And update
        ret

ExtCom_FN6   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN7 - Extended Function Reset Printer
;
; Assert the RESET line on an LPT port
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN7
ExtCom_FN7   proc   near

        FSTI                             ;Not called at interrupt time
        mov     ch,1                    ;ROM BIOS Reset Port
        call    DoLPT                   ;Perform the function
        ret

ExtCom_FN7   endp
page

;----------------------------Public Routine-----------------------------;
;
; $DCBPtr - Return Pointer To DCB
;
; Returns a long pointer to the DCB for the requested device.
;
; Entry:
;   AH = Device ID
; Returns:
;   DX:AX = pointer to DCB.
; Error Returns:
;   DX:AX = 0
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   BX,CX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $DCBPTR
$DCBPTR proc   near

        push    si
        xor     dx,dx
        call    GetDEB                  ;Get pointer to DEB
        mov     ax,dx
        jc      DCBPtr10                ;Jump if invalid device
        mov     ax,si                   ;else return value here
        mov     dx,ds

DCBPtr10:
        pop     si
        ret

$DCBPTR endp
page

;----------------------------Public Routine-----------------------------;
;
; $RECCOM - Receive Characters From Device
;
; Read Byte From RS232 Input Queue If Data Is Ready
;
; LPT ports will return with an indication that no characters are
; available.
;
; Entry:
;   AH = Device ID
; Returns:
;   'Z' clear if data available
;   AL = byte
; Error Returns:
;   'Z' Set if error or no data
;   AX = error code
;   AX = 0 if no data
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $RECCOM
$RECCOM proc   near

         push  si                      ;Once again, save some registers
         push  di
         call  GetDEB                  ;Get DEB pointer in SI
         jc    RecCom10                ;Invalid Port [rkh] ...
         js    RecCom20                ;LPT port, return no characters
	 jmp   short RecCom30

RecCom10:
	 jmp   RecCom100	       ; Invalid Port

RecCom20:
	 jmp   RecCom95 	       ;LPT port, return no characters

; Before removing any charcters from the input queue, check to see
; if XON needs to be issued.  If it needs to be issued, set the
; flag that will force it and arm transmit interrupts.

RecCom30:
         test  Flags[si],fEnqAck+fEtxAck ;Enq or Etx Ack?
         jz    RecCom32                ;  No
         test  HSFlag[si],EnqReceived+HHSDropped ;Enq recvd or lines dropped?
         jz    RecCom60                ;  No Enq recvd & no lines dropped
	 jmp   short RecCom34

RecCom32:
         test  HSFlag[si],HSSent       ;Handshake sent?
         jz    RecCom60                ;  No XOFF sent & no lines dropped

RecCom34:
         mov   ax,QInCount[si]         ;Get current count of input chars
         cmp   ax,XONLim[si]           ;See if at XOn limit
         ja    RecCom60                ;Not at XOn limit yet

; If any hardware lines are down, then raise them.  Then see
; about sending XON.

         mov   dx,Port[si]             ;Get the port
         mov   ah,HHSLines[si]         ;Get hardware lines mask
         FCLI                           ;Handle this as a critical section
         mov   cl,HSFlag[si]           ;Get handshaking flags
         or    ah,ah                   ;Any hardware lines to play with?
         jz    RecCom40                ;  No
         add   dl,ACE_MCR              ;--> Modem control register
         pin   al,dx
         or    al,ah                   ;Turn on the hardware bits
         pause
         pout  dx,al
         and   cl,NOT HHSDropped       ;Show hardware lines back up

RecCom40:
         test  Flags[si],fEnqAck+fEtxAck ;Enq or Etx Ack?
         jz    RecCom47                ;  No
         test  cl,EnqReceived          ;Did we receive Enq?
         jz    RecCom55                ;  No
         and   cl,NOT EnqReceived
	 jmp   short RecCom50

RecCom47:
         test  cl,XOffSent             ;Did we send XOFF?
         jz    RecCom55                ;  No
         and   cl,NOT XOffSent         ;Remove XOFF sent flag

RecCom50:
         or    cl,XOnPending           ;Show XON or ACK must be sent
         call  KickTx                  ;Kick xmit if needed

RecCom55:
         mov   HSFlag[si],cl           ;Store handshake flag
         FSTI                           ;Can allow interrupts now

; Now we can get down to the business at hand, and remove a character
; from the receive queue.  If a communications error exists, we return
; that, and nothing else.

RecCom60:
         xor   ax,ax
         or    ax,ComErr[si]           ;Any Errors?
         jnz   RecCom100               ;  Yes, return the error code
         or    ax,QInCount[si]         ;Get current input char count
         jz    RecCom90                ;No characters in the queue
         les   di,QInAddr[si]          ;Get queue pointer
         assumes es,nothing

         mov   bx,QInGet[si]           ;Also get the index to head
         mov   al,es:[bx][di]          ;Finally, get byte from queue
         inc   bx                      ;Update queue index
         cmp   bx,QInSize[si]          ;See if time for wrap-around
         jc    RecCom70                ;Jump if no wrap
         xor   bx,bx                   ;wrap by zeroing the index

RecCom70:
         mov   QInGet[si],bx           ;Save new head pointer
         dec   QInCount[si]            ;Dec # of bytes in queue

RecCom80:
         or    sp,sp                   ;Reset PSW.Z
         pop   di
         pop   si
         ret

; No characters in the input queue.  Check to see if EOF
; was received, and return it if it was.  Otherwise show
; no characters.

RecCom90:
         test  Flags[si],fBinary       ;Are we doing binary stuff?
         jnz   RecCom95                ;  Yes, show no characters
         mov   al,EOFChar[si]          ;Assume EOF
         test  EFlags[si],fEOF         ;Has end of file char been received?
         jnz   RecCom80                ;  Yes, show end of file

RecCom95:
         xor   ax,ax                   ;Show no more characters

; Return with 'Z' to show error or no characters

RecCom100:
         xor   cx,cx                   ;Set PSW.Z
         pop   di
         pop   si
         ret

$RECCOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $FLUSH - Flush The Input and Output Queues
;
; This is a hard initialization of the transmit and receive queue's,
; which immediately empties the given queue.
;
; LPT ports will just return the device error word
;
; Entry:
;   AH = Device ID
;   BH = Queue # to clear (0=Tx, 1=Rx)
; Returns:
;   AX = Device Error Word. (Not reset)
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $FLUSH
$FLUSH   proc   near

        push    si
        push    di
        call    GetDEB                  ;si --> DEB
        jc      Flush40                 ;Invalid ID
        js      Flush30                 ;LPT port, return any error

        mov     cx,QOutCount-QInCount   ;# of bytes to zero
        lea     di,QInCount[si]         ;--> receive queue data
        or      bh,bh                   ;Transmit queue?
        jnz     Flush10                 ;  No, input queue
        add     di,cx                   ;  Yes, --> xmit queue data

Flush10:
        cld
        push    ds
        pop     es
   assumes es,nothing

        xor     al,al
        FCLI                             ;Time to worry about critical sections
        rep     stosb
        FSTI
   .errnz   QInGet-QInCount-2
   .errnz   QInPut-QInGet-2
   .errnz   QOutCount-QInPut-2
   .errnz   QOutGet-QOutCount-2
   .errnz   QOutPut-QOutGet-2

        or      bh,bh                   ;Rx queue?
        jz      Flush30                 ;  No, xmit queue


;       If the queue to be cleared is the receive queue, any
;       hardware handshake must be cleared to prevent a possible
;       deadlock situation.  Since we just zeroed the queue count,
;       a quick call to $RecCom should do wonders to clear any
;       receive handshake (i.e. send XON if needed).

Flush20:
   call   $RECCOM       ;Take care of handshakes here

Flush30:
        mov     ax,ComErr[si]           ;And return the error word.

Flush40:
        pop     di
        pop     si
        ret

$FLUSH   endp

ifdef DEBUG
   public   KickTx10
   public   GetDEB10
   public   GetDEB20
   public   GetDEB30
   public   SetQue10
   public   Evt10
   public   EvtGet10
   public   StaCom20
   public   StaCom25
   public   StaCom30
   public   ClrBrk10
   public   ClrBrk20
   public   ClrBrk30
   public   ExtCom10
   public   ExtCom20
   public   ExtCom30
   public   ExtCom40
   public   ExtComDummy
   public   DCBPtr10
   public   RecCom30
   public   RecCom40
   public   RecCom50
   public   RecCom60
   public   RecCom70
   public   RecCom80
   public   RecCom90
   public   RecCom95
   public   RecCom100
   public   Flush10
   public   Flush20
   public   Flush30
   public   Flush40
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\ibmsetup.asm ===
page,132
;---------------------------Module-Header-------------------------------;
; Module Name: IBMSETUP.ASM
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; General Description:
;
; History:
;   sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;           FCLI/FSTI macros
;
;-----------------------------------------------------------------------;

title   IBMSetup - IBM PC, PC-XT, PC-AT, PS/2 Communications Interface

.xlist
include cmacros.inc
include comdev.inc
include ins8250.inc
include ibmcom.inc
include BIMODINT.INC
include vint.inc
.list


EBIS_Sel1   equ SIZE Bimodal_Int_Struc
EBIS_Sel2   equ EBIS_Sel1 + (SIZE EBIS_Sel_Struc)

externA  __WinFlags

externFP GetSystemMsecCount
externFP CreateSystemTimer
externFP AllocCStoDSAlias
externFP LockSegment
externFP UnlockSegment
externFP FreeSelector
externFP GetSelectorBase
externFP GetModuleHandle
externFP GetProcAddress
externFP GetPrivateProfileInt
externFP GetPrivateProfileString
externFP GetAppCompatFlags
externFP WowCloseComPort

externNP $RECCOM

externA  __0040H
externA  __F000h

externB  IRQhooks

IF 0
externD  OldIntVecIntB
externD  OldIntVecIntC
externD  OurIntVecIntB
externD  OurIntVecIntC
ENDIF

externB  szMessage
externB  pLPTByte
externB  szCOMMessage
externB  pCOMByte
externB  _szTitle


MULTIPLEX   equ       2Fh       ; multiplex interrupt number
GET386API   equ     1684h       ; Get API entry point from VxD
VPD     equ     000Fh       ; device ID of VPD device
VPD_GETPORT equ     0004h       ; function: assign port to current VM
VPD_RELPORT equ     0005h       ; function: release port
VCD     equ     000Eh       ; device ID of VCD device
VCD_GETVER  equ     0000h       ; get version API
VCD_GETPORT equ     0004h       ; function: assign port to current VM
VCD_RELPORT equ     0005h       ; function: release port
VCD_STEALPORT equ   0006h
VPICD       equ     0003h       ; device ID of VPICD device

POSTMESSAGE equ     110         ; export ordinal of PostMessage()
MESSAGEBOX  equ     1           ; export ordinal of MessageBox()
MB_TASKMODAL equ    2000h
MB_YESNO    equ     0004h       ; messagebox flags
MB_ICONEXCLAMATION equ 0030h
IDYES       equ     6


createSeg _INTERRUPT,IntCode,word,public,CODE
sBegin IntCode
assumes cs,IntCode

    externFP FakeCOMIntFar
    externFP TimerProc
    externFP Control
    externFP COMHandler
    externFP APIHandler
IFDEF No_DOSX_Bimodal_Services
    externW  RM_IntDataSeg
    externFP RM_APIHandler
    externFP Entry_From_RM
    externD  RM_CallBack
ENDIF

sEnd IntCode

page
sBegin   Data

externB lpCommBase
externB CommBaseX
externB lpCommIrq
externB CommIrqX
externB lpCommFifo
externB CommFifoX
externB lpCommDSR
externB CommDSRx

externB lpCommSection
externB lpSYSTEMINI


;------------------------------------------------------------------------------
;
; Reserve data space for COM ports
;
DefineCommX MACRO num
    public  Comm&num
Comm&num label byte
    db  num-1
.errnz  DCB_Id
    db  ((DCBSize+1) AND 0FFFEh)-1 DUP (0)  ; ComDCB
    dw  0                   ; ComErr
    dw  0                   ; Port
    dw  0                   ; NotifyHandle
    dw  0                   ; NotifyFlags
    dw  -1                  ; RecvTrigger
    dw  0                   ; SendTrigger
.errnz IRQhook - SendTrigger - 2
    db  (SIZE ComDEB) - IRQhook DUP(0)
.errnz $ - Comm&num - (SIZE ComDEB)
    Declare_PM_BIS 0,Control,COMHandler,APIHandler,_INTERRUPT,_DATA
    db     (SIZE EBIS_Sel_Struc) * 2 DUP(0)    ; res space for 2 selectors
ENDM
DW_OFFSET_CommX MACRO num
    dw  DataOFFSET Comm&num
ENDM


??portnum = 1
REPT MAXCOM+1
    DefineCommX %??portnum
??portnum = ??portnum+1
ENDM

PUBLIC  COMptrs         ; table of offsets to CommX's declared above
COMptrs label   word
??portnum = 1
REPT MAXCOM+1
    DW_OFFSET_CommX %??portnum
??portnum = ??portnum+1
ENDM

PURGE   DefineCommX
PURGE   DW_OFFSET_CommX

;------------------------------------------------------------------------------
;
; Reserve data space for LPT ports
;
DefineLPTx MACRO num
    public  LPT&num
LPT&num label byte
    db  num-1+LPTx
.errnz  DCB_Id
    db  ((DCBSize+1) AND 0FFFEh)-1 DUP (0)  ; xComDCB
    dw  0                   ; xComErr
    dw  0                   ; xPort
    dw  0                   ; xNotifyHandle
    dw  0                   ; xNotifyFlags
    dw  -1                  ; xRecvTrigger
    dw  0                   ; xSendTrigger
IF num LE 3
    dw  LPTB + (num-1)*2
ELSE
    dw  0                   ; BIOSPortLoc
ENDIF
    .errnz $-LPT&num - SIZE LptDEB
ENDM

??portnum = 1
REPT MAXLPT+1
    DefineLPTx %??portnum
??portnum = ??portnum+1
ENDM

PURGE   DefineLPTx

page

PUBLIC  $MachineID, Using_DPMI
$MachineID    db 0      ;IBM Machine ID
Using_DPMI    db 0      ; 0FFh, if TRUE

    ALIGN 2

PUBLIC  activeCOMs
activeCOMs    dw 0

PUBLIC  lpPostMessage, lpfnMessageBox, lpfnVPD, fVPD

lpPostMessage     dd 0
lpfnMessageBox    dd 0

lpfnVPD       dd 0      ; far pointer to win 386 VPD entry point
lpfnVCD       dd 0      ; far pointer to win 386 VCD entry point
lpfnVPICD     dd 0      ; far pointer to win 386 VPICD entry point
PUBLIC VCD_int_callback
VCD_int_callback  df 0      ; VCD returns the address for this callback
                ;   on every call to acquire a COM port, but
                ;   it is always the same address, so we will
                ;   just maintain it globally.
fVPD          db 0      ; 0-not checked, 1 vpd present, -1 no vpd
fVCD          db 0      ; 0-not checked, 1 vcd present, -1 no vcd
fVPICD        db 0      ; 0-not checked, 1 vpicd present, -1 no vpicd

szUser      db 'USER',0


default_table db  4, 3, 4, 3, 0 ; Default IRQ's (COM3 default is changed to
                ;   3 for PS/2's during LoadLib)


IFDEF No_DOSX_Bimodal_Services
RM_Call_Struc   Real_Mode_Call_Struc <>
ENDIF

IFDEF DEBUG_TimeOut
%OUT including code to display MsgBox, if closing comm with data in buffer
szSendTO    db 'TimedOut CloseComm with data in buffer.  Retry?', 0
ENDIF


sEnd Data

ROMBios           segment  at 0F000h
                  org         0FFFEh

MachineID label byte
RomBios Ends


sBegin Code
assumes cs,Code
assumes ds,Data

page

IFDEF No_DOSX_Bimodal_Services
;----------------------------Private-Routine----------------------------;
; SegmentFromSelector
;
;   Converts a selector to a segment...note that this routine assumes
;   the memory pointed to by the selector is below the 1Meg line!
;
; Params:
;   AX = selector to convert to segment
;
; Returns:
;   AX = segment of selector given
;
; Error Returns:
;   None
;
; Registers Destroyed:
;   CX
;
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public SegmentFromSelector
SegmentFromSelector proc far

.286
    push    dx
    cCall   GetSelectorBase,<ax>    ;DX:AX = segment of selector
    shr ax, 4
    shl dl, 4
    or  ah, dl          ;AX now points to interrupt *segment*
    pop dx
    ret
.8086

SegmentFromSelector endp
ENDIF
page

;------------------------------------------------------------------------------
;
;   Get_API_Entry
;
;   entry - BX = device id
;       DS:DI -> DWORD for proc address
;   exit - Z flag set, if failed
;
Get_API_Entry proc near

    push    di
    xor di, di
    mov es, di
    mov ax, GET386API
    int MULTIPLEX
    mov ax, di
    pop di
    mov [di], ax
    mov [di+2], es
    or  ax, [di+2]
    ret

Get_API_Entry endp

;----------------------------Private-Routine----------------------------;
;
;   Contention_Dlg
;
;   If running under Win386, this routine can be called to ask the user to
;   resolve contention for a COM or LPT port.
;
;   entry - CX is offset of message string for dialog box
;
;   exit  - Z flag set, if user specified that Windows should steal the port

Contention_Dlg proc near
PUBLIC Contention_Dlg

    xor ax,ax
    push    ax          ; hwndOwner
    push    ds
    push    cx          ; message ptr

    cmp wo lpfnMessageBox[2], 0 ;Q: ptr to MessageBox proc valid?
    jne short gmbp_done     ;   Y: we can call it
    push    ds          ;   N: get module handle of USER
    lea ax, szUser
    push    ax
    cCall   GetModuleHandle

    push    ax          ; module handle
    mov ax, MESSAGEBOX
    cwd
    push    dx
    push    ax
    cCall   GetProcAddress
    mov wo lpfnMessageBox[0], ax  ; save received proc address
    mov wo lpfnMessageBox[2], dx
gmbp_done:

    push    ds
    lea ax, _szTitle
    push    ax
    mov ax, MB_ICONEXCLAMATION or MB_YESNO or MB_TASKMODAL
    push    ax
    cCall   lpfnMessageBox
    cmp ax, IDYES       ; user allows us to take the port?
    ret
Contention_Dlg endp


;----------------------------Private-Routine----------------------------;
;
;   GetPort386
;
;   If running under Win386, tell the VPD to assign an LPT port to us.
;   The comm driver will handle contention.
;
;   entry - DI contains offset in ROM area of port...
;       8 - LPT1, A - LPT2, etc
;
;   exit  - registers saved, carry = clear if OK to proceed, set if
;       user won't allow assignment of port or Win386 error
;

GetPort386  proc near
public GetPort386

    cmp fVPD, 0
    jl  getport_VPDNotInstalled
    jnz short getport_CallVPD

    push    di
    mov bx, VPD
    mov di, DataOFFSET lpfnVPD
    call    Get_API_Entry
    pop di
    jnz short getport_CallVPD
    mov fVPD, -1

getport_VPDNotInstalled:
    clc
    jmp short getport_exit

getport_CallVPD:
    mov fVPD, 1
    push    di
    sub di, LPTB
    shr di, 1           ; turn DI into port number

    xor ax, ax
    mov dx, VPD_GETPORT
    mov cx, di
    call    [lpfnVPD]
    jnc getport_gotit

;   port owned by another VM... ask the user for it

    add cl, '1'         ; fix up the port name...
    mov pLPTByte, cl        ; HACK HACK HACK
    lea cx, szMessage
    call    Contention_Dlg
    jnz getport_userwontallow

    mov ax, 1           ; tell win386 we really do want it
    mov cx, di          ;
    mov dx, VPD_GETPORT     ;
    call    [lpfnVPD]       ; return with C set or clear...
    jmp short getport_gotit

getport_userwontallow:
    stc

getport_gotit:
    pop di

getport_exit:
    ret

GetPort386  endp

;----------------------------Private-Routine----------------------------;
;
;   ReleasePort386
;
;   If running under Win386, tell the VPD to deassign an LPT port.
;
;   entry - DS:SI -> COMDEB
;

ReleasePort386  proc near

    cmp fVPD, 1
    jne release_noVPD

    xor cx, cx
    mov cl, [si.DCB_id]
    and cl, NOT LPTx        ; clear high bit
    mov dx, VPD_RELPORT
    call    [lpfnVPD]

release_noVPD:
    ret

ReleasePort386  endp


;----------------------------Private-Routine----------------------------;
;
;   GetCOMport386
;
;   If running under Win386, tell the VCD to assign a COM port to us.
;   The comm driver will handle contention.
;
;   entry - DS:SI -> COMDEB
;
;   exit  - registers saved, carry = clear if OK to proceed, set if
;       user won't allow assignment of port or Win386 error
;
.386
GetCOMport386 proc near
public GetCOMport386

    push    es
    pushad
    cmp fVCD, 0
    jl  short getcomport_VCDNotInstalled
    jnz short getcomport_CallVCD

    mov bx, VCD
    mov di, DataOFFSET lpfnVCD
    call    Get_API_Entry
    jz  short getcomport_checknoVCD

    mov dx, VCD_GETVER
    call    [lpfnVCD]
    cmp ax, 30Ah            ;Q: 3.1 or greater?
    jae short getcomport_CallVCD    ;   Y:

getcomport_checknoVCD:
    mov fVCD, -1

getcomport_VCDNotInstalled:
    clc
    jmp short getcomport_exit

getcomport_CallVCD:
    mov fVCD, 1

    mov ax, 10b         ; flag ring0 int handler
    call    VCD_GetPort_API
    jnc short getcomport_success  ; jump if acquire worked
    jnz short getcomport_noport   ; jump if port doesn't exist

;   port owned by another VM... ask the user for it

    mov cl, [si.DCB_id]
    add cl, '1'         ; fix up the port name...
    mov pCOMByte, cl
    lea cx, szCOMMessage
    call    Contention_Dlg
    stc
    jnz short getcomport_exit

    mov ax, 11b         ; tell win386 we really do want it
    call    VCD_GetPort_API
    jc  short getcomport_exit

getcomport_success:
    mov dword ptr [VCD_int_callback], edi
    mov word ptr [VCD_int_callback+4], cx
    mov [si.VCD_data], ebx
    xchg    ax, [si.Port]
    or  ax, ax          ;Q: already had port base?
    jnz short getcomport_exit ; Y: don't update vector #, or FIFO
    mov [si.IntVecNum], dl
    call    GetPortFlags
    clc

getcomport_exit:
    popad
    pop es
    ret

getcomport_noport:
    mov [si.Port], -1
    jmp getcomport_exit

GetCOMport386 endp

VCD_GetPort_API proc near
    mov dx, VCD_GETPORT
    xor cx, cx
    mov cl, [si.DCB_Id]     ; cx = port #
    mov di, VCDflags        ; offset from start of DEB
    call    [lpfnVCD]
    ret
VCD_GetPort_API endp
.8086

;----------------------------Private-Routine----------------------------;
;
;   ReleaseCOMport386
;
;   If running under Win386, tell the VCD to deassign a COM port.
;
;   entry - DS:SI -> COMDEB
;

ReleaseCOMport386  proc near

ifndef WOW
    cmp fVCD, 1
    jne release_noVCD

    xor cx, cx
    mov cl, [si.DCB_id]
    mov dx, VCD_RELPORT
    call    [lpfnVCD]
else
    xor cx, cx
    mov cl, [si.DCB_id]
    push cx
    call WowCloseComPort
endif

release_noVCD:
    ret

ReleaseCOMport386  endp

PUBLIC StealPort
StealPort proc near

    cmp fVCD, 1
    jne sp_yes
    mov dx, VCD_STEALPORT
    xor cx, cx
    mov cl, [si.DCB_id]
    call    [lpfnVCD]
    or  al, al
    jnz sp_yes

sp_no:
    stc
    ret

sp_yes:
    clc
    mov [si.VCDflags], 0
    ret

StealPort endp

page

;------------------------------------------------------------------------------
;
;   ENTER:  DS:SI -> ComDEB
;   EXIT:   AL = 0, if IRQ was unmasked, else -1, if IRQ was already masked
;
MaskIRQ proc near
    push    es
    push    di
    mov di, ds
    mov es, di
    lea di, [si+SIZE ComDEB]
    mov ax, BIH_API_Get_Mask
    call    APIHandler      ; returns Carry Set, if masked
    jc  short already_masked
    pushf
    mov ax, BIH_API_Mask
    call    APIHandler      ; mask IRQ
    xor ax, ax
    popf
    jnc short mask_exit
already_masked:
    or  al, -1
mask_exit:
    pop di
    pop es
    ret
MaskIRQ endp

;------------------------------------------------------------------------------
;
;   ENTER:  DS:SI -> ComDEB
;
UnmaskIRQ proc near
    push    es
    push    di
    mov di, ds
    mov es, di
    lea di, [si+SIZE ComDEB]
    mov ax, BIH_API_Unmask
    call    APIHandler
    pop di
    pop es
    ret
UnmaskIRQ endp
page

;----------------------------Public Routine-----------------------------;
;
; $INICOM - Initialize A Port
;
; Initalizes the requested port if present, and sets
; up the port with the given attributes when they are valid.
; This routine also initializes communications buffer control
; variables.  This routine is passed the address of a device
; control block.
;
; The RLSD, CTS, and DSR signals should be ignored by all COM
; routines if the corresponding timeout values are 0.
;
; For the LPT ports, a check is performed to see if the hardware
; is present (via the LPT port addresses based at 40:8h.  If the
; port is unavailable, an error is returned.  If the port is
; available, then the DEB is set up for the port.  $SETCOM will
; be called to set up the DEB so that there will be something
; valid to pass back to the caller when he inquires the DEB.
;
; No hardware initialization will be performed to prevent the
; RESET line from being asserted and resetting the printer every
; time this routine is called.
;
; Entry:
;   EX:BX --> Device Control Block with all fields set.
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = initialization error code otherwise
; Registers Preserved:
;   None
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $INICOM
$INICOM  proc  near
    push    si          ;As usual, save register variables
    push    di
    mov ah,es:[bx.DCB_Id]   ;Get device i.d.
    call    GetDEB          ;--> DEB for this device
    mov ax, IE_BADID        ; call it a bad id (spooler uses DOS)
    jc  InitCom15       ;Invalid device
    jns InitCom20       ; jmp if COM port

    push    ds

    mov di, [si.BIOSPortLoc]
    cmp di, LPTB
    jb  short InitLPT_Installed

    mov cx,__0040H      ;[rkh] ...
    mov ds,cx           ;Point DS: at ROM Save Area.
    assumes ds,nothing

    mov ax, IE_HARDWARE
    mov cx, wo [di]
    jcxz    InitCom10       ; if zero, no hardware

    mov ax,IE_BadID     ;Show bad device
    cmp ch, 0           ; zero hibyte -> not valid (redir)
    jz  InitCom10       ;   call it a bad id (spooler uses DOS)

    cmp di, LPTB        ; LPT1?
    jz  InitLPT_Installed   ; yes, must be installed

    cmp cx, wo [di-2]       ;Q: duplicate of previous port
    je  InitCom10       ;   Y: (redirected port)

InitLPT_Installed:
    pop ds
    mov [si.Port], cx
    call    $SETCOM
    call    GetPort386      ; tell win386 we're using the port
    mov ax, IE_OPEN     ; port already open (by another VM)
    jc  InitCom15       ;   error
    jmp InitCom90       ;That's all

InitCom10:
    pop ds          ; get DS back
InitCom15:
    jmp InitCom100


    assumes ds,Data
InitCom17:
    mov ax, IE_OPEN
    cmp [si.Port], -1       ;Q: determined that port didn't exist?
    jne InitCom15       ;   N: return IE_OPEN
    jmp short InitCom27     ;   Y: return IE_HARDWARE

; ***  Set up serial port ***
;
InitCom20:
    cmp [si.Port], -1       ;Q: port exists?
    je  InitCom27       ;   N: report not found

    mov ax, __WinFlags
    test    ax, WF_ENHANCED
    jz  short @F
    call    GetCOMport386
    jc  InitCom17

@@:
    cmp [si.Port], 0        ;Q: already got info?
    jnz @F
    call    FindCOMPort
    jc  InitCom27       ; report not found, if error
    mov [si.Port], ax
    mov [si.IntVecNum], dl
@@:

    push    es          ;Save these registers
    push    di
    push    cx          ;needed later for $SETCOM etc
    push    bx

    mov al, [si.IntVecNum]
    xor ah, ah
    lea di, [si+SIZE ComDEB]
    mov [di.BIS_IRQ_Number], ax

    mov di, DataOFFSET IRQhooks
    mov cx, MAXCOM+1
InitCom25:
    cmp al, [di.IRQn]       ;Q: hooked IRQ matches ours?
    je  short InitCom30     ;   Y:
    cmp [di.IRQn], 0        ;Q: end of hooked IRQ list?
    je  short InitCom35     ;   Y:
    add di, SIZE IRQ_Hook_Struc ;   N: check next hook
    loop    InitCom25
    int 3               ; data structures corrupt if we
                    ; get here, because no hook table
                    ; entries exist and there is suppose
                    ; to be at least 1 for each DEB
InitCom26:
    call    ReleaseCOMport386   ; give port back to 386...
    pop bx
    pop cx
    pop di
    pop es

InitCom27:
    mov ax, IE_HARDWARE     ; jump if port not available
    jmp InitCom100

InitCom30:
    cmp [di.HookCnt], 0     ;Q: IRQ still hooked?
    je  short InitCom35     ;   N: rehook
    inc [di.HookCnt]        ;   Y: inc hook count
    mov [si.IRQhook], di    ;   & link DEB into list
    mov ax, [di.First_DEB]
    mov [si.NextDEB], ax
    mov [di.First_DEB], si
    jmp short InitCom40

InitCom35:
    mov [di.IRQn], al       ; hook IRQ for first time, or rehook
    mov [si.IRQhook], di
    mov [di.First_DEB], si
    mov [di.HookCnt], 1
    call    MaskIRQ
    mov [di.OldMask], al

InitCom40:              ; di -> IRQ_Hook_Struc

    cmp [fVPICD], 0     ;Q: VPICD bimodel services available?
    jl  short InitCom415    ;   N:
    mov ax, ds          ;   Y: use them
    mov es, ax
    lea di, [si+SIZE ComDEB]

    mov [di.BIS_Descriptor_Count], 2
    mov ax, word ptr [si.QInAddr+2]  ; get selector of in queue
    mov [di.EBIS_Sel1.EBIS_User_Mode_Sel], ax
    mov ax, word ptr [si.QOutAddr+2] ; get selector of out queue
    mov [di.EBIS_Sel2.EBIS_User_Mode_Sel], ax

    mov ax, VPICD_Install_Handler
    call    [lpfnVPICD]
    jnc InitCom42
    cmp [di.OldMask], 0
    jne InitCom26
    call    UnmaskIRQ
    jmp InitCom26

InitCom42:
;
; save newly allocated selectors/segments into "Alt" queue pointers
;
    mov ax, [di.EBIS_Sel1.EBIS_Super_Mode_Sel]
    mov word ptr [si.AltQInAddr+2], ax
    mov ax, [di.EBIS_Sel2.EBIS_Super_Mode_Sel]
    mov word ptr [si.AltQOutAddr+2], ax

InitCom414:
    jmp InitCom59

InitCom415:
    cmp [di.VecN], 0FFh     ;Q: int already hooked?
IFDEF No_DOSX_Bimodal_Services
    jnz short InitCom52     ;   Y: init RMode ptrs in BIS
ELSE
    jnz InitCom414      ;   Y:
ENDIF
    mov al, [si.IntVecNum]
    add al, 8           ; 1st PIC starts at vector 8h
    cmp al, 16          ;Q: 2nd PIC?
    jb  short InitCom418    ;   N:
    add al, 70h-16      ;   Y: 2nd PIC starts at vector 70h
InitCom418:
    mov [di.VecN], al

; *** Set interrupt vectors ***
;
    mov ah,35h          ;Get the DOS vector
    int 21h         ;DOS Get Vector Function
    mov wo [di.OldIntVec][0], bx
    mov wo [di.OldIntVec][2], es

InitCom50:
    push    ds          ;Save original DS
    mov dx, [di.HandlerOff]
    mov bx, _INTERRUPT
    mov ds, bx          ;Interrupt handler address in ds:dx
    assumes ds,nothing
    mov ah, 25h         ;DOS Set Vector Function
    int 21h         ;Set the DOS vector
    pop ds          ;Original DS
    assumes ds,Data

IFDEF No_DOSX_Bimodal_Services
InitCom52:
    cmp [Using_DPMI], 0
    jz  short InitCom57

    mov ax, Int31_Get_Version SHL 8
    int 31h
    mov bl, [si.IntVecNum]
    mov bh, bl
    add bl, dh          ; assume master PIC
    sub bh, 8           ;Q: IRQ in master?
    jb  @f          ;   Y: add master's base vec
    add bh, dl          ;   N: add slave's base vec
    mov bl, bh
@@:
    mov ax, Get_RM_IntVector
    int 31h
    mov wo [di.RM_OldIntVec][0], dx
    mov wo [di.RM_OldIntVec][2], cx

    mov dx, [di.RM_HandlerOff]
    mov ax, _INTERRUPT
    call    SegmentFromSelector
    mov cx, ax
    push    cx
    mov ax, Set_RM_IntVector
    int 31h

    lea di, [si+SIZE ComDEB]
    mov wo [di.BIS_Super_Mode_API], IntCodeOFFSET RM_APIHandler
    pop cx
    mov wo [di.BIS_Super_Mode_API+2], cx

;
; Get segment addresses for the Q's and set AltQInAddr and AltQOutAddr
;
    mov ax, wo [si.AltQInAddr+2]
    call    SegmentFromSelector
    mov wo [si.AltQInAddr+2], ax
    mov ax, wo [si.AltQOutAddr+2]
    call    SegmentFromSelector
    mov wo [si.AltQOutAddr+2], ax
InitCom57:
ENDIF
    mov ax, __WinFlags      ;In Standard mode, the PIC IRQ
    test    al, WF_STANDARD     ;  priorities get rotated to favor
    jz  InitCom59       ;  the comm ports.

    call    Rotate_PIC

; *** Interrupt handler set : jump here if handler is already installed ***
;
InitCom59:
    pop bx
    pop cx
    pop di
    pop es

InitCom60:
    mov dx,[si.Port]        ;Set comm card address
    xor ax,ax           ;Need a zero
    inc dx          ;--> Interrupt Enable Register
    .errnz ACE_IER-ACE_RBR-1
    out dx,al           ;Turn off interrupts
    call    FlagNotActive
    add dl,ACE_MCR-ACE_IER  ;--> Modem Control Register
    in  al,dx
    and al,ACE_DTR+ACE_RTS  ;Leave DTR, RTS high if already so
    iodelay             ;  but tri-state IRQ line
    out dx,al

InitCom70:
    push    es          ;Zero queue counts and indexes

    push    ds
    pop es
    assumes es,Data

    lea di,QInCount[si]
    mov cx,(EFlags-QInCount)/2
    .errnz (EFlags-QInCount) AND 1
    xor ax,ax
    cld
    rep stosw

    .errnz  QInGet-QInCount-2
    .errnz  QInPut-QInGet-2
    .errnz  QOutCount-QInPut-2
    .errnz  QOutGet-QOutCount-2
    .errnz  QOutPut-QOutGet-2
    .errnz  EFlags-QOutPut-2    ;First non-queue item

    pop es
    assumes es,nothing

    mov HSFlag[si],al       ;Show no handshakes yet
    mov MiscFlags[si],al    ;Show not discarding
    mov EvtWord[si],ax      ;Show no events
    mov [si.VCDflags], al

    mov [si.SendTrigger], ax
    dec ax
    mov [si.RecvTrigger], ax

;Call $SETCOM to perform further hardware initialization.

InitCom80:
    sub dl,ACE_MCR-ACE_FCR  ; dx -> FCR
    in  al, dx
    iodelay
    test    al, ACE_FIFO_E2         ;Q: FIFO already on?
    jz  short @F            ;   N:
    or  EFlags[si], fFIFOpre        ;   Y: flag it
@@:

    ; needs si, di, and es to be saved from the beginning of inicom
    call    $SETCOM         ;Set up Comm Device
    jnz short InitCom110    ;jump if failed

    call    UnmaskIRQ
    and EFlags[si], fEFlagsMask ;Clear internal state

InitCom90:
    xor ax,ax           ;Return AX = 0 to show success
    mov ComErr[si],ax       ;Get rid of any bogus init error

InitCom100:
    pop di
    pop si
    ret

;
; jump to here, if call to $SETCOM failed
;
; DANGER! *** Call into middle of Terminate to clean things up *** DANGER!
;
InitCom110:
    push    ax          ;Failure, save error code
    call    Terminate45     ;Restore port address, int vec
    pop ax          ;Restore error code and exit
    jmp InitCom100

$INICOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $TRMCOM - Terminate Communications Channel
;
; Wait for any outbound data to be transmitted, drop the hardware
; handshaking lines, and disable interrupts.  If the output queue
; contained data when it was closed, an error will be returned
;
; LPT devices have it easy.  They just need to restore the I/O port
; address.
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = 0
; Error Returns:
;   AX = 8000h if invalid device ID
;   AX = -2 if output queue timeout occured
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $TRMCOM
$TRMCOM  proc   near

    push    si
    push    di
    xor cx,cx           ;Show no error if LPT port
    call    GetDEB
    jc  TermCom60       ;ID is invalid, return error
    js  TermCom30       ;Port is a LPT port

    push    ax          ;Save port id
    or  MiscFlags[si],Discard   ;Show discarding serial data
    mov ComErr[si],cx       ;Clear error flags
    mov QInCount[si],cx     ;Show no chars in input queue
    call    $RECCOM         ;Send XON if needed

;-----------------------------------------------------------------------;
;   We have to wait for the output queue to empty.   To do this,
;   a timer will be created.  If no character has been transmitted
;   when the timeout occurs, then an error will be indicated and
;   the port closed anyway.  If the timer cannot be created, then
;   just loop until the queue empties, which will be better than
;   discarding charatcers if there are any
;-----------------------------------------------------------------------;

    test    [si.HSFlag], HHSAlwaysDown ; Q: handshaking ever up?
    jnz TermCom17       ;   N: skip wait loop

TermCom10:
    mov cx,QOutCount[si]    ;Get current queue count
    jcxz    TermCom20       ;No characters in queue

    cCall   GetSystemMsecCount
    mov di, ax

TermCom15:
    cmp QOutCount[si],cx    ;Queue count change?
    jne TermCom10       ;  Yes, restart timeout

    cCall   GetSystemMsecCount
    sub ax, di
    cmp ax, Timeout * 1000  ;Q: Timeout reached?
    jb  TermCom15       ;   No, keep waiting

IFDEF DEBUG_TimeOut
.286
    pusha
    lea cx, szSendTO
    call    Contention_Dlg
    popa
    jz  TermCom10
.8086
ENDIF

TermCom17:
    mov cx, TimeoutError    ;   Yes, show timeout error

TermCom20:
    pop ax          ;Restore cid

TermCom30:
    mov dx,Port[si]     ;Get port base address
    call    Terminate       ;The real work is done here
    mov ax,cx           ;Set return code

TermCom60:
    pop di
    pop si
    ret

$TRMCOM endp
page

;----------------------------Private-Routine----------------------------;
;
; Terminate - Terminate Device
;
; Restore the port I/O address and make sure that interrupts are off
;
; Entry:
;   AH = Device Id.
;   DX = Device I/O port address.
;   SI --> DEB
; Returns:
;   AX = 0
; Error Returns:
;   AX = -1
; Registers Destroyed:
;   AX,BX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public Terminate                       ;Public for debugging
Terminate proc near

    or  ah,ah           ;LPT port?
    jns Terminate10     ;  No, process COM port
    .errnz  LPTx-10000000b

Terminate5:
    call    ReleasePort386      ; give port back to 386...
    jmp Terminate50     ;That's all


;-----------------------------------------------------------------------;
;   It is a com port!
;
;       We delay for a bit while the last character finishes transmitting
;       Then we drop DTR and RTS, and disable the interrupt generation at
;       the 8250.  Even if fRTSDisable or fDTRDisable is set, those lines
;       will be dropped when the port is closed.
;-----------------------------------------------------------------------;
;
;   When the OUT2 bit is reset to 0 to disable interrupts, many ports
;   generate an interrupt which can not be identified, because the the
;   interrupt ID register will not be set.  To work around this hardware
;   problem we first mask the IRQ, then set the port into loopback mode
;   and output a NULL to generate a receive interrupt request.  Then we
;   reset OUT2 and unmask the IRQ.  This will cause the interrupt to occur
;   and the interrupt handler will be able to correctly identify the
;   interrupt as coming from the com port.

Terminate10:
    inc dx          ;Disable chip interrupts
    .errnz ACE_IER-ACE_RBR-1
    mov al, ACE_ERBFI       ;   except receive
    out dx,al
    call    FlagNotActive       ; don't need to check for postmessage
                    ;   on timer ticks
    add dl,ACE_LSR-ACE_IER  ;--> line status register
    iodelay

Terminate20:
    in  al,dx           ;Wait until xmit is empty
    and al,ACE_THRE+ACE_TSRE
    cmp al,ACE_THRE+ACE_TSRE
    jne Terminate20     ;Not empty yet

Terminate30:
    xor al, al
    test    EFlags[si], fFIFOpre    ;Q: leave FIFO enabled?
    jz  short @F        ;   N:
    mov al, ACE_TRIG14 OR ACE_EFIFO OR ACE_CRFIFO OR ACE_CTFIFO
@@:
    sub dl, ACE_LSR-ACE_FCR
    out dx, al
    iodelay
    call    MaskIRQ
    add dl, ACE_MCR-ACE_FCR ;--> Modem Control Register
    in  al,dx
    iodelay
    mov ah, al
    or  al,ACE_LOOP     ; turn on loopback
    out dx, al
    iodelay
    sub dl, ACE_MCR-ACE_THR
    xor al, al
    out dx, al          ; output a NULL to generate an int
    iodelay
    add dl, ACE_LSR-ACE_THR
Terminate35:
    in  al,dx           ;Wait until xmit is empty
    and al,ACE_THRE+ACE_TSRE
    cmp al,ACE_THRE+ACE_TSRE
    jne Terminate35     ;Not empty yet
    mov al, ah
    dec dl          ; now clear OUT2 and loopback
    .errnz  ACE_LSR-ACE_MCR-1
    and al,ACE_DTR+ACE_RTS  ;Leave DTR, RTS high if already so
    out dx,al           ;  but tri-state IRQ line

    call    UnmaskIRQ       ; this will cause the receive int
                    ; to occur and be processed
    sub dl, ACE_MCR-ACE_IER ; clear the receive int enable
    xor al, al
    out dx, al
    dec dx
    .errnz  ACE_IER-ACE_RBR-1
    call    MaskIRQ

;******* DANGER! ***** NOTICE! ***** DANGER! ***** WARNING! ***** NOTICE!
;
; Terminate45 is a secondary entrypoint into this routine--it's called
; by the initialization code when that code is unable to properly init
; a com port and needs to clean-up the mess it's made.
;
;******* DANGER! ***** NOTICE! ***** DANGER! ***** WARNING! ***** NOTICE!

Terminate45:
    push    cx          ;Save original cx
    push    bx          ;Save original bx

    cmp [fVPICD], 0     ;Q: VPICD bimodel services available?
    jl  short @F        ;   N:
    mov ax, ds          ;   Y: use them
    mov es, ax
    lea di, [si+SIZE ComDEB]
    mov ax, VPICD_Remove_Handler
    call    [lpfnVPICD]
@@:

    mov di, [si.IRQhook]
    dec [di.HookCnt]        ;Q: last port using IRQ?
    jne short Terminate495  ;   N: unmask IRQ again
    mov al, 0FFh
    xchg    al, [di.VecN]       ;Interrupt vector number
    cmp al, 0FFh        ;Q: IRQ vector hooked?
    je  short Terminate49   ;   no...

IFDEF No_DOSX_Bimodal_Services
    cmp [Using_DPMI], 0
    jz  short term_no_dpmi

;
; unhook RM vector thru DPMI for standard mode
;
    push    ax
    mov ax, Int31_Get_Version SHL 8
    int 31h
    mov bl, [si.IntVecNum]
    mov bh, bl
    add bl, dh          ; assume master PIC
    sub bh, 8           ;Q: IRQ in master?
    jb  @f          ;   Y: add master's base vec
    add bh, dl          ;   N: add slave's base vec
    mov bl, bh
@@:
    mov dx, wo [di.RM_OldIntVec][0]
    mov cx, wo [di.RM_OldIntVec][2]
    mov ax, Set_RM_IntVector
    int 31h
    pop ax
term_no_dpmi:
ENDIF
    mov dx, __WinFlags      ;In Standard mode the PIC interrupt
    test    dl, WF_STANDARD     ;  priorities are changed to favor
    jz  Terminate48     ;  the comm ports.

    call    Rotate_PIC      ;This port no longer needs priority

Terminate48:
    ; *** reset int vector to it's previous state
    assumes ds,nothing
    push    ds          ;Save original DS [rkh] ...
    lds dx, [di.OldIntVec]
    mov ah, 25h         ;DOS Set Vector Function
    int 21h         ;Set the DOS vector
    pop ds          ;Original DS
    assumes ds,data

; *** interrupt vectors have been reset if needed at this point ***
;
Terminate49:
    mov cl, [di.OldMask]

; Set the 8259 interrupt mask bit for this IRQ.  Leave interrupts enabled
; if they were already enabled when the comm port was initialized by us.

    or  cl, cl
    jnz @f
Terminate495:
    call    UnmaskIRQ
@@:

    xor ax, ax
    xchg    ax, [si.NextDEB]
    cmp [di.First_DEB], si  ;Q: DEB first for IRQ hook?
    je  short Terminate46   ;   Y:
    mov bx, [di.First_DEB]  ;   N: get first
Terminate453:
    cmp [bx.NextDEB], si    ;Q: does this DEB point to one terminating?
    je  Terminate455        ;   Y:
    mov bx, [bx.NextDEB]    ;   N: get next DEB
    jmp Terminate453
Terminate455:
    mov [bx.NextDEB], ax    ; link previous DEB to NextDEB
    jmp short Terminate47
Terminate46:
    mov [di.First_DEB], ax  ; point IRQ hook at NextDEB
Terminate47:
    pop bx          ;Original BX

    call    ReleaseCOMport386   ; give port back to 386...

    pop cx          ;Original CX

Terminate50:                ;Also called from $INICOM !
    xor ax,ax           ;Indicate no error
    ret             ;Port is closed and deallocated

Terminate   endp
page

;----------------------------Public Routine-----------------------------;
;
; $ENANOTIFY - Enable Event Notification
;
; Entry:
;   AH     =  Device ID
;   BX     =  Window handle for PostMessage
;   CX     =  Receive threshold
;   DX     =  Transmit threshold
; Returns:
;   AX = 1, if no errors occured
; Error Returns:
;   AX = 0
; Registers Preserved:
;   BX,SI,DI,DS
; Registers Destroyed:
;   AX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $ENANOTIFY
$ENANOTIFY proc near
    push    si
    call    GetDEB
    mov ax, 0
    jc  scb_exit

    mov ax, cx
    inc ax
    jz  short scb_recv_ok
    cmp cx, [si.QInSize]    ;Q: receive threshold reasonable?
    jb  short scb_recv_ok   ;   Y:
%OUT should we return an error, if thresholds invalid?
    mov cx, [si.QInSize]    ;   N:
    sub cx, 10
scb_recv_ok:
    inc dx
    jz  short scb_send_ok
    dec dx
    cmp dx, [si.QOutSize]   ;Q: receive threshold reasonable?
    jb  short scb_send_ok   ;   Y:
    mov dx, [si.QOutSize]   ;   N:
    sub dx, 10
scb_send_ok:
    mov [si.NotifyHandle], bx
    mov [si.NotifyFlagsHI], CN_Notify
    or  bx, bx          ;Q: null callback?
    jnz scb_save_thresholds ;   N: save thresholds
    or  cx, -1          ;   Y: zero thresholds
    xor dx, dx
    mov [si.NotifyFlagsHI], 0
scb_save_thresholds:
    mov [si.RecvTrigger], cx
    mov [si.SendTrigger], dx
    or  [si.NotifyFlagsHI], CN_TRANSMIT ; we don't want to send
                    ; a transmit trigger notification until
                    ; the transmit buffer has been filled
                    ; above the trigger level and then
                    ; emptied below it again!

    cmp wo lpPostMessage[2], 0  ;Q: gotten addr of PostMessage yet?
    jne short scb_good      ;   Y:
    push    ds          ;   N: get module handle of USER
    lea ax, szUser
    push    ax
    cCall   GetModuleHandle

    push    ax          ; module handle
    mov ax, POSTMESSAGE
    cwd
    push    dx
    push    ax
    cCall   GetProcAddress
    mov wo lpPostMessage[0], ax ; save received proc address
    mov wo lpPostMessage[2], dx

scb_good:
    mov ax, 1

scb_exit:
    pop si
    ret
$ENANOTIFY endp
page

;----------------------------Public Routine-----------------------------;
;
; $SETQUE - Set up Queue Pointers
;
; Sets pointers to Receive and Transmit Queues, as provided by the
; caller, and initializes those queues to be empty.
;
; Queues must be set before $INICOM is called!
;
; Entry:
;   AH     =  Device ID
;   ES:BX --> Queue Definition Block
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = error code
; Registers Preserved:
;   BX,DX,SI,DI,DS
; Registers Destroyed:
;   AX,CX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $SETQUE
$SETQUE proc near

    push    si          ;These will be used
    push    di
    call    GetDEB          ;Get DEB
    jc  SetQue10        ;Invalid, ignore the call
    js  SetQue10        ;Ignore call for LPT ports
    push    ds          ;Set ds:si --> QDB
    push    es          ;Set es:di --> to ComDCB.QInAddr
    pop ds
    assumes ds,nothing
    pop es
    assumes es,Data
    lea di,QInAddr[si]
    mov si,bx
    cld
    FCLI             ;No one else can play with queues
    movsw               ; QInAddr     = QueueRxAddr
    movsw
    .errnz QueueRxAddr
    sub si, 4           ; AltQInAddr  = QueueRxAddr
    mov cx, 5           ; QInSize     = QueueRxSize
    rep movsw           ; QOutAddr    = QueueTxAddr
    sub si, 4
    mov cx, 3           ; AltQOutAddr = QueueTxAddr
    rep movsw           ; QOutSize    = QueueTxSize

    xor ax,ax           ;Will do some zero filling
    mov cl,(EFlags-QInCount)/2
    .errnz (EFlags-QInCount) AND 0FE01h
    rep stosw
    FSTI
    push    es          ;Restore the data segment
    pop ds
    assumes ds,Data
    assumes es,nothing

SetQue10:
    pop di          ;Restore saved registers
    pop si
    ret

; The above code made a few assumptions about how memory
; was allocated within the structures:

    .errnz AltQInAddr-QInAddr-4
    .errnz (QueueRxSize-QueueRxAddr)-(QInSize-AltQInAddr)
    .errnz (QueueTxAddr-QueueRxSize)-(QOutAddr-QInSize)
    .errnz AltQOutAddr-QOutAddr-4
    .errnz (QueueTxSize-QueueTxAddr)-(QOutSize-AltQOutAddr)

    .errnz QueueRxSize-QueueRxAddr-4
    .errnz QueueTxAddr-QueueRxSize-2
    .errnz QueueTxSize-QueueTxAddr-4

    .errnz QInSize-AltQInAddr-4
    .errnz QOutAddr-QInSize-2
    .errnz QOutSize-AltQOutAddr-4

    .errnz QInCount-QOutSize-2
    .errnz QInGet-QInCount-2
    .errnz QInPut-QInGet-2
    .errnz QOutCount-QInPut-2
    .errnz QOutGet-QOutCount-2
    .errnz QOutPut-QOutGet-2
    .errnz EFlags-QOutPut-2       ;First non-queue item

$SETQUE endp
page

;----------------------------Public Routine-----------------------------;
;
; $SETCOM - Set Communications parameters
;
; Re-initalizes the requested port if present, and sets up the
; port with the given attributes when they are valid.
;
; For LPT ports, just copies whatever is given since it's ignored
; anyway.
;
; Entry:
;   ES:BX --> DCB with all fields set.
; Returns:
;   'Z' Set if no errors occured
;   AX = 0
; Error Returns:
;   'Z' clear if errors occured
;   AX = initialization error code.
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $SETCOM
$SETCOM proc near

    cld
    push    si
    push    di
    mov ah,es:[bx.DCB_Id]   ;Get device i.d.
    call    GetDEB          ;Get DEB pointer in SI
    mov ax,IE_BadID     ;Assume unknown device
    jc  SetCom10        ;Invalid device, return error
    jns SetCom20        ;COM port
    call    SetCom100       ;Copy the DCB

SetCom5:
    xor ax,ax           ;Show no error

SetCom10:
    or  ax,ax           ;Set/clear 'Z'
    pop di          ;  and exit
    pop si
    ret

;-----------------------------------------------------------------------;
;       Have a comm device, check all the serial parameters to make
;       sure they are correct before moving the new DCB into our space
;       and changing the ACE parameters.
;-----------------------------------------------------------------------;

SetCom20:
    call    SetCom300       ;Baud rate valid?
    jcxz    SetCom10        ;  No, return error
    call    SetCom400       ;Byte size/parity/stop bits correct?
    jc  SetCom10        ;  No, return error

; The parameters seem correct.  Copy the DCB into our space and
; initialize the ACE with the new parameters

    mov dx,Port[si]     ;Disable interrupts from the 8250
    inc dx
    .errnz ACE_IER-1
    xor ax,ax
    out dx,al
    call    FlagNotActive

    call    SetCom100       ;Copy the DCB
    mov bx,si           ;Set ES:BX --> DCB
    call    SetCom200       ;Get timeout masks
    xchg    al,ah           ;Want them in the correct registers
    mov wo MSRMask[si],ax
    .errnz MSRInfinite-MSRMask-1

    call    SetCom400       ;Get line control byte
    push    ax          ;  and save LCR value
    inc dx          ;--> LCR
    inc dx
    .errnz ACE_LCR-ACE_IER-2
    or  al,ACE_DLAB     ;Want access to divisor latch
    out dx,al
    mov RxMask[si],ah       ;Save Receive character mask
    mov ax,di           ;Get flags mask, error mask
    and [si.DCB_Flags],ah   ;Disable parity checking if no parity
    mov ErrorMask[si],al    ;Save line status error mask

    call    SetCom300       ;Get baud rate
    sub dl,ACE_LCR-ACE_DLL  ;--> LSB of divisor latch
    mov al,cl
    out dx,al
    mov al,ch
    inc dx          ;--> MSB of divisor latch
    .errnz ACE_DLM-ACE_DLL-1
    iodelay
    out dx,al
    inc dx          ;--> LCR and clear divisor access bit
    inc dx
    .errnz ACE_LCR-ACE_DLM-2
    pop ax
    out dx,al

    inc dx          ;--> Modem Control Register
    .errnz ACE_MCR-ACE_LCR-1

;-----------------------------------------------------------------------;
;       Compute initial state of DTR and RTS.  If they have been disabled,
;       then do not raise them, and disallow being used as a handshaking
;       line.  Also compute the bits to use as hardware handshake bits
;       (DTR and/or RTS as indicated, qualified with the disabled flags).
;-----------------------------------------------------------------------;

    mov al,[si.DCB_Flags]   ;Align DTR/RTS disable flags for 8250
    and al,fRTSDisable+fDTRDisable
    rol al,1            ;d0 = DTR, d2 = RTS  (1 = disabled)
    shr al,1            ;'C'= DTR, d1 = RTS
    adc al,0            ;d0 = DTR, d1 = RTS
    .errnz  fRTSDisable-00000010b
    .errnz  fDTRDisable-10000000b
    .errnz  ACE_DTR-00000001b
    .errnz  ACE_RTS-00000010b

    mov ah,al           ;Save disable mask
    xor al,ACE_DTR+ACE_RTS+ACE_OUT2
    out dx,al           ;Set Modem Control Register

    mov al,[si.DCB_Flags2]  ;Get hardware handshake flags
    rol al,1            ;Align flags as needed
    rol al,1
    rol al,1
    and al,ACE_DTR+ACE_RTS  ;Mask bits of interest
    not ah          ;Want inverse of disable mask
    and al,ah           ;al = bits to handshake with
    mov HHSLines[si],al     ;Save for interrupt code

    .errnz  fDTRFlow-00100000b
    .errnz  fRTSFlow-01000000b
    .errnz  ACE_DTR-00000001b
    .errnz  ACE_RTS-00000010b

    mov al,[si.DCB_Flags]   ;Compute the mask for the output
    shl al,1            ;  hardware handshake lines
    and al,ACE_DSR+ACE_CTS
    mov OutHHSLines[si],al

    .errnz  fOutXCTSFlow-00001000b
    .errnz  fOutXDSRFlow-00010000b
    .errnz  ACE_CTS-00010000b
    .errnz  ACE_DSR-00100000b

; Compute the queue count where XOff should be issued (or hardware
; lines dropped).  This will prevent having to do it at interrupt
; time.

    mov ax,QInSize[si]      ;Get where they want it
    sub ax,[si.DCB_XoffLim] ;  and compute queue count
    mov XOffPoint[si],ax

; Enable FIFO if possible when baudrate >= 4800
;
    sub dl,ACE_MCR - ACE_FCR    ; dx = FCR
    test    EFlags[si], fNoFIFO ;Q: FIFO can be enabled?
    jnz sc_nofifo       ;   N:
    mov ax, [si.DCB_BaudRate]
    cmp ax, 4800
    jb  sc_nofifo
    cmp ah, -1          ;Q: baudrate index?
    jne sc_fifo         ;   N: baudrate >= 4800, enable FIFO
    cmp ax, CBR_4800
    jb  sc_nofifo
%OUT this isn't correct, if lower baudrates are assigned indices above CBR_4800

sc_fifo:
    mov al, ACE_TRIG14 OR ACE_EFIFO OR ACE_CRFIFO OR ACE_CTFIFO
    out dx, al          ; attempt to enable FIFO
    test    EFlags[si], fFIFOchkd   ;Q: FIFO detect been done?
    jnz sc_fifodone     ;   Y: enabled FIFO
    iodelay
    .errnz  ACE_IIDR-ACE_FCR
    in  al, dx
    or  EFlags[si], fFIFOchkd
    test    al, ACE_FIFO_E2     ;Q: FIFO enabled?
    jz  short @F
    test    al, ACE_FIFO_E1     ;Q: 16550A detected?
    jnz sc_fifodone     ;   Y: enabled FIFO
@@:
    iodelay
    or  EFlags[si], fNoFIFO

sc_nofifo:
    xor al, al
    out dx, al
sc_fifodone:

    sub dl,ACE_FCR-ACE_RBR  ; dx -> RBR
;
; Delay for things to settle
;
    push    dx
    cCall   GetSystemMsecCount
    pop dx
    mov cx, ax
delay_loop:
    in  al, dx          ;Read it once
    push    dx
    cCall   GetSystemMsecCount
    pop dx
    sub ax, cx
    cmp ax, DELAY_TIME      ;Q: Timeout reached?
ifndef WOW
    jb  delay_loop      ;   N:
endif

    add dl,ACE_MSR      ;--> Modem Status reg
    in  al,dx           ;Throw away 1st status read
    iodelay
    in  al,dx           ;Save 2nd for MSRWait (Clear MSR int)
    mov MSRShadow[si],al

; Win 3.0 didn't check hardware handshaking until the line status changed.
; Allow some apps to keep that behavior.

    push    dx
    xor ax, ax
    cCall   GetAppCompatFlags,<ax>
    pop dx
    test    ax, GACF_DELAYHWHNDSHAKECHK
    jnz short sc_HHSup

;
; HACK FOR SOME MODEMS:  apparently some modems set CTS, but don't set DSR
; which means that COMM.DRV won't send if the app specifies that hardware
; handshaking is based on CTS & DSR being set.
;
    mov ah,OutHHSLines[si]
    mov al, MSRShadow[si]
    and al,ah           ;Only leave bits of interest
    cmp al, ah          ;Q: handshaking lines ok?
    je  short sc_HHSup      ;   Y:
    cmp ah, ACE_CTS OR ACE_DSR  ;Q: app looking for both high?
    jne short sc_HHSdown    ;   N: skip hack
    test    [si.EFlags], fUseDSR    ;Q: DSR is always significant?
    jnz short sc_HHSdown    ;   Y: skip hack
    cmp al, ACE_CTS     ;Q: DSR low & CTS high
    jne short sc_HHSdown    ;   N: skip hack
    and ah, NOT ACE_DSR     ;   Y: ignore DSR line
    mov OutHHSLines[si], ah
    jmp short sc_HHSup

sc_HHSdown:
    or  [si.HSFlag], HHSDown OR HHSAlwaysDown ; flag handshaking down
sc_HHSup:

;-----------------------------------------------------------------------;
;       Now, at last, interrupts can be enabled.  Don't enable the
;       transmitter empty interrupt.  It will be enabled by the first
;       call to KickTx.
;-----------------------------------------------------------------------;

    sub dl,ACE_MSR-ACE_IER  ;--> Interrupt Enable Register

; flag port as being active
    push    cx
    mov cl, [si.DCB_Id]
    mov ax, 1
    shl ax, cl
    or  [activeCOMs], ax
    pop cx

    mov al,ACE_ERBFI+ACE_ELSI+ACE_EDSSI
    FCLI
    out dx,al           ;Enable interrupts.
    add dl,ACE_LSR-ACE_IER  ;--> Line Status Register
    iodelay
    in  al,dx           ;Clear any Line Status interrupt
    sub dl,ACE_LSR      ;--> Receiver Buffer Register
    iodelay
    in  al,dx           ;Clear any Received Data interrupt
    FSTI
    jmp SetCom5         ;All done

$SETCOM endp
page

FlagNotActive proc near
    push    cx
    mov cl, [si.DCB_Id]
    mov ax, NOT 1
    rol ax, cl
    and [activeCOMs], ax
    pop cx
    ret
FlagNotActive endp

;----------------------------Private-Routine----------------------------;
;
; SetCom100
;
;  Copy the given DCB into the appropriate DEB.  The check has
;  already been made to determine that the ID was valid, so
;  that check can be skipped.
;
; Entry:
;   ES:BX --> DCB
;   DS:SI --> DEB
; Returns:
;   DS:SI --> DEB
;   ES     =  Data
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,ES,DI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom100 proc near
    push    si          ;Save DEB pointer
    mov di,si
    mov si,bx
    push    es
    mov ax,ds
    pop ds
    assumes ds,nothing

    mov es,ax
    assumes es,Data

    mov cx,DCBSize
    cld
    rep movsb
    mov ds,ax
    assumes ds,Data

    pop si          ;Restore DEB pointer
    ret

SetCom100   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom200
;
; Based on whether or not a timeout has been specified for each
; signal, set up a mask byte which is used to mask off lines for
; which we wish to detect timeouts.  0 indicates that the line is
; to be ignored.
;
; Also set up a mask to indicate those lines which are set for
; infinite timeout.  1 indicates that the line has infinite
; timeout.
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   AH = lines to check
;   AL = lines with infinite timeout
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom200 proc near

    xor ax,ax
    xor cx,cx           ;Get mask of lines with timeout = 0
    call    SetCom210
    not al          ;Invert result to get lines to check
    and al,ACE_CTS+ACE_DSR+ACE_RLSD
    xchg    ah,al
    dec cx          ;Get mask of infinite timeouts

SetCom210:
    cmp es:[bx.DCB_RlsTimeout],cx   ;Timeout set to passed value?
    jne SetCom220       ;  No
    or  al,ACE_RLSD     ;  Yes, show checking line

SetCom220:
    cmp es:[bx.DCB_CtsTimeout],cx   ;Timeout set to passed value?
    jne SetCom230       ;  No
    or  al,ACE_CTS      ;  Yes, show checking line

SetCom230:
    cmp es:[bx.DCB_DsrTimeout],cx   ;Timeout set to passed value?
    jne SetCom240       ;  No
    or  al,ACE_DSR      ;  Yes, show checking line

SetCom240:
    ret

SetCom200   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom300
;
; Calculate the correct baudrate divisor for the comm chip.
;
; Note that the baudrate is allowed to be any integer in the
; range 2-19200.  The divisor is computed as 115,200/baudrate.
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   CX = baudrate
; Error Returns:
;   CX = 0 if error
;   AX = error code if invalid baud rate
; Registers Destroyed:
;   AX,CX,FLAGS
; History:
;-----------------------------------------------------------------------;

BaudRateByIndexTable label word
    dw 1047     ; CBR_110
    dw 384      ; CBR_300
    dw 192      ; CBR_600
    dw 96       ; CBR_1200
    dw 48       ; CBR_2400
    dw 24       ; CBR_4800
    dw 12       ; CBR_9600
    dw 9        ; CBR_14400
    dw 6        ; CBR_19200
    dw 0        ;    0FF19h  (reserved)
    dw 0        ;    0FF1Ah  (reserved)
    dw 3        ; CBR_38400
    dw 0        ;    0FF1Ch  (reserved)
    dw 0        ;    0FF1Dh  (reserved)
    dw 0        ;    0FF1Eh  (reserved)
    dw 2        ; CBR_56000

assumes ds,Data
assumes es,nothing

SetCom300 proc near

    push    dx
    mov cx,es:[bx.DCB_BaudRate] ;Get requested baud rate
    xor ax,ax           ;Assume error
    cmp cx, CBR_110     ;Q: baudrate specified as an index?
    jae by_index
    cmp cx,2            ;Within valid range?
    jnae    SetCom310       ;  No, return error

    mov dx,1            ;(dx:ax) = 115,200
    mov ax,0C200h
    div cx          ;(ax) = 115,200/baud

SetCom310:
    mov cx,ax           ;(cx) = baud rate, or error code (0)
    mov ax,IE_Baudrate      ;Set error code incase bad baud
    pop dx
    ret

by_index:
    cmp cx, CBR_56000       ;Q: above supported?
    ja  SetCom310       ;   Y: return error
    push    bx
    mov bx, cx
    sub bx, CBR_110
    shl bx, 1
    mov ax, cs:[bx+BaudRateByIndexTable]    ; get divisor
    pop bx
    jmp SetCom310       ;   Y: return error


SetCom300   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom400
;
; Check the line configuration (Parity, Stop bits, Byte size)
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   'C' clear if OK
;   AL = Line Control Register
;   AH = RxMask
;   DI[15:8] = Flags mask (to remove parity checking)
;   DI[7:0]  = Error mask (to remove parity error)
; Error Returns:
;   'C' set if error
;   AX = error code
; Registers Destroyed:
;   AX,CX,DI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom400   proc   near

    mov ax,wo es:[bx.DCB_ByteSize]  ;al = byte size, ah = parity
    cmp ah,SpaceParity      ;Parity out of range?
    ja  SetCom470       ;  Yes, return error
    mov di,0FF00h+ACE_OR+ACE_PE+ACE_FE+ACE_BI
    or  ah,ah           ;Is parity "NONE"?
    jnz SetCom410       ;  No, something is there for parity
    xor di,(fParity*256)+ACE_PE ;Disable parity checking

SetCom410:
    cmp al,8            ;Byte size out of range?
    ja  SetCom460       ;  Yes, error

SetCom420:
    sub al,5            ;Shift byte size to bits 0&1
    .errnz ACE_WLS-00000011b    ;Word length must be these bits
    jc  SetCom460       ;Byte size is illegal, return error
    add ah,ah           ;Map parity to ACE bits
    jz  SetCom430       ;0=>0, 1=>1, 2=>3, 3=>5, 4=>7
    dec ah

SetCom430:
    shl ah,1            ;Align with 8250 parity bits
    shl ah,1
    shl ah,1
    or  al,ah           ;Add to byte size

    .errnz NoParity-0
    .errnz OddParity-1
    .errnz EvenParity-2
    .errnz MarkParity-3
    .errnz SpaceParity-4
    .errnz ACE_PEN-00001000b
    .errnz ACE_PSB-00110000b
    .errnz ACE_EPS-00010000b
    .errnz  ACE_SP-00100000b

    or  al,ACE_2SB      ;Assume 2 stop bits
    mov ah,es:[bx.DCB_StopBits] ;Get # of stop bits 0=1,1/2= .GT. 1
    or  ah,ah           ;Out of range?
    js  SetCom470       ;  Yes, return error
    jz  SetCom440       ;One stop bit
    sub ah,2
    jz  SetCom450       ;Two stop bits
    jns SetCom470       ;Not 1.5, return error
    test    al,ACE_WLS      ;1.5 stop bits, 5 bit words?
    jnz SetCom470       ;  No, illegal
    .errnz OneStopBit-0
    .errnz One5StopBits-1
    .errnz TwoStopBits-2
    .errnz ACE_5BW

SetCom440:
    and al,NOT ACE_2SB      ;Show 1 (or 1.5) stop bit(s)


; From the byte size, get a mask to be used for stripping
; off unused bits as the characters are received.

SetCom450:
    push    dx
    mov cl,es:[bx.DCB_ByteSize] ;Get data byte size
    mov dx,00FFh        ;Turn into mask by shifting bits
    shl dx,cl
    mov ah,dh           ;Return mask in ah
    pop dx
    clc             ;Show all is fine
    ret

SetCom460:
    mov ax,IE_ByteSize      ;Show byte size is wrong
    stc             ;Show error
    ret

SetCom470:
    mov ax,IE_Default       ;Show something is wrong
    stc             ;Show error
    ret

SetCom400 endp
page

;----------------------------------------------------------------------------
; SuspendOpenCommPorts:
;
; This routine is called from 286 Winoldaps to simply deinstall the comm port
; hooks.
;----------------------------------------------------------------------------

cProc   SuspendOpenCommPorts,<FAR,PUBLIC,PASCAL>

cBegin  nogen

    assumes cs,Code
    assumes ds,Data

%OUT not masking IRQ's

    ; Nothing to do under 3.1!

    ret

cEnd    nogen

;----------------------------------------------------------------------------;
; ReactivateOpenCommPorts:                           ;
;                                        ;
; This routine reinstalls the comm hooks in real mode and reads the 8250     ;
; data and status registers to clear pending interrupts.             ;
;----------------------------------------------------------------------------;

cProc   ReactivateOpenCommPorts,<FAR,PASCAL,PUBLIC>,<si,di>

cBegin
    call    Rotate_PIC      ;make comm ports highest priority

    mov cx, MAXCOM+1
    mov di,dataOffset COMptrs
rcp_loop:
    mov si, [di]
    mov dx, Port[si]
    or  dx, dx
    jz  @f
    call    InitAPort       ;read comm port regs to clr pending ints
@@:
    add di, 2
    loop    rcp_loop

cEnd

;----------------------------------------------------------------------------;
; InitAPort:                                     ;
;                                        ;
; reads the data,status & IIR registers of a port (has to be 8250!)      ;
;                                        ;
; If the port has an out queue pending, then this woutine will also start    ;
; the transmit process by faking a comm interrupt.               ;
;----------------------------------------------------------------------------;

public     InitAPort
InitAPort  proc near

    add dl,ACE_RBR      ;dx=receive buffer register
    in  al,dx           ;read the data port
    jmp short $+2       ;i/o delay
    add dl,ACE_LSR - ACE_RBR    ;get to the status port
    in  al,dx           ;read it too.
    jmp short $+2       ;i/o delay
    add dl,ACE_IIDR - ACE_LSR   ;get to the line status register
    in  al,dx           ;read it once more
    jmp short $+2       ;i/o delay
    add dl,ACE_MSR - ACE_IIDR   ;get to the modem status register
    in  al,dx           ;read it once more
    jmp short $+2       ;i/o delay
    add dl,ACE_RBR - ACE_MSR    ;get to the receive buffer register
    in  al,dx           ;read it once more
    jmp short $+2       ;i/o delay
    call    UnmaskIRQ

; now if the port has characters pending to be sent out then we must fake a
; comm interrupt.

    cmp [si].QOutCount,0    ;characters pending to be sent ?
    jz  @f          ;no.
    FCLI             ;disable interrupts
    call    FakeCOMIntFar       ;fake an interrupt
    FSTI             ;renable interrupts
@@:
    ret

InitAPort endp

page

;----------------------------Public Routine-----------------------------;
;
; $DCBPtr - Return Pointer To DCB
;
; Returns a long pointer to the DCB for the requested device.
;
; Entry:
;   AH = Device ID
; Returns:
;   DX:AX = pointer to DCB.
; Error Returns:
;   DX:AX = 0
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   BX,CX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $DCBPTR
$DCBPTR proc   near

        push    si
        xor     dx,dx
        call    GetDEB                  ;Get pointer to DEB
        mov     ax,dx
        jc      DCBPtr10                ;Jump if invalid device
        mov     ax,si                   ;else return value here
        mov     dx,ds

DCBPtr10:
        pop     si
        ret

$DCBPTR endp
page

;----------------------------Private-Routine----------------------------;
;
; GetDEB - Get Pointer To Device's DEB
;
; Returns a pointer to appropriate DEB, based on device number.
;
; Entry:
;   AH = cid
; Returns:
;   'C' clear
;   'S' set if LPT device
;   DS:SI --> DEB is valid cid
;   AH     =  cid
; Error Returns:
;   'C' set if error (cid is invalid)
;   AX = 8000h
; Registers Preserved:
;   BX,CX,DX,DI,DS,ES
; Registers Destroyed:
;   AX,SI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public GetDEB               ;Public for debugging
GetDEB proc near

    push    cx
    mov cl, ah
    and cx, (NOT LPTx AND 0FFh)
    test    ah, ah          ;Q: LPT id?
    js  short GetDEB10      ;   Y:
.errnz LPTx - 80h
    cmp ah, MAXCOM      ;Q: Within range?
    ja  GetDEB30        ;   N: return invalid ID
    shl cx, 1
    mov si, cx
    mov si, [si+COMptrs]
    jmp short GetDEB20

GetDEB10:
    cmp ah, LPTx+MAXLPT     ;Q: Within range?
    ja  GetDEB30        ;   N: return invalid ID
    mov si, DataOFFSET LPT1
    jcxz    GetDEB20
GetDEB15:
    add si, SIZE LptDEB
    loop    GetDEB15
GetDEB20:
    pop cx
    or  ah, ah          ; clear Carry & set S, if LPT port
    ret

GetDEB30:
    pop cx
    mov ax,8000h        ;Set error code
    stc             ;Set 'C' to show error
    ret

GetDEB endp
page


CvtHex proc near
;   assume DS=SS
    push    si
    mov cl, 4
    mov si, di
    xor dx, dx
    cld
ch_lp:
    lodsb
    sub al, '0'         ;Q: char < '0'
    jb  ch_exit         ;   Y: return
    cmp al, 9           ;Q: char <= '9'
    jbe ch_got_digit        ;   Y: move digit into result
    sub al, 'A' - '0'       ;Q: char < 'A'
    jb  ch_exit         ;   Y: return
    add al, 10
    cmp al, 15          ;Q: char <= 'F'
    jbe ch_got_digit        ;   Y: move hex char into result
    sub al, 10 + 'a' - 'A'  ;Q: char < 'a'
    jb  ch_exit         ;   Y: return
    add al, 10
    cmp al, 15          ;Q: char > 'f'
    ja  ch_exit         ;   Y: return
ch_got_digit:
    shl dx, cl
    or  dl, al
    jmp ch_lp
ch_exit:
    mov ax, dx
    pop si
    ret
CvtHex endp

.286
; attempt to read base from SYSTEM.INI
GetComBase proc near
    push    ds              ; save our DS
    sub sp, 6
    mov di, sp
    mov byte ptr ss:[di], 0
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommBase
    push    ss              ; temp buffer
    push    di
    push    ss              ; default = temp buffer
    push    di
    push    5
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileString     ;   our segment in real mode
    or  ax, ax
    jz  short gcb_exit
    call    CvtHex              ; DS still equal to SS
gcb_exit:
    add sp, 6
    pop ds              ; restore our DS
    assumes ds,Data
    ret
GetComBase endp

GetPortIRQ proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommIrq
    push    bx
    mov bl, [si.DCB_Id]
    cmp bl, 4
    jb  @f
    mov bl, 4
@@:
    xor bh, bh
    mov bl, [bx+default_table]
    mov cx, bx
    pop bx
    push    cx              ; default
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    ret
GetPortIRQ endp


GetPortFlags proc near
    mov al, [si.DCB_Id]
.erre MAXCOM LT 9           ;only single digit port numbers supported
    add al, '1'
    mov [CommFIFOX], al
    mov [CommDSRx], al
    call    GetPortFIFO
    call    GetPortDSR
    ret
GetPortFlags endp

GetPortFIFO proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommFifo
    push    2
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    cmp ax, 1
    ja  short gpf_exit          ; just check at open
    jb  short gpf_no_fifo       ; force OFF, if = 0
    or  EFlags[si], fFIFOchkd       ; flag as checked, to force ON
    jmp short gpf_exit

gpf_no_fifo:
    or  EFlags[si], fNoFIFO OR fFIFOchkd    ; force OFF

gpf_exit:
    ret
GetPortFIFO endp

GetPortDSR proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommDSR
    push    0
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    or  ax, ax
    jz  short gpd_exit
    or  EFlags[si], fUseDSR

gpd_exit:
    ret
GetPortDSR endp


; FindCOMPort
;
; DS:SI -> DEB
;
    PUBLIC FindCOMPort
FindCOMPort proc near
;
; Examine BIOS data area to get base I/O addresses for COM and LPT ports
;
    push    bx
    push    cx
    push    es
    mov ax, __0040H
    mov es, ax
    assumes es,nothing

    mov al, [si.DCB_Id]
    mov ah, al
.erre MAXCOM LT 9           ;only single digit port numbers supported
    add ah, '1'
    mov [CommBaseX], ah
    mov [CommIRQX], ah
    mov [CommFIFOX], ah
    mov [CommDSRx], ah

    cmp al, 4
    jae fcp_not_phys_com
    xor ah, ah
    shl ax, 1
    mov bx, ax
    mov ax, es:[bx+RS232B]
    or  ax, ax
    jnz fcp_got_com_base
fcp_not_phys_com:
    call    GetComBase
    or  ax, ax
    jnz fcp_got_com_base
    mov bl, [si.DCB_Id]
    cmp bl, 2
    jne fcp_invalid     ; jump, if base = 0 & com port <> com3
    mov ax, 3E8h        ; default COM3 to 3E8h
fcp_got_com_base:
    push    ax
    call    GetPortIRQ
    mov dx, ax
    pop ax
    or  dl, dl          ;Q: non-zero IRQ?
    jz  fcp_invalid     ;   N:
    cmp dl, 15          ;Q: IRQ in range?
    ja  fcp_invalid     ;   N:
    xor dh, dh
    push    ax
    push    dx
    call    GetPortFIFO
    call    GetPortDSR
    pop dx
    pop ax
    clc
fcp_exit:
    pop es
    pop cx
    pop bx
    ret

fcp_invalid:
    or  ax, -1
    mov dx, ax
    stc
    jmp fcp_exit

FindCOMPort endp
.8086

page
;--------------------------Private Routine-----------------------------;
;
; Rotate the PIC interrupt priorities so the communication ports are
; highest priority.
;
; NOTE: Only rotates priorities on master PIC.
;
;-----------------------------------------------------------------------;

    assumes ds,Data
    assumes es,nothing

    public Rotate_PIC

Rotate_PIC proc near

    push    ax
    push    cx
    push    di

    mov al, 8           ; 0 - 7 rotated
    mov cx, MAXCOM+1
    mov di, DataOFFSET IRQhooks
rp_loop:
    mov ah, [di.IRQn]
    cmp ah, 0           ;End of hooked IRQ list?
    je  rp_set
    cmp [di.VecN], 0FFh     ;Hooked?
    je  rp_next
    cmp ah, 8           ;If on slave PIC, treat as IRQ2
    jb  @f
    mov ah, 2
@@:
    cmp ah, al
    jae rp_next
    mov al, ah          ;AL = lowest hooked comm IRQ
rp_next:
    add di, SIZE IRQ_Hook_Struc
    loop    rp_loop

rp_set:
    dec al          ;Setting IRQ(n-1) as the lowest
    and al,  07h        ;  priority makes IRQn the highest
    or  al, 0C0h
    out INTA0, al

    pop di
    pop cx
    pop ax
    ret

Rotate_PIC endp


ifdef DEBUG
    public  InitCom10, InitCom20, InitCom40, InitCom50, InitCom59
    public  InitCom60, InitCom70, InitCom80, InitCom90, InitCom100
    public  TermCom10, TermCom15, TermCom20, TermCom30
    public  TermCom60, Terminate5, Terminate10, Terminate20, Terminate30
    public  Terminate45, Terminate49, Terminate50
    public  SetQue10
    public  SetCom5, SetCom10, SetCom20, SetCom210, SetCom220, SetCom230
    public  SetCom240, SetCom310, SetCom410, SetCom420, SetCom430
    public  SetCom440, SetCom450, SetCom460, SetCom470
    public  GetDEB10, GetDEB20, GetDEB30
    public  DCBPtr10
endif

sEnd    code

page

createSeg _INIT,init,word,public,CODE
sBegin init
assumes cs,init



;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
IBMmodel proc near
      push  ax
      push  bx
      push  es

      mov   ah, 0c0h
      int   15h
      jc    IBMmodel_exit

      assumes es,nothing

      cmp   by es:[bx+2], 0f8h      ; PS/2 80
      je    IBMmodel_exit       ;   return carry clear

      cmp   by es:[bx+2], 0fch      ; AT or PS/2 50 or 60
      jne   OldBios         ; assume OldBios

      cmp   by es:[bx+3], 04h       ; PS/2 50
      je    IBMmodel_exit       ;   return carry clear
      cmp   by es:[bx+3], 05h       ; PS/2 60
      je    IBMmodel_exit       ;   return carry clear

OldBios:
      stc

IBMmodel_exit:
      pop   es
      pop   bx
      pop   ax
      ret

IBMmodel endp

cProc LoadLib, <FAR,PUBLIC,NODATA>,<si,di>
cBegin

    push    ds
    mov ax, __F000H
    mov ds, ax
    assumes ds, ROMBios
    mov al, [MachineID]
    pop ds
    assumes ds,Data
    mov [$MachineID], al

    call    IBMmodel        ;Q: PS/2?
    jc  @F          ;   N:
    mov [default_table+2], 3    ;   Y: change COM3 default IRQ to 3
@@:

    push    ds
    mov ax, __0040H
    mov ds, ax
    assumes ds,nothing
    cmp word ptr ds:[RS232B], 2F8h  ;Q: COM2 base in COM1 slot?
    pop ds
    assumes ds,Data
    jne @F              ;   N: leave IRQ default as 4
    mov [default_table], 3      ;   Y: change IRQ default to 3
@@:

    mov [fVPICD], -1        ; assume no

    xor di, di
    mov es, di
    mov ax, GET386API
    mov bx, VPICD
    int MULTIPLEX
    mov wo [lpfnVPICD], di
    mov wo [lpfnVPICD+2], es
    mov ax, es
    or  ax, di
    jz  short no_VPICD      ; jump if no bimodel services available
;
; version check VPICD
;
    mov ax, VPICD_API_Get_Ver
    call    [lpfnVPICD]
%OUT version check VPICD

    mov [fVPICD], 1     ; flag services are available

IFDEF No_DOSX_Bimodal_Services
    jmp short skip_dosx_stuff

no_VPICD:
    mov ax, __WinFlags
    and al, WF_PMODE or WF_WIN286
    cmp al, WF_PMODE or WF_WIN286
    jne skip_dosx_stuff

.286
    mov ax, Int31_Get_Version SHL 8
    int 31h
    test    bl, 10b         ;Q: processor goes to real mode
                    ;   for int reflection?
    jz  skip_dosx_stuff     ;   N:
    mov [Using_DPMI], 0FFh  ;   Y: flag use of DPMI

    mov ax, ds
    cCall   GetSelectorBase,<ax>    ;DX:AX = segment of selector
    shr ax, 4
    shl dl, 4
    or  ah, dl          ;AX now points to interrupt *segment*
    push    ax          ;save on stack
    mov ax, _INTERRUPT      ;write data SEGMENT into _INTERRUPT
    cCall   AllocCStoDSAlias,<ax>   ; code segment -- requires a data alias
    mov es, ax
    pop ax
    mov es:[RM_IntDataSeg],ax
    push    ds
    push    es
    mov ax, ds
    mov es, ax
    mov ax, _INTERRUPT
    mov ds, ax
    mov ax, (Int31_Trans_Serv SHL 8) + Trans_Call_Back
    mov si, IntCodeOFFSET Entry_From_RM
    mov di, DataOFFSET RM_Call_Struc
    int 31h
    pop es
    pop ds
    mov ax, 0
    jnc @f
    jmp short LoadExit
@@:
    mov wo es:[RM_CallBack], dx
    mov wo es:[RM_CallBack+2], cx
    cCall   FreeSelector,<es>    ;don't need CS alias any longer
.8086
skip_dosx_stuff:
ELSE
no_VPICD:
ENDIF

;
; find base values for LPT ports
;
    mov cx, __0040h
    mov es, cx
    mov cx, MAXLPT+1
    mov si, DataOFFSET LPT1
ll_initl_lp:
    mov bx, [si.BIOSPortLoc]
    or  bx, bx
    jz  ll_not_phys_lpt
    mov ax, es:[bx]
    or  ah, ah          ;Q: lpt redirected, or 0?
    jz  ll_not_phys_lpt     ;   Y:
    cmp bx, LPTB        ;Q: first LPT?
    je  ll_got_lpt_base     ;   Y:
    cmp ax, es:[bx-2]       ;Q: base same as previous (redirected)?
    jne ll_got_lpt_base     ;   N: must be real
ll_not_phys_lpt:
%OUT attempt to read base from SYSTEM.INI

ll_got_lpt_base:
    mov [si.Port], ax
    loop    ll_initl_lp

;
; create system timer for signalling chars in receive buffer
;

ifndef WOW
    mov ax, 100         ; create 100msec timer
    push    ax
    mov ax, _INTERRUPT
    push    ax
    mov ax, IntCodeOFFSET TimerProc
    push    ax
    call    CreateSystemTimer   ; ax = 0, if failed
%OUT should I display an error message here?

endif
    assumes es,nothing
LoadExit:
cEnd

sEnd    init

End LoadLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\display\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\comm\ins8250.inc ===
; INS8250 ACE Register Offsets And Bit Definitions


ACE_RBR         equ     0               ;Receiver Buffer
ACE_THR         equ     0               ;Transmit Holding Register

ACE_IER         equ     1               ;Interrupt Enable
  ACE_ERBFI     equ     00000001b       ;  Received Data Available
  ACE_ETBEI     equ     00000010b       ;  Transmitter Holding Register Empty
  ACE_ELSI      equ     00000100b       ;  Receiver Line Status
  ACE_EDSSI	equ	00001000b	;  Modem Status

ACE_FCR 	equ	2		;FIFO control register
  ACE_EFIFO	equ	00000001b	;  Enable FIFO
  ACE_CRFIFO	equ	00000010b	;  Clear receive FIFO queue
  ACE_CTFIFO	equ	00000100b	;  Clear transmit FIFO queue
  ACE_TRIG01	equ	00000000b	;  Trigger receive int on every char
  ACE_TRIG04	equ	01000000b	;  Trigger receive int on every 4th char
  ACE_TRIG08	equ	10000000b	;  Trigger receive int on every 8th char
  ACE_TRIG14	equ	11000000b	;  Trigger receive int on every 14th char

ACE_IIDR        equ     2               ;Interrupt Identification
  ACE_IIP       equ     00000001b       ;  Inverted Interrupt Pending (0=int)
  ACE_IID       equ     00000110b       ;  Interrupt ID
  ACE_MSI       equ     00000000b       ;  Modem Status
  ACE_THREI     equ     00000010b       ;  Transmitter Holding Register Empty
  ACE_RDAI      equ     00000100b       ;  Received Data Available
  ACE_RLSI      equ     00000110b       ;  Receiver Line Status
  ACE_FIFO_E1	equ	01000000b	;set, if FIFO enabled on 16550A
  ACE_FIFO_E2	equ	10000000b	;set, if FIFO enabled on 16550 or 16550A

ACE_LCR         equ     3               ;Line Control
  ACE_WLS       equ     00000011b       ;  Word Length Select Bits
  ACE_WLS0      equ     00000001b       ;  Word Length Select Bit 0
  ACE_WLS1      equ     00000010b       ;  Word Length Select Bit 1
  ACE_5BW       equ     00000000b       ;  5 Bit Words
  ACE_6BW       equ     00000001b       ;  6 Bit Words
  ACE_7BW       equ     00000010b       ;  7 Bit Words
  ACE_8BW       equ     00000011b       ;  8 Bit Words
  ACE_STB       equ     00000100b       ;  Stop Bits
  ACE_1SB       equ     00000000b       ;  1 Stop Bits (1.5 for 5 bit words)
  ACE_2SB       equ     00000100b       ;  2 Stop Bits
  ACE_PEN       equ     00001000b       ;  Parity Enable
  ACE_PSB       equ     00110000b       ;  Parity select bits
  ACE_EPS       equ     00010000b       ;  Even Parity Select
  ACE_SP        equ     00100000b       ;  Stick Parity
  ACE_SB        equ     01000000b       ;  Set Break
  ACE_DLAB      equ     10000000b       ;  Divisor Latch Access Bit

ACE_MCR         equ     4               ;Modem Control
  ACE_DTR       equ     00000001b       ;  Data Terminal ready
  ACE_RTS       equ     00000010b       ;  Request To Send
  ACE_OUT1      equ     00000100b       ;  Output Line 1
  ACE_OUT2      equ     00001000b       ;  Output Line 2
  ACE_LOOP      equ     00010000b       ;  Loopback

ACE_LSR         equ     5               ;Line Status
  ACE_DR        equ     00000001b       ;  Data Ready
  ACE_OR        equ     00000010b       ;  Overrun Error
  ACE_PE        equ     00000100b       ;  Parity Error
  ACE_FE        equ     00001000b       ;  Framing Error
  ACE_BI        equ     00010000b       ;  Break Interrupt
  ACE_THRE      equ     00100000b       ;  Transmitter Holding Register Empty
  ACE_TSRE      equ     01000000b       ;  Transmitter Shift Register Empty

ACE_MSR         equ     6               ;Modem Status
  ACE_DCTS      equ     00000001b       ;  Delta Clear to Send
  ACE_DDSR      equ     00000010b       ;  Delta Data Set Ready
  ACE_TERI      equ     00000100b       ;  Trailing Edge Ring Indicator
  ACE_DRLSD     equ     00001000b       ;  Delta Receive Line Signal Detect
  ACE_CTS       equ     00010000b       ;  Clear To Send
  ACE_DSR       equ     00100000b       ;  Data Set ready
  ACE_RI        equ     01000000b       ;  Ring Indicator
  ACE_RLSD      equ     10000000b       ;  Receive Line Signal Detect

ACE_DLL         equ     0               ;LSB Baud Rate Divisor

ACE_DLM         equ     1               ;MSB Baud Rate Divisor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\display\config.asm ===
;***************************************************************************
;									   *
;   Copyright (C) 1985-1989 by Microsoft Inc.                              *
;									   *
;***************************************************************************

	title	Hardware Dependent Parameters
	%out	config
	page	,132


RGB     macro   R, G, B
        db      R,G,B,0
	endm



OEM	segment public

;	Machine dependent parameters

        dw      14                      ;Height of vertical thumb
        dw      18                      ;Width of horizontal thumb
	dw	2			;Icon horiz compression factor
	dw	2			;Icon vert compression factor
	dw	1			;Cursor horz compression factor
	dw	1			;Cursor vert compression factor
	dw	0			;Kanji window height
	dw	1			;cxBorder (thickness of vertical lines)
	dw	1			;cyBorder (thickness of horizontal lines)

;	Default system color values

        RGB 129,129,129     ;clrScrollbar
        RGB 192,192,192     ;clrDesktop
        RGB 000,000,128     ;clrActiveCaption
        RGB 255,255,255     ;clrInactiveCaption
        RGB 255,255,255     ;clrMenu
        RGB 255,255,255     ;clrWindow
        RGB 000,000,000     ;clrWindowFrame
        RGB 000,000,000     ;clrMenuText
        RGB 000,000,000     ;clrWindowText
        RGB 255,255,255     ;clrCaptionText
        RGB 128,128,128     ;clrActiveBorder
        RGB 255,255,255     ;clrInactiveBorder
        RGB 255,255,255     ;clrAppWorkspace
        RGB 000,000,128     ;clrHiliteBk
        RGB 255,255,255     ;clrHiliteText
        RGB 255,255,255     ;clrBtnFace
        RGB 128,128,128     ;clrBtnShadow
        RGB 128,128,128     ;clrGrayText
        RGB 000,000,000     ;clrBtnText

;	dw	0			;Unused words
;	dw	0
;	dw	0
;	dw	0
;	dw	0
;	dw	0
	dw	0
	dw	0

OEM	ends
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\display\display.asm ===
TITLE	DISPLAY.ASM
	PAGE	,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; DISPLAY.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   13-MAY-1992 Matt Felton (mattfe)
;   Created.
;
; WinProj 3.0 does the following API:-
;  GetModuleFileName(GetModuleHandle("DISPLAY"), buffer, sizeof(buffer));
; In WOW we do not require a display driver becuase we always call GDI32 to
; perform screen IO.



	.286p

	.xlist
	include cmacros.inc
	.list

	__acrtused = 0
	public	__acrtused	;satisfy external C ref.


createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp	    DGROUP,DATA

sBegin	DATA
Reserved	db  16 dup (0)	    ;reserved for Windows  //!!!!! what is this

DISPLAY_Identifier     db      'DISPLAY'

sEnd	DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,DATA
assumes ES,NOTHING

cProc	DISPLAY,<PUBLIC,FAR,PASCAL,NODATA,ATOMIC>
	cBegin	<nogen>
	mov	ax,1		;always indicate success
	ret
	cEnd	<nogen>

assumes DS,NOTHING

cProc	WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
	parmW	iExit		;DLL exit code

	cBegin
	mov	ax,1		;always indicate success
	cEnd

cProc   Disable,<FAR,PUBLIC,WIN,PASCAL>,<si,di>
        parmD   lp_device

cBegin
        mov     ax,-1
cEnd

cProc   Enable,<FAR,PUBLIC,WIN,PASCAL>,<si,di>
        parmD   lp_device               ;Physical device or GDIinfo destination
	parmW	style			;Style, Enable Device, or Inquire Info
	parmD	lp_device_type		;Device type (i.e FX80, HP7470, ...)
	parmD	lp_output_file		;DOS output file name (if applicable)
        parmD   lp_stuff                ;Device specific information

cBegin
        mov     ax,0
cEnd


; required for AutoSketch
cProc	CheckCursor,<FAR,PUBLIC,WIN,PASCAL>
cBegin
        or     ax,ax  ;do nothing
cEnd

assumes DS,DATA

assumes DS,NOTHING

sEnd	CODE

end	DISPLAY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\keyboard.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   KBD.ASM
;   Win16 KEYBOARD thunks
;
;   History:
;
;   Created 06-Jan-1992 by NanduriR
;--

    TITLE   KEYBOARD.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowkbd.inc
    include cmacros.inc
    include windefs.inc
    include vdmtib.inc
    include dpmi.inc
    .list

    __acrtused = 0
    public  __acrtused  ;satisfy external C ref.

ifdef DBCS
externFP GetSystemDefaultLangID
endif ; DBCS

externFP WOW16Call


createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  DATA
Reserved    db  16 dup (0)  ;reserved for Windows
KEYBOARD_Identifier db  'KEYBOARD16 Data Segment'
externD bios_proc

sEnd    DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

; Hung App Support
; If USER32 is unable to terminate an app via End Task then it calls
; WOW32 to kill the app.   We do this by generating a keyboard h/w
; interrupt 9.   Since in WOW all keyboard input comes via USER32 the
; keyboard h/w interrupt is unused for anything else so we can reuse
; this interrupt.


cProc   KEYBOARD16,<PUBLIC,FAR>
cBegin
        mov     ax,3500h or 09h
        int     21h                             ; vector is in ES:BX
        mov     word ptr [bios_proc][0], bx
        mov     word ptr [bios_proc][2], es

; Setup keyboard interrupt vector to point to our interrupt routine
        mov     ax,2500h or 09h
        mov     dx,OFFSET keybd_int
        push    ds                              ; save DS
        push    cs
        pop     ds                              ; set DS = CS
        int     21h                             ; set the vector
        pop     ds                              ; restore DS
ifdef DBCS
        cCall   GetSystemDefaultLangID
endif ; DBCS
        mov     ax,1
cEnd


ifdef   NEC_98
INTA0    equ   0h       ;
else    ; NEC_98
INTA0    equ   20h      ;X'20' 8259 Interrupt Control Port
endif   ; NEC_98
EOI      equ   20h      ;X'20' 8259 End-of-Interrupt ack

public keybd_int
keybd_int   PROC    FAR
        push    ax
        push    bx
        push    es

        mov     al,EOI              ; Send Non-Specific EOI
        out     INTA0,al

;
; Now we test the bit in low memory that is set by wow32 to see if this
; is really a keyboard int forced in by the hung app support.
;
        mov     ax, 40h                 ;use bios data selector
        mov     es, ax
        mov     bx, FIXED_NTVDMSTATE_LINEAR - 400h

        .386    ;make it assemble
.errnz  VDM_WOWHUNGAPP AND 0ff00ffffh   ;make sure it's the third byte
        test    byte ptr es:[bx+2], VDM_WOWHUNGAPP SHR 16

        jnz     short hungapp_exit      ;jump if this is really a hung app

        pop     es
        pop     bx
        pop     ax
        iret

hungapp_exit:
        and    byte ptr es:[bx+2], 255 - (VDM_WOWHUNGAPP SHR 16) ; turn it off
        pop     es
        pop     bx
        pop     ax
        .286p

        DPMIBOP HungAppIretAndExit      ; They said OK to Nuke app.
keybd_int   ENDP



cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
    parmW   iExit       ;DLL exit code

    cBegin
    mov ax,1        ;always indicate success
    cEnd


assumes DS,NOTHING

;;;    KbdThunk        INQUIRE              ;Internal LOCALAPI
;;;    KbdThunk        ENABLE               ;Internal
;;;    KbdThunk        DISABLE              ;Internal
    KbdThunk        TOASCII
    KbdThunk        ANSITOOEM
    KbdThunk        OEMTOANSI
;;;    KbdThunk        SETSPEED             ;Internal
;;;    KbdThunk        SCREENSWITCHENABLE   ;Internal
;;;    KbdThunk        GETTABLESEG          ;Internal
;;;    KbdThunk        NEWTABLE             ;Internal
    KbdThunk        OEMKEYSCAN
    KbdThunk        VKKEYSCAN
    KbdThunk        GETKEYBOARDTYPE
    KbdThunk        MAPVIRTUALKEY
    KbdThunk        GETKBCODEPAGE
    KbdThunk        GETKEYNAMETEXT
    KbdThunk        ANSITOOEMBUFF
    KbdThunk        OEMTOANSIBUFF
;;;    KbdThunk        ENABLEKBSYSREQ       ;Internal LOCALAPI
;;;    KbdThunk        GETBIOSKEYPROC       ; in kbdlocal.asm



sEnd    CODE

end KEYBOARD16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\mouse\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\mouse\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\display\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
	 PROJECT_INC_PATH=$(PROJECT_INC_PATH) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
	 PROJECT_INC_PATH=$(PROJECT_INC_PATH) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\keyboard\kbdlocal.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   KBDLOCAL.ASM
;
;   Win16 KEYBOARD APIS that are 'internal'
;   We make these apis a 'nop'. Relevant code has been copied from WIN31.
;   The intention here is to maintain the stack. Any arguments to the apis
;   are popped and that is it.
;
;   History:
;
;   Created 06-Jan-1992 by NanduriR
;--

    TITLE   KBDLOCAL.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowkbd.inc
    include cmacros.inc
    include windefs.inc
    .list

    __acrtused = 0
    public  __acrtused  ;satisfy external C ref.


createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

; Double byte range values for the East Asia.
; The values defined here are for the Rest Of the World.
; These values are for the inquireData (KBINFO) structure defined below.
; ('KeyInfo' in the Kernel, pState in USER)
;
; KKFIX 10/19/96 #56665
ifdef JAPAN
BeginRange1 equ	129		; 81h
EndRange1   equ	159		; 9Fh
BeginRange2 equ	224		; E0h
EndRange2   equ	252		; FCh
else ; not JAPAN
ifdef TAIWAN                    ; Big-5 lead byte range, pisuih, 3/16/95'
BeginRange1     equ     129     ; 81h
EndRange1       equ     254     ; FEh
else ; TAIWAN
ifdef PRC                    ; GB2312 lead byte range, pisuih, 3/16/95'
BeginRange1     equ     129     ; 81h Change to GBK lead byte, shanxu 2/22/96
EndRange1       equ     254     ; FEh
else ; PRC
ifdef KOREA
BeginRange1 equ 129
EndRange1   equ 254
else ; not KOREA
BeginRange1 equ 255
EndRange1   equ 254
endif ; KOREA
endif ; PRC
endif ; TAIWAN
BeginRange2 equ 255
EndRange2   equ 254
endif ; 

sBegin  DATA

globalD bios_proc, 0
globalD nmi_vector, 0
;externD nmi_vector


public fSysReq
fSysReq     db  0       ; Enables CTRL-ALT-SysReq if NZ

; Keyboard information block (copied to 'KeyInfo' in the kernel)
; this is a KBINFO data structure.. defined in KERNEL.INC, USER.INC, USER.H
; and WINDEFS.INC.
;
; As of 3.0, build 1.30, KBINFO includes the number of function keys
; As of 3.0, build 1.59, the number of bytes in the state block is
; fixed at 4 MAX, for compatibility with Excel 2.1c!!!
;
        PUBLIC  inquireData
        PUBLIC  iqdNumFunc
inquireData LABEL   BYTE
        DB  BeginRange1
        DB  EndRange1
        DB  BeginRange2
        DB  EndRange2
        DW  4       ; #bytes of state info for ToAscii()
iqdNumFunc  label   word
        dw  10      ; number of function keys

sEnd    DATA


sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

assumes DS,DATA

;***************************************************************************
;
; Inquire( pKBINFO ) - copies information about the keyboard hardware into
; the area pointer to by the long pointer argument.  Returns a count of the
; number of bytes copied.
;
; The Windows kernel calls this to copy information to its 'KeyInfo' data
; structure.
;
;***************************************************************************
cProc   Inquire,<PUBLIC,FAR>,<si,di>
    parmD   pKBINFO

cBegin  Inquire
                    ; .. now pass data to Windows ..
    les di,pKBINFO      ; Get far pointer of destination area
    mov si, OFFSET inquireData   ; Get source
    mov ax,size KBINFO      ; Get number of bytes to move
    mov cx,ax           ;  (Return byte count in AX)
    rep movsb           ; Move the bytes

cEnd    Inquire

;---------------------------------------------------------------------
;
;---- ScreenSwitchEnable( fEnable ) ----------------------------------
;
;   This function is called by the display driver to inform the keyboard
;   driver that the display driver is in a critical section and to ignore
;   all OS/2 screen switches until the display driver leaves its
;   critical section.  The fEnable parameter is set to 0 to disable
;   screen switches, and a NONZERO value to re-enable them.  At startup,
;   screen switches are enabled.
;---------------------------------------------------------------------
;

cProc   ScreenSwitchEnable,<PUBLIC,FAR>
parmW   fEnable

cBegin  ScreenSwitchEnable

    mov ax,fEnable      ; get WORD parameter
    or  al,ah           ; stuff any NZ bits into AL
;;; mov fSwitchEnable,al    ; save BYTE.

cEnd    ScreenSwitchEnable

;---------------------------------------------------------------------
;
;---- EnableKBSysReq( fSys ) ----------------------------------
;
;   This function enables and shuttles off NMI interrupt simulation
;   (trap to debugger) when CTRL-ALT-SysReq is pressed.
;   CVWBreak overides int 2.
;   fSysParm    = 01    enable  int 2
;       = 02    disable int 2
;       = 04    enable  CVWBreak
;       = 08    disable CVWBreak
;
;---------------------------------------------------------------------
;
cProc   EnableKBSysReq,<PUBLIC,FAR>
parmW   fSysParm

cBegin  EnableKBSysReq

    mov ax, fSysParm        ; get WORD parameter

    test    al,01           ; turn on int 2?
    jz  @F
    or  fSysReq,01      ; yes, turn it on!
@@: test    al,02           ; turn off int 2?
    jz  @F
    and fSysReq,NOT 01      ; yes, turn it off!

@@: test    al,04           ; turn on CVWBreak?
    jz  @F
    or  fSysReq,02      ; yes, turn it on!
@@: test    al,08           ; turn off CVWBreak?
    jz  @F
    and fSysReq,NOT 02      ; yes, turn it off!
@@:
    xor ah,ah
    mov al,fSysReq

ifdef NEWNMI
    push    ax          ; save return value
    call    short GetNmi        ; save NMI
    pop ax          ; restore ..
endif

cEnd    EnableKBSysReq


; save NMI vector.  Called above in EnableKBSysReq() and in Enable().

ifdef NEWNMI
GetNmi proc near
    mov ax,3502h
    int 21h
    mov word ptr ds:[nmi_vector][0],bx
    mov word ptr ds:[nmi_vector][2],es
    ret
GetNmi endp
endif

;***************************************************************************
;
; Enable( eventProc ) - enable hardware keyboard interrupts, with the passed
; procedure address being the target of all keyboard events.
;
; lpKeyState is a long pointer to the Windows 256 byte keystate table
;
;***************************************************************************
cProc   Enable,<PUBLIC,FAR>,<si,di>
    parmD   eventProc
    parmD   lpKeyState
cBegin  Enable
    sub ax, ax
cEnd    Enable

;***************************************************************************
; Disable( eventProc ) - disable hardware keyboard interrupts, restoring
; the previous IBM BIOS keyboard interrupt handler.
;
;***************************************************************************
cProc   Disable,<PUBLIC,FAR>,<si,di>

cBegin  Disable

        sub ax,ax

cEnd    Disable

; ** GetTableSeg() ***************************************
;
; This finds the paragraph of the TABS segment and stores
; it in TableSeg.
;
; Calling this will force the segment to be loaded.
;
; This segment isn't written to.
;
; REMEMBER that AX is TRASHED !!


cProc   GetTableSeg,<PUBLIC,FAR>,<si,di>
cBegin  GetTableSeg

;;; mov ax,cs
;;; mov TableSeg,ax

cEnd GetTableSeg

;***************************************************************************
;
;   NewTable()
;
;   Change keyboard tables, if a keyboard table DLL is defined in
;   SYSTEM.INI and the function GetKbdTable() exists and returns
;   successfully.
;
;   This function is passed no parameters by the caller -- it obtains
;   the following from SYSTEM.INI:
;
;         [keyboard]
;       TYPE = 4            ; 1..6.  4 is enhanced kbd.
;       SUBTYPE = 0         ; 0 for all but Olivetti
;                       ; 8086 systems & AT&T 6300+
;       KEYBOARD.DLL = kbdus.dll    ; name of DLL file
;       OEMANSI.BIN = XLATNO.BIN    ; oem/ansi tables file
;
;   The module name of the DLL is expected to be the root of the DLL's
;   file name.  In any event, the module name must be different for
;   each keyboard-table DLL!
;
;***************************************************************************

cProc   NewTable,<PUBLIC,FAR>,<si,di>
                        ; LOCAL variables on stack:

cBegin  NewTable
    sub ax,ax
cEnd    NewTable

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SetSpeed.asm
;
;
; Sets 'typematic' speed of AT-type keyboards (type code 3 or 4 in this
; driver).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cProc   SetSpeed,<FAR,PASCAL,PUBLIC>
 parmW  rate_of_speed
cBegin

SS_error_return:
        mov     ax,-1                   ; error return

SS_end:
cEnd


cProc   GetBIOSKeyProc, <FAR, PUBLIC>
cBegin
    mov     ax, word ptr [bios_proc][0]
    mov     dx, word ptr [bios_proc][2]
cEnd

sEnd    CODE


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\ccom.asm ===
;
; Include code from comm
;

include ..\comm\ccom.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\comdev.h ===
;
; Include code from comm
;

include ..\comm\comdev.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\bimodint.inc ===
;
; Include code from comm
;

include ..\comm\bimodint.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm\dispatch.asm ===
PAGE 58,132
;******************************************************************************
TITLE DCOMM.ASM - Dispatch Communications Driver
;******************************************************************************
;
;   (C) Copyright NEC Software Kobe Corp. , 1994
;
;   Title:	DCOMM.ASM - Dispatch Communications Driver
;
;   Version:	1.0
;
;   Date:       27-Jun-1994
;
;   Author:     M.H
;               (Masatoshi Hosokawa)
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV                 DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   27-Jun-1994 M.H Original
;------------------------------------------------------------------------------

        .XLIST
include	cmacros.inc
        .LIST

;------------------------------------------------------------------------------
;	extern
;------------------------------------------------------------------------------
	externFP GetProcAddress
	externFP GetPrivateProfileString
	externFP LoadLibrary
	externFP FreeLibrary
ifdef WINNT			;; Apr 15, 1995
        externFP RegOpenKey
        externFP RegCloseKey
        externFP LoadLibraryEx32W
        externFP FreeLibrary32W
        externFP GetProcAddress32W
        externFP CallProc32W
endif				;; Apr 15, 1995

;------------------------------------------------------------------------------
;	public DATA
;------------------------------------------------------------------------------
	public	ComExAddr
	public	LptExAddr
	public	ComHandle
	public	LptHandle

;------------------------------------------------------------------------------
;	public CODE
;------------------------------------------------------------------------------
	public	inicom
	public	setcom
	public	setque
	public	reccom
	public	sndcom
	public	ctx
	public	trmcom
	public	stacom
	public	cextfcn
	public	cflush
	public	cevt
	public	cevtGet
	public	csetbrk
	public	cclrbrk
	public	getdcb
	public	SuspendOpenCommPorts
	public	ReactivateOpenCommPorts
	public	CommWriteString
	public	ReadCommString		;Add 940924 KBNES
	public	EnableNotification

;------------------------------------------------------------------------------
;	Equates
;------------------------------------------------------------------------------
MAX_PORT	equ	9

ifdef WINNT				;; Apr 15, 1995
HKEY_LOCAL_MACHINE  equ 80000002h
REG_SZ              equ 00000001h
endif					;; Apr 15, 1995

;------------------------------------------------------------------------------
;	Structures
;------------------------------------------------------------------------------
DCD_Struc	STRUC
	Proc@1		dd	0	; inicom
	Proc@2		dd	0	; setcom
	Proc@3		dd	0	; setque
	Proc@4		dd	0	; reccom
	Proc@5		dd	0	; sndcom
	Proc@6		dd	0	; ctx
	Proc@7		dd	0	; trmcom
	Proc@8		dd	0	; stacom
	Proc@9		dd	0	; cextfcn
	Proc@10		dd	0	; cflush
	Proc@11		dd	0	; cevt
	Proc@12		dd	0	; cevtGet
	Proc@13		dd	0	; csetbrk
	Proc@14		dd	0	; cclrbrk
	Proc@15		dd	0	; getdcb
	Proc@16		dd	0	; 	Reserve
	Proc@17		dd	0	; SuspendOpenCommPorts
	Proc@18		dd	0	; ReactivateOpenCommPorts
	Proc@19		dd	0	; CommWriteString
	Proc@20		dd	0	; ReadCommString	;Add 94.09.20 KBNES
	Proc@100	dd	0	; EnableNotification
DCD_Struc	ENDS

;------------------------------------------------------------------------------
;	Data
;------------------------------------------------------------------------------
sBegin	Data
ComExAddr	DCD_Struc	<>
		db	SIZE DCD_Struc * (MAX_PORT - 1)	dup(0)
LptExAddr	DCD_Struc	<>
		db	SIZE DCD_Struc * (MAX_PORT - 1)	dup(0)

ComHandle	dw	MAX_PORT dup(0)
LptHandle	dw	MAX_PORT dup(0)


ExFuncAddrPtr	dw	0
EndExFuncAddrPtr dw	0
tmpMAX		dw	0

ifdef	WINNT					;; Apr 15, 1995

DefaultDriver   db      'neccomm.drv',0
CCU2ndDriver  	db      'nec2comm.drv',0

ComDriver	dw	DefaultDriver			;;
		dw	DefaultDriver			;; FIXME FIXME 
		dw	CCU2ndDriver			;; FIXME FIXME COM2 is 2ndCCU only
		dw	MAX_PORT dup(DefaultDriver)	;; FIXME FIXME
LptDriver	dw	MAX_PORT+1 dup(DefaultDriver)

ComEntryNum     dw      0
LptEntryNum     dw      0

HkeyLocalMachine	dd	HKEY_LOCAL_MACHINE
NULL            dd      00000000H

SerialKeyName   db      'HARDWARE\DEVICEMAP\SERIALCOMM', 0
ParaKeyName	db      'HARDWARE\DEVICEMAP\PARALLEL PORTS', 0

KeyHandle	dd	?
dwIndex         dd      ?
dwType		dd	?
dwSize		dd	?

szSerial	db      'Serial'                ; EntryName = DriverName
SerialNum	db	20 dup (0)
LenszSerial	dd	$ - szSerial

szCom		db	'COM'
ComNum		db	0,0,0,0
		db	20 dup (0)
LenszCom	dd 	$ - szCOM

szParallel	db      '\Device\Parallel'      ; EntryName = DriverName
ParaNum		db	20 dup (0)
LenszParallel	dd	$ - szParallel

szLpt		db	'\DosDevices\LPT'
LptNum		db	0,0,0,0
		db	20 dup (0)
LenszLpt	dd	$ - szLpt

;
; for Generic Thunk
;
szDllName       db      'advapi32',0
szProcName	db	'RegEnumValueW',0
hAdvApi 	dd	?
dwNparams	dd	8
lpRegEnumValue	dd	?
AddrConv	dd	011011101b

else						;; Apr 15, 1995
DriverNameMax	equ	256
DriverName	db	DriverNameMax dup (0)
SectionName	db	'DispatchComm',0	; [Section]
ComEntryName	db	'Com'			; EntryName = DriverName
ComEntryNum	db	'0.drv',0
LptEntryName	db	'Lpt'			; EntryName = DriverName
LptEntryNum	db	'0.drv',0
DefaultDrvName	db	'neccomm.drv',0 	; DriverName(entry not found)
SystemIni	db	'system.ini',0		; file name
endif						;; Apr 15, 1995

sEnd

;------------------------------------------------------------------------------
;	Macro
;------------------------------------------------------------------------------
;func(pdcb)
Dispatch_DCB	macro	Func
local D_LPTx
local D_COMx
local D_SetFuncAddr
local D_Error

ifdef DEBUG
	int	3			; Debug Code
endif ;DEBUG
	sub	sp, 4			; make stack space for retf addr
	push	eax			; save eax
	push	ebx			; save ebx
	push	ds			; save ds

	mov	bx, sp
	mov	eax, ss:[bx + 18]	; mov eax, lpdcb
				; 18 = 4+4+4+4+2(retaddr,retfaddr,eax,ebx,ds)

	mov	bx, ax			; set offset lpdcb
	shr	eax, 16 		; calculate segment lpdcb
	mov	ds, ax			; set segment lpdcb
	mov	al, byte ptr [bx]	; Get al = cid
	mov	bx, _DATA
	mov	ds, bx			; ds = Data
	test	al, 80h 		; Q:LPTx or COMx ?
	jz	short D_COMx		;  If COMx then goto D_COMx
D_LPTx:
	mov	bx, offset LptExAddr
	jmp	short D_SetFuncAddr
D_COMx:
	mov	bx, offset ComExAddr
D_SetFuncAddr:
	and	eax, 007Fh
	cmp	ax, MAX_PORT - 1
	jbe	SHORT @f
	xor	ax, ax
@@:
	imul	eax, SIZE DCD_Struc	; EAX = Offset in LPT table
	add	bx, ax
	mov	eax, [bx + Func]	; get COMM.DRV entry addr
	or	eax, eax
	jz	short D_Error
	pop	ds			; restore ds

	mov	bx, sp
	mov	ss:[bx + 8], eax	; set COMM.DRV entry addr
					; 8 = 4+4(eax,ebx)

	pop	ebx			; restore ebx
	pop	eax			; restore eax
	retf				; go to COMM.DRV driver
D_Error:
	pop	ds			; restore ds
	pop	ebx			; restore ebx
	add	sp, 8
	mov	ax, 0			; return
	retf	4
	endm

;func(cid,..etc)
Dispatch_cid	macro	Func, cid, addsp
local D_LPTx
local D_COMx
local D_SetFuncAddr
local D_Error

ifdef DEBUG
	int	3			; Debug Code
endif ;DEBUG
	sub	sp, 4			; make stack space for retf addr
	push	eax			; save eax
	push	ebx			; save ebx
	push	ds			; save ds
	mov	bx, _DATA
	mov	ds, bx			; ds = Data

	mov	bx, sp
	mov	ax, ss:[bx + cid + 18]	; mov al, cid
				; 18 = 4+4+4+4+2(retaddr,retfaddr,eax,ebx,ds)

	test	al, 0080h		; Q:LPTx or COMx ?
	jz	short D_COMx		;  If COMx then goto D_COMx
D_LPTx:
	mov	bx, offset LptExAddr
	jmp	short D_SetFuncAddr
D_COMx:
	mov	bx, offset ComExAddr
D_SetFuncAddr:
	and	eax, 007Fh
	cmp	ax, MAX_PORT - 1
	jbe	SHORT @f
	xor	ax, ax
@@:
	imul	eax, SIZE DCD_Struc	; EAX = Offset in LPT table
	add	bx, ax
	mov	eax, [bx + Func]	; get COMM.DRV entry addr
	or	eax, eax
	jz	short D_Error
	pop	ds			; restore ds

	mov	bx, sp
	mov	ss:[bx + 8], eax	; set COMM.DRV entry addr
					; 8 = 4+4(eax,ebx)

	pop	ebx			; restore ebx
	pop	eax			; restore eax
	retf				; go to COMM.DRV driver
D_Error:
	pop	ds			; restore ds
	pop	ebx			; restore ebx
	add	sp, 8
	mov	ax, 0			; return
	retf	addsp
	endm

;void func(void)
Dispatch_void	macro FuncName, Func
local D_Loop
local D_Skip
cProc	FuncName,<FAR,PUBLIC,PASCAL>
cBegin	nogen

ifdef DEBUG
	int	3			; Debug Code
endif ;DEBUG
	push	es			; save es
	mov	ecx, MAX_PORT * 2	; Set loop counter(COM & LPT)
	mov	ax, _DATA
	mov	es, ax			; es = Data
	mov	bx, offset ComExAddr	; get Function Addr Ptr
	mov	di, offset ComHandle	; get handle Ptr
D_Loop:
	mov	ax, es:[di]		; get handle
	or	ax, ax			; Q:Invalid handle?
	jz	SHORT D_Skip		;  Yes.
	mov	eax, es:[bx + Func]	; get COMM.DRV entry addr
	or	eax, eax		; Q: entry addr OK?
	jz	SHORT D_Skip		;  No. Skip call COMM.DRV.
	pushad				; save all register
	call	dword ptr es:[bx + Func]; call COMM.DRV driver
	popad				; restore all register
D_Skip:
	add	di, 2			; calculate next handle Ptr
	add	bx, SIZE DCD_Struc	; calculate next Function Addr Ptr
	loop	SHORT D_Loop
	pop	es			; restore es

	ret
cEnd	nogen
	endm


;------------------------------------------------------------------------------
;	Code
;------------------------------------------------------------------------------
sBegin	Code

assumes cs,Code
assumes ds,Data
.386

;------------------------------------------------------------------------------
;	USE DCB ID
;------------------------------------------------------------------------------

inicom		proc	far
;   parmD    pdcb
	Dispatch_DCB	Proc@1
inicom		endp

setcom		proc	far
;   parmD    pdcb
	Dispatch_DCB	Proc@2
setcom		endp

;------------------------------------------------------------------------------
;	USE CID
;------------------------------------------------------------------------------
setque		proc	far
;   parmB    cid
;   parmD    pqdb
	Dispatch_cid	Proc@3, 4, 6
setque		endp

reccom		proc	far
;   parmB    cid
	Dispatch_cid	Proc@4, 0, 2
reccom		endp

sndcom		proc	far
;   parmB    cid
;   parmB    chr
;	Dispatch_cid	Proc@5, 1, 4		;Bug fixed 94.09.20 KBNES
	Dispatch_cid	Proc@5, 2, 4		;Bug fixed 94.09.20 KBNES
sndcom		endp

ctx		proc	far
;   parmB    cid
;   parmB    chr
;	Dispatch_cid	Proc@6, 1, 4		;Bug fixed 94.09.20 KBNES
	Dispatch_cid	Proc@6, 2, 4		;Bug fixed 94.09.20 KBNES
ctx		endp

trmcom		proc	far
;   parmB    cid
	Dispatch_cid	Proc@7, 0, 2
trmcom		endp

stacom		proc	far
;   parmB    cid
;   parmD    pstat
;	Dispatch_cid	Proc@8, 4, 4		;Bug fixed 94.09.20 KBNES
	Dispatch_cid	Proc@8, 4, 6		;Bug fixed 94.09.20 KBNES
stacom		endp

;------------------------------------------------------------------------------
;	USE CID, But(GETMAXCOM GETMAXLPT) call all driver
;------------------------------------------------------------------------------
;;cextfcn function stack
;;
;;	offset	size	coment
;;	-10	4	COMM.DRV Entry addr	(use only GETMAXCOM or LPT)
;;	- 6	4	GETMAXLoop addr 	(use only GETMAXCOM or LPT)
;;	- 4	2	func			(use only GETMAXCOM or LPT)
;;	- 2	2	id			(use only GETMAXCOM or LPT)
;;	  0	2	gs
;;	  2	2	fs
;;	  4	2	es
;;	  6	2	ds
;;	  8	4	ebp
;;	 12	4	edi
;;	 16	4	esi
;;	 20	4	edx
;;	 24	4	ecx
;;	 28	4	ebx
;;	 32	4	eax
;;	 36	4	COMM.DRV Entry addr
;;	 40	4	return addr
;;	 44	2	func
;;	 46	2	id

cextfcn 	proc	far
;   parmB    cid
;   parmW    fcn
ifdef DEBUG
	int	3			; Debug Code
endif ;DEBUG
	sub	sp, 4			; make stack space for retf addr

	push	eax
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	edi
	push	ebp
	push	ds
	push	es
	push	fs
	push	gs

	mov	ax, _DATA
	mov	ds, ax			; ds = Data
	mov	bx, sp
	mov	ax, ss:[bx + 44]	; mov ax, fcn
					; 44 = 36+4+4(pushreg,retaddr,retfaddr)
	mov	bx, offset ComExAddr
	cmp	ax, 9			; Q:fcn = GETMAXCOM ?
	je	SHORT GetMaxEntry	;  Yes.
	mov	bx, offset LptExAddr
	cmp	ax, 8			; Q:fcn = GETMAXLPT ?
	je	SHORT GetMaxEntry	;  Yes.

	mov	bx, sp
	mov	al, ss:[bx + 46]	; mov al, id
				; 46 = 36+4+4+2(pushreg,retaddr,retfaddr,fcn)
	mov	bx, offset ComExAddr
	test	al, 0080h		; Q:LPTx or COMx ?
	jz	short Fcn_SetFuncAddr	;  Yes.
	mov	bx, offset LptExAddr	;  No.
Fcn_SetFuncAddr:
	and	eax, 007Fh
	cmp	ax, MAX_PORT - 1
	jbe	SHORT @f
	xor	ax, ax
@@:
	imul	eax, SIZE DCD_Struc	; EAX = Offset in LPT table
	add	bx, ax
	mov	eax, [bx + Proc@9]	; get COMM.DRV entry addr
	or	eax, eax
	jz	short Fcn_Error

	mov	bx, sp
	mov	ss:[bx + 36], eax	; set COMM.DRV entry addr
					; 36 = (pushreg)
	pop	gs
	pop	fs
	pop	es
	pop	ds
	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax
	retf				; go to COMM.DRV driver

Fcn_Error:
	pop	gs
	pop	fs
	pop	es
	pop	ds
	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax
	add	sp, 4			; del stack space for retf addr
	mov	ax, 0			; return
	retf	4

;  fcn = GETMAXCOM or GETMAXLPT call all driver
GetMaxEntry:
	mov	ExFuncAddrPtr, bx	; Set ExFuncAddrPtr
	add	bx, SIZE DCD_Struc * MAX_PORT
	mov	EndExFuncAddrPtr, bx	; set EndExFuncAddrPtr
	mov	tmpMAX, 0		; Clear tmpMAX
GETMAX1:
	xor	ax, ax			; Clear ax
GETMAXLoop:
	mov	bx, _DATA
	mov	ds, bx			; ds = Data
	cmp	ax, tmpMAX
	jbe	@f
	mov	tmpMAX, ax
@@:
	mov	bx, ExFuncAddrPtr
	cmp	bx, EndExFuncAddrPtr	; Q:Loop End?
	je	GETMAXEnd		;  Yes.
	mov	eax, [bx + Proc@9]	;  get COMM.DRV entry addr
	add	ExFuncAddrPtr, SIZE DCD_Struc; calculate next Function Addr Ptr
	or	eax, eax		; Q:Invalid Addr?
	jz	SHORT GETMAX1		;  Yes.

	mov	bx, sp
	sub	sp, 4			; make stack space for (func,id)
	push	cs
	push	offset GETMAXLoop
	push	eax			; Set COMM.DRV entry addr
	mov	ax, ss:[bx + 44]	; get func
	mov	ss:[bx - 4],ax		; set func
	mov	ax, ss:[bx + 46]	; get id
	mov	ss:[bx - 2],ax		; set id
;  restore pushreg val
	mov	ax, ss:[bx]
	mov	gs, ax
	mov	ax, ss:[bx + 2]
	mov	fs, ax
	mov	ax, ss:[bx + 4]
	mov	es, ax
	mov	ax, ss:[bx + 6]
	mov	ds, ax
	mov	ebp, ss:[bx + 8]
	mov	edi, ss:[bx + 12]
	mov	esi, ss:[bx + 16]
	mov	edx, ss:[bx + 20]
	mov	ecx, ss:[bx + 24]
	mov	eax, ss:[bx + 32]
	mov	ebx, ss:[bx + 28]
	retf				; go to COMM.DRV driver
        
GETMAXEnd:
	mov	dx, tmpMAX
	mov	bx, sp
;  restore pushreg val
	mov	ax, ss:[bx]
	mov	gs, ax
	mov	ax, ss:[bx + 2]
	mov	fs, ax
	mov	ax, ss:[bx + 4]
	mov	es, ax
	mov	ax, ss:[bx + 6]
	mov	ds, ax
	mov	ebp, ss:[bx + 8]
	mov	edi, ss:[bx + 12]
	mov	esi, ss:[bx + 16]
	mov	ecx, ss:[bx + 24]
	mov	ebx, ss:[bx + 28]
	mov	ax, dx
	xor	dx, dx
	add	sp, 36 + 4
	retf	4
cextfcn 	endp

;------------------------------------------------------------------------------
;	USE CID
;------------------------------------------------------------------------------
cflush		proc	far
;   parmB    cid
;   parmB    q
;	Dispatch_cid	Proc@10, 1, 4		;Bug fixed 94.09.20 KBNES
	Dispatch_cid	Proc@10, 2, 4		;Bug fixed 94.09.20 KBNES
cflush		endp

cevt		proc	far
;   parmB    cid
;   parmW    evt_mask
	Dispatch_cid	Proc@11, 2, 4
cevt		endp

cevtGet 	proc	far
;   parmB    cid
;   parmW    evt_mask
	Dispatch_cid	Proc@12, 2, 4
cevtGet 	endp

csetbrk 	proc	far
;   parmB    cid
	Dispatch_cid	Proc@13, 0, 2
csetbrk 	endp

cclrbrk 	proc	far
;   parmB    cid
	Dispatch_cid	Proc@14, 0, 2
cclrbrk 	endp

getdcb		proc	far
;   parmB    cid
	Dispatch_cid	Proc@15, 0, 2
getdcb		endp

;------------------------------------------------------------------------------
;	Call All Driver
;------------------------------------------------------------------------------
Dispatch_void	SuspendOpenCommPorts, Proc@17

Dispatch_void	ReactivateOpenCommPorts, Proc@18

;------------------------------------------------------------------------------
;	USE CID
;------------------------------------------------------------------------------
CommWriteString 	proc	far
;    parmB   cid
;    parmD   lpstring
;    parmW   count
	Dispatch_cid	Proc@19, 6, 8
CommWriteString 	endp

ReadCommString		proc	far		;Add 94.09.20 KBNES
;    parmB    cid				;Add 94.09.20 KBNES
;    parmD    buf				;Add 94.09.20 KBNES
;    parmW    cnt				;Add 94.09.20 KBNES
	Dispatch_cid	Proc@20, 6, 8		;Add 94.09.20 KBNES
ReadCommString		endp			;Add 94.09.20 KBNES

EnableNotification		proc	far
;    parmB   cid
;    parmW   _hWnd
;    parmW   recvT
;    parmW   sendT
;	Dispatch_cid	Proc@100, 12, 8 	;Bug fixed 94.09.20 KBNES
	Dispatch_cid	Proc@100, 6, 8		;Bug fixed 94.09.20 KBNES
EnableNotification		endp


cProc	WEP,<PUBLIC,FAR>
cBegin nogen
ifdef DEBUG
	int	3			; Debug Code
endif ;DEBUG

;  Free Communications Driver
	pushad

	mov	ax, _DATA		;Bug fixed 941008 KBNES
	mov	ds, ax			;Bug fixed 941008 KBNES

	mov	cx, MAX_PORT * 2	; Set loop Counter
	mov	bx, offset ComHandle	; Set Comm Driver handle address
FreeCommDrv:
	mov	ax, [bx]		; Get Communications Driver handle
	add	bx, 2			; calculate next Comm Driver handle
	or	ax, ax			; Q:Invalid handle?
	jz	SHORT @f		;  Yes.
	push	bx			; save bx
	push	cx			; save cx
	cCall	FreeLibrary,<ax>	; Free Communications Driver
	pop	cx			; restore cx
	pop	bx			; restore bx
@@:
	loop	SHORT FreeCommDrv
	popad

	nop				; You don't want to know why.
	mov	ax,1
	ret	2
cEnd nogen

sEnd	Code

;------------------------------------------------------------------------------
;	Initial Code
;------------------------------------------------------------------------------
.286
createSeg _INIT,init,word,public,CODE
sBegin init
assumes cs,init
.386

cProc LoadLib, <FAR,PUBLIC,NODATA>,<si,di>
cBegin
ifdef DEBUG
	int	3			; Debug Code
endif ;DEBUG

	pushad

	mov	ax, _DATA		;Bug fixed 941008 KBNES
	mov	ds, ax			;Bug fixed 941008 KBNES

ifdef WINNT
;	hAdvApi = LoadLibraryEx32W(szDllName, NULL, 0);
;	if ((fpRegEnum = GetProcAddress32W(hAdvApi, szProcName)) == NULL) {
;	    int21(0x4c00);	//system done.
;	}
;
        lea     ax,szDllName
        push    ds
        push    ax
        push    0
        push    0
        push    0
        push    0
        call    far ptr LoadLibraryEx32W
	mov	word ptr hAdvApi,ax
	mov	word ptr hAdvApi+2,dx
        mov     bx,ax
	or	bx,dx
	jne	@f
	stc
	jmp	CSHEnd

@@:
;	farPtr	lpszProcName,ds,ax
;	cCall	GetProcAddress32W,<hAdvApi,lpszProcName>
        push    dx
        push    ax
        lea     cx,szProcName
        push    ds
        push    cx
        call    far ptr GetProcAddress32W
        mov     word ptr lpRegEnumValue,ax
        mov     word ptr lpRegEnumValue+2,dx
        or      ax,dx
        jne     @f
	stc
	jmp	CSHEnd

@@:
endif

ifdef	WINNT	;; Apr 15, 1995
;;
;;	Set Driver Name for All Seiral Ports
;;
;;	Psude code
;;		
;;	if (!RegOpenKey (HKEY_LOCAL_MACHINE, szRegSerialMap, &hkey))
;;         {
;;             while (!RegEnumValue (hkey, i++, szSerial, &dwBufz,
;;                                     NULL, &dwType, szCom, &dwSize)) {
;;		    if (dwType == REG_SZ) {
;;			if (szSerial[7] == '0') ComDriver[szCom[3]-'0'] = DefaultDriver;
;;			else if ((szSerial[8] == '0') && (szSerial[7] == '2'))
;;			    ComDriver[szCom[3]-'0'] = CCU2ndDriver;
;;			else 	// nothing
;;		    }
;;		}
;;		RegCloseKey(hkey);
;;	    }
        lea     ax,KeyHandle
	farPtr	lpKeyHandle,ds,ax
        lea     bx,SerialKeyName
  	farPtr	lpSerialKeyName,ds,bx
        cCall   RegOpenKey,<HkeyLocalMachine,lpSerialKeyName,lpKeyHandle>
        cmp     ax,0
        jne     EnumFailed
        mov     dwIndex,0
        jmp     short EnumSerialStart

EnumSerial:
        inc     dwIndex
EnumSerialStart:
        mov     LenszSerial,26
        mov     LenszCom,27
        lea     ax,szSerial
        farPtr  lpszSerial,ds,ax
        lea     bx,LenszSerial
        farPtr  lpLenszSerial,ds,bx
        lea     cx,dwType
        farPtr  lpdwType,ds,cx
        lea     dx,szCom
        farPtr  lpszCom,ds,dx
        lea     di,LenszCom
        farPtr  lpLenszCom,ds,di

;;      CallProc32W(KeyHandle,dwIndex,lpszSerial,lpLenszSerial,NULL,lpdwType,lpszCom,lpLenszCom,
;;                    lpRegEnumValue, AddrConv, 8);
        cCall   CallProc32W,<KeyHandle,dwIndex,lpszSerial,lpLenszSerial,NULL,lpdwType,lpszCom,lpLenszCom,lpRegEnumValue,AddrConv,dwNparams>
        or      ax,dx
        jne     EnumSerialEnd

        cmp     dwType,REG_SZ   ; Is type of value REG_SZ ?
        jne     EnumSerial

        lea     di,szSerial
        mov     ah,[di+7]
        cmp     ah,0h           ; Serial[7] == 0 ?
        jne     @f
        lea     ax,DefaultDriver
        jmp     SetDriverName
@@:
        mov     ah,[di+6]
        cmp     ah,32h          ; Serial[6] == '2' ?
        jne     EnumSerial
        mov     ah,[di+8]
        cmp     ah,0h           ; Serial[8] == 0 ?
        jne     EnumSerial
        lea     ax,CCU2ndDriver
SetDriverName:
        lea     si,szCom
        mov     bx,[si+3]
        sub     bx,30h
        shl     bx,1            ; bx *= 2
        lea     di,ComDriver
        mov     [di+bx],ax
        jmp     EnumSerial

EnumSerialEnd:
        cCall   RegCloseKey,<KeyHandle>

;;
;;	Set Driver Name for All Parallel Ports
;;
;;	Psude code
;;		
;;	if (!RegOpenKey (HKEY_LOCAL_MACHINE, szRegParallelMap, &hkey))
;;         {
;;             while (!RegEnumValue (hkey, i++, szParallel, &dwBufz,
;;                                     NULL, &dwType, szLpt, &dwSize)) {
;;		    if (dwType == REG_SZ) {
;;			if (szParallel[16] == '0') LptDriver[szLpt[15]-'0'] = DefaultDriver;
;;			else 	// nothing
;;		    }
;;		}
;;		RegCloseKey(hkey);
;;	    }

        lea     ax,KeyHandle
	farPtr	lpKeyHandle,ds,ax
        lea     bx,ParaKeyName
	farPtr	lpParaKeyName,ds,bx
        cCall   RegOpenKey,<HkeyLocalMachine,lpParaKeyName,lpKeyHandle>
        cmp     ax,0
        jne      EnumFailed

        mov     dwIndex,0
        jmp     short EnumParallelStart
EnumParallel:
        inc     dwIndex
EnumParallelStart:

        mov     LenszParallel,36
        mov     LenszLpt,39

;;      CallProc32W(KeyHandle,dwIndex,lpszSerial,lpLenszSerial,NULL,lpdwType,lpszCom,lpLenszCom,
;;                    lpRegEnumValue, AddrConv, 8);
        lea     ax,szParallel
        farPtr  lpszParallel,ds,ax
        lea     bx,LenszParallel
        farPtr  lpLenszParallel,ds,bx
        lea     cx,dwType
        farPtr  lpdwType,ds,cx
        lea     dx,szLpt
        farPtr  lpszLpt,ds,dx
        lea     di,LenszLpt
        farPtr  lpLenszLpt,ds,di
        cCall   CallProc32W,<KeyHandle,dwIndex,lpszSerial,lpLenszSerial,NULL,lpdwType,lpszCom,lpLenszCom,lpRegEnumValue,AddrConv,dwNparams>
        or      ax,dx
        jne     EnumParallelEnd

        cmp     dwType,REG_SZ  ; Value type is not REG_SZ
        jne     EnumParallel

        lea     di,szParallel
        mov     ah,30h
        cmp     [di+16],ah     ; dzParallel[16] == 0 ?
        jne     EnumParallel
        lea     si,szLpt
        xor     bx,bx
        mov     bl,[si+15]      ; LPT No. = szLpt[15] - '0'
        sub     bx,30h
        shl     bx,1            ; bx *= 2
        lea     ax,DefaultDriver
        mov     [LptDriver+bx],ax
        jmp     EnumParallel

EnumParallelEnd:
        cCall   RegCloseKey,<KeyHandle>

; FreeLibraryEx32W(hAdvApi);
        cCall   FreeLibrary32W,<hAdvApi>
        jmp     @f

EnumFailed:
        cCall   FreeLibrary32W,<hAdvApi>
	stc
	jmp	CSHEnd


@@:

LoadDriverStart:
endif					;; Apr 15, 1995

;  Load and Set Communications Driver Function's Address

	xor	cx, cx			; Clear loop counter
LCDLoop:
	push	cx			; Save loop counter

;  Get Communications driver Name(COMx)

	inc	ComEntryNum		; Set Comm EntryName Number

ifdef	WINNT				;; Apr 15, 1995
;;
;;		Do Nothing
;;
else					;; Apr 15, 1995
	lea	ax,SectionName
	farPtr	lpSection,ds,ax
	lea	bx,ComEntryName
	farPtr	lpEntry,ds,bx
	lea	cx,DefaultDrvName
	farPtr	lpDefault,ds,cx
	lea	dx,DriverName
	farPtr	lpReturnBuf,ds,dx
	mov	si,DriverNameMax
	lea	di,SystemIni
	farPtr	lpFileName,ds,di
	cCall	GetPrivateProfileString,<lpSection,lpEntry,lpDefault,lpReturnBuf,si,lpFileName>
endif					;; Apr 15, 1995


;  load Communications driver(COMx)

ifdef	WINNT				;; Apr 15, 1995
	mov	bx,ComEntryNum
	shl	bx,1
	mov	ax,ComDriver[bx]
else					;; Apr 15, 1995
	lea	ax, DriverName
endif					;; Apr 15, 1995
	farPtr	module_name,ds,ax
	cCall	LoadLibrary,<module_name>
	cmp	ax, 32			; Q:LoadLibrary() Success?
	ja	SHORT LoadCOMx		;  Yes.
					;  No.
	pop	cx
	push	cx
	or	cx, cx			; Q:COM1?
	jnz	SHORT @f		;  No.
ifdef	WINNT	;; Jul 24, 1995
	stc
	jmp	CSHEnd
else
	popad

	mov	ax,4c00h		; System Done.
	int	21h			; <--- !!!!!
endif
@@:
	mov	ax, cx
	mov	bx, offset ComHandle
	mov	si, [bx]
	jmp	SHORT GetComExAddr
LoadCOMx:

;  Get Communications driver(COMx) Export Function Address

	mov	si,ax			; si = Communication driver's handle
	mov	bx, offset ComHandle
	pop	cx
	push	cx
	mov	ax, cx
	shl	cx, 1
	add	bx, cx
	mov	[bx], si		; Set Module handle

GetComExAddr:
;	mov	cx, 19			;Del 94.09.20 KBNES
	mov	cx, 20			;Add 94.09.20 KBNES
	mov	bx, offset ComExAddr
	imul	eax, SIZE DCD_Struc	; EAX = Offset in COM table
	add	bx, ax
GPAC1:
;	mov	ax, 20			;Del 94.09.20 KBNES
	mov	ax, 21			;Add 94.09.20 KBNES
	sub	ax, cx			; Set EXPORT No.
	cwd
	push	bx			; save bx
	push	cx			; save cx
	farPtr	func_number,dx,ax
	cCall	GetProcAddress,<si,func_number>	; Get COMM.DRV FuncX Address
	pop	cx			; restore cx
	pop	bx			; restore bx
	mov	[bx], ax
	mov	[bx + 2], dx
	add	bx, 4
	loop	SHORT GPAC1

	mov	ax, 100			; Set EXPORT No.
	cwd
	push	bx			; save bx
	farPtr	func_number,dx,ax
	cCall	GetProcAddress,<si,func_number>	; Get COMM.DRV FuncX Address
	pop	bx			; restore bx
	mov	[bx], ax
	mov	[bx + 2], dx



;  Get Communications driver Name(LPTx)

	inc	LptEntryNum		; Set Lpt EntryName Number

ifdef	WINNT				;; Apr 15, 1995
;;
;;		Do Nothing
;;
else					;; Apr 15, 1995
	lea	ax,SectionName
	farPtr	lpSection,ds,ax
	lea	bx,LptEntryName
	farPtr	lpEntry,ds,bx
	lea	cx,DefaultDrvName
	farPtr	lpDefault,ds,cx
	lea	dx,DriverName
	farPtr	lpReturnBuf,ds,dx
	mov	si,DriverNameMax
	lea	di,SystemIni
	farPtr	lpFileName,ds,di
	cCall	GetPrivateProfileString,<lpSection,lpEntry,lpDefault,lpReturnBuf,si,lpFileName>
endif					;; Apr 15, 1995


;  load Communications driver(LPTx)

ifdef	WINNT				;; Apr 15, 1995
	mov	bx,LptEntryNum
	shl	bx,1
	mov	ax,LptDriver[bx]
else					;; Apr 15, 1995
	lea	ax, DriverName
endif					;; Apr 15, 1995
	farPtr	module_name,ds,ax
	cCall	LoadLibrary,<module_name>
	cmp	ax, 32			; Q:LoadLibrary() Success?
	ja	SHORT LoadLPTx		;  Yes.
					;  No.
	pop	cx
	push	cx
	or	cx, cx			; Q:COM1?
	jnz	SHORT @f		;  No.
ifdef	WINNT	;; Jul 24, 1995
	stc
	jmp	CSHEnd
else
	popad

	mov	ax,4c00h		; System Done.
	int	21h			; <--- !!!!!
endif
@@:
	mov	ax, cx
	mov	bx, offset LptHandle
	mov	si, [bx]
	jmp	SHORT GetLptExAddr
LoadLPTx:

;  Get Communications driver(LPTx) Export Function Address

	mov	si,ax			; si = Communication driver's handle
	mov	bx, offset LptHandle
	pop	cx
	push	cx
	mov	ax, cx
	shl	cx, 1
	add	bx, cx
	mov	[bx], si		; Set Module handle

GetLptExAddr:
;	mov	cx, 19			;Del 94.09.20 KBNES
	mov	cx, 20			;Add 94.09.20 KBNES
	mov	bx, offset LptExAddr
	imul	eax, SIZE DCD_Struc	; EAX = Offset in COM table
	add	bx, ax
GPAL1:
;	mov	ax, 20			;Del 94.09.20 KBNES
	mov	ax, 21			;Add 94.09.20 KBNES
	sub	ax, cx			; Set EXPORT No.
	cwd
	push	bx			; save bx
	push	cx			; save cx
	farPtr	func_number,dx,ax
	cCall	GetProcAddress,<si,func_number>	; Get COMM.DRV FuncX Address
	pop	cx			; restore cx
	pop	bx			; restore bx
	mov	[bx], ax
	mov	[bx + 2], dx
	add	bx, 4
	loop	SHORT GPAL1

	mov	ax, 100			; Set EXPORT No.
	cwd
	push	bx			; save bx
	farPtr	func_number,dx,ax
	cCall	GetProcAddress,<si,func_number>	; Get COMM.DRV FuncX Address
	pop	bx			; restore bx
	mov	[bx], ax
	mov	[bx + 2], dx

	pop	cx			; Restore loop counter
	inc	cx			; Count up
	cmp	cx, MAX_PORT		; if (CX != MAX_PORT)
	jne	LCDLoop			;    then goto LCDLoop

;  Clear Same Handle
;   Algorism
;	for (bx=1 to MAX_PORT*2-1)
;	    if (ComHandle[bx]!=0) for (si=bx+1 to MAX_PORT*2)
;		if (ComHandle[bx]==ComHandle[si]) ComHandle[si]=0

	xor	bx, bx			; Clear Counter(bx)
CSHLoop1:
	cmp	bx, (MAX_PORT*2 - 1)*2	; Q:Loop1 Done?
	je	SHORT CSHEnd		;  Yes.
	mov	ax, ComHandle[bx]
	or	ax, ax			; Q:Invalid handle?
	jz	SHORT CSHSkip		;  Yes.
	mov	di, ax			; di = ComHandle[bx]
	mov	si, bx			; Set Counter(si)
CSHLoop2:
	add	si, 2			; Count Up(si)
	cmp	si, (MAX_PORT * 2) * 2	; Q:Loop2 done?
	je	SHORT CSHSkip		;  Yes.
	xor	ax, ComHandle[si]	; Q:Same Handle?
	jnz	SHORT @f		;  No.
	mov	ComHandle[si], ax	;  Yes. Clear Same Handle
	push	bx
	push	si
	push	di
	cCall	FreeLibrary,<di>	; Free Communications Driver
	pop	di
	pop	si
	pop	bx
@@:
	mov	ax, di			; ax = ComHandle[bx]
	jmp	SHORT CSHLoop2
CSHSkip:
	add	bx, 2			; Count Up(bx)
	jmp	SHORT CSHLoop1
CSHEnd:

	popad
cEnd

sEnd	init

End	LoadLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\mouse\mouse.asm ===
TITLE   MOUSE.ASM
   PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; MOUSE.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   30-Sept-1992 Chandan Chauhan (ChandanC)
;   Created.
;
; Freehand and ??? need mouse driver.
;


   .286p

    .xlist
    include cmacros.inc
    .list

   __acrtused = 0
   public  __acrtused  ;satisfy external C ref.


createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp     DGROUP,DATA

sBegin  DATA
Reserved   db  16 dup (0)      ;reserved for Windows  //!!!!! what is this

mouse_Identifier     db      'mouse'

sEnd    DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING



cProc   MOUSE,<PUBLIC,FAR,PASCAL,NODATA,ATOMIC>
   cBegin  <nogen>
   mov ax,1        ;always indicate success
   ret
   cEnd    <nogen>



;--------------------------Exported-Routine-----------------------------;
; int Inquire(lp_mouse_info);
;
; Information regarding the mouse is returned to the caller.
;
; Entry:
;  None
; Returns:
;  AX = # bytes returned in lp_mouse_info
; Error Returns:
;  None
; Registers Preserved:
;  SI,DI,DS,BP
; Registers Destroyed:
;  AX,BX,CX,DX,ES,FLAGS
;-----------------------------------------------------------------------;

   assumes cs,Code
   assumes ds,Data

cProc  Inquire,<FAR,PUBLIC,WIN,PASCAL>,<di>

   parmD   lp_mouse_info

cBegin
   xor ax, ax

cEnd




;--------------------------Exported-Routine-----------------------------;
; void Enable(lp_event_proc);
;
; Enable hardware mouse interrupts, with the passed procedure address
; being the target of all mouse events.
;
; This routine may be called while already enabled.  In this case the
; passed event procedure should be saved, and all other initialization
; skipped.
;
; Entry:
;  None
; Returns:
;  None
; Error Returns:
;  None
; Registers Preserved:
;  SI,DI,DS,BP
; Registers Destroyed:
;  AX,BX,CX,DX,ES,FLAGS
;-----------------------------------------------------------------------;

   assumes cs,Code
   assumes ds,Data

cProc  Enable,<FAR,PUBLIC,WIN,PASCAL>,<si,di>

   parmD   new_event_proc

cBegin

;  The new event procedure is always saved regardless of the
;  mouse already being enabled.  This allows the event proc
;  to be changed as needed.

    xor ax, ax

cEnd

;--------------------------Exported-Routine-----------------------------;
; void Disable();
;
; Disable hardware mouse interrupts, restoring the previous mouse
; interrupt handler and 8259 interrupt enable mask.
;
; This routine may be called while already disabled.  In this case the
; disabling should be ignored.
;
; Entry:
;  None
; Returns:
;  None
; Error Returns:
;  None
; Registers Preserved:
;  SI,DI,DS,BP
; Registers Destroyed:
;  AX,BX,CX,DX,ES,FLAGS
;-----------------------------------------------------------------------;


   assumes cs,Code
   assumes ds,Data

cProc  Disable,<FAR,PUBLIC,WIN,PASCAL>,<si,di>

cBegin
    xor ax, ax

cEnd

;--------------------------Exported-Routine-----------------------------;
; WORD WEP();
;
; Generic WEP.
;
; Entry:
;  None
; Returns:
;  AX = 1
; Error Returns:
;  None
; Registers Preserved:
;  all
; Registers Destroyed:
;  none
;-----------------------------------------------------------------------;


   assumes cs,Code
   assumes ds,Data

cProc  WEP,<FAR,PUBLIC,WIN,PASCAL>
;  parmW   stuff
cBegin nogen
   mov ax,1
   ret 2
cEnd nogen

;--------------------------Exported-Routine-----------------------------;
; int MouseGetIntVect();
;
; The interrupt vector used by the mouse is returned to the caller.
; If no mouse is found, then -1 is returned.
;
; Entry:
;  None
; Returns:
;  AX = interrupt vector
;  AX = -1 if no mouse was found
; Error Returns:
;  None
; Registers Preserved:
;  SI,DI,DS,BP
; Registers Destroyed:
;  AX,BX,CX,DX,ES,FLAGS
;-----------------------------------------------------------------------;


   assumes cs,Code
   assumes ds,Data

cProc  MouseGetIntVect,<FAR,PUBLIC,WIN,PASCAL>

cBegin
    mov al, -1
cEnd



assumes DS,DATA

assumes DS,NOTHING

sEnd   CODE

end MOUSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\comdev.inc ===
;=========================================================================
; Communications Device Driver Definitions  -  September, 1985
;=========================================================================

.xcref

WIN31 = 1
; remove unneeded things in Windows.inc
NOGDICAPMASKS = 1
NOVK	      = 1
NOWH	      = 1
NOMST	      = 1
NORASTOPS     = 1
NOMETAFILE    = 1
NOMDI	      = 1
NOWINMESSAGES = 1
NOSYSMETRICS  = 1
NOCOLOR       = 1
include windows.inc

DCBSize 	equ	SIZE DCB
DCB_Flags	equ	byte ptr DCB_BitMask1
DCB_Flags2	equ	byte ptr DCB_BitMask2

LPTx            equ     10000000b       ;Flags an ID as being an LPT port

ifdef   NEC_98
ID_COM1 	equ	0		;ID of Com1 Port (INS 92.08.04)
ID_COM2 	equ	1		;ID of Com2 Port (INS 92.08.04)
ID_COM3 	equ	2		;ID of Com3 Port (INS 92.08.04)
ID_LPT1 	equ	(ID_COM1 OR LPTx)	;ID of LPT Port (INS 92.08.04)
ID_LPT2 	equ	(ID_COM2 OR LPTx)	;ID of LPT Port (INS 931218)
ID_LPT3 	equ	(ID_COM3 OR LPTx)	;ID of LPT Port (INS 931218)
endif   ; NEC_98

; DCB_BitMask1 (DCB_Flags) equates

fBinary         equ     00000001b       ;Binary mode
fRTSDisable     equ     00000010b       ;Disable RTS
fParity         equ     00000100b       ;Perform Parity Checking
fOutXCTSFlow    equ     00001000b       ;Output handshaking using CTS
fOutXDSRFlow    equ     00010000b       ;Output handshaking using DSR
fEnqAck         equ     00100000b       ;ENQ/ACK software handshaking [rkh] ...
fEtxAck         equ     01000000b       ;ETX/ACK software handshaking
fDTRDisable     equ     10000000b       ;Disable DTR


; DCB_BitMask2 (DCB_Flags2) equates

fOutX           equ     00000001b       ;Output X-ON/X-OFF
fInX            equ     00000010b       ;Input X-ON/X-OFF
fPErrChar       equ     00000100b       ;Parity Error Replacement char active
fNullStrip      equ     00001000b       ;Null Stripping
fCharEvent      equ     00010000b       ;Character event
fDTRFlow        equ     00100000b       ;Input handshaking using DTR
fRTSFlow        equ     01000000b       ;Input handshaking using RTS
;               equ     10000000b


; Values for RLSTimeout, CTSTimeout, DSRTimeout

Ignore          equ     0
Infinite        equ     0FFFFh


; COMS_BitMask1 equates

fCTSHold        equ     00000001b       ;Tx is on CTS hold
fDSRHold        equ     00000010b       ;Tx is on DSR hold
fRLSDHold       equ     00000100b       ;Tx is on RLSD hold
fXOFFHold       equ     00001000b       ;Received an X-OFF
fXOFFSent       equ     00010000b       ;Sent an X-OFF
fEOF            equ     00100000b       ;Received defined EOF character
fTxImmed        equ     01000000b       ;There's a char to transmit immediate
;               equ     10000000b



;       Event mask definitions.  Used by SetCommEventMask and GetCommEventMask
;
;       RXCHAR  - Set when any character is received and placed in the input
;                 queue.
;       RXFLAG  - Set when a particular character, as defined in the DCB,
;                 is received and placed in the input queue.
;       TXEMPTY - Set when the last character in the transmit queue is
;                 transmitted.
;       CTS     - Set when the CTS signal changes state.
;       DSR     - Set when the DSR signal changes state.
;       RLSD    - Set when the RLSD signal changes state.
;       BREAK   - Set when a break is detected on input.
;       RING    - Set when Ring Indicator is detected
;       ERR     - Set when a line status error occurs.


;=========================================================================
;
;       qdb
;       Queue definition block. Passed to setqueue, defines the location and
;       size of the transmit and receive circular queue's used for interrupt
;       transmit and recieve processing.
;
;=========================================================================

QDB struc
  QueueRxAddr   dd      ?               ;Pointer to RX Queue, Offset
  QueueRxSize   dw      ?               ;Size of RX Queue in bytes
  QueueTxAddr   dd      ?               ;Pointer to TX Queue, Offset
  QueueTxSize   dw      ?               ;Size of TX Queue in bytes
QDB ends

.cref
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\commmsg.asm ===
;
; Include code from comm
;

include ..\comm\commmsg.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\comdevi.h ===
;
; Include code from comm
;

include ..\comm\comdevi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\ibmcom1.asm ===
;
; Include code from comm
;

include ..\comm\ibmcom1.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\delay.asm ===
;#########################################################################
;##	cdk`x@[`					 	##
;##	@w[`iPj			##
;##									##
;##		botNbN				##
;##			uROFPOlgZ (PC-9801UV21)			##
;##			QWUFPQlgZ (PC-9801RX2)			##
;##			RWUFQOlgZ (PC-98RL N-MODE)		##
;##			mobFRRlgZ (PC-H98 Model70)		##
;##									##
;##	@Fs@ANbNOA	##
;##									##
;##	Fbw@ijB			##
;##	oF							##
;##	jWX^FbwAtO					##
;##									##
;##---------------------------------------------------------------------##
;##@@X								##
;##	DATE   |  Ver |							##
;##  --------------------------------------------------------------	##
;##    90-04-24 | 1.00 |	Original				##
;##									##
;#########################################################################

;----------------------	knno --------------------------------------
_V30_DELAY_	EQU	550			;uRO@
_286_DELAY_	EQU	1070			;QWU@
_386_DELAY_	EQU	1600			;RWU@
_DELAY_COUNT_	EQU	307			;mob
;--------------------------------------------------------------------------
;########################################################################
;#				f[^				#
;########################################################################
;;;;; _BIOS_FLAG1_	DB	0   ;[0:458H]e		(del 90.10.6)
;;;;; _BIOS_FLAG2_	DB	0   ;[0:480H]e		(del 90.10.6)
;;;;; _CPU_		DW	0   ;s@A_~[[v	(del 90.10.6)
;;;;; _TIME_		DW	0   ;W			(del 90.10.6)
;;;;; _MUKASI_	DW	0	    ;O		(del 90.10.6)

;************************************************************************
;*	^CX^pFgp_~[[v	*
;*			h^nJo[^CgpB	*
;*	A\`qshb|[gpB			*
;*		\F	RDQU@@				*
;*		lF	POUDW@				*
;*		AhXF	OOTb	gi[hj		*
;************************************************************************


_ARTIC_LOW_	EQU	005CH			;^CX^ph^n port

MSR_DELAY:
	PUSH	AX				;gpWX^
	PUSH	BX				;gpWX^
	PUSH	DX				;gpWX^
	push	es				;		(90.10.6)
	PUSH	DS				;f[^ZOgWX^
	push	ds				;		(90.10.6)
	pop	es				;		(90.10.6)

;************************************************************************
;*	bot						*
;*		|||||||ahnrek`fQ		*
;************************************************************************

	mov	ax, 40h			; 			
	mov	ds, ax			; 			

;----------------mobf------------------------------------

	MOV	AL,BYTE PTR DS:[58H]	    ;40:58eAL 
	MOV	BYTE PTR ES:_BIOS_FLAG1_,AL		

;----------------s@botf------------------------------
	MOV	AL,BYTE PTR DS:[80H]	    ;40:80eAL 
	MOV	BYTE PTR ES:_BIOS_FLAG2_,AL		

	MOV	AL,BYTE PTR DS:[5BH]	    ;40:5BeAL (93.03.09)
	MOV	BYTE PTR ES:_BIOS_FLAG3_,AL	;(93.03.09)

	POP	DS				;f[^ZOgWX^A
						
	AND	BYTE PTR _BIOS_FLAG1_,80H	;VrbgOO}XN
	JNZ	_NPC_				
	AND	BYTE PTR ES:_BIOS_FLAG3_,04H	;(93.03.09)
	JNZ	_NPC_				;(93.03.09)
						
	AND	BYTE PTR _BIOS_FLAG2_,03H	;0,1rbgO0}XN
	JZ	_V30_				;0,1rbg00uRO
						
	CMP	BYTE PTR _BIOS_FLAG2_,01H	;0,1rbg01QWU
	JE	_I286_				

;########################################################################
;#				s@				#
;########################################################################
						
_I386_:						;botRWU
	MOV	WORD PTR _CPU_,_386_DELAY_	;386CPU=_386_DELAY_
	JMP	short	_EXIT_CPU_			
						
_V30_:						;botuRO
	MOV	WORD PTR _CPU_,_V30_DELAY_	;V30CPU=_V30_DELAY_
	JMP	short	_EXIT_CPU_			
						
_I286_:						;botQWU
	MOV	WORD PTR _CPU_,_286_DELAY_	;286CPU=_286_DELAY_
						
_EXIT_CPU_:					
;---------------------------------------------- AP
;						
						;
	PUSH	CX				;JE^e
	MOV	CX,_CPU_			;bwQbotQ
;                  ~~~~l@
_LOOP2_:					;
	LOOP	_LOOP2_				;CX=CX-1 : IF ( CX == 0 ) GOTO _LOOP2_
	POP	CX				;JE^eA
						;
;----------------------------------------------		
						
	LOOP	_EXIT_CPU_			;CX=CX-1 : IF ( CX == 0 ) GOTO LOOP1

	pop	es
	POP	DX				;WX^A
	POP	BX				;WX^A
	POP	AX				;WX^A
						
	RET					;RETURN	
						
						
;########################################################################
;#				mob				#
;########################################################################
_NPC_:						
						
	CALL	_NPC_DELAY_			;P[`
						
	LOOP	_NPC_				;CX=CX-1 
;						: IF ( CX == 0 ) GOTO LOOP1

	pop	es				;(INS.91.1.14)
	POP	DX				;WX^A
	POP	BX				;WX^A
	POP	AX				;WX^A


	RET					
						
_NPC_DELAY_:					
	PUSH	CX				
						
	MOV	DX,_ARTIC_LOW_			;`qshb|[ge
						;cw
	IN	AX,DX				;`qshb|[g`w
						;f[^
	MOV	BX,AX				;
	MOV	CX,_DELAY_COUNT_		;bw
	ADD	CX,BX				;W
	MOV	_TIME_,CX			;Wb`jdi[
						
	JNC	_POPO_				
						
;******************************************************************************
;*	0			   7FFF					FFFF  *
;*	1========-----------------1-----------~======================1   *
;*		 	      		        	@                  *
;*@@@@@@WFb`jd         Faw@@F`w @  *
;*                                                                            *
;*                                                                            *
;*                                                                        *
;*                                                                            *
;******************************************************************************
	MOV	_MUKASI_,BX			;_MUKASI_

_YOMU1_:
	IN	AX,DX				;`w
	CMP	_MUKASI_,AX			;Or
						;@AW
						;@A
						;  O
						;@rB
						;@
						;@^CX^pO
						;@

	JA	_POPO_				;I
	
	MOV	_MUKASI_,AX			;O_MUKASI_
;						 
	JMP	_YOMU1_				;[v
;******************************************************************************
;*	0			   7FFF					FFFF  *
;*	1--------~================1=============---------------------1   *
;*		 	       		                            *
;*@@Faw@@@F`w@@@@WFb`jd            *
;*                                                                            *
;*                                                                            *
;*                                                                        *
;*                                                                            *
;******************************************************************************

_POPO_:
	IN	AX,DX				;`w
	CMP	_TIME_,AX			;WH
	JA	_POPO_				;mFW

	POP	CX
	RET					;END NPC_RTN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\ibmcom.inc ===
DEBUG	 equ   1

No_DOSX_Bimodal_Services = 1
IFDEF No_DOSX_Bimodal_Services
%OUT generating code to handle ints without Bimodal Interrupt Services for DOSX
ENDIF

wo       equ   word ptr
by       equ   byte ptr

MAXLPT	 equ   2	;3 LPTs supported (LPT1,2,3)
ifdef    NEC_98
MAXCOM	 equ   8	;9 COMs supported (COM1,2,3)		   (ins 931218)
else     ; NEC_98
MAXCOM	 equ   3	;4 COMs supported (COM1,2,3,4)
endif    ; NEC_98

RS232B   equ   0h       ;RS232 Card(s) I/O addr 40:Save area.
LPTB     equ   8h       ;LPT   Card(s) I/O addr 40:Save area.

IRQ3	 equ   0bh	; Int vector for Com card @ 2xxh
IRQ4	 equ   0ch	; Int vector for Com card @ 3xxh

INTA0    equ   20h      ;X'20' 8259 Interrupt Control Port
INTA1    equ   21h      ;X'21' 8259 Interrupt Mask Port
EOI      equ   20h      ;X'20' 8259 End-of-Interrupt ack

Open     equ   0201h    ;Int 2F open request
Close    equ   0202h    ;Int 2F close request
Lock2F   equ   0203h    ;Int 2F lock request
Unlock2F equ   0204h    ;Int 2F unlock request


; COMDEB - Communications Device Equipment Block.
;
; This is essentially a superset of the DCB used outside of this
; module. The DCB is contained within the DEB as the first fields.
; The fields which follow are data and status fields which
; are unique to this implementation.
;
; AltQInAddr and AltQOutAddr are alternate queue pointers which are used when
; in "supervisor" mode.  Supervisor mode is a processor mode other than the
; one which Windows normally runs in.  In standard mode Windows, supervisor
; mode is REAL mode.  In enhanced mode Windows, supervisor mode is RING 0
; protected mode.  For more details see comments in IBMINT.ASM.

ComDEB struc                           ;RS232 Data Equip Block

  ComDCB        db      ((DCBSize+1) and 0FFFEh) DUP (0)

  ComErr        dw      0               ;Non-zero if I/O error
  Port          dw      0               ;Base I/O Address
  NotifyHandle	dw	0
  NotifyFlags	dw	0
  RecvTrigger	dw     -1		; char count threshold for calling
  SendTrigger	dw	0		; char count threshold for calling

; The following fields are specific to com ports only

  IRQhook	dw	0		; ptr to IRQ_Hook_Struc
  NextDEB	dw	0		; ptr to next DEB that is sharing IRQ
  XOffPoint     dw      0               ;Q count where XOff is sent
  EvtMask       dw      0               ;Mask of events to check for
  EvtWord       dw      0               ;Event flags
  QInAddr	dd	0		;Address of the queue
  AltQInAddr	dd	0		;   Addr of queue in "supervisor" mode
  QInSize       dw      0               ;Length of queue in bytes
  QOutAddr      dd      0               ;Address of the queue
  AltQOutAddr	dd	0		;   Addr of queue in "supervisor" mode
  QOutSize      dw      0               ;Length of queue in bytes
  QInCount      dw      0               ;Number of bytes currently in queue
  QInGet        dw      0               ;Offset into queue to get bytes from
  QInPut        dw      0               ;Offset into queue to put bytes in
  QOutCount     dw      0               ;Number of bytes currently in queue
  QOutGet       dw      0               ;Offset into queue to get bytes from
  QOutPut       dw      0               ;Offset into queue to put bytes in
  EFlags        db      0               ;Extended flags
  MSRShadow     db      0               ;Modem Status Register Shadow
  ErrorMask     db      0               ;Default error-checking mask
  RxMask        db      0               ;Character mask
  ImmedChar     db      0               ;Char to be transmitted immediately
  HSFlag        db      0               ;Handshake flag
  HHSLines      db      0               ;8250 DTR/RTS bits for handshaking
  OutHHSLines   db      0               ;Lines that must be high to output
  MSRMask       db      0               ;Mask of Modem Lines to check
  MSRInfinite   db      0               ;Mask of MSR lines that must be high
  IntVecNum     db      0               ;Interrupt vector number
  LSRShadow	db	0		;Line Status Register shadow
  QOutMod	dw	0		;characters sent mod xOnLim ENQ/ETX [rkh]
  VCD_data	dd	0
  VCDflags	db	0
  MiscFlags	db	0		;still more flags
ifdef   NEC_98
  TimerProcAdr	dw	0	; System Timer Procesor		(ins 92.08.05)
  TimerHandle	dw	0	; System Timer Handle		(ins 92.08.05)
  MaskFFPort	dw	0	; Mask F/F Set/Reset Port	(ins 92.08.05)
  ReadSigPort	dw	0	; Read Signal Port		(ins 92.08.05)
  DataPort	dw	0	; Data Port			(ins 92.08.05)
  CommandPort	dw	0	; Command Port			(ins 92.08.05)
  StatusPort	dw	0	; Status Port			(ins 92.08.05)
  IMRPort	dw	0	; Interrupt Mask Register Port	(ins 92.08.05)
  EOIPort	dw	0	; End Of Interrupt Port		(ins 92.08.05)
  CommandShadow	db	0	; Copy of 8251 Command byte 	(ins 92.08.05)
  MaskFFShadow	db	0	; Copy of TxR.RxR.TxE MASK byte	(ins 92.08.05)
  Mask8259	db	0	;save old IRQ mask		(INS 92.08.05)
  IntVecIntCount db	0	;				(INS 92.08.05)
  AOBA_flag	db	0	; AOBA 				(ins 94.04.14)
  preFCRShadow	db	0	; WIN N FCR 	(ins 94.06.06)
  hTimer	dw	0	;Timer Handle Flag		<ins 94.06.03>
endif   ; NEC_98
ComDEB ends

.errnz	 (SIZE ComDEB) and 1

.errnz	MSRShadow - EvtWord - 35
; In 3.0 MSRShadow had this relationship to EvtWord and major COM apps all
; use this offset of 35 to get to MSRShadow so that they can determine the
; current status of the Modem Status bits.  We need to maintain this offset
; so that these apps will continue to run.


; The LptDEB is identical to the ComDEB structure, except
; all the COM port specific stuff has been removed (which
; convientiently was stored at the end so offsets would
; be correct).  This allows the code to act indifferently
; when accessing the strucutres for things like the port.

LptDEB struc
  xComDCB       db      ((DCBSize+1) AND 0FFFEh) dup (0)
  xComErr       dw      0               ;Non-zero if I/O error
  xPort         dw      0               ;Base I/O Address
  xNotifyHandle dw	0
  xNotifyFlags	dw	0
  xRecvTrigger	dw     -1		; char count threshold for calling
  xSendTrigger	dw	0		; char count threshold for calling

  BIOSPortLoc	dw	0		;Offset to port location (i.e. 40:0)
LptDEB ends

		.errnz	 xComDCB-ComDCB
		.errnz	 xComErr-ComErr
		.errnz	 xPort-Port

		.errnz	 xNotifyHandle-NotifyHandle
		.errnz	 xNotifyFlags-NotifyFlags
		.errnz	 xRecvTrigger-RecvTrigger
		.errnz	 xSendTrigger-SendTrigger


; flag equates in EFlags
fUseDSR     equ 00000001b		; set, if DSR is significant
fNoFIFO     equ 00000010b		; set, if no FIFO on port
fFIFOchkd   equ 00000100b		; set, if FIFO has been checked
fFIFOpre    equ 00001000b		; FIFO enabled when port opened
;fEOF	    equ 00100000b		; defined in comdev.inc
;fTxImmed   equ 01000000b		; defined in comdev.inc

fEFlagsMask equ fUseDSR OR fFIFOpre OR fFIFOchkd OR fNoFIFO ; flags which shouldn't be cleared

.errnz fEFlagsMask AND (fEOF OR fTxImmed) ;can't overlap with either of the bits
					;  that are folded into COMS_BitMask1

ifdef   NEC_98
; flag equates in AOBA_flag		;					(ins 94.04.14)
fFIFO_Mode  equ 00000001b		; set, if the baudrate is more 1200BPS  (ins 94.04.14)
endif   ; NEC_98

; Values for NotifyFlags
;
CN_RecvSent	equ CN_RECEIVE SHL 8
CN_TransSent	equ CN_TRANSMIT SHL 8

CN_Idle 	equ 10000000b
CN_Notify	equ 01000000b

NotifyFlagsLO	equ byte ptr NotifyFlags
NotifyFlagsHI	equ byte ptr NotifyFlags+1

; Values for the handshake flag
;
; BreakSet        - True if break was set - stops transmission
; XOffSent        - True if we have sent the XOff character
; XOffPending     - True if XOff character needs to be sent
; XOnPending      - True if XOn  character needs to be sent
; HHSDown         - True if host dropped required hardware lines
; HHSDropped      - True if we dropped our hardware handshake lines
; XOffReceived    - True if XOff received from host
; HSPending       - Mask to return non-zero if XOn or Xoff must be sent
; HSReceived      - Mask to return non-zero if handshake has been
;                   received from host stopping transmission
; CannotXmit      - Mask to return non-zero if any condition
;                   exists which prevents us from tranmitting.
; HSSent          - Mask to return non-zero if we sent a handshake


XOffPending     equ     00000001b       ;XOff needs to be sent
EnqPending      equ     00000001b       ;Enq needs to be sent [rkh]
EtxPending      equ     00000001b       ;Etx needs to be sent

HHSDropped      equ     00000010b       ;Our hardware handshake lines are down

XOnPending      equ     00000100b       ;XOn needs to be sent
AckPending      equ     00000100b       ;Ack needs to be sent (ENQ/ACK & ETX/ACK)

XOffReceived    equ     00001000b       ;XOff character received
EnqSent         equ     00001000b       ;Enq has been sent
EtxSent         equ     00001000b       ;Etx has been sent

XOffSent        equ     00010000b       ;XOff has been sent
EnqReceived     equ     00010000b       ;Enq character received (ENQ/ACK)
EtxReceived     equ     00010000b       ;Etx character received (ETX/ACK)

HHSDown         equ     00100000b       ;Host hardware handshake lines are down

BreakSet        equ     01000000b       ;Break has been set

HHSAlwaysDown	equ	10000000b	;set if host handshake lines were never
					;  detected high

HSPending       equ     XOffPending+XOnPending
HSReceived      equ     XOffReceived+HHSDown
HSSent          equ     XOffSent+HHSDropped
CannotXmit	equ	HSPending+HSReceived+BreakSet

; values for MiscFlags

Discard 	equ	00000001b	;Discard recevied data


ifdef   NEC_98
;**     NewI/ODelay - delay long enough for the bus to catch up to the cpu;(ins 92.11.11)
NEWIODELAY	MACRO	times			;(ins 92.11.11)
LOCAL	a					;(ins 92.11.11)
	push	CX				;(ins 92.11.11)
	mov	CX,times			;(ins 92.11.11)
a:	OUT	5Fh,AL				;(ins 92.11.11)
	loop	a				;(ins 92.11.11)
	pop	CX				;(ins 92.11.11)
ENDM						;(ins 92.11.11)
else    ; NEC_98
iodelay macro		     ;;macro to insure that an instruction
	jmp	$+2	     ;;  fetch occurs between IN and/or OUT
	jmp	$+2	     ;;  instructions on the PC-AT machine
endm
endif   ; NEC_98


TimeoutError   equ   -2      ;Timeout error code for $TRMCOM
Timeout        equ   30      ;30 second timeout

DELAY_TIME     equ   200     ;Delay at least 200 milliseconds


;       Status bits returned from the BIOS for LPT ports

PS_NotBusy      equ     10000000b       ;Printer not busy
PS_Ack          equ     01000000b       ;Data acknowledged
PS_PaperOut     equ     00100000b       ;Out of paper
PS_Select       equ     00010000b       ;Device is selected
PS_IOError      equ     00001000b       ;IO error
PS_Timeout      equ     00000001b       ;Timeout occured


; status bit defines for LPT

L_BITS	      equ     0F8h		  ; the status bits we want
L_BITS_INVERT equ     048h		  ; must invert to match BIOS
L_DEVBUSY     equ     080h		  ; device busy bit
L_TIMEOUT     equ     001h		  ; timeout bit

; control bit defines for LPT

L_NORMAL      equ     00Ch		  ; normal state: selected, no reset
L_RESET       equ     008h		  ; reset state
L_STROBE      equ     00Dh		  ; tell printer we have char

ifdef   NEC_98
; control port for TOKI(Printer)	;			 <Toki:930923>
Toki_BasePort		equ	0140h	; Base I/O Address	 <Toki:930923>
Toki_DataLatch		equ	0140h	; Data Port		 <Toki:930923>
Toki_PrinterStatus	equ	0141h	; Status Port		 <Toki:930923>
Toki_PrinterControls	equ	0142h	; Control Port		 <Toki:930923>
Toki_ControlStatus	equ	0149h	; Control Status Port	 <Toki:930923>
Toki_EX_Control		equ	014eh	; Ex Control Port	 <Toki:930923>

;---------------  8251 Serial Interface Command Status  ----------------------
;--------------------------------------------------------
;	Modem Status ( IBM Emulation ) USE MSR_READ
;--------------------------------------------------------
DSR		=	10000000B	; Data Set Ready
RI		=	01000000B	; Ring Indicater (CI)
CTS		=	00100000B	; Clear To Send
RLSD		=	00010000B	; Recive Line Signal Detect (CD)

;--------------------------------------------------------
;	Port C ( USART Trap Mask )
;--------------------------------------------------------
RAM_CHECK	=	00010000b	; Prity Check of RAM Enable
SPEAKER_OFF	=	00001000b	; Stop Speaker
MSK_TXR		=	00000100B	; TX Ready Enable
MSK_TXE		=	00000010B	; TX Empty Enable
MSK_RXR		=	00000001B	; RX Ready Enable

;--------------------------------------------------------
;	8251 Int Enable F/F
;--------------------------------------------------------
Enable_TxR	equ	00000100b	;Tx Ready F/F Enable
Enable_TxE	equ	00000010b	;Tx Empty F/F Enable
Enable_RxR	equ	00000001b	;Rx Ready F/F Enable

;--------------------------------------------------------
;	8251 Status
;--------------------------------------------------------
BRK_DETECT	=	01000000B	; Break Detect
F_ERR		= 	00100000B	; Framing Err
O_ERR		= 	00010000B	; OverRun Err
P_ERR		= 	00001000B	; Parity Err
TX_EMP		=	00000100B	; TX Empty
RX_RDY		= 	00000010B	; RX Ready
TX_RDY		=	00000001B	; TX Ready

;--------------------------------------------------------
;	8251 Command Byte
;--------------------------------------------------------
INTER_RESET	=	01000000B	; Mode Instruction Set
RTS		=	00100000B	; RTS
ERR_RESET	=	00010000B	; Reset PE & OE & FE Bit
SEND_BREAK	=	00001000B	; The Break commands bit
RX_E		=	00000100B	; RX Enable
DTR		=	00000010B	; DTR
TX_E		= 	00000001B	; TX Enable

;--------------------------------------------------------
;	etc.....
;--------------------------------------------------------
SLAVE_PIC	=	08H		; Slave PIC Port
ISR_READ	=	0BH		; ISR Read Command
MASTER_OCW2	=	00H		; Master PIC OCW2 Port
SLAVE_ISR	=	08H		; Slave PIC ISR Port
EOI		=	20H		; EOI Command
ALL_DONE	= 	00000000B	; 8251 Interrupt Disable
RS_TIME_MOD	= 	0B6H		; Ch.0 baudrate Generator
TIMER2		=	075H		;
TIME_CTL	=	077H		;

SI_CHR		=	0FH		; SHIFT IN
SO_CHR		=	0EH		; SHIFT OUT

;---------------------------------------------------------
;	Parallel Interface Command & Status Set
;---------------------------------------------------------
PRN_WRITE_DATA		equ	040h	;
PRN_READ_SIGNAL1	equ	042h	;
PRN_WRITE_SIGNAL1	equ	046h	;

PRN_PSTB_Active_X2 	equ	004h	;
PRN_PSTB_NonActive_X2	equ	005h	;
CMOS_RAM_SEG_X2		equ	0e300h	; Memory Switch Segment ( PC-98XA )

PRN_PSTB_Active_X1 	equ	00eh	;
PRN_PSTB_NonActive_X1	equ	00fh	;
CMOS_RAM_SEG_X1		equ	0a300h	; Memory Switch Segment ( PC-9800 )

PRN_TimeOutValue	equ	005h

;-------------------------------------------
;	Offset Address of Software Switch
;-------------------------------------------
ssw1			equ	0fe2h	;
ssw2			equ	0fe6h	;
ssw3			equ	0feah	;
ssw4			equ	0feeh	;
ssw5			equ	0ff2h	;
ssw6			equ	0ff6h	;
endif   ; NEC_98

IRQ_Hook_Struc struc
IRQn		db  0
HookCnt 	db  0
OldMask 	db  0
VecN		db  0FFh
HandlerOff	dw  0
First_DEB	dw  0
OldIntVec	dd  0
IFDEF No_DOSX_Bimodal_Services
RM_OldIntVec	dd  0
RM_HandlerOff	dw  0
ENDIF
IRQ_Hook_Struc ends


IFDEF No_DOSX_Bimodal_Services
include int31.inc

Get_RM_IntVector equ (Int31_Int_Serv SHL 8) + Int_Get_Real_Vec
Set_RM_IntVector equ (Int31_Int_Serv SHL 8) + Int_Set_Real_Vec
ENDIF

;
; flag bits for VCDflags
;
fCOM_ignore_ints    equ 00000001b
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\ibmcom.asm ===
page,132
;---------------------------Module-Header-------------------------------;
; Module Name: IBMCOM.ASM
;
; !!!
;
; Created: Fri 06-Feb-1987 10:45:12
; Author:  Walt Moore [waltm]
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; General Description:
;
; History:
;
;   ***************************************************************
;	Tue Dec 19 1989 09:32:15   -by-  Amit Chatterjee [amitc]
;   ---------------------------------------------------------------
;   Modified the 'InitAPort' routine called from 'ReactivateOpenCommPort'.
;   If the out queue for a port has characters to send out then we must
;   restart the trasmission process by faking a comm interrupt on that
;   port.
;   ***************************************************************
;	Tue Nov 21 1989 09:46:50    -by- Amit Chatterjee [amitc]
;   ---------------------------------------------------------------
;   The base port addresses in the COMM1,COMM2,COMM3,COMM4 structures
;   are being zeroed out when the corresponding comm port is closed.
;   This is because the  'ReactivateOpenCommPort' function looks at it
;   and if the port address is not zero decides that comm ports are
;   open. 
;   ***************************************************************
;	Tue Nov 14 1989 18:42:00     ADDED TWO EXPORTED FUNCTIONS
;   ---------------------------------------------------------------
;   Added two exported functions 'SuspendOpenCommPorts' and 
;   'ReactivateOpenCommPorts' for 286 winoldap support. The first one simply 
;   releases the comm int vects and installs the originall one, the second one
;   hooks back the comm driver comm vectors and then reads the receive buffer,
;   the status and the IIR registers of all the available comm ports to 
;   remove pending interrupts. It also reprograms the PIC to enable interrupts
;   on all open comm channels.
;   ---------------------------------------------------------------
;   -by- Amit Chatterjee [amitc]    
;   ***************************************************************
;	Tue Aug 30 198? 12:52:00      MAJOR FIX TO HANDLE 8250B
;   ---------------------------------------------------------------
;   
;   8250B has the following peculiar charactersistic
;             . The very first time (after reset) the Tx Holding Empty
;               interrupt is enabled, an immediate interrupt is generated
;
;             . After the first time, switching the Tx Holding Empty
;               interrupt enable bit from disabled to enabled will NOT
;               generate an immediate interrupt (unlike in 8250)
;       Because of this the KICKTX routine fails to set the transmit cycle
;       on if the machine has a 8250B
;   
;       This has been taken care as follows:
;             . For the very first byte that is being transmitted, KICKTX
;               is used to generate the first Tx Holding Empty interrupt
;             . Subsequently, whenever we find that the transmit buffer
;		is empty, we use a SOFTWARE INT (either INT 0Bh, or INT 0Ch)
;               to force the first character out, once this is done the
;               Tx Holding Empty interrupt will be generated once the buffer
;               really is empty
;             . Now we no longer disable the Tx Holding Empty interrupt
;               in the Xmit ISR to ensure that even m/cs with 8250, use
;               the software int to kick the tx interrupt on after the
;               first time.
;             . The software interrupt is also forced whenever an X-ON 
;               character is received.   
;
;       The code that implements the above logic is marked out with a line
;       asterixes.   
;   ------------------------------------------------------------------
;   -by- Amit Chatterjee [amitc]    
;       ******************************************************************
;
;   062587   HSFlag and Evtmask in DoLPT.  These fields do not exist
;      for LPT type devices.  The code which manipulated them
;      was removed
;
;      KickTx from $SndCom - interrupts were not disabled when
;      calling KickTx.
;
;      $SetCom - added CLD at the start
;
;      $SetQue - movsw ==> stosw
;
;       111285  Changed the Timeout from 7 to 30 seconds.
;
;       110885  Forgot to set EV_RxChar event when a character
;               was received.
;
;       102985  INS8250, INS8250B bug with enabling interrupts.
;               Setting ACE_ETBEI in the Interrupt Enable Register
;               will cause an immediate interrupt regardless of
;               whether the transmitter register is empty or not.
;               The first interrupt MAY also be missed.
;
;               The first case is not a problem since we only enable
;               interrupts if the transmitter register is empty.  The
;               second problem was showing up on Microsoft System Cards
;               in PC-XTs.  The first interrupt was missed after a cold
;               boot.  National claims the fix is to write the register
;               twice, which SEEMS to work...
;
;               Added timeout code to $TRMCOM.  If the number of
;               characters in the output queue doesn't decrease
;               in "Timeout" seconds, then the port will be closed
;               anyway.  Also flushed the input queue and added a
;               discard-input flag for the data available interrupt
;               code to discard any input received while terminating
;               a port.  $TRMCOM will return an error code if it
;               discarded any output data.
;
;               Removed infinite timeout test in MSRWait routine.
;               Still bad, but it will timeout around 65 seconds
;               instead of never.
;
;       102785  LPT initialization code was jumping to InitCom90,
;               which was setting EFlags[si] to null.  Well, LPTs
;               don't have an EFlags field, so the null was getting
;               stuffed over the LSB of BIOSPortLoc of the next LPT
;               device.
;
;       101185  Save interrupt vector when opening a comm port
;               and restore it when closing.  Would you believe
;               there are actually programs that assume the
;               vector points to a non-specific 8259 ACK and
;               an IRET!
;
;       100985  Added MS-NET support to gain exclusive control
;               of an LPT port if DOS 3.x and not running in as
;               a server, receiver, or messenger.   Required to
;               keep another application, such as command.com
;               from closing the stream or mixing their output
;               with ours.
;       sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;               FCLI/FSTI macros
;-----------------------------------------------------------------------;

title   IBMCom - IBM PC, PC-XT, PC-AT, PS/2 Communications Interface

.xlist
include cmacros.inc
include comdev.inc
include ins8250.inc
include ibmcom.inc
include vint.inc
.list

externNP GetDEB
externNP DoLPT
externNP StringToLPT
externNP FindCOMPort
externNP StealPort

ifdef   NEC_98
externFP MSR_READ_Call					;[QN]	;(ins 92.09.27)
externFP AOBA_MSR_READ_Call				;AOBA-bug ins 94.11.19 KBNES
externFP Set8251modeFar					;(ins 94.04.18)
externFP SetFIFOmodeFar					;(ins 94.04.18)
endif   ; NEC_98

sBegin	 Data

externB  $MachineID

ifdef   NEC_98
;-------------------------------------------------------;[QN]	(ins 92.08.xx)
;	MSR's_DELAY local buffer			;[QN]	(ins 92.08.xx)
;-------------------------------------------------------;[QN]	(ins 92.08.xx)
 _BIOS_FLAG1_	DB	0	;[0:458H]		;[QN]	(ins 92.08.xx)
 _BIOS_FLAG2_	DB	0	;[0:480H]		;[QN]	(ins 92.08.xx)
 _BIOS_FLAG3_	DB	0	;[0:45BH]		;[QN]	(ins 93.03.09)
 _CPU_		DW	0	;loop count		;[QN]	(ins 92.08.xx)
 _TIME_		DW	0	;target time		;[QN]	(ins 92.08.xx)
 _MUKASI_	DW	0	;previous time		;[QN]	(ins 92.08.xx)
endif   ; NEC_98

sEnd Data

sBegin Code
assumes cs,Code
assumes ds,Data

page

;----------------------------Public Routine-----------------------------;
;
; $RECCOM - Receive Characters From Device
;
; Read Byte From RS232 Input Queue If Data Is Ready
;
; LPT ports will return with an indication that no characters are
; available.
;
; Entry:
;   AH = Device ID
; Returns:
;   'Z' clear if data available
;   AL = byte
; Error Returns:
;   'Z' Set if error or no data
;   AX = error code
;   AX = 0 if no data
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $RECCOM
$RECCOM proc   near

	push	si			;Once again, save some registers
	push	di
	call	GetDEB			;Get DEB pointer in SI
	jc	RecCom10		;Invalid Port [rkh] ...
	jns	RecCom20		;COM port
	jmp	RecCom95		;LPT port, return no characters

RecCom10:
	jmp	RecCom100		; Invalid Port

; Before removing any charcters from the input queue, check to see
; if XON needs to be issued.  If it needs to be issued, set the
; flag that will force it and arm transmit interrupts.

RecCom20:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	RecCom32		;  No
	test	HSFlag[si],EnqReceived+HHSDropped ;Enq recvd or lines dropped?
        jnz      RecCom21                ;  No Enq recvd & no lines dropped
        jmp      RecCom60                ;  No Enq recvd & no lines dropped
RecCom21:
	jmp	short RecCom34

RecCom32:
	test	HSFlag[si],HSSent	;Handshake sent?
ifdef   NEC_98
        jnz     RecCom34                ;  No XOFF sent & no lines dropped
        jmp     RecCom60                ;  No XOFF sent & no lines dropped
else    ; NEC_98
        jnz     RecCom33                ;  No XOFF sent & no lines dropped
        jmp     RecCom60                ;  No XOFF sent & no lines dropped
RecCom33:
endif   ; NEC_98

RecCom34:
	mov	ax,QInCount[si] 	;Get current count of input chars
	cmp	ax,[si.DCB_XonLim]	;See if at XOn limit
ifdef   NEC_98
        jbe     Dummy00                 ;(95.1.25)
	jmp	RecCom60		;Not at XOn limit yet
Dummy00:
else    ; NEC_98
	ja	RecCom60		;Not at XOn limit yet
endif   ; NEC_98

; If any hardware lines are down, then raise them.  Then see
; about sending XON.

ifdef   NEC_98
	mov     dx,CommandPort[si]	;Get the port	   ;[QN] (ins 92.08.xx)
else    ; NEC_98
	mov	dx,Port[si]		;Get the port
endif   ; NEC_98
	mov	ah,HHSLines[si] 	;Get hardware lines mask
ifndef  NEC_98
        call DOCLI                             ;Handle this as a critical section
endif   ; NEC_98
	mov	cl,HSFlag[si]		;Get handshaking flags
	or	ah,ah			;Any hardware lines to play with?
	jz	RecCom40		;  No
ifdef   NEC_98
        mov	al,CommandShadow[si]	;8251 Command get 	 (ins 92.08.xx)|
	test	ah,ACE_DTR	    	;DTR handshake Enable ?	 (ins 92.08.xx)|
	jz	RecCom31	    	;  No			 (ins 92.08.xx)|
	or	al,DTR		    	;Set 8251's DTR Active ! (ins 92.08.xx)|
RecCom31:			    	;			 (ins 92.08.xx)|
	test	ah,ACE_RTS	    	;RTS handshake Enable ?	 (ins 92.08.xx)|
	jz	RecCom33		;  No			 (ins 92.08.xx)|
	or	al,RTS			;Set 8251's RTS Active ! (ins 92.08.xx)|
RecCom33:				;			 (ins 92.08.xx)|
	push	dx			;			(ins 94.05.18)|
	mov	dh,CommandShadow[si]	;			(ins 94.05.18)|
	mov	dl,al			;			(ins 94.05.18)|
	and	dx,2222h		;			(ins 94.05.18)|
	cmp	dh,dl			;			(ins 94.05.18)|
	pop	dx			;			(ins 94.05.18)|
	je	@f			;			(ins 94.05.18)|
	FCLI				;			(ins 94.05.18)|
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.05.18)|
	jz	RecCom35		;Now, 8251 mode		(ins 94.05.18)|
	call	Set8251modeFar		;Change to 8251 mode	(ins 94.05.18)|
RecCom35:				;			(ins 94.05.18)|
	out	dx,al			;			 (ins 92.08.xx)|
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.05.18)|
	jz	@F			;Now, 8251 mode		(ins 94.05.18)|
	call	SetFIFOmodeFar		;Change to FIFO mode	(ins 94.05.18)|
@@:					;			(ins 94.05.18)|
	mov	CommandShadow[si],al 	;Get Back 8251 Command   (ins 92.08.xx)|
else    ; NEC_98
	add	dl,ACE_MCR		;--> Modem control register
	in	al,dx
	or	al,ah			;Turn on the hardware bits
	iodelay
	out	dx,al
endif   ; NEC_98
	and	cl,NOT HHSDropped	;Show hardware lines back up

RecCom40:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	RecCom47		;  No
	test	cl,EnqReceived		;Did we receive Enq?
	jz	RecCom55		;  No
	and	cl,NOT EnqReceived
	jmp	short RecCom50

RecCom47:
	test	cl,XOffSent		;Did we send XOFF?
	jz	RecCom55		;  No
	and	cl,NOT XOffSent 	;Remove XOFF sent flag

RecCom50:
	or	cl,XOnPending		;Show XON or ACK must be sent
ifdef   NEC_98
        mov	HSFlag[si],cl  		;Store handshake flag ;[QN](ins 92.08.xx /92.10.21)
endif   ; NEC_98
	call	KickTx			;Kick xmit if needed

RecCom55:
	mov	HSFlag[si],cl		;Store handshake flag
        call DOSTI                             ;Can allow interrupts now

; Now we can get down to the business at hand, and remove a character
; from the receive queue.  If a communications error exists, we return
; that, and nothing else.

RecCom60:
	xor	ax,ax
	or	ax,ComErr[si]		;Any Errors?
	jnz	RecCom100		;  Yes, return the error code
	or	ax,QInCount[si] 	;Get current input char count
	jz	RecCom90		;No characters in the queue
	les	di,QInAddr[si]		;Get queue pointer
	assumes es,nothing

	mov	bx,QInGet[si]		;Also get the index to head
	mov	al,es:[bx][di]		;Finally, get byte from queue
	inc	bx			;Update queue index
	cmp	bx,QInSize[si]		;See if time for wrap-around
	jc	RecCom70		;Jump if no wrap
	xor	bx,bx			;wrap by zeroing the index

RecCom70:
	mov	QInGet[si],bx		;Save new head pointer
	dec	QInCount[si]		;Dec # of bytes in queue

	mov	cx, [si.QinCount]
	cmp	cx, [si.RecvTrigger]	;Q: have we read below trigger?
	jae	RecCom80		;   N:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE ; allow timeout notify again
RecCom80:
	or	sp,sp			;Reset PSW.Z
	pop	di
	pop	si
	ret

; No characters in the input queue.  Check to see if EOF
; was received, and return it if it was.  Otherwise show
; no characters.

RecCom90:
	test	[si.DCB_Flags],fBinary	;Are we doing binary stuff?
	jnz	RecCom95		;  Yes, show no characters
	mov	al,[si.DCB_EofChar]	;Assume EOF
	test	EFlags[si],fEOF 	;Has end of file char been received?
	jnz	RecCom80		;  Yes, show end of file

RecCom95:
	xor	ax,ax			;Show no more characters

; Return with 'Z' to show error or no characters

RecCom100:
	xor	cx,cx			;Set PSW.Z
	pop	di
	pop	si
	ret

$RECCOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $RECSTR - Receive Characters From Device
;
; Read Byte From RS232 Input Queue If Data Is Ready
;
; LPT ports will return with an indication that no characters are
; available.
;
; Entry:
;   AH = Device ID
;   ES:DI -> receive buffer
;   CX max bytes to read
; Returns:
;   'Z' clear if data available
;   AX = # of bytes read
; Error Returns:
;   'Z' Set if error or no data
;   AX = error code
;   AX = 0 if no data
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	 $RECSTR
$RECSTR proc   near

	push	si			;Once again, save some registers
	push	di
	call	GetDEB			;Get DEB pointer in SI
	jc	RecStr10		;Invalid Port [rkh] ...
	jns	RecStr20		;COM port
	jmp	RecStr95		;LPT port, return no characters

RecStr10:
	jmp	RecStr100		; Invalid Port
RecStr15:
	jmp	RecStr90

RecStr20:
	xor	ax,ax
	or	ax,ComErr[si]		;Any Errors?
	jnz	RecStr10		;  Yes, return the error code
	or	ax,QInCount[si] 	;Get current input char count
	jz	RecStr15		;No characters in the queue

	cmp	cx, ax			;Q: more chars available than can read?
	jbe	short RecStr30		;   N:
	mov	cx, ax			;   Y: adjust # of chars to read
RecStr30:
	push	cx
	mov	dx, QInSize[si]
	mov	ax, QInGet[si]
	sub	dx, ax			; dx = # of bytes before end of buf
	cmp	dx, cx			;Q: more avail than can read?
	jbe	short RecStr40		;   N:
	mov	dx, cx			;   Y: adjust avail count
RecStr40:
	xchg	cx, dx			; cx = # of bytes for 1st copy
	sub	dx, cx			; dx = # of bytes for 2nd copy

	push	ds
	push	si
	lds	bx, QInAddr[si]
	mov	si, bx
	add	si, ax			; ds:si -> first char in buffer
	cld
	rep	movsb			; do first copy
	mov	cx, dx
	jcxz	short RecStr50		; jump if no 2nd copy needed
	mov	si, bx			; ds:si -> start of buffer
	rep	movsb			; do 2nd copy
RecStr50:
	sub	si, bx			; si = new QInGet
	mov	bx, si
	pop	si
	pop	ds
	pop	cx
        call DOCLI
	mov	QInGet[si], bx		; update QInGet
	sub	QInCount[si], cx	; update count
	mov	ax, QInCount[si]
        call DOSTI

	cmp	ax, [si.RecvTrigger]	;Q: have we read below trigger?
	jae	@F			;   N:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE ; allow timeout notify again
@@:

; Check to see if XON needs to be issued.  If it needs to be issued, set the
; flag that will force it and arm transmit interrupts.

	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	@F			;  No
	test	HSFlag[si],EnqReceived+HHSDropped ;Enq recvd or lines dropped?
        jnz     RecStr58                ;  No Enq recvd & no lines dropped
        jmp     RecStr80                ;  No Enq recvd & no lines dropped
RecStr58:
	jmp	short RecStr60

@@:
	test	HSFlag[si],HSSent	;Handshake sent?
        jnz     RecStr59                ;  No XOFF sent & no lines dropped
        jmp     RecStr80                ;  No XOFF sent & no lines dropped
RecStr59:

RecStr60:
					;ax = current count of input chars
	cmp	ax,[si.DCB_XonLim]	;See if at XOn limit
ifdef   NEC_98
        jbe     Dummy10                 ;(95.1.25)
	jmp	RecStr80		;Not at XOn limit yet
Dummy10:
else    ; NEC_98
	ja	RecStr80		;Not at XOn limit yet
endif   ; NEC_98

;;	  int 1
; If any hardware lines are down, then raise them.  Then see
; about sending XON.

ifdef   NEC_98
	push	cx			;			(ins 92.09.xx)|
	mov   dx,CommandPort[si]	;Get the port		    (92.08.xx)|
	mov   ah,HHSLines[si]		;Get hardware lines mask    (92.08.xx)|
	mov   cl,HSFlag[si]		;Get handshaking flags	    (92.08.xx)|
        or      ah,ah           	;Any H/W lines to play with?(92.08.xx)|
        jz      RecStr64                ;  No (Goto Xmit Xon Char)  (92.08.xx)|
        mov	al,CommandShadow[si]	;8151 Command get 	    (92.08.xx)|
	test	ah,ACE_DTR		;DTR handshake Enable ?	    (92.08.xx)|
	jz	RecStr61		;  No			    (92.08.xx)|
	or	al,DTR			;Set 8251's DTR Active !    (92.08.xx)|
RecStr61:				;			    (92.08.xx)|
	test	ah,ACE_RTS		;RTS handshake Enable ?	    (92.08.xx)|
	jz	RecStr63		;  No			    (92.08.xx)|
	or	al,RTS			;Set 8251's RTS Active !    (92.08.xx)|
RecStr63:				;			    (92.08.xx)|
	push	dx			;			(ins 94.05.18)|
	mov	dh,CommandShadow[si]	;			(ins 94.05.18)|
	mov	dl,al			;			(ins 94.05.18)|
	and	dx,2222h		;			(ins 94.05.18)|
	cmp	dh,dl			;			(ins 94.05.18)|
	pop	dx			;			(ins 94.05.18)|
	je	@f			;			(ins 94.05.18)|
	FCLI				;			(ins 94.05.18)|
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.05.18)|
	jz	RecStr63_1		;Now, 8251 mode		(ins 94.05.18)|
	call	Set8251modeFar		;Change to 8251 mode	(ins 94.05.18)|
RecStr63_1:				;			(ins 94.05.18)|
	out	dx,al			;			    (92.08.xx)|
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.05.18)|
	jz	@F			;Now, 8251 mode		(ins 94.05.18)|
	call	SetFIFOmodeFar		;Change to FIFO mode	(ins 94.05.18)|
@@:					;			(ins 94.05.18)|
	mov	CommandShadow[si],al	;Get Back 8251 Command Byte (92.08.xx)|
	and	cl,NOT HHSDropped	;Show hardware lines back up(92.08.xx)|
RecStr64:				;			    (92.08.xx)|
else    ; NEC_98
	mov	dx,Port[si]		;Get the port
	mov	ah,HHSLines[si] 	;Get hardware lines mask
	push	cx
        call DOCLI                             ;Handle this as a critical section
	mov	cl,HSFlag[si]		;Get handshaking flags
	or	ah,ah			;Any hardware lines to play with?
	jz	@F			;  No
	add	dl,ACE_MCR		;--> Modem control register
	in	al,dx
	or	al,ah			;Turn on the hardware bits
	iodelay
	out	dx,al
	and	cl,NOT HHSDropped	;Show hardware lines back up

@@:
endif   ; NEC_98
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	@F			;  No
	test	cl,EnqReceived		;Did we receive Enq?
	jz	RecStr70		;  No
	and	cl,NOT EnqReceived
	jmp	short RecStr65

@@:
	test	cl,XOffSent		;Did we send XOFF?
	jz	RecStr70		;  No
	and	cl,NOT XOffSent 	;Remove XOFF sent flag

RecStr65:
	or	cl,XOnPending		;Show XON or ACK must be sent
ifdef   NEC_98
	mov	HSFlag[si],cl		;Store handshake flg ;[QN](ins92.10.19)
endif   ; NEC_98
	call	KickTx			;Kick xmit if needed

RecStr70:
	mov	HSFlag[si],cl		;Store handshake flag
        call DOSTI                             ;Can allow interrupts now
	pop	cx

RecStr80:
	mov	ax, cx
	or	sp,sp			;Reset PSW.Z
	pop	di
	pop	si
	ret

; No characters in the input queue.  Check to see if EOF
; was received, and return it if it was.  Otherwise show
; no characters.

RecStr90:
	test	[si.DCB_Flags],fBinary	;Are we doing binary stuff?
	jnz	RecStr95		;  Yes, show no characters
	mov	al,[si.DCB_EofChar]	;Assume EOF
	test	EFlags[si],fEOF 	;Has end of file char been received?
	jnz	RecStr80		;  Yes, show end of file

RecStr95:
	xor	ax,ax			;Show no more characters

; Return with 'Z' to show error or no characters

RecStr100:
	xor	cx,cx			;Set PSW.Z
	pop	di
	pop	si
	ret

$RECSTR endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDIMM - Send A Character Immediately
;
; This routine either sends a character to the port immediately,
; or places the character in a special location which is used by
; the next transmit interrupt to transmit the character prior to
; those in the normal transmit queue.
;
; For LPT ports, the character is always sent immediately.
;
; Entry:
;   AH = Device ID
;   AL = Character
; Returns:
;   AX = 0
; Error Returns:
;   AX = 8000H if Bad ID
;   AX = 4000H if couldn't send because another character
;        transmitted "immediately" is waiting to be sent
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;


   assumes ds,Data
   assumes es,nothing

   public   $SNDIMM
$SNDIMM proc   near

        push    si
        call    GetDEB                  ;Get pointer to the DEB
	jc	SendImm20		;Bad ID, return an error
	jns	SendImm10		;Its a COM port


;	For LPT ports, call DoLPT to do the dirty work.  If DoLPT
;       returns an error code, map it to 4000h.

	xor	ch,ch			;Show xmit character
	call	DoLPT			;Do the work here
        or      ax,ax                   ;Error occur?
	jz	SendImm20		;  No, show all is OK
	mov	ax,4000h		;  Yes, return 4000h
	jmp	short SendImm20

SendImm10:
	mov	dl, al
        mov     ax,4000h                ;In case we cannot send
        test    EFlags[si],fTxImmed     ;Another char waiting "immediately"?
	jnz	SendImm20		;  Yes, return error
	mov	ah,dl			;Set char for TXI
        call DOCLI                             ;TXI is critical section code
        call    TXI                     ;Set character to tx immediately
        call DOSTI
        xor     ax,ax                   ;Show all is OK

SendImm20:
        pop     si
        ret

$SNDIMM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDCOM - Send Byte To Port
;
; The given byte is sent to the passed port if possible.
; If the output queue is full, an error will be returned.
;
; Entry:
;   AH = Device ID
;   AL = Character
; Returns:
;   AX = 0
; Error Returns:
;   AX = error code
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $SNDCOM
$SNDCOM  proc  near

	push	si
	push	di
	call	GetDEB			;--> DEB
	jc	SendCom40		;Invalid ID
	jns	SendCom20		;Its a COM port

; Handle the transmission of a LPT character.  The ROM BIOS int 17
; call will be made to do the transmission.  The port address will
; be restored during the call, then zeroed out upon return.

SendCom10:
	xor	ch,ch			;Show xmit character
	call	DoLPT			;Do the work here
	jmp	short SendCom40 	;Return the status to caller

; Send a character to a COM port.  Return an error if control
; line timeout occurs or there is no room in the output queue.

SendCom20:
	push	ax			;Save character

	call	MSRWait 		;See if lines are correct for output
	pop	ax			;Restore char
	jnz	SendCom60		;Timeout occured, return error
	mov	cx,QOutSize[si] 	;See if queue is full
	cmp	cx,QOutCount[si]
	jle	SendCom50		;There is no room in the queue
	les	di,QOutAddr[si] 	;--> output queue
	assumes es,nothing

	mov	bx,QOutPut[si]		;Get index into queue
	mov	es:[bx][di],al		;Store the byte
	inc	bx			;Update index
	cmp	bx,cx			;Wrap time?
	jc	SendCom30		;  No
	xor	bx,bx			;Wrap-around is a new zero pointer

SendCom30:

        call DOCLI
	mov	QOutPut[si],bx		;Store updated pointer
	mov	ax,QOutCount[si]	; get the count
	inc	ax			; have the updated value in AX for test later
	mov	QOutCount[si],ax	;Update queue population
	call	KickTx			;Make sure xmit interrupt is armed
        call DOSTI

	xor	ax,ax			;Show no error (that we know of)

;****************************************************************************

SendCom40:
	pop	di
	pop	si
	ret

SendCom50:
	or	by ComErr+1[si],HIGH CE_TXFULL
	.errnz LOW CE_TXFULL

SendCom60:
	mov	ax,ComErr[si]		;Return error code to caller
	jmp	short SendCom40

$SNDCOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDCOMSTR - Send buffer To Port
;
; The given buffer is sent to the passed port if possible.
; Once the output queue is detected as being full, a CE_TXFULL error
; will be indicated and AX will be returned as the # of chars actually
; queued.
;
; Entry:
;   DS:SI --> DEB
;   ES:DI --> buffer
; Returns:
;   AX = # of bytes queued
; Registers Destroyed:
;   AX,BX,CX,DX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	$SNDCOMSTR
$SNDCOMSTR proc near

	push	cx			; save count
	call	GetDEB
	jc	cws_error		; jump if id invalid
	jns	cws_comm		; jump if COM port

	call	StringToLPT
	pop	cx			; discard saved count, ax = # transfered
	jmp	short cws_exit

cws_error:
	pop	ax
	sub	ax, cx			; ax = # transfered
cws_exit:
	ret

cws_comm:
	call	MSRWait 		;See if lines are correct for output
	pop	cx
	push	cx
	jnz	cws_error		;Timeout occured, return error

	mov	dx, QOutSize[si]	;See if queue is full
        sub     dx, QOutCount[si]       ; dx = # of chars free in queue
        jg      scs_loop
        jmp     scs_full                ;There is no room in the queue

scs_loop:
	push	cx			; save count left to send
	cmp	cx, dx			;Q: room for buffer in queue?
	jbe	@f			;   Y:
	mov	cx, dx			;   N: adjust size to send
@@:
	push	cx			; save # of chars which will be copied
	push	si
	push	ds
	push	di
	push	es
	les	bx,QOutAddr[si] 	;--> output queue
	assumes es,nothing

	mov	dx, QOutSize[si]
	mov	di, QOutPut[si] 	;Get index into queue
	sub	dx, di			; dx = # of free chars before end of queue
	cmp	dx, cx
	jbe	@f
	mov	dx, cx
@@:
	xchg	cx, dx			; cx = # of chars for 1st copy
	sub	dx, cx			; dx = # of chars for 2nd copy
	pop	ds
	pop	si			; ds:si -> src buffer
	assumes ds,nothing
	add	di, bx			; es:di -> current pos in queue
	cld
	rep	movsb			; copy first section
	mov	cx, dx
	jcxz	@F
	mov	di, bx			; circle back to start of queue
	rep	movsb			; copy 2nd section
@@:
	sub	di, bx			; di last index into queue
	mov	dx, di
	mov	di, si			; last location in src buffer
	mov	si, ds
	mov	es, si			; es:di -> last loc in src buf
	pop	ds
	pop	si			; ds:si -> ComDEB
	assumes ds,data
	pop	bx			; # of chars copied
        call DOCLI
	mov	QOutPut[si], dx 	;new index into queue
	add	QOutCount[si], bx
	call	KickTx
        call DOSTI
	pop	cx
	sub	cx, bx			; # of chars left to send
	jnz	scs_full_2		;  jump if none
scs_exit:
	pop	ax
	sub	ax, cx			; ax = # transfered
	ret

scs_full:
        call DOCLI
	call	KickTx
        call DOSTI
scs_full_2:
	or	by ComErr+1[si],HIGH CE_TXFULL
	.errnz LOW CE_TXFULL
	jmp	scs_exit

$SNDCOMSTR endp
page

;----------------------------Public Routine-----------------------------;
;
; $FLUSH - Flush The Input and Output Queues
;
; This is a hard initialization of the transmit and receive queue's,
; which immediately empties the given queue.
;
; LPT ports will just return the device error word
;
; Entry:
;   AH = Device ID
;   BH = Queue # to clear (0=Tx, 1=Rx)
; Returns:
;   AX = Device Error Word. (Not reset)
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $FLUSH
$FLUSH   proc   near

        push    si
        push    di
        call    GetDEB                  ;si --> DEB
        jc      Flush40                 ;Invalid ID
        js      Flush30                 ;LPT port, return any error

        mov     cx,QOutCount-QInCount   ;# of bytes to zero
        lea     di,QInCount[si]         ;--> receive queue data
        or      bh,bh                   ;Transmit queue?
        jnz     Flush10                 ;  No, input queue
        add     di,cx                   ;  Yes, --> xmit queue data

Flush10:
        cld
        push    ds
        pop     es
   assumes es,nothing

        xor     al,al
        call DOCLI                             ;Time to worry about critical sections
        rep     stosb
        call DOSTI
	.errnz	 QInGet-QInCount-2
	.errnz	 QInPut-QInGet-2
	.errnz	 QOutCount-QInPut-2
	.errnz	 QOutGet-QOutCount-2
	.errnz	 QOutPut-QOutGet-2

        or      bh,bh                   ;Rx queue?
        jz      Flush30                 ;  No, xmit queue


;       If the queue to be cleared is the receive queue, any
;       hardware handshake must be cleared to prevent a possible
;       deadlock situation.  Since we just zeroed the queue count,
;       a quick call to $RecCom should do wonders to clear any
;       receive handshake (i.e. send XON if needed).

Flush20:
	call   $RECCOM	     ;Take care of handshakes here

Flush30:
        mov     ax,ComErr[si]           ;And return the error word.

Flush40:
        pop     di
        pop     si
        ret

$FLUSH	 endp
page

;----------------------------Private-Routine----------------------------;
;
; TXI - Transmit A Character Immediately
;
; Set up a character to be transmitted "immediately".
; by placing the character in a location that guarantees
; it to be the next character transmitted.
;
; The check to see if the immediate character can be placed has
; already been made prior to entry.
;
; Interrupts must be disabled before entering this code
;
; Entry:
;   AH = Character
;   DS:SI --> DEB
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   L,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   TXI         ;Public for debugging
TXI   proc   near

;       call DOCLI                             ;Must be done by caller!
	or	EFlags[si],fTxImmed	;Show char to xmit
	mov	ImmedChar[si],ah	;Set character to transmit next
;	jmp	short KickTx		;Kick Xmit just in case
	errn$	KickTx

TXI   endp
page

;----------------------------Private-Routine----------------------------;
;
; KickTx - Kick Transmitter
;
; "Kick" the transmitter interrupt routine into operation.
; If the Transmitter Holding Register isn't empty, then
; nothing needs to be done.  If it is empty, then the xmit
; interrupt needs to enabled in the IER.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	 KickTx 			;Public for debugging
KickTx   proc   near

;       call DOCLI                             ;Done by caller
ifdef   NEC_98
	push	cx			;		;[QN]	(ins 92.09.24)
endif   ; NEC_98
	test	[si.VCDflags], 1	;Q: we still own port?
	jnz	can_we_steal		;   N:

enable_int:
ifdef   NEC_98
	cmp	[si.DCB_id],ID_Com1	;Is This Com1 ID ?	(ins 92.08.xx)|
	jne	KickTx5			;No, go to KickTx5	(ins 92.08.xx)|
	mov	dx,MaskFFPort[si]	;F/F Port Mask Bit	(ins 92.08.xx)|
	in	al,dx			;			(ins 92.08.xx)|
	mov	MaskFFShadow[si],al	;Save the Old Mask bit	(ins 92.08.xx)|
					;			(ins 92.08.xx)|
KickTx5:				;			(ins 92.08.xx)|
 	mov	al,MaskFFShadow[si] ;mask data(port C) save 	(ins 92.08.xx)|
 	test	al,MSK_TXR		;			(ins 93.06.18)|
 	jnz	KickTx10		;  Enable		(ins 92.08.xx)|

KickTx9:
 	or	al,MSK_TXR+MSK_RXR	;			(ins 93.06.18)|
 	mov	dx,MaskFFPort[si]	;Port address (Port C)	(ins 92.08.xx)|
	mov	MaskFFShadow[si],al	;Masking data save  	(ins 92.08.xx)|
	out	dx,al			;Masking set		(ins 92.08.xx)|
	pop	cx			;			(ins 92.09.24)|
        ret				;			(ins 92.08.xx)|

KickTx10:				;			(ins 92.08.xx)|
 	and	al,NOT(MSK_TXR+MSK_RXR)	;			(ins 93.06.18)
	mov	dx,MaskFFPort[si]	;Port address (Port C)	(ins 93.03.22)
	out	dx,al			;Masking set		(ins 93.03.22)
	NEWIODELAY 1			;<OUT 5F,AL>  		(ins 93.03.22)
	jmp	short KickTx9		;			(ins 93.03.22)
else    ; NEC_98
	mov	dx,Port[si]		;Get device I/O address
	add	dl,ACE_IER		;--> Interrupt enable register
	in	al,dx			;Get current IER state
	test	al,ACE_ETBEI		;Interrupt already enabled?
	jnz	KickTx10		;  Yes, don't reenable it
	or	al,ACE_ETBEI		;  No, enable it
	out	dx,al
	iodelay 			;8250, 8250-B bug requires
	out	dx,al			;  writting register twice

KickTx10:
;       call DOSTI                             ;Done by caller
	ret
endif   ; NEC_98

can_we_steal:
	call	StealPort		; call VCD to see if we can steal
					;     the port back
	jnc	short enable_int	; jump, if we got it
;
; flush out queue
;
	xor	ax, ax
	mov	[si.QOutCount], ax
	mov	[si.QOutMod], ax
	mov	ax, [si.QOutGet]
	mov	[si.QOutPut], ax
	jmp	short KickTx10		;   N:

KickTx   endp
page

;----------------------------Private-Routine----------------------------;
;
; MSRWait - Modem Status Register Wait
;
; This routine checks the modem status register for CTS, DSR,
; and/or RLSD signals.   If a timeout occurs while checking,
; the appropriate error code will be returned.
;
; This routine will not check for any signal with a corresponding
; time out value of 0 (ignore line).
;
; Entry:
;   SI --> DEB
; Returns:
;   AL = error code
;   ComErr[si] updated
;   'Z' set if no timeout
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   MSRWait	  ;Public for debugging

MSRWait proc   near

        push    di

MSRRestart:
        xor     di,di                   ;Init Timer

MSRWait10:
	mov	cx,11			;Init Delay counter (used on non-ATs)

MSRWait20:
ifdef   NEC_98
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.04.18)|
	jnz	@F			;Now, fifo mode		(ins 94.04.18)|
	call	MSR_READ_Call		;			(ins 92.08.xx)|
@@:					;			(ins 94.04.18)|
endif   ; NEC_98
        xor     dh,dh                   ;Init error accumulator
        mov     al,MSRShadow[si]        ;Get Modem Status
        and     al,MSRMask[si]          ;Only leave bits of interest
        xor     al,MSRMask[si]          ;0 = line high
	jz	MSRWait90		;All lines of interest are high
	mov	ah,al			;ah has 1 bits for down lines

        shl     ah,1                    ;Line Signal Detect low?
	jnc	MSRWait30		;  No, it's high
	.errnz	ACE_RLSD-10000000b
	cmp	di,[si.DCB_RlsTimeout]	;RLSD timeout yet?
	jb	MSRWait30		;  No
        or      dh,CE_RLSDTO            ;Show modem status timeout

MSRWait30:
	shl	ah,1			;Data Set Ready low?
	shl	ah,1
	.errnz	ACE_DSR-00100000b
	jnc	MSRWait40		;  No, it's high
	cmp	di,[si.DCB_DsrTimeout]	;DSR timeout yet?
	jb	MSRWait40		;  No
        or      dh,CE_DSRTO             ;Show data set ready timeout

MSRWait40:
	shl	ah,1			;CTS low?
	jnc	MSRWait50		;  No, it's high
	.errnz	ACE_CTS-00010000b
	cmp	di,[si.DCB_CtsTimeout]	;CTS timeout yet?
	jb	MSRWait50		;  No
        or      dh,CE_CTSTO             ;Show clear to send timeout

MSRWait50:
        or      dh,dh                   ;Any timeout occur?
	jnz	MSRWait80		;  Yes

ifndef  NEC_98
        cmp     [$MachineID],0FCh       ;Is this a PC-AT? [rkh debug for PS/2]
	je	MSRWait60		;  Yes, use ROM function
	loop	MSRWait20		;  No, continue until timeout
        jmp     short MSRWait70         ;Should have taken about a millisecond
endif   ; NEC_98

MSRWait60:
ifdef   NEC_98
	mov	cx,1						;(ins 92.08.xx)|
	call	MSR_DELAY	        			;(ins 92.08.xx)|
else    ; NEC_98
        push    bx                      ;Special SALMON ROM routine to delay
        push    di
        xor     cx,cx                   ;Number of Microseconds to delay
        mov     dx,1000                 ;  in CX:DX
        mov     ah,86h
        int     15h                     ;Wait 1 millisecond
        pop     di
        pop     bx
endif   ; NEC_98

MSRWait70:
        inc     di                      ;Timer +1
	jmp	short MSRWait10 	;Until Timeout or Good status

MSRWait80:
        xor     ah,ah
        mov     al,dh
        or      by ComErr[si],al        ;Return updated status
	.errnz	HIGH CE_CTSTO
	.errnz	HIGH CE_DSRTO
	.errnz	HIGH CE_RLSDTO

MSRWait90:
        or      al,al                   ;Set 'Z' if no timeout
        pop     di
        ret

MSRWait endp
page

;----------------------------Public Routine-----------------------------;
;
; $EVT - Set Event Mask
;
; Set up event word and mask.  Returns a pointer to a word in which
; certain bits, as enabled by the mask, will be set when certain
; events occur.
;
; Entry:
;   AH = Device ID
;   BX = Event enable mask
; Returns:
;   DX:AX --> event word.
; Error Returns:
;   AX = 0 if error
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $EVT
$EVT   proc   near

        push    si
        xor     dx,dx                   ;In case of error
        call    GetDEB                  ;Get pointer to DEB
        mov     ax,dx                   ;Finish setting error return value
        jc      Evt10                   ;Illegal id, return error
        js      Evt10                   ;LPTx, return error
        mov     EvtMask[si],bx          ;Save the new event mask
        lea     ax,EvtWord[si]          ;Get address of event word
        mov     dx,ds                   ;  into dx:ax

Evt10:
        pop     si
        ret

$EVT   endp
page

;----------------------------Public Routine-----------------------------;
;
; $EVTGET - Get Event Word
;
; Return and clear fields in the event word.  This routine MUST be used
; by applications to read the event word, as it is the ONLY way they
; can be assured that an event is not lost between reading the flags
; and resetting some.
;
; Entry:
;   AH = Device ID
;   BX = Event clear mask
; Returns:
;   AX = event word
; Error Returns:
;   None
; Registers Preserved:
;   AX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   BX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $EVTGET
$EVTGET proc   near

        push    si
        call    GetDEB
        mov     ah,0                    ;In case of error (AL already 0)
        jc      EvtGet10                ;Illegal ID
        js      EvtGet10                ;Illegal ID
        call DOCLI                             ;No interrupts allowed
        mov     ax,EvtWord[si]          ;Get the current event word
        not     bx                      ;Convert mask for our purposes
        and     bx,ax                   ;Clear events that user wants us to
        mov     EvtWord[si],bx          ;And save those results
        call DOSTI                             ;Magic over

EvtGet10:
        pop     si
        ret

$EVTGET endp
page

;----------------------------Public Routine-----------------------------;
;
; $STACOM - Return Status Information
;
; Returns the number of bytes in both queues.
;
; LPT ports will show both queues empty.
; and resetting some.
;
; Entry:
;   AH    = Device ID
;   ES:BX = Pointer to status structure to be updated.
;         = Null if not to update
; Returns:
;   AX = comm error word
;   Status Structure Updated.
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $STACOM
$STACOM proc   near

	push	si
	call	GetDEB			;Get DEB pointer in SI
	jc	StaCom30		;Invalid ID
	mov	cx,es			;Is the pointer NULL?
	or	cx,bx
	jz	StaCom25		;  Yes, just return error code
	xor	cx,cx
	xor	dx,dx
	or	ah,ah			;Set 'S' if LPT port
	mov	ax,cx			;For LPTs, everything is zero
	js	StaCom20		;LPT port
ifdef   NEC_98
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.04.16)|
	jnz	@F			;Now, fifo mode		(ins 94.04.16)|
	call	MSR_READ_Call		;			(ins 92.08.xx)|
	jmp	short MSR_READ_END	;AOBA-bug ins 94.11.19 KBNES
@@:					;			(ins 94.04.16)|
	call	AOBA_MSR_READ_Call	;AOBA-bug ins 94.11.19 KBNES
MSR_READ_END:				;AOBA-bug ins 94.11.19 KBNES
endif   ; NEC_98

; Need to get the status for a com port.  Since not all the
; status is contained within EFlags, it has to be assembled.
; Also note that currently there is no way to specify RLSD
; as a handshaking line, so fRLSDHold is always returned false.

	mov	al,MSRShadow[si]	;Get state of hardware lines
	and	al,OutHHSLines[si]	;Mask off required bits
	xor	al,OutHHSLines[si]	;1 = line low
	mov	cl,4			;Align bits
	shr	al,cl			;al = fCTSHold + fDSRHold
	.errnz	  ACE_CTS-00010000b
	.errnz	  ACE_DSR-00100000b
	.errnz	 fCTSHold-00000001b
	.errnz	 fDSRHold-00000010b

	mov	ah,HSFlag[si]		;Get fXOffHold+fXOffSent
	and	ah,XOffReceived+XOffSent
	or	al,ah

	.errnz	 XOffReceived-fXOFFHold
	.errnz	 XOffSent-fXOFFSent

	mov	ah,EFlags[si]		;Get fEOF+fTxImmed
	and	ah,fEOF+fTxImmed
	or	al,ah

	mov	cx,QInCount[si] 	;Get input queue count
	mov	dx,QOutCount[si]	;Get tx queue count

StaCom20:
	mov	es:[bx.COMS_BitMask1],al
	mov	es:[bx.COMS_cbInQue],cx
	mov	es:[bx.COMS_cbOutQue],dx

StaCom25:
	xor	ax,ax			;Return old com error
	xchg	ax,ComErr[si]		;  and clear it out

StaCom30:
	pop	si
	ret

$STACOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SetBrk - Set Break
;
; Clamp the Tx data line low.  Does not wait for the
; transmitter holding register and shift registers to empty.
;
; LPT ports will just return the comm error word
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $SETBRK
$SETBRK proc   near

ifdef   NEC_98
	push	bx			;(ins 92.08.xx)
	mov	bh,SEND_BREAK		;Save the Break commands bit(ins 92.08.xx)
endif   ; NEC_98
        mov     cx,0FF00h+ACE_SB        ;Will be setting break
        jmp     short ClrBrk10
	.errnz BreakSet-ACE_SB		;Must be same bits

$SETBRK endp
page

;----------------------------Public Routine-----------------------------;
;
; $CLRBRK - Clear Break
;
; Release any BREAK clamp on the Tx data line.
;
; LPT ports will just return the comm error word
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $CLRBRK
$CLRBRK proc near

ifdef   NEC_98
	push	bx			;(ins 92.08.xx)
	mov	bh,not SEND_BREAK	;Save the Break Reset command(ins 92.08.xx)
endif   ; NEC_98
	mov	cx,(NOT ACE_SB) SHL 8
	.errnz BreakSet-ACE_SB		;Must be same bits

ClrBrk10:
	push	si
	call	GetDEB			;Get DEB address
	jc	ClrBrk30		;Invalid ID
	js	ClrBrk20		;Ignored for LPT ports
        call DOCLI
	and	HSFlag[si],ch		;Set or clear the BreakSet bit
	or	HSFlag[si],cl

; ch = mask to remove bits in the Line Control Register
; cl = mask to turn bits on in the Line Control Register

ifdef   NEC_98
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.04.16)|
	jz	@F			;Now, 8251 mode		(ins 94.04.16)|
	call	Set8251modeFar		;Change to 8251 mode	(ins 94.04.16)|
@@:					;			(ins 94.04.16)|
	mov	dx,CommandPort[si]	;8251 Command Address	(ins 92.08.xx)|
	mov	al,CommandShadow[si]	;8251 Active CMD Byte	(ins 92.08.xx)|
	cmp	bh,SEND_BREAK		;Send Break ?		(ins 92.08.xx)|
	jne	ClrBrk15		;  No, Clear bit	(ins 92.08.xx)|
	or	al,bh			;Send break bit "set"	(ins 92.08.xx)|
	jmp	short ClrBrk17		;			(ins 92.08.xx)|
ClrBrk15:				;			(ins 92.08.xx)|
	and	al,bh			;Send break bit "reset"	(ins 92.08.xx)|
ClrBrk17:				;			(ins 92.08.xx)|
	out	dx,al			;New command out	(ins 92.08.xx)|
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.04.16)|
	jz	@F			;Now, 8251 mode		(ins 94.04.16)|
	call	SetFIFOmodeFar		;Change to FIFO mode	(ins 94.04.16)|
@@:					;			(ins 94.04.16)|
	FSTI				;			(ins 92.08.xx)|
					;			(ins 92.08.xx)|
ClrBrk20:				;			(ins 92.08.xx)|
        mov     ax,ComErr[si]           ;Return Status Word	(ins 92.08.xx)|
					;			(ins 92.08.xx)|
ClrBrk30:				;			(ins 92.08.xx)|
        pop     si			;			(ins 92.08.xx)|
	pop	bx			;			(ins 92.08.xx)|
        ret				;			(ins 92.08.xx)|
else    ; NEC_98
	mov	dx,Port[si]		;Get comm device base I/O port
	add	dl,ACE_LCR		;Point at the Line Control Regieter
	in	al,dx			;Get old line control value
	and	al,ch			;Turn off desired bits
	or	al,cl			;Turn on  desired bits
	iodelay
	out	dx,al			;Output New LCR.
        call DOSTI

ClrBrk20:
	mov	ax,ComErr[si]		;Return Status Word

ClrBrk30:
        pop     si
        ret
endif   ; NEC_98

$CLRBRK endp

page

;----------------------------Public Routine-----------------------------;
;
; $EXTCOM - Extended Comm Functions
;
; A number of extended functions are routed through this entry point.
;
; Functions currently implemented:
;
;   0: Ignored
;   1: SETXOFF - Exactly as if X-OFF character has been received.
;   2: SETXON  - Exactly as if X-ON character has been received.
;   3: SETRTS  - Set the RTS signal
;   4: CLRRTS  - Clear the RTS signal
;   5: SETDTR  - Set the DTR signal
;   6: CLRDTR  - Clear the DTR signal
;   7: RESET   - Yank on reset line if available (LPT devices)
;
; Entry:
;   AH = Device ID
;   BL = Function Code
;        (0-127 are MS-defined, 128-255 are OEM defined)
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;


;       Dispatch table for the extended functions

ExtTab  dw      ExtComDummy             ;Function 0: Never Mind
        dw      ExtCom_FN1              ;1: Set X-Off
        dw      ExtCom_FN2              ;2: Clear X-Off
        dw      ExtCom_FN3              ;3: Set RTS
        dw      ExtCom_FN4              ;4: Clear RTS
        dw      ExtCom_FN5              ;5: Set DSR
	dw	ExtCom_FN6		;6: Clear DSR
	dw	ExtCom_FN7		;7: Reset printer
	dw	ExtCom_FN8		;8: Get Max LPT Port
	dw	ExtCom_FN9		;9: Get Max COM Port
	dw	ExtCom_FN10		;10: Get COM Port Base & IRQ
	dw	ExtCom_FN10		;11: Get COM Port Base & IRQ
%OUT fix this for bld 32 -- GetBaseIRQ is now 10

   assumes ds,Data
   assumes es,nothing

   public   $EXTCOM
$EXTCOM proc   near

	push	si
	push	di
        call    GetDEB                  ;Get DEB pointer
        jc      ExtCom40                ;Invalid ID, return error
ifdef   NEC_98
	mov	dx,CommandPort[si]	;Command registor 	(ins 92.08.xx)
else    ; NEC_98
	mov	dx,Port[si]		; get port address
endif   ; NEC_98
        jns     ExtCom10                ;Its a COM port
        cmp     bl,7                    ;RESET extended function?
	jne	ExtCom30		;  No, return error word
        jmp     short ExtCom20          ;  Yes, invoke the function

ExtCom10:
	cmp	bl,11			;Last fcn supported
	ja	ExtCom30		;Not an implemented function.

ExtCom20:
        xor     bh,bh
        add     bx,bx                   ;Shift for the call
        call DOCLI                             ;Consider as critical sections
	call	ExtTab[bx]		;  and perform the function
        call DOSTI
	jc	ExtCom40		; jump if sub returns data in DX:AX

ExtCom30:
        mov     ax,ComErr[si]           ;Return standard error word
	xor	dx, dx

ExtCom40:
	pop	di
        pop     si

        ret

$EXTCOM endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN1 - Extended Function Set X-Off
;
; Analagous to receiving an X-OFF character.  Bufferred transmision of
; characters is halted until an X-ON character is received, or until
; we fake that with a Clear X-Off call.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN1
ExtCom_FN1   proc   near

        or      HSFlag[si],XOffReceived
ExtComDummy:
	clc
        ret

ExtCom_FN1   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN2 - Extended Function Clear X-Off
;
; Analagous to receiving an X-ON character. Buffered
; transmission of characters is restarted.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN2
ExtCom_FN2   proc   near

        and     HSFlag[si],NOT XOffReceived
	call	KickTx			;Kick transmitter interrupts on
	clc
	ret

ExtCom_FN2   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN3 - Extended Function Set RTS
;
; Set the RTS signal active.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN3
ExtCom_FN3   proc   near

ifdef   NEC_98
	mov	al,CommandShadow[si] 	;Old command byte load	(ins 92.08.22)|
	or	al,RTS			;=00100000B RTS bit "On"(ins 92.08.22)|
	mov	dx,CommandPort[si]	;Command registor 	(ins 92.08.22)|
	call	GoNakasu		;RTS set 		(ins 92.08.22)|
	mov	CommandShadow[si],al	;New command byte save	(ins 92.08.22)|
else    ; NEC_98
	add	dl,ACE_MCR		;Point at Modem Control Register
	in	al,dx			;Get current settings
	or	al,ACE_RTS		;Set RTS
	iodelay
	out	dx,al			;And update
endif   ;NEC_98
	clc
	ret

ExtCom_FN3   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN4 - Extended Function Clear RTS
;
; Set the RTS signal inactive.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN4
ExtCom_FN4   proc   near

ifdef   NEC_98
	mov	al,CommandShadow[si]	;Old command byte load	(ins 92.08.22)|
	and	al,not RTS		;=11011111B RTS bit"Off"(ins 92.08.22)|
	mov	dx,CommandPort[si]	;Command registor 	(ins 92.08.22)|
	call	GoNakasu		;Clear rts		(ins 92.08.22)|
	mov	CommandShadow[si],AL	;New command byte save	(ins 92.08.22)|
else    ; NEC_98
        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        and     al,NOT ACE_RTS          ;Clear RTS
	iodelay
	out	dx,al			;And update
endif   ; NEC_98
	clc
        ret

ExtCom_FN4   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN5 - Extended Function Set DTR
;
; Set the DTR signal active.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN5
ExtCom_FN5   proc   near

ifdef   NEC_98
	mov	al,CommandShadow[si]	;Old command byte load	(ins 92.08.xx)|
	or	al,DTR			;=00000010B DTR bit "On"(ins 92.08.xx)|
	mov	dx,CommandPort[si]	;Command registor 	(ins 92.08.xx)|
	call	GoNakasu		;set dtr		(ins 92.08.xx)|
	mov	CommandShadow[si],al	;New command byte save	(ins 92.08.xx)|
else    ; NEC_98
        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        or      al,ACE_DTR              ;Set DTR
	iodelay
	out	dx,al			;And update
endif   ; NEC_98
	clc
        ret

ExtCom_FN5   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN6 - Extended Function Clear DTR
;
; Set the DTR signal inactive.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN6
ExtCom_FN6   proc   near

ifdef   NEC_98
	mov	al,CommandShadow[si]	;Old command byte load	(ins 92.08.xx)|
	and	al,not DTR		;=11111101B DTR bit"Off"(ins 92.08.xx)|
	mov	dx,CommandPort[si]	;Command registor 	(ins 92.08.xx)|
	call	GoNakasu		;set DTR		(ins 92.08.xx)|
	mov	CommandShadow[si],al	;New command byte save	(ins 92.08.xx)|
else    ; NEC_98
        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        and     al,NOT ACE_DTR          ;Clear DTR
	iodelay
	out	dx,al			;And update
endif   ; NEC_98
	clc
        ret

ExtCom_FN6   endp

ifdef   NEC_98
GoNakasu proc near			;			(ins 94.05.19)|
	push	dx			;			(ins 94.05.19)|
	mov	dh,CommandShadow[si]	;			(ins 94.05.19)|
	mov	dl,al			;			(ins 94.05.19)|
	and	dx,2222h		;			(ins 94.05.19)|
	cmp	dh,dl			;			(ins 94.05.19)|
	pop	dx			;			(ins 94.05.19)|
	je	@f			;			(ins 94.05.19)|
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.05.19)|
	jz	HakataNoYatai		;Now, 8251 mode		(ins 94.05.19)|
	call	Set8251modeFar		;Change to 8251 mode	(ins 94.05.19)|
HakataNoYatai:				;			(ins 94.05.19)|
	out	dx,al			;			(ins 94.05.19)|
	test	[si.AOBA_flag],fFIFO_Mode ;			(ins 94.05.19)|
	jz	@F			;Now, 8251 mode		(ins 94.05.19)|
	call	SetFIFOmodeFar		;Change to FIFO mode	(ins 94.05.19)|
@@:					;			(ins 94.05.19)|
	ret				;			(ins 94.05.19)|
GoNakasu	endp			;			(ins 94.05.19)|
endif   ; NEC_98

page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN7 - Extended Function Reset Printer
;
; Assert the RESET line on an LPT port
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN7
ExtCom_FN7   proc   near

        call DOSTI                             ;Not called at interrupt time
        mov     ch,1                    ;ROM BIOS Reset Port
	call	DoLPT			;Perform the function
	clc
        ret

ExtCom_FN7   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN8 - Get Num Ports
;
; Entry:
; Returns:
;   AX = Max LPT port id
;   DX = 0
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN8
ExtCom_FN8   proc   near

	mov	ax, MAXLPT + LPTx
	xor	dx, dx
	stc
        ret

ExtCom_FN8   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN9  - Get Max COM Port
;
; Entry:
; Returns:
;   AX = Max COM port id
;   DX = 0
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN9
ExtCom_FN9    proc   near

	mov	ax, MAXCOM
	xor	dx, dx
	stc
        ret

ExtCom_FN9    endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN10 - Get COM Port Bas & IRQ
;
; Entry:
;   AH = com id
;   DS:SI -> DEB
; Returns:
;   AX = base
;   DX = irq
; Error Returns:
;   None
; Registers Preserved:
;   DS
; Registers Destroyed:
;   AX,BX,CX,DX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN10
ExtCom_FN10   proc   near

	call	FindCOMPort
	stc
	ret

ExtCom_FN10   endp
page

ifdef   NEC_98
include	delay.asm				;		(ins 92.08.xx)
TOMOE_PAT	DB	16 DUP('PATCH !!')	;PATCH AREA 	(ins 92.11.11)
endif   ; NEC_98

ifdef DEBUG
	public	RecCom40, RecCom50, RecCom60, RecCom70, RecCom80
	public	RecCom90, RecCom95, RecCom100
	public	SendImm10, SendImm20,
	public	SendCom10, SendCom20, SendCom30, SendCom40, SendCom50, SendCom60
	public	Flush10, Flush20, Flush30, Flush40
	public	KickTx10
	public	Evt10
	public	EvtGet10
	public	StaCom20, StaCom25, StaCom30
	public	ClrBrk10, ClrBrk20, ClrBrk30
	public	ExtCom10, ExtCom20, ExtCom30, ExtCom40, ExtComDummy
	public	MSRRestart, MSRWait10, MSRWait20, MSRWait30, MSRWait40
	public	MSRWait50, MSRWait60, MSRWait70, MSRWait80, MSRWait90
endif


DOSTI proc    near
      FSTI
      ret
DOSTI endp

DOCLI proc    near
      FCLI
      ret
DOCLI endp


sEnd    code
End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\bimodint.inc ===
;
; Include code from comm
;

include ..\comm\bimodint.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\ccom.asm ===
;
; Include code from comm
;

include ..\comm\ccom.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\comdev.h ===
;
; Include code from comm
;

include ..\comm\comdev.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\comdevi.h ===
;
; Include code from comm
;

include ..\comm\comdevi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\commmsg.asm ===
;
; Include code from comm
;

include ..\comm\commmsg.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\delay.asm ===
;#########################################################################
;##	cdk`x@[`					 	##
;##	@w[`iPj			##
;##									##
;##		botNbN				##
;##			uROFPOlgZ (PC-9801UV21)			##
;##			QWUFPQlgZ (PC-9801RX2)			##
;##			RWUFQOlgZ (PC-98RL N-MODE)		##
;##			mobFRRlgZ (PC-H98 Model70)		##
;##									##
;##	@Fs@ANbNOA	##
;##									##
;##	Fbw@ijB			##
;##	oF							##
;##	jWX^FbwAtO					##
;##									##
;##---------------------------------------------------------------------##
;##@@X								##
;##	DATE   |  Ver |							##
;##  --------------------------------------------------------------	##
;##    90-04-24 | 1.00 |	Original				##
;##									##
;#########################################################################

;----------------------	knno --------------------------------------
_V30_DELAY_	EQU	550			;uRO@
_286_DELAY_	EQU	1070			;QWU@
_386_DELAY_	EQU	1600			;RWU@
_DELAY_COUNT_	EQU	307			;mob
;--------------------------------------------------------------------------
;########################################################################
;#				f[^				#
;########################################################################
;;;;; _BIOS_FLAG1_	DB	0   ;[0:458H]e		(del 90.10.6)
;;;;; _BIOS_FLAG2_	DB	0   ;[0:480H]e		(del 90.10.6)
;;;;; _CPU_		DW	0   ;s@A_~[[v	(del 90.10.6)
;;;;; _TIME_		DW	0   ;W			(del 90.10.6)
;;;;; _MUKASI_	DW	0	    ;O		(del 90.10.6)

;************************************************************************
;*	^CX^pFgp_~[[v	*
;*			h^nJo[^CgpB	*
;*	A\`qshb|[gpB			*
;*		\F	RDQU@@				*
;*		lF	POUDW@				*
;*		AhXF	OOTb	gi[hj		*
;************************************************************************


_ARTIC_LOW_	EQU	005CH			;^CX^ph^n port

MSR_DELAY:
	PUSH	AX				;gpWX^
	PUSH	BX				;gpWX^
	PUSH	DX				;gpWX^
	push	es				;		(90.10.6)
	PUSH	DS				;f[^ZOgWX^
	push	ds				;		(90.10.6)
	pop	es				;		(90.10.6)

;************************************************************************
;*	bot						*
;*		|||||||ahnrek`fQ		*
;************************************************************************

	mov	ax, 40h			; 			
	mov	ds, ax			; 			

;----------------mobf------------------------------------

	MOV	AL,BYTE PTR DS:[58H]	    ;40:58eAL 
	MOV	BYTE PTR ES:_BIOS_FLAG1_,AL		

;----------------s@botf------------------------------
	MOV	AL,BYTE PTR DS:[80H]	    ;40:80eAL 
	MOV	BYTE PTR ES:_BIOS_FLAG2_,AL		

	MOV	AL,BYTE PTR DS:[5BH]	    ;40:5BeAL (93.03.09)
	MOV	BYTE PTR ES:_BIOS_FLAG3_,AL	;(93.03.09)

	POP	DS				;f[^ZOgWX^A
						
	AND	BYTE PTR _BIOS_FLAG1_,80H	;VrbgOO}XN
	JNZ	_NPC_				
	AND	BYTE PTR ES:_BIOS_FLAG3_,04H	;(93.03.09)
	JNZ	_NPC_				;(93.03.09)
						
	AND	BYTE PTR _BIOS_FLAG2_,03H	;0,1rbgO0}XN
	JZ	_V30_				;0,1rbg00uRO
						
	CMP	BYTE PTR _BIOS_FLAG2_,01H	;0,1rbg01QWU
	JE	_I286_				

;########################################################################
;#				s@				#
;########################################################################
						
_I386_:						;botRWU
	MOV	WORD PTR _CPU_,_386_DELAY_	;386CPU=_386_DELAY_
	JMP	short	_EXIT_CPU_			
						
_V30_:						;botuRO
	MOV	WORD PTR _CPU_,_V30_DELAY_	;V30CPU=_V30_DELAY_
	JMP	short	_EXIT_CPU_			
						
_I286_:						;botQWU
	MOV	WORD PTR _CPU_,_286_DELAY_	;286CPU=_286_DELAY_
						
_EXIT_CPU_:					
;---------------------------------------------- AP
;						
						;
	PUSH	CX				;JE^e
	MOV	CX,_CPU_			;bwQbotQ
;                  ~~~~l@
_LOOP2_:					;
	LOOP	_LOOP2_				;CX=CX-1 : IF ( CX == 0 ) GOTO _LOOP2_
	POP	CX				;JE^eA
						;
;----------------------------------------------		
						
	LOOP	_EXIT_CPU_			;CX=CX-1 : IF ( CX == 0 ) GOTO LOOP1

	pop	es
	POP	DX				;WX^A
	POP	BX				;WX^A
	POP	AX				;WX^A
						
	RET					;RETURN	
						
						
;########################################################################
;#				mob				#
;########################################################################
_NPC_:						
						
	CALL	_NPC_DELAY_			;P[`
						
	LOOP	_NPC_				;CX=CX-1 
;						: IF ( CX == 0 ) GOTO LOOP1

	pop	es				;(INS.91.1.14)
	POP	DX				;WX^A
	POP	BX				;WX^A
	POP	AX				;WX^A


	RET					
						
_NPC_DELAY_:					
	PUSH	CX				
						
	MOV	DX,_ARTIC_LOW_			;`qshb|[ge
						;cw
	IN	AX,DX				;`qshb|[g`w
						;f[^
	MOV	BX,AX				;
	MOV	CX,_DELAY_COUNT_		;bw
	ADD	CX,BX				;W
	MOV	_TIME_,CX			;Wb`jdi[
						
	JNC	_POPO_				
						
;******************************************************************************
;*	0			   7FFF					FFFF  *
;*	1========-----------------1-----------~======================1   *
;*		 	      		        	@                  *
;*@@@@@@WFb`jd         Faw@@F`w @  *
;*                                                                            *
;*                                                                            *
;*                                                                        *
;*                                                                            *
;******************************************************************************
	MOV	_MUKASI_,BX			;_MUKASI_

_YOMU1_:
	IN	AX,DX				;`w
	CMP	_MUKASI_,AX			;Or
						;@AW
						;@A
						;  O
						;@rB
						;@
						;@^CX^pO
						;@

	JA	_POPO_				;I
	
	MOV	_MUKASI_,AX			;O_MUKASI_
;						 
	JMP	_YOMU1_				;[v
;******************************************************************************
;*	0			   7FFF					FFFF  *
;*	1--------~================1=============---------------------1   *
;*		 	       		                            *
;*@@Faw@@@F`w@@@@WFb`jd            *
;*                                                                            *
;*                                                                            *
;*                                                                        *
;*                                                                            *
;******************************************************************************

_POPO_:
	IN	AX,DX				;`w
	CMP	_TIME_,AX			;WH
	JA	_POPO_				;mFW

	POP	CX
	RET					;END NPC_RTN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\ibmlpt.asm ===
page,132
ifdef   NEC_98
.286p
endif   ; NEC_98
;---------------------------Module-Header-------------------------------;
; Module Name: IBMLPT.ASM
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; General Description:
;
; History:
;
;-----------------------------------------------------------------------;

title	IBMLpt - IBM PC, PC-XT, PC-AT, PS/2 Parallel Communications Interface

.xlist
include cmacros.inc
include comdev.inc
include ins8250.inc
include ibmcom.inc
ifdef   NEC_98
include vint.inc
endif   ; NEC_98
.list

ifdef   NEC_98
sBegin	 Data				;			(ins 93.03.28)
	InitRetry         dw 0		;LPT Retry count	(ins 93.03.28)
	ModeFlag	  db 0		; = 0 KAN-I SENTRO	(ins 93.03.28)
					; = 1 SENTRO		(ins 93.03.28)
					;		     <ins:Toki:930923>
	CurPrinterMode db 0		;		     <ins:Toki:930923>
	OrgPrinterMode db 0		;		     <ins:Toki:931013>
					;		     <ins:Toki:930923>
	PC98_Mode  =	00000000b	;		     <ins:Toki:930923>
	Toki_Mode  =	00000001b	;		     <ins:Toki:930923>
	Org_Toki_ControlStatus db 0	;		     <ins:Toki:931027>
	Org_Toki_EX_Control    db 0	;  		     <ins:Toki:931027>
					;
	Org_Toki_ControlStatus540 db 0	;		     	(ins 931219)
	Org_Toki_EX_Control540    db 0	;  		     	(ins 931219)
					;			(ins 931219)
	Org_Toki_ControlStatusD40 db 0	;			(ins 931219)
	Org_Toki_EX_ControlD40    db 0	;  			(ins 931219)
					;			(ins 931219)
	InitCounter	db	0	;Lpt initialize counter <ins 931028>
					;			<ins 931028>
	   LptInit	= 00000001b	;	LPT Init OK !	<ins 931028>
	   ;RFU		= 00000010b	;			<ins 931028>
	   ;RFU		= 00000100b	;			<ins 931028>
	   ;RFU		= 00001000b	;			<ins 931028>
	   ;RFU		= 00010000b	;			<ins 931028>
	   ;RFU		= 00100000b	;			<ins 931028>
	   ;RFU		= 01000000b	;			<ins 931028>
	   ;RFU		= 10000000b	;			<ins 931028>
sEnd Data				;			(ins 93.03.28)
endif   ; NEC_98

sBegin Code
assumes cs,Code
assumes ds,Data

externFP GetSystemMsecCount

externA __0040H

ifdef   NEC_98
;-------------------------------------------------------------------------
;	Printer Status Bit for IBM-PC
;-------------------------------------------------------------------------
PS_NotBusy      equ     10000000b       ;Printer not busy
PS_Ack          equ     01000000b       ;Data acknowledged
PS_PaperOut     equ     00100000b       ;Out of paper
PS_Select       equ     00010000b       ;Device is selected
PS_IOError      equ     00001000b       ;IO error
PS_Timeout      equ     00000001b       ;Timeout occured
;-------------------------------------------------------------------------
;	Parameter for PC-9800
;-------------------------------------------------------------------------
PRNStrobFF_ON		=	0dh	; port_C Strob F/F on
PRNStrobFF_OFF		=	0ch	; port_C Strob F/F off
SystemPort		=	37h	; port_C I/O Address
PRN_Mode		=	46h	; Printer Mode
PRN_WSignal		=	46h	;
PRN_RSignal		=	42h	;

PRN_WRITE_DATA		equ	040h	;
PRN_READ_SIGNAL1	equ	042h	;
PRN_WRITE_SIGNAL1	equ	046h	;

PRN_PSTB_Active_X2 	equ	004h	;
PRN_PSTB_NonActive_X2	equ	005h	;

PRN_PSTB_Active_X1 	equ	00eh	;
PRN_PSTB_NonActive_X1	equ	00fh	;
endif   ; NEC_98

;----------------------------Private-Routine----------------------------;
;
; DoLPT - Do Function To LPT port
;
; The given function (output or reset) is performed to the
; passed LPT port.
;
; Before a character is sent, a check is made to see if the device
; will be able to accept the character.  If it can, then the character
; will be sent.  If not, then an error will be returned.  If the
; printer is selected and busy and no error, then the code returned
; will be CE_TXFULL and the handshake bits will be set in HSFlag
; to simulate that a handshake was received.
;
; If the BIOS ROM code is examined, you will note that they wait for
; the busy character from the last charcater to be cleared before
; they strobe in the current character.  This can take a long time
; on the standard EPSON class printer (1 mSec to greater than
; 300 mSec if the last character actually caused printing).
;
; Because of this, several status read retrys will be made before
; declaring that the device is actually busy.  If only one status
; read is performed, the spooler will yeild, take a while to get
; back here, and things will be really slow.  What difference does
; it really make if we or the BIOS does the delay, at least we can
; break out of it at some point when it seems hopeless.
;
;   The OKIHACK: Okidata reports a 50 ns. 2.2 volt pulse on the paper
;   out signal on the trailing edge of the Busy signal.  If we see this
;   glitch then we report paper out.  So we try to get the status twice...
;   if it changes between the two tries we keep getting the status.
;   
;
; Entry:
;   AH    =  cid
;   AL    =  character to output
;   CH	  =  Function request.	0 = Output, 1 = Initialize, 2 = Status
;   DS:SI -> DEB for the port
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

ifdef   NEC_98
	iodelay	macro			;		<ins:Toki:930923>
		out	5fh, al		;		<ins:Toki:930923>
	endm				;		<ins:Toki:930923>
endif   ; NEC_98

	public DoLPT
DoLPT   proc   near

ifdef   NEC_98
	cmp	wo [si.Port], 00h	;		     (ins 931219)
	jz	DoLPT98			;		<ins:Toki:930923>
	jmp	Toki_DoLpt		;		<ins:Toki:930923>
else    ; NEC_98
	mov	dx,Port[si]		;Get port address

;   DX = port address
;   CH = operation: 0 = write, 1 = init, 2 = status
;   AL = character

	or	ch, ch
	jz	LPT_OutChar
	cmp	ch, 1
	jz	LPT_Reset
	jmp	LPT_GetStatus
	ret

LPT_Reset:

	inc	dx
	inc	dx
	mov	al, L_RESET
	iodelay
	out	dx, al

	push	dx

	cCall	GetSystemMsecCount
	mov	bx, ax

LPT_ResetDelay:
	push	bx
	cCall	GetSystemMsecCount
	pop	bx
	sub	ax, bx
	cmp	ax, 300 		; 1/3 sec as good as any
	jbe	LPT_ResetDelay

	pop	dx

	mov	al, L_NORMAL
	iodelay
	iodelay
	out	dx, al
	dec	dx
	dec	dx
	jmp	LPT_GetStatus

LPT_OutChar:
	push	ax			; save character to be written

	; first check to see if printer is ready for us
	push	di

	push	dx
	call	GetSystemMSecCount
	mov	di, ax
	pop	dx

LPT_WaitReady:

	inc	dx			; point to status port
	iodelay
	in	al, dx			; get status bits
	and	al, L_BITS	      ; mask unused ones
	xor	al, L_BITS_INVERT     ; flip a couple
	xchg	al, ah

ifndef NOOKIHACK
	iodelay
	in	al, dx

	dec	dx

	and	al, L_BITS
	xor	al, L_BITS_INVERT
	cmp	al, ah			; did any bits change?
	jnz	LPT_WaitReady
else
	dec	dx
endif


	test	ah, PS_PaperOut or PS_IOError
	jnz	LPT_PrinterNotReady
	test	ah, PS_Select
	jz	LPT_PrinterNotReady
	test	ah, PS_NotBusy
	jnz	LPT_PrinterReady

	push	ax
	push	dx
	call	GetSystemMSecCount
	pop	dx
	pop	bx
	sub	ax, di
	cmp	ax, 300 	       ; 1/3 sec timeout

	jbe	LPT_WaitReady

;       The device seems to be selected and powered up, but is just
;       busy (some printers seem to show selected but busy when they
;       are taken offline).  Show that the transmit queue is full and
;       that the hold handshakes are set.  This is so the windows
;	spooler will retry (and do yields so that other apps may run).


	or	ComErr[si],CE_TXFULL	;Show queue full
	mov	ah,bh
	or	ah, L_TIMEOUT

LPT_PrinterNotReady:

	pop	di
	pop	cx			; throw away character
	jmp	short LPT_ReturnStatus

LPT_PrinterReady:
	pop	di			; get di back
	pop	ax			; get character back

	iodelay
	out	dx, al			; write character to port

	inc	dx			; access status port

LPT_Strobe:
	inc	dx			; control port
	mov	al, L_STROBE	      ; set strobe high
	iodelay
	iodelay
	iodelay
	iodelay
	out	dx, al			;   ...

	mov	al, L_NORMAL	      ;
	iodelay
	iodelay
	iodelay
	iodelay
	out	dx, al			; set strobe low

	sub	dx, 2			; point back to port base

	; FALL THRU

LPT_GetStatus:
	inc	dx			; point to status port
LPT_GS1:
	iodelay
	iodelay
	in	al, dx			; get status bits
	and	al, L_BITS	      ; mask unused ones
	xor	al, L_BITS_INVERT     ; flip a couple
	mov	ah, al

ifndef NOOKIHACK
	in	al, dx
	and	al, L_BITS
	xor	al, L_BITS_INVERT
	cmp	al, ah
	jnz	LPT_GS1 	; if they changed try again...
endif

LPT_ReturnStatus:

	assumes ds,Data
        and     ax,(PS_PaperOut+PS_Select+PS_IOError+PS_Timeout)*256
        shr     ah,1
        adc     ah,al                   ;Get back Timeout bit
        xor     ah,HIGH CE_DNS          ;Invert selected bit
   .errnz   LOW CE_DNS
        or      by ComErr+1[si],ah      ;Save comm error
        ret

   .errnz   CE_PTO-0200h
   .errnz   CE_IOE-0400h
   .errnz   CE_DNS-0800h
   .errnz   CE_OOP-1000h

DoLPT40:
	assumes ds,Data
        or      ComErr[si],CE_TXFULL    ;Show queue full
        ret
endif   ; NEC_98

DoLPT   endp
page

ifdef   NEC_98
	public DoLPT98
DoLPT98 proc   near
        push    di                      ;Need some extra space
        mov     di,[InitRetry]          ;Initialize retry count = 0
        mov     ah,ch                   ;Set function request
DoLPT10:
        or      ah,ah                   ;If reset
        jnz     DoLPT50                 ;  skip status pre-read

;-------------------------------------------------------------------------
;output data to printer
;-------------------------------------------------------------------------
        xchg    ax,cx                   ;CX = output data

DoLPT20:
;-------------------------------------------------------------------------
;	switch (AH) {
;	0: Output Data
;	1: Initialize Printer
;	2: Read Printer Status
;	}
;-------------------------------------------------------------------------
        mov     ah,2                      ;
	call	PrinterCall               ; read status

;-------------------------------------------------------------------------
;(91.1.7)  			       AH = (B)(A)(P)(S)|(F)(0)(0)(T)
;	   [IBM Printer Status]	 	     |  |  |  |   |	   |
;	 PS_NotBusy  = 10000000b ------------+  |  |  |   |        |
;	 PS_Ack      = 01000000b ---------------+  |  |   |        |
;	 PS_PaperOut = 00100000b ------------------+  |   |        |
;	 PS_Select   = 00010000b ---------------------+   |        |
;	 PS_IOError  = 00001000b -------------------------+        |
;	 PS_Timeout  = 00000001b ----------------------------------+
;-------------------------------------------------------------------------
        test    ah,PS_PaperOut+PS_IOError ;
        jnz     DoLPT60                 ;paper empty or I/O error
        test    ah,PS_Select
        jz      DoLPT60                 ;error if not select
        or      ah,ah
        js      DoLPT40                 ;output data if not busy

        dec     di
        jnz     DoLPT20                 ;until initialize retry count =0

DoLPT30:				;select & busy & retry count=0
        or      ComErr[si],CE_TXFULL    ;Show queue full
	or	ah, PS_Timeout		;Show timeout
	jmp	short DoLPT60		;  goto EVENT Create

DoLPT40:				;
        xchg    ax,cx                   ;AX = output data

DoLPT50:
;-------------------------------------------------------------------------
;	switch (AH) {
;	0: Output Data
;	1: Initialize Printer 
;	2: Read Printer Status
;	}
;-------------------------------------------------------------------------
	call	PrinterCall		;Let the BIOS do the work

;-------------------------------------------------------------------------
;(91.1.7)  			       AH = (B)(A)(P)(S)|(F)(0)(0)(T)
;	   [IBM Printer Status]	 	     |  |  |  |   |	   |
;	 PS_NotBusy  = 10000000b ------------+  |  |  |   |	   |
;	 PS_Ack      = 01000000b ---------------+  |  |   |	   |
;	 PS_PaperOut = 00100000b ------------------+  |   |	   |
;	 PS_Select   = 00010000b ---------------------+   |	   |
;	 PS_IOError  = 00001000b -------------------------+	   |
;	 PS_Timeout  = 00000001b ----------------------------------+
;-------------------------------------------------------------------------
DoLPT60:
	and     ax,(PS_PaperOut+PS_Select+PS_IOError+PS_Timeout)*256 ;	1.
	shr     ah,1				;			2.
	adc     ah,al                   	;Get back Timeout bit	3.
	shr     ah,1				;			4.
	adc     ah,al           		;Get back Timeout bit	5.
	shl	ah,1				;			6.
	xor     ah,HIGH CE_DNS          	;Invert selected bit	7.

	;-------------------------------------------------------------------
	; <<Explain of 1.2.3.4.5.6.7.>>	;	_ <AH>       <AL>
	;				;	BAPS|F00T  ????|????
	; 1.	and     ax,(PS_Pa..+..)*256 ;	00PS|F00T  0000|0000
	; 2.	shr     ah,1		;	000P|SF00  0000|0000  CY=(T)
	; 3.	adc     ah,al          	;	000P|SF0T  0000|0000
	; 4.	shr     ah,1		;	0000|PSF0  0000|0000  CY=(T)
	; 5.	adc     ah,al          	;	0000|PSFT  0000|0000
	; 6.	shl	ah, 1		;	000P|SFT0  0000|0000
	; 7.	xor     ah,HIGH CE_DNS	;	000P|SFT0  0000|0000
	;					   | |||
	;       CE_OOP equ 1000h ------------------+ |||
	;       CE_DNS equ 0800h --------------------+||
	;       CE_IOE equ 0400h ---------------------+|
	;	CE_PTO equ 0200h ----------------------+
	;-------------------------------------------------------------------
	test	ah, high(CE_TXFULL or CE_OOP or CE_DNS or CE_IOE )
	jz      DoLPT70                 	;No error occured
	or      by ComErr+1[si],ah      	;Save comm error
	test    by EvtMask+1[si],HIGH EV_PErr	;Printer error event request?
	jz      DoLPT70                 	;  No
	or      by EvtWord+1[si],HIGH EV_PErr	;  Yes, show event occured
	
DoLPT70:
	pop     di
	ret
DoLPT98   endp

page
;-----------------------------------------------------------------------
; Open LPT
;-----------------------------------------------------------------------
	public	INT_1AH_call
INT_1AH_call	proc	near

;-(931219)-----------------------------------------------------------------
;   Check H/W environment, and set correct I/O address to [si.Port].
;
;  +---------------------------------------+--------------------+
;  |				           |     [si.Port]      |
;  |            H/W environment            |--------------------|
;  |				           | LPT1 | LPT2 | LPT3 |
;  +---------------------------------------+--------------------+
;  |1|Standard Machine		           | 000h |  -1  |  -1  |
;  |2|Standard Machine+Ex board(LPT1/2)    | 540h | d40h |  -1  |
;  |3|		               (LPT2/3)    | 000h | 540h | d40h |
;  |4|TOKI on board			   | 140h |  -1  |  -1  |
;  |4|TOKI on board            (LPT1 KAN-I)| 000h |  -1  |  -1  |
;  |5|TOKI on board + Ex board	           | 140h | 540h | d40h |
;  |5|TOKI on board + Ex board (LPT1 KAN-I)| 000h | 540h | d40h |
;  +---------------------------------------+--------------------+
;		000h -> compatible H/W,  -1 -> no H/W
;
; [CurPrinterMode]
;	PC98_Mode =	00000000b -> Standard Machine, no Ex board
;	Toki_Mode =	00000001b -> TOKI on board
;	ExToki_12 =	00000010b -> Ex LPT=LPT1/2
;	ExToki_23 =	00000100b -> Ex LPT=LPT2/3
;	ExToki_Available = (ExToki_12 or ExToki_23) 
;
;   ENTER:  DS:SI -> ComDEB
;
; Toki_BasePort	        0140h	; Base I/O Address
; Toki_DataLatch        0140h	; Data Port
; Toki_PrinterStatus    0141h	; Status Port
; Toki_PrinterControls  0142h	; Control Port
; Toki_ControlStatus    0149h	; Control Status Port
; Toki_EX_Control       014eh	; Ex Control Port
;
; BIOS Common Area [0:458h] Full SENTRO if Bit1=1
; BIOS Common Area [0:5B3h] TOKI on board if Bit7=1

	cmp	by [si.DCB_Id], ID_LPT1 ;	LPT1 ?		(ins 931219)
	jne	LPT2_TokiSetup		;	@@N: NEXT	(ins 931219)
					;			(ins 931219)
	push	ds			;			<ins:Toki:931027>
	mov	ax, 40h			; BIOS Common Area	<ins:Toki:931027>
	mov	ds, ax			;			<ins:Toki:931027>
	test	by ds:[1b3h], 10000000b ; TOKI if bit7=1	<ins:Toki:931027>
	pop	ds			;
	mov	wo [si.Port], 140h	;		     	(ins 931219)
	jz	@f			;   N: NEXT		(ins 931219)
	jmp	LPT1_TokiSetup		;   Y: TOKI I/O		(ins 931219)
					; -> LPT1=TOKI on board (ins 931219)
@@:					;     			(ins 931219)
	mov dx, Toki_ControlStatus+400h ;			(ins 931219)
	in	al, dx			;		     	(ins 931219)
	cmp	al, 0ffh		; Is there Ex board ?  	(ins 931219)
	mov	wo [si.Port], 00h	;		     	(ins 931219)
	jne	@f			;   Y: NEXT		(ins 931219)
	jmp	PrePrinterCall		;   N: standard I/O	(ins 931219)
					; -> LPT1=KAN-I on board(ins 931219)
@@:					;			(ins 931219)
	mov	dx, 54fh		;			(ins 931219)
	in	al, dx			; 		     	(ins 931219)
	test	al, 00000100b		; Ex board = LPT1/2 ?	(ins 931219)
	mov	wo [si.Port], 00h	;		     	(ins 931219)
	jz	@f			;   Y: Ex board I/O	(ins 931219)
					; -> LPT1=CH1		(ins 931219)
	jmp	PrePrinterCall		;   N: Standard I/O	(ins 931219)
					; -> LPT1=KAN-I on board(ins 931219)
@@:					;      	  		(ins 931219)
	;-------------------------------------------------------------------
	;    Initialize Ex 1CH(Port 054xh)
	;-------------------------------------------------------------------
	mov	wo [si.Port], 540h	; 			(ins 931219)
Init_Port540h:				;		     	(ins 931219)
	mov	dx, Toki_ControlStatus+400h;			(ins 931219)
	in	al, dx			;			(ins 931219)
	mov [Org_Toki_ControlStatus540], al; Save Control Status(ins 931219)
	mov	dx, Toki_EX_Control+400h;			(ins 931219)
	in	al, dx			;			(ins 931219)
	mov [Org_Toki_EX_Control540], al; Save Ex Control	(ins 931219)
	mov dx, Toki_ControlStatus+400h	; AT Standard mode	(ins 931219)
	mov	al, 00010000b		; Normal Speed		(ins 931219)
	out	dx, al			;			(ins 931219)
	iodelay				;			(ins 931219)
	mov dx, Toki_EX_Control+400h	; AT Standard mode	(ins 931219)
	mov	al, 00010100b		; S/W Control		(ins 931219)
	out	dx, al			;			(ins 931219)
	iodelay				;			(ins 931219)
	mov dx,Toki_PrinterControls+400h; Select Printer	(ins 931219)
	mov	al, 00001100b		; nothing to initialize	(ins 931219)
	out	dx, al			;			(ins 931219)
	ret				;			(ins 931219)

LPT2_TokiSetup:
	cmp	by [si.DCB_Id], ID_LPT2 ; LPT2 ?		(ins 931219)
	jne	LPT3_TokiSetup		;	   N: NEXT	(ins 931219)
	mov dx, Toki_ControlStatus+400h ;			(ins 931219)
	in	al, dx			;		     	(ins 931219)
	cmp	al, 0ffh		; Is there Ex board ?	(ins 931219)
	mov	wo [si.Port], -1	; 			(ins 931219)
	jne	@f			;    Y: NEXT		(ins 931219)
	ret				;    N: Error		(ins 931219)
@@:					;			(ins 931219)
	mov	dx, 54fh		;			(ins 931219)
	in	al, dx			; 		     	(ins 931219)
	test	al, 00000100b		; Ex board=LPT2/3 ?	(ins 931219)
	mov	wo [si.Port], 540h	; 			(ins 931219)
	jnz	Init_Port540h		;    Y: Init CH1 Port	(ins 931219)
					;	  -> LPT2=CH1   (ins 931219)
					;    N: Init CH2 Port	(ins 931219)
					;	  -> LPT2=CH2   (ins 931219)
	;-------------------------------------------------------------------
	;    Initialize Ex 2CH(Port 0d4xh)
	;-------------------------------------------------------------------
	mov	wo [si.Port], 0d40h	; 			(ins 931219)
Init_PortD40h:				;		     	(ins 931219)
	mov	dx, Toki_ControlStatus+0c00h;			(ins 931219)
	in	al, dx			;			(ins 931219)
	mov [Org_Toki_ControlStatusD40], al; Save Control Status(ins 931219)
	mov	dx, Toki_EX_Control+0c00h;			(ins 931219)
	in	al, dx			;			(ins 931219)
	mov [Org_Toki_EX_ControlD40], al; Save Ex Control	(ins 931219)
	mov dx, Toki_ControlStatus+0c00h; AT Standard mode	(ins 931219)
	mov	al, 00010000b		; Normal Speed		(ins 931219)
	out	dx, al			;			(ins 931219)
	iodelay				;			(ins 931219)
	mov dx, Toki_EX_Control+0c00h	; AT Standard mode	(ins 931219)
	mov	al, 00010100b		; S/W Control		(ins 931219)
	out	dx, al			;			(ins 931219)
	iodelay				;			(ins 931219)
	mov dx,Toki_PrinterControls+0c00h; Select Printer	(ins 931219)
	mov	al, 00001100b		; nothing to initialize	(ins 931219)
	out	dx, al			;			(ins 931219)
	ret				;			(ins 931219)

LPT3_TokiSetup:
	mov dx, Toki_ControlStatus+0c00h;			(ins 931219)
	in	al, dx			;		     	(ins 931219)
	cmp	al, 0ffh		; Is there Ex board ?	(ins 931219)
	mov	wo [si.Port], -1	; 			(ins 931219)
	jne	@f			;    Y: NEXT
	ret				;    N: Error
@@:					;
	mov	dx, 54fh		;			(ins 931219)
	in	al, dx			; 		     	(ins 931219)
	test	al, 00000100b		; Ex board=LPT2/3 ?	(ins 931219)
	mov	wo [si.Port], 0d40h	; 			(ins 931219)
	jnz	Init_PortD40h		;    Y: Init CH2 Port	(ins 931219)
					;	  -> LPT3=CH2   (ins 931219)
	mov	wo [si.Port], -1	; 			(ins 931219)
	ret				;			(ins 931219)

LPT1_TokiSetup:				;		     	(ins 931219)
	;----------------------------------------------------------------
	; Save Status of TOKI
	;----------------------------------------------------------------
	mov	dx, Toki_ControlStatus	;			<ins:Toki:931027>
	in	al, dx			;			<ins:Toki:931027>
	mov [Org_Toki_ControlStatus], al; Save Control Status	<ins:Toki:931027>
	mov	dx, Toki_EX_Control	;			<ins:Toki:931027>
	in	al, dx			;			<ins:Toki:931027>
	mov [Org_Toki_EX_Control], al	; Save Ex Control	<ins:Toki:931027>

	;----------------------------------------------------------------
	; Set Full SENTRO for checking cable
	;----------------------------------------------------------------
	mov	dx, Toki_ControlStatus	; AT Standard mode	<ins:Toki:930923>
	mov	al, 00010000b		; Normal Speed		<ins:Toki:930923>
	out	dx, al			;			<ins:Toki:930923>
	iodelay				;			<ins:Toki:930923>
	mov	dx, Toki_EX_Control	; AT Standard mode	<ins:Toki:930923>
	mov	al, 00000000b		; S/W Control		<ins:Toki:930923>
	out	dx, al			;			<ins:Toki:930923>

	;----------------------------------------------------------------
	; Check cable
	;----------------------------------------------------------------
	mov  dx, Toki_PrinterControls 	;		<ins:Toki:931027>
	in	al, dx			; PrinterControls Read	(ins 940224)
	and	al, 11011111b		; Set DIR(=Foward)	(ins 940224)
	out	dx, al			; identification Sequence<ins:Toki:931027>
	mov	dx, Toki_DataLatch	;   of cable	<ins:Toki:931027>
	mov	al, 0			;		<ins:Toki:931027>
	out	dx, al			;		<ins:Toki:931027>
	mov	dx, Toki_PrinterStatus	;		<ins:Toki:931027>
	in	al, dx			;		<ins:Toki:931027>
	test	al, 00000010b ; SENTRO cable(PowON)?	<ins:Toki:931027>
	jnz	TokiFullInit		;  Y: Init as	<ins:Toki:931027>
					;    Full SENTRO<ins:Toki:931027>
	mov	dx, Toki_DataLatch	;  N: NEXT	<ins:Toki:931028>
	mov	al, 80h			;		<ins:Toki:931028>
	out	dx, al			;		<ins:Toki:931028>
	mov	dx, Toki_PrinterStatus	;		<ins:Toki:931028>
	in	al, dx			;		<ins:Toki:931028>
	test	al, 00000010b ; SENTRO cable(PowOFF)?	<ins:Toki:931028>
	jz	TokiFullInit 		;  Y: Init as	<ins:Toki:931028>
					;    Full SENTRO<ins:Toki:931028>
	;----------------------------------------------------------------
	; Initialize as KAN-I SENTRO
	;----------------------------------------------------------------
	mov	wo [si.Port], 0		;		     (ins 931219)
	mov	dx, Toki_ControlStatus	;		<ins:Toki:931027>
	mov	al, 0			;		<ins:Toki:931027>
	out	dx, al			;  N: KAN-I	<ins:Toki:931027>
	jmp  	short PrePrinterCall	;		<ins:94.05.26   >
					;		<ins:Toki:931013>
	;----------------------------------------------------------------
	; Initialize as Full SENTRO
	;----------------------------------------------------------------
TokiFullInit:				;		<ins:Toki:931013>
	or	[CurPrinterMode], Toki_Mode;		<ins:Toki:930923>
	mov	dx, Toki_ControlStatus	; AT Standard mode<ins:Toki:930923>
	mov	al, 00010000b		; Normal Speed	<ins:Toki:930923>
	out	dx, al			;		<ins:Toki:930923>
	iodelay				;		<ins:Toki:930923>
	mov	dx, Toki_EX_Control	; AT Standard mode<ins:Toki:930923>
	mov	al, 00000000b		; S/W Control	<ins:Toki:930923>
	out	dx, al			;		<ins:Toki:930923>
	iodelay				;		<ins:Toki:930923>
	mov	dx, Toki_PrinterControls; Select Printer<ins:Toki:930923>
	mov	al, 00001100b		; nothing to initialize	<ins:Toki:930923>
	out	dx, al			;		<ins:Toki:930923>
	ret				;		<ins:Toki:930923>
					;		<ins:Toki:930923>
INT_1AH_call	endp

;-----------------------------------------------------------------------
; Close LPT
;-----------------------------------------------------------------------
	public	INT_1AH_Close		;			<ins:Toki:931013>
INT_1AH_Close	proc	near		;			<ins:Toki:931013>
	cmp	wo[si.Port], 00h	;		     	(ins 931219)
	jnz	@f			;			<ins:Toki:931013>
	ret				;			<ins:Toki:931013>
@@:					;			<ins:Toki:931013>
	cmp	wo [si.Port], 140h	;			(ins 931219)
	jne	@f			;			(ins 931219)
	mov  al,[Org_Toki_ControlStatus];			<ins:Toki:931027>
	mov	dx, Toki_ControlStatus	;			<ins:Toki:931027>
	out	dx, al			; Restore Control Status<ins:Toki:931027>
	mov  al,[Org_Toki_EX_Control]	;			<ins:Toki:931027>
	mov	dx, Toki_EX_Control	;			<ins:Toki:931027>
	out	dx, al			; Restore Ex Control	<ins:Toki:931027>
	ret				;			<ins:Toki:931013>
@@:
	cmp	wo [si.Port], 540h	;			(ins 931219)
	jne	@f			;			(ins 931219)
	mov  al,[Org_Toki_ControlStatus540];			(ins 931219)
	mov	dx, Toki_ControlStatus+400h;			(ins 931219)
	out	dx, al			; Restore Control Status(ins 931219)
					;			(ins 931219)
	mov  al,[Org_Toki_EX_Control540];			(ins 931219)
	mov	dx, Toki_EX_Control+400h;			(ins 931219)
	out	dx, al			; Restore Ex Control	(ins 931219)
	ret				;			(ins 931219)
@@:					;			(ins 931219)
	mov  al,[Org_Toki_ControlStatusD40];			(ins 931219)
	mov	dx, Toki_ControlStatus+0c00h;			(ins 931219)
	out	dx, al			; Restore Control Status(ins 931219)
					;			(ins 931219)
	mov  al,[Org_Toki_EX_ControlD40];			(ins 931219)
	mov	dx, Toki_EX_Control+0c00h;			(ins 931219)
	out	dx, al			; Restore Ex Control	(ins 931219)
	ret				;			(ins 931219)
INT_1AH_Close	endp		;			<ins:Toki:931013>

	public	PrinterCall
PrePrinterCall	proc	near
	test  	[InitCounter],LptInit 	; LPT Init Finish ? XL  <ins 931028>
	jz	@f			; Yes: goto Return      <ins 931028>
	ret				;			<ins 931028>
@@:					;			<ins 931028>
	or    	[InitCounter],LptInit 	; LPT Init Flag "ON"    <ins 931028>
	mov   ah,1		      	; Printer Initialize	<ins 931028>

PrePrinterCall	endp

	public	PrinterCall

PrinterCall	proc	near
	push	bx
	push	cx
	push	dx

	or	ah,ah			; switch (AH) {
	jnz	@f			;
	call	LPT_OutPut		;	0: Output Data
	jmp	short End_INT1AH	;

@@:
	dec	ah			;
	jnz	@f			;
	call	LPT_Initialize		;	1: Initialize Printer
	jmp	short End_INT1AH	;

@@:
	dec	ah			;
	jnz	@f			;
	call	LPT_GetStatus		;	2: Read Printer Status

@@:
End_INT1AH:
	pop	dx
	pop	cx
	pop	bx
	ret
PrinterCall	endp

;---------------------------------------------------------------------------
;	Output Data to Printer
;---------------------------------------------------------------------------
	public	LPT_Output
LPT_OutPut	proc	near
	mov	dx,PRN_WRITE_DATA	;Set Printer Write Data Port
	out	dx,al			;Data out
	mov	dx,PRN_READ_SIGNAL1	;Set Printer Status Port

	in	al,dx			; Get Printer Status	(ins 93.03.23)
	test	al,(PS_NotBusy shr 5)	;  if (status != Busy)	(ins 93.03.23)
	jnz	INT1AH13		;  yes : goto INT1AH13	(ins 93.03.23)

INT1AH11:				;
	push	dx			;
	call	GetSystemMSecCount	; Get System Timer
	mov	di, ax			;	di = Tick Value	
	pop	dx			;
					;
INT1AH12:				;
	in	al,dx			; Get Printer Status
	test	al,(PS_NotBusy shr 5)	;  if (status != Busy)
	jnz	INT1AH13		;  yes : goto INT1AH13
					;
	push	dx			;
	call	GetSystemMSecCount	;
	pop	dx			;
	sub	ax, di			;
	cmp	ax, 300 	       	; 1/3 sec timeout
	jbe	INT1AH12		;
					;
	cmp	byte ptr [ModeFlag],0	;### (ins 93.03.31)
	jnz	INT1AH12_1		;
	or	al,061h
	and	al,065h	
INT1AH12_1:				;
	call	XlatStatus		;Locate bits 
	or	ah,PS_Timeout		;Show timeout
	and  ah,(PS_NotBusy+PS_Ack+PS_PaperOut+PS_Select+PS_IOError+PS_Timeout)
	ret
INT1AH13:
	cmp	byte ptr [ModeFlag],0	;### (ins 93.03.31)
	jnz	INT1AH13_X2		;
INT1AH13_X1:				;
	FCLI				;
	mov	dx,PRN_WRITE_SIGNAL1	;Set Printer Status Port
	mov	al,PRN_PSTB_Active_X1	;Strobe High
	out	dx,al

	NEWIODELAY 2			;<OUT 5F,AL>  	(ins 92.11.11)
	mov	al,PRN_PSTB_NonActive_X1 ;Strobe Low
	out	dx,al
	call	LPT_GetStatus
	ret

INT1AH13_X2:				;
	FCLI				;
	mov	dx,PRN_WRITE_SIGNAL1	;Set Printer Status Port
	mov	al,PRN_PSTB_Active_X2	;Strobe High
	out	dx,al

	NEWIODELAY 2			;<OUT 5F,AL>  	(ins 92.11.11)
	mov	al,PRN_PSTB_NonActive_X2;Strobe Low
	out	dx,al

	call	LPT_GetStatus
	ret
LPT_OutPut	endp

;---------------------------------------------------------------------------
;	Read Printer Status
;---------------------------------------------------------------------------
	public	LPT_GetStatus
LPT_GetStatus	proc	near
	FSTI

	mov	dx,PRN_READ_SIGNAL1	;
	in	al,dx			; Read Status

	cmp	byte ptr [ModeFlag],0	;(ins 93.03.31)####
	jnz	INT1AH22		;

	or	al,061h
	and	al,065h	

INT1AH22:				;
	jmp	short XlatStatus	;(ins 93.03.31)####
LPT_GetStatus	endp

;---------------------------------------------------------------------------
;	Locate Bits 
; 	   [ NES's Printer STATUS ]
;	(7)(6)(5)(4)(3)(2)(1)(0)   
;	 I  I  I  I  I  I     +-------------------- = 0: ACK 
;	 I  I  I  I  I  +-------------------------- = 0: BUSY
;	 I  I  I  I  +----------------------------- = 0: IBUSY
;	 I  I  I  +-------------------------------- = 0: DC5V
;	 I  I  +----------------------------------- = 0: PE
;	 I  +-------------------------------------- = 0: FAULT
;	 +----------------------------------------- = 0: SELECT
;
;	   [IBM Printer Status]
;       (B)(A)(P)(S)|(F)(0)(0)(T)
;	 |  |  |  |   |        +------------------- = 1: PS_Timeout
;	 |  |  |  |   +---------------------------- = 1: PS_IOError
;	 |  |  |  +-------------------------------- = 1: PS_Select
;	 |  |  +----------------------------------- = 1: PS_PaperOut
;	 |  +-------------------------------------- = 1: PS_Ack
;	 +----------------------------------------- = 1: PS_NotBusy
;
;---------------------------------------------------------------------------
	public	XlatStatus     			;
XlatStatus proc	near	   			;           <AH>      <AL>
	mov	ah,al	     			;	 ____ __ _
	and 	ah,11111101b 			;	 SFP5|IB0A
						;        ____ ___
	inc	ah	     			;	 SFP5|IBA?
						;         ___ ____
	shr	ah,1	     			;	 0SFP|5IBA
						;	 _ __ ____
	ror	ah,1	     			;	 A0SF|P5IB
						;	 __ _ ____
	ror	ah,1	     			;	 BA0S|FP5I
	and 	ah,(PS_NotBusy+PS_Ack+PS_Select+PS_IOError);
						;        __ _ _
						;	 BA0S|F000    _
	and	al,PS_PaperOut			;	 ____ _	    00P0|0000
	or	ah,al				;	 BAPS|F000
	xor	ah,(PS_Ack+PS_PaperOut+PS_Select+PS_IOError)
						;	 _
	ret					;	 BAPS|F000
XlatStatus	endp				;

;---------------------------------------------------------------------------
;	Initialize Printer Port
;---------------------------------------------------------------------------
	public	LPT_Initialize
LPT_Initialize	proc	near
;	Check Printer mode
;	[out]	ZF =0		= KAN-I SENTRO
;		ZF !=0		= Full SENTRO
	call	mode_check
	jnz	INT1AH42		;(ins 92.09.25)
	ret				;(ins 92.09.25)
INT1AH42:				;(ins 92.09.25)
	push	ax			;	[8255 mode set]
	push	cx			;		I
					;		I
	mov	al,PRNStrobFF_ON	;        ____	I = 0dh
	out	SystemPort,al		;        PSTB mask 'ON'
		NEWIODELAY 10		;<OUT 5F,AL>  	(ins 92.11.11)
	mov	al,0a2h			;		I
	out	PRN_Mode,al		;    mode set of SENTRO Interface
		NEWIODELAY 10		;<OUT 5F,AL>  	(ins 92.11.11)
	mov	al,05h			;		I     ____
	out	PRN_Mode,al		;    SENTRO Interface PSTB 'OFF'
		NEWIODELAY 10		;<OUT 5F,AL>  	(ins 92.11.11)
	mov	al,PRNStrobFF_OFF	;	 ____	I
	out	SystemPort,al		;	 PSTB mask 'OFF
		NEWIODELAY 10		;<OUT 5F,AL>  	(ins 92.11.11)
	xor	ax,ax			;		I
	out	PRN_WSignal,al		;      INPUTPRIME 'ON'	__________
					;		I		I
INT1AH45:				;		I		I
	mov	cx,0			;		I		I
	loop	$			;		I		I
	mov	al,1			;		I		I
	out	PRN_WSignal,al		;      INPUTPRIME 'OFF' ---------
	NEWIODELAY	10		;<OUT 5F,AL>  	(ins 92.11.11)
	mov	al,0ch			;		I
	out	PRN_WSignal,al		;  INTE Disable(Stop LPT Interrupt)
	mov	cx,0			;  	   ____	I
INT1AH47:				;	   BUSY Check
	in  	al,42h			;		I
	test 	al,(PS_NotBusy shr 5)	;		I
	loopz 	INT1AH47		;		I
;=======================================================================
	stc			;			  (ins 940115)
	push	di		;			  (ins 940115)
	push	dx		; We need to wait for	  (ins 940115)
	call GetSystemMSecCount	;   reset process	  (ins 940115)
	mov	di, ax		;   if reset by port on	  (ins 940115)
	pop	dx		;   PC-PR602R.		  (ins 940115)
@@:				; Then wait 1.5sec here.  (ins 940115)
	push	dx		;			  (ins 940115)
	call GetSystemMSecCount	;			  (ins 940115)
	pop	dx		;			  (ins 940115)
	sub	ax, di		;			  (ins 940115)
	cmp	ax, 1500 	;			  (ins 940115)
	jbe	@b		;			  (ins 940115)
	pop	di		;			  (ins 940115)
;=======================================================================
	pop	cx			;	     [ END ]
	pop	ax
INT1AH49:
	ret
LPT_Initialize endp

page
endif   ; NEC_98

CheckStatus proc    near
ifdef   NEC_98
	call	LPT_GetStatus		;(ins 93.03.31)####
	and	ah, L_BITS	      	;; #### 93.03.30 ####
	mov	al, ah			;; #### 92.10.11 ####
else    ; NEC_98
	in	al, dx			; get status bits
	mov	ah, al
	and	al, L_BITS	      ; mask unused ones
	xor	al, L_BITS_INVERT     ; flip a couple
	xchg	al, ah

ifndef NOOKIHACK
	iodelay
	in	al, dx

	and	al, L_BITS
	xor	al, L_BITS_INVERT
	cmp	al, ah			; did any bits change?
	jnz	CheckStatus
endif
endif   ; NEC_98
	test	ah, PS_PaperOut or PS_IOError
	jz	@F
	stc
	ret
@@:
	test	ah, PS_Select
	jnz	@F
	stc
	ret
@@:
	and	ah, PS_NotBusy
	clc
	ret

CheckStatus endp


;----------------------------Public Routine-----------------------------;
;
; StringToLPT - Send string To LPT Port
;
; Entry:
;   DS:SI -> DEB
;   ES:DI -> string to send
;   CX = # of bytes to send
; Returns:
;   AX = # of bytes actually sent
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

PUBLIC StringToLPT
StringToLPT proc    near

ifdef   NEC_98
	cmp	wo[si.Port], 00h;			     (ins 931219)
	jz	StringToLPT98		;		<ins:Toki:930923>
	jmp	Toki_StringToLPT	;		<ins:Toki:930923>
else    ; NEC_98
	mov	dx, Port[si]		; get port address
	inc	dx			; access status port

	push	cx			; save count for later
	push	ds
	mov	bx, __0040H
	mov	ds, bx

	cld

	call	CheckStatus		; quick status check before slowness
	jc	PrinterError
	jz	PrinterBusy		; if printer not ready for first char
					;   then just return with CE_TXFULL

CharacterToLPT:
;;	  mov	  bh, 10		  ; will wait 10 clock tics (~ 1/2 sec)
	mov	bh, 3			; will wait 3 clock tics (~ 1/6 sec)
l1:
	mov	bl, ds:[006Ch]		; low byte of tic counter
l2:
	call	CheckStatus		; quick status check before slowness
	jc	PrinterError
	jnz	LPT_PrinterRdy

	cmp	bl, ds:[006Ch]
	jz	l2			; tic count hasn't changed

	dec	bh
	jz	PrinterBusy		; out of tics, timeout
	jmp	short l1

LPT_PrinterRdy:
	mov	al, es:[di]
	inc	di

	dec	dx			; point to data port

	out	dx, al			; write character to port

	add	dx, 2			; access control port
	mov	al, L_STROBE		; set strobe high
	out	dx, al			;   ...

	mov	al, L_NORMAL		;
	iodelay
	iodelay
	out	dx, al			; set strobe low

	dec	dx			; point to status port for check

	loop	CharacterToLPT
	pop	ds
	jmp	short LPT_Exit

PrinterError:
	pop	ds
	jmp	short ReturnStatus

PrinterBusy:
	pop	ds
	or	ComErr[si],CE_TXFULL	; set buffer full bit
	or	al, L_TIMEOUT		; show timeout bit

ReturnStatus:
	and	ax,(PS_PaperOut+PS_Select+PS_IOError+PS_Timeout)
	xchg	al, ah
        shr     ah,1
        adc     ah,al                   ;Get back Timeout bit
	xor	ah,HIGH CE_DNS		;Invert selected bit
	.errnz	LOW CE_DNS
	or	by ComErr+1[si],ah	;Save comm error

LPT_Exit:
	pop	ax			; get total count
	sub	ax, cx			; subtract remaining unsent charts

	ret
endif   ; NEC_98

StringToLPT endp

ifdef   NEC_98
PUBLIC StringToLPT98
StringToLPT98 proc    near
	push	cx			; save count for 	(ins 92.09.28)
	push	ds			;			(ins 92.09.28)
	cld

CharacterToLPT:
	mov	dx, PRN_READ_SIGNAL1	;Set Status Port   (ins 93.03.31)####
	in	al, dx			;Get Status	   (ins 93.03.31)####
	test	al,(PS_NotBusy shr 5)	;  if ( != Busy)   (ins 93.03.31)####
	jnz	LPT_PrinterRdy		;  yes : OUT Port  (ins 93.03.31)####

	push	dx			;
	call	GetSystemMSecCount	; Get System Timer
	mov	bx, ax			;	ax = Tick Value
	pop	dx			;

CharToLPT1:
	push	bx
	call	CheckStatus		; quick status check 	(ins 92.08.xx)
	pop	bx
	jc	PrinterError		; ## 92.10.11 ##	(ins 92.08.xx)
	jnz	LPT_PrinterRdy		;			(ins 92.08.xx)

CharToLPT2:
	push	ax
	push	dx			;
	call	GetSystemMSecCount	;
	pop	dx			;
	sub	ax, bx			;
	cmp	ax, 1000 		; ## 92.10.11 ##     1 sec timeout
	pop	ax
	jbe	CharToLPT1		;
	jmp	short	PrinterBusy	;			(ins 92.08.xx)

LPT_PrinterRdy:
	mov	al, es:[di]
	inc	di
	push	ax			;			(ins 92.10.01)
	push	di			;			(ins 92.10.01)
	call	LPT_OutPut2		;data out		(ins 92.10.01)
	pop	di			;			(ins 92.10.01)
	pop	ax			;			(ins 92.10.01)
	loop	CharacterToLPT
	pop	ds
	jmp	short LPT_Exit

PrinterError:
	pop	ds
	jmp	short ReturnStatus

PrinterBusy:
	pop	ds
	or	ComErr[si],CE_TXFULL	; set buffer full bit
	or	al, L_TIMEOUT		; show timeout bit

ReturnStatus:
	and	ax,(PS_Select+PS_IOError+PS_Timeout)		;(ins 93.03.30)
	xchg	al, ah
	shr     ah,1
	adc     ah,al                   ;Get back Timeout bit
	xor	ah,HIGH CE_DNS		;Invert selected bit
	.errnz	LOW CE_DNS
	or	by ComErr+1[si],ah	;Save comm error

LPT_Exit:
	pop	ax			; get total count
	sub	ax, cx			; subtract remaining unsent charts
	ret
StringToLPT98 endp

;############ ins 93.03.28 #############
public	LPT_OutPut2			;		(ins 93.03.30) [QN]
LPT_OutPut2	proc	near		;		(ins 93.03.28) [QN]
	FCLI				;		(ins 93.03.28) [QN]
	mov	dx,PRN_WRITE_DATA	;Set Write Port	(ins 93.03.28) [QN]
	out	dx,al			;Data out	(ins 93.03.28) [QN]
	out	5fh, al			;		(ins 93.04.03) [QN]
	cmp	byte ptr [ModeFlag],0	;	####### (ins 93.03.31) [QN]
	jnz	LPT_OutPut2_X2		;		(ins 93.03.28) [QN]
					;		(ins 93.03.28) [QN]
LPT_OutPut2_X1:				;		(ins 93.03.28) [QN]
	mov	dx,PRN_WRITE_SIGNAL1	;		(ins 93.03.28) [QN]
	mov	al,PRN_PSTB_Active_X1	;Strobe High	(ins 93.03.28) [QN]
	out	dx,al			;		(ins 93.03.28) [QN]
	out	5fh, al			;		(ins 93.04.03) [QN]
	mov	al,PRN_PSTB_NonActive_X1;Strobe Low	(ins 93.03.28) [QN]
	out	dx,al			;		(ins 93.03.28) [QN]
	FSTI				;		(ins 93.03.28) [QN]
	ret				;		(ins 93.03.28) [QN]
					;		(ins 93.03.28) [QN]
LPT_OutPut2_X2:				;		(ins 93.03.28) [QN]
	mov	dx,PRN_WRITE_SIGNAL1	;		(ins 93.03.28) [QN]
	mov	al,PRN_PSTB_Active_X2	;Strobe High	(ins 93.03.28) [QN]
	out	dx,al			;		(ins 93.03.28) [QN]
	out	5fh, al			;		(ins 93.04.03) [QN]
	mov	al,PRN_PSTB_NonActive_X2;Strobe Low	(ins 93.03.28) [QN]
	out	dx,al			;		(ins 93.03.28) [QN]
	FSTI				;		(ins 93.03.28) [QN]
	ret				;		(ins 93.03.28) [QN]
LPT_OutPut2	endp			;		(ins 93.03.28) [QN]

;(ins 92.08.xx)
page
;-------------------------------------------------------
;	Check Printer Mode
;-------------------------------------------------------
;	[out]	ZF == 0		= KAN-I SENTRO
;		ZF != 0		= Full SENTRO
;-------------------------------------------------------
_X2_mode	equ	00000100b			;
_NPC_check	equ	10000000b			;

mode_check:						;
	mov	Byte ptr [ModeFlag],0			;(ins 93.03.28)
	push	ax					;
	push	ds					;
	mov	ax,40H					;
	mov	ds,ax					;
	test	by ds:[58H],_NPC_check			;
	pop	ds					;
	pop	ax					;
	jz	NH_check				;Standard Machine
;-------------------------------------
; Hiper 98
;-------------------------------------
	call	NH_check				;
	jnz	exit_mode_check				;Highreso for NPC
;------------------------------------
; Hiper 98 Normal Mode
;------------------------------------
	push	ax					;
	push	dx					;
	mov	dx,448h					;
;------------------------------------------------------
;Read data of Ex mode register from 448h
;bit0=1 : Full SENTRO,  bit0=0 : KAN-I SENTRO
;------------------------------------------------------
	in	al,dx					;
	test	al,1					;
	pop	dx					;
	pop	ax					;
	jz	exit_mode_check				;(ins 93.03.28)
	mov	Byte ptr [ModeFlag],1			;(ins 93.03.28)
							;(ins 93.03.28)
exit_mode_check:
	ret						;

;------------------------------------------------------- 
;	Check Machine architecture
;
;	[out]	ZF  =0	... Normal
;		ZF !=0	... Highreso
;------------------------------------------------------- 
bios_common	equ	501h				;
_X2_system	equ	00001000b			;
							;
NH_check:
	push	ax					;
	push	ds					;

;	40H:[101H] bit3 (_X2_system)
;	  =0 : Normal
;	  =1 : Highreso

	mov	ax,40H				;
	mov	ds,ax				;
	test	by ds:[101H],_X2_system		;

	pop	ds				;
	pop	ax				;

	jz	@f				;(ins 93.03.28)
	mov	Byte ptr [ModeFlag],1		;(ins 93.03.28)
@@:						;(ins 93.03.28)
	ret					;
						;
mode_check2:					;(ins 93.03.28)
	cmp	byte ptr [ModeFlag],0		;(ins 93.03.28)
	ret					;(ins 93.03.28)

page
;----------------------------Private-Routine----------------------------;
; Toki_DoLPT - Do Function To LPT port
;
; Entry:
;   AH    =  cid
;   AL    =  character to output
;   CH    =  Function request.  0 = Output, 1 = Initialize, 2 = Status
;   DS:SI -> DEB for the port
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;
        public Toki_DoLPT
Toki_DoLPT   proc   near

        mov     dx,Port[si]             ;Get port address

;   DX = port address
;   CH = operation: 0 = write, 1 = init, 2 = status
;   AL = character

        or      ch, ch
        jz      Toki_LPT_OutChar
        cmp     ch, 1
        jz      Toki_LPT_Reset
        jmp     Toki_LPT_GetStatus
        ret

Toki_LPT_Reset:

        inc     dx
        inc     dx
        mov     al, L_RESET
        iodelay
        out     dx, al

        push    dx

        cCall   GetSystemMsecCount
        mov     bx, ax

Toki_LPT_ResetDelay:
        push    bx
        cCall   GetSystemMsecCount
        pop     bx
        sub     ax, bx
        cmp     ax, 300                 ; 1/3 sec as good as any
        jbe     Toki_LPT_ResetDelay

        pop     dx

        mov     al, L_NORMAL
        iodelay
        iodelay
        out     dx, al
        dec     dx
        dec     dx
        jmp     short Toki_LPT_GetStatus

Toki_LPT_OutChar:
        push    ax                      ; save character to be written

        ; first check to see if printer is ready for us
        push    di

        push    dx
        call    GetSystemMSecCount
        mov     di, ax
        pop     dx

Toki_LPT_WaitReady:

        inc     dx                      ; point to status port
        iodelay
        in      al, dx                  ; get status bits
        and     al, L_BITS            ; mask unused ones
        xor     al, L_BITS_INVERT     ; flip a couple
        xchg    al, ah

ifndef NOOKIHACK
        iodelay
        in      al, dx

        dec     dx

        and     al, L_BITS
        xor     al, L_BITS_INVERT
        cmp     al, ah                  ; did any bits change?
        jnz     Toki_LPT_WaitReady
else
        dec     dx
endif

        test    ah, PS_PaperOut or PS_IOError
        jnz     Toki_LPT_PrinterNotReady
        test    ah, PS_Select
        jz      Toki_LPT_PrinterNotReady
        test    ah, PS_NotBusy
        jnz     Toki_LPT_PrinterReady

        push    ax
        push    dx
        call    GetSystemMSecCount
        pop     dx
        pop     bx
        sub     ax, di
        cmp     ax, 300                ; 1/3 sec timeout

        jbe     Toki_LPT_WaitReady

;       The device seems to be selected and powered up, but is just
;       busy (some printers seem to show selected but busy when they
;       are taken offline).  Show that the transmit queue is full and
;       that the hold handshakes are set.  This is so the windows
;       spooler will retry (and do yields so that other apps may run).

        or      ComErr[si],CE_TXFULL    ;Show queue full
        mov     ah,bh
        or      ah, L_TIMEOUT

Toki_LPT_PrinterNotReady:
        pop     di
        pop     cx                      ; throw away character
        jmp     short Toki_LPT_ReturnStatus

Toki_LPT_PrinterReady:
        pop     di                      ; get di back
        pop     ax                      ; get character back

        iodelay
        out     dx, al                  ; write character to port

        inc     dx                      ; access status port

Toki_LPT_Strobe:
        inc     dx                      ; control port
        mov     al, L_STROBE          ; set strobe high
        iodelay
        out     dx, al                  ;   ...
        mov     al, L_NORMAL          ;
        out     dx, al                  ; set strobe low
        sub     dx, 2                   ; point back to port base

        ; FALL THRU

Toki_LPT_GetStatus:
        inc     dx                      ; point to status port

Toki_LPT_GS1:
        iodelay
        iodelay
        in      al, dx                  ; get status bits
        and     al, L_BITS            ; mask unused ones
        xor     al, L_BITS_INVERT     ; flip a couple
        mov     ah, al

ifndef NOOKIHACK
        in      al, dx
        and     al, L_BITS
        xor     al, L_BITS_INVERT
        cmp     al, ah
        jnz     Toki_LPT_GS1         ; if they changed try again...
endif

Toki_LPT_ReturnStatus:
        assumes ds,Data
        and ax,(            PS_Select+PS_IOError+PS_Timeout)*256 ; (ins 940125)
        shr     ah,1
        adc     ah,al                   ;Get back Timeout bit
        xor     ah,HIGH CE_DNS          ;Invert selected bit
   .errnz   LOW CE_DNS
        or      by ComErr+1[si],ah      ;Save comm error
        ret

   .errnz   CE_PTO-0200h
   .errnz   CE_IOE-0400h
   .errnz   CE_DNS-0800h
   .errnz   CE_OOP-1000h

Toki_DoLPT40:
        assumes ds,Data
        or      ComErr[si],CE_TXFULL    ;Show queue full
        ret
Toki_DoLPT   endp
page

Toki_CheckStatus proc    near
        in      al, dx                  ; get status bits
	test	al, PS_PaperOut		; paper empty ?		(ins 94.08.09)
	jz	@f			;  N: Next		(ins 94.08.09)
	and	al, not PS_IOError	;  Y: Show I/O error	(ins 94.08.09)
@@:					;			(ins 94.08.09)
        mov     ah, al
        and     al, L_BITS            ; mask unused ones
        xor     al, L_BITS_INVERT     ; flip a couple
        xchg    al, ah

ifndef NOOKIHACK
        iodelay
        in      al, dx
	test	al, PS_PaperOut		; paper empty ?		(ins 94.08.09)
	jz	@f			;  N: Next		(ins 94.08.09)
	and	al, not PS_IOError	;  Y: Show I/O error	(ins 94.08.09)
@@:					;			(ins 94.08.09)
        and     al, L_BITS
        xor     al, L_BITS_INVERT
        cmp     al, ah                  ; did any bits change?
        jnz     Toki_CheckStatus
endif

        test    ah, PS_PaperOut or PS_IOError
        jz      @F
        stc
        ret
@@:
        test    ah, PS_Select
        jnz     @F
        stc
        ret
@@:
        and     ah, PS_NotBusy
        clc
        ret
Toki_CheckStatus endp

;----------------------------Public Routine-----------------------------;
; Toki_StringToLPT - Send string To LPT Port
;
; Entry:
;   DS:SI -> DEB
;   ES:DI -> string to send
;   CX = # of bytes to send
; Returns:
;   AX = # of bytes actually sent
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;
PUBLIC Toki_StringToLPT
Toki_StringToLPT proc    near
        mov     dx, Port[si]           ; get port address <del:Toki:930923>
	inc     dx                      ; access status port

        push    cx                      ; save count for later
        push    ds

        cld

        call    Toki_CheckStatus        ; quick status check before slowness
        jc      Toki_PrinterError
        jz      Toki_PrinterBusy        ; if printer not ready for first char
                                        ;   then just return with CE_TXFULL

Toki_CharacterToLPT:
	push	dx		   ;			<inc:Toki:930923>
	call	GetSystemMSecCount ; Get System Timer	<inc:Toki:930923>
	mov	bx, ax		   ;	ax = Tick Value	<inc:Toki:930923>
	pop	dx		   ;			<inc:Toki:930923>
				   ;			<inc:Toki:930923>
Toki_CharToLPT1:		   ;			<inc:Toki:930923>
	push	bx		   ;			<inc:Toki:930923>
	call	Toki_CheckStatus   ; quick status check	<inc:Toki:930923>
	pop	bx		   ;			<inc:Toki:930923>
	jc	Toki_PrinterError  ; 			<inc:Toki:930923>
	jnz	Toki_LPT_PrinterRdy;			<inc:Toki:930923>
				   ;			<inc:Toki:930923>
Toki_CharToLPT2:		   ;			<inc:Toki:930923>
	push	ax		   ;			<inc:Toki:930923>
	push	dx		   ;			<inc:Toki:930923>
	call	GetSystemMSecCount ;			<inc:Toki:930923>
	pop	dx		   ;			<inc:Toki:930923>
	sub	ax, bx		   ;			<inc:Toki:930923>
	cmp	ax, 1000 	   ; 1 sec timeout	<inc:Toki:930923>
	pop	ax		   ; 			<inc:Toki:930923>
	jbe	Toki_CharToLPT1	   ; 			<inc:Toki:930923>
	jmp	short Toki_PrinterBusy  ; 		<inc:Toki:930923>
				   ;			<inc:Toki:930923>
Toki_LPT_PrinterRdy:
        mov     al, es:[di]
        inc     di

        dec     dx                      ; point to data port

        out     dx, al                  ; write character to port

        add     dx, 2                   ; access control port
        mov     al, L_STROBE            ; set strobe high
        out     dx, al                  ;   ...

        mov     al, L_NORMAL            ;
        out     dx, al                  ; set strobe low

        dec     dx                      ; point to status port for check

        loop    Toki_CharacterToLPT
        pop     ds
        jmp     short Toki_LPT_Exit

Toki_PrinterError:
        pop     ds
        jmp     short Toki_ReturnStatus

Toki_PrinterBusy:
        pop     ds
        or      ComErr[si],CE_TXFULL    ; set buffer full bit
        or      al, L_TIMEOUT           ; show timeout bit

Toki_ReturnStatus:
	and  ax,(            PS_Select+PS_IOError+PS_Timeout) ; (ins 940125)
        xchg    al, ah
        shr     ah,1
        adc     ah,al                   ;Get back Timeout bit
        xor     ah,HIGH CE_DNS          ;Invert selected bit
        .errnz  LOW CE_DNS
        or      by ComErr+1[si],ah      ;Save comm error

Toki_LPT_Exit:
        pop     ax                      ; get total count
        sub     ax, cx                  ; subtract remaining unsent charts
        ret
Toki_StringToLPT endp

TOMOE_PAT	DB	16 DUP('PATCH !!')	;PATCH AREA (ins 92.11.11)
endif   ; NEC_98

IFDEF DEBUG		;Publics for debugging
ifdef   NEC_98
    public  Toki_LPT_Reset
    public  Toki_LPT_Outchar
    public  Toki_LPT_Strobe
    public  Toki_LPT_GetStatus
    public  Toki_DoLPT40
else    ; NEC_98
    public  LPT_Reset
    public  LPT_Outchar
    public  LPT_Strobe
    public  LPT_GetStatus
    public  DoLPT40
endif   ; NEC_98
ENDIF

sEnd    code
End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\ibmcom1.asm ===
;
; Include code from comm
;

include ..\comm\ibmcom1.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\ibmint.asm ===
page,132
;---------------------------Module-Header-------------------------------
; Module Name: IBMINT.ASM
;
; Created: Fri 06-Feb-1987 10:45:12
; Author:  Walt Moore [waltm]
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved
;
; General Description:
;   This file contains the interrupt time routines for the
;   IBM Windows communications driver.
;
;   The interrupt code is preloaded and fixed.
;
; History:
;
; **********************************************************************
;    Tue Dec 19 1989 09:35:15	-by-  Amit Chatterjee  [amitc]
; ----------------------------------------------------------------------
;    Added a far entry point 'FakeCOMIntFar' so that the routine 'FakeCOMInt'
; could be called from the 'InitAPort' routine in IBMCOM.ASM
;
;   26.Nov.90	richp
;
;   Changed interrupt routines to use new VPICD services for bi-modal/multi-
;   modal interrupt handling.  They now work in straight real mode for real
;   mode Windows, but can also handle interrupts in real mode or protected
;   mode for standard mode Windows, and handle interrupts in RING 0 protected
;   mode for enhanced mode Windows, even when the Windows VM is not currently
;   executing.
;
;   sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;           FCLI/FSTI macros
;-----------------------------------------------------------------------;

subttl  Communications Hardware Interrupt Service Routines

.xlist
include cmacros.inc
include comdev.inc
include ibmcom.inc
include ins8250.inc
include BIMODINT.INC
include vint.inc
.list

externFP GetSystemMsecCount

externW  COMptrs
externW  activeCOMs

externD  lpPostMessage

ifdef   NEC_98
externFP Comm1				;(ins 92.09.25)
externFP Comm2				;(ins 92.09.25)
externFP Comm3				;(ins 92.09.25)
externFP SetFIFOmodeFar			;(ins 94.04.18)
externFP Set8251modeFar			;(ins 94.04.18)
externW  Port_TBL			;(ins 92.08.24)
externW  Port_EOI			;(ins 92.08.24)
externB  Vect_TBL			;(ins 92.08.24)
externB  Mask_TBL			;(ins 92.08.24)
externW  RECLoopCounter			;(ins 93.03.31)

BIOS_FLAG5	equ	58h		; ins 93.03.24 (IOrecovery)
BIOS_FLAG7	equ	5bh		; ins 93.03.24 (IOrecovery)
endif   ; NEC_98

sBegin Data

PUBLIC IRQhooks
IRQhooks    label byte
DefineIRQhook MACRO num
IFDEF No_DOSX_Bimodal_Services
IRQhook&num IRQ_Hook_Struc <,,,,IntCodeOFFSET DEF_COM_INT_&num,,,, \
			    IntCodeOFFSET DEF_RM_COM_INT_&num>
ELSE
IRQhook&num IRQ_Hook_Struc <,,,,IntCodeOFFSET DEF_COM_INT_&num>
ENDIF
ENDM
??portnum = 1
REPT MAXCOM+1
	DefineIRQhook %??portnum
??portnum = ??portnum+1
ENDM

PURGE DefineIRQhook

EXTRN VCD_int_callback:fword

ifdef   NEC_98
TicCount	  dw 0		       ;Timeout counter (ins 92.09.25)
endif   ; NEC_98

sEnd data

createSeg _INTERRUPT,IntCode,word,public,CODE
sBegin IntCode
assumes cs,IntCode

page

IFDEF No_DOSX_Bimodal_Services
public RM_IntDataSeg
RM_IntDataSeg	dw 0
  ; this variable is written into by a routine in inicom
  ; if the 286 DOS extender is present.  This variable
  ; contains the SEGMENT value of the data selector "_DATA"
  ; so that the real mode interrupt handler may use the
  ; data segment, and not it's selector !

PUBLIC	RM_CallBack
RM_CallBack	dd  0
ENDIF


Control proc far
	ret
Control endp


IFDEF No_DOSX_Bimodal_Services
DEF_RM_Handler proc far
	push	es
	push	di
	push	ax
	mov	es, cs:[RM_IntDataSeg]
	mov	di, es:[di.First_DEB]	    ; ES:DI -> ComDEB
	add	di, SIZE ComDEB 	    ; ES:DI -> BIS
	mov	es:[di.BIS_Mode], 4
	push	cs
	call	NEAR PTR COMHandler
	mov	es:[di.BIS_Mode], 0
	pop	ax
	pop	di			    ; ES:DI -> IRQ_Hook_Struc
	jc	short DEF_RM_chain
	pop	es
	pop	di
	add	sp, 4
	iret

DEF_RM_chain:
        call DOCLI
	push	bp
	mov	bp, sp			    ;stack frame:
					    ;	bp+8	-> OldInt CS
					    ;	bp+6	-> OldInt IP
					    ;	bp+4	-> di
					    ;	bp+2	-> es
					    ;	bp+0	-> bp
	les	di, es:[di.RM_OldIntVec]
	mov	[bp+6], di
	mov	[bp+8], es
	pop	bp
	pop	es
	pop	di
	ret				    ; far ret to OldInt handler
DEF_RM_Handler endp
ENDIF	;No_DOSX_Bimodal_Services


Define_DEF_COM_INT MACRO num
IFDEF No_DOSX_Bimodal_Services
PUBLIC DEF_RM_COM_INT_&num
DEF_RM_COM_INT_&num proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook&num
        jmp     DEF_RM_Handler
DEF_RM_COM_INT_&num endp
ENDIF
PUBLIC DEF_COM_INT_&num
DEF_COM_INT_&num proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook&num
ifdef   NEC_98
        jmp     DEF_COM_DUMMY
else    ; NEC_98
        jmp     DEF_Handler
endif   ; NEC_98
DEF_COM_INT_&num endp
ENDM

??portnum = 2
REPT MAXCOM
	Define_DEF_COM_INT %??portnum
??portnum = ??portnum+1
ENDM

PURGE Define_DEF_COM_INT

ifdef   NEC_98
DEF_COM_DUMMY:
        jmp     short DEF_Handler
endif   ; NEC_98

IFDEF No_DOSX_Bimodal_Services
PUBLIC DEF_RM_COM_INT_1
DEF_RM_COM_INT_1 proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook1
        jmp     DEF_RM_Handler
DEF_RM_COM_INT_1 endp
ENDIF

PUBLIC DEF_COM_INT_1
DEF_COM_INT_1 proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook1
IF2
.errnz $ - OFFSET DEF_Handler
ENDIF
DEF_COM_INT_1 endp

DEF_Handler proc far
	push	es
	push	di
	push	ax
	mov	ax, _DATA
	mov	es, ax
	mov	di, es:[di.First_DEB]	    ; ES:DI -> ComDEB
	add	di, SIZE ComDEB 	    ; ES:DI -> BIS
	push	cs
	call	NEAR PTR COMHandler
	pop	ax
	pop	di			    ; ES:DI -> IRQ_Hook_Struc
	jc	short DEF_chain
	pop	es
	pop	di
	add	sp, 4
	iret

DEF_chain:
        call DOCLI
	push	bp
	mov	bp, sp			    ;stack frame:
					    ;	bp+8	-> OldInt CS
					    ;	bp+6	-> OldInt IP
					    ;	bp+4	-> di
					    ;	bp+2	-> es
					    ;	bp+0	-> bp
	les	di, es:[di.OldIntVec]
	mov	[bp+6], di
	mov	[bp+8], es
	pop	bp
	pop	es
	pop	di
	ret				    ; far ret to OldInt handler
DEF_Handler endp

;------------------------------------------------------------------------------
;
;   ENTER:	ES:DI -> BIS
;
;   EXIT:	Carry set, if IRQ not handled by any com ports
;
COMHandler proc far
	push	ds
	push	si
	push	ax
	push	bx
	mov	si, es
	mov	ds, si
	mov	bh, -1
ch_chk_all:
	lea	si, [di-SIZE ComDEB]	;ds:si -> ComDEB
	mov	si, [si.IRQhook]
	mov	si, [si.First_DEB]
	mov	bl, -1
ch_next_com:
	inc	bl			; first time bl = 0
	xor	ax, ax
	xchg	ax, [di.BIS_Mode]
	lea	di, [si+SIZE ComDEB]
	mov	[di.BIS_Mode], ax
ifdef   NEC_98
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.04.16)  |
	jz	@F				;Now, 8251 mode	(ins 94.04.16)  |
	call	AOBA_CommInt			;		(ins 94.04.16)  |
	jmp	short	ch_AOBA_int		;		(ins 94.05.17)  |
@@:						;		(ins 94.04.16)  |
	call	CommInt
ch_AOBA_int:					;		(ins 94.05.17)  
else    ; NEC_98
	call	CommInt
endif   ; NEC_98
	and	al, 80h
	or	bl, al

	mov	si, [si.NextDEB]
	or	si, si
	jnz	ch_next_com

	test	bl, 7Fh 		;Q: more than 1 com port?
	jnz	short ch_shared 	;   Y: check if handled
	or	bl, bl			;Q: int handled by port?
	stc
	jns	ch_exit 		;   N:

ch_eoi:
	xor	ax, ax
.errnz BIH_API_EOI
	xor	bx, bx
	xchg	bx, es:[di.BIS_Mode]
	call	es:[bx][di.BIS_User_Mode_API]
	lea	si, [di-SIZE ComDEB]	; ds:si -> ComDEB
	mov	si, [si.IRQhook]
	mov	al, [si.OldMask]
	shr	al, 1			; shift bit 0 into Carry (0, if unmasked
	cmc				;   -1, if originally masked)

ch_exit:
	pop	bx
	pop	ax
	pop	si
	pop	ds
	ret

ch_shared:
	inc	bh			; count loop
	or	bl, bl			;Q: int handled by any port?
	js	ch_chk_all		;   Y: check all ports again
	or	bh, bh			;Q: first time thru loop?
	stc
	jz	ch_exit 		;   Y: int wasn't for a COM port, so
					;      chain to next IRQ handler
	jmp	ch_eoi

COMHandler endp


IFDEF No_DOSX_Bimodal_Services

PUBLIC Entry_From_RM
Entry_From_RM proc far

;
; Simulate the far ret
;
	cld
	lodsw
	mov	es:[di.RealMode_IP], ax
	lodsw
	mov	es:[di.RealMode_CS], ax
	add	es:[di.RealMode_SP], 4

	push	es
	push	di
.286
;
; Push far addr of Ret_To_IRET to cleanup stack and return to DPMI host
;
	push	cs
	push	IntCodeOFFSET Ret_To_IRET
;
; Push far addr of proc to call, so we can do a far ret to it
;
	push	es:[di.RealMode_CX]	; segment of callback
	push	es:[di.RealMode_DX]	; offset of callback
	mov	di, es:[di.RealMode_DI]
	ret				; far ret to cx:dx
					;   called proc will do a far ret
Ret_To_IRET:				; <- to here
	pop	di
	pop	es
	iret
.8086

Entry_From_RM endp

PUBLIC RM_APIHandler
RM_APIHandler proc far
	cmp	ax, BIH_API_Call_Back
	jne	APIHandler
	call	cs:[RM_CallBack]
	ret
RM_APIHandler endp

ENDIF

;------------------------------------------------------------------------------
;
;   ENTER:	ES:DI -> BIS
;
APIHandler proc far

	or	ax, ax
	jnz	short api_not_EOI
.errnz	BIH_API_EOI
ifdef   NEC_98
	push	dx				;		(ins 93.03.20)
	mov	ax, es:[di.BIS_IRQ_Number]	;		(ins 92.10.06)
	cmp	al,8		 	;Q: slave IRQ?		(ins 92.10.06)
	mov	al,EOI		 	;			(ins 92.10.06)
	jb	short api_master 	; N:			(ins 92.10.06)
	mov	dx,08h			;Pic port address save	(ins 93.03.11)
	NEWIODELAY	1		;<OUT 5F,AL>  		(ins 93.03.08)
	out	dx,al			;			(ins 93.03.08)
	mov	al,ISR_READ		;Isr read command byte	(ins 93.03.08)
	NEWIODELAY	1		;<OUT 5F,AL>  		(ins 93.03.08)
	out	dx,al			;			(ins 93.03.08)
	NEWIODELAY	1		;<OUT 5F,AL>  		(ins 93.03.08)
	in	al,SLAVE_ISR		;			(ins 93.03.08)
	test	al,0ffh			;			(ins 93.03.08)
	jnz	EOI_INT50		;			(ins 93.03.08)
	mov	al,EOI			;			(ins 93.03.08)
	NEWIODELAY	1		;<OUT 5F,AL>  		(ins 93.03.08)
	jmp	short	api_master	;			(ins 93.03.08)
EOI_INT50:				;			(ins 93.03.08)
	NEWIODELAY	1		;<OUT 5F,AL>  		(ins 93.03.08)
	pop	dx			;			(ins 93.03.20)
	ret				;			(ins 93.03.08)
api_master:				;			(ins 92.10.06)
	out	00h,al			; EOI master		(ins 92.10.06)
	NEWIODELAY	1		;<OUT 5F,AL>  		(ins 93.03.08)
	pop	dx			;			(ins 93.03.20)
	ret				;			(ins 92.10.06)
else    ; NEC_98
	mov	ax, es:[di.BIS_IRQ_Number]
	cmp	al,8			;Q: slave IRQ?
	mov	al,EOI
	jb	short api_master	;   N:
	out	0A0h,al 		;   Y: EOI slave
api_master:
	out	INTA0,al		; EOI master
	ret
endif   ; NEC_98

api_not_EOI:
	cmp	ax, BIH_API_Call_Back
	jae	short api_callme
	push	dx
	push	cx
ifdef   NEC_98
	mov	dx, 0002h		;			(ins 92.10.06)
else    ; NEC_98
	mov	dx, INTA1
endif   ; NEC_98
	mov	cx,  es:[di.BIS_IRQ_Number]
	cmp	cl, 8			;Q: 2nd PIC?
	jb	@f			;   N:
ifdef   NEC_98
	mov	dx, 000Ah		;			(ins 92.10.06)
else    ; NEC_98
	mov	dx, 0A1h		;   Y: dx = mask port
endif   ; NEC_98
	sub	cl, 8
@@:
	cmp	al, BIH_API_Get_Mask	;Q: get IRQ mask?
	jae	api_get_mask		;   Y:
	mov	ah, al
	mov	ch, 1
	shl	ch, cl			; ch = mask byte
	pushf
        call DOCLI
	in	al, dx			; get current PIC mask state
	cmp	ah, BIH_API_Mask	;Q: mask IRQ?
	jne	@f			;   N:
	or	al, ch			;   Y: set IRQ's bit
	jmp	short api_mask_exit
@@:
	not	ch			;   N: clear IRQ's bit to unmask
	and	al, ch
api_mask_exit:
	out	dx, al
	pop	ax
	test	ah, 2			;Q: ints were enabled?
	jz	@f			;   N:
        call DOSTI
@@:
	pop	cx
	pop	dx
	ret

api_get_mask:
	in	al, dx			; get current PIC mask state
	inc	cl
	shr	al, cl			; move IRQ's bit into carry
					; Carry set, if IRQ masked
	pop	cx
	pop	dx
	ret

api_callme:
	push	cx
	push	dx
	ret				; far ret to call back, which will
					; do a far ret to our caller
APIHandler endp


;--------------------------Fake a Hardware Interrupt----------------------;
; FakeCOMInt
;
; This routine fakes a hardware interrupt to IRQ3 or IRQ4
; to clear out characters pending in the buffer
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;
; Registers Destroyed:
;   AX,DX,FLAGS
; History: glenn steffler 5/17/89
;-----------------------------------------------------------------------;

FakeCOMInt proc near

      ; call DOCLI                             ;Done by caller
;
; WARNING: jumping into the middle of CommInt, so the stack must be set
;	   properly.
;
	push	dx
	push	bx
	push	cx
	push	di
	push	es
	push	EvtWord[si]
ifdef   NEC_98
	test	[si.AOBA_flag],fFIFO_Mode	;		(ins 94.04.16)  |
	jz	@F			;Now, 8251 mode		(ins 94.04.16)  |
	mov	dx,Port[si]		;Get device I/O address (ins 94.04.16)  |
	add	dl, ACE_IIDR			;		(ins 94.04.16)  |
	push	dx				;		(ins 94.04.18)  |
	jmp	AOBA_FakeXmitEmpty		;		(ins 94.04.18)  |
@@:						;		(ins 94.04.16)  |
else    ; NEC_98
	mov	dx,Port[si]		;Get device I/O address
	add	dl, ACE_IIDR
endif   ; NEC_98
	push	dx
	jmp	FakeXmitEmpty		;Process the fake interrupt, DS:SI is
					;  already pointing to proper DEB
;
; FakeXmitEmpty falls in XmitEmpty which jumps back into CommInt.  When CommInt
; determines that no interrupt is pending, then it will near return back to
; FakeCOMIntFar which can far ret back to its caller.
;
FakeCOMInt endp

public	FakeCOMIntFar
FakeCOMIntFar proc far

	call	FakeCOMInt
	ret

FakeCOMIntFar endp

;--------------------------Interrupt Handler----------------------------
;
; CommInt - Interrupt handler for com ports
;
; Interrupt handlers for PC com ports.	This is the communications
; interrupt service routine for RS232 communications.  When an RS232
; event occurs the interrupt vectors here.  This routine determines
; who the caller was and services the appropriate interrupt.  The
; interrupts are prioritized in the following order:
;
;     1.  line status interrupt
;     2.  read data available interrupt
;     3.  transmit buffer empty interrupt
;     4.  modem service interrupt
;
; This routine continues to service until all interrupts have been
; satisfied.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   AL = 0, if not handled, -1, if handled
;
;-----------------------------------------------------------------------

assumes ds,Data
assumes es,nothing

;   Dispatch table for interrupt types

ifndef  NEC_98
SrvTab label word
	dw	OFFSET ModemStatus	;[0] Modem Status Interrupt
	dw	OFFSET XmitEmpty	;[2] Tx Holding Reg. Interrupt
	dw	OFFSET DataAvail	;[4] Rx Data Available Interrupt
					;   or [C] if 16550 & 16550A
	dw	OFFSET LineStat 	;[6] Reciever Line Status Interrupt
endif   ; NEC_98


	public	CommInt

CommInt proc near

	xor	al, al
	cmp	word ptr [VCD_int_callback+4], 0
	je	short @F			; jump if no callback (not 3.1 VCD)
	test	[si.VCDflags], fCOM_ignore_ints ;Q: we still own port?
ifdef   NEC_98
	jz	IntLoop45			;	[QN]  (ins 92.09.xx)
	ret					;	[QN]  (ins 92.09.xx)
IntLoop45:					;	[QN]  (ins 92.09.xx)
else    ; NEC_98
	jnz	IntLoop40			;   N: ignore the int
endif   ; NEC_98
.386
	push	esi
	mov	esi, [si.VCD_data]
	call	[VCD_int_callback]
	pop	esi
.8086
@@:

	push	dx
ifdef   NEC_98
	mov	dx,StatusPort[si]	;		   [QN]	(ins 92.08.xx)
	in	al, dx			; Get Status	   [QN]	(ins 92.08.xx)
	test	al,(TX_RDY+TX_EMP+RX_RDY);		   [QN]	(ins 92.08.xx)
	jnz	IntLoop_qn		;  Yes		   [QN]	(ins 93.03.17)
	or	al, 1			;  No		   [QN]	(ins 93.03.17)
	jmp	short	IntLoop30	;		   [QN]	(ins 93.03.17)
IntLoop_qn:				;		   [QN]	(ins 93.03.17)
	xor	al, al			;		   [QN]	(ins 93.03.17)
else    ; NEC_98
	mov	dx,Port[si]		;Get comm I/O port
	add	dl,ACE_IIDR		;--> Interrupt ID Register
	in	al, dx
	test	al, 1			;Q: interrupt pending?
	jnz	short IntLoop30 	;   N:
endif   ; NEC_98

	push	bx
	push	cx
	push	di
	push	es
	mov	cx, EvtWord[si]
	push	cx
	jmp	short IntLoop10

InterruptLoop_ChkTx:
	cmp	QOutCount[si],0 	;Output queue empty?
	je	short InterruptLoop	;   Y: don't chk tx
ifdef   NEC_98
	call	KickTxINT		;			(ins 92.09.xx)
else    ; NEC_98
	pop	dx
	push	dx
	dec	dx			; to IER
.errnz ACE_IIDR - ACE_IER - 1
	in	al, dx
	and	al,NOT ACE_ETBEI	; disable it
	iodelay
	out	dx, al
	or	al, ACE_ETBEI		; enable it again
	iodelay
	out	dx, al
	iodelay
	out	dx, al
endif   ; NEC_98

InterruptLoop:
ifdef   NEC_98
	mov	dx,StatusPort[si]       ;Get ID reg I/O Address	(ins 92.08.xx)
					;			(ins 92.08.xx)
IntLoop10:				;			(ins 92.08.xx)
        in      al,dx                   ;Get Interrupt Id	(ins 92.08.xx)
	test	al,RX_RDY		;			(ins 92.08.xx)
	jz	Intloop15		;			(ins 92.08.xx)
	jmp	DataAvail		;Receive Data		(ins 92.08.xx)
					;			(ins 92.08.xx)
IntLoop15:				;			(ins 92.08.xx)
	test	al,(TX_RDY)		;			(ins 92.08.xx)
	jz	IntLoop20		;			(ins 92.08.xx)
	jmp	XmitEmpty		;Send Data		(ins 92.08.xx)
					;			(ins 92.08.xx)
					;Check whether tx queue	(ins 92.08.xx)
					;  has data		(ins 92.08.xx)
IntLoop17:				;			(ins 92.08.xx)
	mov	dx,StatusPort[si]	;Get ID reg I/O Address	(ins 92.08.xx)
	in	al,dx			;Get Status		(ins 92.08.xx)
	test	al,RX_RDY		;			(ins 92.08.xx)
	jz	IntLoop20		;			(ins 92.08.xx)
	jmp	short DataAvail		;Receive Data		(ins 92.08.xx)
else    ; NEC_98
	pop	dx			;Get ID reg I/O address

	in	al,dx			;Get Interrupt Id
	test	al,1			;Interrupt need servicing?
	jnz	IntLoop20		;No, all done

IntLoop10:
	and	ax, 07h
	mov	di,ax
	push	dx			;Save Id register
	jmp	SrvTab[di]		;Service the Interrupt
endif   ; NEC_98

IntLoop20:
	mov	ax,EvtMask[si]		;Mask the event word to only the
	and	ax, EvtWord[si] 	;  user specified bits
	mov	EvtWord[si], ax
	pop	bx
	test	[si.NotifyFlagsHI], CN_Notify
	jz	short ci_exit
	not	bx
	and	ax, bx			; bits set in ax are new events
	jnz	short ci_new_events

ci_exit:
	pop	es
	assumes es,nothing

	pop	di
	pop	cx
	pop	bx
	xor	al, al

IntLoop30:
	pop	dx
	and	al, 1
	dec	al			; 0->-1, 1->0
IntLoop40:
	ret

ci_new_events:
	mov	ax, CN_EVENT
	call	notify_owner
	jmp	ci_exit

CommInt endp

page

;----------------------------Private-Routine----------------------------;
;
; LineStat - Line Status Interrupt Handler
;
; Break detection is handled and set in the event word if
; enabled.  Other errors (overrun, parity, framing) are
; saved for the data available interrupt.
;
; This routine used to fall into DataAvail for the bulk of its processing.
; This is no longer the case...  A very popular internal modem seems to
; operate differently than a real 8250 when parity errors occur.  Falling
; into the DataAvail handler on a parity error caused the same character
; to be received twice.  Having this routine save the LSR status, and
; return to InterruptLoop fixes the problem, and still works on real COMM
; ports.  The extra overhead isn't a big deal since this routine is only
; entered when there is an exception like a parity error.
;
; This routine is jumped to, and will perform a jump back into
; the dispatch loop.
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,FLAGS
; History:
;-----------------------------------------------------------------------;


; assumes ds,Data
assumes es,nothing

public LineStat 			;Public for debugging
LineStat proc near

ifdef   NEC_98
;=======================================================================[QN]|
;									[QN]|
; Read Line Status							[QN]|
;									[QN]|
; <Entry>								[QN]|
;	none								[QN]|
;									[QN]|
; <Exit>								[QN]|
;	[AL]= Line Status						[QN]|
;									[QN]|
; <Modified>								[QN]|
;	AL Registor							[QN]|
;									[QN]|
; < Status Format >   8251 USART					[QN]|
;	Bit    (7)  (6)  (5)  (4)  (3)  (2)  (1)  (0)  			[QN]|
;	      none [bd] [fe] [oe] [pe] none none none  ---------+	[QN]|
;								I	[QN]|
; < Status Format >   8250 USART MS-Windows format		I	[QN]|
;	Bit    (7)  (6)  (5)  (4)  (3)  (2)  (1)  (0)  		I	[QN]|
;	      none none none [bd] [fe] [pe] [oe] none  <--------+	[QN]|
;									[QN]|
;=======================================================================[QN]|
	push	dx			;				[QN]|
	push	bx			;				[QN]|
	push	ax			;				[QN]|
	mov	dx,StatusPort[si] 	;				[QN]|
	in	al,dx			;				[QN]|
	and	al,01111000b		;				[QN]|
	test	al,00111000B		; Error ?			[QN]|
	jz	LINE_SR_10		;	NO ! -> Reset Error	[QN]|
	push	ax			;				[QN]|
	test	al,01000000b		;				[QN]|
	jz	LINE_SR_EV_Err		;				[QN]|
	or	by EvtWord[si],EV_Break ;Show break			[QN]|
LINE_SR_EV_Err:				;				[QN]|
	or	by EvtWord[si],EV_Err	;Line Status Error		[QN]|
					;				[QN]|
					;   AH		AL	  BH	[QN]|
	mov	al,CommandShadow[si] 	;********    0bfop000  ********	[QN]|
	or	al,ERR_RESET		;********    0bf1p000  ********	[QN]|
	out	dx,al			; Reset !			[QN]|
	pop	ax			;				[QN]|
LINE_SR_10:				;Adjust Bit Arrange to		[QN]|
					;  MS-Windows Format (bit4-1)	[QN]|
	shr	al,1			;********    00bf1p00  ********	[QN]|
	shr	al,1			;********    000bf1p0  ********	[QN]|
	mov	ah,al			;000bf1p0    000bf1p0  ******** [QN]|
	mov	bh,al			;000bf1p0    000bf1p0  000bf1p0 [QN]|
					;Clear Bit 2,1			[QN]|
	and	al,11111001B		;000bf1p0    000bf1p0  000bf1p0 [QN]|
					;Save (PE)Bit			[QN]|
	and	ah,00000010B		;000000p0    000bf1p0  000bf1p0 [QN]|
					;Save (OE)Bit			[QN]|
	and 	bh,00000100B		;000000p0    000bf1p0  00000100 [QN]|
	shl	ah,1			;0000000p    000bf1p0  00000100 [QN]|
	shr	bh,1			;0000000p    000bf1p0  00000010 [QN]|
					;Reshuffle (PE) and (OE) bit	[QN]|
	or	ah,bh			;0000001p    000bf1p0  00000010 [QN]|
					;Save Bit 2,1			[QN]|
	or	al,ah			;0000001p    000bf11p  00000010 [QN]|
	mov	dl,al			;				[QN]|
	pop	ax			;				[QN]|
	mov	al,dl			;				[QN]|
	pop	bx			;				[QN]|
	pop	dx			;				[QN]|

	test	al,ACE_PE+ACE_FE+ACE_OR ;Parity, Framing, Overrun error?
	jz	@f
	mov	LSRShadow[si],al	;yes, save status for DataAvail
@@:
	ret				;  qnes 92.10.06
else    ; NEC_98
	or	by EvtWord[si],EV_Err	;Show line status error

	add	dl,ACE_LSR-ACE_IIDR	;--> Line Status Register
	in	al,dx
	test	al,ACE_PE+ACE_FE+ACE_OR ;Parity, Framing, Overrun error?
	jz	@f

	mov	LSRShadow[si],al	;yes, save status for DataAvail
@@:
	test	al,ACE_BI		;Break detect?
	jz	InterruptLoop_ChkTx	;Not break detect interrupt

	or	by EvtWord[si],EV_Break ;Show break

	jmp	short InterruptLoop_ChkTx
endif   ; NEC_98

LineStat   endp

page

;----------------------------Private-Routine----------------------------;
;
; DataAvail - Data Available Interrupt Handler
;
; The available character is read and stored in the input queue.
; If the queue has reached the point that a handshake is needed,
; one is issued (if enabled).  EOF detection, Line Status errors,
; and lots of other stuff is checked.
;
; This routine is jumped to, and will perform a jump back into
; the dispatch loop.
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

; assumes ds,Data
assumes es,nothing

public DataAvail                       ;public for debugging
DataAvail   proc   near

ifdef   NEC_98
;---------------------------------------------------------------;(ins 92.08.24)
;	LineStat......Read Line Status				;(ins 92.08.24)
;			return = AL (Line Status)		;(ins 92.08.24)
;---------------------------------------------------------------;(ins 92.08.24)
								;(ins 92.08.24)
	call	LineStat		;Read 8251 Line Status	;(ins 92.08.24)
	mov	dx, DataPort[si]	;Store Read Data Port 	;(ins 92.08.24)
	in	al, dx			;Receive Data		;(ins 92.08.24)
	NEWIODELAY	14		;<OUT 5F,AL>  		;(ins 93.10.27)
else    ; NEC_98
	sub	dl,ACE_IIDR-ACE_RBR	;--> receiver buffer register
	in	al,dx			;Read received character
endif   ; NEC_98

	and	[si.NotifyFlagsHI], NOT CN_Idle ; flag as not idle

	mov	ah,LSRShadow[si]	;what did the last Line Status intrpt
	mov	bh,ah			;  have to say?
	or	ah,ah
	jz	@f

	and	ah,ErrorMask[si]	;there was an error, record it
	or	by ComErr[si],ah
IFNDEF KKBUGFIX  ; 1/05/93:TakuA:Fix #1666
	mov	LSRShadow[si],0
ENDIF
ifndef  NEC_98
	.errnz	ACE_OR-CE_OVERRUN	;Must be the same bits
	.errnz	ACE_PE-CE_RXPARITY
	.errnz	ACE_FE-CE_FRAME
	.errnz	ACE_BI-CE_BREAK
endif   ; NEC_98
@@:

; Regardless of the character received, flag the event in case
; the user wants to see it.

	or	by EvtWord[si],EV_RxChar ;Show a character received
	.errnz HIGH EV_RxChar

; Check the input queue, and see if there is room for another
; character.  If not, or if the end of file character has already
; been received, then go declare overflow.

DataAvail00:

IFDEF KKBUGFIX  ; 1/05/93:TakuA:Fix #1666
        mov     bh,LSRShadow[si]
        mov     LSRShadow[si],0
ENDIF
	mov	cx,QInCount[si] 	;Get queue count (used later too)
	cmp	cx,QInSize[si]		;Is queue full?
	jge	DataAvail20		;  Yes, comm overrun
	test	EFlags[si],fEOF 	;Has end of file been received?
	jnz	DataAvail20		;  Yes - treat as overflow

; Test to see if there was a parity error, and replace
; the character with the parity character if so

	test	bh,ACE_PE		;Parity error
	jz	DataAvail25		;  No
	test	[si.DCB_Flags2],fPErrChar   ;Parity error replacement character?
	jz	DataAvail25		;  No
	mov	al,[si.DCB_PEChar]	;  Yes, get parity replacement char

; Skip all other processing except event checking and the queing
; of the parity error replacement character

	jmp	short DataAvail80	;Skip all but event check, queing

DataAvail20:
	or	by ComErr[si],CE_RXOVER ;Show queue overrun
	jmp	short DataAvail50

; See if we need to strip null characters, and skip
; queueing if this is one.  Also remove any parity bits.

DataAvail25:
	and	al,RxMask[si]		;Remove any parity bits
	jnz	DataAvail30		;Not a Null character
	test	[si.DCB_Flags2],fNullStrip  ;Are we stripping received nulls?
	jnz	DataAvail50		;  Yes, put char in the bit bucket

; Check to see if we need to check for EOF characters, and if so
; see if this character is it.

DataAvail30:
	test	[si.DCB_Flags],fBinary	;Is this binary stuff?
	jnz	DataAvail60		;  Yes, skip EOF check
	cmp	al,[si.DCB_EOFChar]	;Is this the EOF character?
	jnz	DataAvail60		;  No, see about queing the charcter
	or	EFlags[si],fEOF 	;Set end of file flag
DataAvail50:
	jmp	DataAvail140		;Skip the queing process

; If output XOn/XOff is enabled, see if the character just received
; is either an XOn or XOff character.  If it is, then set or
; clear the XOffReceived flag as appropriate.

DataAvail60:
	test	[si.DCB_Flags2],fOutX	;Output handshaking?
	jz	DataAvail80		;  No
	cmp	al,[si.DCB_XoffChar]	;Is this an X-Off character?
	jnz	DataAvail70		;  No, see about XOn or Ack
	or	HSFlag[si],XOffReceived ;Show XOff received, ENQ or ETX [rkh]
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	DataAvail50		;  No
	cmp	cx,[si.DCB_XonLim]	;See if at XOn limit
	ja	DataAvail50		;  No
	and	HSFlag[si],NOT XOffReceived ;Show ENQ or ETX not received
	and	HSFlag[si], NOT XOnPending+XOffSent
	mov	al, [si.DCB_XonChar]
	call	OutHandshakingChar
	jmp	DataAvail50		;Done

DataAvail70:
	cmp	al,[si.DCB_XonChar]	;Is this an XOn character?
	jnz	DataAvail80		;  No, just a normal character
	and	HSFlag[si],NOT XOffReceived
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	DataAvail75		;  No - jump to FakeXmitEmpty to get
					;	transmitting going again
	and	HSFlag[si],NOT EnqSent

DataAvail75:
	jmp	FakeXmitEmpty		;Restart transmit

; Now see if this is a character for which we need to set an event as
; having occured. If it is, then set the appropriate event flag


DataAvail80:
	cmp	al,[si.DCB_EVTChar]	;Is it the event generating character?
	jne	DataAvail90		;  No
	or	by EvtWord[si],EV_RxFlag   ;Show received specific character

; Finally, a valid character that we want to keep, and we have
; room in the queue. Place the character in the queue.
; If the discard flag is set, then discard the character

DataAvail90:
	test	MiscFlags[si], Discard	;Discarding characters ?
	jnz	DataAvail50		;  Yes

	lea	bx, [si+SIZE ComDEB]	; DS:BX -> BIS
	mov	bx, [bx.BIS_Mode]	; mode will be either 0 or 4
	les	di,QInAddr[si][bx]	;Get queue base pointer from either
	assumes es,nothing		;   QInAddr or AltQInAddr

	mov	bx,QInPut[si]		;Get index into queue
	mov	es:[bx][di],al		;Store the character
	inc	bx			;Update queue index
	cmp	bx,QInSize[si]		;See if time for wrap-around
	jc	DataAvail100		;Not time to wrap
	xor	bx,bx			;Wrap-around is a new zero pointer

DataAvail100:
	mov	QInPut[si],bx		;Store updated pointer
	inc	cx			;And update queue population
	mov	QInCount[si],cx

; If flow control has been enabled, see if we are within the
; limit that requires us to halt the host's transmissions

	cmp	cx,XOffPoint[si]	;Time to see about XOff?
	jc	DataAvail120		;  Not yet
	test	HSFlag[si],HSSent	;Handshake already sent?
	jnz	DataAvail120		;  Yes, don't send it again

	mov	ah,HHSLines[si] 	;Should hardware lines be dropped?
	or	ah,ah			;  (i.e. do we have HW HS enabled?)
	jz	DataAvail110		;  No
ifdef   NEC_98
	mov	al,CommandShadow[si] ;8251 Command get    	(ins 92.08.xx)
	test	ah,ACE_DTR	     ;DTR handshake Enable ?	(ins 92.08.xx)
	jz	DataAvail101	     ;  No			(ins 92.08.xx)
	and	al,not DTR	     ;Clear 8251's DTR Line ! 	(ins 92.08.xx)
DataAvail101:			     ;				(ins 92.08.xx)
	test	ah,ACE_RTS	     ;RTS handshake Enable ?	(ins 92.08.xx)
	jz	DataAvail102	     ;  No			(ins 92.08.xx)
	and	al,not RTS	     ;Clear 8251's RTS Line !	(ins 92.08.xx)
DataAvail102:			     ;				(ins 92.08.xx)
	mov	dx,CommandPort[si]   ;GET Command port address	(ins 92.08.xx)
	out	dx,al		     ;				(ins 92.08.xx)
	mov	CommandShadow[si],al ;Get Back 8251 Command 	(ins 92.08.xx)
	or	HSFlag[si],HHSDropped  ;  and remember they were dropped(ins 92.08.xx)
else    ; NEC_98
	add	dl,ACE_MCR		;  Yes
	in	al,dx			;Clear the necessary bits
	not	ah
	and	al,ah
	or	HSFlag[si],HHSDropped	;Show lines have been dropped
	out	dx,al			;  and drop the lines
	sub	dl,ACE_MCR
endif   ; NEC_98

DataAvail110:
	test	[si.DCB_Flags2],fInX	;Input Xon/XOff handshaking
	jz	DataAvail120		;  No
	or	HSFlag[si], XOffSent
	mov	al, [si.DCB_XoffChar]
	call	OutHandshakingChar

DataAvail120:
	cmp	cx, [si.RecvTrigger]	;Q: time to call owner's callback?
	jb	short DataAvail130	;   N:

	test	[si.NotifyFlagsHI], CN_RECEIVE
	jnz	short DataAvail140	; jump if notify already sent and
					;   data in buffer hasn't dropped
					;   below threshold
	mov	ax, IntCodeOFFSET DataAvail140
	push	ax
	mov	ax, CN_RECEIVE
%OUT probably should just set a flag and notify after EOI
	jmp	notify_owner

DataAvail130:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE

DataAvail140:
ifdef   NEC_98
	mov	dx,StatusPort[si]       ;	[QN][BA] (ins 93.03.23)
        in      al,dx                   ;	[QN][BA] (ins 93.03.23)
	test	al,01000000b		;	[QN][BA] (ins 93.03.23)
	jz	@f			;	[QN][BA] (ins 93.03.23)
	or	by EvtWord[si],EV_Break ;	[QN][BA] (ins 93.03.23)
@@:					;	[QN][BA] (ins 93.03.23)
	test	[si.DCB_Flags],fBinary	;Is this binary stuff?	<add 92.10.13>|
	jnz	DataAvail140_Binary	;  Yes			<add 93.03.23>|

	mov	dx,StatusPort[si]       ;Get ID reg I/O Address	(ins 92.08.xx)
        in      al,dx                   ;Get Interrupt Id	(ins 92.08.xx)
	test	al,RX_RDY		;Is this RX_ready ?	(ins 92.08.xx)
	jz	@F			;  No			(ins 92.08.xx)

	mov	dx, DataPort[si]	;Store Read Data Port 	(ins 92.08.xx)
	in	al, dx			;Receive Data		(ins 92.08.xx)
	NEWIODELAY	14		;<OUT 5F,AL>  		(ins 93.10.27)
	jmp	DataAvail00
@@:
	jmp	InterruptLoop		;;;92.10.05

DataAvail140_Binary:			;Receive Binary		<add 92.10.13>|
	push	cx			;			<add 92.10.13>|
	mov	cx, [RECLoopCounter]	;		[QN][BA](ins 93.03.30)

RetryReadData2:				;			<add 92.10.13>|
	mov	dx,StatusPort[si]       ;Get ID reg I/O address	<add 92.10.13>|
        in      al,dx                   ;Get Interrupt Id	<add 92.10.13>|
	test	al,RX_RDY		;Is this RX_ready ?	<add 92.10.13>|
	jz	@F			;  No			<add 92.10.13>|
	pop	cx			;			<add 92.10.13>|
	mov	dx, DataPort[si]	; Store Read Data Port	<add 92.10.13>|
	in	al, dx			;Receive Data		<add 92.10.13>|
	NEWIODELAY	14		;<OUT 5F,AL>  		(ins 93.10.27)
	jmp	DataAvail00		;			<add 92.10.13>|
@@:					;			<add 92.10.13>|
	loop	RetryReadData2		;			<add 92.10.13>|
	pop	cx			;			<add 92.10.13>|
	jmp	InterruptLoop		;			<add 92.10.13>|
else    ; NEC_98
	pop	dx
	push	dx
	add	dl, ACE_LSR-ACE_IIDR
	in	al, dx
	test	al, ACE_DR		;Q: more data available?
	jz	@F			;   N:
	sub	dl, ACE_LSR		;   Y: go read it
	in	al, dx			;Read available character
	jmp	DataAvail00
@@:
	jmp	InterruptLoop_ChkTx
endif   ; NEC_98

DataAvail endp


OutHandshakingChar proc near

ifdef   NEC_98
	mov	dx,StatusPort[si]       ;Get ID reg I/O Address	(ins 92.08.xx)|
	mov	ah, al			;			(ins 92.08.xx)|
@@:					;			(ins 92.08.xx)|
	in	al, dx			;			(ins 92.08.xx)|
	test	al,(TX_RDY+TX_EMP)	;Is this TX_empty ?	(ins 92.08.xx)|
	jz	@B			;			(ins 92.08.xx)|
	mov	dx,DataPort[si]		;			(ins 92.09.24)|
else    ; NEC_98
	add	dl, ACE_LSR
	mov	ah, al
@@:
	in	al, dx
	test	al, ACE_THRE
	jz	@B
	sub	dl, ACE_LSR
endif   ; NEC_98
	mov	al, ah
	out	dx, al
	ret

OutHandshakingChar endp


page

;----------------------------Private-Routine----------------------------;
;
; XmitEmpty - Transmitter Register Empty
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

; assumes ds,Data
assumes es,nothing

public FakeXmitEmpty
FakeXmitEmpty:
	pop	dx
	push	dx

; "Kick" the transmitter interrupt routine into operation.

ifdef   NEC_98
	call	KickTxINT	   ;			(ins 92.09.xx)
	mov	dx,StatusPort[si]  ;Get Status Port	(ins 92.08.xx)
	mov	ah, al		   ;			(ins 92.08.xx)
	in	al, dx		   ;			(ins 92.08.xx)
	test	al,(TX_RDY+TX_EMP) ;Is this TX_ready ?	(ins 92.08.xx)
else    ; NEC_98
	dec	dl
.errnz ACE_IIDR - ACE_IER-1
	in	al,dx			;Get current IER state
	test	al,ACE_ETBEI		;Interrupt already enabled?
	jnz	@F			;  Yes, don't reenable it
	or	al,ACE_ETBEI		;  No, enable it
	out	dx,al
	iodelay 			;8250, 8250-B bug requires
	out	dx,al			;  writting register twice
@@:
	add	dl,ACE_LSR-ACE_IER	;--> Line Status Register
	iodelay
	in	al,dx			;Is xmit really empty?
	sub	dl,ACE_LSR-ACE_THR	;--> Transmitter Holding Register
	test	al,ACE_THRE
endif   ; NEC_98
	jnz	short XmitEmpty5	;   Y: send next char
	jmp	InterruptLoop		;   N: return to processing loop

public XmitEmpty
XmitEmpty proc near

ifdef   NEC_98
	call	MSR_READ		;			(ins 92.09.xx)
	mov	dx,StatusPort[si]       ;Get ID reg I/O Address	(ins 92.08.xx)
	in	al, dx			;			(ins 92.08.xx)
	test	al,(TX_EMP+TX_RDY)	;Is this TX_empty ?	(ins 92.08.xx)
else    ; NEC_98
	add	dl,ACE_LSR-ACE_IIDR	;--> Line Status Register
	in	al,dx			;Is xmit really empty?
	sub	dl,ACE_LSR-ACE_THR	;--> Transmitter Holding Register
	test	al,ACE_THRE
endif   ; NEC_98
	jz	Xmit_jumpto90		;Transmitter not empty, cannot send

; If the hardware handshake lines are down, then XOff/XOn cannot
; be sent.  If they are up and XOff/XOn has been received, still
; allow us to transmit an XOff/XOn character.  It will make
; a dead lock situation less possible (even though there are
; some which could happen that cannot be handled).

XmitEmpty5:
	mov	ah,HSFlag[si]		;Get handshaking flag
	test	ah,HHSDown+BreakSet	;Hardware lines down or break set?
	jnz	Xmit_jumpto100		;  Yes, cannot transmit

; Give priority to any handshake character waiting to be
; sent.  If there are none, then check to see if there is
; an "immediate" character to be sent.  If not, try the queue.

XmitEmpty10:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jnz	XmitEmpty40		;  Yes

XmitEmpty15:
	test	ah,HSPending		;XOff or XOn pending
	jz	XmitEmpty40		;  No

XmitEmpty20:
	and	ah,NOT XOnPending+XOffSent
	mov	al,[si.DCB_XonChar]	;Get XOn character

XmitEmpty30:
	mov	HSFlag[si],ah		;Save updated handshake flag
ifdef   NEC_98
	mov	dx,DataPort[si]					;(ins 92.09.24)
endif   ; NEC_98
	jmp	XmitEmpty110		;Go output the character

Xmit_jumpto90:
	jmp	XmitEmpty90

; If any of the lines which were specified for a timeout are low, then
; don't send any characters.  Note that by putting the check here,
; XOff and Xon can still be sent even though the lines might be low.

; Also test to see if a software handshake was received.  If so,
; then transmission cannot continue.  By delaying the software check
; to here, XOn/XOff can still be issued even though the host told
; us to stop transmission.

XmitEmpty40:
	test	ah,CannotXmit		;Anything preventing transmission?
	jz	XmitEmpty45		;  No
Xmit_jumpto100:
	jmp	XmitEmpty100		;  Yes, disarm and exit

; If a character has been placed in the single character "transmit
; immediately" buffer, clear that flag and pick up that character
; without affecting the transmitt queue.

XmitEmpty45:
	test	EFlags[si],fTxImmed	;Character to xmit immediately?
	jz	XmitEmpty515		;  No, try the queue
	and	EFlags[si],NOT fTxImmed ;Clear xmit immediate flag
	mov	al,ImmedChar[si]	;Get char to xmit
ifdef   NEC_98
	mov	dx,DataPort[si]		;(ins 92.09.xx)
endif   ; NEC_98
	jmp	XmitEmpty110		;Transmit the character

XmitEmpty515:
	mov	cx,QOutCount[si]	;Output queue empty?
	jcxz	Xmit_jumpto90		;  Yes, go set an event

	test	[si.DCB_Flags],fEtxAck	;Etx Ack?
	jz	XmitEmpty55		;  No
	mov	cx,QOutMod[si]		;Get number bytes sent since last ETX
	cmp	cx,[si.DCB_XonLim]	;At Etx limit yet?
	jne	XmitEmpty51		;  No, inc counter
	mov	QOutMod[si],0		;  Yes, zero counter
	or	HSFlag[si],EtxSent	;Show ETX sent
	jmp	short XE_sendXOFF

XmitEmpty51:
	inc	cx			; Update counter
	mov	QOutMod[si],cx		; Save counter
	jmp	short XmitEmpty59	; Send queue character

XmitEmpty55:
	test	[si.DCB_Flags],fEnqAck	;Enq Ack?
	jz	XmitEmpty59		;  No, send queue character
	mov	cx,QOutMod[si]		;Get number bytes sent since last ENQ
	or	cx,cx			;At the front again?
	jnz	XmitEmpty56		;  No, inc counter
	mov	QOutMod[si],1		;  Yes, send ENQ
	or	HSFlag[si],EnqSent	;Show ENQ sent
XE_sendXOFF:
	mov	al,[si.DCB_XoffChar]
ifdef   NEC_98
	mov	dx,DataPort[si]					;(ins 92.09.24)
endif   ; NEC_98
	jmp	short XmitEmpty110	;Go output the character

XmitEmpty56:
	inc	cx			;Update counter
	cmp	cx,[si.DCB_XonLim]	;At end of our out buffer len?
	jne	XmitEmpty58		;  No
	xor	cx,cx			;Show at front again.

XmitEmpty58:
	mov	QOutMod[si],cx		;Save counter

XmitEmpty59:
	lea	bx, [si+SIZE ComDEB]	; DS:BX -> BIS
	mov	bx, [bx.BIS_Mode]	; mode will be either 0 or 4
	les	di,QOutAddr[si][bx]	;Get queue base pointer from either
	assumes es,nothing		;   QOutAddr or AltQOutAddr

	mov	bx,QOutGet[si]		;Get pointer into queue
	mov	al,es:[bx][di]		;Get the character

	inc	bx			;Update queue pointer
	cmp	bx,QOutSize[si] 	;See if time for wrap-around
	jc	XmitEmpty60		;Not time for wrap
	xor	bx,bx			;Wrap by zeroing the index

XmitEmpty60:
	mov	QOutGet[si],bx		;Save queue index
	mov	cx,QOutCount[si]	;Output queue empty?
	dec	cx			;Dec # of bytes in queue
	mov	QOutCount[si],cx	;  and save new population

ifdef   NEC_98
	mov	dx,DataPort[si]		;		(ins 92.08.xx)
endif   ; NEC_98
	out	dx,al			;Send char

	cmp	cx, [si.SendTrigger]	;Q: time to call owner's callback?
	jae	short XmitEmpty70	;   N:

	test	[si.NotifyFlagsHI], CN_TRANSMIT
	jnz	short XmitEmpty80	; jump if notify already sent and
					;   data in buffer hasn't raised
					;   above threshold
	mov	ax, IntCodeOFFSET XmitEmpty80
	push	ax
	mov	ax, CN_TRANSMIT
ifdef   NEC_98
	jmp	notify_owner
else    ; NEC_98
	jmp	short notify_owner
endif   ; NEC_98

XmitEmpty70:
	and	[si.NotifyFlagsHI], NOT CN_TRANSMIT

XmitEmpty80:
%OUT check fNoFIFO in EFlags[si] to determine if we can queue more output
ifdef   NEC_98
	jmp	IntLoop17		;92.10.03
else    ; NEC_98
	jmp	InterruptLoop
endif   ; NEC_98


; No more characters to transmit.  Flag this as an event.

XmitEmpty90:
	or	by EvtWord[si],EV_TxEmpty

; Cannot continue transmitting (for any of a number of reasons).
; Disable the transmit interrupt.  When it's time resume, the
; transmit interrupt will be reenabled, which will generate an
; interrupt.

XmitEmpty100:
ifdef   NEC_98
	cmp	[si.DCB_id],ID_Com1	;Is This Com1 ID ?	(ins 92.08.xx)|
	jne	XmitEmpty102		;No, go to KickTx5	(ins 92.08.xx)|
	mov	dx,MaskFFPort[si]	;F/F Port Mask Bit	(ins 92.08.xx)|
	in	al,dx			;			(ins 92.08.xx)|
	mov	MaskFFShadow[si],al	;Save the Old Mask bit	(ins 92.08.xx)|
					;			(ins 92.08.xx)|
XmitEmpty102:				;			(ins 92.08.xx)|
 	mov	al,MaskFFShadow[si] ;mask data(port C) save 	(ins 92.08.xx)|
 	test	al,MSK_TXR		;Check a tx.RDY INT mask(ins 93.06.18)|
 	jz	XmitEmpty105		;  disable		(ins 92.08.xx)|
 	and	al,NOT(MSK_TXE+MSK_TXR)	;= 11111001b		(ins 92.08.xx)|
	mov	dx,MaskFFPort[si]	;Port address (Port C)	(ins 92.08.xx)|
	mov	MaskFFShadow[si],al	;Masking data save  	(ins 92.08.xx)|
XmitEmpty110:				;			(ins 92.08.xx)|
	out	dx,al			;Masking set		(ins 92.08.xx)|
XmitEmpty105:				;			(ins 92.08.xx)|
	jmp	IntLoop17		;			(ins 92.09.xx)|
else    ; NEC_98
	inc	dx			;--> Interrupt Enable Register
	.errnz	ACE_IER-ACE_THR-1
	in	al,dx			;I don't know why it has to be read
	and	al,NOT ACE_ETBEI	;  first, but it works this way
XmitEmpty110:
	out	dx,al
	jmp	InterruptLoop
endif   ; NEC_98

XmitEmpty endp

page

;----------------------------Private-Routine----------------------------;
;
; ModemStatus - Modem Status Interrupt Handler
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;


; assumes ds,Data
assumes es,nothing

public ModemStatus                     ;Public for debugging
ModemStatus proc near

; Get the modem status value and shadow it for MSRWait.

ifdef   NEC_98
	push	ax			;			     	[QN]|
	push	cx			;			     	[QN]|
        mov     ch,al                   ;Save a local copy	     	[QN]|
					;		 	     	[QN]|
; [Modem Status format (in AL and CH)]	: [Assign of Event Word]	[QN]|
;                  +------------- DRLSD :    EV_RLSD = 0000|0000 0010|0000b |
;	           |  +---------- TERI  :    EV_Ring = 0000|0001 0000|0000b |
;                  |  |  +------- DDSR  :    EV_DSR  = 0000|0000 0001|0000b |
;                  |  |  |  +---- DCTS  :    EV_CTS  = 0000|0000 0000|1000b |
;    (*)(*)(*)(*)|(R)(E)(D)(C)   	:		       		[QN]|
				;   <ah>       <al>       <cl>		[QN]|
        mov     ah,al	      	; ****|REDC  ****|REDC  ****|****    	[QN]|
        shr     ax,1		; 0***|*RED  C***|*RED  ****|****    	[QN]|
        shr     ax,1		; 00**|**RE  DC**|**RE	****|****    	[QN]|
        ror     al,1		; 000*|**RE  EDC*|***R	****|****    	[QN]|
        ror     al,1		; 000*|**RE  REDC|****	****|****    	[QN]|
        ror     al,1		; 000*|**RE  *RED|C***	****|****    	[QN]|
	mov	cl,al		;                       *RED|C***    	[QN]|
	and	ax, 0118h	; 0000|000E  000D|C000		     	[QN]|
	and	cl, 40h		;                       0R00|0000    	[QN]|
	shr	cl, 1		;                       00R0|0000    	[QN]|
	or	al, cl		; 0000|000E  00RD|C000		     	[QN]|
				;				     	[QN]|
        and     ax,EV_CTS+EV_DSR+EV_RLSD+EV_Ring ;		     	[QN]|
				; 0000|000E  00RD|C000		     	[QN]|
        or      EvtWord[si],ax	;			     	     	[QN]|
				;				     	[QN]|
; [Modem Status format (in CH)]		: [Assign of Event Word]     	[QN]|
;  	+------------------------- RLSD :  EV_RLSDS  = 0001|0000 0000|0000b |
;	|  +---------------------- RI   :  EV_RingTe = 0010|0000 0000|0000b |
;       |  |  +------------------- DSR  :  EV_DSRS   = 0000|1000 0000|0000b |
;       |  |  |  +---------------- CTS  :  EV_CTSS   = 0000|0100 0000|0000b |
;      (R)(I)(D)(C)|(*)(*)(*)(*)				     	[QN]|
;				;   <ah>       <al>       <cl>	     	[QN]|
         mov   ah,ch        	; RIDC|****  ****|****  RIDC|****    	[QN]|
         shr   ah,1		; 0RID|C***  ****|****  RIDC|****    	[QN]|
         shr   ah,1		; 00RI|DC**  ****|****  RIDC|****    	[QN]|
         and ax,EV_CTSS+EV_DSRS	; 0000|DC00  0000|0000  RIDC|****    	[QN]|
         or    EvtWord[si],ax	;			     	     	[QN]|
				;			     	     	[QN]|
         mov   ah,ch		; RIDC|****  ****|****  RIDC|****    	[QN]|
         mov   cl,3		;			     	     	[QN]|
         shr   ah,cl		; 000R|IDC*  ****|****  RIDC|****    	[QN]|
         and   ax,EV_RLSDS	; 000R|0000  0000|0000  RIDC|****    	[QN]|
         or    EvtWord[si],ax	;			     	     	[QN]|
				;			     	     	[QN]|
         mov   ah,ch		; RIDC|****  ****|****  RIDC|****    	[QN]|
	 shr   ah, 1		; 0RID|C***  ****|****  RIDC|****    	[QN]|
         and   ax,EV_RingTe	; 00I0|0000  0000|0000  RIDC|****    	[QN]|
         or    EvtWord[si],ax	;			             	[QN]|
				;				     	[QN]|
ModemStatus10:				;			     	[QN]|
        mov     al,OutHHSLines[si]      ;				[QN]|
        or      al,al                   ;				[QN]|
        jz      ModemStatus30           ;No H/W handshake on output  	[QN]|
        and     ch,al                   ;				[QN]|
        cmp     ch,al                   ;Lines set for Xmit?	     	[QN]|
        je      ModemStatus20           ;  Yes			     	[QN]|
        or      HSFlag[si],HHSDown      ;Show H/W lines have dropped 	[QN]|
        jmp     short ModemStatus30	;			     	[QN]|
					;			     	[QN]|
ModemStatus20:				;			     	[QN]|
        and     HSFlag[si],NOT HHSDown  ;			     	[QN]|
	call	KickTxINT		;		(ins 92.09.xx)	[QN]|
					;			     	[QN]|
ModemStatus30:				;			     	[QN]|
        mov	ax,EvtMask[si]		;Mask event signal		[QN]|
        and	EvtWord[si],ax  	;  that user need		[QN]|
					;				[QN]|
	pop	cx			;			     	[QN]|
	pop	ax			;			     	[QN]|
        ret				;		(ins 92.09.xx)	[QN]|
else    ; NEC_98
	add	dl,ACE_MSR-ACE_IIDR	;--> Modem Status Register
	in	al,dx
	mov	MSRShadow[si],al	;Save MSR data for others
	mov	ch,al			;Save a local copy

; Create the event mask for the delta signals

	mov	ah,al			;Just a lot of shifting
	shr	ax,1
	shr	ax,1
	shr	ah,1
	mov	cl,3
	shr	ax,cl
	and	ax,EV_CTS+EV_DSR+EV_RLSD+EV_Ring
	or	EvtWord[si],ax

	mov	ah,ch				       ;[rkh]...
	shr	ah,1
	shr	ah,1
	and	ax,EV_CTSS+EV_DSRS
	or	EvtWord[si],ax

	mov	ah,ch
	mov	cl,3
	shr	ah,cl
	and	ax,EV_RLSD
	or	EvtWord[si],ax

	mov	ah,ch
	mov	cl,3
	shl	ah,cl
	and	ax,EV_RingTe
	or	EvtWord[si],ax

	.errnz	   EV_CTS-0000000000001000b
	.errnz	   EV_DSR-0000000000010000b
	.errnz	  EV_RLSD-0000000000100000b
	.errnz	  EV_Ring-0000000100000000b

	.errnz	    EV_CTSS-0000010000000000b	    ;[rkh]
	.errnz	    EV_DSRS-0000100000000000b
	.errnz	   EV_RLSDS-0001000000000000b
	.errnz	  EV_RingTe-0010000000000000b

	.errnz	 ACE_DCTS-00000001b
	.errnz	 ACE_DDSR-00000010b
	.errnz	ACE_DRLSD-00001000b
	.errnz	   ACE_RI-01000000b

	.errnz	 ACE_TERI-00000100b		    ;[rkh]
	.errnz	  ACE_CTS-00010000b
	.errnz	  ACE_DSR-00100000b
	.errnz	 ACE_RLSD-10000000b

ModemStatus10:
	mov	al,OutHHSLines[si]	;Get output hardware handshake lines
	or	al,al			;Any lines that must be set?
	jz	ModemStatus40		;No hardware handshake on output
	and	ch,al			;Mask bits of interest
	cmp	ch,al			;Lines set for Xmit?
	je	ModemStatus20		;  Yes
	or	HSFlag[si],HHSDown	;Show hardware lines have dropped
ModemStatus30:
	jmp	InterruptLoop

ModemStatus40:
	jmp	InterruptLoop_ChkTx

; Lines are set for xmit.  Kick an xmit interrupt if needed

ModemStatus20:
	and	HSFlag[si],NOT (HHSDown OR HHSAlwaysDown)
					;Show hardware lines back up
	mov	cx,QOutCount[si]	;Output queue empty?
	jcxz	ModemStatus30		;  Yes, return to InterruptLoop
	jmp	FakeXmitEmpty		;Restart transmit
endif   ; NEC_98

ModemStatus endp

page

;------------------------------------------------------------------------------
;
;   ENTER:  AX = message #
;	    DS:SI -> DEB
notify_owner proc near

	or	[si.NotifyFlags], ax
	lea	di, [si+SIZE ComDEB]
	mov	ax, ds
	mov	es, ax
	mov	ax, BIH_API_Call_Back	; call immediate, or in protected mode
	mov	bx, 1			; force SYS VM, if enhanced mode
	mov	cx, _INTERRUPT
	mov	dx, IntCodeOFFSET callback_event
%OUT use equate
	push	ds
	push	si
	mov	si, 1			; low priority boost
	push	bp
	mov	bp, es:[di.BIS_Mode]
	call	es:[bp][di.BIS_User_Mode_API]
	pop	bp
	pop	si
	pop	ds
	ret

notify_owner endp

;------------------------------------------------------------------------------
;
;   ENTER:  ES:DI -> BIS
;
callback_event proc far
	lea	si, [di-SIZE ComDEB]
	mov	ax, es
	mov	ds, ax
ifdef   NEC_98
	mov	al, [si.NotifyFlagsLO]	;ins 94.12.02 KBNES
	and	al, al			;ins 94.12.02 KBNES
	jnz	@f			;ins 94.12.02 KBNES
	ret				;ins 94.12.02 KBNES
@@:					;ins 94.12.02 KBNES
endif   ; NEC_98
	mov	ax, [si.NotifyHandle]
	push	ax			; push hWnd
	mov	ax, WM_COMMNOTIFY
	push	ax			; push wMsg
	xor	ax, ax
	mov	al, [si.DCB_Id]
	push	ax			; push wParam = ComID
	xor	al, al
	push	ax			; push high word of lParam
	xchg	al, [si.NotifyFlagsLO]
	or	[si.NotifyFlagsHI], al
	push	ax			; push low word of lParam = event flags
	call	[lpPostMessage]
	ret
callback_event endp


PUBLIC TimerProc
TimerProc proc far

	push	ds
	mov	ax, _DATA
	mov	ds, ax
	assumes ds,data

	mov	ax, [activeCOMs]
	or	ax, ax
	jz	short tp_nonactive
	push	si
	mov	si, DataOFFSET COMptrs
	mov	cx, MAXCOM+1
tp_lp:
	push	si
	mov	si, [si]		; si -> ComDEB
	shr	ax, 1
	jnc	tp_lpend

	cmp	[si.RecvTrigger], -1	;Q: owner wants notification?
	je	short tp_lpend		;   N: skip notify
	cmp	[si.QInCount], 0	;Q: anything in input queue?
	je	short tp_lpend		;   N: skip notify
	test	[si.NotifyFlagsHI], CN_RECEIVE ;Q: timeout notify already given?
	jnz	short tp_lpend		;   N: skip notify

	xor	[si.NotifyFlagsHI], CN_Idle ;Q: first timer call?
	js	short tp_lpend		;   Y: skip notify

	push	ax
	push	cx
	mov	ax, CN_RECEIVE		;   N: notify owner
	call	notify_owner
	pop	cx
	pop	ax

tp_lpend:
	pop	si
	inc	si			; inc to ptr to next ComDEB
	inc	si
	or	ax, ax
	loopnz	tp_lp
	pop	si

tp_nonactive:
	pop	ds
	assumes ds,nothing
	ret

TimerProc endp
page

ifdef   NEC_98
;===========================================================================
;	System Timer Interrupt Routine
;
;			if ( QOutCount[si] != 0x0000 )
;				{
;				KickTx ();
;				}
;===========================================================================
public TickEntry1		;(ins 92.09.25)
public TickEntry2		;(ins 92.09.25)
public TickEntry3		;(ins 92.09.25)

TickEntry1	proc	far		;for COM1
	push	si			;
	push	ds			;
	push	ax			;
	mov	si,dataOFFSET Comm1	;
	mov	ax, _DATA		;
	mov	ds, ax
	jmp	short TickWork		;
					;
TickEntry2:				;for COM2
	push	si			;
	push	ds			;
	push	ax			;
	mov	si,dataOFFSET Comm2	;
	mov	ax, _DATA		;
	mov	ds, ax
	jmp	short TickWork		;
					;
TickEntry3:				;for COM3
	push	si			;
	push	ds			;
	push	ax			;
	mov	si,dataOFFSET Comm3	;
	mov	ax, _DATA		;
	mov	ds, ax
					;
public	TickWork			;
TickWork:				;
        cmp     QOutCount[si],wo 00h	;Does queue empty ?
	jz	TickNoWork		;  Yes : Goto Return
	push	dx			;
        call    KickTxINT               ;
	pop	dx			;

TickNoWork:				;
	pop	ax			;
	pop	ds			;
	pop	si			;
	ret				;
;(ins end 92.09.25)
TickEntry1	endp

page

;----------------------------Private-Routine----------------------------
; MSR Read
;-----------------------------------------------------------------------
public	MSR_READ_Call				;(ins 92.08.xx)
MSR_READ_Call	proc	far			;(ins 92.08.xx)
	call	 MSR_READ			;(ins 92.08.xx)
	ret					;(ins 92.08.xx)
MSR_READ_Call endp				;(ins 92.08.xx)

MSR_READ	PROC	NEAR
	push	cx			;
	push	ax			;
	mov	dx,StatusPort[si] 	; 8251 Status Port ( DSR )

	in	al,dx			; Read Status
	mov	ch,al			; save to CH
	mov	dx,ReadSigPort[si] 	; MODEM Status Port (CS,CD,CI)
	in	al,dx			; Read Status
					;---------------------------------
					; CD='a' CI='b' DR='c' CS='d'
					; a,b,c,d = ( 0 or 1 )
	mov	ah,al			;   [AH]   I    [AL]   I    [CH]
	xor	al,al			; bda?????    00000000    c???????
	and	ch,10000000b		; bda?????    00000000    c0000000
	and	ah,11100000b		; bda00000    00000000    c0000000
	rol	ah,1			; da00000b    00000000    c0000000
	rol	ah,1			; a00000bd    00000000    c0000000
	shr	ax,1			; 0a00000b    d0000000    c0000000
	shr	al,1			; 0a00000b    0d000000    c0000000
	or	al,ch			; 0a00000b    cd000000    c0000000
	shr	ax,1			; 00a00000    bcd00000    c0000000
	rol	ah,1			; 0a000000    bcd00000    c0000000
	rol	ah,1			; a0000000    bcd00000    c0000000
	rol	ah,1			; 0000000a    bcd00000    c0000000
	shr	ax,1			; 00000000    abcd0000    c0000000
					;
	mov	cl,al			; restore AL
	pop	ax			;
	xor	cl,11010000b		; Bit invert
	mov	ch,cl			; (CD,CS,CI is active Low )
	and	cl,0f0h			;
	xor	MSRShadow[si],cl	;
	shr	by MSRShadow[si],1	;
	shr	by MSRShadow[si],1	;
	shr	by MSRShadow[si],1	;
	shr	by MSRShadow[si],1	;
	or	MSRShadow[si],ch	;
	mov	al,MSRShadow[si]	;

	pop	cx			;

	call	ModemStatus		;Set Event Flag
	ret
MSR_READ	ENDP

;------------------------------------------------------------------------------
;	AOBA-bug	ins 94.11.19 KBNES
;------------------------------------------------------------------------------
public	AOBA_MSR_READ_Call
AOBA_MSR_READ_Call	proc	far
	call	 AOBA_MSR_READ
	ret
AOBA_MSR_READ_Call	endp

AOBA_MSR_READ	PROC	NEAR
	push	ax
	push	dx
        mov     dx,Port[si]             ;Get comm I/O port
        add     dl,ACE_MSR		;
        in      al,dx
        mov     MSRShadow[si],al        ;Save MSR data for others
	call	ModemStatus		;Set Event Flag
	pop	dx			;
	pop	ax			;
	ret
AOBA_MSR_READ	ENDP
;------------------------------------------------------------------------------
;	AOBA-bug	ins end 94.11.19 KBNES
;------------------------------------------------------------------------------

;----------------------------Private-Routine----------------------------;
;
; KickTxINT - Kick Transmitter
;
; "Kick" the transmitter interrupt routine into operation.
; If the Transmitter Holding Register isn't empty, then
; nothing needs to be done.  If it is empty, then the xmit
; interrupt needs to enabled in the IER.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	 KickTxINT 			;Public for debugging
KickTxINT   proc   near

	cmp	[si.DCB_id],ID_Com1	;Is This Com1 ID ?	(ins 92.08.xx)
	jne	KickTxINT5		;No, go to KickTx5	(ins 92.08.xx)
	mov	dx,MaskFFPort[si]	;F/F Port Mask Bit	(ins 92.08.xx)
	in	al,dx			;			(ins 92.08.xx)
	mov	MaskFFShadow[si],al	;Save the Old Mask bit	(ins 92.08.xx)
					;			(ins 92.08.xx)
KickTxINT5:				;			(ins 92.08.xx)
 	mov	al,MaskFFShadow[si] ;mask data(port C) save 	(ins 92.08.xx)
 	test	al,MSK_TXR		;(ins 93.06.18)
 	jnz	KickTxINT10		;  Enable		(ins 92.08.xx)

KickTxINT9:
 	or	al,MSK_TXR+MSK_RXR	;			(ins 93.06.18)
 	mov	dx,MaskFFPort[si]	;Port address (Port C)	(ins 92.08.xx)
	mov	MaskFFShadow[si],al	;Masking data save  	(ins 92.08.xx)
	out	dx,al			;Masking set		(ins 92.08.xx)
        ret				;			(ins 92.08.xx)

KickTxINT10:				;			(ins 92.08.xx)|
 	and	al,NOT(MSK_TXR+MSK_RXR)	;			(ins 93.06.18)
	mov	dx,MaskFFPort[si]	;Port address (Port C)	(ins 93.03.22)
	out	dx,al			;Masking set		(ins 93.03.22)
	NEWIODELAY 1			;<OUT 5F,AL>  		(ins 93.03.22)
	jmp	short KickTxINT9	;			(ins 93.03.22)
					;			(ins 93.03.22)
KickTxINT   endp

;--------------------------Interrupt Handler----------------------------
;
; AOBA_CommInt - Interrupt handler for com ports
;
; Interrupt handlers for PC com ports.  This is the communications
; interrupt service routine for RS232 communications.  When an RS232
; event occurs the interrupt vectors here.  This routine determines
; who the caller was and services the appropriate interrupt.  The
; interrupts are prioritized in the following order:
;
;     1.  line status interrupt
;     2.  read data available interrupt
;     3.  transmit buffer empty interrupt
;     4.  modem service interrupt
;
; This routine continues to service until all interrupts have been
; satisfied.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   AL = 0, if not handled, -1, if handled
;
;-----------------------------------------------------------------------

assumes ds,Data
assumes es,nothing

;   Dispatch table for interrupt types

SrvTab label word
        dw      OFFSET AOBA_ModemStatus      ;[0] Modem Status Interrupt
        dw      OFFSET AOBA_XmitEmpty        ;[2] Tx Holding Reg. Interrupt
        dw      OFFSET AOBA_DataAvail        ;[4] Rx Data Available Interrupt
                                             ;   or [C] if 16550 & 16550A
        dw      OFFSET AOBA_LineStat         ;[6] Reciever Line Status Interrupt


        public  AOBA_CommInt

AOBA_CommInt proc near

        xor     al, al
        cmp     word ptr [VCD_int_callback+4], 0
        je      short @F                        ; jump if no callback (not 3.1 VCD)
        test    [si.VCDflags], fCOM_ignore_ints ;Q: we still own port?
        jnz     AOBA_IntLoop40                       ;   N: ignore the int
.386
        push    esi
        mov     esi, [si.VCD_data]
        call    [VCD_int_callback]
        pop     esi
.8086
@@:

        push    dx
        mov     dx,Port[si]             ;Get comm I/O port
        add     dl,ACE_IIDR             ;--> Interrupt ID Register
        in      al, dx
        test    al, 1                   ;Q: interrupt pending?
        jnz     short AOBA_IntLoop30         ;   N:

        push    bx
        push    cx
        push    di
        push    es
        mov     cx, EvtWord[si]
        push    cx
        jmp     short AOBA_IntLoop10
public	AOBA_InterruptLoop_ChkTx
AOBA_InterruptLoop_ChkTx:
        cmp     QOutCount[si],0         ;Output queue empty?
        je      short AOBA_InterruptLoop     ;   Y: don't chk tx

	call	KickTxINT		;				(ins 94.04.16)
public	AOBA_InterruptLoop
AOBA_InterruptLoop:
        pop     dx                      ;Get ID reg I/O address

        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_IIDR             ;--> Interrupt ID Register	(ins 94.04.16)
        in      al,dx                   ;Get Interrupt Id
        test    al,1                    ;Interrupt need servicing?
        jnz     AOBA_IntLoop20               ;No, all done
public	AOBA_IntLoop10
AOBA_IntLoop10:
        and     ax, 07h
        mov     di,ax
        push    dx                      ;Save Id register
        jmp     SrvTab[di]              ;Service the Interrupt
public	AOBA_IntLoop20
AOBA_IntLoop20:
        mov     ax,EvtMask[si]          ;Mask the event word to only the
        and     ax, EvtWord[si]         ;  user specified bits
        mov     EvtWord[si], ax
        pop     bx
        test    [si.NotifyFlagsHI], CN_Notify
        jz      short AOBA_ci_exit
        not     bx
        and     ax, bx                  ; bits set in ax are new events
        jnz     short AOBA_ci_new_events
public	AOBA_ci_exit
AOBA_ci_exit:
        pop     es
        assumes es,nothing

        pop     di
        pop     cx
        pop     bx
        xor     al, al
public	AOBA_IntLoop30
AOBA_IntLoop30:
        pop     dx
        and     al, 1
        dec     al                      ; 0->-1, 1->0
public	AOBA_IntLoop40
AOBA_IntLoop40:
        ret

public	AOBA_ci_new_events
AOBA_ci_new_events:
        mov     ax, CN_EVENT
        call    notify_owner
        jmp     AOBA_ci_exit

public	AOBA_CommInt
AOBA_CommInt endp

page

;----------------------------Private-Routine----------------------------;
;
; AOBA_LineStat - Line Status Interrupt Handler
;
; Break detection is handled and set in the event word if
; enabled.  Other errors (overrun, parity, framing) are
; saved for the data available interrupt.
;
; This routine used to fall into DataAvail for the bulk of its processing.
; This is no longer the case...  A very popular internal modem seems to
; operate differently than a real 8250 when parity errors occur.  Falling
; into the DataAvail handler on a parity error caused the same character
; to be received twice.  Having this routine save the LSR status, and
; return to InterruptLoop fixes the problem, and still works on real COMM
; ports.  The extra overhead isn't a big deal since this routine is only
; entered when there is an exception like a parity error.
;
; This routine is jumped to, and will perform a jump back into
; the dispatch loop.
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,FLAGS
; History:
;-----------------------------------------------------------------------;


; assumes ds,Data
assumes es,nothing

public AOBA_LineStat                         ;Public for debugging
AOBA_LineStat proc near

        or      by EvtWord[si],EV_Err   ;Show line status error

        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_LSR             ;--> Line Status Register	(ins 94.04.16)

        in      al,dx
        test    al,ACE_PE+ACE_FE+ACE_OR ;Parity, Framing, Overrun error?
        jz      @f

        mov     LSRShadow[si],al        ;yes, save status for DataAvail
@@:
        test    al,ACE_BI               ;Break detect?
        jz      AOBA_InterruptLoop_ChkTx     ;Not break detect interrupt

        or      by EvtWord[si],EV_Break ;Show break

        jmp     short AOBA_InterruptLoop_ChkTx

AOBA_LineStat   endp

page

;----------------------------Private-Routine----------------------------;
;
; AOBA_DataAvail - Data Available Interrupt Handler
;
; The available character is read and stored in the input queue.
; If the queue has reached the point that a handshake is needed,
; one is issued (if enabled).  EOF detection, Line Status errors,
; and lots of other stuff is checked.
;
; This routine is jumped to, and will perform a jump back into
; the dispatch loop.
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

; assumes ds,Data
assumes es,nothing

public AOBA_DataAvail                       ;public for debugging
AOBA_DataAvail   proc   near

        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_RBR     		;--> receiver buffer register	(ins 94.04.16)
        in      al,dx                   ;Read received character

        and     [si.NotifyFlagsHI], NOT CN_Idle ; flag as not idle

        mov     ah,LSRShadow[si]        ;what did the last Line Status intrpt
        mov     bh,ah                   ;  have to say?
        or      ah,ah
        jz      @f

        and     ah,ErrorMask[si]        ;there was an error, record it
        or      by ComErr[si],ah
IFNDEF KKBUGFIX  ; 1/05/93:TakuA:Fix #1666
        mov     LSRShadow[si],0
ENDIF
@@:

; Regardless of the character received, flag the event in case
; the user wants to see it.

        or      by EvtWord[si],EV_RxChar ;Show a character received
        .errnz HIGH EV_RxChar

; Check the input queue, and see if there is room for another
; character.  If not, or if the end of file character has already
; been received, then go declare overflow.

public	AOBA_DataAvail00
AOBA_DataAvail00:
IFDEF KKBUGFIX  ; 1/05/93:TakuA:Fix #1666
        mov     bh,LSRShadow[si]
        mov     LSRShadow[si],0
ENDIF
        mov     cx,QInCount[si]         ;Get queue count (used later too)
        cmp     cx,QInSize[si]          ;Is queue full?
        jge     AOBA_DataAvail20             ;  Yes, comm overrun
        test    EFlags[si],fEOF         ;Has end of file been received?
        jnz     AOBA_DataAvail20             ;  Yes - treat as overflow

; Test to see if there was a parity error, and replace
; the character with the parity character if so

        test    bh,ACE_PE               ;Parity error
        jz      AOBA_DataAvail25             ;  No
        test    [si.DCB_Flags2],fPErrChar   ;Parity error replacement character?
        jz      AOBA_DataAvail25             ;  No
        mov     al,[si.DCB_PEChar]      ;  Yes, get parity replacement char

; Skip all other processing except event checking and the queing
; of the parity error replacement character

        jmp     short AOBA_DataAvail80       ;Skip all but event check, queing
public	AOBA_DataAvail20
AOBA_DataAvail20:
        or      by ComErr[si],CE_RXOVER ;Show queue overrun
        jmp     short AOBA_DataAvail50

; See if we need to strip null characters, and skip
; queueing if this is one.  Also remove any parity bits.

public	AOBA_DataAvail25
AOBA_DataAvail25:
        and     al,RxMask[si]           ;Remove any parity bits
        jnz     AOBA_DataAvail30             ;Not a Null character
        test    [si.DCB_Flags2],fNullStrip  ;Are we stripping received nulls?
        jnz     AOBA_DataAvail50             ;  Yes, put char in the bit bucket

; Check to see if we need to check for EOF characters, and if so
; see if this character is it.

public	AOBA_DataAvail30
AOBA_DataAvail30:
        test    [si.DCB_Flags],fBinary  ;Is this binary stuff?
        jnz     AOBA_DataAvail60             ;  Yes, skip EOF check
        cmp     al,[si.DCB_EOFChar]     ;Is this the EOF character?
        jnz     AOBA_DataAvail60             ;  No, see about queing the charcter
        or      EFlags[si],fEOF         ;Set end of file flag
public	AOBA_DataAvail50
AOBA_DataAvail50:
        jmp     AOBA_DataAvail140            ;Skip the queing process

; If output XOn/XOff is enabled, see if the character just received
; is either an XOn or XOff character.  If it is, then set or
; clear the XOffReceived flag as appropriate.

public	AOBA_DataAvail60
AOBA_DataAvail60:
        test    [si.DCB_Flags2],fOutX   ;Output handshaking?
        jz      AOBA_DataAvail80             ;  No
        cmp     al,[si.DCB_XoffChar]    ;Is this an X-Off character?
        jnz     AOBA_DataAvail70             ;  No, see about XOn or Ack
        or      HSFlag[si],XOffReceived ;Show XOff received, ENQ or ETX [rkh]
        test    [si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
        jz      AOBA_DataAvail50             ;  No
        cmp     cx,[si.DCB_XonLim]      ;See if at XOn limit
        ja      AOBA_DataAvail50             ;  No
        and     HSFlag[si],NOT XOffReceived ;Show ENQ or ETX not received
        and     HSFlag[si], NOT XOnPending+XOffSent
        mov     al, [si.DCB_XonChar]
        call    AOBA_OutHandshakingChar
        jmp     AOBA_DataAvail50             ;Done

public	AOBA_DataAvail70
AOBA_DataAvail70:
        cmp     al,[si.DCB_XonChar]     ;Is this an XOn character?
        jnz     AOBA_DataAvail80             ;  No, just a normal character
        and     HSFlag[si],NOT XOffReceived
        test    [si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
        jz      AOBA_DataAvail75             ;  No - jump to FakeXmitEmpty to get
                                        ;       transmitting going again
        and     HSFlag[si],NOT EnqSent

public	AOBA_DataAvail75
AOBA_DataAvail75:
        jmp     AOBA_FakeXmitEmpty           ;Restart transmit

; Now see if this is a character for which we need to set an event as
; having occured. If it is, then set the appropriate event flag

public	AOBA_DataAvail80
AOBA_DataAvail80:
        cmp     al,[si.DCB_EVTChar]     ;Is it the event generating character?
        jne     AOBA_DataAvail90             ;  No
        or      by EvtWord[si],EV_RxFlag   ;Show received specific character

; Finally, a valid character that we want to keep, and we have
; room in the queue. Place the character in the queue.
; If the discard flag is set, then discard the character

public	AOBA_DataAvail90
AOBA_DataAvail90:
        test    MiscFlags[si], Discard  ;Discarding characters ?
        jnz     AOBA_DataAvail50             ;  Yes

        lea     bx, [si+SIZE ComDEB]    ; DS:BX -> BIS
        mov     bx, [bx.BIS_Mode]       ; mode will be either 0 or 4
        les     di,QInAddr[si][bx]      ;Get queue base pointer from either
        assumes es,nothing              ;   QInAddr or AltQInAddr

        mov     bx,QInPut[si]           ;Get index into queue
        mov     es:[bx][di],al          ;Store the character
        inc     bx                      ;Update queue index
        cmp     bx,QInSize[si]          ;See if time for wrap-around
        jc      AOBA_DataAvail100            ;Not time to wrap
        xor     bx,bx                   ;Wrap-around is a new zero pointer

public	AOBA_DataAvail100
AOBA_DataAvail100:
        mov     QInPut[si],bx           ;Store updated pointer
        inc     cx                      ;And update queue population
        mov     QInCount[si],cx

; If flow control has been enabled, see if we are within the
; limit that requires us to halt the host's transmissions

        cmp     cx,XOffPoint[si]        ;Time to see about XOff?
        jc      AOBA_DataAvail120            ;  Not yet
        test    HSFlag[si],HSSent       ;Handshake already sent?
        jnz     AOBA_DataAvail120            ;  Yes, don't send it again

        mov     ah,HHSLines[si]         ;Should hardware lines be dropped?
        or      ah,ah                   ;  (i.e. do we have HW HS enabled?)
        jz      AOBA_DataAvail110            ;  No
;[QN]---------------------------------------------------------------------------+
	mov	al,CommandShadow[si] ;8251 Command get    	(ins 94.04.16)	|
	test	ah,ACE_DTR	     ;DTR handshake Enable ?	(ins 94.04.16)	|
	jz	AOBA_DataAvail101	     ;  No		(ins 94.04.16)	|
	and	al,not DTR	     ;Clear 8251's DTR Line ! 	(ins 94.04.16)	|
public	AOBA_DataAvail101
AOBA_DataAvail101:			     ;			(ins 94.04.16)	|
	test	ah,ACE_RTS	     ;RTS handshake Enable ?	(ins 94.04.16)	|
	jz	AOBA_DataAvail102	     ;  No		(ins 94.04.16)	|
	and	al,not RTS	     ;Clear 8251's RTS Line !	(ins 94.04.16)	|
public	AOBA_DataAvail102
AOBA_DataAvail102:			     ;			(ins 94.04.16)	|
	mov	dx,CommandPort[si]   ;GET Command port address	(ins 94.04.16)	|
	call	int_Set8251mode      ;Change to 8251 mode	(ins 94.04.16)	|
	out	dx,al		     ;				(ins 94.04.16)	|
	call	int_SetFIFOmode      ;Change to FIFO mode	(ins 94.04.16)	|
	mov	CommandShadow[si],al ;Get Back 8251 Command 	(ins 94.04.16)	|
	or	HSFlag[si],HHSDropped  ;  			(ins 94.04.16)	|
;[QN]---------------------------------------------------------------------------+

public	AOBA_DataAvail110
AOBA_DataAvail110:
        test    [si.DCB_Flags2],fInX    ;Input Xon/XOff handshaking
        jz      AOBA_DataAvail120            ;  No
        or      HSFlag[si], XOffSent
        mov     al, [si.DCB_XoffChar]
        call    AOBA_OutHandshakingChar

public	AOBA_DataAvail120
AOBA_DataAvail120:
        cmp     cx, [si.RecvTrigger]    ;Q: time to call owner's callback?
        jb      short AOBA_DataAvail130      ;   N:

        test    [si.NotifyFlagsHI], CN_RECEIVE
        jnz     short AOBA_DataAvail140      ; jump if notify already sent and
                                        ;   data in buffer hasn't dropped
                                        ;   below threshold
        mov     ax, IntCodeOFFSET AOBA_DataAvail140
        push    ax
        mov     ax, CN_RECEIVE
%OUT probably should just set a flag and notify after EOI
        jmp     notify_owner

public	AOBA_DataAvail130
AOBA_DataAvail130:
        and     [si.NotifyFlagsHI], NOT CN_RECEIVE

public	AOBA_DataAvail140
AOBA_DataAvail140:
        pop     dx
        push    dx
        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_LSR		;				(ins 94.04.16)
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        in      al, dx
        test    al, ACE_DR              ;Q: more data available?
        jz      @F                      ;   N:
        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_RBR		;				(ins 94.04.16)
        in      al, dx                  ;Read available character
        jmp     AOBA_DataAvail00
@@:
        jmp     AOBA_InterruptLoop_ChkTx

AOBA_DataAvail endp


public	AOBA_OutHandshakingChar
AOBA_OutHandshakingChar proc near

        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_LSR		;				(ins 94.04.16)
        mov     ah, al
@@:
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        in      al, dx
        test    al,ACE_TSRE			;			(ins 94.05.17)
        jz      @B
        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_THR		;				(ins 94.04.16)
        mov     al, ah
        out     dx, al
        ret

AOBA_OutHandshakingChar endp


page

;----------------------------Private-Routine----------------------------;
;
; AOBA_XmitEmpty - Transmitter Register Empty
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

; assumes ds,Data
assumes es,nothing

public AOBA_FakeXmitEmpty
AOBA_FakeXmitEmpty:
        pop     dx
        push    dx

; "Kick" the transmitter interrupt routine into operation.
	call	KickTxINT		;Bug fixed PC-11419 AutoCAD	(ins 94.09.07)
        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_LSR		;				(ins 94.04.16)
	NEWIODELAY 1			;<OUT 5F,AL>  			(ins 94.04.18)
        in      al,dx                   ;Is xmit really empty?
        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_THR      	;--> Transmitter Holding Register(ins 94.04.16)
        test    al,ACE_TSRE			;			(ins 94.05.17)
        jnz     short AOBA_XmitEmpty5        ;   Y: send next char
        jmp     AOBA_InterruptLoop           ;   N: return to processing loop

public AOBA_XmitEmpty
AOBA_XmitEmpty proc near

	call	AOBA_MSR_READ		;AOBA-bug del 94.11.19 KBNES
        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_LSR		;--> Line Status Register	(ins 94.04.16)
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        out	5fh,al			;				(ins 94.05.18)
        in      al,dx                   ;Is xmit really empty?
        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_THR      	;--> Transmitter Holding Register(ins 94.04.16)
        test    al,ACE_TSRE			;			(ins 94.05.17)
        jz      AOBA_Xmit_jumpto90           ;Transmitter not empty, cannot send

; If the hardware handshake lines are down, then XOff/XOn cannot
; be sent.  If they are up and XOff/XOn has been received, still
; allow us to transmit an XOff/XOn character.  It will make
; a dead lock situation less possible (even though there are
; some which could happen that cannot be handled).

public	AOBA_XmitEmpty5
AOBA_XmitEmpty5:
        mov     ah,HSFlag[si]           ;Get handshaking flag
        test    ah,HHSDown+BreakSet     ;Hardware lines down or break set?
        jnz     AOBA_Xmit_jumpto100          ;  Yes, cannot transmit

; Give priority to any handshake character waiting to be
; sent.  If there are none, then check to see if there is
; an "immediate" character to be sent.  If not, try the queue.

public	AOBA_XmitEmpty10
AOBA_XmitEmpty10:
        test    [si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
        jnz     AOBA_XmitEmpty40             ;  Yes

public	AOBA_XmitEmpty15
AOBA_XmitEmpty15:
        test    ah,HSPending            ;XOff or XOn pending
        jz      AOBA_XmitEmpty40             ;  No

public	AOBA_XmitEmpty20
AOBA_XmitEmpty20:
        and     ah,NOT XOnPending+XOffSent
        mov     al,[si.DCB_XonChar]     ;Get XOn character

public	AOBA_XmitEmpty30
AOBA_XmitEmpty30:
        mov     HSFlag[si],ah           ;Save updated handshake flag
        jmp     AOBA_XmitEmpty110            ;Go output the character

public	AOBA_Xmit_jumpto90
AOBA_Xmit_jumpto90:
        jmp     AOBA_XmitEmpty90

; If any of the lines which were specified for a timeout are low, then
; don't send any characters.  Note that by putting the check here,
; XOff and Xon can still be sent even though the lines might be low.

; Also test to see if a software handshake was received.  If so,
; then transmission cannot continue.  By delaying the software check
; to here, XOn/XOff can still be issued even though the host told
; us to stop transmission.

public	AOBA_XmitEmpty40
AOBA_XmitEmpty40:
        test    ah,CannotXmit           ;Anything preventing transmission?
        jz      AOBA_XmitEmpty45             ;  No

public	AOBA_Xmit_jumpto100
AOBA_Xmit_jumpto100:
        jmp     AOBA_XmitEmpty100            ;  Yes, disarm and exit

; If a character has been placed in the single character "transmit
; immediately" buffer, clear that flag and pick up that character
; without affecting the transmitt queue.

public	AOBA_XmitEmpty45
AOBA_XmitEmpty45:
        test    EFlags[si],fTxImmed     ;Character to xmit immediately?
        jz      AOBA_XmitEmpty515            ;  No, try the queue
        and     EFlags[si],NOT fTxImmed ;Clear xmit immediate flag
        mov     al,ImmedChar[si]        ;Get char to xmit
        jmp     AOBA_XmitEmpty110            ;Transmit the character

public	AOBA_XmitEmpty515
AOBA_XmitEmpty515:
        mov     cx,QOutCount[si]        ;Output queue empty?
        jcxz    AOBA_Xmit_jumpto90           ;  Yes, go set an event

        test    [si.DCB_Flags],fEtxAck  ;Etx Ack?
        jz      AOBA_XmitEmpty55             ;  No
        mov     cx,QOutMod[si]          ;Get number bytes sent since last ETX
        cmp     cx,[si.DCB_XonLim]      ;At Etx limit yet?
        jne     AOBA_XmitEmpty51             ;  No, inc counter
        mov     QOutMod[si],0           ;  Yes, zero counter
        or      HSFlag[si],EtxSent      ;Show ETX sent
        jmp     short AOBA_XE_sendXOFF

public	AOBA_XmitEmpty51
AOBA_XmitEmpty51:
        inc     cx                      ; Update counter
        mov     QOutMod[si],cx          ; Save counter
        jmp     short AOBA_XmitEmpty59       ; Send queue character

public	AOBA_XmitEmpty55
AOBA_XmitEmpty55:
        test    [si.DCB_Flags],fEnqAck  ;Enq Ack?
        jz      AOBA_XmitEmpty59             ;  No, send queue character
        mov     cx,QOutMod[si]          ;Get number bytes sent since last ENQ
        or      cx,cx                   ;At the front again?
        jnz     AOBA_XmitEmpty56             ;  No, inc counter
        mov     QOutMod[si],1           ;  Yes, send ENQ
        or      HSFlag[si],EnqSent      ;Show ENQ sent
public	AOBA_XE_sendXOFF
AOBA_XE_sendXOFF:
        mov     al,[si.DCB_XoffChar]
        jmp     short AOBA_XmitEmpty110      ;Go output the character

public	AOBA_XmitEmpty56
AOBA_XmitEmpty56:
        inc     cx                      ;Update counter
        cmp     cx,[si.DCB_XonLim]      ;At end of our out buffer len?
        jne     AOBA_XmitEmpty58             ;  No
        xor     cx,cx                   ;Show at front again.

public	AOBA_XmitEmpty58
AOBA_XmitEmpty58:
        mov     QOutMod[si],cx          ;Save counter

public	AOBA_XmitEmpty59
AOBA_XmitEmpty59:
        lea     bx, [si+SIZE ComDEB]    ; DS:BX -> BIS
        mov     bx, [bx.BIS_Mode]       ; mode will be either 0 or 4
        les     di,QOutAddr[si][bx]     ;Get queue base pointer from either
        assumes es,nothing              ;   QOutAddr or AltQOutAddr

        mov     bx,QOutGet[si]          ;Get pointer into queue
        mov     al,es:[bx][di]          ;Get the character

        inc     bx                      ;Update queue pointer
        cmp     bx,QOutSize[si]         ;See if time for wrap-around
        jc      AOBA_XmitEmpty60             ;Not time for wrap
        xor     bx,bx                   ;Wrap by zeroing the index

public	AOBA_XmitEmpty60
AOBA_XmitEmpty60:
        mov     QOutGet[si],bx          ;Save queue index
        mov     cx,QOutCount[si]        ;Output queue empty?
        dec     cx                      ;Dec # of bytes in queue
        mov     QOutCount[si],cx        ;  and save new population

        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_THR		;				(ins 94.04.16)

        out     dx,al                   ;Send char

        cmp     cx, [si.SendTrigger]    ;Q: time to call owner's callback?
        jae     short AOBA_XmitEmpty70       ;   N:

        test    [si.NotifyFlagsHI], CN_TRANSMIT
        jnz     short AOBA_XmitEmpty80       ; jump if notify already sent and
                                        ;   data in buffer hasn't raised
                                        ;   above threshold
        mov     ax, IntCodeOFFSET AOBA_XmitEmpty80
        push    ax
        mov     ax, CN_TRANSMIT
        jmp     notify_owner

public	AOBA_XmitEmpty70
AOBA_XmitEmpty70:
        and     [si.NotifyFlagsHI], NOT CN_TRANSMIT

public	AOBA_XmitEmpty80
AOBA_XmitEmpty80:
%OUT check fNoFIFO in EFlags[si] to determine if we can queue more output
        jmp     AOBA_InterruptLoop


; No more characters to transmit.  Flag this as an event.

public	AOBA_XmitEmpty90
AOBA_XmitEmpty90:
        or      by EvtWord[si],EV_TxEmpty

; Cannot continue transmitting (for any of a number of reasons).
; Disable the transmit interrupt.  When it's time resume, the
; transmit interrupt will be reenabled, which will generate an
; interrupt.

public	AOBA_XmitEmpty100
AOBA_XmitEmpty100:
;[QN]-------------------------------------------------------------------------+
	cmp	[si.DCB_id],ID_Com1	;Is This Com1 ID ?	(ins 94.05.19)|
	jne	AOBA_XmitEmpty102	;No, go to KickTx5	(ins 94.05.19)|
	mov	dx,MaskFFPort[si]	;F/F Port Mask Bit	(ins 94.05.19)|
	in	al,dx			;			(ins 94.05.19)|
	mov	MaskFFShadow[si],al	;Save the Old Mask bit	(ins 94.05.19)|
					;			(ins 94.05.19)|
AOBA_XmitEmpty102:			;			(ins 94.05.19)|
 	mov	al,MaskFFShadow[si] ;mask data(port C) save 	(ins 94.05.19)|
 	test	al,MSK_TXR		;Check a tx.RDY INT mask(ins 94.05.19)|
 	jz	AOBA_XmitEmpty110	;  disable		(ins 94.05.19)|
 	and	al,NOT(MSK_TXE+MSK_TXR)	;= 11111001b		(ins 94.05.19)|
	mov	dx,MaskFFPort[si]	;Port address (Port C)	(ins 94.05.19)|
	mov	MaskFFShadow[si],al	;Masking data save  	(ins 94.05.19)|
;-----------------------------------------------------------------------------+
public	AOBA_XmitEmpty110
AOBA_XmitEmpty110:
	out	dx,al
        jmp     AOBA_InterruptLoop

AOBA_XmitEmpty endp

page

;----------------------------Private-Routine----------------------------;
;
; AOBA_ModemStatus - Modem Status Interrupt Handler
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;


; assumes ds,Data
assumes es,nothing

public AOBA_ModemStatus                     ;Public for debugging
AOBA_ModemStatus proc near

; Get the modem status value and shadow it for MSRWait.

        mov     dx,Port[si]             ;Get comm I/O port		(ins 94.04.16)
        add     dl,ACE_MSR		;				(ins 94.04.16)

        in      al,dx
        mov     MSRShadow[si],al        ;Save MSR data for others
        mov     ch,al                   ;Save a local copy

; Create the event mask for the delta signals

        mov     ah,al                   ;Just a lot of shifting
        shr     ax,1
        shr     ax,1
        shr     ah,1
        mov     cl,3
        shr     ax,cl
        and     ax,EV_CTS+EV_DSR+EV_RLSD+EV_Ring
        or      EvtWord[si],ax

        mov     ah,ch                                  ;[rkh]...
        shr     ah,1
        shr     ah,1
        and     ax,EV_CTSS+EV_DSRS
        or      EvtWord[si],ax

        mov     ah,ch
        mov     cl,3
        shr     ah,cl
        and     ax,EV_RLSD
        or      EvtWord[si],ax

        mov     ah,ch
        mov     cl,3
        shl     ah,cl
        and     ax,EV_RingTe
        or      EvtWord[si],ax

public	AOBA_ModemStatus10
AOBA_ModemStatus10:
        mov     al,OutHHSLines[si]      ;Get output hardware handshake lines
        or      al,al                   ;Any lines that must be set?
        jz      AOBA_ModemStatus40           ;No hardware handshake on output
        and     ch,al                   ;Mask bits of interest
        cmp     ch,al                   ;Lines set for Xmit?
        je      AOBA_ModemStatus20           ;  Yes
        or      HSFlag[si],HHSDown      ;Show hardware lines have dropped

public	AOBA_ModemStatus30
AOBA_ModemStatus30:
        jmp     AOBA_InterruptLoop

public	AOBA_ModemStatus40
AOBA_ModemStatus40:
        jmp     AOBA_InterruptLoop_ChkTx

; Lines are set for xmit.  Kick an xmit interrupt if needed

public	AOBA_ModemStatus20
AOBA_ModemStatus20:
        and     HSFlag[si],NOT (HHSDown OR HHSAlwaysDown)
                                        ;Show hardware lines back up
        mov     cx,QOutCount[si]        ;Output queue empty?
        jcxz    AOBA_ModemStatus30           ;  Yes, return to InterruptLoop
        jmp     AOBA_FakeXmitEmpty           ;Restart transmit

AOBA_ModemStatus endp

;-----------------------------Public-Routine----------------------------;
;  int_Set8251mode - Change to 8251 mode
;
; Entry:
;   
; Returns:
;   
; Error Returns:
;   NONE
; Registers Destroyed:
;   NONE
; History:						QNES 	T-MATUDA
;-----------------------------------------------------------------------;
int_Set8251mode	proc near		
	push	dx			;
	push	ax			;
	mov	dx,Port[si]		;
	add	dx,ACE_FCR		;
	in	al, dx			;
	NEWIODELAY 3			;	<OUT 5F,AL>
	test	al, 01h			;
	jz	int_running_fifo_mode	;

	and	al, 0feh
	out	dx,al			;
	NEWIODELAY 3			;	<OUT 5F,AL>
@@:					;
	in	al,dx			;
	NEWIODELAY 3			;	<OUT 5F,AL>
	test	al,ACE_EFIFO		;
	jnz	@B			;
int_running_fifo_mode:			;
	pop	ax			;
	pop	dx			;
	ret
int_Set8251mode   endp

;-----------------------------Public-Routine----------------------------;
;  int_SetFIFOmode - Change to FIFO mode
;
; Entry:
;   
; Returns:
;   
; Error Returns:
;   NONE
; Registers Destroyed:
;   NONE
; History:						QNES 	T-MATUDA
;-----------------------------------------------------------------------;
int_SetFIFOmode	proc near		
	push	dx			;
	push	ax			;
	mov	dx,Port[si]		;
	add	dx,ACE_FCR		;
	in	al, dx			;
	NEWIODELAY 3			;	<OUT 5F,AL>
	test	al, 01h			;
	jnz	int_running_8251_mode	;

;Set_FIFO == RLInt_Enable + ACE_TRIG14 + ACE_EFIFO
	mov	al,Set_FIFO		;set FIFO mode
	out	dx,al			;
	NEWIODELAY 3			;	<OUT 5F,AL>
int_running_8251_mode:			;
	pop	ax			;
	pop	dx			;
	ret
int_SetFIFOmode   endp

TOMOE_PAT	DB	16 DUP('PATCH !!')	;PATCH AREA (ins 92.11.11)
endif   ; NEC_98

ifdef DEBUG
	public	Control, DEF_Handler, COMHandler, APIHandler
	public	InterruptLoop, IntLoop10, IntLoop20
	public	DataAvail25, DataAvail30, DataAvail50
	public	DataAvail60, DataAvail70, DataAvail80, DataAvail90
	public	DataAvail100, DataAvail110, DataAvail120
	public	DataAvail130, DataAvail140, OutHandshakingChar
	public	XmitEmpty10, XmitEmpty20, XmitEmpty30, XmitEmpty40
	public	XmitEmpty59, XmitEmpty60
	public	XmitEmpty90, XmitEmpty100, XmitEmpty110
	public	ModemStatus10, ModemStatus20, ModemStatus30
	public	notify_owner, callback_event
endif

DOSTI proc    near
      FSTI
      ret
DOSTI endp

DOCLI proc    near
      FCLI
      ret
DOCLI endp



sEnd   IntCode
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\comdev.inc ===
;
; Include code from comm
;

include ..\comm\comdev.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\ins8250.inc ===
; INS8250 ACE Register Offsets And Bit Definitions


ACE_RBR         equ     0               ;Receiver Buffer
ACE_THR         equ     0               ;Transmit Holding Register

ACE_IER         equ     1               ;Interrupt Enable
  ACE_ERBFI     equ     00000001b       ;  Received Data Available
  ACE_ETBEI     equ     00000010b       ;  Transmitter Holding Register Empty
  ACE_ELSI      equ     00000100b       ;  Receiver Line Status
  ACE_EDSSI	equ	00001000b	;  Modem Status

ifdef   NEC_98
ACE_FCR 	equ	8		;FIFO control register
  ACE_EFIFO	equ	00000001b	;  Enable FIFO
  ACE_CRFIFO	equ	00000010b	;  Clear receive FIFO queue
  ACE_CTFIFO	equ	00000100b	;  Clear transmit FIFO queue
  RLInt_Enable	equ	00001000b	;  Receiver Line Status
  MSInt_Enable	equ	00010000b	;  Modem Status
  ACE_TRIG01	equ	00000000b	;  Trigger receive int on every char
  ACE_TRIG04	equ	01000000b	;  Trigger receive int on every 4th char
  ACE_TRIG08	equ	10000000b	;  Trigger receive int on every 8th char
  ACE_TRIG14	equ	11000000b	;  Trigger receive int on every 14th char
else    ; NEC_98
ACE_FCR 	equ	2		;FIFO control register
  ACE_EFIFO	equ	00000001b	;  Enable FIFO
  ACE_CRFIFO	equ	00000010b	;  Clear receive FIFO queue
  ACE_CTFIFO	equ	00000100b	;  Clear transmit FIFO queue
  ACE_TRIG01	equ	00000000b	;  Trigger receive int on every char
  ACE_TRIG04	equ	01000000b	;  Trigger receive int on every 4th char
  ACE_TRIG08	equ	10000000b	;  Trigger receive int on every 8th char
  ACE_TRIG14	equ	11000000b	;  Trigger receive int on every 14th char
endif   ; NEC_98

ifdef   NEC_98
ACE_IIDR        equ     6               ;Interrupt Identification
  ACE_IIP       equ     00000001b       ;  Inverted Interrupt Pending (0=int)
  ACE_IID       equ     00000110b       ;  Interrupt ID
  ACE_MSI       equ     00000000b       ;  Modem Status
  ACE_THREI     equ     00000010b       ;  Transmitter Holding Register Empty
  ACE_RDAI      equ     00000100b       ;  Received Data Available
  ACE_RLSI      equ     00000110b       ;  Receiver Line Status
  AOBA_RECTO	equ	00001000b	;  Receive Charactor Time-out
  AOBA_PRS0	equ	00100000b	;  AOBA Present
  AOBA_PRS1	equ	01000000b	;  AOBA Present
else    ; NEC_98
ACE_IIDR        equ     2               ;Interrupt Identification
  ACE_IIP       equ     00000001b       ;  Inverted Interrupt Pending (0=int)
  ACE_IID       equ     00000110b       ;  Interrupt ID
  ACE_MSI       equ     00000000b       ;  Modem Status
  ACE_THREI     equ     00000010b       ;  Transmitter Holding Register Empty
  ACE_RDAI      equ     00000100b       ;  Received Data Available
  ACE_RLSI      equ     00000110b       ;  Receiver Line Status
  ACE_FIFO_E1	equ	01000000b	;set, if FIFO enabled on 16550A
  ACE_FIFO_E2	equ	10000000b	;set, if FIFO enabled on 16550 or 16550A
endif   ; NEC_98

ACE_LCR         equ     3               ;Line Control
  ACE_WLS       equ     00000011b       ;  Word Length Select Bits
  ACE_WLS0      equ     00000001b       ;  Word Length Select Bit 0
  ACE_WLS1      equ     00000010b       ;  Word Length Select Bit 1
  ACE_5BW       equ     00000000b       ;  5 Bit Words
  ACE_6BW       equ     00000001b       ;  6 Bit Words
  ACE_7BW       equ     00000010b       ;  7 Bit Words
  ACE_8BW       equ     00000011b       ;  8 Bit Words
  ACE_STB       equ     00000100b       ;  Stop Bits
  ACE_1SB       equ     00000000b       ;  1 Stop Bits (1.5 for 5 bit words)
  ACE_2SB       equ     00000100b       ;  2 Stop Bits
  ACE_PEN       equ     00001000b       ;  Parity Enable
  ACE_PSB       equ     00110000b       ;  Parity select bits
  ACE_EPS       equ     00010000b       ;  Even Parity Select
  ACE_SP        equ     00100000b       ;  Stick Parity
  ACE_SB        equ     01000000b       ;  Set Break
  ACE_DLAB      equ     10000000b       ;  Divisor Latch Access Bit

ACE_MCR         equ     4               ;Modem Control
  ACE_DTR       equ     00000001b       ;  Data Terminal ready
  ACE_RTS       equ     00000010b       ;  Request To Send
  ACE_OUT1      equ     00000100b       ;  Output Line 1
  ACE_OUT2      equ     00001000b       ;  Output Line 2
  ACE_LOOP      equ     00010000b       ;  Loopback

ifdef   NEC_98
ACE_LSR         equ     2               ;Line Status
  ACE_THRE      equ     00000001b       ;  Send FIFO and CCU Send Register All Empty
  ACE_TSRE      equ     00000010b       ;  Send FIFO Empty
  ACE_DR        equ     00000100b       ;  FIFO Data Enable
  ACE_PE        equ     00001000b       ;  Parity Error with Current FIFOed Data
  ACE_OR        equ     00010000b       ;  CCU Overrun Error
  ACE_FE        equ     00100000b       ;  Framing Error with Current FIFOed Data
  ACE_BI        equ     01000000b       ;  Break/SYNC with Current FIFOed Data
  AOBA_ERF1     equ     10000000b       ;  Error in Receive FIFO
else    ; NEC_98
ACE_LSR         equ     5               ;Line Status
  ACE_DR        equ     00000001b       ;  Data Ready
  ACE_OR        equ     00000010b       ;  Overrun Error
  ACE_PE        equ     00000100b       ;  Parity Error
  ACE_FE        equ     00001000b       ;  Framing Error
  ACE_BI        equ     00010000b       ;  Break Interrupt
  ACE_THRE      equ     00100000b       ;  Transmitter Holding Register Empty
  ACE_TSRE      equ     01000000b       ;  Transmitter Shift Register Empty
endif   ; NEC_98

ifdef   NEC_98
ACE_MSR         equ     4               ;Modem Status
else    ; NEC_98
ACE_MSR         equ     6               ;Modem Status
endif   ; NEC_98
  ACE_DCTS      equ     00000001b       ;  Delta Clear to Send
  ACE_DDSR      equ     00000010b       ;  Delta Data Set Ready
  ACE_TERI      equ     00000100b       ;  Trailing Edge Ring Indicator
  ACE_DRLSD     equ     00001000b       ;  Delta Receive Line Signal Detect
  ACE_CTS       equ     00010000b       ;  Clear To Send
  ACE_DSR       equ     00100000b       ;  Data Set ready
  ACE_RI        equ     01000000b       ;  Ring Indicator
  ACE_RLSD      equ     10000000b       ;  Receive Line Signal Detect

ACE_DLL         equ     0               ;LSB Baud Rate Divisor

ACE_DLM         equ     1               ;MSB Baud Rate Divisor

ifdef   NEC_98
NOT_ACE_EFIFO	equ	11111110b	;  disable FIFO
;------------------------------------------------------------------------------
;	AOBA-bug	ins 94.11.19 KBNES
;------------------------------------------------------------------------------
FIFO_Set_Buf_Clr	equ	RLInt_Enable OR ACE_TRIG04 OR ACE_EFIFO OR ACE_CRFIFO OR ACE_CTFIFO
Set_FIFO		equ	RLInt_Enable OR ACE_TRIG04 OR ACE_EFIFO
Set_8251		equ	RLInt_Enable OR ACE_TRIG04
;------------------------------------------------------------------------------
;	AOBA-bug	ins end 94.11.19 KBNES
;------------------------------------------------------------------------------
endif   ; NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm1\ibmsetup.asm ===
page,132
;---------------------------Module-Header-------------------------------;
; Module Name: IBMSETUP.ASM
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; General Description:
;
; History:
;   sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;           FCLI/FSTI macros
;
;-----------------------------------------------------------------------;

title   IBMSetup - IBM PC, PC-XT, PC-AT, PS/2 Communications Interface

.xlist
include cmacros.inc
include comdev.inc
include ins8250.inc
include ibmcom.inc
include BIMODINT.INC
include vint.inc
.list


EBIS_Sel1   equ SIZE Bimodal_Int_Struc
EBIS_Sel2   equ EBIS_Sel1 + (SIZE EBIS_Sel_Struc)

externA  __WinFlags

externFP GetSystemMsecCount
externFP CreateSystemTimer
externFP AllocCStoDSAlias
externFP LockSegment
externFP UnlockSegment
externFP FreeSelector
externFP GetSelectorBase
externFP GetModuleHandle
externFP GetProcAddress
externFP GetPrivateProfileInt
externFP GetPrivateProfileString
externFP GetAppCompatFlags
ifdef   NEC_98
externFP KillSystemTimer                        ; (ins 92.xx.xx)        |
externFP TickEntry1                             ; (ins 92.09.25)        |
externFP TickEntry2                             ; (ins 92.09.25)        |
externFP TickEntry3                             ; (ins 92.09.25)        |
externNP INT_1AH_call                           ; (ins 92.xx.xx)                |
externNP INT_1AH_Close                          ; (ins 93.10.13)                |
externFP MSR_READ_Call                          ; (ins 92.xx.xx)                |
else    ; NEC_98
externFP WowCloseComPort
endif   ; NEC_98

externNP $RECCOM

externA  __0040H
externA  __F000h

externB  IRQhooks

IF 0
externD  OldIntVecIntB
externD  OldIntVecIntC
externD  OurIntVecIntB
externD  OurIntVecIntC
ENDIF

externB  szMessage
externB  pLPTByte
externB  szCOMMessage
externB  pCOMByte
externB  _szTitle


MULTIPLEX   equ       2Fh       ; multiplex interrupt number
GET386API   equ     1684h       ; Get API entry point from VxD
VPD     equ     000Fh       ; device ID of VPD device
VPD_GETPORT equ     0004h       ; function: assign port to current VM
VPD_RELPORT equ     0005h       ; function: release port
ifdef   NEC_98
VPD_GETVER  equ     0000h       ; get version API               (ins 94.02.24)  |
endif   ; NEC_98
VCD     equ     000Eh       ; device ID of VCD device
VCD_GETVER  equ     0000h       ; get version API
VCD_GETPORT equ     0004h       ; function: assign port to current VM
VCD_RELPORT equ     0005h       ; function: release port
VCD_STEALPORT equ   0006h
VPICD       equ     0003h       ; device ID of VPICD device

POSTMESSAGE equ     110         ; export ordinal of PostMessage()
MESSAGEBOX  equ     1           ; export ordinal of MessageBox()
MB_TASKMODAL equ    2000h
MB_YESNO    equ     0004h       ; messagebox flags
MB_ICONEXCLAMATION equ 0030h
IDYES       equ     6

ifdef   NEC_98
NULL        equ 00h             ;       [QN]    (INS 92.08.05)          |
BIOS_FLAG5  equ 58h             ;       [QN]    (ins 92.11.06)          |
BIOS_FLAG7  equ 5bh             ;       [QN]    (ins 92.11.06)          |
endif   ; NEC_98

createSeg _INTERRUPT,IntCode,word,public,CODE
sBegin IntCode
assumes cs,IntCode

    externFP FakeCOMIntFar
    externFP TimerProc
    externFP Control
    externFP COMHandler
    externFP APIHandler
IFDEF No_DOSX_Bimodal_Services
    externW  RM_IntDataSeg
    externFP RM_APIHandler
    externFP Entry_From_RM
    externD  RM_CallBack
ENDIF

sEnd IntCode

page
sBegin   Data

externB lpCommBase
externB CommBaseX
externB lpCommIrq
externB CommIrqX
externB lpCommFifo
externB CommFifoX
externB lpCommDSR
externB CommDSRx

externB lpCommSection
externB lpSYSTEMINI


;------------------------------------------------------------------------------
;
; Reserve data space for COM ports
;
DefineCommX MACRO num
    public  Comm&num
Comm&num label byte
    db  num-1
.errnz  DCB_Id
    db  ((DCBSize+1) AND 0FFFEh)-1 DUP (0)  ; ComDCB
    dw  0                   ; ComErr
    dw  0                   ; Port
    dw  0                   ; NotifyHandle
    dw  0                   ; NotifyFlags
    dw  -1                  ; RecvTrigger
    dw  0                   ; SendTrigger
.errnz IRQhook - SendTrigger - 2
    db  (SIZE ComDEB) - IRQhook DUP(0)
.errnz $ - Comm&num - (SIZE ComDEB)
    Declare_PM_BIS 0,Control,COMHandler,APIHandler,_INTERRUPT,_DATA
    db     (SIZE EBIS_Sel_Struc) * 2 DUP(0)    ; res space for 2 selectors
ENDM
DW_OFFSET_CommX MACRO num
    dw  DataOFFSET Comm&num
ENDM


??portnum = 1
REPT MAXCOM+1
    DefineCommX %??portnum
??portnum = ??portnum+1
ENDM

PUBLIC  COMptrs         ; table of offsets to CommX's declared above
COMptrs label   word
??portnum = 1
REPT MAXCOM+1
    DW_OFFSET_CommX %??portnum
??portnum = ??portnum+1
ENDM

PURGE   DefineCommX
PURGE   DW_OFFSET_CommX

;------------------------------------------------------------------------------
;
; Reserve data space for LPT ports
;
DefineLPTx MACRO num
    public  LPT&num
LPT&num label byte
    db  num-1+LPTx
.errnz  DCB_Id
    db  ((DCBSize+1) AND 0FFFEh)-1 DUP (0)  ; xComDCB
    dw  0                   ; xComErr
    dw  0                   ; xPort
    dw  0                   ; xNotifyHandle
    dw  0                   ; xNotifyFlags
    dw  -1                  ; xRecvTrigger
    dw  0                   ; xSendTrigger
IF num LE 3
    dw  LPTB + (num-1)*2
ELSE
    dw  0                   ; BIOSPortLoc
ENDIF
    .errnz $-LPT&num - SIZE LptDEB
ENDM

??portnum = 1
REPT MAXLPT+1
    DefineLPTx %??portnum
??portnum = ??portnum+1
ENDM

PURGE   DefineLPTx

page

PUBLIC  $MachineID, Using_DPMI
$MachineID    db 0      ;IBM Machine ID
Using_DPMI    db 0      ; 0FFh, if TRUE

    ALIGN 2

PUBLIC  activeCOMs
activeCOMs    dw 0

PUBLIC  lpPostMessage, lpfnMessageBox, lpfnVPD, fVPD

lpPostMessage     dd 0
lpfnMessageBox    dd 0

lpfnVPD       dd 0      ; far pointer to win 386 VPD entry point
lpfnVCD       dd 0      ; far pointer to win 386 VCD entry point
lpfnVPICD     dd 0      ; far pointer to win 386 VPICD entry point
ifdef   NEC_98
lpfnWPSVPD    dd 0      ; far pointer to win 386 VPICD entry point(ins 94.02.24)|
endif   ; NEC_98
PUBLIC VCD_int_callback
VCD_int_callback  df 0      ; VCD returns the address for this callback
                ;   on every call to acquire a COM port, but
                ;   it is always the same address, so we will
                ;   just maintain it globally.
fVPD          db 0      ; 0-not checked, 1 vpd present, -1 no vpd
fVCD          db 0      ; 0-not checked, 1 vcd present, -1 no vcd
fVPICD        db 0      ; 0-not checked, 1 vpicd present, -1 no vpicd
ifdef   NEC_98
fWPSVPD       db 0      ; 0-not checked, 1 WPS present, -1 no WPS (ins 94.02.24)        |
endif

szUser      db 'USER',0


default_table db  4, 3, 4, 3, 0 ; Default IRQ's (COM3 default is changed to
                ;   3 for PS/2's during LoadLib)


IFDEF No_DOSX_Bimodal_Services
RM_Call_Struc   Real_Mode_Call_Struc <>
ENDIF

IFDEF DEBUG_TimeOut
%OUT including code to display MsgBox, if closing comm with data in buffer
szSendTO    db 'TimedOut CloseComm with data in buffer.  Retry?', 0
ENDIF

ifdef   NEC_98
;;;;;;;************  DEB Value of Each Port  ************                       |
;;;;;;;                                                                         |
;;;;;;;            +---------------------------------------ComDCB               |
;;;;;;;            |+--------------------------------------ComErr               |
;;;;;;;            ||+-------------------------------------Port                 |
;;;;;;;            |||+------------------------------------NotifyHandle         |
;;;;;;;            ||||+-----------------------------------NotifyFlag           |
;;;;;;;            |||||+----------------------------------RecvTrigger          |
;;;;;;;            ||||||+---------------------------------SendTrigger          |
;;;;;;;            |||||||    +----------------------------TimerProcAdr         |
;;;;;;;            |||||||    |        +-------------------MaskFFPort           |
;;;;;;;            |||||||    |        |    +--------------ReadSigPort          |
;;;;;;;            |||||||    |        |    |    +---------DataPort             |
;;;;;;;            |||||||    |        |    |    |    +----CommandPort          |
;;;;;;;            |||||||    |        |    |    |    |    +--StatusPort        |
;;;;;;;            |||||||    |        |    |    |    |    |                    |
;;;;;;Comm1 ComDEB <,,,,,,,TickEntry1,035h,033h,030h,032h,032h,> ;Com1          |
;;;;;;Comm2 ComDEB <,,,,,,,TickEntry2,0B0h,0B0h,0B1h,0B3h,0B3h,> ;Com2          |
;;;;;;Comm3 ComDEB <,,,,,,,TickEntry3,0B2h,0B2h,0B9h,0BBh,0BBh,> ;Com3          |
                                                        ;                       |
public Port_TBL,Port_EOI,Vect_TBL,Mask_TBL,PRN_CHAR     ;                       |
public Board_66L,Board_59,FindCOMPort                              ;            |
                                                                   ;            |
;**************************  Data Table  **************************             |
; using IRQ as 'index'.
Port_TBL        dw      00h,00h,00h,02h,00h,02h,02h,00h
                dw      00h,0ah,0ah,00h,0ah,0ah,00h,00h
Port_EOI        dw      00h,00h,00h,0bh,00h,0dh,0eh,00h
                dw      00h,11h,13h,00h,14h,15h,00h,00h
Vect_TBL        db      00h,00h,00h,00h,00h,00h,00h,00h
                db      00h,08h,08h,00h,08h,08h,00h,00h
Mask_TBL        db      00h,00h,00h,08h,00h,20h,40h,00h
                db      00h,02h,08h,00h,10h,20h,00h,00h
PRN_CHAR        db      0               ;Lpt Output Char Buffer                 |
                                        ;                                       |
Board_66L       dw      0BAh            ;PC-980166/L board                      |
Board_59        dw      0BFh            ;PC-980159 board                        |
                                        ;                                       |
out5f_flag      db      0               ; ins 93.03.24 (IOrecovery)             |
public  RECLoopCounter                  ; ins 93.03.31                          |
RECLoopCounter  dw      0               ; ins 93.03.31                          |
endif   ; NEC_98

sEnd Data

ROMBios           segment  at 0F000h
                  org         0FFFEh

MachineID label byte
RomBios Ends


sBegin Code
assumes cs,Code
assumes ds,Data

page

IFDEF No_DOSX_Bimodal_Services
;----------------------------Private-Routine----------------------------;
; SegmentFromSelector
;
;   Converts a selector to a segment...note that this routine assumes
;   the memory pointed to by the selector is below the 1Meg line!
;
; Params:
;   AX = selector to convert to segment
;
; Returns:
;   AX = segment of selector given
;
; Error Returns:
;   None
;
; Registers Destroyed:
;   CX
;
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public SegmentFromSelector
SegmentFromSelector proc far

.286
    push    dx
    cCall   GetSelectorBase,<ax>    ;DX:AX = segment of selector
    shr ax, 4
    shl dl, 4
    or  ah, dl          ;AX now points to interrupt *segment*
    pop dx
    ret
.8086

SegmentFromSelector endp
ENDIF
page

;------------------------------------------------------------------------------
;
;   Get_API_Entry
;
;   entry - BX = device id
;       DS:DI -> DWORD for proc address
;   exit - Z flag set, if failed
;
Get_API_Entry proc near

    push    di
    xor di, di
    mov es, di
    mov ax, GET386API
    int MULTIPLEX
    mov ax, di
    pop di
    mov [di], ax
    mov [di+2], es
    or  ax, [di+2]
    ret

Get_API_Entry endp

;----------------------------Private-Routine----------------------------;
;
;   Contention_Dlg
;
;   If running under Win386, this routine can be called to ask the user to
;   resolve contention for a COM or LPT port.
;
;   entry - CX is offset of message string for dialog box
;
;   exit  - Z flag set, if user specified that Windows should steal the port

Contention_Dlg proc near
PUBLIC Contention_Dlg

    xor ax,ax
    push    ax          ; hwndOwner
    push    ds
    push    cx          ; message ptr

    cmp wo lpfnMessageBox[2], 0 ;Q: ptr to MessageBox proc valid?
    jne short gmbp_done     ;   Y: we can call it
    push    ds          ;   N: get module handle of USER
    lea ax, szUser
    push    ax
    cCall   GetModuleHandle

    push    ax          ; module handle
    mov ax, MESSAGEBOX
    cwd
    push    dx
    push    ax
    cCall   GetProcAddress
    mov wo lpfnMessageBox[0], ax  ; save received proc address
    mov wo lpfnMessageBox[2], dx
gmbp_done:

    push    ds
    lea ax, _szTitle
    push    ax
    mov ax, MB_ICONEXCLAMATION or MB_YESNO or MB_TASKMODAL
    push    ax
    cCall   lpfnMessageBox
    cmp ax, IDYES       ; user allows us to take the port?
    ret
Contention_Dlg endp

ifdef   NEC_98
;---------------------------------------------------------------(ins 94.02.24)  |
; WPS386                                                        (ins 94.02.24)  |
;       Request ON/OFF of port trap to WPSVPD                   (ins 94.02.24)  |
;       (The function is toggled by calling WPSVPD)             (ins 94.02.24)  |
;                                                               (ins 94.02.24)  |
;       entry - DI contains offset in ROM area of port...       (ins 94.02.24)  |
;               8 - LPT1, A - LPT2, etc                         (ins 94.02.24)  |
;---------------------------------------------------------------(ins 94.02.24)  |
WPS386  proc near                       ;                       (ins 94.02.24)  |
.286                                    ;                       (ins 94.02.24)  |
        pusha                           ;                       (ins 94.02.24)  |
.8086                                   ;                       (ins 94.02.24)  |
        mov     di, [si.BIOSPortLoc]    ;                       (ins 94.02.24)  |
        sub     di, LPTB                ;                       (ins 94.02.24)  |
        shr     di, 1                   ; DI into port number   (ins 94.02.24)  |
        cmp     fWPSVPD, 1              ; Is there WPSVPD ?     (ins 94.02.24)  |
        je      short beWPSVPD          ;   Y: Go Next          (ins 94.02.24)  |
                                        ;                       (ins 94.02.24)  |
        push    di                      ;                       (ins 94.02.24)  |
        mov     bx, VPD                 ;                       (ins 94.02.24)  |
        mov  di, DataOFFSET lpfnWPSVPD  ;                       (ins 94.02.24)  |
        call    Get_API_Entry           ;Is there VPD ?         (ins 94.02.24)  |
        pop     di                      ;                       (ins 94.02.24)  |
        jnz     short chkWPSVPD         ;   Y: Go Next          (ins 94.02.24)  |
        mov     fWPSVPD, -1             ;                       (ins 94.02.24)  |
        jmp     short WPSVPD_exit       ;                       (ins 94.02.24)  |
chkWPSVPD:                              ;                       (ins 94.02.24)  |
        push    di                      ;                       (ins 94.02.24)  |
        mov     dx, VPD_GETVER          ; Get VPD version       (ins 94.02.24)  |
        call    [lpfnWPSVPD]            ;                       (ins 94.02.24)  |
        pop     di                      ;                       (ins 94.02.24)  |
        cmp     ax, 030bh               ; WPSVPD(=30bh)H       (ins 94.02.24)  |
        je      short insWPSVPD         ;   Y: Next(IS WPSVPD)  (ins 94.02.24)  |
        mov     fWPSVPD, -1             ;               )       (ins 94.02.24)  |
        jne     short WPSVPD_exit       ;                       (ins 94.02.24)  |
insWPSVPD:                              ;                       (ins 94.02.24)  |
        mov     fWPSVPD, 1              ; There is WPSVPD       (ins 94.02.24)  |
beWPSVPD:                               ;                       (ins 94.02.24)  |
        xor     ax, ax                  ;                       (ins 94.02.24)  |
        mov     cx, di                  ; Set LPT ID            (ins 94.02.24)  |
        mov     dx, VPD_GETPORT         ;                       (ins 94.02.24)  |
        call    [lpfnWPSVPD]            ; Call VPD_PM_Aquire_Port(ins 94.02.24) |
WPSVPD_exit:                            ;                       (ins 94.02.24)  |
.286                                    ;                       (ins 94.02.24)  |
        popa                            ;                       (ins 94.02.24)  |
        ret                             ;                       (ins 94.02.24)  |
.8086                                   ;                       (ins 94.02.24)  |
WPS386  endp                            ;                       (ins 94.02.24)  |
endif   ; NEC_98

;----------------------------Private-Routine----------------------------;
;
;   GetPort386
;
;   If running under Win386, tell the VPD to assign an LPT port to us.
;   The comm driver will handle contention.
;
;   entry - DI contains offset in ROM area of port...
;       8 - LPT1, A - LPT2, etc
;
;   exit  - registers saved, carry = clear if OK to proceed, set if
;       user won't allow assignment of port or Win386 error
;

GetPort386  proc near
public GetPort386

    cmp fVPD, 0
    jl  getport_VPDNotInstalled
    jnz short getport_CallVPD

    push    di
    mov bx, VPD
    mov di, DataOFFSET lpfnVPD
    call    Get_API_Entry
    pop di
    jnz short getport_CallVPD
    mov fVPD, -1

getport_VPDNotInstalled:
    clc
    jmp short getport_exit

getport_CallVPD:
    mov fVPD, 1
    push    di
    sub di, LPTB
    shr di, 1           ; turn DI into port number

    xor ax, ax
    mov dx, VPD_GETPORT
    mov cx, di
    call    [lpfnVPD]
    jnc getport_gotit

;   port owned by another VM... ask the user for it

    add cl, '1'         ; fix up the port name...
    mov pLPTByte, cl        ; HACK HACK HACK
    lea cx, szMessage
    call    Contention_Dlg
    jnz getport_userwontallow

    mov ax, 1           ; tell win386 we really do want it
    mov cx, di          ;
    mov dx, VPD_GETPORT     ;
    call    [lpfnVPD]       ; return with C set or clear...
    jmp short getport_gotit

getport_userwontallow:
    stc

getport_gotit:
    pop di

getport_exit:
    ret

GetPort386  endp

;----------------------------Private-Routine----------------------------;
;
;   ReleasePort386
;
;   If running under Win386, tell the VPD to deassign an LPT port.
;
;   entry - DS:SI -> COMDEB
;

ReleasePort386  proc near

    cmp fVPD, 1
    jne release_noVPD

    xor cx, cx
    mov cl, [si.DCB_id]
    and cl, NOT LPTx        ; clear high bit
    mov dx, VPD_RELPORT
    call    [lpfnVPD]

release_noVPD:
    ret

ReleasePort386  endp


;----------------------------Private-Routine----------------------------;
;
;   GetCOMport386
;
;   If running under Win386, tell the VCD to assign a COM port to us.
;   The comm driver will handle contention.
;
;   entry - DS:SI -> COMDEB
;
;   exit  - registers saved, carry = clear if OK to proceed, set if
;       user won't allow assignment of port or Win386 error
;
.386
GetCOMport386 proc near
public GetCOMport386

    push    es
    pushad
    cmp fVCD, 0
    jl  short getcomport_VCDNotInstalled
    jnz short getcomport_CallVCD

    mov bx, VCD
    mov di, DataOFFSET lpfnVCD
    call    Get_API_Entry
    jz  short getcomport_checknoVCD

    mov dx, VCD_GETVER
    call    [lpfnVCD]
    cmp ax, 30Ah            ;Q: 3.1 or greater?
    jae short getcomport_CallVCD    ;   Y:

getcomport_checknoVCD:
    mov fVCD, -1

getcomport_VCDNotInstalled:
    clc
    jmp short getcomport_exit

getcomport_CallVCD:
    mov fVCD, 1

    mov ax, 10b         ; flag ring0 int handler
    call    VCD_GetPort_API
    jnc short getcomport_success  ; jump if acquire worked
    jnz short getcomport_noport   ; jump if port doesn't exist

;   port owned by another VM... ask the user for it

    mov cl, [si.DCB_id]
    add cl, '1'         ; fix up the port name...
    mov pCOMByte, cl
    lea cx, szCOMMessage
    call    Contention_Dlg
    stc
    jnz short getcomport_exit

    mov ax, 11b         ; tell win386 we really do want it
    call    VCD_GetPort_API
    jc  short getcomport_exit

getcomport_success:
    mov dword ptr [VCD_int_callback], edi
    mov word ptr [VCD_int_callback+4], cx
    mov [si.VCD_data], ebx
    xchg    ax, [si.Port]
    or  ax, ax          ;Q: already had port base?
    jnz short getcomport_exit ; Y: don't update vector #, or FIFO
    mov [si.IntVecNum], dl
    call    GetPortFlags
    clc

getcomport_exit:
    popad
    pop es
    ret

getcomport_noport:
    mov [si.Port], -1
    jmp getcomport_exit

GetCOMport386 endp

VCD_GetPort_API proc near
    mov dx, VCD_GETPORT
    xor cx, cx
    mov cl, [si.DCB_Id]     ; cx = port #
    mov di, VCDflags        ; offset from start of DEB
    call    [lpfnVCD]
    ret
VCD_GetPort_API endp
.8086

;----------------------------Private-Routine----------------------------;
;
;   ReleaseCOMport386
;
;   If running under Win386, tell the VCD to deassign a COM port.
;
;   entry - DS:SI -> COMDEB
;

ReleaseCOMport386  proc near

ifdef   NEC_98
    cmp fVCD, 1
    jne release_noVCD

    xor cx, cx
    mov cl, [si.DCB_id]
    mov dx, VCD_RELPORT
    call    [lpfnVCD]
else    ; NEC_98
ifndef WOW
    cmp fVCD, 1
    jne release_noVCD

    xor cx, cx
    mov cl, [si.DCB_id]
    mov dx, VCD_RELPORT
    call    [lpfnVCD]
else
    xor cx, cx
    mov cl, [si.DCB_id]
    push cx
    call WowCloseComPort
endif
endif   ; NEC_98

release_noVCD:
    ret

ReleaseCOMport386  endp

PUBLIC StealPort
StealPort proc near

    cmp fVCD, 1
    jne sp_yes
    mov dx, VCD_STEALPORT
    xor cx, cx
    mov cl, [si.DCB_id]
    call    [lpfnVCD]
    or  al, al
    jnz sp_yes

sp_no:
    stc
    ret

sp_yes:
    clc
    mov [si.VCDflags], 0
    ret

StealPort endp

page

;------------------------------------------------------------------------------
;
;   ENTER:  DS:SI -> ComDEB
;   EXIT:   AL = 0, if IRQ was unmasked, else -1, if IRQ was already masked
;
MaskIRQ proc near
    push    es
    push    di
    mov di, ds
    mov es, di
    lea di, [si+SIZE ComDEB]
    mov ax, BIH_API_Get_Mask
    call    APIHandler      ; returns Carry Set, if masked
    jc  short already_masked
    pushf
    mov ax, BIH_API_Mask
    call    APIHandler      ; mask IRQ
    xor ax, ax
    popf
    jnc short mask_exit
already_masked:
    or  al, -1
mask_exit:
    pop di
    pop es
    ret
MaskIRQ endp

;------------------------------------------------------------------------------
;
;   ENTER:  DS:SI -> ComDEB
;
UnmaskIRQ proc near
    push    es
    push    di
    mov di, ds
    mov es, di
    lea di, [si+SIZE ComDEB]
    mov ax, BIH_API_Unmask
    call    APIHandler
    pop di
    pop es
    ret
UnmaskIRQ endp
page

;----------------------------Public Routine-----------------------------;
;
; $INICOM - Initialize A Port
;
; Initalizes the requested port if present, and sets
; up the port with the given attributes when they are valid.
; This routine also initializes communications buffer control
; variables.  This routine is passed the address of a device
; control block.
;
; The RLSD, CTS, and DSR signals should be ignored by all COM
; routines if the corresponding timeout values are 0.
;
; For the LPT ports, a check is performed to see if the hardware
; is present (via the LPT port addresses based at 40:8h.  If the
; port is unavailable, an error is returned.  If the port is
; available, then the DEB is set up for the port.  $SETCOM will
; be called to set up the DEB so that there will be something
; valid to pass back to the caller when he inquires the DEB.
;
; No hardware initialization will be performed to prevent the
; RESET line from being asserted and resetting the printer every
; time this routine is called.
;
; Entry:
;   EX:BX --> Device Control Block with all fields set.
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = initialization error code otherwise
; Registers Preserved:
;   None
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $INICOM
$INICOM  proc  near
    push    si          ;As usual, save register variables
    push    di
    mov ah,es:[bx.DCB_Id]   ;Get device i.d.
    call    GetDEB          ;--> DEB for this device
    mov ax, IE_BADID        ; call it a bad id (spooler uses DOS)
    jc  InitCom15       ;Invalid device
    jns InitCom20       ; jmp if COM port

ifndef  NEC_98
    push    ds

    mov di, [si.BIOSPortLoc]
    cmp di, LPTB
    jb  short InitLPT_Installed

    mov cx,__0040H      ;[rkh] ...
    mov ds,cx           ;Point DS: at ROM Save Area.
    assumes ds,nothing

    mov ax, IE_HARDWARE
    mov cx, wo [di]
    jcxz    InitCom10       ; if zero, no hardware

    mov ax,IE_BadID     ;Show bad device
    cmp ch, 0           ; zero hibyte -> not valid (redir)
    jz  InitCom10       ;   call it a bad id (spooler uses DOS)

    cmp di, LPTB        ; LPT1?
    jz  InitLPT_Installed   ; yes, must be installed

    cmp cx, wo [di-2]       ;Q: duplicate of previous port
    je  InitCom10       ;   Y: (redirected port)

InitLPT_Installed:
    pop ds
    mov [si.Port], cx
endif   ; NEC_98
    call    $SETCOM
ifdef   NEC_98
    mov di, [si.BIOSPortLoc]            ;                       (ins 93.12.19)  |
endif   ; NEC_98
    call    GetPort386      ; tell win386 we're using the port
    mov ax, IE_OPEN     ; port already open (by another VM)
    jc  InitCom15       ;   error
ifdef   NEC_98
    call    WPS386                      ; WPS386 I/O trap ON    (ins 94.02.24)  |
    mov ah, 1                           ; Check H/W environment (ins 93.10.29)  |
    call    int_1ah_call                ;   and set to [si.Port](ins 93.10.29)  |
    call    WPS386                      ; WPS386 I/O trap OFF   (ins 94.02.24)  |
    cmp wo [si.Port], -1                ; Port = -1 ?           (ins 93.12.19)  |
    mov ax, IE_HARDWARE                 ; (no H/W?)             (ins 93.12.19)  |
    jne @f                              ;     N: success        (ins 93.12.19)  |
    call    ReleasePort386              ;     Y: release port   (ins 93.12.19)  |
    jmp InitCom100                      ;                       (ins 93.12.19)  |
@@:                                     ;                       (ins 93.12.19)  |
endif   ; NEC_98
    jmp InitCom90       ;That's all

InitCom10:
    pop ds          ; get DS back
InitCom15:
    jmp InitCom100


    assumes ds,Data
InitCom17:
ifdef   NEC_98
    mov ax, IE_OPEN                     ;                       (ins 92.08.xx)  |
    mov dx,StatusPort[si]               ;dx = StatusPort[si]    (ins 92.08.xx)  |
    NEWIODELAY  5                       ;<OUT 5F,AL>            (ins 94.05.11)  |
    in  al,dx                           ;                       (ins 92.08.xx)  |
    cmp al,-1                           ;                       (ins 92.08.xx)  |
    jne InitCom15                       ;   N:return IE_OPEN    (ins 92.08.xx)  |
    jmp InitCom27                       ;   Y:return IE_HARDWARE(ins 92.08.xx)  |
else    ; NEC_98
    mov ax, IE_OPEN
    cmp [si.Port], -1       ;Q: determined that port didn't exist?
    jne InitCom15       ;   N: return IE_OPEN
    jmp short InitCom27     ;   Y: return IE_HARDWARE
endif   ; NEC_98

; ***  Set up serial port ***
;
InitCom20:
ifdef   NEC_98
    push    cx                          ;                                       |
    push    ax                          ;                                       |
                                        ;                                       |
    call    OUT5FCheck                  ;                       (ins 93.03.24)  |
                                        ;                                       |
    mov cx,500                          ;                                       |
    mov ax, __WinFlags                  ;               [QN][BA](ins 93.03.30)  |
    and ax, WF_ENHANCED                 ;               [QN][BA](ins 93.03.30)  |
    jnz Go_EnhSET                       ;               [QN][BA](ins 93.03.30)  |
                                        ;                                       |
    cmp [out5f_flag],1                  ;out 5f ok ??           (ins 93.03.24)  |
    je  @f                              ;yes                    (ins 93.03.24)  |
    mov cx,5000                         ;                                       |
@@:                                     ;                                       |
    jmp short OUT5FSetEND               ;                                       |
                                        ;                                       |
Go_EnhSET:                              ;                                       |
    cmp [out5f_flag],1                  ;out 5f ok ??           (ins 93.03.24)  |
    jne @f                              ;No                     (ins 93.03.24)  |
    mov cx,1                            ;                                       |
@@:                                     ;                                       |
                                        ;                                       |
OUT5FSetEND:                            ;                                       |
    mov [RECLoopCounter] , cx           ;                                       |
    pop ax                              ;                                       |
    pop cx                              ;                                       |
                                        ;                                       |
    mov ah,es:[bx.DCB_Id]               ;Get device i.d.        (ins 92.08.xx)  |
    cmp ah,ID_COM1                      ;COM1?                  (ins 92.08.xx)  |
    je  InitCom22                       ;Yes, InitCom22 B(ins 92.08.xx)  |
InitCom21:                              ;                       (ins 94.04.15)  |
    or  EFlags[si], fNoFIFO             ;                       (ins 94.04.21)  |
    mov dx,[Board_66L]                  ;                       (ins 92.08.xx)  |
    in  al,dx                           ;PC-980166/L{[h      (ins 92.08.xx)  |
    cmp al,0FFH                         ;MA_v^     (ins 92.08.xx)  |
    je  @f                              ;                       (ins 94.05.19)  |
    jmp InitCom27                       ;                       (ins 94.05.19)  |
@@:                                     ;                       (ins 94.05.19)  |
    mov dx,[Board_59]                   ;                       (ins 92.08.xx)  |
    in  al,dx                           ;PC-980159{[h        (ins 92.08.xx)  |
    cmp al,0FFH                         ;A_v^     (ins 92.08.xx)  |
        je      @f
        jmp     InitCom27
@@:
    mov dx,StatusPort[si]               ;dx = StatusPort[si]    (ins 92.08.xx)  |
    in  al,dx                           ;                       (ins 92.08.xx)  |
    cmp al,-1                           ;                       (ins 92.08.xx)  |
    jne @f
    jmp InitCom27
@@:
                                        ;                                       |
InitCom22:                              ;                       (ins 92.08.xx)  |
else    ; NEC_98
    cmp [si.Port], -1       ;Q: port exists?
    je  InitCom27       ;   N: report not found
endif   ; NEC_98

    mov ax, __WinFlags
    test    ax, WF_ENHANCED
    jz  short @F
    call    GetCOMport386
ifdef   NEC_98
    jc  InitCom23                       ;                       (ins 94.04.18)  |
    jmp short   @F                      ;                       (ins 94.04.18)  |
InitCom23:                              ;                       (ins 94.04.18)  |
    jmp InitCom17                       ;                       (ins 94.04.18)  |
@@:                                     ;                       (ins 94.04.18)  |
    mov ah,es:[bx.DCB_Id]               ;Get device i.d.        (mov 94.05.19)  |
    or  EFlags[si], fNoFIFO             ;no AOBA on board       (ins 94.05.31)  |
    cmp ah,ID_COM1                      ;COM1?                  (mov 94.05.19)  |
    jne InitCom24_1                     ;No,                    (mov 94.05.19)  |
    mov Port[si],0                      ;                       (mov 94.05.19)  |
    call    AOBACheck                   ;Check AOBA             (mov 94.05.19)  |
    FCLI                                ;                       (mov 94.05.19)  |
    test    EFlags[si], fNoFIFO         ;AOBA on board ?        (mov 94.05.19)  |
    jnz InitCom24_2                     ;                       (mov 94.05.19)  |
    mov Port[si],130H                   ;                       (mov 94.05.19)  |
    mov dx,Port[si]                     ;AOBA BASE PORT         (mov 94.05.19)  |
    add dx,ACE_FCR                      ;                       (mov 94.05.19)  |
    in  al,dx                           ;                       (mov 94.05.19)  |
    mov preFCRShadow[si],al             ;Save FCR when WIN start(ins 94.06.06)  |
    test    al,ACE_EFIFO                ;FIFO mode ?            (mov 94.05.19)  |
    jz  short   @F                      ;No, 8251 mode          (mov 94.05.19)  |
    call    Set8251mode                 ;Set 8251 mode          (mov 94.05.19)  |
@@:                                     ;                       (mov 94.05.19)  |
    jmp short   InitCom24_2             ;                       (mov 94.05.19)  |
InitCom24_1:                            ;                       (mov 94.05.19)  |
InitCom24_2:                            ;                       (mov 94.05.19)  |

; Entry:                                                       ;(ins 92.08.xx)  |
;   DS:SI --> DEB                                              ;(ins 92.08.xx)  |
;   CX = Port base address                                     ;(ins 92.08.xx)  |
;   DS = Data                                                  ;(ins 92.08.xx)  |
                                                               ;(ins 92.08.xx)  |
    call    Get_PortAddr_and_INTVect    ;xN^  ;(ins 92.08.xx)  |
                                                               ;(ins 92.08.xx)  |
; Returns:                                                     ;(ins 92.08.xx)  |
;   AH = IRQ number                                            ;(ins 92.08.xx)  |
;   AL = 8259 Mask                                             ;(ins 92.08.xx)  |
;   DI:DX --> interrupt handler                                ;(ins 92.08.xx)  |
                                                               ;(ins 92.08.xx)  |
    inc IntVecIntCount[si]              ; USE Rotate_Pic()      (ins 92.08.xx)  |
    call    FindCOMPort                 ;                      (MOVE 93.03.20)  |
else    ; NEC_98
    jc  InitCom17

@@:
    cmp [si.Port], 0        ;Q: already got info?
    jnz @F
    call    FindCOMPort
    jc  InitCom27       ; report not found, if error
    mov [si.Port], ax
    mov [si.IntVecNum], dl
@@:
endif   ; NEC_98

    push    es          ;Save these registers
    push    di
    push    cx          ;needed later for $SETCOM etc
    push    bx

    mov al, [si.IntVecNum]
    xor ah, ah
    lea di, [si+SIZE ComDEB]
    mov [di.BIS_IRQ_Number], ax

    mov di, DataOFFSET IRQhooks
ifdef   NEC_98
    xor cx,cx                           ;                   [QN] (ins 92.09.xx) |
    mov cl, [si.DCB_Id]                 ;                   [QN] (ins 92.09.xx) |
    jcxz    InitCom30                   ;                   [QN] (ins 92.09.xx) |
else    ; NEC_98
    mov cx, MAXCOM+1
endif   ; NEC_98
InitCom25:
ifndef  NEC_98
    cmp al, [di.IRQn]       ;Q: hooked IRQ matches ours?
    je  short InitCom30     ;   Y:
    cmp [di.IRQn], 0        ;Q: end of hooked IRQ list?
    je  short InitCom35     ;   Y:
endif   ; NEC_98
    add di, SIZE IRQ_Hook_Struc ;   N: check next hook
    loop    InitCom25
ifdef   NEC_98
    jmp short InitCom30                 ;                   [QN] (ins 92.09.xx) |
endif   ; NEC_98
    int 3               ; data structures corrupt if we
                    ; get here, because no hook table
                    ; entries exist and there is suppose
                    ; to be at least 1 for each DEB
InitCom26:
    call    ReleaseCOMport386   ; give port back to 386...
    pop bx
    pop cx
    pop di
    pop es

InitCom27:
    mov ax, IE_HARDWARE     ; jump if port not available
    jmp InitCom100

InitCom30:
    cmp [di.HookCnt], 0     ;Q: IRQ still hooked?
    je  short InitCom35     ;   N: rehook
    inc [di.HookCnt]        ;   Y: inc hook count
    mov [si.IRQhook], di    ;   & link DEB into list
    mov ax, [di.First_DEB]
    mov [si.NextDEB], ax
    mov [di.First_DEB], si
    jmp short InitCom40

InitCom35:
    mov [di.IRQn], al       ; hook IRQ for first time, or rehook
    mov [si.IRQhook], di
    mov [di.First_DEB], si
    mov [di.HookCnt], 1
    call    MaskIRQ
    mov [di.OldMask], al

InitCom40:              ; di -> IRQ_Hook_Struc

    cmp [fVPICD], 0     ;Q: VPICD bimodel services available?
    jl  short InitCom415    ;   N:
    mov ax, ds          ;   Y: use them
    mov es, ax
    lea di, [si+SIZE ComDEB]

    mov [di.BIS_Descriptor_Count], 2
    mov ax, word ptr [si.QInAddr+2]  ; get selector of in queue
    mov [di.EBIS_Sel1.EBIS_User_Mode_Sel], ax
    mov ax, word ptr [si.QOutAddr+2] ; get selector of out queue
    mov [di.EBIS_Sel2.EBIS_User_Mode_Sel], ax

    mov ax, VPICD_Install_Handler
    call    [lpfnVPICD]
    jnc InitCom42
    cmp [di.OldMask], 0
    jne InitCom26
    call    UnmaskIRQ
    jmp InitCom26

InitCom42:
;
; save newly allocated selectors/segments into "Alt" queue pointers
;
    mov ax, [di.EBIS_Sel1.EBIS_Super_Mode_Sel]
    mov word ptr [si.AltQInAddr+2], ax
    mov ax, [di.EBIS_Sel2.EBIS_Super_Mode_Sel]
    mov word ptr [si.AltQOutAddr+2], ax

InitCom414:
    jmp InitCom59

InitCom415:
    cmp [di.VecN], 0FFh     ;Q: int already hooked?
IFDEF No_DOSX_Bimodal_Services
    jnz short InitCom52     ;   Y: init RMode ptrs in BIS
ELSE
    jnz InitCom414      ;   Y:
ENDIF
    mov al, [si.IntVecNum]
    add al, 8           ; 1st PIC starts at vector 8h
ifndef  NEC_98
    cmp al, 16          ;Q: 2nd PIC?
    jb  short InitCom418    ;   N:
    add al, 70h-16      ;   Y: 2nd PIC starts at vector 70h
endif   ; NEC_98
InitCom418:
    mov [di.VecN], al

; *** Set interrupt vectors ***
;
    mov ah,35h          ;Get the DOS vector
    int 21h         ;DOS Get Vector Function
    mov wo [di.OldIntVec][0], bx
    mov wo [di.OldIntVec][2], es

InitCom50:
    push    ds          ;Save original DS
    mov dx, [di.HandlerOff]
    mov bx, _INTERRUPT
    mov ds, bx          ;Interrupt handler address in ds:dx
    assumes ds,nothing
    mov ah, 25h         ;DOS Set Vector Function
    int 21h         ;Set the DOS vector
    pop ds          ;Original DS
    assumes ds,Data

IFDEF No_DOSX_Bimodal_Services
InitCom52:
    cmp [Using_DPMI], 0
    jz  short InitCom57

    mov ax, Int31_Get_Version SHL 8
    int 31h
    mov bl, [si.IntVecNum]
    mov bh, bl
    add bl, dh          ; assume master PIC
    sub bh, 8           ;Q: IRQ in master?
    jb  @f          ;   Y: add master's base vec
    add bh, dl          ;   N: add slave's base vec
    mov bl, bh
@@:
    mov ax, Get_RM_IntVector
    int 31h
    mov wo [di.RM_OldIntVec][0], dx
    mov wo [di.RM_OldIntVec][2], cx

    mov dx, [di.RM_HandlerOff]
    mov ax, _INTERRUPT
    call    SegmentFromSelector
    mov cx, ax
    push    cx
    mov ax, Set_RM_IntVector
    int 31h

    lea di, [si+SIZE ComDEB]
    mov wo [di.BIS_Super_Mode_API], IntCodeOFFSET RM_APIHandler
    pop cx
    mov wo [di.BIS_Super_Mode_API+2], cx

;
; Get segment addresses for the Q's and set AltQInAddr and AltQOutAddr
;
    mov ax, wo [si.AltQInAddr+2]
    call    SegmentFromSelector
    mov wo [si.AltQInAddr+2], ax
    mov ax, wo [si.AltQOutAddr+2]
    call    SegmentFromSelector
    mov wo [si.AltQOutAddr+2], ax
InitCom57:
ENDIF
    mov ax, __WinFlags      ;In Standard mode, the PIC IRQ
    test    al, WF_STANDARD     ;  priorities get rotated to favor
    jz  InitCom59       ;  the comm ports.

    call    Rotate_PIC

; *** Interrupt handler set : jump here if handler is already installed ***
;
InitCom59:
    pop bx
    pop cx
    pop di
    pop es

ifdef   NEC_98
    cmp es:[bx.DCB_Id],ID_Com1          ;Is this ID Com1 ?      (ins 92.08.xx)|
    jne InitCom60                       ;No, jump InitCom60     (ins 92.08.xx)|
    mov dx,MaskFFPort[si]               ;F/F Port Mask Bit      (ins 92.08.xx)|
    in  al,dx                           ;                       (ins 92.08.xx)|
    mov MaskFFShadow[si],al             ;Save Old Mask bit      (ins 92.08.xx)|
                                        ;                                     |
InitCom60:                              ;                                     |
    mov al,MaskFFShadow[si]             ;Get 8251 INT Mask bit  (ins 92.08.xx)|
    and al,not(Enable_TxR or Enable_TxE or Enable_RxR)         ;(ins 92.08.xx)|
    mov dx,MaskFFPort[si]                                      ;(ins 92.08.xx)|
    out dx,al                                                  ;(ins 92.08.xx)|
    mov MaskFFShadow[si],al             ;Sasve Mask bit        ;(ins 92.08.xx)|
    call    FlagNotActive                                      ;(ins 92.08.xx)|
else    ; NEC_98
InitCom60:
    mov dx,[si.Port]        ;Set comm card address
    xor ax,ax           ;Need a zero
    inc dx          ;--> Interrupt Enable Register
    .errnz ACE_IER-ACE_RBR-1
    out dx,al           ;Turn off interrupts
    call    FlagNotActive
    add dl,ACE_MCR-ACE_IER  ;--> Modem Control Register
    in  al,dx
    and al,ACE_DTR+ACE_RTS  ;Leave DTR, RTS high if already so
    iodelay             ;  but tri-state IRQ line
    out dx,al
endif   ; NEC_98

InitCom70:
    push    es          ;Zero queue counts and indexes

    push    ds
    pop es
    assumes es,Data

    lea di,QInCount[si]
    mov cx,(EFlags-QInCount)/2
    .errnz (EFlags-QInCount) AND 1
    xor ax,ax
    cld
    rep stosw

    .errnz  QInGet-QInCount-2
    .errnz  QInPut-QInGet-2
    .errnz  QOutCount-QInPut-2
    .errnz  QOutGet-QOutCount-2
    .errnz  QOutPut-QOutGet-2
    .errnz  EFlags-QOutPut-2    ;First non-queue item

    pop es
    assumes es,nothing

    mov HSFlag[si],al       ;Show no handshakes yet
    mov MiscFlags[si],al    ;Show not discarding
    mov EvtWord[si],ax      ;Show no events
    mov [si.VCDflags], al

    mov [si.SendTrigger], ax
    dec ax
    mov [si.RecvTrigger], ax

;Call $SETCOM to perform further hardware initialization.

InitCom80:
ifndef  NEC_98
    sub dl,ACE_MCR-ACE_FCR  ; dx -> FCR
    in  al, dx
    iodelay
    test    al, ACE_FIFO_E2         ;Q: FIFO already on?
    jz  short @F            ;   N:
    or  EFlags[si], fFIFOpre        ;   Y: flag it
@@:
endif   ; NEC_98

    ; needs si, di, and es to be saved from the beginning of inicom
    call    $SETCOM         ;Set up Comm Device
    jnz short InitCom110    ;jump if failed

    call    UnmaskIRQ
    and EFlags[si], fEFlagsMask ;Clear internal state

InitCom90:
    xor ax,ax           ;Return AX = 0 to show success
    mov ComErr[si],ax       ;Get rid of any bogus init error

InitCom100:
ifdef   NEC_98
    FSTI                                ;                       (ins 94.05.17)
endif   ; NEC_98
    pop di
    pop si
    ret

;
; jump to here, if call to $SETCOM failed
;
; DANGER! *** Call into middle of Terminate to clean things up *** DANGER!
;
InitCom110:
    push    ax          ;Failure, save error code
    call    Terminate45     ;Restore port address, int vec
    pop ax          ;Restore error code and exit
    jmp InitCom100

$INICOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $TRMCOM - Terminate Communications Channel
;
; Wait for any outbound data to be transmitted, drop the hardware
; handshaking lines, and disable interrupts.  If the output queue
; contained data when it was closed, an error will be returned
;
; LPT devices have it easy.  They just need to restore the I/O port
; address.
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = 0
; Error Returns:
;   AX = 8000h if invalid device ID
;   AX = -2 if output queue timeout occured
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $TRMCOM
$TRMCOM  proc   near

    push    si
    push    di
    xor cx,cx           ;Show no error if LPT port
    call    GetDEB
    jc  TermCom60       ;ID is invalid, return error
    js  TermCom30       ;Port is a LPT port

    push    ax          ;Save port id
    or  MiscFlags[si],Discard   ;Show discarding serial data
    mov ComErr[si],cx       ;Clear error flags
    mov QInCount[si],cx     ;Show no chars in input queue
    call    $RECCOM         ;Send XON if needed

;-----------------------------------------------------------------------;
;   We have to wait for the output queue to empty.   To do this,
;   a timer will be created.  If no character has been transmitted
;   when the timeout occurs, then an error will be indicated and
;   the port closed anyway.  If the timer cannot be created, then
;   just loop until the queue empties, which will be better than
;   discarding charatcers if there are any
;-----------------------------------------------------------------------;

    test    [si.HSFlag], HHSAlwaysDown ; Q: handshaking ever up?
    jnz TermCom17       ;   N: skip wait loop

TermCom10:
    mov cx,QOutCount[si]    ;Get current queue count
    jcxz    TermCom20       ;No characters in queue

    cCall   GetSystemMsecCount
    mov di, ax

TermCom15:
    cmp QOutCount[si],cx    ;Queue count change?
    jne TermCom10       ;  Yes, restart timeout

    cCall   GetSystemMsecCount
    sub ax, di
ifdef   NEC_98
    cmp ax, 20000           ;Q: Timeout reached?    (ins 94.06.08)
else    ; NEC_98
    cmp ax, Timeout * 1000  ;Q: Timeout reached?
endif   ; NEC_98
    jb  TermCom15       ;   No, keep waiting

IFDEF DEBUG_TimeOut
.286
    pusha
    lea cx, szSendTO
    call    Contention_Dlg
    popa
    jz  TermCom10
.8086
ENDIF

TermCom17:
    mov cx, TimeoutError    ;   Yes, show timeout error

TermCom20:
    pop ax          ;Restore cid
ifdef   NEC_98
    test    [si.AOBA_flag],fFIFO_Mode   ;                       (ins 94.04.11)|
    jnz @F                              ;Now, FIFO mode         (ins 94.04.11)|
TermCom25:                              ;                       (ins 92.08.xx)|
    mov dx,ReadSigPort[si]              ;CI/CS/CD Signal Port   (ins 94.06.08)|
    in  al,dx                           ;in al,33h              (ins 94.06.08)|
    test    al,40h                      ;CS Off ?               (ins 94.06.08)|
    jnz @f                              ;y: jump                (ins 94.06.08)|
                                        ;                       (ins 94.06.08)|
    push    ax                          ;                       (ins 92.08.xx)|
    push    dx                          ;                       (ins 92.08.xx)|
    mov dx,StatusPort[si]               ;8251 status port read  (ins 92.08.xx)|
    in  al,dx                           ;                       (ins 92.08.xx)|
                                        ;                       (ins 92.08.xx)|
    test    al,(TX_EMP)                 ;tx_empty check         (ins 92.08.xx)|
    pop dx                              ;                       (ins 92.08.xx)|
    pop ax                              ;                       (ins 92.08.xx)|
    jz  TermCom25                       ;                       (ins 92.08.xx)|
@@:                                     ;                       (ins 94.04.11)|
;-------------------------------------------------------------- (ins 92.08.xx)|
;   Close process of system timer                               (ins 92.08.xx)|
;-------------------------------------------------------------- (ins 92.08.xx)|
    push    ax                          ;                       (ins 92.08.xx)|
    mov ax,hTimer[si]                   ; Check hTimer          (ins 94.04.12)|
    or  ax,ax                           ; Is there TimerProcess?(ins 92.08.xx)|
    jz  NoKillTimer                     ;   Y:(Nothing)         (ins 92.08.xx)|
    cCall   KillSystemTimer,<ax>        ; Kill system timer     (ins 92.08.xx)|
    mov hTimer[si] ,NULL                ; Clear hTimer          (ins 94.04.12)|
NoKillTimer:                            ;                       (ins 92.08.xx)|
    pop ax                              ;                       (ins 92.08.xx)|
endif   ; NEC_98

TermCom30:
    mov dx,Port[si]     ;Get port base address
    call    Terminate       ;The real work is done here
ifndef  NEC_98
    mov ax,cx           ;Set return code
endif   ; NEC_98

TermCom60:
    pop di
    pop si
    ret

$TRMCOM endp
page

;----------------------------Private-Routine----------------------------;
;
; Terminate - Terminate Device
;
; Restore the port I/O address and make sure that interrupts are off
;
; Entry:
;   AH = Device Id.
;   DX = Device I/O port address.
;   SI --> DEB
; Returns:
;   AX = 0
; Error Returns:
;   AX = -1
; Registers Destroyed:
;   AX,BX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public Terminate                       ;Public for debugging
Terminate proc near

    or  ah,ah           ;LPT port?
    jns Terminate10     ;  No, process COM port
    .errnz  LPTx-10000000b

Terminate5:
ifdef   NEC_98
    call    WPS386                      ; WPS386 I/O trap ON        (ins 940224)
    call    INT_1AH_Close               ;                           (ins 931027)
    call    WPS386                      ; WPS386 I/O trap OFF       (ins 940224)
endif   ; NEC_98
    call    ReleasePort386      ; give port back to 386...
    jmp Terminate50     ;That's all


;-----------------------------------------------------------------------;
;   It is a com port!
;
;       We delay for a bit while the last character finishes transmitting
;       Then we drop DTR and RTS, and disable the interrupt generation at
;       the 8250.  Even if fRTSDisable or fDTRDisable is set, those lines
;       will be dropped when the port is closed.
;-----------------------------------------------------------------------;
;
;   When the OUT2 bit is reset to 0 to disable interrupts, many ports
;   generate an interrupt which can not be identified, because the the
;   interrupt ID register will not be set.  To work around this hardware
;   problem we first mask the IRQ, then set the port into loopback mode
;   and output a NULL to generate a receive interrupt request.  Then we
;   reset OUT2 and unmask the IRQ.  This will cause the interrupt to occur
;   and the interrupt handler will be able to correctly identify the
;   interrupt as coming from the com port.

Terminate10:
ifdef   NEC_98
    push    ax                          ;                       (ins 94.04.18)  |
    call    FlagNotActive               ; don't need to check   (ins 94.04.11)  |
                                        ;   on timer ticks                      |
    pop ax                              ;                       (ins 94.04.18)  |
    FCLI                                ;                       (ins 94.06.06)  |
    test    [si.AOBA_flag],fFIFO_Mode   ;                       (ins 94.04.11)  |
    jz  AOBA_Term35                     ;Now, 8251 mode         (ins 94.04.11)  |
                                        ;                                       |
;;;;;;; begin code : process for AOBA---------------------------(ins 94.04.11)  |
    push    ax                          ;                                       |
    push    dx                          ;                                       |
                                        ;                                       |
    mov dx,Port[si]                     ;                         (ins 94.06.08)|
    add dx,ACE_MSR                      ;Modem Status = 134h      (ins 94.06.08)|
    in  al,dx                           ;Wait until xmit is empty (ins 94.06.08)|
    out 05fh ,al                        ;                         (ins 94.06.08)|
    test    al,ACE_CTS                  ; CS = Off ?              (ins 94.06.08)|
    jz  AOBA_Term30                     ; Y; jump                 (ins 94.06.08)|
                                        ;                                       |
    mov dx,Port[si]                     ;                                       |
    add dx,ACE_LSR                      ;Line Status register                   |
public  AOBA_Term20                     ;                                       |
AOBA_Term20:                            ;                                       |
    in  al,dx                           ;Wait until xmit is empty               |
    out 05fh ,al                        ;           (ins 94.06.07)              |
    test    al,ACE_THRE                 ;  Send FIFO and CCU Send Reg All Empty |
    jz  AOBA_Term20                     ;Not empty yet                          |
                                        ;                                       |
public  AOBA_Term30                     ;                         (ins 94.06.08)|
AOBA_Term30:                            ;                         (ins 94.06.08)|
    call    Set8251mode                 ;Change to 8251 mode                    |
    pop dx                              ;                                       |
    pop ax                              ;                                       |
;;;;;;; end code : process for AOBA-----------------------------(ins 94.04.11)  |
                                        ;                                       |
public  AOBA_Term35                     ;                                       |
AOBA_Term35:                            ;                       (ins 94.04.11)  |
                                        ;                                       |
;;;;;;;;;;;;;;;;8251 F/F interrupt mask ;                       (ins 92.08.xx)  |
                                        ;                       (ins 92.08.xx)  |
Terminate11:                            ;                       (ins 92.08.xx)  |
    cmp ah,ID_Com1                      ; com1 ?                (ins 92.08.xx)  |
    jne Terminate12                     ; No:                   (ins 92.08.xx)  |
    mov dx,MaskFFPort[si]               ;                       (ins 92.08.xx)  |
    in  al,dx                           ; Read Port C data      (ins 92.08.xx)  |
    mov MaskFFShadow[si],al             ;Int mask data          (ins 92.08.xx)  |
                                        ;   Port C save         (ins 92.08.xx)  |
Terminate12:                            ;                       (ins 92.08.xx)  |
    mov dx,MaskFFPort[si]               ;                       (ins 92.08.xx)  |
    mov al,MaskFFShadow[si]             ;                       (ins 92.08.xx)  |
    and  al,not(MSK_TXE+MSK_TXR+MSK_RXR);8251 F/F INT mask      (ins 92.08.xx)  |
    mov MaskFFShadow[si],al             ;8251 Mask data save    (ins 92.08.xx)  |
        out     dx,al                   ;Send mask data         (ins 92.08.xx)  |
                                        ;                       (ins 92.08.xx)  |
;;;;;;;;;;;;;;;;;;;;8259 interrupt mask on IMR ;                (ins 92.08.xx)  |
                                        ;                       (ins 92.08.xx)  |
    push    bx                          ;Save bx                (ins 92.08.xx)  |
    push    dx                          ;Save dx                (ins 92.08.xx)  |
                                        ;                       (ins 92.08.xx)  |
    mov dx,IMRPort[si]                  ;INT Mask Register Port (ins 92.08.xx)  |
    mov bl,Mask8259[si]                 ;8259 Mask bit          (ins 92.08.xx)  |
    in  al,dx                           ;AL=IMRPort             (ins 92.08.xx)  |
    NEWIODELAY 1                        ;<OUT 5F,AL>            (ins 92.11.14)  |
    mov     cx,ax                       ;                       (ins 92.08.xx)  |
    or  al,bl                           ;Mask RS232c            (ins 92.08.xx)  |
    out dx,al                           ;                       (ins 92.08.xx)  |
    NEWIODELAY 1                        ;<OUT 5F,AL>            (ins 92.11.14)  |
    pop dx                              ;                       (ins 92.08.xx)  |
    pop bx                              ;                       (ins 92.08.xx)  |
                                        ;                       (ins 92.08.xx)  |
;--------- internal reset -------------------------------       (ins 92.08.xx)  |
                                        ;                       (ins 92.08.xx)  |
Terminate15:                            ;                       (ins 92.08.xx)  |
    push    cx                          ;                       (ins 92.08.xx)  |
    push    ax                          ;                       (ins 92.08.xx)  |
    push    dx                          ;                       (ins 92.08.xx)  |
    mov cx,3                            ;                       (ins 92.08.xx)  |
    xor ax,ax                           ;                       (ins 92.08.xx)  |
                                        ;                       (ins 92.08.xx)  |
Terminate20:                            ;                       (ins 92.08.xx)  |
    mov dx,CommandPort[si]              ;                       (ins 92.08.xx)  |
    out dx,al                           ;                       (ins 92.08.xx)  |
    NEWIODELAY 20                       ;<OUT 5F,AL>            (ins 92.11.14)  |
    loop    Terminate20                 ;                       (ins 92.08.xx)  |
    mov al,40h                          ;                       (ins 92.08.xx)  |
    out dx,al                           ;                       (ins 92.08.xx)  |
    pop dx                              ;                       (ins 92.08.xx)  |
    pop ax                              ;                       (ins 92.08.xx)  |
    pop cx                              ;                       (ins 92.08.xx)  |
                                        ;                       (ins 92.08.xx)  |
Terminate30:                            ;                       (ins 94.04.15)  |
else    ; NEC_98
    inc dx          ;Disable chip interrupts
    .errnz ACE_IER-ACE_RBR-1
    mov al, ACE_ERBFI       ;   except receive
    out dx,al
    call    FlagNotActive       ; don't need to check for postmessage
                    ;   on timer ticks
    add dl,ACE_LSR-ACE_IER  ;--> line status register
    iodelay

Terminate20:
    in  al,dx           ;Wait until xmit is empty
    and al,ACE_THRE+ACE_TSRE
    cmp al,ACE_THRE+ACE_TSRE
    jne Terminate20     ;Not empty yet

Terminate30:
    xor al, al
    test    EFlags[si], fFIFOpre    ;Q: leave FIFO enabled?
    jz  short @F        ;   N:
    mov al, ACE_TRIG14 OR ACE_EFIFO OR ACE_CRFIFO OR ACE_CTFIFO
@@:
    sub dl, ACE_LSR-ACE_FCR
    out dx, al
    iodelay
    call    MaskIRQ
    add dl, ACE_MCR-ACE_FCR ;--> Modem Control Register
    in  al,dx
    iodelay
    mov ah, al
    or  al,ACE_LOOP     ; turn on loopback
    out dx, al
    iodelay
    sub dl, ACE_MCR-ACE_THR
    xor al, al
    out dx, al          ; output a NULL to generate an int
    iodelay
    add dl, ACE_LSR-ACE_THR
Terminate35:
    in  al,dx           ;Wait until xmit is empty
    and al,ACE_THRE+ACE_TSRE
    cmp al,ACE_THRE+ACE_TSRE
    jne Terminate35     ;Not empty yet
    mov al, ah
    dec dl          ; now clear OUT2 and loopback
    .errnz  ACE_LSR-ACE_MCR-1
    and al,ACE_DTR+ACE_RTS  ;Leave DTR, RTS high if already so
    out dx,al           ;  but tri-state IRQ line

    call    UnmaskIRQ       ; this will cause the receive int
                    ; to occur and be processed
    sub dl, ACE_MCR-ACE_IER ; clear the receive int enable
    xor al, al
    out dx, al
    dec dx
    .errnz  ACE_IER-ACE_RBR-1
    call    MaskIRQ
endif   ; NEC_98

;******* DANGER! ***** NOTICE! ***** DANGER! ***** WARNING! ***** NOTICE!
;
; Terminate45 is a secondary entrypoint into this routine--it's called
; by the initialization code when that code is unable to properly init
; a com port and needs to clean-up the mess it's made.
;
;******* DANGER! ***** NOTICE! ***** DANGER! ***** WARNING! ***** NOTICE!

Terminate45:
    push    cx          ;Save original cx
    push    bx          ;Save original bx

ifdef   NEC_98
    dec IntVecIntCount[si]              ;USE Rotate_Pic()       (ins 92.08.xx)
endif   ; NEC_98
    cmp [fVPICD], 0     ;Q: VPICD bimodel services available?
    jl  short @F        ;   N:
    mov ax, ds          ;   Y: use them
    mov es, ax
    lea di, [si+SIZE ComDEB]
    mov ax, VPICD_Remove_Handler
    call    [lpfnVPICD]
@@:

    mov di, [si.IRQhook]
    dec [di.HookCnt]        ;Q: last port using IRQ?
    jne short Terminate495  ;   N: unmask IRQ again
    mov al, 0FFh
    xchg    al, [di.VecN]       ;Interrupt vector number
    cmp al, 0FFh        ;Q: IRQ vector hooked?
    je  short Terminate49   ;   no...

IFDEF No_DOSX_Bimodal_Services
    cmp [Using_DPMI], 0
    jz  short term_no_dpmi

;
; unhook RM vector thru DPMI for standard mode
;
    push    ax
    mov ax, Int31_Get_Version SHL 8
    int 31h
    mov bl, [si.IntVecNum]
    mov bh, bl
    add bl, dh          ; assume master PIC
ifndef  NEC_98
    sub bh, 8           ;Q: IRQ in master?
    jb  @f          ;   Y: add master's base vec
    add bh, dl          ;   N: add slave's base vec
    mov bl, bh
endif   ; NEC_98
@@:
    mov dx, wo [di.RM_OldIntVec][0]
    mov cx, wo [di.RM_OldIntVec][2]
    mov ax, Set_RM_IntVector
    int 31h
    pop ax
term_no_dpmi:
ENDIF
    mov dx, __WinFlags      ;In Standard mode the PIC interrupt
    test    dl, WF_STANDARD     ;  priorities are changed to favor
    jz  Terminate48     ;  the comm ports.

    call    Rotate_PIC      ;This port no longer needs priority

Terminate48:
    ; *** reset int vector to it's previous state
    assumes ds,nothing
    push    ds          ;Save original DS [rkh] ...
    lds dx, [di.OldIntVec]
    mov ah, 25h         ;DOS Set Vector Function
    int 21h         ;Set the DOS vector
    pop ds          ;Original DS
    assumes ds,data

; *** interrupt vectors have been reset if needed at this point ***
;
Terminate49:
    mov cl, [di.OldMask]

; Set the 8259 interrupt mask bit for this IRQ.  Leave interrupts enabled
; if they were already enabled when the comm port was initialized by us.

    or  cl, cl
    jnz @f
Terminate495:
    call    UnmaskIRQ
@@:

    xor ax, ax
    xchg    ax, [si.NextDEB]
    cmp [di.First_DEB], si  ;Q: DEB first for IRQ hook?
    je  short Terminate46   ;   Y:
    mov bx, [di.First_DEB]  ;   N: get first
Terminate453:
    cmp [bx.NextDEB], si    ;Q: does this DEB point to one terminating?
    je  Terminate455        ;   Y:
    mov bx, [bx.NextDEB]    ;   N: get next DEB
    jmp Terminate453
Terminate455:
    mov [bx.NextDEB], ax    ; link previous DEB to NextDEB
    jmp short Terminate47
Terminate46:
    mov [di.First_DEB], ax  ; point IRQ hook at NextDEB
Terminate47:
ifdef   NEC_98
    test    EFlags[si], fNoFIFO         ;                       (ins 94.06.06)  |
    jnz @F                              ;                       (ins 94.06.06)  |
    mov al,preFCRShadow                 ;                       (ins 94.06.06)  |
    and al,00000110b                    ;Clear FIFO buffer      (ins 94.06.06)  |
    mov dx,Port[si]                     ;                       (ins 94.06.06)  |
    add dx,ACE_FCR                      ;FIFO control register  (ins 94.06.06)  |
    out dx, al                          ;                       (ins 94.06.06)  |
@@:                                     ;                       (ins 94.04.13)  |
    FSTI                                ;                       (ins 94.06.06)  |
endif   ; NEC_98
    pop bx          ;Original BX

    call    ReleaseCOMport386   ; give port back to 386...

    pop cx          ;Original CX

Terminate50:                ;Also called from $INICOM !
    xor ax,ax           ;Indicate no error
    ret             ;Port is closed and deallocated

Terminate   endp
page

;----------------------------Public Routine-----------------------------;
;
; $ENANOTIFY - Enable Event Notification
;
; Entry:
;   AH     =  Device ID
;   BX     =  Window handle for PostMessage
;   CX     =  Receive threshold
;   DX     =  Transmit threshold
; Returns:
;   AX = 1, if no errors occured
; Error Returns:
;   AX = 0
; Registers Preserved:
;   BX,SI,DI,DS
; Registers Destroyed:
;   AX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $ENANOTIFY
$ENANOTIFY proc near
    push    si
    call    GetDEB
    mov ax, 0
    jc  scb_exit

    mov ax, cx
    inc ax
    jz  short scb_recv_ok
    cmp cx, [si.QInSize]    ;Q: receive threshold reasonable?
    jb  short scb_recv_ok   ;   Y:
%OUT should we return an error, if thresholds invalid?
    mov cx, [si.QInSize]    ;   N:
    sub cx, 10
scb_recv_ok:
    inc dx
    jz  short scb_send_ok
    dec dx
    cmp dx, [si.QOutSize]   ;Q: receive threshold reasonable?
    jb  short scb_send_ok   ;   Y:
    mov dx, [si.QOutSize]   ;   N:
    sub dx, 10
scb_send_ok:
    mov [si.NotifyHandle], bx
    mov [si.NotifyFlagsHI], CN_Notify
    or  bx, bx          ;Q: null callback?
    jnz scb_save_thresholds ;   N: save thresholds
    or  cx, -1          ;   Y: zero thresholds
    xor dx, dx
    mov [si.NotifyFlagsHI], 0
scb_save_thresholds:
    mov [si.RecvTrigger], cx
    mov [si.SendTrigger], dx
    or  [si.NotifyFlagsHI], CN_TRANSMIT ; we don't want to send
                    ; a transmit trigger notification until
                    ; the transmit buffer has been filled
                    ; above the trigger level and then
                    ; emptied below it again!

    cmp wo lpPostMessage[2], 0  ;Q: gotten addr of PostMessage yet?
    jne short scb_good      ;   Y:
    push    ds          ;   N: get module handle of USER
    lea ax, szUser
    push    ax
    cCall   GetModuleHandle

    push    ax          ; module handle
    mov ax, POSTMESSAGE
    cwd
    push    dx
    push    ax
    cCall   GetProcAddress
    mov wo lpPostMessage[0], ax ; save received proc address
    mov wo lpPostMessage[2], dx

scb_good:
    mov ax, 1

scb_exit:
    pop si
    ret
$ENANOTIFY endp
page

;----------------------------Public Routine-----------------------------;
;
; $SETQUE - Set up Queue Pointers
;
; Sets pointers to Receive and Transmit Queues, as provided by the
; caller, and initializes those queues to be empty.
;
; Queues must be set before $INICOM is called!
;
; Entry:
;   AH     =  Device ID
;   ES:BX --> Queue Definition Block
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = error code
; Registers Preserved:
;   BX,DX,SI,DI,DS
; Registers Destroyed:
;   AX,CX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $SETQUE
$SETQUE proc near

    push    si          ;These will be used
    push    di
    call    GetDEB          ;Get DEB
    jc  SetQue10        ;Invalid, ignore the call
    js  SetQue10        ;Ignore call for LPT ports
    push    ds          ;Set ds:si --> QDB
    push    es          ;Set es:di --> to ComDCB.QInAddr
    pop ds
    assumes ds,nothing
    pop es
    assumes es,Data
    lea di,QInAddr[si]
    mov si,bx
    cld
    FCLI             ;No one else can play with queues
    movsw               ; QInAddr     = QueueRxAddr
    movsw
    .errnz QueueRxAddr
    sub si, 4           ; AltQInAddr  = QueueRxAddr
    mov cx, 5           ; QInSize     = QueueRxSize
    rep movsw           ; QOutAddr    = QueueTxAddr
    sub si, 4
    mov cx, 3           ; AltQOutAddr = QueueTxAddr
    rep movsw           ; QOutSize    = QueueTxSize

    xor ax,ax           ;Will do some zero filling
    mov cl,(EFlags-QInCount)/2
    .errnz (EFlags-QInCount) AND 0FE01h
    rep stosw
    FSTI
    push    es          ;Restore the data segment
    pop ds
    assumes ds,Data
    assumes es,nothing

SetQue10:
    pop di          ;Restore saved registers
    pop si
    ret

; The above code made a few assumptions about how memory
; was allocated within the structures:

    .errnz AltQInAddr-QInAddr-4
    .errnz (QueueRxSize-QueueRxAddr)-(QInSize-AltQInAddr)
    .errnz (QueueTxAddr-QueueRxSize)-(QOutAddr-QInSize)
    .errnz AltQOutAddr-QOutAddr-4
    .errnz (QueueTxSize-QueueTxAddr)-(QOutSize-AltQOutAddr)

    .errnz QueueRxSize-QueueRxAddr-4
    .errnz QueueTxAddr-QueueRxSize-2
    .errnz QueueTxSize-QueueTxAddr-4

    .errnz QInSize-AltQInAddr-4
    .errnz QOutAddr-QInSize-2
    .errnz QOutSize-AltQOutAddr-4

    .errnz QInCount-QOutSize-2
    .errnz QInGet-QInCount-2
    .errnz QInPut-QInGet-2
    .errnz QOutCount-QInPut-2
    .errnz QOutGet-QOutCount-2
    .errnz QOutPut-QOutGet-2
    .errnz EFlags-QOutPut-2       ;First non-queue item

$SETQUE endp
page

;----------------------------Public Routine-----------------------------;
;
; $SETCOM - Set Communications parameters
;
; Re-initalizes the requested port if present, and sets up the
; port with the given attributes when they are valid.
;
; For LPT ports, just copies whatever is given since it's ignored
; anyway.
;
; Entry:
;   ES:BX --> DCB with all fields set.
; Returns:
;   'Z' Set if no errors occured
;   AX = 0
; Error Returns:
;   'Z' clear if errors occured
;   AX = initialization error code.
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $SETCOM
$SETCOM proc near

    cld
    push    si
    push    di
    mov ah,es:[bx.DCB_Id]   ;Get device i.d.
    call    GetDEB          ;Get DEB pointer in SI
    mov ax,IE_BadID     ;Assume unknown device
    jc  SetCom10        ;Invalid device, return error
    jns SetCom20        ;COM port
    call    SetCom100       ;Copy the DCB

SetCom5:
    xor ax,ax           ;Show no error

SetCom10:
    or  ax,ax           ;Set/clear 'Z'
    pop di          ;  and exit
    pop si
    ret

;-----------------------------------------------------------------------;
;       Have a comm device, check all the serial parameters to make
;       sure they are correct before moving the new DCB into our space
;       and changing the ACE parameters.
;-----------------------------------------------------------------------;

SetCom20:
ifdef   NEC_98
    FCLI                                ;                       (ins 94.05.17)  |
    test    EFlags[si], fNoFIFO         ;                       (ins 94.04.13)  |
    jnz @F                              ;no AOBA on board       (ins 94.04.13)  |
    call    Set8251mode                 ;Change to 8251 mode    (ins 94.04.12)  |
@@:                                     ;                       (ins 94.04.13)  |
    FSTI                                ;                       (ins 94.06.11)
endif   ; NEC_98
    call    SetCom300       ;Baud rate valid?
    jcxz    SetCom10        ;  No, return error
    call    SetCom400       ;Byte size/parity/stop bits correct?
    jc  SetCom10        ;  No, return error

; The parameters seem correct.  Copy the DCB into our space and
; initialize the ACE with the new parameters

ifdef   NEC_98
    mov dx,MaskFFPort[si]               ;Disable INT from 8251  (ins 92.08.xx)|
    cmp es:[bx.DCB_Id],ID_COM1          ; com1 ?                (ins 92.08.xx)|
    jne SetCom2001                      ;  no, Jump SetCom2001  (ins 92.08.xx)|
    in  al,dx                           ; Read port_c           (ins 92.08.xx)|
    jmp short SetCom2002                ;                       (ins 92.08.xx)|
                                        ;                       (ins 92.08.xx)|
SetCom2001:                             ;                       (ins 92.08.xx)|
    mov al,MaskFFShadow[si]             ;read 8251 mask data    (ins 92.08.xx)|
                                        ;                       (ins 92.08.xx)|
SetCom2002:                             ;                       (ins 92.08.xx)|
    and al,not(MSK_TXE+MSK_TXR+MSK_RXR) ;                       (ins 92.08.xx)|
    mov MaskFFShadow[si],al             ;write 8251 mask data   (ins 92.08.xx)|
    out dx,al                           ;                       (ins 92.08.xx)|
else    ; NEC_98
    mov dx,Port[si]     ;Disable interrupts from the 8250
    inc dx
    .errnz ACE_IER-1
    xor ax,ax
    out dx,al
endif   ; NEC_98
    call    FlagNotActive

    call    SetCom100       ;Copy the DCB
    mov bx,si           ;Set ES:BX --> DCB
ifdef   NEC_98
    FCLI                                ;                       (ins 94.06.11)  |
endif   ; NEC_98
    call    SetCom200       ;Get timeout masks
ifdef   NEC_98
    FSTI                                ;                       (ins 94.06.11)
endif   ; NEC_98
    xchg    al,ah           ;Want them in the correct registers
    mov wo MSRMask[si],ax
    .errnz MSRInfinite-MSRMask-1

    call    SetCom400       ;Get line control byte
    push    ax          ;  and save LCR value
ifndef  NEC_98
    inc dx          ;--> LCR
    inc dx
    .errnz ACE_LCR-ACE_IER-2
    or  al,ACE_DLAB     ;Want access to divisor latch
    out dx,al
endif   ; NEC_98
    mov RxMask[si],ah       ;Save Receive character mask
    mov ax,di           ;Get flags mask, error mask
    and [si.DCB_Flags],ah   ;Disable parity checking if no parity
    mov ErrorMask[si],al    ;Save line status error mask

    call    SetCom300       ;Get baud rate
ifdef   NEC_98
;-----------------------------------------------------------------------------+
;       timer set !!                                            (ins 92.08.xx)|
;---------------------------------------------------------------(ins 92.08.xx)|
    cmp es:[bx.DCB_Id],00h              ;Comm1 ?                (ins 92.08.xx)|
    jne SetCom21                        ;  No                   (ins 92.08.xx)|
    mov al,RS_TIME_MOD          ;Mode = counter2,LBS->MSB,mode2 (ins 92.08.xx)|
    out TIME_CTL,al                     ; (8253) (priscaler)    (ins 92.08.xx)|
        NEWIODELAY 2                    ;       <OUT 5F,AL>     (ins 92.11.14)|
    mov ax,cx                           ;divisor data set (LSB) (ins 92.08.xx)|
    out TIMER2,al                       ;               '=075H' (ins 92.08.xx)|
        NEWIODELAY 2                    ;       <OUT 5F,AL>     (ins 92.11.14)|
    mov al,ah                           ;divisor data set (MSB) (ins 92.08.xx)|
    out TIMER2,al                       ;                       (ins 92.08.xx)|
                                        ;                       (ins 92.08.xx)|
SetCom21:                               ;                       (ins 92.08.xx)|
    mov dx,CommandPort[si]              ;8251 mode Inst Addr    (ins 92.08.xx)|
    xor ax,ax                           ;                       (ins 92.08.xx)|
    FCLI                                ;                       (ins 94.06.11)|
    out dx,al                           ;null out               (ins 92.08.xx)|
        NEWIODELAY 20                   ;       <OUT 5F,AL>     (ins 92.11.14)|
    out dx,al                           ;null out               (ins 92.08.xx)|
        NEWIODELAY 20                   ;       <OUT 5F,AL>     (ins 92.11.14)|
    out dx,al                           ;null out               (ins 92.08.xx)|
        NEWIODELAY 20                   ;       <OUT 5F,AL>     (ins 92.11.14)|
    mov al,INTER_RESET                  ;reset (=40h)           (ins 92.08.xx)|
    out dx,al                           ;                       (ins 92.08.xx)|
    pop ax                              ;Get Mode Inst (8251)   (ins 92.08.xx)|
        NEWIODELAY 20                   ;       <OUT 5F,AL>     (ins 92.11.14)|
    out dx,al                           ;mode set               (ins 92.08.xx)|
    FSTI                                ;                       (ins 94.06.11)|
;--------------------------------------------------------------------------   |
;       relative DTR, RTS to FRTSDisable & FDTRDisable                        |
;       for hardware handshake !?                                             |
;--------------------------------------------------------------------------   |
                                        ;NOW,DCB_Flags is 8250's format !!    |
    mov al,[si.DCB_Flags]               ;Align DTR/RTS disable flags for 8251 |
    mov ah,al                           ;                                     |
    and al,FRTSDisable                  ;= 00000010b ______.                  |
    and ah,FDTRDisable                  ;= 10000000b ______I___________.      |
    shl al,1                            ;                  I           I      |
    shl al,1                            ; 8251 mode (7)(6)(5)(4)(3)(2)(1)(0)  |
    shl al,1                            ;                  I        I  I  I   |
    shl al,1                            ;          RTS ____I RX_E __I  I  I   |
    rol ah,1                            ;                    DTR ______I TX_E |
    rol ah,1                            ;                                     |
    or  al,ah                           ;                                     |
    mov cl,al                           ;                                     |
    or  al,RX_E+TX_E                    ;add the tx.disable and rx.disable    |
    xor al,DTR+RTS                      ; Enable = "On"                       |
    FCLI                                ;                       (ins 94.06.11)|
    out dx,al                           ;NOW,DCB_Flags is 8251's format !!    |
    FSTI                                ;                       (ins 94.06.11)|
    mov CommandShadow[si],al            ;Save Command                         |
else    ; NEC_98
    sub dl,ACE_LCR-ACE_DLL  ;--> LSB of divisor latch
    mov al,cl
    out dx,al
    mov al,ch
    inc dx          ;--> MSB of divisor latch
    .errnz ACE_DLM-ACE_DLL-1
    iodelay
    out dx,al
    inc dx          ;--> LCR and clear divisor access bit
    inc dx
    .errnz ACE_LCR-ACE_DLM-2
    pop ax
    out dx,al

    inc dx          ;--> Modem Control Register
    .errnz ACE_MCR-ACE_LCR-1
endif   ; NEC_98

;-----------------------------------------------------------------------;
;       Compute initial state of DTR and RTS.  If they have been disabled,
;       then do not raise them, and disallow being used as a handshaking
;       line.  Also compute the bits to use as hardware handshake bits
;       (DTR and/or RTS as indicated, qualified with the disabled flags).
;-----------------------------------------------------------------------;

    mov al,[si.DCB_Flags]   ;Align DTR/RTS disable flags for 8250
    and al,fRTSDisable+fDTRDisable
    rol al,1            ;d0 = DTR, d2 = RTS  (1 = disabled)
    shr al,1            ;'C'= DTR, d1 = RTS
    adc al,0            ;d0 = DTR, d1 = RTS
    .errnz  fRTSDisable-00000010b
    .errnz  fDTRDisable-10000000b
    .errnz  ACE_DTR-00000001b
    .errnz  ACE_RTS-00000010b

    mov ah,al           ;Save disable mask
ifndef  NEC_98
    xor al,ACE_DTR+ACE_RTS+ACE_OUT2
    out dx,al           ;Set Modem Control Register
endif   ; NEC_98

    mov al,[si.DCB_Flags2]  ;Get hardware handshake flags
    rol al,1            ;Align flags as needed
    rol al,1
    rol al,1
    and al,ACE_DTR+ACE_RTS  ;Mask bits of interest
    not ah          ;Want inverse of disable mask
    and al,ah           ;al = bits to handshake with
    mov HHSLines[si],al     ;Save for interrupt code

    .errnz  fDTRFlow-00100000b
    .errnz  fRTSFlow-01000000b
    .errnz  ACE_DTR-00000001b
    .errnz  ACE_RTS-00000010b

    mov al,[si.DCB_Flags]   ;Compute the mask for the output
    shl al,1            ;  hardware handshake lines
    and al,ACE_DSR+ACE_CTS
    mov OutHHSLines[si],al

    .errnz  fOutXCTSFlow-00001000b
    .errnz  fOutXDSRFlow-00010000b
    .errnz  ACE_CTS-00010000b
    .errnz  ACE_DSR-00100000b

; Compute the queue count where XOff should be issued (or hardware
; lines dropped).  This will prevent having to do it at interrupt
; time.

    mov ax,QInSize[si]      ;Get where they want it
    sub ax,[si.DCB_XoffLim] ;  and compute queue count
    mov XOffPoint[si],ax

ifdef   NEC_98
    FSTI                                ;                       (ins:94.06.11)  |
    test    EFlags[si], fNoFIFO         ;                                       |
    jnz SetCom21_NO_AOBA                ; no AOBA on board                      |
                                        ;                       (ins 94.04.11)  |
; Enable FIFO if possible when baudrate >= 1200                 (ins 94.04.11)  |
    mov dx,Port[si]                     ;                       (ins 94.04.11)  |
    add dx,ACE_FCR                      ;                       (ins 94.04.11)  |
                                        ;                       (ins 94.04.11)  |
    mov ax, [si.DCB_BaudRate]           ;                       (ins 94.04.11)  |
    cmp ah, -1                          ;Q: baudrate index?     (ins 94.04.11)  |
    jne sc_fifo                         ;   N: baudrate >= 1200, enable FIFO    |
sc_fifo:                                ;                       (ins 94.04.11)  |
    or  [si. AOBA_flag],fFIFO_Mode      ;                       (ins 94.04.14)  |
    mov al, ACE_TRIG04 OR ACE_EFIFO OR ACE_CRFIFO OR ACE_CTFIFO;(ins 94.06.07)  |
    out dx, al                          ; attempt to enable FIFO(ins 94.06.07)  |
    test    EFlags[si], fFIFOchkd       ;Q: FIFO detect been done?      ;       |
    jnz sc_fifodone                     ;   Y: enabled FIFO     (ins 94.04.11)  |
    or  EFlags[si], fFIFOchkd           ;                       (ins 94.04.11)  |
    jmp short sc_fifodone               ;                       (ins 94.05.12)  |
sc_nofifo:                              ;                       (ins 94.04.11)  |
    jmp short SetCom21_NO_AOBA          ;                       (ins 94.05.24)  |
sc_fifodone:                            ;                       (ins 94.04.11)  |
    test    [si.AOBA_flag],fFIFO_Mode   ;                       (ins 94.04.15)  |
    jz  SetCom21_NO_AOBA                ;                       (ins 94.04.15)  |
    mov dx,Port[si]                     ;                       (ins 94.04.11)  |
    add dx,ACE_MSR                      ;--> Modem Status reg   (ins 94.04.11)  |
    in  al,dx                           ;Throw away 1st status read             |
    NEWIODELAY 2                        ;       <OUT 5F,AL>     (ins 94.04.18)  |
    in  al,dx                           ;Save 2nd for MSRWait (Clear MSR int)   |
    call    Set8251mode                 ;Change to 8251 mode    (ins 94.05.12)  |
    FSTI                                ;                       (ins 94.06.09)  |
    call    MSR_READ_Call               ;AOBA-bug ins 94.11.19 KBNES            |
    jmp short   @f                      ;                       (ins 94.04.11)  |
SetCom21_NO_AOBA:                       ;                       (ins 94.04.11)  |
    FSTI                                ;                       (ins 94.06.09)  |
    and [si.AOBA_flag],not(fFIFO_Mode)  ;                       (mov 94.05.24)  |
    call    MSR_READ_Call               ;               [QN]    (ins 92.08.05)  |
@@:                                     ;                       (ins 94.04.11)  |
else    ; NEC_98
; Enable FIFO if possible when baudrate >= 4800
;
    sub dl,ACE_MCR - ACE_FCR    ; dx = FCR
    test    EFlags[si], fNoFIFO ;Q: FIFO can be enabled?
    jnz sc_nofifo       ;   N:
    mov ax, [si.DCB_BaudRate]
    cmp ax, 4800
    jb  sc_nofifo
    cmp ah, -1          ;Q: baudrate index?
    jne sc_fifo         ;   N: baudrate >= 4800, enable FIFO
    cmp ax, CBR_4800
    jb  sc_nofifo
%OUT this isn't correct, if lower baudrates are assigned indices above CBR_4800

sc_fifo:
    mov al, ACE_TRIG14 OR ACE_EFIFO OR ACE_CRFIFO OR ACE_CTFIFO
    out dx, al          ; attempt to enable FIFO
    test    EFlags[si], fFIFOchkd   ;Q: FIFO detect been done?
    jnz sc_fifodone     ;   Y: enabled FIFO
    iodelay
    .errnz  ACE_IIDR-ACE_FCR
    in  al, dx
    or  EFlags[si], fFIFOchkd
    test    al, ACE_FIFO_E2     ;Q: FIFO enabled?
    jz  short @F
    test    al, ACE_FIFO_E1     ;Q: 16550A detected?
    jnz sc_fifodone     ;   Y: enabled FIFO
@@:
    iodelay
    or  EFlags[si], fNoFIFO

sc_nofifo:
    xor al, al
    out dx, al
sc_fifodone:

    sub dl,ACE_FCR-ACE_RBR  ; dx -> RBR
;
; Delay for things to settle
;
    push    dx
    cCall   GetSystemMsecCount
    pop dx
    mov cx, ax
delay_loop:
    in  al, dx          ;Read it once
    push    dx
    cCall   GetSystemMsecCount
    pop dx
    sub ax, cx
    cmp ax, DELAY_TIME      ;Q: Timeout reached?
ifndef WOW
    jb  delay_loop      ;   N:
endif

    add dl,ACE_MSR      ;--> Modem Status reg
    in  al,dx           ;Throw away 1st status read
    iodelay
    in  al,dx           ;Save 2nd for MSRWait (Clear MSR int)
endif   ; NEC_98
    mov MSRShadow[si],al

; Win 3.0 didn't check hardware handshaking until the line status changed.
; Allow some apps to keep that behavior.

    push    dx
    xor ax, ax
    cCall   GetAppCompatFlags,<ax>
    pop dx
    test    ax, GACF_DELAYHWHNDSHAKECHK
    jnz short sc_HHSup

;
; HACK FOR SOME MODEMS:  apparently some modems set CTS, but don't set DSR
; which means that COMM.DRV won't send if the app specifies that hardware
; handshaking is based on CTS & DSR being set.
;
    mov ah,OutHHSLines[si]
    mov al, MSRShadow[si]
    and al,ah           ;Only leave bits of interest
    cmp al, ah          ;Q: handshaking lines ok?
    je  short sc_HHSup      ;   Y:
    cmp ah, ACE_CTS OR ACE_DSR  ;Q: app looking for both high?
    jne short sc_HHSdown    ;   N: skip hack
    test    [si.EFlags], fUseDSR    ;Q: DSR is always significant?
    jnz short sc_HHSdown    ;   Y: skip hack
    cmp al, ACE_CTS     ;Q: DSR low & CTS high
    jne short sc_HHSdown    ;   N: skip hack
    and ah, NOT ACE_DSR     ;   Y: ignore DSR line
    mov OutHHSLines[si], ah
    jmp short sc_HHSup

sc_HHSdown:
    or  [si.HSFlag], HHSDown OR HHSAlwaysDown ; flag handshaking down
sc_HHSup:

;-----------------------------------------------------------------------;
;       Now, at last, interrupts can be enabled.  Don't enable the
;       transmitter empty interrupt.  It will be enabled by the first
;       call to KickTx.
;-----------------------------------------------------------------------;

ifndef  NEC_98
    sub dl,ACE_MSR-ACE_IER  ;--> Interrupt Enable Register
endif   ; NEC_98

; flag port as being active
    push    cx
    mov cl, [si.DCB_Id]
    mov ax, 1
    shl ax, cl
    or  [activeCOMs], ax
    pop cx

ifdef   NEC_98
    FCLI                                ;                       (ins 94.06.09)|
    mov dx,MaskFFPort[si]               ;port c address         (ins 92.08.xx)|
    cmp [si.DCB_id],ID_COM1             ;                       (ins 92.08.xx)|
    jne SetCom3001                      ;  no                   (ins 92.08.xx)|
    in  al,dx                           ;                       (ins 92.08.xx)|
    jmp short SetCom3002                ;                       (ins 92.08.xx)|
                                        ;                       (ins 92.08.xx)|
SetCom3001:                             ;                       (ins 92.08.xx)|
    mov al,MaskFFShadow[si]             ;Read 8251 mask data    (ins 92.08.xx)|
                                        ;                       (ins 92.08.xx)|
SetCom3002:                             ;                       (ins 92.08.xx)|
    or  al,MSK_RXR                      ;receive int enable     (ins 92.08.xx)|
    out dx,al                           ;                       (ins 92.08.xx)|
    mov MaskFFShadow[si],al             ;Write 8251 mask data   (ins 92.08.xx)|
    FSTI                                ;                       (ins 94.06.09)|
                                        ;                       (ins 92.08.xx)|
;---------------------------------------------------------------(ins 92.08.xx)|
;       Close process of system timer                           (ins 92.08.xx)|
;---------------------------------------------------------------(ins 92.08.xx)|
    push    ax                          ;                       (ins 92.08.xx)|
    mov ax,hTimer[si]                   ; Check hTimer          (ins 94.04.12)|
    or  ax,ax                           ; TimerProcess Nothing? (ins 92.08.xx)|
    jz  SetNoKillTimer                  ;   Y:(Nothing)         (ins 92.08.xx)|
    cCall   KillSystemTimer,<ax>        ; Kill Syatem Timer     (ins 92.08.xx)|
    mov hTimer[si] ,00h                 ; Clear hTimer          (ins 94.04.12)|
SetNoKillTimer:                         ;                       (ins 92.08.xx)|
                                        ;                       (ins 92.08.xx)|
;---------------------------------------------------------------(ins 92.08.xx)|
;       make process of system timer                            (ins 92.08.xx)|
;---------------------------------------------------------------(ins 92.08.xx)|
    test    DCB_Flags[si],fOutXCTSFlow or fOutXDSRFlow ;        (ins 92.08.xx)|
                                        ; HHS Enable ?          (ins 92.08.xx)|
    jz  SetCom3003                      ;    No: No Set Timer   (ins 92.08.xx)|
    mov ax, 200                         ; create 200msec timer  (ins 92.08.xx)|
    push    ax                          ;                       (ins 92.08.xx)|
    mov ax, _INTERRUPT                  ;                       (ins 92.08.xx)|
    push    ax                          ;                       (ins 92.08.xx)|
    mov ax,TimerProcAdr[si]             ;--> timer processor    (ins 92.08.xx)|
    push    ax                          ;                       (ins 92.08.xx)|
    call    CreateSystemTimer           ; ax = 0, if failed     (ins 92.08.xx)|
    mov hTimer[si] ,ax                  ; Get hTimer            (ins 94.04.12)|
                                        ;                       (ins 92.08.xx)|
SetCom3003:                             ;                       (ins 92.08.xx)|
    pop ax                              ;                       (ins 92.08.xx)|
                                        ;                       (ins 92.08.xx)|
    FCLI                                ;                       (ins 94.06.09)|
    test    [si.AOBA_flag],fFIFO_Mode   ;                       (ins 94.04.15)|
    jz  @F                              ;                       (ins 94.04.15)|
    call    Set8251Mode                 ;FIFODisable            (ins 94.05.16)|
    mov dx,Port[si]                     ;                       (ins 94.04.13)|
    add dx,ACE_FCR                      ;                       (ins 94.04.13)|
    mov al,FIFO_Set_Buf_Clr             ;                       (ins 94.04.15)|
    out dx,al                           ;                       (ins 94.04.13)|
@@:                                     ;                       (ins 94.05.12)|
else    ; NEC_98
    mov al,ACE_ERBFI+ACE_ELSI+ACE_EDSSI
    FCLI
    out dx,al           ;Enable interrupts.
    add dl,ACE_LSR-ACE_IER  ;--> Line Status Register
    iodelay
    in  al,dx           ;Clear any Line Status interrupt
    sub dl,ACE_LSR      ;--> Receiver Buffer Register
    iodelay
    in  al,dx           ;Clear any Received Data interrupt
endif   ; NEC_98
    FSTI
    jmp SetCom5         ;All done

$SETCOM endp
page

FlagNotActive proc near
    push    cx
    mov cl, [si.DCB_Id]
    mov ax, NOT 1
    rol ax, cl
    and [activeCOMs], ax
    pop cx
    ret
FlagNotActive endp

;----------------------------Private-Routine----------------------------;
;
; SetCom100
;
;  Copy the given DCB into the appropriate DEB.  The check has
;  already been made to determine that the ID was valid, so
;  that check can be skipped.
;
; Entry:
;   ES:BX --> DCB
;   DS:SI --> DEB
; Returns:
;   DS:SI --> DEB
;   ES     =  Data
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,ES,DI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom100 proc near
    push    si          ;Save DEB pointer
    mov di,si
    mov si,bx
    push    es
    mov ax,ds
    pop ds
    assumes ds,nothing

    mov es,ax
    assumes es,Data

    mov cx,DCBSize
    cld
    rep movsb
    mov ds,ax
    assumes ds,Data

    pop si          ;Restore DEB pointer
    ret

SetCom100   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom200
;
; Based on whether or not a timeout has been specified for each
; signal, set up a mask byte which is used to mask off lines for
; which we wish to detect timeouts.  0 indicates that the line is
; to be ignored.
;
; Also set up a mask to indicate those lines which are set for
; infinite timeout.  1 indicates that the line has infinite
; timeout.
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   AH = lines to check
;   AL = lines with infinite timeout
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom200 proc near

    xor ax,ax
    xor cx,cx           ;Get mask of lines with timeout = 0
    call    SetCom210
    not al          ;Invert result to get lines to check
    and al,ACE_CTS+ACE_DSR+ACE_RLSD
    xchg    ah,al
    dec cx          ;Get mask of infinite timeouts

SetCom210:
    cmp es:[bx.DCB_RlsTimeout],cx   ;Timeout set to passed value?
    jne SetCom220       ;  No
    or  al,ACE_RLSD     ;  Yes, show checking line

SetCom220:
    cmp es:[bx.DCB_CtsTimeout],cx   ;Timeout set to passed value?
    jne SetCom230       ;  No
    or  al,ACE_CTS      ;  Yes, show checking line

SetCom230:
    cmp es:[bx.DCB_DsrTimeout],cx   ;Timeout set to passed value?
    jne SetCom240       ;  No
    or  al,ACE_DSR      ;  Yes, show checking line

SetCom240:
    ret

SetCom200   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom300
;
; Calculate the correct baudrate divisor for the comm chip.
;
; Note that the baudrate is allowed to be any integer in the
; range 2-19200.  The divisor is computed as 115,200/baudrate.
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   CX = baudrate
; Error Returns:
;   CX = 0 if error
;   AX = error code if invalid baud rate
; Registers Destroyed:
;   AX,CX,FLAGS
; History:
;-----------------------------------------------------------------------;

ifdef   NEC_98
;       If 110bps                               [QN] (ins 92.08.xx)
;               *16     10M     1396            [QN] (ins 92.08.xx)
;                        8M     1135            [QN] (ins 92.08.xx)
;               *64     10M      349            [QN] (ins 92.08.xx)
;                        8M      284            [QN] (ins 92.08.xx)
BaudRateByIndexTable label word             ;; (93.04.12)
    dw 110      ; CBR_110                   ;; (93.04.12)
    dw 300      ; CBR_300                   ;; (93.04.12)
    dw 600      ; CBR_600                   ;; (93.04.12)
    dw 1200     ; CBR_1200                  ;; (93.04.12)
    dw 2400     ; CBR_2400                  ;; (93.04.12)
    dw 4800     ; CBR_4800                  ;; (93.04.12)
    dw 9600     ; CBR_9600                  ;; (93.04.12)
    dw 14400    ; CBR_14400                 ;; (93.04.12)
    dw 19200    ; CBR_19200                 ;; (93.04.12)
    dw 0        ;    0FF19h  (reserved)     ;; (93.04.12)
    dw 0        ;    0FF1Ah  (reserved)     ;; (93.04.12)
    dw 38400    ; CBR_38400  (reserved)     ;; (93.04.12)
    dw 0        ;    0FF1Ch  (reserved)     ;; (93.04.12)
    dw 0        ;    0FF1Dh  (reserved)     ;; (93.04.12)
    dw 0        ;    0FF1Eh  (reserved)     ;; (93.04.12)
    dw 56000    ; CBR_56000  (reserved)     ;; (93.04.12)
else    ; NEC_98
BaudRateByIndexTable label word
    dw 1047     ; CBR_110
    dw 384      ; CBR_300
    dw 192      ; CBR_600
    dw 96       ; CBR_1200
    dw 48       ; CBR_2400
    dw 24       ; CBR_4800
    dw 12       ; CBR_9600
    dw 9        ; CBR_14400
    dw 6        ; CBR_19200
    dw 0        ;    0FF19h  (reserved)
    dw 0        ;    0FF1Ah  (reserved)
    dw 3        ; CBR_38400
    dw 0        ;    0FF1Ch  (reserved)
    dw 0        ;    0FF1Dh  (reserved)
    dw 0        ;    0FF1Eh  (reserved)
    dw 2        ; CBR_56000
endif   ; NEC_98

assumes ds,Data
assumes es,nothing

SetCom300 proc near

ifdef   NEC_98
    push    dx                          ;                       (ins 92.08.05)|
    mov dx,13                           ;base value of div for 8MHz(ins 92.08.05)|
                                        ;                       (ins 92.08.05)|
    mov ax,40h                          ;                       (ins 92.08.05)|
    push    ds                          ;                       (ins 92.08.05)|
    mov ds,ax                           ;DS <- 40H              (ins 92.08.05)|
    test    byte ptr ds:[101h],80h      ;clock late check       (ins 92.08.05)|
    pop ds                              ;                       (ins 92.08.05)|
    jnz SetCom328                       ;= 1 -> 8MHz            (ins 92.08.05)|
                                        ;                                     |
;In the case of 5MHz ----------------(93.03.02)-----------------(ins 93.03.02)|
    xor dx,dx                           ;                       (ins 93.03.02)|
SetCom310:                              ;                       (ins 93.03.02)|
    mov ax,es:DCB_BaudRate[bx]          ;Save data              (ins 93.03.02)|
                                        ;                       (ins 93.03.02)|
    cmp ax, CBR_110                     ;as an index?           (ins 93.04.12)
    jnae    not_index5                  ;                       (ins 93.04.12)
    cmp ax, CBR_19200                   ;                       (ins 93.04.12)
    ja  not_index5                      ;                       (ins 93.04.12)
    cmp ax, CBR_14400                   ;                       (ins 93.04.12)
    je  not_index5                      ;                       (ins 93.04.12)

    push    bx                          ;                       (ins 93.04.12)
    mov bx, ax                          ;                       (ins 93.04.12)
    sub bx, CBR_110                     ;                       (ins 93.04.12)
    shl bx, 1                           ;                       (ins 93.04.12)
    mov ax, cs:[bx+BaudRateByIndexTable];                       (ins 93.04.12)
    pop bx                              ;                       (ins 93.04.12)

not_index5:                             ;                       (ins 93.04.12)
    cmp ax,19200                        ;baudrate=75-19200bps?  (ins 93.03.02)|
    ja  SetCom330                       ; No , go to SetCom330  (ins 93.03.02)|
                                        ;                       (ins 93.03.02)|
    cmp ax,110                          ;baudrate=110 bps?      (ins 93.03.02)|
    je  SetCom335                       ;Yes, go to SetCom335   (ins 93.03.02)|
    xor cx,cx                           ;                       (ins 93.03.02)|
    mov cx,75                           ;                       (ins 93.03.02)|
    div cx                              ;dx:ax/75=ax dx(mod)    (ins 93.03.02)|
    cmp dx,0                            ;Good data ?            (ins 93.03.02)|
    jne SetCom330                       ;  No!                  (ins 93.03.02)|
    cmp ax,0                            ;Good data ?            (ins 93.03.02)|
    je  SetCom330                       ;  No,dx:ax = 0 (?!)    (ins 93.03.02)|
                                        ;                       (ins 93.03.02)|
;       It is good data!!!              ;                       (ins 93.03.02)|
SetCom320:                              ;                       (ins 93.03.02)|
    mov dx,8                            ;base value of div for 5MHz(ins 93.03.02)|
    mov cl,7                            ;                       (ins 93.03.02)|
    shl ax,cl                           ;if 19200, the most high bit is 1.(ins 93.03.02)|
SetCom327:                              ;                       (ins 93.03.02)|
    shl ax,1                            ;                       (ins 93.03.02)|
    jc  SetCom340                       ;OK,go to return !!     (ins 93.03.02)|
    shl dx,1                            ;                       (ins 93.03.02)|
    jmp short SetCom327                 ;                       (ins 93.03.02)|
                                        ;                       (ins 93.03.02)|
SetCom328:      ;In the case of 8MHz---(ins 93.03.02)-----------(ins 93.03.02)|
    mov ax,es:DCB_BaudRate[bx]          ;Save data              (ins 93.03.02)|

    cmp ax, CBR_110                     ;as an index?           (ins 93.04.12)
    jnae    not_index8                  ;                       (ins 93.04.12)
    cmp ax, CBR_9600                    ;                       (ins 93.04.12)
    ja  not_index8                      ;                       (ins 93.04.12)
    cmp ax, CBR_14400                   ;                       (ins 93.04.12)
    je  not_index8                      ;                       (ins 93.04.12)

    push    bx                          ;                       (ins 93.04.12)
    mov bx, ax                          ;                       (ins 93.04.12)
    sub bx, CBR_110                     ;                       (ins 93.04.12)
    shl bx, 1                           ;                       (ins 93.04.12)
    mov ax, cs:[bx+BaudRateByIndexTable];                       (ins 93.04.12)
    pop bx                              ;                       (ins 93.04.12)
not_index8:                             ;                       (ins 93.04.12)
    cmp ax,9600                         ;baudrate=75-9600bps?   (ins 93.03.02)|
    ja  SetCom330                       ; No , go to SetCom330  (ins 93.03.02)|
    cmp ax,110                          ;baudrate=110 bps?      (ins 93.03.02)|
    je  SetCom335                       ;Yes, go to SetCom335   (ins 93.03.02)|
    mov cl,75                           ;                       (ins 93.03.02)|
    div cl                              ;ax/75=al ah(mod)       (ins 93.03.02)|
    cmp ah,0                            ;Good data ?            (ins 93.03.02)|
    jne SetCom330                       ;  No!                  (ins 93.03.02)|
    cmp al,0                            ;Good data ?            (ins 93.03.02)|
    je  SetCom330                       ;  No,ax = 0 (?!)       (ins 93.03.02)|
                                        ;                       (ins 93.03.02)|
;       It is good data!!!              ;                       (ins 93.03.02)|
SetCom329:                              ;                       (ins 93.03.02)|
    shl al,1                            ;                       (ins 93.03.02)|
    jc  SetCom340                       ;                       (ins 93.03.02)|
    shl dx,1                            ;                       (ins 93.03.02)|
    jmp short SetCom329                 ;                       (ins 93.03.02)|
                                        ;                       (ins 93.03.02)|
;-------(end 93.03.02)----------------------------------------- (ins 93.03.02)|
SetCom330:                              ;                       (ins 92.08.05)|
    xor cx,cx                           ;                       (ins 92.08.05)|
    mov ax,IE_Baudrate                  ;Show Unsupported BaudRate(ins 92.08.05)|
    pop dx                              ;                       (ins 92.08.05)|
    ret                                 ;                       (ins 92.08.05)|
                                        ;                       (ins 92.08.05)|
SetCom335:                              ;for 110bps             (ins 92.08.05)|
    cmp dx,13                           ;8MHz ?                 (ins 92.08.05)|
    je  SetCom338                       ;                       (ins 92.08.05)|
    mov cx,1396                         ;Save timer value for 110bps(ins 92.08.05)|
    jmp short SetCom339                 ;                       (ins 92.08.05)|
SetCom338:                              ;                       (ins 92.08.05)|
    mov cx,1135                         ;Save timer value for 110bps(ins 92.08.05)|
SetCom339:                              ;                       (ins 92.08.05)|
    pop dx                              ;                       (ins 92.08.05)|
    ret                                 ;                       (ins 92.08.05)|
SetCom340:                              ;                       (ins 92.08.05)|
    mov cx,dx                           ;Save result            (ins 92.08.05)|
    pop dx                              ;                       (ins 92.08.05)|
    ret                                 ;                       (ins 92.08.05)|
else    ; NEC_98
    push    dx
    mov cx,es:[bx.DCB_BaudRate] ;Get requested baud rate
    xor ax,ax           ;Assume error
    cmp cx, CBR_110     ;Q: baudrate specified as an index?
    jae by_index
    cmp cx,2            ;Within valid range?
    jnae    SetCom310       ;  No, return error

    mov dx,1            ;(dx:ax) = 115,200
    mov ax,0C200h
    div cx          ;(ax) = 115,200/baud

SetCom310:
    mov cx,ax           ;(cx) = baud rate, or error code (0)
    mov ax,IE_Baudrate      ;Set error code incase bad baud
    pop dx
    ret

by_index:
    cmp cx, CBR_56000       ;Q: above supported?
    ja  SetCom310       ;   Y: return error
    push    bx
    mov bx, cx
    sub bx, CBR_110
    shl bx, 1
    mov ax, cs:[bx+BaudRateByIndexTable]    ; get divisor
    pop bx
    jmp SetCom310       ;   Y: return error
endif   ; NEC_98


SetCom300   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom400
;
; Check the line configuration (Parity, Stop bits, Byte size)
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   'C' clear if OK
;   AL = Line Control Register
;   AH = RxMask
;   DI[15:8] = Flags mask (to remove parity checking)
;   DI[7:0]  = Error mask (to remove parity error)
; Error Returns:
;   'C' set if error
;   AX = error code
; Registers Destroyed:
;   AX,CX,DI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom400   proc   near

ifdef   NEC_98
assumes es,nothing
;[QN](ins 92.08.xx)---------------------------------------------------------+
;                                                                       [QN]|
; (Parity, Stop bits, Byte size) Check Signal Status                    [QN]|
;                                                                       [QN]|
;       Entry:  es:bx --> DCB                                           [QN]|
;                                                                       [QN]|
;       Exit:   es:bx --> DCB                                           [QN]|
;               'C' clear if OK                                         [QN]|
;                 al = 8251 Mode instruction                            [QN]|
;                 ah = RxMask                                           [QN]|
;                 di[15:8] = Flags mask (to remove parity checking)     [QN]|
;                 di[7:0]  = Error mask (to remove parity error)        [QN]|
;               'C' set if error                                        [QN]|
;                 ax = error code                                       [QN]|
;                                                                       [QN]|
;       Uses:   ax,cx,di,flags                                          [QN]|
;                                                                       [QN]|
;       8251 mode instruction format                                    [QN]|
;               (7)   (6)   (5)   (4)   (3)   (2)   (1)   (0)           [QN]|
;               <------->   <------->   <------->   <------->           [QN]|
;               stop bit    parity bit  byte size   clock(x16)=10b      [QN]|
;                0     0 <----------------- none                        [QN]|
;                0     1 <----------------- 1                           [QN]|
;                1     0 <----------------- 1.5                         [QN]|
;                1     1 <----------------- 2                           [QN]|
;                            0 <------------------ odd parity           [QN]|
;                            1 <------------------ even parity          [QN]|
;                                  0 <----------------- parity disable  [QN]|
;                                  1 <----------------- parity enable   [QN]|
;                                        0     0 <--------- 5 bit       [QN]|
;                                        0     1 <--------- 6 bit       [QN]|
;                                        1     0 <--------- 7 bit       [QN]|
;                                        1     1 <--------- 8 bit       [QN]|
;                                                     0   0 <-sync      [QN]|
;                                                     0   1 <-async x1  [QN]|
;                                                     1   0 <-async x16 [QN]|
;                                                     1   1 <-async x64 [QN]|
;       ins 92.08.05                                                    [QN]|
;-----------------------------------------------------------------------[QN]|
    mov ax,wo es:[bx.DCB_ByteSize]          ;al=byte size, ah=parity    [QN]|
    mov ah,es:DCB_Parity[bx]                ;ah =parity                 [QN]|
    cmp ah,2                                ;Is parity incorrect ?      [QN]|
    ja  SetCom470                           ;  Yes, return error        [QN]|
    mov di,0FF00h+ACE_OR+ACE_PE+ACE_FE+ACE_BI;                          [QN]|
                                        ;ACE_OR(overrun err)            [QN]|
                                        ;ACE_PE(parity err)             [QN]|
                                        ;ACE_FE(framing err)            [QN]|
                                        ;ACE_BI(break interrupt)        [QN]|
                                        ;                               [QN]|
    or  ah,ah                           ;non-parity ?                   [QN]|
    jnz SetCom410                       ;  No, It has parity.           [QN]|
    xor di,(fParity*256)+ACE_PE         ;                               [QN]|
                                        ;Don't check parity             [QN]|
SetCom410:                              ;                               [QN]|
    cmp al,8                            ;byte size = 8 Bit ?            [QN]|
    ja  SetCom460                       ;If bytesize >  8 Bit , error!! [QN]|
    cmp al,5                            ;If bytesize <  5 Bit           [QN]|
    jc  SetCom460                       ;   , Error!!                   [QN]|
SetCom420:                              ;                               [QN]|
    sub al,5                            ;Shift byte size to bit1&0      [QN]|
                                        ;                               [QN]|
    add ah,ah                           ;Map parity to ACE bits         [QN]|
    jz  SetCom430                       ;0=>0, 1=>1, 2=>3, 3=>5, 4=>7   [QN]|
    dec ah                              ;                               [QN]|
                                        ;                               [QN]|
SetCom430:                              ;                               [QN]|
    shl ax,1                            ;Align with 8251 parity bits    [QN]|
    shl ax,1                            ;                               [QN]|
    shl ah,1                            ;                               [QN]|
    shl ah,1                            ;                               [QN]|
    or  al,ah                           ;Add to byte size               [QN]|
                                        ;                               [QN]|
    mov ah,es:[bx.DCB_StopBits]      ;Get # of stop bits 0=1,1/2= .GT.1 [QN]|
    cmp ah,3                            ;Is it out of area ?            [QN]|
    jnc SetCom470                       ;  Yes, Return Error            [QN]|
    inc ah                              ; stop1 = 00h                   [QN]|
    ror ah,1                            ; stop1.5 = 01h                 [QN]|
    ror ah,1                            ; stop2 = 10h                   [QN]|
                                        ;                               [QN]|
SetCom440:                              ;                               [QN]|
    or  al,ah                           ;                               [QN]|
    or  al,00000010b                    ;clock late (x16) set           [QN]|
else    ; NEC_98
    mov ax,wo es:[bx.DCB_ByteSize]  ;al = byte size, ah = parity
    cmp ah,SpaceParity      ;Parity out of range?
    ja  SetCom470       ;  Yes, return error
    mov di,0FF00h+ACE_OR+ACE_PE+ACE_FE+ACE_BI
    or  ah,ah           ;Is parity "NONE"?
    jnz SetCom410       ;  No, something is there for parity
    xor di,(fParity*256)+ACE_PE ;Disable parity checking

SetCom410:
    cmp al,8            ;Byte size out of range?
    ja  SetCom460       ;  Yes, error

SetCom420:
    sub al,5            ;Shift byte size to bits 0&1
    .errnz ACE_WLS-00000011b    ;Word length must be these bits
    jc  SetCom460       ;Byte size is illegal, return error
    add ah,ah           ;Map parity to ACE bits
    jz  SetCom430       ;0=>0, 1=>1, 2=>3, 3=>5, 4=>7
    dec ah

SetCom430:
    shl ah,1            ;Align with 8250 parity bits
    shl ah,1
    shl ah,1
    or  al,ah           ;Add to byte size

    .errnz NoParity-0
    .errnz OddParity-1
    .errnz EvenParity-2
    .errnz MarkParity-3
    .errnz SpaceParity-4
    .errnz ACE_PEN-00001000b
    .errnz ACE_PSB-00110000b
    .errnz ACE_EPS-00010000b
    .errnz  ACE_SP-00100000b

    or  al,ACE_2SB      ;Assume 2 stop bits
    mov ah,es:[bx.DCB_StopBits] ;Get # of stop bits 0=1,1/2= .GT. 1
    or  ah,ah           ;Out of range?
    js  SetCom470       ;  Yes, return error
    jz  SetCom440       ;One stop bit
    sub ah,2
    jz  SetCom450       ;Two stop bits
    jns SetCom470       ;Not 1.5, return error
    test    al,ACE_WLS      ;1.5 stop bits, 5 bit words?
    jnz SetCom470       ;  No, illegal
    .errnz OneStopBit-0
    .errnz One5StopBits-1
    .errnz TwoStopBits-2
    .errnz ACE_5BW

SetCom440:
    and al,NOT ACE_2SB      ;Show 1 (or 1.5) stop bit(s)
endif   ; NEC_98


; From the byte size, get a mask to be used for stripping
; off unused bits as the characters are received.

SetCom450:
    push    dx
    mov cl,es:[bx.DCB_ByteSize] ;Get data byte size
    mov dx,00FFh        ;Turn into mask by shifting bits
    shl dx,cl
    mov ah,dh           ;Return mask in ah
    pop dx
    clc             ;Show all is fine
    ret

SetCom460:
    mov ax,IE_ByteSize      ;Show byte size is wrong
    stc             ;Show error
    ret

SetCom470:
    mov ax,IE_Default       ;Show something is wrong
    stc             ;Show error
    ret

SetCom400 endp
page

;----------------------------------------------------------------------------
; SuspendOpenCommPorts:
;
; This routine is called from 286 Winoldaps to simply deinstall the comm port
; hooks.
;----------------------------------------------------------------------------

cProc   SuspendOpenCommPorts,<FAR,PUBLIC,PASCAL>

cBegin  nogen

    assumes cs,Code
    assumes ds,Data

%OUT not masking IRQ's

    ; Nothing to do under 3.1!

    ret

cEnd    nogen

;----------------------------------------------------------------------------;
; ReactivateOpenCommPorts:                           ;
;                                        ;
; This routine reinstalls the comm hooks in real mode and reads the 8250     ;
; data and status registers to clear pending interrupts.             ;
;----------------------------------------------------------------------------;

cProc   ReactivateOpenCommPorts,<FAR,PASCAL,PUBLIC>,<si,di>

cBegin
    call    Rotate_PIC      ;make comm ports highest priority

    mov cx, MAXCOM+1
    mov di,dataOffset COMptrs
rcp_loop:
    mov si, [di]
    mov dx, Port[si]
    or  dx, dx
    jz  @f
    call    InitAPort       ;read comm port regs to clr pending ints
@@:
    add di, 2
    loop    rcp_loop

cEnd

;----------------------------------------------------------------------------;
; InitAPort:                                     ;
;                                        ;
; reads the data,status & IIR registers of a port (has to be 8250!)      ;
;                                        ;
; If the port has an out queue pending, then this woutine will also start    ;
; the transmit process by faking a comm interrupt.               ;
;----------------------------------------------------------------------------;

public     InitAPort
InitAPort  proc near

ifdef   NEC_98
        cmp     IntVecNum[si],0         ;       [QN]    (ins 92.08.05)
        je      InitAPort1              ;       [QN]    (ins 92.08.05)
        mov     dx,DataPort[si]         ;       [QN]    (ins 92.08.05)
        in      al,dx                   ;       [QN]    (ins 92.08.05)
else    ; NEC_98
    add dl,ACE_RBR      ;dx=receive buffer register
    in  al,dx           ;read the data port
    jmp short $+2       ;i/o delay
    add dl,ACE_LSR - ACE_RBR    ;get to the status port
    in  al,dx           ;read it too.
    jmp short $+2       ;i/o delay
    add dl,ACE_IIDR - ACE_LSR   ;get to the line status register
    in  al,dx           ;read it once more
    jmp short $+2       ;i/o delay
    add dl,ACE_MSR - ACE_IIDR   ;get to the modem status register
    in  al,dx           ;read it once more
    jmp short $+2       ;i/o delay
    add dl,ACE_RBR - ACE_MSR    ;get to the receive buffer register
    in  al,dx           ;read it once more
    jmp short $+2       ;i/o delay
endif   ; NEC_98
    call    UnmaskIRQ

; now if the port has characters pending to be sent out then we must fake a
; comm interrupt.

    cmp [si].QOutCount,0    ;characters pending to be sent ?
    jz  @f          ;no.
    FCLI             ;disable interrupts
    call    FakeCOMIntFar       ;fake an interrupt
    FSTI             ;renable interrupts
@@:
ifdef   NEC_98
InitAPort1:                             ;(ins 92.08.xx)
endif   ; NEC_98
    ret

InitAPort endp

page

;----------------------------Public Routine-----------------------------;
;
; $DCBPtr - Return Pointer To DCB
;
; Returns a long pointer to the DCB for the requested device.
;
; Entry:
;   AH = Device ID
; Returns:
;   DX:AX = pointer to DCB.
; Error Returns:
;   DX:AX = 0
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   BX,CX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $DCBPTR
$DCBPTR proc   near

        push    si
        xor     dx,dx
        call    GetDEB                  ;Get pointer to DEB
        mov     ax,dx
        jc      DCBPtr10                ;Jump if invalid device
        mov     ax,si                   ;else return value here
        mov     dx,ds

DCBPtr10:
        pop     si
        ret

$DCBPTR endp
page

;----------------------------Private-Routine----------------------------;
;
; GetDEB - Get Pointer To Device's DEB
;
; Returns a pointer to appropriate DEB, based on device number.
;
; Entry:
;   AH = cid
; Returns:
;   'C' clear
;   'S' set if LPT device
;   DS:SI --> DEB is valid cid
;   AH     =  cid
; Error Returns:
;   'C' set if error (cid is invalid)
;   AX = 8000h
; Registers Preserved:
;   BX,CX,DX,DI,DS,ES
; Registers Destroyed:
;   AX,SI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public GetDEB               ;Public for debugging
GetDEB proc near

    push    cx
    mov cl, ah
    and cx, (NOT LPTx AND 0FFh)
    test    ah, ah          ;Q: LPT id?
    js  short GetDEB10      ;   Y:
.errnz LPTx - 80h
    cmp ah, MAXCOM      ;Q: Within range?
    ja  GetDEB30        ;   N: return invalid ID
    shl cx, 1
    mov si, cx
    mov si, [si+COMptrs]
    jmp short GetDEB20

GetDEB10:
    cmp ah, LPTx+MAXLPT     ;Q: Within range?
    ja  GetDEB30        ;   N: return invalid ID
ifdef   NEC_98
    cmp ah, ID_LPT1                     ;                       (ins 940115)
    je  @f                              ;                       (ins 940115)
;                                                               (ins 940125)
;  Don't guarantee Ex board on Highreso mode.                   (ins 940125)
;  So return ID error if the request is LPT2/3.                 (ins 940125)
;                                                               (ins 940125)
;     40H:[101H] bit3                                           (ins 940125)
;       =0 : Normal mode                                        (ins 940125)
;       =1 : Highreso mode                                      (ins 940125)
    push    ax                          ;                       (ins 940125)
    push    ds                          ;                       (ins 940125)
    mov ax,40H                          ;                       (ins 940125)
    mov ds,ax                           ;                       (ins 940125)
    test    by ds:[101H],00001000b      ; normal mode ?         (ins 940125)
    pop ds                              ;                       (ins 940125)
    pop ax                              ;                       (ins 940125)
    jz  NormalRez                       ;  Y: Next Check        (ins 940125)
    jmp short GetDEB30                  ;  N: return invalid ID (ins 940125)
NormalRez:                              ;                       (ins 940125)
    push    ax                          ; Check whether request (ins 940115)
    push    dx                          ; LPT2/3 without Ex board(ins 940115)
    mov dx, Toki_ControlStatus+400h     ;                       (ins 940115)
    in  al, dx                          ;                       (ins 940115)
    cmp al, 0ffh                        ; Is there Ex board ?   (ins 940115)
    pop dx                              ;                       (ins 940115)
    pop ax                              ;                       (ins 940115)
    je  GetDEB30                        ;   N: Error            (ins 940115)
@@:                                     ;   Y: Next             (ins 940115)
                                        ;                       (ins 931225)
    cmp ah, ID_LPT3                     ; Open LPT3 ?           (ins 931225)
    jne @f                              ;   N: NEXT             (ins 931225)
    push    dx                          ;                       (ins 931225)
    push    ax                          ;                       (ins 931225)
    mov dx, 54fh                        ;                       (ins 931225)
    in  al, dx                          ;                       (ins 931225)
    test    al, 00000100b               ; Ex board=LPT1/2 ?     (ins 931225)
    pop ax                              ;                       (ins 931225)
    pop dx                              ;                       (ins 931225)
    jz  GetDEB30                        ;   Y: error            (ins 931225)
@@:                                     ;
endif   ; NEC_98
    mov si, DataOFFSET LPT1
    jcxz    GetDEB20
GetDEB15:
    add si, SIZE LptDEB
    loop    GetDEB15
GetDEB20:
    pop cx
    or  ah, ah          ; clear Carry & set S, if LPT port
    ret

GetDEB30:
    pop cx
    mov ax,8000h        ;Set error code
    stc             ;Set 'C' to show error
    ret

GetDEB endp
page


CvtHex proc near
;   assume DS=SS
ifndef  NEC_98
    push    si
    mov cl, 4
    mov si, di
    xor dx, dx
    cld
ch_lp:
    lodsb
    sub al, '0'         ;Q: char < '0'
    jb  ch_exit         ;   Y: return
    cmp al, 9           ;Q: char <= '9'
    jbe ch_got_digit        ;   Y: move digit into result
    sub al, 'A' - '0'       ;Q: char < 'A'
    jb  ch_exit         ;   Y: return
    add al, 10
    cmp al, 15          ;Q: char <= 'F'
    jbe ch_got_digit        ;   Y: move hex char into result
    sub al, 10 + 'a' - 'A'  ;Q: char < 'a'
    jb  ch_exit         ;   Y: return
    add al, 10
    cmp al, 15          ;Q: char > 'f'
    ja  ch_exit         ;   Y: return
ch_got_digit:
    shl dx, cl
    or  dl, al
    jmp ch_lp
ch_exit:
    mov ax, dx
    pop si
endif   ; NEC_98
    ret
CvtHex endp

.286
; attempt to read base from SYSTEM.INI
GetComBase proc near
    push    ds              ; save our DS
    sub sp, 6
    mov di, sp
    mov byte ptr ss:[di], 0
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommBase
    push    ss              ; temp buffer
    push    di
    push    ss              ; default = temp buffer
    push    di
    push    5
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileString     ;   our segment in real mode
    or  ax, ax
    jz  short gcb_exit
    call    CvtHex              ; DS still equal to SS
gcb_exit:
    add sp, 6
    pop ds              ; restore our DS
    assumes ds,Data
    ret
GetComBase endp

GetPortIRQ proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommIrq
    push    bx
    mov bl, [si.DCB_Id]
    cmp bl, 4
    jb  @f
    mov bl, 4
@@:
    xor bh, bh
    mov bl, [bx+default_table]
    mov cx, bx
    pop bx
    push    cx              ; default
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    ret
GetPortIRQ endp


GetPortFlags proc near
    mov al, [si.DCB_Id]
.erre MAXCOM LT 9           ;only single digit port numbers supported
    add al, '1'
    mov [CommFIFOX], al
    mov [CommDSRx], al
    call    GetPortFIFO
    call    GetPortDSR
    ret
GetPortFlags endp

GetPortFIFO proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommFifo
    push    2
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    cmp ax, 1
    ja  short gpf_exit          ; just check at open
    jb  short gpf_no_fifo       ; force OFF, if = 0
    or  EFlags[si], fFIFOchkd       ; flag as checked, to force ON
    jmp short gpf_exit

gpf_no_fifo:
    or  EFlags[si], fNoFIFO OR fFIFOchkd    ; force OFF

gpf_exit:
    ret
GetPortFIFO endp

GetPortDSR proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommDSR
    push    0
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    or  ax, ax
    jz  short gpd_exit
    or  EFlags[si], fUseDSR

gpd_exit:
    ret
GetPortDSR endp


; FindCOMPort
;
; DS:SI -> DEB
;
    PUBLIC FindCOMPort
FindCOMPort proc near
;
; Examine BIOS data area to get base I/O addresses for COM and LPT ports
;
    push    bx
    push    cx
    push    es
ifndef  NEC_98
    mov ax, __0040H
    mov es, ax
    assumes es,nothing

    mov al, [si.DCB_Id]
    mov ah, al
.erre MAXCOM LT 9           ;only single digit port numbers supported
    add ah, '1'
    mov [CommBaseX], ah
    mov [CommIRQX], ah
    mov [CommFIFOX], ah
    mov [CommDSRx], ah

    cmp al, 4
    jae fcp_not_phys_com
    xor ah, ah
    shl ax, 1
    mov bx, ax
    mov ax, es:[bx+RS232B]
    or  ax, ax
    jnz fcp_got_com_base
fcp_not_phys_com:
    call    GetComBase
    or  ax, ax
    jnz fcp_got_com_base
    mov bl, [si.DCB_Id]
    cmp bl, 2
    jne fcp_invalid     ; jump, if base = 0 & com port <> com3
    mov ax, 3E8h        ; default COM3 to 3E8h
endif   ; NEC_98
fcp_got_com_base:
    push    ax
    call    GetPortIRQ
    mov dx, ax
    pop ax
ifndef  NEC_98
    or  dl, dl          ;Q: non-zero IRQ?
    jz  fcp_invalid     ;   N:
    cmp dl, 15          ;Q: IRQ in range?
    ja  fcp_invalid     ;   N:
endif   ; NEC_98
    xor dh, dh
    push    ax
    push    dx
    call    GetPortFIFO
    call    GetPortDSR
    pop dx
    pop ax
    clc
fcp_exit:
    pop es
    pop cx
    pop bx
    ret

ifndef  NEC_98
fcp_invalid:
    or  ax, -1
    mov dx, ax
    stc
    jmp fcp_exit
endif   ; NEC_98

FindCOMPort endp
.8086

page
;--------------------------Private Routine-----------------------------;
;
; Rotate the PIC interrupt priorities so the communication ports are
; highest priority.
;
; NOTE: Only rotates priorities on master PIC.
;
;-----------------------------------------------------------------------;

    assumes ds,Data
    assumes es,nothing

    public Rotate_PIC

Rotate_PIC proc near

ifdef   NEC_98
    push    ax                                  ;                       [QN]|
    mov al, [si.DCB_Id]                         ; Port is 2ch/3ch ?     [QN]|
    or  al, al                                  ;                       [QN]|
    jnz rotate30                                ;  Y: goto Return       [QN]|
    xor ah,ah                                   ;                       [QN]|
    cmp byte ptr IntVecIntcount[si],0           ;                       [QN]|
    je  rotate10                                ;                       [QN]|
    mov al,11000011b                            ; IRQ3 is lower         [QN]|
    jmp short rotate20                          ;                       [QN]|
rotate10:                                       ;                       [QN]|
    mov al,11000111b                            ; IRQ7 is lower         [QN]|
rotate20:                                       ;                       [QN]|
    out 00H,al                                  ;                       [QN]|
rotate30:                                       ;                       [QN]|
    pop ax                                      ;                       [QN]|
    ret                                         ;                       [QN]|
else    ; NEC_98
    push    ax
    push    cx
    push    di

    mov al, 8           ; 0 - 7 rotated
    mov cx, MAXCOM+1
    mov di, DataOFFSET IRQhooks
rp_loop:
    mov ah, [di.IRQn]
    cmp ah, 0           ;End of hooked IRQ list?
    je  rp_set
    cmp [di.VecN], 0FFh     ;Hooked?
    je  rp_next
    cmp ah, 8           ;If on slave PIC, treat as IRQ2
    jb  @f
    mov ah, 2
@@:
    cmp ah, al
    jae rp_next
    mov al, ah          ;AL = lowest hooked comm IRQ
rp_next:
    add di, SIZE IRQ_Hook_Struc
    loop    rp_loop

rp_set:
    dec al          ;Setting IRQ(n-1) as the lowest
    and al,  07h        ;  priority makes IRQn the highest
    or  al, 0C0h
    out INTA0, al

    pop di
    pop cx
    pop ax
    ret
endif   ; NEC_98

Rotate_PIC endp

ifdef   NEC_98
;-----------------------------Public-Routine---------------------------;[QN]
;                                                                       [QN]
; Get_PortAddr_and_INTVect - get port address and interrupt vector      [QN]
;                                                                       [QN]
; The interrupt vector number and the port address are returned         [QN]
; to the caller.                                                        [QN]
;                                                                       [QN]
; Entry:                                                                [QN]
;   DS:SI --> DEB                                                       [QN]
;   CX = Port base address                                              [QN]
;   DS = Data                                                           [QN]
; Returns:                                                              [QN]
;   AH = IRQ number                                                     [QN]
;   AL = 8259 Mask                                                      [QN]
;   DI:DX --> interrupt handler                                         [QN]
;   IMRPort     = IMR Port Addr                                         [QN]
;   EOIPort     = EOI Port Addr                                         [QN]
;   Mask8259    = INT mask of COM1,COM2,COM3(PIC)                       [QN]
;   IntVecNum   = COM1,COM2,COM3 Vect (0CH,etc...)                      [QN]
;   MaskFFPort                                                          [QN]
;   ReadSigPort                                                         [QN]
;   DataPort                                                            [QN]
;   CommandPort                                                         [QN]
;   StatusPort                                                          [QN]
;   TimerProcAdr= Timer Process Addr (TickEntry1,TickEntry2,TickEntry3) [QN]
;                                                                       [QN]
;                                                                       [QN]
; Error Returns:                                                        [QN]
;   None                                                                [QN]
; Registers Destroyed:                                                  [QN]
;   FLAGS                                                               [QN]
; History:                                                              [QN]
;----------------------------------------------------------------------;[QN]
assumes ds,Data                         ;                               [QN]
assumes es,nothing                      ;                               [QN]
                                        ;                               [QN]
public   Get_PortAddr_and_INTVect       ;                               [QN]
Get_PortAddr_and_INTVect        proc near;                              [QN]
    push    bx                          ;                               [QN]
    push    cx                          ;                               [QN]
;-------------------------------------------------------------          [QN]
;       Get Port Address and INT Level                                  [QN]
;-------------------------------------------------------------          [QN]
Get_Interrupt_Dat001:                   ;                               [QN]
    mov ah,[si.DCB_id]                  ;Get device ID from DCB         [QN]
    cmp ah,ID_COM1                      ;Com1 ?                         [QN]
    jne Get_Interrupt_Dat002            ;  No (Com2/3 select)           [QN]
;-------- Com1 --------------------------                               [QN]
    mov IMRPort[si],02h                 ;Store IMR Port Addr            [QN]
    mov EOIPort[si],00h                 ;Store EOI Port Addr            [QN]
    mov Mask8259[si],00010000b          ;INT mask of Com1(PIC)          [QN]
    mov IntVecNum[si],0Ch               ;Store Com1 Vect (0CH)          [QN]
                                        ;                               [QN]
    mov MaskFFPort[si],035h             ;                               [QN]
    mov ReadSigPort[si],033h            ;                               [QN]
    mov DataPort[si],030h               ;                               [QN]
    mov CommandPort[si],032h            ;                               [QN]
    mov StatusPort[si],032h             ;                               [QN]
    lea ax,TickEntry1                   ;(ins 92.09.25)                 [QN]
    mov TimerProcAdr[si],ax             ;(ins 92.09.25)                 [QN]
    jmp Get_Interrupt_Dat004            ;next                           [QN]
;-------- Com2 or Com3 --------------------------                       [QN]
Get_Interrupt_Dat002:                   ;                               [QN]
    mov MaskFFPort[si],0B2h             ;COM3 (CHANGE 93.03.20)         [QN]
    mov ReadSigPort[si],0B2h            ;COM3 (CHANGE 93.03.20)         [QN]
    mov DataPort[si],0B9h               ;COM3 (CHANGE 93.03.20)         [QN]
    mov CommandPort[si],0BBh            ;COM3 (CHANGE 93.03.20)         [QN]
    mov StatusPort[si],0BBh             ;COM3 (CHANGE 93.03.20)         [QN]
    push    ax                          ;                               [QN]
    lea ax,TickEntry3                   ;COM3 (CHANGE 93.03.20)         [QN]
    mov TimerProcAdr[si],ax             ;COM3 (CHANGE 93.03.20)         [QN]
    pop ax                              ;                               [QN]
                                        ;                               [QN]
    cmp ah,ID_COM3                      ;Com3 ?                         [QN]
    je  Get_Interrupt_Dat3              ;  YES                          [QN]
                                        ;                               [QN]
    mov MaskFFPort[si],0B0h             ;COM2 (CHANGE 93.03.20)         [QN]
    mov ReadSigPort[si],0B0h            ;COM2 (CHANGE 93.03.20)         [QN]
    mov DataPort[si],0B1h               ;COM2 (CHANGE 93.03.20)         [QN]
    mov CommandPort[si],0B3h            ;COM2 (CHANGE 93.03.20)         [QN]
    mov StatusPort[si],0B3h             ;COM2 (CHANGE 93.03.20)         [QN]
    push    ax                          ;                               [QN]
    lea ax,TickEntry2                   ;COM2 (CHANGE 93.03.20)         [QN]
    mov TimerProcAdr[si],ax             ;COM2 (CHANGE 93.03.20)         [QN]
    pop ax                              ;                               [QN]
                                        ;                               [QN]
Get_Interrupt_Dat3:                     ;                               [QN]
    mov dx,ReadSigPort[si]              ;CI/CS/CD Signal Port           [QN]
    in  al,dx                           ;INT Level data save            [QN]
    and al,03h                          ;Mask of BIT 0,1 for INT        [QN]
    push    bx                          ;DCB Pointer save               [QN]
    mov bl,al                           ;                               [QN]
    xor bh,bh                           ;                               [QN]
    shl bx,1                            ;Made of Word Pointer           [QN]
    call    GetPortIRQ                  ; Get IRQ from system.ini(Registry)
    mov bx,ax
;----- Not Com1(Board is available) -----
    mov dx,PORT_TBL[bx]                 ;
    mov IMRPort[si],dx                  ;Get IMR Port Addr
                                        ;
    mov dx,PORT_EOI[bx]                 ;
    mov EOIPort[si],dx                  ;EOI set resistor
                                        ;
    mov dl,MASK_TBL[bx]                 ;
    mov Mask8259[si],dl                 ;Get IMR Pattern
                                        ;
    shr bx,1                            ; byte pointer
    mov dl,VECT_TBL[bx]                 ;
    mov IntVecNum[si],dl                ;Get INT Num(0b/0d/0e/11/13/14/15)h
    pop bx                              ;

Get_Interrupt_Dat004:                   ;                               [QN]
    mov al,Mask8259[si]                 ; al = Pic mask data            [QN]
    mov ah,IntVecNum[si]                ; ah = Interrupt Req            [QN]
    mov di,cs                           ; di = Int Vecter Seg           [QN]
                                        ;                               [QN]
    pop cx                              ;                               [QN]
    pop bx                              ;                               [QN]
    ret                                 ;                               [QN]
Get_PortAddr_and_INTVect   endp         ;                               [QN]
                                        ;                               [QN]
;(ins end 92.08.24)                     ;                               [QN]
;;;---------------------------------------------------------------------[QN]

;(ins 93.03.24)
;-----------------------------Public-Routine----------------------------;
;
;  OUT5FCheck - out 5f check logic for IOrecovery time
;
; Entry:
;   out5f_flag  ==      0       :default
; Returns:
;   out5f_flag  ==      0       :
;   out5f_flag  ==      1       :out5f ok
; Error Returns:
;   None
; Registers Destroyed:
;   es,ax
; History:
;-----------------------------------------------------------------------;
assumes ds,Data                         ;
assumes es,nothing                      ;
                                        ;
public   OUT5FCheck                     ;
OUT5FCheck      proc near               ;
    push    es
    push    ax

    mov AX,40h
    mov ES,AX
    test    byte ptr ES:[BIOS_FLAG5],80h    ; NESA(OUT5F support)?
    jz  @F
    mov out5f_flag,1
    jmp short   OUT5FCheckEnd
@@:
    test    byte ptr ES:[BIOS_FLAG7],80h    ; Normal(OUT5F support)?
    jz  OUT5FCheckEnd
    mov out5f_flag,1
public  OUT5FCheckEnd
OUT5FCheckEnd:
    pop ax
    pop es

    ret
OUT5FCheck   endp                       ;
;(ins end 93.03.24)

;(ins 94.04.11)
;-----------------------------Public-Routine----------------------------;
;  AOBACheck - Check whether AOBA on board
;
;       IID_Port = 0y36H        using bit:6-5 PRS(1-0) register
;               (y =1)                  for FIFO
; Entry:
;
; Returns:
;   AOBA on board       EFlags[si] reset fNoFIFO
;   non AOBA on board   EFlags[si] set fNoFIFO
; Error Returns:
;   NONE
; Registers Destroyed:
;   NONE
; History:                                              QNES    T-MATUDA
;-----------------------------------------------------------------------;
assumes ds,Data
assumes es,nothing

public   AOBACheck
AOBACheck       proc near
    push    ax
    push    dx
    push    cx

    xor cx,cx
    mov dx,130H                         ;
    add dx,ACE_IIDR                     ; dx = 136H
    in  al,dx                           ;
    test    al,040H                     ;PRS(1-0) == 1x ?
    jnz AOBACheck1                      ;(rel 94.05.11)
    in  al,dx                           ;
AOBACheck1:
    inc cx
    in  al,dx                           ;
    test    al,060H                     ;PRS(1-0) == 00 ?
    jnz NoAOBA                          ;non AOBA on board
    in  al,dx                           ;
    and al,060H                         ;PRS(1-0) == 10 ?
    cmp al,040H                         ;
    jne NoAOBA                          ;non AOBA on board
    cmp cx,2                            ;
    jb  AOBACheck1                      ;check twice ?
    and EFlags[si], not(fNoFIFO)        ;(ins 94.05.11) 
    jmp short @F
NoAOBA:
    or  EFlags[si], fNoFIFO             ;
@@:
    pop cx
    pop dx
    pop ax

    ret
AOBACheck   endp

;-----------------------------Public-Routine----------------------------;
;  Set8251mode - Change to 8251 mode
;
; Entry:
;   
; Returns:
;   
; Error Returns:
;   NONE
; Registers Destroyed:
;   NONE
; History:                                              QNES    T-MATUDA
;-----------------------------------------------------------------------;
assumes ds,Data
assumes es,nothing

public   Set8251mode
Set8251mode     proc near
    push    dx                          ;
    push    ax                          ;
    mov dx,Port[si]                     ;
    cmp dx,0130h                        ;(ins 94.5.31)
    je  Set8251mode001                  ;(ins 94.5.31)
    pop ax                              ;(ins 94.5.31)
    pop dx                              ;(ins 94.5.31)
    ret                                 ;(ins 94.5.31)
Set8251mode001:                         ;(ins 94.5.31)
    add dx,ACE_FCR                      ; 
    mov al,0                            ;set 8251 mode <94.5.16>
    out dx,al                           ; 
    NEWIODELAY 3                        ;(ins 94.04.25)
    PUSH    CX
Set8251mode002:                         ; (94.05.19)
    mov cx,1000h                        ; (94.05.19)
Set8251mode003:                         ; (94.05.19)
    in  al,dx                           ; (94.05.19)
    NEWIODELAY 3                        ; (94.05.19)
    test    al,ACE_EFIFO                ; (94.05.19)
    jz  @f                              ; (94.05.19)
    loop    Set8251mode003              ; (94.05.19)
                                        ; (94.05.19)
    mov dx,132h                         ; (94.05.19)
    in  al,dx                           ; (94.05.19)
    NEWIODELAY 3                        ; (94.05.19)
    mov dx,130h                         ; (94.05.19)
    in  al,dx                           ; (94.05.19)
    NEWIODELAY 3                        ; (94.05.19)
    mov dx,138h                         ; (94.05.19)
    jmp Set8251mode002                  ; (94.05.19)
@@:                                     ; (94.05.19)
    POP CX
    pop ax                              ;
    pop dx                              ;
    ret
Set8251mode   endp

;-----------------------------Public-Routine----------------------------;
;  SetFIFOmode - Change to FIFO mode
;
; Entry:
;   
; Returns:
;   
; Error Returns:
;   NONE
; Registers Destroyed:
;   NONE
; History:                                              QNES    T-MATUDA
;-----------------------------------------------------------------------;
assumes ds,Data
assumes es,nothing

public   SetFIFOmode
SetFIFOmode     proc near
    push    dx                          ;
    push    ax                          ;
    mov dx,Port[si]                     ;
    add dx,ACE_FCR                      ;
    in  al, dx                          ;(ins 94.5.16)
    NEWIODELAY 3                        ;       <OUT 5F,AL>     (ins 94.04.25)  |
    test    al, 01h                     ;(ins 94.5.16)
    jz  running_8251_mode               ;(ins 94.5.16)
    pop ax                              ;(ins 94.5.16)
    pop dx                              ;(ins 94.5.16)
    ret                                 ;(ins 94.5.16)
running_8251_mode:                      ;(ins 94.5.16)
;Set_FIFO == RLInt_Enable + ACE_TRIG14 + ACE_EFIFO
    mov al,Set_FIFO                     ;set FIFO mode
    out dx,al                           ;
    NEWIODELAY 3                        ;       <OUT 5F,AL>     (ins 94.04.25)  |
    pop ax                              ;
    pop dx                              ;
    ret
SetFIFOmode   endp

public  Set8251modeFar
Set8251modeFar proc far
    call    Set8251mode
    ret
Set8251modeFar endp

public  SetFIFOmodeFar
SetFIFOmodeFar proc far
    call    SetFIFOmode
    ret
SetFIFOmodeFar endp

;(ins end 94.04.11)

TOMOE_PAT   DB      16 DUP('PATCH !!')  ;PATCH AREA (ins 92.11.11)
endif   ; NEC_98

ifdef DEBUG
    public  InitCom10, InitCom20, InitCom40, InitCom50, InitCom59
    public  InitCom60, InitCom70, InitCom80, InitCom90, InitCom100
    public  TermCom10, TermCom15, TermCom20, TermCom30
ifdef   NEC_98
    public  TermCom60, Terminate5, Terminate10, Terminate20
else    ; NEC_98
    public  TermCom60, Terminate5, Terminate10, Terminate20, Terminate30
endif   ; NEC_98
    public  Terminate45, Terminate49, Terminate50
    public  SetQue10
    public  SetCom5, SetCom10, SetCom20, SetCom210, SetCom220, SetCom230
    public  SetCom240, SetCom310, SetCom410, SetCom420, SetCom430
    public  SetCom440, SetCom450, SetCom460, SetCom470
    public  GetDEB10, GetDEB20, GetDEB30
    public  DCBPtr10
endif

sEnd    code

page

createSeg _INIT,init,word,public,CODE
sBegin init
assumes cs,init



;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
IBMmodel proc near
ifndef  NEC_98
      push  ax
      push  bx
      push  es

      mov   ah, 0c0h
      int   15h
      jc    IBMmodel_exit

      assumes es,nothing

      cmp   by es:[bx+2], 0f8h      ; PS/2 80
      je    IBMmodel_exit       ;   return carry clear

      cmp   by es:[bx+2], 0fch      ; AT or PS/2 50 or 60
      jne   OldBios         ; assume OldBios

      cmp   by es:[bx+3], 04h       ; PS/2 50
      je    IBMmodel_exit       ;   return carry clear
      cmp   by es:[bx+3], 05h       ; PS/2 60
      je    IBMmodel_exit       ;   return carry clear

OldBios:
      stc

IBMmodel_exit:
      pop   es
      pop   bx
      pop   ax
endif   ; NEC_98
      ret

IBMmodel endp

cProc LoadLib, <FAR,PUBLIC,NODATA>,<si,di>
cBegin

ifndef  NEC_98
    push    ds
    mov ax, __F000H
    mov ds, ax
    assumes ds, ROMBios
    mov al, [MachineID]
    pop ds
    assumes ds,Data
    mov [$MachineID], al

    call    IBMmodel        ;Q: PS/2?
    jc  @F          ;   N:
    mov [default_table+2], 3    ;   Y: change COM3 default IRQ to 3
@@:

    push    ds
    mov ax, __0040H
    mov ds, ax
    assumes ds,nothing
    cmp word ptr ds:[RS232B], 2F8h  ;Q: COM2 base in COM1 slot?
    pop ds
    assumes ds,Data
    jne @F              ;   N: leave IRQ default as 4
    mov [default_table], 3      ;   Y: change IRQ default to 3
@@:
endif   ; NEC_98

    mov [fVPICD], -1        ; assume no

    xor di, di
    mov es, di
    mov ax, GET386API
    mov bx, VPICD
    int MULTIPLEX
    mov wo [lpfnVPICD], di
    mov wo [lpfnVPICD+2], es
    mov ax, es
    or  ax, di
    jz  short no_VPICD      ; jump if no bimodel services available
;
; version check VPICD
;
    mov ax, VPICD_API_Get_Ver
    call    [lpfnVPICD]
%OUT version check VPICD

    mov [fVPICD], 1     ; flag services are available

IFDEF No_DOSX_Bimodal_Services
    jmp short skip_dosx_stuff

no_VPICD:
    mov ax, __WinFlags
    and al, WF_PMODE or WF_WIN286
    cmp al, WF_PMODE or WF_WIN286
    jne skip_dosx_stuff

.286
    mov ax, Int31_Get_Version SHL 8
    int 31h
    test    bl, 10b         ;Q: processor goes to real mode
                    ;   for int reflection?
    jz  skip_dosx_stuff     ;   N:
    mov [Using_DPMI], 0FFh  ;   Y: flag use of DPMI

    mov ax, ds
    cCall   GetSelectorBase,<ax>    ;DX:AX = segment of selector
    shr ax, 4
    shl dl, 4
    or  ah, dl          ;AX now points to interrupt *segment*
    push    ax          ;save on stack
    mov ax, _INTERRUPT      ;write data SEGMENT into _INTERRUPT
    cCall   AllocCStoDSAlias,<ax>   ; code segment -- requires a data alias
    mov es, ax
    pop ax
    mov es:[RM_IntDataSeg],ax
    push    ds
    push    es
    mov ax, ds
    mov es, ax
    mov ax, _INTERRUPT
    mov ds, ax
    mov ax, (Int31_Trans_Serv SHL 8) + Trans_Call_Back
    mov si, IntCodeOFFSET Entry_From_RM
    mov di, DataOFFSET RM_Call_Struc
    int 31h
    pop es
    pop ds
    mov ax, 0
    jnc @f
    jmp short LoadExit
@@:
    mov wo es:[RM_CallBack], dx
    mov wo es:[RM_CallBack+2], cx
    cCall   FreeSelector,<es>    ;don't need CS alias any longer
.8086
skip_dosx_stuff:
ELSE
no_VPICD:
ENDIF

;
; find base values for LPT ports
;
ifndef   NEC_98
    mov cx, __0040h
    mov es, cx
    mov cx, MAXLPT+1
    mov si, DataOFFSET LPT1
ll_initl_lp:
    mov bx, [si.BIOSPortLoc]
    or  bx, bx
    jz  ll_not_phys_lpt
    mov ax, es:[bx]
    or  ah, ah          ;Q: lpt redirected, or 0?
    jz  ll_not_phys_lpt     ;   Y:
    cmp bx, LPTB        ;Q: first LPT?
    je  ll_got_lpt_base     ;   Y:
    cmp ax, es:[bx-2]       ;Q: base same as previous (redirected)?
    jne ll_got_lpt_base     ;   N: must be real
ll_not_phys_lpt:
%OUT attempt to read base from SYSTEM.INI

ll_got_lpt_base:
    mov [si.Port], ax
    loop    ll_initl_lp
endif   ; NEC_98

;
; create system timer for signalling chars in receive buffer
;

ifndef WOW
    mov ax, 100         ; create 100msec timer
    push    ax
    mov ax, _INTERRUPT
    push    ax
    mov ax, IntCodeOFFSET TimerProc
    push    ax
    call    CreateSystemTimer   ; ax = 0, if failed
%OUT should I display an error message here?

endif
    assumes es,nothing
LoadExit:
cEnd

sEnd    init

End LoadLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\ibmlpt.asm ===
;
; Include code from comm
;

include ..\comm\ibmlpt.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\sound\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\sound\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\ibmint.asm ===
page,132
;---------------------------Module-Header-------------------------------
; Module Name: IBMINT.ASM
;
; Created: Fri 06-Feb-1987 10:45:12
; Author:  Walt Moore [waltm]
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved
;
; General Description:
;   This file contains the interrupt time routines for the
;   IBM Windows communications driver.
;
;   The interrupt code is preloaded and fixed.
;
; History:
;
; **********************************************************************
;    Tue Dec 19 1989 09:35:15	-by-  Amit Chatterjee  [amitc]
; ----------------------------------------------------------------------
;    Added a far entry point 'FakeCOMIntFar' so that the routine 'FakeCOMInt'
; could be called from the 'InitAPort' routine in IBMCOM.ASM
;
;   26.Nov.90	richp
;
;   Changed interrupt routines to use new VPICD services for bi-modal/multi-
;   modal interrupt handling.  They now work in straight real mode for real
;   mode Windows, but can also handle interrupts in real mode or protected
;   mode for standard mode Windows, and handle interrupts in RING 0 protected
;   mode for enhanced mode Windows, even when the Windows VM is not currently
;   executing.
;
;   sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;           FCLI/FSTI macros
;-----------------------------------------------------------------------;

subttl  Communications Hardware Interrupt Service Routines

.xlist
include cmacros.inc
include comdev.inc
include ibmcom.inc
include ins8250.inc
include BIMODINT.INC
include vint.inc
.list

externFP GetSystemMsecCount

externW  COMptrs
externW  activeCOMs

externD  lpPostMessage

ifdef   NEC_98
externFP Comm4				;Ins 940923 KBNES
endif   ; NEC_98

sBegin Data

PUBLIC IRQhooks
IRQhooks    label byte
DefineIRQhook MACRO num
IFDEF No_DOSX_Bimodal_Services
IRQhook&num IRQ_Hook_Struc <,,,,IntCodeOFFSET DEF_COM_INT_&num,,,, \
			    IntCodeOFFSET DEF_RM_COM_INT_&num>
ELSE
IRQhook&num IRQ_Hook_Struc <,,,,IntCodeOFFSET DEF_COM_INT_&num>
ENDIF
ENDM
??portnum = 1
REPT MAXCOM+1
	DefineIRQhook %??portnum
??portnum = ??portnum+1
ENDM

PURGE DefineIRQhook

EXTRN VCD_int_callback:fword

sEnd data

createSeg _INTERRUPT,IntCode,word,public,CODE
sBegin IntCode
assumes cs,IntCode

page

IFDEF No_DOSX_Bimodal_Services
public RM_IntDataSeg
RM_IntDataSeg	dw 0
  ; this variable is written into by a routine in inicom
  ; if the 286 DOS extender is present.  This variable
  ; contains the SEGMENT value of the data selector "_DATA"
  ; so that the real mode interrupt handler may use the
  ; data segment, and not it's selector !

PUBLIC	RM_CallBack
RM_CallBack	dd  0
ENDIF


Control proc far
	ret
Control endp


IFDEF No_DOSX_Bimodal_Services
DEF_RM_Handler proc far
	push	es
	push	di
	push	ax
	mov	es, cs:[RM_IntDataSeg]
	mov	di, es:[di.First_DEB]	    ; ES:DI -> ComDEB
	add	di, SIZE ComDEB 	    ; ES:DI -> BIS
	mov	es:[di.BIS_Mode], 4
	push	cs
	call	NEAR PTR COMHandler
	mov	es:[di.BIS_Mode], 0
	pop	ax
	pop	di			    ; ES:DI -> IRQ_Hook_Struc
ifndef  NEC_98
	jc	short DEF_RM_chain
endif   ; NEC_98
	pop	es
	pop	di
	add	sp, 4
	iret

DEF_RM_chain:
        call DOCLI
	push	bp
	mov	bp, sp			    ;stack frame:
					    ;	bp+8	-> OldInt CS
					    ;	bp+6	-> OldInt IP
					    ;	bp+4	-> di
					    ;	bp+2	-> es
					    ;	bp+0	-> bp
	les	di, es:[di.RM_OldIntVec]
	mov	[bp+6], di
	mov	[bp+8], es
	pop	bp
	pop	es
	pop	di
	ret				    ; far ret to OldInt handler
DEF_RM_Handler endp
ENDIF	;No_DOSX_Bimodal_Services


Define_DEF_COM_INT MACRO num
IFDEF No_DOSX_Bimodal_Services
PUBLIC DEF_RM_COM_INT_&num
DEF_RM_COM_INT_&num proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook&num
        jmp     DEF_RM_Handler
DEF_RM_COM_INT_&num endp
ENDIF
PUBLIC DEF_COM_INT_&num
DEF_COM_INT_&num proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook&num
        jmp     DEF_Handler
DEF_COM_INT_&num endp
ENDM

??portnum = 2
REPT MAXCOM
	Define_DEF_COM_INT %??portnum
??portnum = ??portnum+1
ENDM

PURGE Define_DEF_COM_INT

IFDEF No_DOSX_Bimodal_Services
PUBLIC DEF_RM_COM_INT_1
DEF_RM_COM_INT_1 proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook1
        jmp     DEF_RM_Handler
DEF_RM_COM_INT_1 endp
ENDIF

PUBLIC DEF_COM_INT_1
DEF_COM_INT_1 proc far
	sub	sp, 4
	push	di
	mov	di, DataOFFSET IRQhook1
IF2
.errnz $ - OFFSET DEF_Handler
ENDIF
DEF_COM_INT_1 endp

DEF_Handler proc far
	push	es
	push	di
	push	ax
	mov	ax, _DATA
	mov	es, ax
	mov	di, es:[di.First_DEB]	    ; ES:DI -> ComDEB
	add	di, SIZE ComDEB 	    ; ES:DI -> BIS
	push	cs
	call	NEAR PTR COMHandler
	pop	ax
	pop	di			    ; ES:DI -> IRQ_Hook_Struc
ifndef  NEC_98
	jc	short DEF_chain
endif   ; NEC_98
	pop	es
	pop	di
	add	sp, 4
	iret

DEF_chain:
        call DOCLI
	push	bp
	mov	bp, sp			    ;stack frame:
					    ;	bp+8	-> OldInt CS
					    ;	bp+6	-> OldInt IP
					    ;	bp+4	-> di
					    ;	bp+2	-> es
					    ;	bp+0	-> bp
	les	di, es:[di.OldIntVec]
	mov	[bp+6], di
	mov	[bp+8], es
	pop	bp
	pop	es
	pop	di
	ret				    ; far ret to OldInt handler
DEF_Handler endp

;------------------------------------------------------------------------------
;
;   ENTER:	ES:DI -> BIS
;
;   EXIT:	Carry set, if IRQ not handled by any com ports
;
COMHandler proc far
	push	ds
	push	si
	push	ax
	push	bx
	mov	si, es
	mov	ds, si
	mov	bh, -1
ch_chk_all:
	lea	si, [di-SIZE ComDEB]	;ds:si -> ComDEB
	mov	si, [si.IRQhook]
	mov	si, [si.First_DEB]
	mov	bl, -1
ch_next_com:
	inc	bl			; first time bl = 0
	xor	ax, ax
	xchg	ax, [di.BIS_Mode]
	lea	di, [si+SIZE ComDEB]
	mov	[di.BIS_Mode], ax
	call	CommInt
	and	al, 80h
	or	bl, al

	mov	si, [si.NextDEB]
	or	si, si
	jnz	ch_next_com

	test	bl, 7Fh 		;Q: more than 1 com port?
	jnz	short ch_shared 	;   Y: check if handled
	or	bl, bl			;Q: int handled by port?
	stc
	jns	ch_exit 		;   N:

ch_eoi:
	xor	ax, ax
.errnz BIH_API_EOI
	xor	bx, bx
	xchg	bx, es:[di.BIS_Mode]
	call	es:[bx][di.BIS_User_Mode_API]
	lea	si, [di-SIZE ComDEB]	; ds:si -> ComDEB
	mov	si, [si.IRQhook]
	mov	al, [si.OldMask]
	shr	al, 1			; shift bit 0 into Carry (0, if unmasked
	cmc				;   -1, if originally masked)

ch_exit:
	pop	bx
	pop	ax
	pop	si
	pop	ds
	ret

ch_shared:
	inc	bh			; count loop
	or	bl, bl			;Q: int handled by any port?
	js	ch_chk_all		;   Y: check all ports again
	or	bh, bh			;Q: first time thru loop?
	stc
	jz	ch_exit 		;   Y: int wasn't for a COM port, so
					;      chain to next IRQ handler
	jmp	ch_eoi

COMHandler endp


IFDEF No_DOSX_Bimodal_Services

PUBLIC Entry_From_RM
Entry_From_RM proc far

;
; Simulate the far ret
;
	cld
	lodsw
	mov	es:[di.RealMode_IP], ax
	lodsw
	mov	es:[di.RealMode_CS], ax
	add	es:[di.RealMode_SP], 4

	push	es
	push	di
.286
;
; Push far addr of Ret_To_IRET to cleanup stack and return to DPMI host
;
	push	cs
	push	IntCodeOFFSET Ret_To_IRET
;
; Push far addr of proc to call, so we can do a far ret to it
;
	push	es:[di.RealMode_CX]	; segment of callback
	push	es:[di.RealMode_DX]	; offset of callback
	mov	di, es:[di.RealMode_DI]
	ret				; far ret to cx:dx
					;   called proc will do a far ret
Ret_To_IRET:				; <- to here
	pop	di
	pop	es
	iret
.8086

Entry_From_RM endp

PUBLIC RM_APIHandler
RM_APIHandler proc far
	cmp	ax, BIH_API_Call_Back
	jne	APIHandler
	call	cs:[RM_CallBack]
	ret
RM_APIHandler endp

ENDIF

;------------------------------------------------------------------------------
;
;   ENTER:	ES:DI -> BIS
;
APIHandler proc far

	or	ax, ax
	jnz	short api_not_EOI
.errnz	BIH_API_EOI
	mov	ax, es:[di.BIS_IRQ_Number]
	cmp	al,8			;Q: slave IRQ?
	mov	al,EOI
	jb	short api_master	;   N:
ifdef   NEC_98
	out	08h,al			;   Y: EOI slave
else    ; NEC_98
	out	0A0h,al 		;   Y: EOI slave
endif   ; NEC_98
api_master:
ifdef   NEC_98
	out	00h,al			; EOI master
else    ; NEC_98
	out	INTA0,al		; EOI master
endif   ; NEC_98
	ret

api_not_EOI:
	cmp	ax, BIH_API_Call_Back
	jae	short api_callme
	push	dx
	push	cx
ifdef   NEC_98
	mov	dx, 02h
else    ; NEC_98
	mov	dx, INTA1
endif   ; NEC_98
	mov	cx,  es:[di.BIS_IRQ_Number]
	cmp	cl, 8			;Q: 2nd PIC?
	jb	@f			;   N:
ifdef   NEC_98
	mov	dx, 0Ah			;   Y: dx = mask port
else    ; NEC_98
	mov	dx, 0A1h		;   Y: dx = mask port
endif   ; NEC_98
	sub	cl, 8
@@:
	cmp	al, BIH_API_Get_Mask	;Q: get IRQ mask?
	jae	api_get_mask		;   Y:
	mov	ah, al
	mov	ch, 1
	shl	ch, cl			; ch = mask byte
	pushf
        call DOCLI
	in	al, dx			; get current PIC mask state
	cmp	ah, BIH_API_Mask	;Q: mask IRQ?
	jne	@f			;   N:
	or	al, ch			;   Y: set IRQ's bit
	jmp	short api_mask_exit
@@:
	not	ch			;   N: clear IRQ's bit to unmask
	and	al, ch
api_mask_exit:
	out	dx, al
	pop	ax
	test	ah, 2			;Q: ints were enabled?
	jz	@f			;   N:
        call DOSTI
@@:
	pop	cx
	pop	dx
	ret

api_get_mask:
	in	al, dx			; get current PIC mask state
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	inc	cl
	shr	al, cl			; move IRQ's bit into carry
					; Carry set, if IRQ masked
	pop	cx
	pop	dx
	ret

api_callme:
	push	cx
	push	dx
	ret				; far ret to call back, which will
					; do a far ret to our caller
APIHandler endp


;--------------------------Fake a Hardware Interrupt----------------------;
; FakeCOMInt
;
; This routine fakes a hardware interrupt to IRQ3 or IRQ4
; to clear out characters pending in the buffer
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;
; Registers Destroyed:
;   AX,DX,FLAGS
; History: glenn steffler 5/17/89
;-----------------------------------------------------------------------;

FakeCOMInt proc near

      ; call DOCLI                             ;Done by caller
;
; WARNING: jumping into the middle of CommInt, so the stack must be set
;	   properly.
;
	push	dx
	push	bx
	push	cx
	push	di
	push	es
	push	EvtWord[si]
	mov	dx,Port[si]		;Get device I/O address
	add	dl, ACE_IIDR
	push	dx
	jmp	FakeXmitEmpty		;Process the fake interrupt, DS:SI is
					;  already pointing to proper DEB
;
; FakeXmitEmpty falls in XmitEmpty which jumps back into CommInt.  When CommInt
; determines that no interrupt is pending, then it will near return back to
; FakeCOMIntFar which can far ret back to its caller.
;
FakeCOMInt endp

public	FakeCOMIntFar
FakeCOMIntFar proc far

	call	FakeCOMInt
	ret

FakeCOMIntFar endp

;--------------------------Interrupt Handler----------------------------
;
; CommInt - Interrupt handler for com ports
;
; Interrupt handlers for PC com ports.	This is the communications
; interrupt service routine for RS232 communications.  When an RS232
; event occurs the interrupt vectors here.  This routine determines
; who the caller was and services the appropriate interrupt.  The
; interrupts are prioritized in the following order:
;
;     1.  line status interrupt
;     2.  read data available interrupt
;     3.  transmit buffer empty interrupt
;     4.  modem service interrupt
;
; This routine continues to service until all interrupts have been
; satisfied.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   AL = 0, if not handled, -1, if handled
;
;-----------------------------------------------------------------------

assumes ds,Data
assumes es,nothing

;   Dispatch table for interrupt types

SrvTab label word
	dw	OFFSET ModemStatus	;[0] Modem Status Interrupt
	dw	OFFSET XmitEmpty	;[2] Tx Holding Reg. Interrupt
	dw	OFFSET DataAvail	;[4] Rx Data Available Interrupt
					;   or [C] if 16550 & 16550A
	dw	OFFSET LineStat 	;[6] Reciever Line Status Interrupt


	public	CommInt

CommInt proc near

	xor	al, al
	cmp	word ptr [VCD_int_callback+4], 0
	je	short @F			; jump if no callback (not 3.1 VCD)
	test	[si.VCDflags], fCOM_ignore_ints ;Q: we still own port?
	jnz	IntLoop40			;   N: ignore the int
.386
	push	esi
	mov	esi, [si.VCD_data]
	call	[VCD_int_callback]
	pop	esi
.8086
@@:

	push	dx
	mov	dx,Port[si]		;Get comm I/O port
	add	dl,ACE_IIDR		;--> Interrupt ID Register
	in	al, dx
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	test	al, 1			;Q: interrupt pending?
	jnz	short IntLoop30 	;   N:

	push	bx
	push	cx
	push	di
	push	es
	mov	cx, EvtWord[si]
	push	cx
	jmp	short IntLoop10

InterruptLoop_ChkTx:
	cmp	QOutCount[si],0 	;Output queue empty?
	je	short InterruptLoop	;   Y: don't chk tx
	pop	dx
	push	dx
	dec	dx			; to IER
.errnz ACE_IIDR - ACE_IER - 1
	in	al, dx
	and	al,NOT ACE_ETBEI	; disable it
	iodelay
	out	dx, al
	or	al, ACE_ETBEI		; enable it again
	iodelay
	out	dx, al
	iodelay
	out	dx, al
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98

InterruptLoop:
	pop	dx			;Get ID reg I/O address

	in	al,dx			;Get Interrupt Id
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	test	al,1			;Interrupt need servicing?
	jnz	IntLoop20		;No, all done

IntLoop10:
	and	ax, 07h
	mov	di,ax
	push	dx			;Save Id register
	jmp	SrvTab[di]		;Service the Interrupt

IntLoop20:
	mov	ax,EvtMask[si]		;Mask the event word to only the
	and	ax, EvtWord[si] 	;  user specified bits
	mov	EvtWord[si], ax
	pop	bx
	test	[si.NotifyFlagsHI], CN_Notify
	jz	short ci_exit
	not	bx
	and	ax, bx			; bits set in ax are new events
	jnz	short ci_new_events

ci_exit:
	pop	es
	assumes es,nothing

	pop	di
	pop	cx
	pop	bx
	xor	al, al

IntLoop30:
	pop	dx
	and	al, 1
	dec	al			; 0->-1, 1->0
IntLoop40:
	ret

ci_new_events:
	mov	ax, CN_EVENT
	call	notify_owner
	jmp	ci_exit

CommInt endp

page

;----------------------------Private-Routine----------------------------;
;
; LineStat - Line Status Interrupt Handler
;
; Break detection is handled and set in the event word if
; enabled.  Other errors (overrun, parity, framing) are
; saved for the data available interrupt.
;
; This routine used to fall into DataAvail for the bulk of its processing.
; This is no longer the case...  A very popular internal modem seems to
; operate differently than a real 8250 when parity errors occur.  Falling
; into the DataAvail handler on a parity error caused the same character
; to be received twice.  Having this routine save the LSR status, and
; return to InterruptLoop fixes the problem, and still works on real COMM
; ports.  The extra overhead isn't a big deal since this routine is only
; entered when there is an exception like a parity error.
;
; This routine is jumped to, and will perform a jump back into
; the dispatch loop.
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,FLAGS
; History:
;-----------------------------------------------------------------------;


; assumes ds,Data
assumes es,nothing

public LineStat 			;Public for debugging
LineStat proc near

	or	by EvtWord[si],EV_Err	;Show line status error

	add	dl,ACE_LSR-ACE_IIDR	;--> Line Status Register
	in	al,dx
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	test	al,ACE_PE+ACE_FE+ACE_OR ;Parity, Framing, Overrun error?
	jz	@f

	mov	LSRShadow[si],al	;yes, save status for DataAvail
@@:
	test	al,ACE_BI		;Break detect?
	jz	InterruptLoop_ChkTx	;Not break detect interrupt

	or	by EvtWord[si],EV_Break ;Show break

	jmp	short InterruptLoop_ChkTx

LineStat   endp

page

;----------------------------Private-Routine----------------------------;
;
; DataAvail - Data Available Interrupt Handler
;
; The available character is read and stored in the input queue.
; If the queue has reached the point that a handshake is needed,
; one is issued (if enabled).  EOF detection, Line Status errors,
; and lots of other stuff is checked.
;
; This routine is jumped to, and will perform a jump back into
; the dispatch loop.
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

; assumes ds,Data
assumes es,nothing

public DataAvail                       ;public for debugging
DataAvail   proc   near

	sub	dl,ACE_IIDR-ACE_RBR	;--> receiver buffer register
	in	al,dx			;Read received character
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98

	and	[si.NotifyFlagsHI], NOT CN_Idle ; flag as not idle

	mov	ah,LSRShadow[si]	;what did the last Line Status intrpt
	mov	bh,ah			;  have to say?
	or	ah,ah
	jz	@f

	and	ah,ErrorMask[si]	;there was an error, record it
	or	by ComErr[si],ah
IFNDEF KKBUGFIX  ; 1/05/93:TakuA:Fix #1666
	mov	LSRShadow[si],0
ENDIF
	.errnz	ACE_OR-CE_OVERRUN	;Must be the same bits
	.errnz	ACE_PE-CE_RXPARITY
	.errnz	ACE_FE-CE_FRAME
	.errnz	ACE_BI-CE_BREAK
@@:

; Regardless of the character received, flag the event in case
; the user wants to see it.

	or	by EvtWord[si],EV_RxChar ;Show a character received
	.errnz HIGH EV_RxChar

; Check the input queue, and see if there is room for another
; character.  If not, or if the end of file character has already
; been received, then go declare overflow.

DataAvail00:

IFDEF KKBUGFIX  ; 1/05/93:TakuA:Fix #1666
        mov     bh,LSRShadow[si]
        mov     LSRShadow[si],0
ENDIF
	mov	cx,QInCount[si] 	;Get queue count (used later too)
	cmp	cx,QInSize[si]		;Is queue full?
	jge	DataAvail20		;  Yes, comm overrun
	test	EFlags[si],fEOF 	;Has end of file been received?
	jnz	DataAvail20		;  Yes - treat as overflow

; Test to see if there was a parity error, and replace
; the character with the parity character if so

	test	bh,ACE_PE		;Parity error
	jz	DataAvail25		;  No
	test	[si.DCB_Flags2],fPErrChar   ;Parity error replacement character?
	jz	DataAvail25		;  No
	mov	al,[si.DCB_PEChar]	;  Yes, get parity replacement char

; Skip all other processing except event checking and the queing
; of the parity error replacement character

	jmp	short DataAvail80	;Skip all but event check, queing

DataAvail20:
	or	by ComErr[si],CE_RXOVER ;Show queue overrun
	jmp	short DataAvail50

; See if we need to strip null characters, and skip
; queueing if this is one.  Also remove any parity bits.

DataAvail25:
	and	al,RxMask[si]		;Remove any parity bits
	jnz	DataAvail30		;Not a Null character
	test	[si.DCB_Flags2],fNullStrip  ;Are we stripping received nulls?
	jnz	DataAvail50		;  Yes, put char in the bit bucket

; Check to see if we need to check for EOF characters, and if so
; see if this character is it.

DataAvail30:
	test	[si.DCB_Flags],fBinary	;Is this binary stuff?
	jnz	DataAvail60		;  Yes, skip EOF check
	cmp	al,[si.DCB_EOFChar]	;Is this the EOF character?
	jnz	DataAvail60		;  No, see about queing the charcter
	or	EFlags[si],fEOF 	;Set end of file flag
DataAvail50:
	jmp	DataAvail140		;Skip the queing process

; If output XOn/XOff is enabled, see if the character just received
; is either an XOn or XOff character.  If it is, then set or
; clear the XOffReceived flag as appropriate.

DataAvail60:
	test	[si.DCB_Flags2],fOutX	;Output handshaking?
	jz	DataAvail80		;  No
	cmp	al,[si.DCB_XoffChar]	;Is this an X-Off character?
	jnz	DataAvail70		;  No, see about XOn or Ack
	or	HSFlag[si],XOffReceived ;Show XOff received, ENQ or ETX [rkh]
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	DataAvail50		;  No
	cmp	cx,[si.DCB_XonLim]	;See if at XOn limit
	ja	DataAvail50		;  No
	and	HSFlag[si],NOT XOffReceived ;Show ENQ or ETX not received
	and	HSFlag[si], NOT XOnPending+XOffSent
	mov	al, [si.DCB_XonChar]
	call	OutHandshakingChar
	jmp	DataAvail50		;Done

DataAvail70:
	cmp	al,[si.DCB_XonChar]	;Is this an XOn character?
	jnz	DataAvail80		;  No, just a normal character
	and	HSFlag[si],NOT XOffReceived
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	DataAvail75		;  No - jump to FakeXmitEmpty to get
					;	transmitting going again
	and	HSFlag[si],NOT EnqSent

DataAvail75:
	jmp	FakeXmitEmpty		;Restart transmit

; Now see if this is a character for which we need to set an event as
; having occured. If it is, then set the appropriate event flag


DataAvail80:
	cmp	al,[si.DCB_EVTChar]	;Is it the event generating character?
	jne	DataAvail90		;  No
	or	by EvtWord[si],EV_RxFlag   ;Show received specific character

; Finally, a valid character that we want to keep, and we have
; room in the queue. Place the character in the queue.
; If the discard flag is set, then discard the character

DataAvail90:
	test	MiscFlags[si], Discard	;Discarding characters ?
	jnz	DataAvail50		;  Yes

	lea	bx, [si+SIZE ComDEB]	; DS:BX -> BIS
	mov	bx, [bx.BIS_Mode]	; mode will be either 0 or 4
	les	di,QInAddr[si][bx]	;Get queue base pointer from either
	assumes es,nothing		;   QInAddr or AltQInAddr

	mov	bx,QInPut[si]		;Get index into queue
	mov	es:[bx][di],al		;Store the character
	inc	bx			;Update queue index
	cmp	bx,QInSize[si]		;See if time for wrap-around
	jc	DataAvail100		;Not time to wrap
	xor	bx,bx			;Wrap-around is a new zero pointer

DataAvail100:
	mov	QInPut[si],bx		;Store updated pointer
	inc	cx			;And update queue population
	mov	QInCount[si],cx

; If flow control has been enabled, see if we are within the
; limit that requires us to halt the host's transmissions

	cmp	cx,XOffPoint[si]	;Time to see about XOff?
	jc	DataAvail120		;  Not yet
	test	HSFlag[si],HSSent	;Handshake already sent?
	jnz	DataAvail120		;  Yes, don't send it again

	mov	ah,HHSLines[si] 	;Should hardware lines be dropped?
	or	ah,ah			;  (i.e. do we have HW HS enabled?)
	jz	DataAvail110		;  No
	add	dl,ACE_MCR		;  Yes
	in	al,dx			;Clear the necessary bits
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	not	ah
	and	al,ah
	or	HSFlag[si],HHSDropped	;Show lines have been dropped
	out	dx,al			;  and drop the lines
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	sub	dl,ACE_MCR

DataAvail110:
	test	[si.DCB_Flags2],fInX	;Input Xon/XOff handshaking
	jz	DataAvail120		;  No
	or	HSFlag[si], XOffSent
	mov	al, [si.DCB_XoffChar]
	call	OutHandshakingChar

DataAvail120:
	cmp	cx, [si.RecvTrigger]	;Q: time to call owner's callback?
	jb	short DataAvail130	;   N:

	test	[si.NotifyFlagsHI], CN_RECEIVE
	jnz	short DataAvail140	; jump if notify already sent and
					;   data in buffer hasn't dropped
					;   below threshold
	mov	ax, IntCodeOFFSET DataAvail140
	push	ax
	mov	ax, CN_RECEIVE
%OUT probably should just set a flag and notify after EOI
	jmp	notify_owner

DataAvail130:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE

DataAvail140:
	pop	dx
	push	dx
	add	dl, ACE_LSR-ACE_IIDR
	in	al, dx
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	test	al, ACE_DR		;Q: more data available?
	jz	@F			;   N:
	sub	dl, ACE_LSR		;   Y: go read it
	in	al, dx			;Read available character
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	jmp	DataAvail00
@@:
	jmp	InterruptLoop_ChkTx

DataAvail endp


OutHandshakingChar proc near

	add	dl, ACE_LSR
	mov	ah, al
@@:
	in	al, dx
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	test	al, ACE_THRE
	jz	@B
	sub	dl, ACE_LSR
	mov	al, ah
	out	dx, al
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	ret

OutHandshakingChar endp


page

;----------------------------Private-Routine----------------------------;
;
; XmitEmpty - Transmitter Register Empty
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

; assumes ds,Data
assumes es,nothing

public FakeXmitEmpty
FakeXmitEmpty:
	pop	dx
	push	dx

; "Kick" the transmitter interrupt routine into operation.

	dec	dl
.errnz ACE_IIDR - ACE_IER-1
	in	al,dx			;Get current IER state
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	test	al,ACE_ETBEI		;Interrupt already enabled?
	jnz	@F			;  Yes, don't reenable it
	or	al,ACE_ETBEI		;  No, enable it
	out	dx,al
	iodelay 			;8250, 8250-B bug requires
	out	dx,al			;  writting register twice
@@:
	add	dl,ACE_LSR-ACE_IER	;--> Line Status Register
	iodelay
	in	al,dx			;Is xmit really empty?
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	sub	dl,ACE_LSR-ACE_THR	;--> Transmitter Holding Register
	test	al,ACE_THRE
	jnz	short XmitEmpty5	;   Y: send next char
	jmp	InterruptLoop		;   N: return to processing loop

public XmitEmpty
XmitEmpty proc near

	add	dl,ACE_LSR-ACE_IIDR	;--> Line Status Register
	in	al,dx			;Is xmit really empty?
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	sub	dl,ACE_LSR-ACE_THR	;--> Transmitter Holding Register
	test	al,ACE_THRE
	jz	Xmit_jumpto90		;Transmitter not empty, cannot send

; If the hardware handshake lines are down, then XOff/XOn cannot
; be sent.  If they are up and XOff/XOn has been received, still
; allow us to transmit an XOff/XOn character.  It will make
; a dead lock situation less possible (even though there are
; some which could happen that cannot be handled).

XmitEmpty5:
	mov	ah,HSFlag[si]		;Get handshaking flag
	test	ah,HHSDown+BreakSet	;Hardware lines down or break set?
	jnz	Xmit_jumpto100		;  Yes, cannot transmit

; Give priority to any handshake character waiting to be
; sent.  If there are none, then check to see if there is
; an "immediate" character to be sent.  If not, try the queue.

XmitEmpty10:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jnz	XmitEmpty40		;  Yes

XmitEmpty15:
	test	ah,HSPending		;XOff or XOn pending
	jz	XmitEmpty40		;  No

XmitEmpty20:
	and	ah,NOT XOnPending+XOffSent
	mov	al,[si.DCB_XonChar]	;Get XOn character

XmitEmpty30:
	mov	HSFlag[si],ah		;Save updated handshake flag
	jmp	XmitEmpty110		;Go output the character

Xmit_jumpto90:
	jmp	XmitEmpty90

; If any of the lines which were specified for a timeout are low, then
; don't send any characters.  Note that by putting the check here,
; XOff and Xon can still be sent even though the lines might be low.

; Also test to see if a software handshake was received.  If so,
; then transmission cannot continue.  By delaying the software check
; to here, XOn/XOff can still be issued even though the host told
; us to stop transmission.

XmitEmpty40:
	test	ah,CannotXmit		;Anything preventing transmission?
	jz	XmitEmpty45		;  No
Xmit_jumpto100:
	jmp	XmitEmpty100		;  Yes, disarm and exit

; If a character has been placed in the single character "transmit
; immediately" buffer, clear that flag and pick up that character
; without affecting the transmitt queue.

XmitEmpty45:
	test	EFlags[si],fTxImmed	;Character to xmit immediately?
	jz	XmitEmpty515		;  No, try the queue
	and	EFlags[si],NOT fTxImmed ;Clear xmit immediate flag
	mov	al,ImmedChar[si]	;Get char to xmit
	jmp	XmitEmpty110		;Transmit the character

XmitEmpty515:
	mov	cx,QOutCount[si]	;Output queue empty?
	jcxz	Xmit_jumpto90		;  Yes, go set an event

	test	[si.DCB_Flags],fEtxAck	;Etx Ack?
	jz	XmitEmpty55		;  No
	mov	cx,QOutMod[si]		;Get number bytes sent since last ETX
	cmp	cx,[si.DCB_XonLim]	;At Etx limit yet?
	jne	XmitEmpty51		;  No, inc counter
	mov	QOutMod[si],0		;  Yes, zero counter
	or	HSFlag[si],EtxSent	;Show ETX sent
	jmp	short XE_sendXOFF

XmitEmpty51:
	inc	cx			; Update counter
	mov	QOutMod[si],cx		; Save counter
	jmp	short XmitEmpty59	; Send queue character

XmitEmpty55:
	test	[si.DCB_Flags],fEnqAck	;Enq Ack?
	jz	XmitEmpty59		;  No, send queue character
	mov	cx,QOutMod[si]		;Get number bytes sent since last ENQ
	or	cx,cx			;At the front again?
	jnz	XmitEmpty56		;  No, inc counter
	mov	QOutMod[si],1		;  Yes, send ENQ
	or	HSFlag[si],EnqSent	;Show ENQ sent
XE_sendXOFF:
	mov	al,[si.DCB_XoffChar]
	jmp	short XmitEmpty110	;Go output the character

XmitEmpty56:
	inc	cx			;Update counter
	cmp	cx,[si.DCB_XonLim]	;At end of our out buffer len?
	jne	XmitEmpty58		;  No
	xor	cx,cx			;Show at front again.

XmitEmpty58:
	mov	QOutMod[si],cx		;Save counter

XmitEmpty59:
	lea	bx, [si+SIZE ComDEB]	; DS:BX -> BIS
	mov	bx, [bx.BIS_Mode]	; mode will be either 0 or 4
	les	di,QOutAddr[si][bx]	;Get queue base pointer from either
	assumes es,nothing		;   QOutAddr or AltQOutAddr

	mov	bx,QOutGet[si]		;Get pointer into queue
	mov	al,es:[bx][di]		;Get the character

	inc	bx			;Update queue pointer
	cmp	bx,QOutSize[si] 	;See if time for wrap-around
	jc	XmitEmpty60		;Not time for wrap
	xor	bx,bx			;Wrap by zeroing the index

XmitEmpty60:
	mov	QOutGet[si],bx		;Save queue index
	mov	cx,QOutCount[si]	;Output queue empty?
	dec	cx			;Dec # of bytes in queue
	mov	QOutCount[si],cx	;  and save new population

	out	dx,al			;Send char
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98

	cmp	cx, [si.SendTrigger]	;Q: time to call owner's callback?
	jae	short XmitEmpty70	;   N:

	test	[si.NotifyFlagsHI], CN_TRANSMIT
	jnz	short XmitEmpty80	; jump if notify already sent and
					;   data in buffer hasn't raised
					;   above threshold
	mov	ax, IntCodeOFFSET XmitEmpty80
	push	ax
	mov	ax, CN_TRANSMIT
	jmp	short notify_owner

XmitEmpty70:
	and	[si.NotifyFlagsHI], NOT CN_TRANSMIT

XmitEmpty80:
%OUT check fNoFIFO in EFlags[si] to determine if we can queue more output
	jmp	InterruptLoop


; No more characters to transmit.  Flag this as an event.

XmitEmpty90:
	or	by EvtWord[si],EV_TxEmpty

; Cannot continue transmitting (for any of a number of reasons).
; Disable the transmit interrupt.  When it's time resume, the
; transmit interrupt will be reenabled, which will generate an
; interrupt.

XmitEmpty100:
	inc	dx			;--> Interrupt Enable Register
	.errnz	ACE_IER-ACE_THR-1
	in	al,dx			;I don't know why it has to be read
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	and	al,NOT ACE_ETBEI	;  first, but it works this way
XmitEmpty110:
	out	dx,al
	jmp	InterruptLoop

XmitEmpty endp

page

;----------------------------Private-Routine----------------------------;
;
; ModemStatus - Modem Status Interrupt Handler
;
; Entry:
;   DS:SI --> DEB
;   DX     =  Port.IIDR
; Returns:
;   None
; Error Returns:
;   None
; Registers Destroyed:
;   AX,BX,CX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;


; assumes ds,Data
assumes es,nothing

public ModemStatus                     ;Public for debugging
ModemStatus proc near

; Get the modem status value and shadow it for MSRWait.

	add	dl,ACE_MSR-ACE_IIDR	;--> Modem Status Register
	in	al,dx
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	mov	MSRShadow[si],al	;Save MSR data for others
	mov	ch,al			;Save a local copy

; Create the event mask for the delta signals

	mov	ah,al			;Just a lot of shifting
	shr	ax,1
	shr	ax,1
	shr	ah,1
	mov	cl,3
	shr	ax,cl
	and	ax,EV_CTS+EV_DSR+EV_RLSD+EV_Ring
	or	EvtWord[si],ax

	mov	ah,ch				       ;[rkh]...
	shr	ah,1
	shr	ah,1
	and	ax,EV_CTSS+EV_DSRS
	or	EvtWord[si],ax

	mov	ah,ch
	mov	cl,3
	shr	ah,cl
	and	ax,EV_RLSD
	or	EvtWord[si],ax

	mov	ah,ch
	mov	cl,3
	shl	ah,cl
	and	ax,EV_RingTe
	or	EvtWord[si],ax

	.errnz	   EV_CTS-0000000000001000b
	.errnz	   EV_DSR-0000000000010000b
	.errnz	  EV_RLSD-0000000000100000b
	.errnz	  EV_Ring-0000000100000000b

	.errnz	    EV_CTSS-0000010000000000b	    ;[rkh]
	.errnz	    EV_DSRS-0000100000000000b
	.errnz	   EV_RLSDS-0001000000000000b
	.errnz	  EV_RingTe-0010000000000000b

	.errnz	 ACE_DCTS-00000001b
	.errnz	 ACE_DDSR-00000010b
	.errnz	ACE_DRLSD-00001000b
	.errnz	   ACE_RI-01000000b

	.errnz	 ACE_TERI-00000100b		    ;[rkh]
	.errnz	  ACE_CTS-00010000b
	.errnz	  ACE_DSR-00100000b
	.errnz	 ACE_RLSD-10000000b

ModemStatus10:
	mov	al,OutHHSLines[si]	;Get output hardware handshake lines
	or	al,al			;Any lines that must be set?
	jz	ModemStatus40		;No hardware handshake on output
	and	ch,al			;Mask bits of interest
	cmp	ch,al			;Lines set for Xmit?
	je	ModemStatus20		;  Yes
	or	HSFlag[si],HHSDown	;Show hardware lines have dropped
ModemStatus30:
	jmp	InterruptLoop

ModemStatus40:
	jmp	InterruptLoop_ChkTx

; Lines are set for xmit.  Kick an xmit interrupt if needed

ModemStatus20:
	and	HSFlag[si],NOT (HHSDown OR HHSAlwaysDown)
					;Show hardware lines back up
	mov	cx,QOutCount[si]	;Output queue empty?
	jcxz	ModemStatus30		;  Yes, return to InterruptLoop
	jmp	FakeXmitEmpty		;Restart transmit

ModemStatus endp

page

;------------------------------------------------------------------------------
;
;   ENTER:  AX = message #
;	    DS:SI -> DEB
notify_owner proc near

	or	[si.NotifyFlags], ax
	lea	di, [si+SIZE ComDEB]
	mov	ax, ds
	mov	es, ax
	mov	ax, BIH_API_Call_Back	; call immediate, or in protected mode
	mov	bx, 1			; force SYS VM, if enhanced mode
	mov	cx, _INTERRUPT
	mov	dx, IntCodeOFFSET callback_event
%OUT use equate
	push	ds
	push	si
	mov	si, 1			; low priority boost
	push	bp
	mov	bp, es:[di.BIS_Mode]
	call	es:[bp][di.BIS_User_Mode_API]
	pop	bp
	pop	si
	pop	ds
	ret

notify_owner endp

;------------------------------------------------------------------------------
;
;   ENTER:  ES:DI -> BIS
;
callback_event proc far
	lea	si, [di-SIZE ComDEB]
	mov	ax, es
	mov	ds, ax
	mov	ax, [si.NotifyHandle]
	push	ax			; push hWnd
	mov	ax, WM_COMMNOTIFY
	push	ax			; push wMsg
	xor	ax, ax
	mov	al, [si.DCB_Id]
	push	ax			; push wParam = ComID
	xor	al, al
	push	ax			; push high word of lParam
	xchg	al, [si.NotifyFlagsLO]
	or	[si.NotifyFlagsHI], al
	push	ax			; push low word of lParam = event flags
	call	[lpPostMessage]
	ret
callback_event endp


PUBLIC TimerProc
TimerProc proc far

	push	ds
	mov	ax, _DATA
	mov	ds, ax
	assumes ds,data

	mov	ax, [activeCOMs]
	or	ax, ax
	jz	short tp_nonactive
	push	si
	mov	si, DataOFFSET COMptrs
	mov	cx, MAXCOM+1
tp_lp:
	push	si
	mov	si, [si]		; si -> ComDEB
	shr	ax, 1
	jnc	tp_lpend

	cmp	[si.RecvTrigger], -1	;Q: owner wants notification?
	je	short tp_lpend		;   N: skip notify
	cmp	[si.QInCount], 0	;Q: anything in input queue?
	je	short tp_lpend		;   N: skip notify
	test	[si.NotifyFlagsHI], CN_RECEIVE ;Q: timeout notify already given?
	jnz	short tp_lpend		;   N: skip notify

	xor	[si.NotifyFlagsHI], CN_Idle ;Q: first timer call?
	js	short tp_lpend		;   Y: skip notify

	push	ax
	push	cx
	mov	ax, CN_RECEIVE		;   N: notify owner
	call	notify_owner
	pop	cx
	pop	ax

tp_lpend:
	pop	si
	inc	si			; inc to ptr to next ComDEB
	inc	si
	or	ax, ax
	loopnz	tp_lp
	pop	si

tp_nonactive:
	pop	ds
	assumes ds,nothing
	ret

TimerProc endp
page

ifdef   NEC_98
;===========================================================================
;	System Timer Interrupt Routine
;
;			if ( QOutCount[si] != 0x0000 ) 
;				{
;				KickTx ();
;				}
;===========================================================================
public TickEntry4			;Ins 940923 KBNES
TickEntry4	proc	far		;for COM4
	push	si			;
	push	ds			;
	push	ax			;
	mov	si,dataOFFSET Comm4	;
	mov	ax, _DATA		;
	mov	ds, ax
					;
public	TickWork			;
TickWork:				;
        cmp     QOutCount[si],wo 00h	;Does queue empty ?
	jz	TickNoWork		;  Yes : Goto Return
	push	dx			;
        call    KickTxINT               ;
	pop	dx			;

TickNoWork:				;
	pop	ax			;
	pop	ds			;
	pop	si			;
	ret				;
TickEntry4	endp

;----------------------------Private-Routine----------------------------;
;
; KickTxInt - Kick Transmitter
;
; "Kick" the transmitter interrupt routine into operation.
; If the Transmitter Holding Register isn't empty, then
; nothing needs to be done.  If it is empty, then the xmit
; interrupt needs to enabled in the IER.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;
assumes ds,Data
assumes es,nothing

public   KickTxInt			;Ins 940923 KBNES
KickTxInt   proc   near
        mov     dx,Port[si]             ;Get device I/O address
        add     dl,ACE_IER              ;--> Interrupt enable register
        in      al,dx                   ;Get current IER state
	iodelay				;
        test    al,ACE_ETBEI            ;Interrupt already enabled?
        jnz     @F	                ;  Yes, don't reenable it
        or      al,ACE_ETBEI            ;  No, enable it
        out     dx,al
        iodelay                         ;8250, 8250-B bug requires
        out     dx,al                   ;  writting register twice
	iodelay				;
@@:
        ret
KickTxInt   endp
endif   ; NEC_98

ifdef DEBUG
	public	Control, DEF_Handler, COMHandler, APIHandler
	public	InterruptLoop, IntLoop10, IntLoop20
	public	DataAvail25, DataAvail30, DataAvail50
	public	DataAvail60, DataAvail70, DataAvail80, DataAvail90
	public	DataAvail100, DataAvail110, DataAvail120
	public	DataAvail130, DataAvail140, OutHandshakingChar
	public	XmitEmpty10, XmitEmpty20, XmitEmpty30, XmitEmpty40
	public	XmitEmpty59, XmitEmpty60
	public	XmitEmpty90, XmitEmpty100, XmitEmpty110
	public	ModemStatus10, ModemStatus20, ModemStatus30
	public	notify_owner, callback_event
endif

DOSTI proc    near
      FSTI
      ret
DOSTI endp

DOCLI proc    near
      FCLI
      ret
DOCLI endp



sEnd   IntCode
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\ins8250.inc ===
;
; Include code from comm
;

include ..\comm\ins8250.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\ibmcom.asm ===
page,132
;---------------------------Module-Header-------------------------------;
; Module Name: IBMCOM.ASM
;
; !!!
;
; Created: Fri 06-Feb-1987 10:45:12
; Author:  Walt Moore [waltm]
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; General Description:
;
; History:
;
;   ***************************************************************
;	Tue Dec 19 1989 09:32:15   -by-  Amit Chatterjee [amitc]
;   ---------------------------------------------------------------
;   Modified the 'InitAPort' routine called from 'ReactivateOpenCommPort'.
;   If the out queue for a port has characters to send out then we must
;   restart the trasmission process by faking a comm interrupt on that
;   port.
;   ***************************************************************
;	Tue Nov 21 1989 09:46:50    -by- Amit Chatterjee [amitc]
;   ---------------------------------------------------------------
;   The base port addresses in the COMM1,COMM2,COMM3,COMM4 structures
;   are being zeroed out when the corresponding comm port is closed.
;   This is because the  'ReactivateOpenCommPort' function looks at it
;   and if the port address is not zero decides that comm ports are
;   open. 
;   ***************************************************************
;	Tue Nov 14 1989 18:42:00     ADDED TWO EXPORTED FUNCTIONS
;   ---------------------------------------------------------------
;   Added two exported functions 'SuspendOpenCommPorts' and 
;   'ReactivateOpenCommPorts' for 286 winoldap support. The first one simply 
;   releases the comm int vects and installs the originall one, the second one
;   hooks back the comm driver comm vectors and then reads the receive buffer,
;   the status and the IIR registers of all the available comm ports to 
;   remove pending interrupts. It also reprograms the PIC to enable interrupts
;   on all open comm channels.
;   ---------------------------------------------------------------
;   -by- Amit Chatterjee [amitc]    
;   ***************************************************************
;	Tue Aug 30 198? 12:52:00      MAJOR FIX TO HANDLE 8250B
;   ---------------------------------------------------------------
;   
;   8250B has the following peculiar charactersistic
;             . The very first time (after reset) the Tx Holding Empty
;               interrupt is enabled, an immediate interrupt is generated
;
;             . After the first time, switching the Tx Holding Empty
;               interrupt enable bit from disabled to enabled will NOT
;               generate an immediate interrupt (unlike in 8250)
;       Because of this the KICKTX routine fails to set the transmit cycle
;       on if the machine has a 8250B
;   
;       This has been taken care as follows:
;             . For the very first byte that is being transmitted, KICKTX
;               is used to generate the first Tx Holding Empty interrupt
;             . Subsequently, whenever we find that the transmit buffer
;		is empty, we use a SOFTWARE INT (either INT 0Bh, or INT 0Ch)
;               to force the first character out, once this is done the
;               Tx Holding Empty interrupt will be generated once the buffer
;               really is empty
;             . Now we no longer disable the Tx Holding Empty interrupt
;               in the Xmit ISR to ensure that even m/cs with 8250, use
;               the software int to kick the tx interrupt on after the
;               first time.
;             . The software interrupt is also forced whenever an X-ON 
;               character is received.   
;
;       The code that implements the above logic is marked out with a line
;       asterixes.   
;   ------------------------------------------------------------------
;   -by- Amit Chatterjee [amitc]    
;       ******************************************************************
;
;   062587   HSFlag and Evtmask in DoLPT.  These fields do not exist
;      for LPT type devices.  The code which manipulated them
;      was removed
;
;      KickTx from $SndCom - interrupts were not disabled when
;      calling KickTx.
;
;      $SetCom - added CLD at the start
;
;      $SetQue - movsw ==> stosw
;
;       111285  Changed the Timeout from 7 to 30 seconds.
;
;       110885  Forgot to set EV_RxChar event when a character
;               was received.
;
;       102985  INS8250, INS8250B bug with enabling interrupts.
;               Setting ACE_ETBEI in the Interrupt Enable Register
;               will cause an immediate interrupt regardless of
;               whether the transmitter register is empty or not.
;               The first interrupt MAY also be missed.
;
;               The first case is not a problem since we only enable
;               interrupts if the transmitter register is empty.  The
;               second problem was showing up on Microsoft System Cards
;               in PC-XTs.  The first interrupt was missed after a cold
;               boot.  National claims the fix is to write the register
;               twice, which SEEMS to work...
;
;               Added timeout code to $TRMCOM.  If the number of
;               characters in the output queue doesn't decrease
;               in "Timeout" seconds, then the port will be closed
;               anyway.  Also flushed the input queue and added a
;               discard-input flag for the data available interrupt
;               code to discard any input received while terminating
;               a port.  $TRMCOM will return an error code if it
;               discarded any output data.
;
;               Removed infinite timeout test in MSRWait routine.
;               Still bad, but it will timeout around 65 seconds
;               instead of never.
;
;       102785  LPT initialization code was jumping to InitCom90,
;               which was setting EFlags[si] to null.  Well, LPTs
;               don't have an EFlags field, so the null was getting
;               stuffed over the LSB of BIOSPortLoc of the next LPT
;               device.
;
;       101185  Save interrupt vector when opening a comm port
;               and restore it when closing.  Would you believe
;               there are actually programs that assume the
;               vector points to a non-specific 8259 ACK and
;               an IRET!
;
;       100985  Added MS-NET support to gain exclusive control
;               of an LPT port if DOS 3.x and not running in as
;               a server, receiver, or messenger.   Required to
;               keep another application, such as command.com
;               from closing the stream or mixing their output
;               with ours.
;       sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;               FCLI/FSTI macros
;-----------------------------------------------------------------------;

title   IBMCom - IBM PC, PC-XT, PC-AT, PS/2 Communications Interface

.xlist
include cmacros.inc
include comdev.inc
include ins8250.inc
include ibmcom.inc
include vint.inc
.list

externNP GetDEB
ifndef  NEC_98
externNP DoLPT
externNP StringToLPT
endif   ; NEC_98
externNP FindCOMPort
externNP StealPort


sBegin	 Data

externB  $MachineID

ifdef   NEC_98
;-------------------------------------------------------;Bug fixed 1994.09.10 KBNES
;	MSR's_DELAY local buffer			;Bug fixed 1994.09.10 KBNES
;-------------------------------------------------------;Bug fixed 1994.09.10 KBNES
 _BIOS_FLAG1_	DB	0	;[0:458H]		;Bug fixed 1994.09.10 KBNES
 _BIOS_FLAG2_	DB	0	;[0:480H]		;Bug fixed 1994.09.10 KBNES
 _BIOS_FLAG3_	DB	0	;[0:45BH]		;Bug fixed 1994.09.10 KBNES
 _CPU_		DW	0	;loop count		;Bug fixed 1994.09.10 KBNES
 _TIME_		DW	0	;target time		;Bug fixed 1994.09.10 KBNES
 _MUKASI_	DW	0	;previous time		;Bug fixed 1994.09.10 KBNES
endif   ; NEC_98

sEnd Data

sBegin Code
assumes cs,Code
assumes ds,Data

page

;----------------------------Public Routine-----------------------------;
;
; $RECCOM - Receive Characters From Device
;
; Read Byte From RS232 Input Queue If Data Is Ready
;
; LPT ports will return with an indication that no characters are
; available.
;
; Entry:
;   AH = Device ID
; Returns:
;   'Z' clear if data available
;   AL = byte
; Error Returns:
;   'Z' Set if error or no data
;   AX = error code
;   AX = 0 if no data
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $RECCOM
$RECCOM proc   near

	push	si			;Once again, save some registers
	push	di
	call	GetDEB			;Get DEB pointer in SI
	jc	RecCom10		;Invalid Port [rkh] ...
	jns	RecCom20		;COM port
	jmp	RecCom95		;LPT port, return no characters

RecCom10:
	jmp	RecCom100		; Invalid Port

; Before removing any charcters from the input queue, check to see
; if XON needs to be issued.  If it needs to be issued, set the
; flag that will force it and arm transmit interrupts.

RecCom20:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	RecCom32		;  No
	test	HSFlag[si],EnqReceived+HHSDropped ;Enq recvd or lines dropped?
ifdef   NEC_98
        jnz     @f
else    ; NEC_98
        jnz      RecCom21                ;  No Enq recvd & no lines dropped
endif   ; NEC_98
        jmp      RecCom60                ;  No Enq recvd & no lines dropped
RecCom21:
	jmp	short RecCom34

RecCom32:
	test	HSFlag[si],HSSent	;Handshake sent?
ifdef   NEC_98
        jnz     @f
else    ; NEC_98
        jnz     RecCom33                ;  No XOFF sent & no lines dropped
endif   ; NEC_98
        jmp     RecCom60                ;  No XOFF sent & no lines dropped
RecCom33:

RecCom34:
	mov	ax,QInCount[si] 	;Get current count of input chars
	cmp	ax,[si.DCB_XonLim]	;See if at XOn limit
	ja	RecCom60		;Not at XOn limit yet
ifdef   NEC_98
@@:
endif   ; NEC_98

; If any hardware lines are down, then raise them.  Then see
; about sending XON.

	mov	dx,Port[si]		;Get the port
	mov	ah,HHSLines[si] 	;Get hardware lines mask
        call DOCLI                             ;Handle this as a critical section
	mov	cl,HSFlag[si]		;Get handshaking flags
	or	ah,ah			;Any hardware lines to play with?
	jz	RecCom40		;  No
	add	dl,ACE_MCR		;--> Modem control register
	in	al,dx
	or	al,ah			;Turn on the hardware bits
	iodelay
	out	dx,al
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	and	cl,NOT HHSDropped	;Show hardware lines back up

RecCom40:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	RecCom47		;  No
	test	cl,EnqReceived		;Did we receive Enq?
	jz	RecCom55		;  No
	and	cl,NOT EnqReceived
	jmp	short RecCom50

RecCom47:
	test	cl,XOffSent		;Did we send XOFF?
	jz	RecCom55		;  No
	and	cl,NOT XOffSent 	;Remove XOFF sent flag

RecCom50:
	or	cl,XOnPending		;Show XON or ACK must be sent
	call	KickTx			;Kick xmit if needed

RecCom55:
	mov	HSFlag[si],cl		;Store handshake flag
        call DOSTI                             ;Can allow interrupts now

; Now we can get down to the business at hand, and remove a character
; from the receive queue.  If a communications error exists, we return
; that, and nothing else.

RecCom60:
	xor	ax,ax
	or	ax,ComErr[si]		;Any Errors?
	jnz	RecCom100		;  Yes, return the error code
	or	ax,QInCount[si] 	;Get current input char count
	jz	RecCom90		;No characters in the queue
	les	di,QInAddr[si]		;Get queue pointer
	assumes es,nothing

	mov	bx,QInGet[si]		;Also get the index to head
	mov	al,es:[bx][di]		;Finally, get byte from queue
	inc	bx			;Update queue index
	cmp	bx,QInSize[si]		;See if time for wrap-around
	jc	RecCom70		;Jump if no wrap
	xor	bx,bx			;wrap by zeroing the index

RecCom70:
	mov	QInGet[si],bx		;Save new head pointer
	dec	QInCount[si]		;Dec # of bytes in queue

	mov	cx, [si.QinCount]
	cmp	cx, [si.RecvTrigger]	;Q: have we read below trigger?
	jae	RecCom80		;   N:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE ; allow timeout notify again
RecCom80:
	or	sp,sp			;Reset PSW.Z
	pop	di
	pop	si
	ret

; No characters in the input queue.  Check to see if EOF
; was received, and return it if it was.  Otherwise show
; no characters.

RecCom90:
	test	[si.DCB_Flags],fBinary	;Are we doing binary stuff?
	jnz	RecCom95		;  Yes, show no characters
	mov	al,[si.DCB_EofChar]	;Assume EOF
	test	EFlags[si],fEOF 	;Has end of file char been received?
	jnz	RecCom80		;  Yes, show end of file

RecCom95:
	xor	ax,ax			;Show no more characters

; Return with 'Z' to show error or no characters

RecCom100:
	xor	cx,cx			;Set PSW.Z
	pop	di
	pop	si
	ret

$RECCOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $RECSTR - Receive Characters From Device
;
; Read Byte From RS232 Input Queue If Data Is Ready
;
; LPT ports will return with an indication that no characters are
; available.
;
; Entry:
;   AH = Device ID
;   ES:DI -> receive buffer
;   CX max bytes to read
; Returns:
;   'Z' clear if data available
;   AX = # of bytes read
; Error Returns:
;   'Z' Set if error or no data
;   AX = error code
;   AX = 0 if no data
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	 $RECSTR
$RECSTR proc   near

	push	si			;Once again, save some registers
	push	di
	call	GetDEB			;Get DEB pointer in SI
	jc	RecStr10		;Invalid Port [rkh] ...
	jns	RecStr20		;COM port
	jmp	RecStr95		;LPT port, return no characters

RecStr10:
	jmp	RecStr100		; Invalid Port
RecStr15:
	jmp	RecStr90

RecStr20:
	xor	ax,ax
	or	ax,ComErr[si]		;Any Errors?
	jnz	RecStr10		;  Yes, return the error code
	or	ax,QInCount[si] 	;Get current input char count
	jz	RecStr15		;No characters in the queue

	cmp	cx, ax			;Q: more chars available than can read?
	jbe	short RecStr30		;   N:
	mov	cx, ax			;   Y: adjust # of chars to read
RecStr30:
	push	cx
	mov	dx, QInSize[si]
	mov	ax, QInGet[si]
	sub	dx, ax			; dx = # of bytes before end of buf
	cmp	dx, cx			;Q: more avail than can read?
	jbe	short RecStr40		;   N:
	mov	dx, cx			;   Y: adjust avail count
RecStr40:
	xchg	cx, dx			; cx = # of bytes for 1st copy
	sub	dx, cx			; dx = # of bytes for 2nd copy

	push	ds
	push	si
	lds	bx, QInAddr[si]
	mov	si, bx
	add	si, ax			; ds:si -> first char in buffer
	cld
	rep	movsb			; do first copy
	mov	cx, dx
	jcxz	short RecStr50		; jump if no 2nd copy needed
	mov	si, bx			; ds:si -> start of buffer
	rep	movsb			; do 2nd copy
RecStr50:
	sub	si, bx			; si = new QInGet
	mov	bx, si
	pop	si
	pop	ds
	pop	cx
        call DOCLI
	mov	QInGet[si], bx		; update QInGet
	sub	QInCount[si], cx	; update count
	mov	ax, QInCount[si]
        call DOSTI

	cmp	ax, [si.RecvTrigger]	;Q: have we read below trigger?
	jae	@F			;   N:
	and	[si.NotifyFlagsHI], NOT CN_RECEIVE ; allow timeout notify again
@@:

; Check to see if XON needs to be issued.  If it needs to be issued, set the
; flag that will force it and arm transmit interrupts.

	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	@F			;  No
	test	HSFlag[si],EnqReceived+HHSDropped ;Enq recvd or lines dropped?
        jnz     RecStr58                ;  No Enq recvd & no lines dropped
        jmp     RecStr80                ;  No Enq recvd & no lines dropped
RecStr58:
	jmp	short RecStr60

@@:
	test	HSFlag[si],HSSent	;Handshake sent?
        jnz     RecStr59                ;  No XOFF sent & no lines dropped
        jmp     RecStr80                ;  No XOFF sent & no lines dropped
RecStr59:

RecStr60:
					;ax = current count of input chars
	cmp	ax,[si.DCB_XonLim]	;See if at XOn limit
	ja	RecStr80		;Not at XOn limit yet

;;	  int 1
; If any hardware lines are down, then raise them.  Then see
; about sending XON.

	mov	dx,Port[si]		;Get the port
	mov	ah,HHSLines[si] 	;Get hardware lines mask
	push	cx
        call DOCLI                             ;Handle this as a critical section
	mov	cl,HSFlag[si]		;Get handshaking flags
	or	ah,ah			;Any hardware lines to play with?
	jz	@F			;  No
	add	dl,ACE_MCR		;--> Modem control register
	in	al,dx
	or	al,ah			;Turn on the hardware bits
	iodelay
	out	dx,al
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	and	cl,NOT HHSDropped	;Show hardware lines back up

@@:
	test	[si.DCB_Flags],fEnqAck+fEtxAck ;Enq or Etx Ack?
	jz	@F			;  No
	test	cl,EnqReceived		;Did we receive Enq?
	jz	RecStr70		;  No
	and	cl,NOT EnqReceived
	jmp	short RecStr65

@@:
	test	cl,XOffSent		;Did we send XOFF?
	jz	RecStr70		;  No
	and	cl,NOT XOffSent 	;Remove XOFF sent flag

RecStr65:
	or	cl,XOnPending		;Show XON or ACK must be sent
	call	KickTx			;Kick xmit if needed

RecStr70:
	mov	HSFlag[si],cl		;Store handshake flag
        call DOSTI                             ;Can allow interrupts now
	pop	cx

RecStr80:
	mov	ax, cx
	or	sp,sp			;Reset PSW.Z
	pop	di
	pop	si
	ret

; No characters in the input queue.  Check to see if EOF
; was received, and return it if it was.  Otherwise show
; no characters.

RecStr90:
	test	[si.DCB_Flags],fBinary	;Are we doing binary stuff?
	jnz	RecStr95		;  Yes, show no characters
	mov	al,[si.DCB_EofChar]	;Assume EOF
	test	EFlags[si],fEOF 	;Has end of file char been received?
	jnz	RecStr80		;  Yes, show end of file

RecStr95:
	xor	ax,ax			;Show no more characters

; Return with 'Z' to show error or no characters

RecStr100:
	xor	cx,cx			;Set PSW.Z
	pop	di
	pop	si
	ret

$RECSTR endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDIMM - Send A Character Immediately
;
; This routine either sends a character to the port immediately,
; or places the character in a special location which is used by
; the next transmit interrupt to transmit the character prior to
; those in the normal transmit queue.
;
; For LPT ports, the character is always sent immediately.
;
; Entry:
;   AH = Device ID
;   AL = Character
; Returns:
;   AX = 0
; Error Returns:
;   AX = 8000H if Bad ID
;   AX = 4000H if couldn't send because another character
;        transmitted "immediately" is waiting to be sent
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;


   assumes ds,Data
   assumes es,nothing

   public   $SNDIMM
$SNDIMM proc   near

        push    si
        call    GetDEB                  ;Get pointer to the DEB
	jc	SendImm20		;Bad ID, return an error
ifndef  NEC_98
	jns	SendImm10		;Its a COM port


;	For LPT ports, call DoLPT to do the dirty work.  If DoLPT
;       returns an error code, map it to 4000h.

	xor	ch,ch			;Show xmit character
	call	DoLPT			;Do the work here
        or      ax,ax                   ;Error occur?
	jz	SendImm20		;  No, show all is OK
	mov	ax,4000h		;  Yes, return 4000h
	jmp	short SendImm20
endif   ; NEC_98

SendImm10:
	mov	dl, al
        mov     ax,4000h                ;In case we cannot send
        test    EFlags[si],fTxImmed     ;Another char waiting "immediately"?
	jnz	SendImm20		;  Yes, return error
	mov	ah,dl			;Set char for TXI
        call DOCLI                             ;TXI is critical section code
        call    TXI                     ;Set character to tx immediately
        call DOSTI
        xor     ax,ax                   ;Show all is OK

SendImm20:
        pop     si
        ret

$SNDIMM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDCOM - Send Byte To Port
;
; The given byte is sent to the passed port if possible.
; If the output queue is full, an error will be returned.
;
; Entry:
;   AH = Device ID
;   AL = Character
; Returns:
;   AX = 0
; Error Returns:
;   AX = error code
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $SNDCOM
$SNDCOM  proc  near

	push	si
	push	di
	call	GetDEB			;--> DEB
	jc	SendCom40		;Invalid ID
ifndef  NEC_98
	jns	SendCom20		;Its a COM port

; Handle the transmission of a LPT character.  The ROM BIOS int 17
; call will be made to do the transmission.  The port address will
; be restored during the call, then zeroed out upon return.

SendCom10:
	xor	ch,ch			;Show xmit character
	call	DoLPT			;Do the work here
	jmp	short SendCom40 	;Return the status to caller
endif   ; NEC_98

; Send a character to a COM port.  Return an error if control
; line timeout occurs or there is no room in the output queue.

SendCom20:
	push	ax			;Save character

	call	MSRWait 		;See if lines are correct for output
	pop	ax			;Restore char
	jnz	SendCom60		;Timeout occured, return error
	mov	cx,QOutSize[si] 	;See if queue is full
	cmp	cx,QOutCount[si]
	jle	SendCom50		;There is no room in the queue
	les	di,QOutAddr[si] 	;--> output queue
	assumes es,nothing

	mov	bx,QOutPut[si]		;Get index into queue
	mov	es:[bx][di],al		;Store the byte
	inc	bx			;Update index
	cmp	bx,cx			;Wrap time?
	jc	SendCom30		;  No
	xor	bx,bx			;Wrap-around is a new zero pointer

SendCom30:

        call DOCLI
	mov	QOutPut[si],bx		;Store updated pointer
	mov	ax,QOutCount[si]	; get the count
	inc	ax			; have the updated value in AX for test later
	mov	QOutCount[si],ax	;Update queue population
	call	KickTx			;Make sure xmit interrupt is armed
        call DOSTI

	xor	ax,ax			;Show no error (that we know of)

;****************************************************************************

SendCom40:
	pop	di
	pop	si
	ret

SendCom50:
	or	by ComErr+1[si],HIGH CE_TXFULL
	.errnz LOW CE_TXFULL

SendCom60:
	mov	ax,ComErr[si]		;Return error code to caller
	jmp	short SendCom40

$SNDCOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SNDCOMSTR - Send buffer To Port
;
; The given buffer is sent to the passed port if possible.
; Once the output queue is detected as being full, a CE_TXFULL error
; will be indicated and AX will be returned as the # of chars actually
; queued.
;
; Entry:
;   DS:SI --> DEB
;   ES:DI --> buffer
; Returns:
;   AX = # of bytes queued
; Registers Destroyed:
;   AX,BX,CX,DX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	$SNDCOMSTR
$SNDCOMSTR proc near

	push	cx			; save count
	call	GetDEB
	jc	cws_error		; jump if id invalid
	jns	cws_comm		; jump if COM port

ifndef  NEC_98
	call	StringToLPT
	pop	cx			; discard saved count, ax = # transfered
	jmp	short cws_exit
endif   ; NEC_98

cws_error:
	pop	ax
	sub	ax, cx			; ax = # transfered
cws_exit:
	ret

cws_comm:
	call	MSRWait 		;See if lines are correct for output
	pop	cx
	push	cx
	jnz	cws_error		;Timeout occured, return error

	mov	dx, QOutSize[si]	;See if queue is full
        sub     dx, QOutCount[si]       ; dx = # of chars free in queue
        jg      scs_loop
        jmp     scs_full                ;There is no room in the queue

scs_loop:
	push	cx			; save count left to send
	cmp	cx, dx			;Q: room for buffer in queue?
	jbe	@f			;   Y:
	mov	cx, dx			;   N: adjust size to send
@@:
	push	cx			; save # of chars which will be copied
	push	si
	push	ds
	push	di
	push	es
	les	bx,QOutAddr[si] 	;--> output queue
	assumes es,nothing

	mov	dx, QOutSize[si]
	mov	di, QOutPut[si] 	;Get index into queue
	sub	dx, di			; dx = # of free chars before end of queue
	cmp	dx, cx
	jbe	@f
	mov	dx, cx
@@:
	xchg	cx, dx			; cx = # of chars for 1st copy
	sub	dx, cx			; dx = # of chars for 2nd copy
	pop	ds
	pop	si			; ds:si -> src buffer
	assumes ds,nothing
	add	di, bx			; es:di -> current pos in queue
	cld
	rep	movsb			; copy first section
	mov	cx, dx
	jcxz	@F
	mov	di, bx			; circle back to start of queue
	rep	movsb			; copy 2nd section
@@:
	sub	di, bx			; di last index into queue
	mov	dx, di
	mov	di, si			; last location in src buffer
	mov	si, ds
	mov	es, si			; es:di -> last loc in src buf
	pop	ds
	pop	si			; ds:si -> ComDEB
	assumes ds,data
	pop	bx			; # of chars copied
        call DOCLI
	mov	QOutPut[si], dx 	;new index into queue
	add	QOutCount[si], bx
	call	KickTx
        call DOSTI
	pop	cx
	sub	cx, bx			; # of chars left to send
	jnz	scs_full_2		;  jump if none
scs_exit:
	pop	ax
	sub	ax, cx			; ax = # transfered
	ret

scs_full:
        call DOCLI
	call	KickTx
        call DOSTI
scs_full_2:
	or	by ComErr+1[si],HIGH CE_TXFULL
	.errnz LOW CE_TXFULL
	jmp	scs_exit

$SNDCOMSTR endp
page

;----------------------------Public Routine-----------------------------;
;
; $FLUSH - Flush The Input and Output Queues
;
; This is a hard initialization of the transmit and receive queue's,
; which immediately empties the given queue.
;
; LPT ports will just return the device error word
;
; Entry:
;   AH = Device ID
;   BH = Queue # to clear (0=Tx, 1=Rx)
; Returns:
;   AX = Device Error Word. (Not reset)
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $FLUSH
$FLUSH   proc   near

        push    si
        push    di
        call    GetDEB                  ;si --> DEB
        jc      Flush40                 ;Invalid ID
        js      Flush30                 ;LPT port, return any error

        mov     cx,QOutCount-QInCount   ;# of bytes to zero
        lea     di,QInCount[si]         ;--> receive queue data
        or      bh,bh                   ;Transmit queue?
        jnz     Flush10                 ;  No, input queue
        add     di,cx                   ;  Yes, --> xmit queue data

Flush10:
        cld
        push    ds
        pop     es
   assumes es,nothing

        xor     al,al
        call DOCLI                             ;Time to worry about critical sections
        rep     stosb
        call DOSTI
	.errnz	 QInGet-QInCount-2
	.errnz	 QInPut-QInGet-2
	.errnz	 QOutCount-QInPut-2
	.errnz	 QOutGet-QOutCount-2
	.errnz	 QOutPut-QOutGet-2

        or      bh,bh                   ;Rx queue?
        jz      Flush30                 ;  No, xmit queue


;       If the queue to be cleared is the receive queue, any
;       hardware handshake must be cleared to prevent a possible
;       deadlock situation.  Since we just zeroed the queue count,
;       a quick call to $RecCom should do wonders to clear any
;       receive handshake (i.e. send XON if needed).

Flush20:
	call   $RECCOM	     ;Take care of handshakes here

Flush30:
        mov     ax,ComErr[si]           ;And return the error word.

Flush40:
        pop     di
        pop     si
        ret

$FLUSH	 endp
page

;----------------------------Private-Routine----------------------------;
;
; TXI - Transmit A Character Immediately
;
; Set up a character to be transmitted "immediately".
; by placing the character in a location that guarantees
; it to be the next character transmitted.
;
; The check to see if the immediate character can be placed has
; already been made prior to entry.
;
; Interrupts must be disabled before entering this code
;
; Entry:
;   AH = Character
;   DS:SI --> DEB
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   L,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   TXI         ;Public for debugging
TXI   proc   near

;       call DOCLI                             ;Must be done by caller!
	or	EFlags[si],fTxImmed	;Show char to xmit
	mov	ImmedChar[si],ah	;Set character to transmit next
;	jmp	short KickTx		;Kick Xmit just in case
	errn$	KickTx

TXI   endp
page

;----------------------------Private-Routine----------------------------;
;
; KickTx - Kick Transmitter
;
; "Kick" the transmitter interrupt routine into operation.
; If the Transmitter Holding Register isn't empty, then
; nothing needs to be done.  If it is empty, then the xmit
; interrupt needs to enabled in the IER.
;
; Entry:
;   DS:SI --> DEB
;   INTERRUPTS DISABLED!
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public	 KickTx 			;Public for debugging
KickTx   proc   near

;       call DOCLI                             ;Done by caller
	test	[si.VCDflags], 1	;Q: we still own port?
	jnz	can_we_steal		;   N:

enable_int:
	mov	dx,Port[si]		;Get device I/O address
	add	dl,ACE_IER		;--> Interrupt enable register
	in	al,dx			;Get current IER state
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	test	al,ACE_ETBEI		;Interrupt already enabled?
	jnz	KickTx10		;  Yes, don't reenable it
	or	al,ACE_ETBEI		;  No, enable it
	out	dx,al
	iodelay 			;8250, 8250-B bug requires
	out	dx,al			;  writting register twice
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif

KickTx10:
;       call DOSTI                             ;Done by caller
	ret

can_we_steal:
	call	StealPort		; call VCD to see if we can steal
					;     the port back
	jnc	short enable_int	; jump, if we got it
;
; flush out queue
;
	xor	ax, ax
	mov	[si.QOutCount], ax
	mov	[si.QOutMod], ax
	mov	ax, [si.QOutGet]
	mov	[si.QOutPut], ax
	jmp	short KickTx10		;   N:

KickTx   endp
page

;----------------------------Private-Routine----------------------------;
;
; MSRWait - Modem Status Register Wait
;
; This routine checks the modem status register for CTS, DSR,
; and/or RLSD signals.   If a timeout occurs while checking,
; the appropriate error code will be returned.
;
; This routine will not check for any signal with a corresponding
; time out value of 0 (ignore line).
;
; Entry:
;   SI --> DEB
; Returns:
;   AL = error code
;   ComErr[si] updated
;   'Z' set if no timeout
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   MSRWait	  ;Public for debugging

MSRWait proc   near

        push    di

MSRRestart:
        xor     di,di                   ;Init Timer

MSRWait10:
	mov	cx,11			;Init Delay counter (used on non-ATs)

MSRWait20:
        xor     dh,dh                   ;Init error accumulator
        mov     al,MSRShadow[si]        ;Get Modem Status
        and     al,MSRMask[si]          ;Only leave bits of interest
        xor     al,MSRMask[si]          ;0 = line high
	jz	MSRWait90		;All lines of interest are high
	mov	ah,al			;ah has 1 bits for down lines

        shl     ah,1                    ;Line Signal Detect low?
	jnc	MSRWait30		;  No, it's high
	.errnz	ACE_RLSD-10000000b
	cmp	di,[si.DCB_RlsTimeout]	;RLSD timeout yet?
	jb	MSRWait30		;  No
        or      dh,CE_RLSDTO            ;Show modem status timeout

MSRWait30:
	shl	ah,1			;Data Set Ready low?
	shl	ah,1
	.errnz	ACE_DSR-00100000b
	jnc	MSRWait40		;  No, it's high
	cmp	di,[si.DCB_DsrTimeout]	;DSR timeout yet?
	jb	MSRWait40		;  No
        or      dh,CE_DSRTO             ;Show data set ready timeout

MSRWait40:
	shl	ah,1			;CTS low?
	jnc	MSRWait50		;  No, it's high
	.errnz	ACE_CTS-00010000b
	cmp	di,[si.DCB_CtsTimeout]	;CTS timeout yet?
	jb	MSRWait50		;  No
        or      dh,CE_CTSTO             ;Show clear to send timeout

MSRWait50:
        or      dh,dh                   ;Any timeout occur?
	jnz	MSRWait80		;  Yes

ifndef  NEC_98
        cmp     [$MachineID],0FCh       ;Is this a PC-AT? [rkh debug for PS/2]
	je	MSRWait60		;  Yes, use ROM function
	loop	MSRWait20		;  No, continue until timeout
        jmp     short MSRWait70         ;Should have taken about a millisecond
endif   ; NEC_98

MSRWait60:
ifdef   NEC_98
	mov	cx,1					;(ins 94.08.02)       |
	call	MSR_DELAY	        		;(ins 94.08.02)       |
else    ; NEC_98
        push    bx                      ;Special SALMON ROM routine to delay
        push    di
        xor     cx,cx                   ;Number of Microseconds to delay
        mov     dx,1000                 ;  in CX:DX
        mov     ah,86h
        int     15h                     ;Wait 1 millisecond
        pop     di
        pop     bx
endif   ; NEC_98

MSRWait70:
        inc     di                      ;Timer +1
	jmp	short MSRWait10 	;Until Timeout or Good status

MSRWait80:
        xor     ah,ah
        mov     al,dh
        or      by ComErr[si],al        ;Return updated status
	.errnz	HIGH CE_CTSTO
	.errnz	HIGH CE_DSRTO
	.errnz	HIGH CE_RLSDTO

MSRWait90:
        or      al,al                   ;Set 'Z' if no timeout
        pop     di
        ret

MSRWait endp
page

;----------------------------Public Routine-----------------------------;
;
; $EVT - Set Event Mask
;
; Set up event word and mask.  Returns a pointer to a word in which
; certain bits, as enabled by the mask, will be set when certain
; events occur.
;
; Entry:
;   AH = Device ID
;   BX = Event enable mask
; Returns:
;   DX:AX --> event word.
; Error Returns:
;   AX = 0 if error
; Registers Preserved:
;   BX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   AX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $EVT
$EVT   proc   near

        push    si
        xor     dx,dx                   ;In case of error
        call    GetDEB                  ;Get pointer to DEB
        mov     ax,dx                   ;Finish setting error return value
        jc      Evt10                   ;Illegal id, return error
        js      Evt10                   ;LPTx, return error
        mov     EvtMask[si],bx          ;Save the new event mask
        lea     ax,EvtWord[si]          ;Get address of event word
        mov     dx,ds                   ;  into dx:ax

Evt10:
        pop     si
        ret

$EVT   endp
page

;----------------------------Public Routine-----------------------------;
;
; $EVTGET - Get Event Word
;
; Return and clear fields in the event word.  This routine MUST be used
; by applications to read the event word, as it is the ONLY way they
; can be assured that an event is not lost between reading the flags
; and resetting some.
;
; Entry:
;   AH = Device ID
;   BX = Event clear mask
; Returns:
;   AX = event word
; Error Returns:
;   None
; Registers Preserved:
;   AX,CX,SI,DI,DS,ES
; Registers Destroyed:
;   BX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $EVTGET
$EVTGET proc   near

        push    si
        call    GetDEB
        mov     ah,0                    ;In case of error (AL already 0)
        jc      EvtGet10                ;Illegal ID
        js      EvtGet10                ;Illegal ID
        call DOCLI                             ;No interrupts allowed
        mov     ax,EvtWord[si]          ;Get the current event word
        not     bx                      ;Convert mask for our purposes
        and     bx,ax                   ;Clear events that user wants us to
        mov     EvtWord[si],bx          ;And save those results
        call DOSTI                             ;Magic over

EvtGet10:
        pop     si
        ret

$EVTGET endp
page

;----------------------------Public Routine-----------------------------;
;
; $STACOM - Return Status Information
;
; Returns the number of bytes in both queues.
;
; LPT ports will show both queues empty.
; and resetting some.
;
; Entry:
;   AH    = Device ID
;   ES:BX = Pointer to status structure to be updated.
;         = Null if not to update
; Returns:
;   AX = comm error word
;   Status Structure Updated.
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $STACOM
$STACOM proc   near

	push	si
	call	GetDEB			;Get DEB pointer in SI
	jc	StaCom30		;Invalid ID
	mov	cx,es			;Is the pointer NULL?
	or	cx,bx
	jz	StaCom25		;  Yes, just return error code
	xor	cx,cx
	xor	dx,dx
	or	ah,ah			;Set 'S' if LPT port
	mov	ax,cx			;For LPTs, everything is zero
	js	StaCom20		;LPT port

; Need to get the status for a com port.  Since not all the
; status is contained within EFlags, it has to be assembled.
; Also note that currently there is no way to specify RLSD
; as a handshaking line, so fRLSDHold is always returned false.

	mov	al,MSRShadow[si]	;Get state of hardware lines
	and	al,OutHHSLines[si]	;Mask off required bits
	xor	al,OutHHSLines[si]	;1 = line low
	mov	cl,4			;Align bits
	shr	al,cl			;al = fCTSHold + fDSRHold
	.errnz	  ACE_CTS-00010000b
	.errnz	  ACE_DSR-00100000b
	.errnz	 fCTSHold-00000001b
	.errnz	 fDSRHold-00000010b

	mov	ah,HSFlag[si]		;Get fXOffHold+fXOffSent
	and	ah,XOffReceived+XOffSent
	or	al,ah

	.errnz	 XOffReceived-fXOFFHold
	.errnz	 XOffSent-fXOFFSent

	mov	ah,EFlags[si]		;Get fEOF+fTxImmed
	and	ah,fEOF+fTxImmed
	or	al,ah

	mov	cx,QInCount[si] 	;Get input queue count
	mov	dx,QOutCount[si]	;Get tx queue count

StaCom20:
	mov	es:[bx.COMS_BitMask1],al
	mov	es:[bx.COMS_cbInQue],cx
	mov	es:[bx.COMS_cbOutQue],dx

StaCom25:
	xor	ax,ax			;Return old com error
	xchg	ax,ComErr[si]		;  and clear it out

StaCom30:
	pop	si
	ret

$STACOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $SetBrk - Set Break
;
; Clamp the Tx data line low.  Does not wait for the
; transmitter holding register and shift registers to empty.
;
; LPT ports will just return the comm error word
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $SETBRK
$SETBRK proc   near

        mov     cx,0FF00h+ACE_SB        ;Will be setting break
        jmp     short ClrBrk10
	.errnz BreakSet-ACE_SB		;Must be same bits

$SETBRK endp
page

;----------------------------Public Routine-----------------------------;
;
; $CLRBRK - Clear Break
;
; Release any BREAK clamp on the Tx data line.
;
; LPT ports will just return the comm error word
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS,ES
; Registers Destroyed:
;   AX,BX,CX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $CLRBRK
$CLRBRK proc near

	mov	cx,(NOT ACE_SB) SHL 8
	.errnz BreakSet-ACE_SB		;Must be same bits

ClrBrk10:
	push	si
	call	GetDEB			;Get DEB address
	jc	ClrBrk30		;Invalid ID
	js	ClrBrk20		;Ignored for LPT ports
        call DOCLI
	and	HSFlag[si],ch		;Set or clear the BreakSet bit
	or	HSFlag[si],cl

; ch = mask to remove bits in the Line Control Register
; cl = mask to turn bits on in the Line Control Register

	mov	dx,Port[si]		;Get comm device base I/O port
	add	dl,ACE_LCR		;Point at the Line Control Regieter
	in	al,dx			;Get old line control value
	and	al,ch			;Turn off desired bits
	or	al,cl			;Turn on  desired bits
	iodelay
	out	dx,al			;Output New LCR.
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
        call DOSTI

ClrBrk20:
	mov	ax,ComErr[si]		;Return Status Word

ClrBrk30:
        pop     si
        ret

$CLRBRK endp

page

;----------------------------Public Routine-----------------------------;
;
; $EXTCOM - Extended Comm Functions
;
; A number of extended functions are routed through this entry point.
;
; Functions currently implemented:
;
;   0: Ignored
;   1: SETXOFF - Exactly as if X-OFF character has been received.
;   2: SETXON  - Exactly as if X-ON character has been received.
;   3: SETRTS  - Set the RTS signal
;   4: CLRRTS  - Clear the RTS signal
;   5: SETDTR  - Set the DTR signal
;   6: CLRDTR  - Clear the DTR signal
;   7: RESET   - Yank on reset line if available (LPT devices)
;
; Entry:
;   AH = Device ID
;   BL = Function Code
;        (0-127 are MS-defined, 128-255 are OEM defined)
; Returns:
;   AX = comm error word
; Error Returns:
;   AX = error code
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;


;       Dispatch table for the extended functions

ExtTab  dw      ExtComDummy             ;Function 0: Never Mind
        dw      ExtCom_FN1              ;1: Set X-Off
        dw      ExtCom_FN2              ;2: Clear X-Off
        dw      ExtCom_FN3              ;3: Set RTS
        dw      ExtCom_FN4              ;4: Clear RTS
        dw      ExtCom_FN5              ;5: Set DSR
	dw	ExtCom_FN6		;6: Clear DSR
	dw	ExtCom_FN7		;7: Reset printer
	dw	ExtCom_FN8		;8: Get Max LPT Port
	dw	ExtCom_FN9		;9: Get Max COM Port
	dw	ExtCom_FN10		;10: Get COM Port Base & IRQ
	dw	ExtCom_FN10		;11: Get COM Port Base & IRQ
%OUT fix this for bld 32 -- GetBaseIRQ is now 10

   assumes ds,Data
   assumes es,nothing

   public   $EXTCOM
$EXTCOM proc   near

	push	si
	push	di
        call    GetDEB                  ;Get DEB pointer
        jc      ExtCom40                ;Invalid ID, return error
	mov	dx,Port[si]		; get port address
        jns     ExtCom10                ;Its a COM port
        cmp     bl,7                    ;RESET extended function?
	jne	ExtCom30		;  No, return error word
        jmp     short ExtCom20          ;  Yes, invoke the function

ExtCom10:
	cmp	bl,11			;Last fcn supported
	ja	ExtCom30		;Not an implemented function.

ExtCom20:
        xor     bh,bh
        add     bx,bx                   ;Shift for the call
        call DOCLI                             ;Consider as critical sections
	call	ExtTab[bx]		;  and perform the function
        call DOSTI
	jc	ExtCom40		; jump if sub returns data in DX:AX

ExtCom30:
        mov     ax,ComErr[si]           ;Return standard error word
	xor	dx, dx

ExtCom40:
	pop	di
        pop     si

        ret

$EXTCOM endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN1 - Extended Function Set X-Off
;
; Analagous to receiving an X-OFF character.  Bufferred transmision of
; characters is halted until an X-ON character is received, or until
; we fake that with a Clear X-Off call.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN1
ExtCom_FN1   proc   near

        or      HSFlag[si],XOffReceived
ExtComDummy:
	clc
        ret

ExtCom_FN1   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN2 - Extended Function Clear X-Off
;
; Analagous to receiving an X-ON character. Buffered
; transmission of characters is restarted.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN2
ExtCom_FN2   proc   near

        and     HSFlag[si],NOT XOffReceived
	call	KickTx			;Kick transmitter interrupts on
	clc
	ret

ExtCom_FN2   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN3 - Extended Function Set RTS
;
; Set the RTS signal active.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN3
ExtCom_FN3   proc   near

	add	dl,ACE_MCR		;Point at Modem Control Register
	in	al,dx			;Get current settings
	or	al,ACE_RTS		;Set RTS
	iodelay
	out	dx,al			;And update
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	clc
	ret

ExtCom_FN3   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN4 - Extended Function Clear RTS
;
; Set the RTS signal inactive.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   ExtCom_FN4
ExtCom_FN4   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        and     al,NOT ACE_RTS          ;Clear RTS
	iodelay
	out	dx,al			;And update
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	clc
        ret

ExtCom_FN4   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN5 - Extended Function Set DTR
;
; Set the DTR signal active.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN5
ExtCom_FN5   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        or      al,ACE_DTR              ;Set DTR
	iodelay
	out	dx,al			;And update
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	clc
        ret

ExtCom_FN5   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN6 - Extended Function Clear DTR
;
; Set the DTR signal inactive.
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN6
ExtCom_FN6   proc   near

        add     dl,ACE_MCR              ;Point at Modem Control Register
	in	al,dx			;Get current settings
        and     al,NOT ACE_DTR          ;Clear DTR
	iodelay
	out	dx,al			;And update
ifdef   NEC_98
	iodelay		;1994.08.01 KBNES 
endif   ; NEC_98
	clc
        ret

ExtCom_FN6   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN7 - Extended Function Reset Printer
;
; Assert the RESET line on an LPT port
;
; Entry:
;   interrupts disabled
;   dx = port base address
; Returns:
;   None
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN7
ExtCom_FN7   proc   near

        call DOSTI                             ;Not called at interrupt time
ifndef  NEC_98
        mov     ch,1                    ;ROM BIOS Reset Port
	call	DoLPT			;Perform the function
endif   ; NEC_98
	clc
        ret

ExtCom_FN7   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN8 - Get Num Ports
;
; Entry:
; Returns:
;   AX = Max LPT port id
;   DX = 0
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN8
ExtCom_FN8   proc   near

	mov	ax, MAXLPT + LPTx
	xor	dx, dx
	stc
        ret

ExtCom_FN8   endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN9  - Get Max COM Port
;
; Entry:
; Returns:
;   AX = Max COM port id
;   DX = 0
; Error Returns:
;   None
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN9
ExtCom_FN9    proc   near

	mov	ax, MAXCOM
	xor	dx, dx
	stc
        ret

ExtCom_FN9    endp
page

;----------------------------Private-Routine----------------------------;
;
; ExtCom_FN10 - Get COM Port Bas & IRQ
;
; Entry:
;   AH = com id
;   DS:SI -> DEB
; Returns:
;   AX = base
;   DX = irq
; Error Returns:
;   None
; Registers Preserved:
;   DS
; Registers Destroyed:
;   AX,BX,CX,DX,DI,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

      public   ExtCom_FN10
ExtCom_FN10   proc   near

	call	FindCOMPort
	stc
	ret

ExtCom_FN10   endp
page

ifdef   NEC_98
include	delay.asm				;		(ins 94.08.02)
endif   ; NEC_98

ifdef DEBUG
	public	RecCom40, RecCom50, RecCom60, RecCom70, RecCom80
	public	RecCom90, RecCom95, RecCom100
	public	SendImm10, SendImm20,
ifdef   NEC_98
        public  SendCom20, SendCom30, SendCom40, SendCom50, SendCom60
else    ; NEC_98
	public	SendCom10, SendCom20, SendCom30, SendCom40, SendCom50, SendCom60
endif   ; NEC_98
	public	Flush10, Flush20, Flush30, Flush40
	public	KickTx10
	public	Evt10
	public	EvtGet10
	public	StaCom20, StaCom25, StaCom30
	public	ClrBrk10, ClrBrk20, ClrBrk30
	public	ExtCom10, ExtCom20, ExtCom30, ExtCom40, ExtComDummy
	public	MSRRestart, MSRWait10, MSRWait20, MSRWait30, MSRWait40
	public	MSRWait50, MSRWait60, MSRWait70, MSRWait80, MSRWait90
endif


DOSTI proc    near
      FSTI
      ret
DOSTI endp

DOCLI proc    near
      FCLI
      ret
DOCLI endp


sEnd    code
End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\ibmcom.inc ===
DEBUG	 equ   1

No_DOSX_Bimodal_Services = 1
IFDEF No_DOSX_Bimodal_Services
%OUT generating code to handle ints without Bimodal Interrupt Services for DOSX
ENDIF

wo       equ   word ptr
by       equ   byte ptr

MAXLPT	 equ   2	;3 LPTs supported (LPT1,2,3)
ifdef    NEC_98
MAXCOM   equ   4        ;5 COMs supported (COM1,2,3,4,5)	;ins 95.03.25 KBNES
else     ; NEC_98
MAXCOM	 equ   3	;4 COMs supported (COM1,2,3,4)
endif    ; NEC_98

RS232B   equ   0h       ;RS232 Card(s) I/O addr 40:Save area.
LPTB     equ   8h       ;LPT   Card(s) I/O addr 40:Save area.

IRQ3	 equ   0bh	; Int vector for Com card @ 2xxh
IRQ4	 equ   0ch	; Int vector for Com card @ 3xxh

INTA0    equ   20h      ;X'20' 8259 Interrupt Control Port
INTA1    equ   21h      ;X'21' 8259 Interrupt Mask Port
EOI      equ   20h      ;X'20' 8259 End-of-Interrupt ack

Open     equ   0201h    ;Int 2F open request
Close    equ   0202h    ;Int 2F close request
Lock2F   equ   0203h    ;Int 2F lock request
Unlock2F equ   0204h    ;Int 2F unlock request


; COMDEB - Communications Device Equipment Block.
;
; This is essentially a superset of the DCB used outside of this
; module. The DCB is contained within the DEB as the first fields.
; The fields which follow are data and status fields which
; are unique to this implementation.
;
; AltQInAddr and AltQOutAddr are alternate queue pointers which are used when
; in "supervisor" mode.  Supervisor mode is a processor mode other than the
; one which Windows normally runs in.  In standard mode Windows, supervisor
; mode is REAL mode.  In enhanced mode Windows, supervisor mode is RING 0
; protected mode.  For more details see comments in IBMINT.ASM.

ComDEB struc                           ;RS232 Data Equip Block

  ComDCB        db      ((DCBSize+1) and 0FFFEh) DUP (0)

  ComErr        dw      0               ;Non-zero if I/O error
  Port          dw      0               ;Base I/O Address
  NotifyHandle	dw	0
  NotifyFlags	dw	0
  RecvTrigger	dw     -1		; char count threshold for calling
  SendTrigger	dw	0		; char count threshold for calling

; The following fields are specific to com ports only

  IRQhook	dw	0		; ptr to IRQ_Hook_Struc
  NextDEB	dw	0		; ptr to next DEB that is sharing IRQ
  XOffPoint     dw      0               ;Q count where XOff is sent
  EvtMask       dw      0               ;Mask of events to check for
  EvtWord       dw      0               ;Event flags
  QInAddr	dd	0		;Address of the queue
  AltQInAddr	dd	0		;   Addr of queue in "supervisor" mode
  QInSize       dw      0               ;Length of queue in bytes
  QOutAddr      dd      0               ;Address of the queue
  AltQOutAddr	dd	0		;   Addr of queue in "supervisor" mode
  QOutSize      dw      0               ;Length of queue in bytes
  QInCount      dw      0               ;Number of bytes currently in queue
  QInGet        dw      0               ;Offset into queue to get bytes from
  QInPut        dw      0               ;Offset into queue to put bytes in
  QOutCount     dw      0               ;Number of bytes currently in queue
  QOutGet       dw      0               ;Offset into queue to get bytes from
  QOutPut       dw      0               ;Offset into queue to put bytes in
  EFlags        db      0               ;Extended flags
  MSRShadow     db      0               ;Modem Status Register Shadow
  ErrorMask     db      0               ;Default error-checking mask
  RxMask        db      0               ;Character mask
  ImmedChar     db      0               ;Char to be transmitted immediately
  HSFlag        db      0               ;Handshake flag
  HHSLines      db      0               ;8250 DTR/RTS bits for handshaking
  OutHHSLines   db      0               ;Lines that must be high to output
  MSRMask       db      0               ;Mask of Modem Lines to check
  MSRInfinite   db      0               ;Mask of MSR lines that must be high
  IntVecNum     db      0               ;Interrupt vector number
  LSRShadow	db	0		;Line Status Register shadow
  QOutMod	dw	0		;characters sent mod xOnLim ENQ/ETX [rkh]
  VCD_data	dd	0
  VCDflags	db	0
  MiscFlags	db	0		;still more flags
ifdef   NEC_98
  TimerProcAdr	dw	0	; System Timer Procesor		Ins 940923 KBNES
  TimerHandle	dw	0	; System Timer Handle		Ins 940923 KBNES
  hTimer	dw	0	;Timer Handle Flag		Ins 940923 KBNES
endif   ; NEC_98
ComDEB ends

.errnz	 (SIZE ComDEB) and 1

.errnz	MSRShadow - EvtWord - 35
; In 3.0 MSRShadow had this relationship to EvtWord and major COM apps all
; use this offset of 35 to get to MSRShadow so that they can determine the
; current status of the Modem Status bits.  We need to maintain this offset
; so that these apps will continue to run.


; The LptDEB is identical to the ComDEB structure, except
; all the COM port specific stuff has been removed (which
; convientiently was stored at the end so offsets would
; be correct).  This allows the code to act indifferently
; when accessing the strucutres for things like the port.

LptDEB struc
  xComDCB       db      ((DCBSize+1) AND 0FFFEh) dup (0)
  xComErr       dw      0               ;Non-zero if I/O error
  xPort         dw      0               ;Base I/O Address
  xNotifyHandle dw	0
  xNotifyFlags	dw	0
  xRecvTrigger	dw     -1		; char count threshold for calling
  xSendTrigger	dw	0		; char count threshold for calling

  BIOSPortLoc	dw	0		;Offset to port location (i.e. 40:0)
LptDEB ends

		.errnz	 xComDCB-ComDCB
		.errnz	 xComErr-ComErr
		.errnz	 xPort-Port

		.errnz	 xNotifyHandle-NotifyHandle
		.errnz	 xNotifyFlags-NotifyFlags
		.errnz	 xRecvTrigger-RecvTrigger
		.errnz	 xSendTrigger-SendTrigger


; flag equates in EFlags
fUseDSR     equ 00000001b		; set, if DSR is significant
fNoFIFO     equ 00000010b		; set, if no FIFO on port
fFIFOchkd   equ 00000100b		; set, if FIFO has been checked
fFIFOpre    equ 00001000b		; FIFO enabled when port opened
;fEOF	    equ 00100000b		; defined in comdev.inc
;fTxImmed   equ 01000000b		; defined in comdev.inc

fEFlagsMask equ fUseDSR OR fFIFOpre OR fFIFOchkd OR fNoFIFO ; flags which shouldn't be cleared

.errnz fEFlagsMask AND (fEOF OR fTxImmed) ;can't overlap with either of the bits
					;  that are folded into COMS_BitMask1


; Values for NotifyFlags
;
CN_RecvSent	equ CN_RECEIVE SHL 8
CN_TransSent	equ CN_TRANSMIT SHL 8

CN_Idle 	equ 10000000b
CN_Notify	equ 01000000b

NotifyFlagsLO	equ byte ptr NotifyFlags
NotifyFlagsHI	equ byte ptr NotifyFlags+1

; Values for the handshake flag
;
; BreakSet        - True if break was set - stops transmission
; XOffSent        - True if we have sent the XOff character
; XOffPending     - True if XOff character needs to be sent
; XOnPending      - True if XOn  character needs to be sent
; HHSDown         - True if host dropped required hardware lines
; HHSDropped      - True if we dropped our hardware handshake lines
; XOffReceived    - True if XOff received from host
; HSPending       - Mask to return non-zero if XOn or Xoff must be sent
; HSReceived      - Mask to return non-zero if handshake has been
;                   received from host stopping transmission
; CannotXmit      - Mask to return non-zero if any condition
;                   exists which prevents us from tranmitting.
; HSSent          - Mask to return non-zero if we sent a handshake


XOffPending     equ     00000001b       ;XOff needs to be sent
EnqPending      equ     00000001b       ;Enq needs to be sent [rkh]
EtxPending      equ     00000001b       ;Etx needs to be sent

HHSDropped      equ     00000010b       ;Our hardware handshake lines are down

XOnPending      equ     00000100b       ;XOn needs to be sent
AckPending      equ     00000100b       ;Ack needs to be sent (ENQ/ACK & ETX/ACK)

XOffReceived    equ     00001000b       ;XOff character received
EnqSent         equ     00001000b       ;Enq has been sent
EtxSent         equ     00001000b       ;Etx has been sent

XOffSent        equ     00010000b       ;XOff has been sent
EnqReceived     equ     00010000b       ;Enq character received (ENQ/ACK)
EtxReceived     equ     00010000b       ;Etx character received (ETX/ACK)

HHSDown         equ     00100000b       ;Host hardware handshake lines are down

BreakSet        equ     01000000b       ;Break has been set

HHSAlwaysDown	equ	10000000b	;set if host handshake lines were never
					;  detected high

HSPending       equ     XOffPending+XOnPending
HSReceived      equ     XOffReceived+HHSDown
HSSent          equ     XOffSent+HHSDropped
CannotXmit	equ	HSPending+HSReceived+BreakSet

; values for MiscFlags

Discard 	equ	00000001b	;Discard recevied data


iodelay macro		     ;;macro to insure that an instruction
ifdef   NEC_98
	out	05fh,al		;PC-98 IO rec.
else    ; NEC_98
	jmp	$+2	     ;;  fetch occurs between IN and/or OUT
	jmp	$+2	     ;;  instructions on the PC-AT machine
endif   ; NEC_98
endm


TimeoutError   equ   -2      ;Timeout error code for $TRMCOM
Timeout        equ   30      ;30 second timeout

DELAY_TIME     equ   200     ;Delay at least 200 milliseconds


;       Status bits returned from the BIOS for LPT ports

PS_NotBusy      equ     10000000b       ;Printer not busy
PS_Ack          equ     01000000b       ;Data acknowledged
PS_PaperOut     equ     00100000b       ;Out of paper
PS_Select       equ     00010000b       ;Device is selected
PS_IOError      equ     00001000b       ;IO error
PS_Timeout      equ     00000001b       ;Timeout occured


; status bit defines for LPT

L_BITS	      equ     0F8h		  ; the status bits we want
L_BITS_INVERT equ     048h		  ; must invert to match BIOS
L_DEVBUSY     equ     080h		  ; device busy bit
L_TIMEOUT     equ     001h		  ; timeout bit

; control bit defines for LPT

L_NORMAL      equ     00Ch		  ; normal state: selected, no reset
L_RESET       equ     008h		  ; reset state
L_STROBE      equ     00Dh		  ; tell printer we have char


IRQ_Hook_Struc struc
IRQn		db  0
HookCnt 	db  0
OldMask 	db  0
VecN		db  0FFh
HandlerOff	dw  0
First_DEB	dw  0
OldIntVec	dd  0
IFDEF No_DOSX_Bimodal_Services
RM_OldIntVec	dd  0
RM_HandlerOff	dw  0
ENDIF
IRQ_Hook_Struc ends


IFDEF No_DOSX_Bimodal_Services
include int31.inc

Get_RM_IntVector equ (Int31_Int_Serv SHL 8) + Int_Get_Real_Vec
Set_RM_IntVector equ (Int31_Int_Serv SHL 8) + Int_Set_Real_Vec
ENDIF

;
; flag bits for VCDflags
;
fCOM_ignore_ints    equ 00000001b
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\sound\sound.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   SOUND.ASM
;   Win16 SOUND thunks
;
;   History:
;
;   Created 06-Jan-1992 by NanduriR
;--

    TITLE   SOUND.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowsnd.inc
    include cmacros.inc
    include windefs.inc
    .list

    __acrtused = 0
    public  __acrtused  ;satisfy external C ref.

externFP WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  DATA
Reserved    db  16 dup (0)  ;reserved for Windows
SOUND_Identifier db  'SOUND16 Data Segment'


sEnd    DATA


sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

cProc   SOUND16,<PUBLIC,FAR,PASCAL,NODATA,ATOMIC>

    cBegin  <nogen>
        mov     ax,1
    ret
    cEnd    <nogen>


cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
    parmW   iExit       ;DLL exit code

    cBegin
    mov ax,1        ;always indicate success
    cEnd


assumes DS,NOTHING

    SoundThunk      OPENSOUND
    SoundThunk      CLOSESOUND
    SoundThunk      SETVOICEQUEUESIZE
    SoundThunk      SETVOICENOTE
    SoundThunk      SETVOICEACCENT
    SoundThunk      SETVOICEENVELOPE
    SoundThunk      SETSOUNDNOISE
    SoundThunk      SETVOICESOUND
    SoundThunk      STARTSOUND
    SoundThunk      STOPSOUND
    SoundThunk      WAITSOUNDSTATE
    SoundThunk      SYNCALLVOICES
    SoundThunk      COUNTVOICENOTES
    SoundThunk      GETTHRESHOLDEVENT
    SoundThunk      GETTHRESHOLDSTATUS
    SoundThunk      SETVOICETHRESHOLD
    SoundThunk      DOBEEP
    SoundThunk      MYOPENSOUND


sEnd    CODE

end SOUND16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\fontres.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  FONTRES.C
 *  WOW16 user resource services
 *
 *  History:
 *
 *  Created 05-Apr-1993 by Craig Jones (v-cjones)
 *
 *  This file provides support for the Win 3.1 AddFontResource &
 *  RemoveFontResource API's.
 *
--*/


#include <windows.h>

int  WINAPI WOWAddFontResource    (LPCSTR lpszFileName);
BOOL WINAPI WOWRemoveFontResource (LPCSTR lpszFileName);
WORD WINAPI WOWCreateDIBPatternBrush(LPVOID lpData, UINT fColor);

int WINAPI IAddFontResource (LPCSTR lpszFileName)
{

    int   ret;
    char  sz[128];
    LPSTR lpsz;

    // if the app passed a handle instead of a file name - get the file name
    if(HIWORD((DWORD)lpszFileName) == 0) {

        if(GetModuleFileName((HINSTANCE)LOWORD((DWORD)lpszFileName), sz, 128)) {
            lpsz = sz;
        }
        else {
            lpsz = NULL;
            ret  = 0;
        }
    }
    else {
        lpsz = (LPSTR)lpszFileName;
    }

    // we're really calling wg32AddFontResource here
    if(lpsz) {
        ret = WOWAddFontResource((LPCSTR)lpsz);
    }

    // ALDUS PM5 expects AddFontResource to succeed if given the base name of
    // a font that it previously did a LoadLibrary on.  The full path name was
    // passed to LoadLibrary. So if AddFontResouce failed then find out if
    // there is a loaded module already.  If so then get the full path name
    // and retry the AddFontResource. - MarkRi 6/93
    if( !ret && (HIWORD((DWORD)lpszFileName) != 0) ) {
        HMODULE hmod ;

        hmod = GetModuleHandle( lpszFileName ) ;
        if( hmod ) {
            if( GetModuleFileName( (HINSTANCE)hmod, sz, sizeof(sz) ) ) {
               ret = WOWAddFontResource( (LPCSTR)sz ) ;
            }
        }
    }

    return(ret);
}




BOOL WINAPI IRemoveFontResource (LPCSTR lpszFileName)
{
    BOOL  ret;
    char  sz[128];
    LPSTR lpsz;

    // if the app passed a handle instead of a file name - get the file name
    if(HIWORD((DWORD)lpszFileName) == 0) {

        if(GetModuleFileName((HINSTANCE)LOWORD((DWORD)lpszFileName), sz, 128)) {
            lpsz = sz;
        }
        else {
            lpsz = NULL;
            ret  = FALSE;
        }
    }
    else {
        lpsz = (LPSTR)lpszFileName;
    }

    // we're really calling wg32RemoveFontResource here
    if(lpsz) {
        ret = (BOOL)WOWRemoveFontResource((LPCSTR)lpsz);
    }

    return(ret);
}



WORD WINAPI ICreateDIBPatternBrush (HGLOBAL hMem, UINT fColor)
{
    LPVOID lpT;
    WORD  wRet = 0;

    if (lpT = LockResource(hMem)) {
        wRet = WOWCreateDIBPatternBrush(lpT, fColor);
        UnlockResource(hMem);
    }

    return wRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\drivers\neccomm2\ibmsetup.asm ===
page,132
;---------------------------Module-Header-------------------------------;
; Module Name: IBMSETUP.ASM
;
; Copyright (c) Microsoft Corporation 1985-1990.  All Rights Reserved.
;
; General Description:
;
; History:
;   sudeepb 10-Jan-1993 changed the costly cli/sti with non-trapping
;           FCLI/FSTI macros
;
;-----------------------------------------------------------------------;

title   IBMSetup - IBM PC, PC-XT, PC-AT, PS/2 Communications Interface

.xlist
include cmacros.inc
include comdev.inc
include ins8250.inc
include ibmcom.inc
include BIMODINT.INC
include vint.inc
.list


EBIS_Sel1   equ SIZE Bimodal_Int_Struc
EBIS_Sel2   equ EBIS_Sel1 + (SIZE EBIS_Sel_Struc)

externA  __WinFlags

externFP GetSystemMsecCount
externFP CreateSystemTimer
externFP AllocCStoDSAlias
externFP LockSegment
externFP UnlockSegment
externFP FreeSelector
externFP GetSelectorBase
externFP GetModuleHandle
externFP GetProcAddress
externFP GetPrivateProfileInt
externFP GetPrivateProfileString
externFP GetAppCompatFlags
ifdef   NEC_98
externFP KillSystemTimer                ;Ins 940923 KBNES
externFP TickEntry4                     ;Ins 940923 KBNES
else    ; NEC_98
externFP WowCloseComPort
endif   ; NEC_98

externNP $RECCOM

externA  __0040H
externA  __F000h

externB  IRQhooks

IF 0
externD  OldIntVecIntB
externD  OldIntVecIntC
externD  OurIntVecIntB
externD  OurIntVecIntC
ENDIF

externB  szMessage
externB  pLPTByte
externB  szCOMMessage
externB  pCOMByte
externB  _szTitle


MULTIPLEX   equ       2Fh       ; multiplex interrupt number
GET386API   equ     1684h       ; Get API entry point from VxD
VPD     equ     000Fh       ; device ID of VPD device
VPD_GETPORT equ     0004h       ; function: assign port to current VM
VPD_RELPORT equ     0005h       ; function: release port
VCD     equ     000Eh       ; device ID of VCD device
VCD_GETVER  equ     0000h       ; get version API
VCD_GETPORT equ     0004h       ; function: assign port to current VM
VCD_RELPORT equ     0005h       ; function: release port
VCD_STEALPORT equ   0006h
VPICD       equ     0003h       ; device ID of VPICD device

POSTMESSAGE equ     110         ; export ordinal of PostMessage()
MESSAGEBOX  equ     1           ; export ordinal of MessageBox()
MB_TASKMODAL equ    2000h
MB_YESNO    equ     0004h       ; messagebox flags
MB_ICONEXCLAMATION equ 0030h
IDYES       equ     6


createSeg _INTERRUPT,IntCode,word,public,CODE
sBegin IntCode
assumes cs,IntCode

    externFP FakeCOMIntFar
    externFP TimerProc
    externFP Control
    externFP COMHandler
    externFP APIHandler
IFDEF No_DOSX_Bimodal_Services
    externW  RM_IntDataSeg
    externFP RM_APIHandler
    externFP Entry_From_RM
    externD  RM_CallBack
ENDIF

sEnd IntCode

page
sBegin   Data

externB lpCommBase
externB CommBaseX
externB lpCommIrq
externB CommIrqX
externB lpCommFifo
externB CommFifoX
externB lpCommDSR
externB CommDSRx

externB lpCommSection
externB lpSYSTEMINI


;------------------------------------------------------------------------------
;
; Reserve data space for COM ports
;
DefineCommX MACRO num
    public  Comm&num
Comm&num label byte
    db  num-1
.errnz  DCB_Id
    db  ((DCBSize+1) AND 0FFFEh)-1 DUP (0)  ; ComDCB
    dw  0                   ; ComErr
    dw  0                   ; Port
    dw  0                   ; NotifyHandle
    dw  0                   ; NotifyFlags
    dw  -1                  ; RecvTrigger
    dw  0                   ; SendTrigger
.errnz IRQhook - SendTrigger - 2
    db  (SIZE ComDEB) - IRQhook DUP(0)
.errnz $ - Comm&num - (SIZE ComDEB)
    Declare_PM_BIS 0,Control,COMHandler,APIHandler,_INTERRUPT,_DATA
    db     (SIZE EBIS_Sel_Struc) * 2 DUP(0)    ; res space for 2 selectors
ENDM
DW_OFFSET_CommX MACRO num
    dw  DataOFFSET Comm&num
ENDM


??portnum = 1
REPT MAXCOM+1
    DefineCommX %??portnum
??portnum = ??portnum+1
ENDM

PUBLIC  COMptrs         ; table of offsets to CommX's declared above
COMptrs label   word
??portnum = 1
REPT MAXCOM+1
    DW_OFFSET_CommX %??portnum
??portnum = ??portnum+1
ENDM

PURGE   DefineCommX
PURGE   DW_OFFSET_CommX

;------------------------------------------------------------------------------
;
; Reserve data space for LPT ports
;
DefineLPTx MACRO num
    public  LPT&num
LPT&num label byte
    db  num-1+LPTx
.errnz  DCB_Id
    db  ((DCBSize+1) AND 0FFFEh)-1 DUP (0)  ; xComDCB
    dw  0                   ; xComErr
    dw  0                   ; xPort
    dw  0                   ; xNotifyHandle
    dw  0                   ; xNotifyFlags
    dw  -1                  ; xRecvTrigger
    dw  0                   ; xSendTrigger
IF num LE 3
    dw  LPTB + (num-1)*2
ELSE
    dw  0                   ; BIOSPortLoc
ENDIF
    .errnz $-LPT&num - SIZE LptDEB
ENDM

??portnum = 1
REPT MAXLPT+1
    DefineLPTx %??portnum
??portnum = ??portnum+1
ENDM

PURGE   DefineLPTx

page

PUBLIC  $MachineID, Using_DPMI
$MachineID    db 0      ;IBM Machine ID
Using_DPMI    db 0      ; 0FFh, if TRUE

    ALIGN 2

PUBLIC  activeCOMs
activeCOMs    dw 0

PUBLIC  lpPostMessage, lpfnMessageBox, lpfnVPD, fVPD

lpPostMessage     dd 0
lpfnMessageBox    dd 0

lpfnVPD       dd 0      ; far pointer to win 386 VPD entry point
lpfnVCD       dd 0      ; far pointer to win 386 VCD entry point
lpfnVPICD     dd 0      ; far pointer to win 386 VPICD entry point
PUBLIC VCD_int_callback
VCD_int_callback  df 0      ; VCD returns the address for this callback
                ;   on every call to acquire a COM port, but
                ;   it is always the same address, so we will
                ;   just maintain it globally.
fVPD          db 0      ; 0-not checked, 1 vpd present, -1 no vpd
fVCD          db 0      ; 0-not checked, 1 vcd present, -1 no vcd
fVPICD        db 0      ; 0-not checked, 1 vpicd present, -1 no vpicd

szUser      db 'USER',0


default_table db  4, 3, 4, 3, 0 ; Default IRQ's (COM3 default is changed to
                ;   3 for PS/2's during LoadLib)


IFDEF No_DOSX_Bimodal_Services
RM_Call_Struc   Real_Mode_Call_Struc <>
ENDIF

IFDEF DEBUG_TimeOut
%OUT including code to display MsgBox, if closing comm with data in buffer
szSendTO    db 'TimedOut CloseComm with data in buffer.  Retry?', 0
ENDIF

ifdef   NEC_98
CM_VxD_Device_ID        EQU     034h
CM_GetVersion           EQU     0
CM_GetConfig            EQU     1
CM_LockConfig           EQU     2
CM_UnlockConfig         EQU     3

CM_ConfigBuffSize       EQU     SIZE Config_Info_Struc

Max_Mem_Registers       EQU     9
Max_IO_Ports            EQU     20
Max_IRQs                EQU     7
Max_DMA_Channels        EQU     7

Config_info_Struc STRUC
CIS_Bus_id              dd      ?
CIS_Device_id           dd      ?
CIS_Serial_Number       dd      ?
CIS_Log_ID              dd      ?
CIS_Flags               dd      ?
;
; NOTE:For this example,we are using the ISA Plug&Play card access data only
;      since the sample driver is for a theoretical new ISA card.
;
CIS_CSN                 db      ?
CIS_LogicalDevNumber    db      ?
CIS_Read_data_port      dw      ?
;
; Below this point is data common to all device on all busses
;
CIS_NumMemWindows       dw      ?
CIS_MemBase             dd      Max_Mem_Registers dup(?)
CIS_MemLength           dd      Max_Mem_Registers dup(?)
CIS_MemAttrib           dw      Max_Mem_Registers dup(?)
CIS_NumIOPorts          dw      ?
CIS_IOPort_Base         dw      Max_IO_Ports      dup(?)
CIS_IOPort_Length       dw      Max_IO_Ports      dup(?)
CIS_NumIRQs             dw      ?
CIS_IRQRegisters        db      Max_IRQs          dup(?)
CIS_IRQAttrib           db      Max_IRQs          dup(?)
CIS_NumDMAs             dw      ?
CIS_DMAList             db      Max_DMA_Channels  dup(?)
CIS_DMAAttrib           dw      Max_DMA_Channels  dup(?)
CIS_Reserved            db      3 dup(?)
Config_Info_Struc ENDS

CM_Entry_Point          LABEL   DWORD
CM_Entry_Point_Off      dw      ?
CM_Entry_Point_Seg      dw      ?

My_Config_Buffer        Config_Info_Struc<>

My_Search_Buffer        LABEL   DWORD
                        dd      ?               ;My_Bus_ID
                        dd      ?               ;My_Dev_ID
                        dd      ?               ;My_Serial_Num
My_Log_ID               dd      04180a3b8h      ;My_Log_ID Fax ID 94.08.02
endif   ; NEC_98

sEnd Data

ROMBios           segment  at 0F000h
                  org         0FFFEh

MachineID label byte
RomBios Ends


sBegin Code
assumes cs,Code
assumes ds,Data

page

IFDEF No_DOSX_Bimodal_Services
;----------------------------Private-Routine----------------------------;
; SegmentFromSelector
;
;   Converts a selector to a segment...note that this routine assumes
;   the memory pointed to by the selector is below the 1Meg line!
;
; Params:
;   AX = selector to convert to segment
;
; Returns:
;   AX = segment of selector given
;
; Error Returns:
;   None
;
; Registers Destroyed:
;   CX
;
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public SegmentFromSelector
SegmentFromSelector proc far

.286
    push    dx
    cCall   GetSelectorBase,<ax>    ;DX:AX = segment of selector
    shr ax, 4
    shl dl, 4
    or  ah, dl          ;AX now points to interrupt *segment*
    pop dx
    ret
.8086

SegmentFromSelector endp
ENDIF
page

;------------------------------------------------------------------------------
;
;   Get_API_Entry
;
;   entry - BX = device id
;       DS:DI -> DWORD for proc address
;   exit - Z flag set, if failed
;
Get_API_Entry proc near

    push    di
    xor di, di
    mov es, di
    mov ax, GET386API
    int MULTIPLEX
    mov ax, di
    pop di
    mov [di], ax
    mov [di+2], es
    or  ax, [di+2]
    ret

Get_API_Entry endp

;----------------------------Private-Routine----------------------------;
;
;   Contention_Dlg
;
;   If running under Win386, this routine can be called to ask the user to
;   resolve contention for a COM or LPT port.
;
;   entry - CX is offset of message string for dialog box
;
;   exit  - Z flag set, if user specified that Windows should steal the port

Contention_Dlg proc near
PUBLIC Contention_Dlg

    xor ax,ax
    push    ax          ; hwndOwner
    push    ds
    push    cx          ; message ptr

    cmp wo lpfnMessageBox[2], 0 ;Q: ptr to MessageBox proc valid?
    jne short gmbp_done     ;   Y: we can call it
    push    ds          ;   N: get module handle of USER
    lea ax, szUser
    push    ax
    cCall   GetModuleHandle

    push    ax          ; module handle
    mov ax, MESSAGEBOX
    cwd
    push    dx
    push    ax
    cCall   GetProcAddress
    mov wo lpfnMessageBox[0], ax  ; save received proc address
    mov wo lpfnMessageBox[2], dx
gmbp_done:

    push    ds
    lea ax, _szTitle
    push    ax
    mov ax, MB_ICONEXCLAMATION or MB_YESNO or MB_TASKMODAL
    push    ax
    cCall   lpfnMessageBox
    cmp ax, IDYES       ; user allows us to take the port?
    ret
Contention_Dlg endp


ifndef   NEC_98
;----------------------------Private-Routine----------------------------;
;
;   GetPort386
;
;   If running under Win386, tell the VPD to assign an LPT port to us.
;   The comm driver will handle contention.
;
;   entry - DI contains offset in ROM area of port...
;       8 - LPT1, A - LPT2, etc
;
;   exit  - registers saved, carry = clear if OK to proceed, set if
;       user won't allow assignment of port or Win386 error
;

GetPort386  proc near
public GetPort386

    cmp fVPD, 0
    jl  getport_VPDNotInstalled
    jnz short getport_CallVPD

    push    di
    mov bx, VPD
    mov di, DataOFFSET lpfnVPD
    call    Get_API_Entry
    pop di
    jnz short getport_CallVPD
    mov fVPD, -1

getport_VPDNotInstalled:
    clc
    jmp short getport_exit

getport_CallVPD:
    mov fVPD, 1
    push    di
    sub di, LPTB
    shr di, 1           ; turn DI into port number

    xor ax, ax
    mov dx, VPD_GETPORT
    mov cx, di
    call    [lpfnVPD]
    jnc getport_gotit

;   port owned by another VM... ask the user for it

    add cl, '1'         ; fix up the port name...
    mov pLPTByte, cl        ; HACK HACK HACK
    lea cx, szMessage
    call    Contention_Dlg
    jnz getport_userwontallow

    mov ax, 1           ; tell win386 we really do want it
    mov cx, di          ;
    mov dx, VPD_GETPORT     ;
    call    [lpfnVPD]       ; return with C set or clear...
    jmp short getport_gotit

getport_userwontallow:
    stc

getport_gotit:
    pop di

getport_exit:
    ret

GetPort386  endp
endif   ; NEC_98

;----------------------------Private-Routine----------------------------;
;
;   ReleasePort386
;
;   If running under Win386, tell the VPD to deassign an LPT port.
;
;   entry - DS:SI -> COMDEB
;

ReleasePort386  proc near

    cmp fVPD, 1
    jne release_noVPD

    xor cx, cx
    mov cl, [si.DCB_id]
    and cl, NOT LPTx        ; clear high bit
    mov dx, VPD_RELPORT
    call    [lpfnVPD]

release_noVPD:
    ret

ReleasePort386  endp


ifndef  NEC_98
;----------------------------Private-Routine----------------------------;
;
;   GetCOMport386
;
;   If running under Win386, tell the VCD to assign a COM port to us.
;   The comm driver will handle contention.
;
;   entry - DS:SI -> COMDEB
;
;   exit  - registers saved, carry = clear if OK to proceed, set if
;       user won't allow assignment of port or Win386 error
;
.386
GetCOMport386 proc near
public GetCOMport386

    push    es
    pushad
    cmp fVCD, 0
    jl  short getcomport_VCDNotInstalled
    jnz short getcomport_CallVCD

    mov bx, VCD
    mov di, DataOFFSET lpfnVCD
    call    Get_API_Entry
    jz  short getcomport_checknoVCD

    mov dx, VCD_GETVER
    call    [lpfnVCD]
    cmp ax, 30Ah            ;Q: 3.1 or greater?
    jae short getcomport_CallVCD    ;   Y:

getcomport_checknoVCD:
    mov fVCD, -1

getcomport_VCDNotInstalled:
    clc
    jmp short getcomport_exit

getcomport_CallVCD:
    mov fVCD, 1

    mov ax, 10b         ; flag ring0 int handler
    call    VCD_GetPort_API
    jnc short getcomport_success  ; jump if acquire worked
    jnz short getcomport_noport   ; jump if port doesn't exist

;   port owned by another VM... ask the user for it

    mov cl, [si.DCB_id]
    add cl, '1'         ; fix up the port name...
    mov pCOMByte, cl
    lea cx, szCOMMessage
    call    Contention_Dlg
    stc
    jnz short getcomport_exit

    mov ax, 11b         ; tell win386 we really do want it
    call    VCD_GetPort_API
    jc  short getcomport_exit

getcomport_success:
    mov dword ptr [VCD_int_callback], edi
    mov word ptr [VCD_int_callback+4], cx
    mov [si.VCD_data], ebx
    xchg    ax, [si.Port]
    or  ax, ax          ;Q: already had port base?
    jnz short getcomport_exit ; Y: don't update vector #, or FIFO
    mov [si.IntVecNum], dl
    call    GetPortFlags
    clc

getcomport_exit:
    popad
    pop es
    ret

getcomport_noport:
    mov [si.Port], -1
    jmp getcomport_exit

GetCOMport386 endp

VCD_GetPort_API proc near
    mov dx, VCD_GETPORT
    xor cx, cx
    mov cl, [si.DCB_Id]     ; cx = port #
    mov di, VCDflags        ; offset from start of DEB
    call    [lpfnVCD]
    ret
VCD_GetPort_API endp
.8086

;----------------------------Private-Routine----------------------------;
;
;   ReleaseCOMport386
;
;   If running under Win386, tell the VCD to deassign a COM port.
;
;   entry - DS:SI -> COMDEB
;

ReleaseCOMport386  proc near

ifndef WOW
    cmp fVCD, 1
    jne release_noVCD

    xor cx, cx
    mov cl, [si.DCB_id]
    mov dx, VCD_RELPORT
    call    [lpfnVCD]
else
    xor cx, cx
    mov cl, [si.DCB_id]
    push cx
    call WowCloseComPort
endif

release_noVCD:
    ret

ReleaseCOMport386  endp
endif   ; NEC_98

PUBLIC StealPort
StealPort proc near

    cmp fVCD, 1
    jne sp_yes
    mov dx, VCD_STEALPORT
    xor cx, cx
    mov cl, [si.DCB_id]
    call    [lpfnVCD]
    or  al, al
    jnz sp_yes

sp_no:
    stc
    ret

sp_yes:
    clc
    mov [si.VCDflags], 0
    ret

StealPort endp

page

;------------------------------------------------------------------------------
;
;   ENTER:  DS:SI -> ComDEB
;   EXIT:   AL = 0, if IRQ was unmasked, else -1, if IRQ was already masked
;
MaskIRQ proc near
    push    es
    push    di
    mov di, ds
    mov es, di
    lea di, [si+SIZE ComDEB]
    mov ax, BIH_API_Get_Mask
    call    APIHandler      ; returns Carry Set, if masked
    jc  short already_masked
    pushf
    mov ax, BIH_API_Mask
    call    APIHandler      ; mask IRQ
    xor ax, ax
    popf
    jnc short mask_exit
already_masked:
    or  al, -1
mask_exit:
    pop di
    pop es
    ret
MaskIRQ endp

;------------------------------------------------------------------------------
;
;   ENTER:  DS:SI -> ComDEB
;
UnmaskIRQ proc near
    push    es
    push    di
    mov di, ds
    mov es, di
    lea di, [si+SIZE ComDEB]
    mov ax, BIH_API_Unmask
    call    APIHandler
    pop di
    pop es
    ret
UnmaskIRQ endp
page

;----------------------------Public Routine-----------------------------;
;
; $INICOM - Initialize A Port
;
; Initalizes the requested port if present, and sets
; up the port with the given attributes when they are valid.
; This routine also initializes communications buffer control
; variables.  This routine is passed the address of a device
; control block.
;
; The RLSD, CTS, and DSR signals should be ignored by all COM
; routines if the corresponding timeout values are 0.
;
; For the LPT ports, a check is performed to see if the hardware
; is present (via the LPT port addresses based at 40:8h.  If the
; port is unavailable, an error is returned.  If the port is
; available, then the DEB is set up for the port.  $SETCOM will
; be called to set up the DEB so that there will be something
; valid to pass back to the caller when he inquires the DEB.
;
; No hardware initialization will be performed to prevent the
; RESET line from being asserted and resetting the printer every
; time this routine is called.
;
; Entry:
;   EX:BX --> Device Control Block with all fields set.
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = initialization error code otherwise
; Registers Preserved:
;   None
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $INICOM
$INICOM  proc  near
    push    si          ;As usual, save register variables
    push    di
    mov ah,es:[bx.DCB_Id]   ;Get device i.d.
    call    GetDEB          ;--> DEB for this device
    mov ax, IE_BADID        ; call it a bad id (spooler uses DOS)
    jc  InitCom15       ;Invalid device
    jns InitCom20       ; jmp if COM port

ifndef  NEC_98
    push    ds

    mov di, [si.BIOSPortLoc]
    cmp di, LPTB
    jb  short InitLPT_Installed

    mov cx,__0040H      ;[rkh] ...
    mov ds,cx           ;Point DS: at ROM Save Area.
    assumes ds,nothing

    mov ax, IE_HARDWARE
    mov cx, wo [di]
    jcxz    InitCom10       ; if zero, no hardware

    mov ax,IE_BadID     ;Show bad device
    cmp ch, 0           ; zero hibyte -> not valid (redir)
    jz  InitCom10       ;   call it a bad id (spooler uses DOS)

    cmp di, LPTB        ; LPT1?
    jz  InitLPT_Installed   ; yes, must be installed

    cmp cx, wo [di-2]       ;Q: duplicate of previous port
    je  InitCom10       ;   Y: (redirected port)

InitLPT_Installed:
    pop ds
    mov [si.Port], cx
    call    $SETCOM
    call    GetPort386      ; tell win386 we're using the port
    mov ax, IE_OPEN     ; port already open (by another VM)
    jc  InitCom15       ;   error
    jmp InitCom90       ;That's all
endif   ; NEC_98

InitCom10:
    pop ds          ; get DS back
InitCom15:
    jmp InitCom100


    assumes ds,Data
InitCom17:
    mov ax, IE_OPEN
    cmp [si.Port], -1       ;Q: determined that port didn't exist?
    jne InitCom15       ;   N: return IE_OPEN
    jmp short InitCom27     ;   Y: return IE_HARDWARE

; ***  Set up serial port ***
;
InitCom20:
    cmp [si.Port], -1       ;Q: port exists?
    je  InitCom27       ;   N: report not found

    mov ax, __WinFlags
    test    ax, WF_ENHANCED
    jz  short @F
ifndef  NEC_98
    call    GetCOMport386
    jc  InitCom17
endif   ; NEC_98

@@:
ifdef   NEC_98
    push    ax                          ;Ins 940923 KBNES
    lea ax,TickEntry4                   ;Ins 940923 KBNES
    mov TimerProcAdr[si],ax             ;Ins 940923 KBNES
    pop ax                              ;Ins 940923 KBNES
endif   ; NEC_98
    cmp [si.Port], 0        ;Q: already got info?
    jnz @F
    call    FindCOMPort
    jc  InitCom27       ; report not found, if error
    mov [si.Port], ax
    mov [si.IntVecNum], dl
@@:

    push    es          ;Save these registers
    push    di
    push    cx          ;needed later for $SETCOM etc
    push    bx

    mov al, [si.IntVecNum]
    xor ah, ah
    lea di, [si+SIZE ComDEB]
    mov [di.BIS_IRQ_Number], ax

    mov di, DataOFFSET IRQhooks
    mov cx, MAXCOM+1
InitCom25:
ifdef   NEC_98
    jmp InitCom35                       ;Add 1994.08.02 KBNES
endif   ; NEC_98
    cmp al, [di.IRQn]       ;Q: hooked IRQ matches ours?
    je  short InitCom30     ;   Y:
    cmp [di.IRQn], 0        ;Q: end of hooked IRQ list?
    je  short InitCom35     ;   Y:
    add di, SIZE IRQ_Hook_Struc ;   N: check next hook
    loop    InitCom25
    int 3               ; data structures corrupt if we
                    ; get here, because no hook table
                    ; entries exist and there is suppose
                    ; to be at least 1 for each DEB
InitCom26:
ifndef  NEC_98
    call    ReleaseCOMport386   ; give port back to 386...
endif   ; NEC_98
    pop bx
    pop cx
    pop di
    pop es

InitCom27:
    mov ax, IE_HARDWARE     ; jump if port not available
    jmp InitCom100

InitCom30:
    cmp [di.HookCnt], 0     ;Q: IRQ still hooked?
    je  short InitCom35     ;   N: rehook
    inc [di.HookCnt]        ;   Y: inc hook count
    mov [si.IRQhook], di    ;   & link DEB into list
    mov ax, [di.First_DEB]
    mov [si.NextDEB], ax
    mov [di.First_DEB], si
    jmp short InitCom40

InitCom35:
    mov [di.IRQn], al       ; hook IRQ for first time, or rehook
    mov [si.IRQhook], di
    mov [di.First_DEB], si
    mov [di.HookCnt], 1
    call    MaskIRQ
    mov [di.OldMask], al

InitCom40:              ; di -> IRQ_Hook_Struc

    cmp [fVPICD], 0     ;Q: VPICD bimodel services available?
    jl  short InitCom415    ;   N:
    mov ax, ds          ;   Y: use them
    mov es, ax
    lea di, [si+SIZE ComDEB]

    mov [di.BIS_Descriptor_Count], 2
    mov ax, word ptr [si.QInAddr+2]  ; get selector of in queue
    mov [di.EBIS_Sel1.EBIS_User_Mode_Sel], ax
    mov ax, word ptr [si.QOutAddr+2] ; get selector of out queue
    mov [di.EBIS_Sel2.EBIS_User_Mode_Sel], ax

    mov ax, VPICD_Install_Handler
    call    [lpfnVPICD]
    jnc InitCom42
    cmp [di.OldMask], 0
    jne InitCom26
    call    UnmaskIRQ
    jmp InitCom26

InitCom42:
;
; save newly allocated selectors/segments into "Alt" queue pointers
;
    mov ax, [di.EBIS_Sel1.EBIS_Super_Mode_Sel]
    mov word ptr [si.AltQInAddr+2], ax
    mov ax, [di.EBIS_Sel2.EBIS_Super_Mode_Sel]
    mov word ptr [si.AltQOutAddr+2], ax

InitCom414:
    jmp InitCom59

InitCom415:
    cmp [di.VecN], 0FFh     ;Q: int already hooked?
IFDEF No_DOSX_Bimodal_Services
    jnz short InitCom52     ;   Y: init RMode ptrs in BIS
ELSE
    jnz InitCom414      ;   Y:
ENDIF
    mov al, [si.IntVecNum]
    add al, 8           ; 1st PIC starts at vector 8h
    cmp al, 16          ;Q: 2nd PIC?
    jb  short InitCom418    ;   N:
    add al, 70h-16      ;   Y: 2nd PIC starts at vector 70h
InitCom418:
    mov [di.VecN], al

; *** Set interrupt vectors ***
;
    mov ah,35h          ;Get the DOS vector
    int 21h         ;DOS Get Vector Function
    mov wo [di.OldIntVec][0], bx
    mov wo [di.OldIntVec][2], es

InitCom50:
    push    ds          ;Save original DS
    mov dx, [di.HandlerOff]
    mov bx, _INTERRUPT
    mov ds, bx          ;Interrupt handler address in ds:dx
    assumes ds,nothing
    mov ah, 25h         ;DOS Set Vector Function
    int 21h         ;Set the DOS vector
    pop ds          ;Original DS
    assumes ds,Data

IFDEF No_DOSX_Bimodal_Services
InitCom52:
    cmp [Using_DPMI], 0
    jz  short InitCom57

    mov ax, Int31_Get_Version SHL 8
    int 31h
    mov bl, [si.IntVecNum]
    mov bh, bl
    add bl, dh          ; assume master PIC
    sub bh, 8           ;Q: IRQ in master?
    jb  @f          ;   Y: add master's base vec
    add bh, dl          ;   N: add slave's base vec
    mov bl, bh
@@:
    mov ax, Get_RM_IntVector
    int 31h
    mov wo [di.RM_OldIntVec][0], dx
    mov wo [di.RM_OldIntVec][2], cx

    mov dx, [di.RM_HandlerOff]
    mov ax, _INTERRUPT
    call    SegmentFromSelector
    mov cx, ax
    push    cx
    mov ax, Set_RM_IntVector
    int 31h

    lea di, [si+SIZE ComDEB]
    mov wo [di.BIS_Super_Mode_API], IntCodeOFFSET RM_APIHandler
    pop cx
    mov wo [di.BIS_Super_Mode_API+2], cx

;
; Get segment addresses for the Q's and set AltQInAddr and AltQOutAddr
;
    mov ax, wo [si.AltQInAddr+2]
    call    SegmentFromSelector
    mov wo [si.AltQInAddr+2], ax
    mov ax, wo [si.AltQOutAddr+2]
    call    SegmentFromSelector
    mov wo [si.AltQOutAddr+2], ax
InitCom57:
ENDIF
    mov ax, __WinFlags      ;In Standard mode, the PIC IRQ
    test    al, WF_STANDARD     ;  priorities get rotated to favor
    jz  InitCom59       ;  the comm ports.

    call    Rotate_PIC

; *** Interrupt handler set : jump here if handler is already installed ***
;
InitCom59:
    pop bx
    pop cx
    pop di
    pop es

InitCom60:
    mov dx,[si.Port]        ;Set comm card address
    xor ax,ax           ;Need a zero
    inc dx          ;--> Interrupt Enable Register
    .errnz ACE_IER-ACE_RBR-1
    out dx,al           ;Turn off interrupts
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    call    FlagNotActive
    add dl,ACE_MCR-ACE_IER  ;--> Modem Control Register
    in  al,dx
    and al,ACE_DTR+ACE_RTS  ;Leave DTR, RTS high if already so
    iodelay             ;  but tri-state IRQ line
    out dx,al
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98

InitCom70:
    push    es          ;Zero queue counts and indexes

    push    ds
    pop es
    assumes es,Data

    lea di,QInCount[si]
    mov cx,(EFlags-QInCount)/2
    .errnz (EFlags-QInCount) AND 1
    xor ax,ax
    cld
    rep stosw

    .errnz  QInGet-QInCount-2
    .errnz  QInPut-QInGet-2
    .errnz  QOutCount-QInPut-2
    .errnz  QOutGet-QOutCount-2
    .errnz  QOutPut-QOutGet-2
    .errnz  EFlags-QOutPut-2    ;First non-queue item

    pop es
    assumes es,nothing

    mov HSFlag[si],al       ;Show no handshakes yet
    mov MiscFlags[si],al    ;Show not discarding
    mov EvtWord[si],ax      ;Show no events
    mov [si.VCDflags], al

    mov [si.SendTrigger], ax
    dec ax
    mov [si.RecvTrigger], ax

;Call $SETCOM to perform further hardware initialization.

InitCom80:
    sub dl,ACE_MCR-ACE_FCR  ; dx -> FCR
    in  al, dx
    iodelay
    test    al, ACE_FIFO_E2         ;Q: FIFO already on?
    jz  short @F            ;   N:
    or  EFlags[si], fFIFOpre        ;   Y: flag it
@@:

    ; needs si, di, and es to be saved from the beginning of inicom
    call    $SETCOM         ;Set up Comm Device
    jnz short InitCom110    ;jump if failed

    call    UnmaskIRQ
    and EFlags[si], fEFlagsMask ;Clear internal state

InitCom90:
    xor ax,ax           ;Return AX = 0 to show success
    mov ComErr[si],ax       ;Get rid of any bogus init error

InitCom100:
    pop di
    pop si
    ret

;
; jump to here, if call to $SETCOM failed
;
; DANGER! *** Call into middle of Terminate to clean things up *** DANGER!
;
InitCom110:
    push    ax          ;Failure, save error code
    call    Terminate45     ;Restore port address, int vec
    pop ax          ;Restore error code and exit
    jmp InitCom100

$INICOM endp
page

;----------------------------Public Routine-----------------------------;
;
; $TRMCOM - Terminate Communications Channel
;
; Wait for any outbound data to be transmitted, drop the hardware
; handshaking lines, and disable interrupts.  If the output queue
; contained data when it was closed, an error will be returned
;
; LPT devices have it easy.  They just need to restore the I/O port
; address.
;
; Entry:
;   AH = Device ID
; Returns:
;   AX = 0
; Error Returns:
;   AX = 8000h if invalid device ID
;   AX = -2 if output queue timeout occured
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public   $TRMCOM
$TRMCOM  proc   near

    push    si
    push    di
    xor cx,cx           ;Show no error if LPT port
    call    GetDEB
    jc  TermCom60       ;ID is invalid, return error
    js  TermCom30       ;Port is a LPT port

    push    ax          ;Save port id
    or  MiscFlags[si],Discard   ;Show discarding serial data
    mov ComErr[si],cx       ;Clear error flags
    mov QInCount[si],cx     ;Show no chars in input queue
    call    $RECCOM         ;Send XON if needed

;-----------------------------------------------------------------------;
;   We have to wait for the output queue to empty.   To do this,
;   a timer will be created.  If no character has been transmitted
;   when the timeout occurs, then an error will be indicated and
;   the port closed anyway.  If the timer cannot be created, then
;   just loop until the queue empties, which will be better than
;   discarding charatcers if there are any
;-----------------------------------------------------------------------;

    test    [si.HSFlag], HHSAlwaysDown ; Q: handshaking ever up?
    jnz TermCom17       ;   N: skip wait loop

TermCom10:
    mov cx,QOutCount[si]    ;Get current queue count
    jcxz    TermCom20       ;No characters in queue

    cCall   GetSystemMsecCount
    mov di, ax

TermCom15:
    cmp QOutCount[si],cx    ;Queue count change?
    jne TermCom10       ;  Yes, restart timeout

    cCall   GetSystemMsecCount
    sub ax, di
    cmp ax, Timeout * 1000  ;Q: Timeout reached?
    jb  TermCom15       ;   No, keep waiting

IFDEF DEBUG_TimeOut
.286
    pusha
    lea cx, szSendTO
    call    Contention_Dlg
    popa
    jz  TermCom10
.8086
ENDIF

TermCom17:
    mov cx, TimeoutError    ;   Yes, show timeout error

TermCom20:
    pop ax          ;Restore cid
ifdef   NEC_98
;-------------------------------------------------------------- Ins 940923 KBNES
;       Close Process of System Timer                           Ins 940923 KBNES
;-------------------------------------------------------------- Ins 940923 KBNES
    push    ax                          ;                       Ins 940923 KBNES
    mov ax,hTimer[si]                   ; Check hTimer          Ins 940923 KBNES
    or  ax,ax                           ; Is there TimerProcess?Ins 940923 KBNES
    jz  NoKillTimer                     ;   Y:(Nothing)         Ins 940923 KBNES
    cCall    KillSystemTimer,<ax>       ; Kill System Timer     Ins 940923 KBNES
    mov hTimer[si] ,NULL                ; Clear hTimer          Ins 940923 KBNES
NoKillTimer:                            ;                       Ins 940923 KBNES
    pop ax                              ;                       Ins 940923 KBNES
endif   ; NEC_98

TermCom30:
    mov dx,Port[si]     ;Get port base address
    call    Terminate       ;The real work is done here
    mov ax,cx           ;Set return code

TermCom60:
    pop di
    pop si
    ret

$TRMCOM endp
page

;----------------------------Private-Routine----------------------------;
;
; Terminate - Terminate Device
;
; Restore the port I/O address and make sure that interrupts are off
;
; Entry:
;   AH = Device Id.
;   DX = Device I/O port address.
;   SI --> DEB
; Returns:
;   AX = 0
; Error Returns:
;   AX = -1
; Registers Destroyed:
;   AX,BX,DX,FLAGS
; History:
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public Terminate                       ;Public for debugging
Terminate proc near

    or  ah,ah           ;LPT port?
    jns Terminate10     ;  No, process COM port
    .errnz  LPTx-10000000b

Terminate5:
    call    ReleasePort386      ; give port back to 386...
    jmp Terminate50     ;That's all


;-----------------------------------------------------------------------;
;   It is a com port!
;
;       We delay for a bit while the last character finishes transmitting
;       Then we drop DTR and RTS, and disable the interrupt generation at
;       the 8250.  Even if fRTSDisable or fDTRDisable is set, those lines
;       will be dropped when the port is closed.
;-----------------------------------------------------------------------;
;
;   When the OUT2 bit is reset to 0 to disable interrupts, many ports
;   generate an interrupt which can not be identified, because the the
;   interrupt ID register will not be set.  To work around this hardware
;   problem we first mask the IRQ, then set the port into loopback mode
;   and output a NULL to generate a receive interrupt request.  Then we
;   reset OUT2 and unmask the IRQ.  This will cause the interrupt to occur
;   and the interrupt handler will be able to correctly identify the
;   interrupt as coming from the com port.

Terminate10:
    inc dx          ;Disable chip interrupts
    .errnz ACE_IER-ACE_RBR-1
    mov al, ACE_ERBFI       ;   except receive
    out dx,al
    call    FlagNotActive       ; don't need to check for postmessage
                    ;   on timer ticks
    add dl,ACE_LSR-ACE_IER  ;--> line status register
    iodelay

Terminate20:
    in  al,dx           ;Wait until xmit is empty
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    and al,ACE_THRE+ACE_TSRE
    cmp al,ACE_THRE+ACE_TSRE
    jne Terminate20     ;Not empty yet

Terminate30:
    xor al, al
    test    EFlags[si], fFIFOpre    ;Q: leave FIFO enabled?
    jz  short @F        ;   N:
    mov al, ACE_TRIG14 OR ACE_EFIFO OR ACE_CRFIFO OR ACE_CTFIFO
@@:
    sub dl, ACE_LSR-ACE_FCR
    out dx, al
    iodelay
    call    MaskIRQ
    add dl, ACE_MCR-ACE_FCR ;--> Modem Control Register
    in  al,dx
    iodelay
    mov ah, al
    or  al,ACE_LOOP     ; turn on loopback
    out dx, al
    iodelay
    sub dl, ACE_MCR-ACE_THR
    xor al, al
    out dx, al          ; output a NULL to generate an int
    iodelay
    add dl, ACE_LSR-ACE_THR
Terminate35:
    in  al,dx           ;Wait until xmit is empty
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    and al,ACE_THRE+ACE_TSRE
    cmp al,ACE_THRE+ACE_TSRE
    jne Terminate35     ;Not empty yet
    mov al, ah
    dec dl          ; now clear OUT2 and loopback
    .errnz  ACE_LSR-ACE_MCR-1
    and al,ACE_DTR+ACE_RTS  ;Leave DTR, RTS high if already so
    out dx,al           ;  but tri-state IRQ line
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98

    call    UnmaskIRQ       ; this will cause the receive int
                    ; to occur and be processed
    sub dl, ACE_MCR-ACE_IER ; clear the receive int enable
    xor al, al
    out dx, al
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    dec dx
    .errnz  ACE_IER-ACE_RBR-1
    call    MaskIRQ

;******* DANGER! ***** NOTICE! ***** DANGER! ***** WARNING! ***** NOTICE!
;
; Terminate45 is a secondary entrypoint into this routine--it's called
; by the initialization code when that code is unable to properly init
; a com port and needs to clean-up the mess it's made.
;
;******* DANGER! ***** NOTICE! ***** DANGER! ***** WARNING! ***** NOTICE!

Terminate45:
    push    cx          ;Save original cx
    push    bx          ;Save original bx

    cmp [fVPICD], 0     ;Q: VPICD bimodel services available?
    jl  short @F        ;   N:
    mov ax, ds          ;   Y: use them
    mov es, ax
    lea di, [si+SIZE ComDEB]
    mov ax, VPICD_Remove_Handler
    call    [lpfnVPICD]
@@:

    mov di, [si.IRQhook]
    dec [di.HookCnt]        ;Q: last port using IRQ?
    jne short Terminate495  ;   N: unmask IRQ again
    mov al, 0FFh
    xchg    al, [di.VecN]       ;Interrupt vector number
    cmp al, 0FFh        ;Q: IRQ vector hooked?
    je  short Terminate49   ;   no...

IFDEF No_DOSX_Bimodal_Services
    cmp [Using_DPMI], 0
    jz  short term_no_dpmi

;
; unhook RM vector thru DPMI for standard mode
;
    push    ax
    mov ax, Int31_Get_Version SHL 8
    int 31h
    mov bl, [si.IntVecNum]
    mov bh, bl
    add bl, dh          ; assume master PIC
    sub bh, 8           ;Q: IRQ in master?
    jb  @f          ;   Y: add master's base vec
    add bh, dl          ;   N: add slave's base vec
    mov bl, bh
@@:
    mov dx, wo [di.RM_OldIntVec][0]
    mov cx, wo [di.RM_OldIntVec][2]
    mov ax, Set_RM_IntVector
    int 31h
    pop ax
term_no_dpmi:
ENDIF
    mov dx, __WinFlags      ;In Standard mode the PIC interrupt
    test    dl, WF_STANDARD     ;  priorities are changed to favor
    jz  Terminate48     ;  the comm ports.

    call    Rotate_PIC      ;This port no longer needs priority

Terminate48:
    ; *** reset int vector to it's previous state
    assumes ds,nothing
    push    ds          ;Save original DS [rkh] ...
    lds dx, [di.OldIntVec]
    mov ah, 25h         ;DOS Set Vector Function
    int 21h         ;Set the DOS vector
    pop ds          ;Original DS
    assumes ds,data

; *** interrupt vectors have been reset if needed at this point ***
;
Terminate49:
    mov cl, [di.OldMask]

; Set the 8259 interrupt mask bit for this IRQ.  Leave interrupts enabled
; if they were already enabled when the comm port was initialized by us.

    or  cl, cl
    jnz @f
Terminate495:
    call    UnmaskIRQ
@@:

    xor ax, ax
    xchg    ax, [si.NextDEB]
    cmp [di.First_DEB], si  ;Q: DEB first for IRQ hook?
    je  short Terminate46   ;   Y:
    mov bx, [di.First_DEB]  ;   N: get first
Terminate453:
    cmp [bx.NextDEB], si    ;Q: does this DEB point to one terminating?
    je  Terminate455        ;   Y:
    mov bx, [bx.NextDEB]    ;   N: get next DEB
    jmp Terminate453
Terminate455:
    mov [bx.NextDEB], ax    ; link previous DEB to NextDEB
    jmp short Terminate47
Terminate46:
    mov [di.First_DEB], ax  ; point IRQ hook at NextDEB
Terminate47:
    pop bx          ;Original BX

ifndef  NEC_98
    call    ReleaseCOMport386   ; give port back to 386...
endif   ; NEC_98

    pop cx          ;Original CX

Terminate50:                ;Also called from $INICOM !
    xor ax,ax           ;Indicate no error
    ret             ;Port is closed and deallocated

Terminate   endp
page

;----------------------------Public Routine-----------------------------;
;
; $ENANOTIFY - Enable Event Notification
;
; Entry:
;   AH     =  Device ID
;   BX     =  Window handle for PostMessage
;   CX     =  Receive threshold
;   DX     =  Transmit threshold
; Returns:
;   AX = 1, if no errors occured
; Error Returns:
;   AX = 0
; Registers Preserved:
;   BX,SI,DI,DS
; Registers Destroyed:
;   AX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public  $ENANOTIFY
$ENANOTIFY proc near
    push    si
    call    GetDEB
    mov ax, 0
    jc  scb_exit

    mov ax, cx
    inc ax
    jz  short scb_recv_ok
    cmp cx, [si.QInSize]    ;Q: receive threshold reasonable?
    jb  short scb_recv_ok   ;   Y:
%OUT should we return an error, if thresholds invalid?
    mov cx, [si.QInSize]    ;   N:
    sub cx, 10
scb_recv_ok:
    inc dx
    jz  short scb_send_ok
    dec dx
    cmp dx, [si.QOutSize]   ;Q: receive threshold reasonable?
    jb  short scb_send_ok   ;   Y:
    mov dx, [si.QOutSize]   ;   N:
    sub dx, 10
scb_send_ok:
    mov [si.NotifyHandle], bx
    mov [si.NotifyFlagsHI], CN_Notify
    or  bx, bx          ;Q: null callback?
    jnz scb_save_thresholds ;   N: save thresholds
    or  cx, -1          ;   Y: zero thresholds
    xor dx, dx
    mov [si.NotifyFlagsHI], 0
scb_save_thresholds:
    mov [si.RecvTrigger], cx
    mov [si.SendTrigger], dx
    or  [si.NotifyFlagsHI], CN_TRANSMIT ; we don't want to send
                    ; a transmit trigger notification until
                    ; the transmit buffer has been filled
                    ; above the trigger level and then
                    ; emptied below it again!

    cmp wo lpPostMessage[2], 0  ;Q: gotten addr of PostMessage yet?
    jne short scb_good      ;   Y:
    push    ds          ;   N: get module handle of USER
    lea ax, szUser
    push    ax
    cCall   GetModuleHandle

    push    ax          ; module handle
    mov ax, POSTMESSAGE
    cwd
    push    dx
    push    ax
    cCall   GetProcAddress
    mov wo lpPostMessage[0], ax ; save received proc address
    mov wo lpPostMessage[2], dx

scb_good:
    mov ax, 1

scb_exit:
    pop si
    ret
$ENANOTIFY endp
page

;----------------------------Public Routine-----------------------------;
;
; $SETQUE - Set up Queue Pointers
;
; Sets pointers to Receive and Transmit Queues, as provided by the
; caller, and initializes those queues to be empty.
;
; Queues must be set before $INICOM is called!
;
; Entry:
;   AH     =  Device ID
;   ES:BX --> Queue Definition Block
; Returns:
;   AX = 0 if no errors occured
; Error Returns:
;   AX = error code
; Registers Preserved:
;   BX,DX,SI,DI,DS
; Registers Destroyed:
;   AX,CX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $SETQUE
$SETQUE proc near

    push    si          ;These will be used
    push    di
    call    GetDEB          ;Get DEB
    jc  SetQue10        ;Invalid, ignore the call
    js  SetQue10        ;Ignore call for LPT ports
    push    ds          ;Set ds:si --> QDB
    push    es          ;Set es:di --> to ComDCB.QInAddr
    pop ds
    assumes ds,nothing
    pop es
    assumes es,Data
    lea di,QInAddr[si]
    mov si,bx
    cld
    FCLI             ;No one else can play with queues
    movsw               ; QInAddr     = QueueRxAddr
    movsw
    .errnz QueueRxAddr
    sub si, 4           ; AltQInAddr  = QueueRxAddr
    mov cx, 5           ; QInSize     = QueueRxSize
    rep movsw           ; QOutAddr    = QueueTxAddr
    sub si, 4
    mov cx, 3           ; AltQOutAddr = QueueTxAddr
    rep movsw           ; QOutSize    = QueueTxSize

    xor ax,ax           ;Will do some zero filling
    mov cl,(EFlags-QInCount)/2
    .errnz (EFlags-QInCount) AND 0FE01h
    rep stosw
    FSTI
    push    es          ;Restore the data segment
    pop ds
    assumes ds,Data
    assumes es,nothing

SetQue10:
    pop di          ;Restore saved registers
    pop si
    ret

; The above code made a few assumptions about how memory
; was allocated within the structures:

    .errnz AltQInAddr-QInAddr-4
    .errnz (QueueRxSize-QueueRxAddr)-(QInSize-AltQInAddr)
    .errnz (QueueTxAddr-QueueRxSize)-(QOutAddr-QInSize)
    .errnz AltQOutAddr-QOutAddr-4
    .errnz (QueueTxSize-QueueTxAddr)-(QOutSize-AltQOutAddr)

    .errnz QueueRxSize-QueueRxAddr-4
    .errnz QueueTxAddr-QueueRxSize-2
    .errnz QueueTxSize-QueueTxAddr-4

    .errnz QInSize-AltQInAddr-4
    .errnz QOutAddr-QInSize-2
    .errnz QOutSize-AltQOutAddr-4

    .errnz QInCount-QOutSize-2
    .errnz QInGet-QInCount-2
    .errnz QInPut-QInGet-2
    .errnz QOutCount-QInPut-2
    .errnz QOutGet-QOutCount-2
    .errnz QOutPut-QOutGet-2
    .errnz EFlags-QOutPut-2       ;First non-queue item

$SETQUE endp
page

;----------------------------Public Routine-----------------------------;
;
; $SETCOM - Set Communications parameters
;
; Re-initalizes the requested port if present, and sets up the
; port with the given attributes when they are valid.
;
; For LPT ports, just copies whatever is given since it's ignored
; anyway.
;
; Entry:
;   ES:BX --> DCB with all fields set.
; Returns:
;   'Z' Set if no errors occured
;   AX = 0
; Error Returns:
;   'Z' clear if errors occured
;   AX = initialization error code.
; Registers Destroyed:
;   AX,BX,CX,DX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public $SETCOM
$SETCOM proc near

    cld
    push    si
    push    di
    mov ah,es:[bx.DCB_Id]   ;Get device i.d.
    call    GetDEB          ;Get DEB pointer in SI
    mov ax,IE_BadID     ;Assume unknown device
    jc  SetCom10        ;Invalid device, return error
    jns SetCom20        ;COM port
    call    SetCom100       ;Copy the DCB

SetCom5:
    xor ax,ax           ;Show no error

SetCom10:
    or  ax,ax           ;Set/clear 'Z'
    pop di          ;  and exit
    pop si
    ret

;-----------------------------------------------------------------------;
;       Have a comm device, check all the serial parameters to make
;       sure they are correct before moving the new DCB into our space
;       and changing the ACE parameters.
;-----------------------------------------------------------------------;

SetCom20:
    call    SetCom300       ;Baud rate valid?
    jcxz    SetCom10        ;  No, return error
    call    SetCom400       ;Byte size/parity/stop bits correct?
    jc  SetCom10        ;  No, return error

; The parameters seem correct.  Copy the DCB into our space and
; initialize the ACE with the new parameters

    mov dx,Port[si]     ;Disable interrupts from the 8250
    inc dx
    .errnz ACE_IER-1
    xor ax,ax
    out dx,al
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    call    FlagNotActive

    call    SetCom100       ;Copy the DCB
    mov bx,si           ;Set ES:BX --> DCB
    call    SetCom200       ;Get timeout masks
    xchg    al,ah           ;Want them in the correct registers
    mov wo MSRMask[si],ax
    .errnz MSRInfinite-MSRMask-1

    call    SetCom400       ;Get line control byte
    push    ax          ;  and save LCR value
    inc dx          ;--> LCR
    inc dx
    .errnz ACE_LCR-ACE_IER-2
    or  al,ACE_DLAB     ;Want access to divisor latch
    out dx,al
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    mov RxMask[si],ah       ;Save Receive character mask
    mov ax,di           ;Get flags mask, error mask
    and [si.DCB_Flags],ah   ;Disable parity checking if no parity
    mov ErrorMask[si],al    ;Save line status error mask

    call    SetCom300       ;Get baud rate
    sub dl,ACE_LCR-ACE_DLL  ;--> LSB of divisor latch
    mov al,cl
    out dx,al
    mov al,ch
    inc dx          ;--> MSB of divisor latch
    .errnz ACE_DLM-ACE_DLL-1
    iodelay
    out dx,al
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    inc dx          ;--> LCR and clear divisor access bit
    inc dx
    .errnz ACE_LCR-ACE_DLM-2
    pop ax
    out dx,al
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98

    inc dx          ;--> Modem Control Register
    .errnz ACE_MCR-ACE_LCR-1

;-----------------------------------------------------------------------;
;       Compute initial state of DTR and RTS.  If they have been disabled,
;       then do not raise them, and disallow being used as a handshaking
;       line.  Also compute the bits to use as hardware handshake bits
;       (DTR and/or RTS as indicated, qualified with the disabled flags).
;-----------------------------------------------------------------------;

    mov al,[si.DCB_Flags]   ;Align DTR/RTS disable flags for 8250
    and al,fRTSDisable+fDTRDisable
    rol al,1            ;d0 = DTR, d2 = RTS  (1 = disabled)
    shr al,1            ;'C'= DTR, d1 = RTS
    adc al,0            ;d0 = DTR, d1 = RTS
    .errnz  fRTSDisable-00000010b
    .errnz  fDTRDisable-10000000b
    .errnz  ACE_DTR-00000001b
    .errnz  ACE_RTS-00000010b

    mov ah,al           ;Save disable mask
    xor al,ACE_DTR+ACE_RTS+ACE_OUT2
    out dx,al           ;Set Modem Control Register
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98

    mov al,[si.DCB_Flags2]  ;Get hardware handshake flags
    rol al,1            ;Align flags as needed
    rol al,1
    rol al,1
    and al,ACE_DTR+ACE_RTS  ;Mask bits of interest
    not ah          ;Want inverse of disable mask
    and al,ah           ;al = bits to handshake with
    mov HHSLines[si],al     ;Save for interrupt code

    .errnz  fDTRFlow-00100000b
    .errnz  fRTSFlow-01000000b
    .errnz  ACE_DTR-00000001b
    .errnz  ACE_RTS-00000010b

    mov al,[si.DCB_Flags]   ;Compute the mask for the output
    shl al,1            ;  hardware handshake lines
    and al,ACE_DSR+ACE_CTS
    mov OutHHSLines[si],al

    .errnz  fOutXCTSFlow-00001000b
    .errnz  fOutXDSRFlow-00010000b
    .errnz  ACE_CTS-00010000b
    .errnz  ACE_DSR-00100000b

; Compute the queue count where XOff should be issued (or hardware
; lines dropped).  This will prevent having to do it at interrupt
; time.

    mov ax,QInSize[si]      ;Get where they want it
    sub ax,[si.DCB_XoffLim] ;  and compute queue count
    mov XOffPoint[si],ax

; Enable FIFO if possible when baudrate >= 4800
;
    sub dl,ACE_MCR - ACE_FCR    ; dx = FCR
    test    EFlags[si], fNoFIFO ;Q: FIFO can be enabled?
    jnz sc_nofifo       ;   N:
    mov ax, [si.DCB_BaudRate]
    cmp ax, 4800
    jb  sc_nofifo
    cmp ah, -1          ;Q: baudrate index?
    jne sc_fifo         ;   N: baudrate >= 4800, enable FIFO
    cmp ax, CBR_4800
    jb  sc_nofifo
%OUT this isn't correct, if lower baudrates are assigned indices above CBR_4800

sc_fifo:
    mov al, ACE_TRIG14 OR ACE_EFIFO OR ACE_CRFIFO OR ACE_CTFIFO
    out dx, al          ; attempt to enable FIFO
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    test    EFlags[si], fFIFOchkd   ;Q: FIFO detect been done?
    jnz sc_fifodone     ;   Y: enabled FIFO
    iodelay
    .errnz  ACE_IIDR-ACE_FCR
    in  al, dx
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    or  EFlags[si], fFIFOchkd
    test    al, ACE_FIFO_E2     ;Q: FIFO enabled?
    jz  short @F
    test    al, ACE_FIFO_E1     ;Q: 16550A detected?
    jnz sc_fifodone     ;   Y: enabled FIFO
@@:
    iodelay
    or  EFlags[si], fNoFIFO

sc_nofifo:
    xor al, al
    out dx, al
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
sc_fifodone:

    sub dl,ACE_FCR-ACE_RBR  ; dx -> RBR
;
; Delay for things to settle
;
    push    dx
    cCall   GetSystemMsecCount
    pop dx
    mov cx, ax
delay_loop:
    in  al, dx          ;Read it once
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    push    dx
    cCall   GetSystemMsecCount
    pop dx
    sub ax, cx
    cmp ax, DELAY_TIME      ;Q: Timeout reached?
ifdef   NEC_98
    jb  delay_loop      ;   N:
else    ; NEC_98
ifndef WOW
    jb  delay_loop      ;   N:
endif
endif   ; NEC_98

    add dl,ACE_MSR      ;--> Modem Status reg
    in  al,dx           ;Throw away 1st status read
    iodelay
    in  al,dx           ;Save 2nd for MSRWait (Clear MSR int)
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    mov MSRShadow[si],al

; Win 3.0 didn't check hardware handshaking until the line status changed.
; Allow some apps to keep that behavior.

    push    dx
    xor ax, ax
    cCall   GetAppCompatFlags,<ax>
    pop dx
    test    ax, GACF_DELAYHWHNDSHAKECHK
    jnz short sc_HHSup

;
; HACK FOR SOME MODEMS:  apparently some modems set CTS, but don't set DSR
; which means that COMM.DRV won't send if the app specifies that hardware
; handshaking is based on CTS & DSR being set.
;
    mov ah,OutHHSLines[si]
    mov al, MSRShadow[si]
    and al,ah           ;Only leave bits of interest
    cmp al, ah          ;Q: handshaking lines ok?
    je  short sc_HHSup      ;   Y:
    cmp ah, ACE_CTS OR ACE_DSR  ;Q: app looking for both high?
    jne short sc_HHSdown    ;   N: skip hack
    test    [si.EFlags], fUseDSR    ;Q: DSR is always significant?
    jnz short sc_HHSdown    ;   Y: skip hack
    cmp al, ACE_CTS     ;Q: DSR low & CTS high
    jne short sc_HHSdown    ;   N: skip hack
    and ah, NOT ACE_DSR     ;   Y: ignore DSR line
    mov OutHHSLines[si], ah
    jmp short sc_HHSup

sc_HHSdown:
    or  [si.HSFlag], HHSDown OR HHSAlwaysDown ; flag handshaking down
sc_HHSup:

;-----------------------------------------------------------------------;
;       Now, at last, interrupts can be enabled.  Don't enable the
;       transmitter empty interrupt.  It will be enabled by the first
;       call to KickTx.
;-----------------------------------------------------------------------;

    sub dl,ACE_MSR-ACE_IER  ;--> Interrupt Enable Register

; flag port as being active
    push    cx
    mov cl, [si.DCB_Id]
    mov ax, 1
    shl ax, cl
    or  [activeCOMs], ax
    pop cx

ifdef   NEC_98
;---------------------------------------------------------------Ins 940923 KBNES
;       Close process of system timer                           Ins 940923 KBNES
;---------------------------------------------------------------Ins 940923 KBNES
    push    dx                          ;                       Ins 940924 KBNES
    push    ax                          ;                       Ins 940923 KBNES
    mov ax,hTimer[si]                   ; Check hTimer          Ins 940923 KBNES
    or  ax,ax                           ; TimerProcess Nothing? Ins 940923 KBNES
    jz  SetNoKillTimer                  ;   Y:(Nothing)         Ins 940923 KBNES
    cCall    KillSystemTimer,<ax>       ; Kill Syatem Timer     Ins 940923 KBNES
    mov hTimer[si] ,00h                 ; Clear hTimer          Ins 940923 KBNES
SetNoKillTimer:                         ;                       Ins 940923 KBNES
;---------------------------------------------------------------Ins 940923 KBNES
;       make process of system timer                            Ins 940923 KBNES
;---------------------------------------------------------------Ins 940923 KBNES
    mov ax, 200                         ; create 200msec timer  Ins 940923 KBNES
    push    ax                          ;                       Ins 940923 KBNES
    mov ax, _INTERRUPT                  ;                       Ins 940923 KBNES
    push    ax                          ;                       Ins 940923 KBNES
    mov ax,TimerProcAdr[si]             ;--> timer processor    Ins 940923 KBNES
    push    ax                          ;                       Ins 940923 KBNES
    call    CreateSystemTimer           ; ax = 0, if failed     Ins 940923 KBNES
    mov hTimer[si] ,ax                  ; Get hTimer            Ins 940923 KBNES
SetCom3003:                             ;                       Ins 940923 KBNES
    pop ax                              ;                       Ins 940923 KBNES
    pop dx                              ;                       Ins 940924 KBNES
endif   ; NEC_98

    mov al,ACE_ERBFI+ACE_ELSI+ACE_EDSSI
    FCLI
    out dx,al           ;Enable interrupts.
    add dl,ACE_LSR-ACE_IER  ;--> Line Status Register
    iodelay
    in  al,dx           ;Clear any Line Status interrupt
    sub dl,ACE_LSR      ;--> Receiver Buffer Register
    iodelay
    in  al,dx           ;Clear any Received Data interrupt
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
endif   ; NEC_98
    FSTI
    jmp SetCom5         ;All done

$SETCOM endp
page

FlagNotActive proc near
    push    cx
    mov cl, [si.DCB_Id]
    mov ax, NOT 1
    rol ax, cl
    and [activeCOMs], ax
    pop cx
    ret
FlagNotActive endp

;----------------------------Private-Routine----------------------------;
;
; SetCom100
;
;  Copy the given DCB into the appropriate DEB.  The check has
;  already been made to determine that the ID was valid, so
;  that check can be skipped.
;
; Entry:
;   ES:BX --> DCB
;   DS:SI --> DEB
; Returns:
;   DS:SI --> DEB
;   ES     =  Data
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,ES,DI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom100 proc near
    push    si          ;Save DEB pointer
    mov di,si
    mov si,bx
    push    es
    mov ax,ds
    pop ds
    assumes ds,nothing

    mov es,ax
    assumes es,Data

    mov cx,DCBSize
    cld
    rep movsb
    mov ds,ax
    assumes ds,Data

    pop si          ;Restore DEB pointer
    ret

SetCom100   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom200
;
; Based on whether or not a timeout has been specified for each
; signal, set up a mask byte which is used to mask off lines for
; which we wish to detect timeouts.  0 indicates that the line is
; to be ignored.
;
; Also set up a mask to indicate those lines which are set for
; infinite timeout.  1 indicates that the line has infinite
; timeout.
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   AH = lines to check
;   AL = lines with infinite timeout
; Error Returns:
;   None
; Registers Destroyed:
;   AX,CX,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom200 proc near

    xor ax,ax
    xor cx,cx           ;Get mask of lines with timeout = 0
    call    SetCom210
    not al          ;Invert result to get lines to check
    and al,ACE_CTS+ACE_DSR+ACE_RLSD
    xchg    ah,al
    dec cx          ;Get mask of infinite timeouts

SetCom210:
    cmp es:[bx.DCB_RlsTimeout],cx   ;Timeout set to passed value?
    jne SetCom220       ;  No
    or  al,ACE_RLSD     ;  Yes, show checking line

SetCom220:
    cmp es:[bx.DCB_CtsTimeout],cx   ;Timeout set to passed value?
    jne SetCom230       ;  No
    or  al,ACE_CTS      ;  Yes, show checking line

SetCom230:
    cmp es:[bx.DCB_DsrTimeout],cx   ;Timeout set to passed value?
    jne SetCom240       ;  No
    or  al,ACE_DSR      ;  Yes, show checking line

SetCom240:
    ret

SetCom200   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom300
;
; Calculate the correct baudrate divisor for the comm chip.
;
; Note that the baudrate is allowed to be any integer in the
; range 2-19200.  The divisor is computed as 115,200/baudrate.
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   CX = baudrate
; Error Returns:
;   CX = 0 if error
;   AX = error code if invalid baud rate
; Registers Destroyed:
;   AX,CX,FLAGS
; History:
;-----------------------------------------------------------------------;

BaudRateByIndexTable label word
    dw 1047     ; CBR_110
    dw 384      ; CBR_300
    dw 192      ; CBR_600
    dw 96       ; CBR_1200
    dw 48       ; CBR_2400
    dw 24       ; CBR_4800
    dw 12       ; CBR_9600
    dw 9        ; CBR_14400
    dw 6        ; CBR_19200
    dw 0        ;    0FF19h  (reserved)
    dw 0        ;    0FF1Ah  (reserved)
    dw 3        ; CBR_38400
    dw 0        ;    0FF1Ch  (reserved)
    dw 0        ;    0FF1Dh  (reserved)
    dw 0        ;    0FF1Eh  (reserved)
    dw 2        ; CBR_56000
ifdef   NEC_98
    dw 0        ;    0FF20h  (reserved)
    dw 0        ;    0FF21h  (reserved)
    dw 0        ;    0FF22h  (reserved)
    dw 1        ; CBR_128000
endif   ; NEC_98

assumes ds,Data
assumes es,nothing

SetCom300 proc near

    push    dx
    mov cx,es:[bx.DCB_BaudRate] ;Get requested baud rate
    xor ax,ax           ;Assume error
    cmp cx, CBR_110     ;Q: baudrate specified as an index?
    jae by_index
    cmp cx,2            ;Within valid range?
    jnae    SetCom310       ;  No, return error

    mov dx,1            ;(dx:ax) = 115,200
    mov ax,0C200h
    div cx          ;(ax) = 115,200/baud

SetCom310:
    mov cx,ax           ;(cx) = baud rate, or error code (0)
    mov ax,IE_Baudrate      ;Set error code incase bad baud
    pop dx
    ret

by_index:
ifdef   NEC_98
    cmp cx, CBR_128000                  ;ins 95.03.25 KBNES
else    ; NEC_98
    cmp cx, CBR_56000       ;Q: above supported?
endif   ; NEC_98
    ja  SetCom310       ;   Y: return error
    push    bx
    mov bx, cx
    sub bx, CBR_110
    shl bx, 1
    mov ax, cs:[bx+BaudRateByIndexTable]    ; get divisor
    pop bx
    jmp SetCom310       ;   Y: return error


SetCom300   endp
page

;----------------------------Private-Routine----------------------------;
;
; SetCom400
;
; Check the line configuration (Parity, Stop bits, Byte size)
;
; Entry:
;   ES:BX --> DCB
; Returns:
;   ES:BX --> DCB
;   'C' clear if OK
;   AL = Line Control Register
;   AH = RxMask
;   DI[15:8] = Flags mask (to remove parity checking)
;   DI[7:0]  = Error mask (to remove parity error)
; Error Returns:
;   'C' set if error
;   AX = error code
; Registers Destroyed:
;   AX,CX,DI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SetCom400   proc   near

    mov ax,wo es:[bx.DCB_ByteSize]  ;al = byte size, ah = parity
    cmp ah,SpaceParity      ;Parity out of range?
    ja  SetCom470       ;  Yes, return error
    mov di,0FF00h+ACE_OR+ACE_PE+ACE_FE+ACE_BI
    or  ah,ah           ;Is parity "NONE"?
    jnz SetCom410       ;  No, something is there for parity
    xor di,(fParity*256)+ACE_PE ;Disable parity checking

SetCom410:
    cmp al,8            ;Byte size out of range?
    ja  SetCom460       ;  Yes, error

SetCom420:
    sub al,5            ;Shift byte size to bits 0&1
    .errnz ACE_WLS-00000011b    ;Word length must be these bits
    jc  SetCom460       ;Byte size is illegal, return error
    add ah,ah           ;Map parity to ACE bits
    jz  SetCom430       ;0=>0, 1=>1, 2=>3, 3=>5, 4=>7
    dec ah

SetCom430:
    shl ah,1            ;Align with 8250 parity bits
    shl ah,1
    shl ah,1
    or  al,ah           ;Add to byte size

    .errnz NoParity-0
    .errnz OddParity-1
    .errnz EvenParity-2
    .errnz MarkParity-3
    .errnz SpaceParity-4
    .errnz ACE_PEN-00001000b
    .errnz ACE_PSB-00110000b
    .errnz ACE_EPS-00010000b
    .errnz  ACE_SP-00100000b

    or  al,ACE_2SB      ;Assume 2 stop bits
    mov ah,es:[bx.DCB_StopBits] ;Get # of stop bits 0=1,1/2= .GT. 1
    or  ah,ah           ;Out of range?
    js  SetCom470       ;  Yes, return error
    jz  SetCom440       ;One stop bit
    sub ah,2
    jz  SetCom450       ;Two stop bits
    jns SetCom470       ;Not 1.5, return error
    test    al,ACE_WLS      ;1.5 stop bits, 5 bit words?
    jnz SetCom470       ;  No, illegal
    .errnz OneStopBit-0
    .errnz One5StopBits-1
    .errnz TwoStopBits-2
    .errnz ACE_5BW

SetCom440:
    and al,NOT ACE_2SB      ;Show 1 (or 1.5) stop bit(s)


; From the byte size, get a mask to be used for stripping
; off unused bits as the characters are received.

SetCom450:
    push    dx
    mov cl,es:[bx.DCB_ByteSize] ;Get data byte size
    mov dx,00FFh        ;Turn into mask by shifting bits
    shl dx,cl
    mov ah,dh           ;Return mask in ah
    pop dx
    clc             ;Show all is fine
    ret

SetCom460:
    mov ax,IE_ByteSize      ;Show byte size is wrong
    stc             ;Show error
    ret

SetCom470:
    mov ax,IE_Default       ;Show something is wrong
    stc             ;Show error
    ret

SetCom400 endp
page

;----------------------------------------------------------------------------
; SuspendOpenCommPorts:
;
; This routine is called from 286 Winoldaps to simply deinstall the comm port
; hooks.
;----------------------------------------------------------------------------

cProc   SuspendOpenCommPorts,<FAR,PUBLIC,PASCAL>

cBegin  nogen

    assumes cs,Code
    assumes ds,Data

%OUT not masking IRQ's

    ; Nothing to do under 3.1!

    ret

cEnd    nogen

;----------------------------------------------------------------------------;
; ReactivateOpenCommPorts:                           ;
;                                        ;
; This routine reinstalls the comm hooks in real mode and reads the 8250     ;
; data and status registers to clear pending interrupts.             ;
;----------------------------------------------------------------------------;

cProc   ReactivateOpenCommPorts,<FAR,PASCAL,PUBLIC>,<si,di>

cBegin
    call    Rotate_PIC      ;make comm ports highest priority

    mov cx, MAXCOM+1
    mov di,dataOffset COMptrs
rcp_loop:
    mov si, [di]
    mov dx, Port[si]
    or  dx, dx
    jz  @f
    call    InitAPort       ;read comm port regs to clr pending ints
@@:
    add di, 2
    loop    rcp_loop

cEnd

;----------------------------------------------------------------------------;
; InitAPort:                                     ;
;                                        ;
; reads the data,status & IIR registers of a port (has to be 8250!)      ;
;                                        ;
; If the port has an out queue pending, then this woutine will also start    ;
; the transmit process by faking a comm interrupt.               ;
;----------------------------------------------------------------------------;

public     InitAPort
InitAPort  proc near

    add dl,ACE_RBR      ;dx=receive buffer register
    in  al,dx           ;read the data port
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
else    ; NEC_98
    jmp short $+2       ;i/o delay
endif   ; NEC_98
    add dl,ACE_LSR - ACE_RBR    ;get to the status port
    in  al,dx           ;read it too.
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
else    ; NEC_98
    jmp short $+2       ;i/o delay
endif   ; NEC_98
    add dl,ACE_IIDR - ACE_LSR   ;get to the line status register
    in  al,dx           ;read it once more
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
else    ; NEC_98
    jmp short $+2       ;i/o delay
endif   ; NEC_98
    add dl,ACE_MSR - ACE_IIDR   ;get to the modem status register
    in  al,dx           ;read it once more
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
else    ; NEC_98
    jmp short $+2       ;i/o delay
endif   ; NEC_98
    add dl,ACE_RBR - ACE_MSR    ;get to the receive buffer register
    in  al,dx           ;read it once more
ifdef   NEC_98
    iodelay                             ;1994.08.01 KBNES 
else    ; NEC_98
    jmp short $+2       ;i/o delay
endif   ; NEC_98
    call    UnmaskIRQ

; now if the port has characters pending to be sent out then we must fake a
; comm interrupt.

    cmp [si].QOutCount,0    ;characters pending to be sent ?
    jz  @f          ;no.
    FCLI             ;disable interrupts
    call    FakeCOMIntFar       ;fake an interrupt
    FSTI             ;renable interrupts
@@:
    ret

InitAPort endp

page

;----------------------------Public Routine-----------------------------;
;
; $DCBPtr - Return Pointer To DCB
;
; Returns a long pointer to the DCB for the requested device.
;
; Entry:
;   AH = Device ID
; Returns:
;   DX:AX = pointer to DCB.
; Error Returns:
;   DX:AX = 0
; Registers Preserved:
;   SI,DI,DS
; Registers Destroyed:
;   BX,CX,ES,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

   assumes ds,Data
   assumes es,nothing

   public   $DCBPTR
$DCBPTR proc   near

        push    si
        xor     dx,dx
        call    GetDEB                  ;Get pointer to DEB
        mov     ax,dx
        jc      DCBPtr10                ;Jump if invalid device
        mov     ax,si                   ;else return value here
        mov     dx,ds

DCBPtr10:
        pop     si
        ret

$DCBPTR endp
page

;----------------------------Private-Routine----------------------------;
;
; GetDEB - Get Pointer To Device's DEB
;
; Returns a pointer to appropriate DEB, based on device number.
;
; Entry:
;   AH = cid
; Returns:
;   'C' clear
;   'S' set if LPT device
;   DS:SI --> DEB is valid cid
;   AH     =  cid
; Error Returns:
;   'C' set if error (cid is invalid)
;   AX = 8000h
; Registers Preserved:
;   BX,CX,DX,DI,DS,ES
; Registers Destroyed:
;   AX,SI,FLAGS
; History:
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

public GetDEB               ;Public for debugging
GetDEB proc near

    push    cx
    mov cl, ah
    and cx, (NOT LPTx AND 0FFh)
    test    ah, ah          ;Q: LPT id?
ifdef   NEC_98
    js  short GetDEB30      ;   Y:   error if LPT
else    ; NEC_98
    js  short GetDEB10      ;   Y:
endif   ; NEC_98
.errnz LPTx - 80h
    cmp ah, MAXCOM      ;Q: Within range?
    ja  GetDEB30        ;   N: return invalid ID
    shl cx, 1
    mov si, cx
    mov si, [si+COMptrs]
ifndef  NEC_98
    jmp short GetDEB20

GetDEB10:
    cmp ah, LPTx+MAXLPT     ;Q: Within range?
    ja  GetDEB30        ;   N: return invalid ID
    mov si, DataOFFSET LPT1
    jcxz    GetDEB20
GetDEB15:
    add si, SIZE LptDEB
    loop    GetDEB15
GetDEB20:
endif   ; NEC_98
    pop cx
    or  ah, ah          ; clear Carry & set S, if LPT port
    ret

GetDEB30:
    pop cx
    mov ax,8000h        ;Set error code
    stc             ;Set 'C' to show error
    ret

GetDEB endp
page


CvtHex proc near
;   assume DS=SS
    push    si
    mov cl, 4
    mov si, di
    xor dx, dx
    cld
ch_lp:
    lodsb
    sub al, '0'         ;Q: char < '0'
    jb  ch_exit         ;   Y: return
    cmp al, 9           ;Q: char <= '9'
    jbe ch_got_digit        ;   Y: move digit into result
    sub al, 'A' - '0'       ;Q: char < 'A'
    jb  ch_exit         ;   Y: return
    add al, 10
    cmp al, 15          ;Q: char <= 'F'
    jbe ch_got_digit        ;   Y: move hex char into result
    sub al, 10 + 'a' - 'A'  ;Q: char < 'a'
    jb  ch_exit         ;   Y: return
    add al, 10
    cmp al, 15          ;Q: char > 'f'
    ja  ch_exit         ;   Y: return
ch_got_digit:
    shl dx, cl
    or  dl, al
    jmp ch_lp
ch_exit:
    mov ax, dx
    pop si
    ret
CvtHex endp

.286
; attempt to read base from SYSTEM.INI
GetComBase proc near
    push    ds              ; save our DS
    sub sp, 6
    mov di, sp
    mov byte ptr ss:[di], 0
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommBase
    push    ss              ; temp buffer
    push    di
    push    ss              ; default = temp buffer
    push    di
    push    5
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileString     ;   our segment in real mode
    or  ax, ax
    jz  short gcb_exit
    call    CvtHex              ; DS still equal to SS
gcb_exit:
    add sp, 6
    pop ds              ; restore our DS
    assumes ds,Data
    ret
GetComBase endp

GetPortIRQ proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommIrq
    push    bx
    mov bl, [si.DCB_Id]
    cmp bl, 4
    jb  @f
    mov bl, 4
@@:
    xor bh, bh
    mov bl, [bx+default_table]
    mov cx, bx
    pop bx
    push    cx              ; default
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    ret
GetPortIRQ endp


GetPortFlags proc near
    mov al, [si.DCB_Id]
.erre MAXCOM LT 9           ;only single digit port numbers supported
    add al, '1'
    mov [CommFIFOX], al
    mov [CommDSRx], al
    call    GetPortFIFO
    call    GetPortDSR
    ret
GetPortFlags endp

GetPortFIFO proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommFifo
    push    2
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    cmp ax, 1
    ja  short gpf_exit          ; just check at open
    jb  short gpf_no_fifo       ; force OFF, if = 0
    or  EFlags[si], fFIFOchkd       ; flag as checked, to force ON
    jmp short gpf_exit

gpf_no_fifo:
    or  EFlags[si], fNoFIFO OR fFIFOchkd    ; force OFF

gpf_exit:
    ret
GetPortFIFO endp

GetPortDSR proc near
    push    ds              ; save our DS
    push    ds
    push    DataOFFSET lpCommSection
    push    ds
    push    DataOFFSET lpCommDSR
    push    0
    push    ds
    push    DataOFFSET lpSYSTEMINI
    mov cx, ss              ; temporarily assign DS=SS
    mov ds, cx              ;   to allow KERNEL to thunk
    assumes ds,nothing
    call    GetPrivateProfileInt        ;   our segment in real mode
    pop ds              ; restore our DS
    assumes ds,Data
    or  ax, ax
    jz  short gpd_exit
    or  EFlags[si], fUseDSR

gpd_exit:
    ret
GetPortDSR endp


; FindCOMPort
;
; DS:SI -> DEB
;
    PUBLIC FindCOMPort
FindCOMPort proc near
;
; Examine BIOS data area to get base I/O addresses for COM and LPT ports
;
    push    bx
    push    cx
    push    es
ifndef  NEC_98
    mov ax, __0040H
    mov es, ax
    assumes es,nothing
endif   ; NEC_98

    mov al, [si.DCB_Id]
    mov ah, al
.erre MAXCOM LT 9           ;only single digit port numbers supported
    add ah, '1'
    mov [CommBaseX], ah
    mov [CommIRQX], ah
    mov [CommFIFOX], ah
    mov [CommDSRx], ah

ifdef   NEC_98
    mov ax,238h                         ;I/O Base Addr Set
    mov dx,5                            ;IRQ Set
else    ; NEC_98
    cmp al, 4
    jae fcp_not_phys_com
    xor ah, ah
    shl ax, 1
    mov bx, ax
    mov ax, es:[bx+RS232B]
    or  ax, ax
    jnz fcp_got_com_base
fcp_not_phys_com:
    call    GetComBase
    or  ax, ax
    jnz fcp_got_com_base
    mov bl, [si.DCB_Id]
    cmp bl, 2
    jne fcp_invalid     ; jump, if base = 0 & com port <> com3
    mov ax, 3E8h        ; default COM3 to 3E8h
fcp_got_com_base:
    push    ax
    call    GetPortIRQ
    mov dx, ax
    pop ax
    or  dl, dl          ;Q: non-zero IRQ?
    jz  fcp_invalid     ;   N:
    cmp dl, 15          ;Q: IRQ in range?
    ja  fcp_invalid     ;   N:
    xor dh, dh
endif   ; NEC_98
    push    ax
    push    dx
    call    GetPortFIFO
    call    GetPortDSR
    pop dx
    pop ax
    clc
fcp_exit:
    pop es
    pop cx
    pop bx
    ret

fcp_invalid:
    or  ax, -1
    mov dx, ax
    stc
    jmp fcp_exit

FindCOMPort endp
.8086

page
;--------------------------Private Routine-----------------------------;
;
; Rotate the PIC interrupt priorities so the communication ports are
; highest priority.
;
; NOTE: Only rotates priorities on master PIC.
;
;-----------------------------------------------------------------------;

    assumes ds,Data
    assumes es,nothing

    public Rotate_PIC

Rotate_PIC proc near

ifndef  NEC_98
    push    ax
    push    cx
    push    di

    mov al, 8           ; 0 - 7 rotated
    mov cx, MAXCOM+1
    mov di, DataOFFSET IRQhooks
rp_loop:
    mov ah, [di.IRQn]
    cmp ah, 0           ;End of hooked IRQ list?
    je  rp_set
    cmp [di.VecN], 0FFh     ;Hooked?
    je  rp_next
    cmp ah, 8           ;If on slave PIC, treat as IRQ2
    jb  @f
    mov ah, 2
@@:
    cmp ah, al
    jae rp_next
    mov al, ah          ;AL = lowest hooked comm IRQ
rp_next:
    add di, SIZE IRQ_Hook_Struc
    loop    rp_loop

rp_set:
    dec al          ;Setting IRQ(n-1) as the lowest
    and al,  07h        ;  priority makes IRQn the highest
    or  al, 0C0h
    out INTA0, al

    pop di
    pop cx
    pop ax
endif   ; NEC_98
    ret

Rotate_PIC endp


ifdef DEBUG
ifdef   NEC_98
    public  InitCom20, InitCom40, InitCom50, InitCom59
else    ; NEC_98
    public  InitCom10, InitCom20, InitCom40, InitCom50, InitCom59
endif   ; NEC_98
    public  InitCom60, InitCom70, InitCom80, InitCom90, InitCom100
    public  TermCom10, TermCom15, TermCom20, TermCom30
    public  TermCom60, Terminate5, Terminate10, Terminate20, Terminate30
    public  Terminate45, Terminate49, Terminate50
    public  SetQue10
ifdef   NEC_98
    public  SetCom5, SetCom20, SetCom210, SetCom220, SetCom230
else    ; NEC_98
    public  SetCom5, SetCom10, SetCom20, SetCom210, SetCom220, SetCom230
endif   ; NEC_98
    public  SetCom240, SetCom310, SetCom410, SetCom420, SetCom430
    public  SetCom440, SetCom450, SetCom460, SetCom470
ifdef   NEC_98
    public  GetDEB30
else    ; NEC_98
    public  GetDEB10, GetDEB20, GetDEB30
endif   ; NEC_98
    public  DCBPtr10
endif

sEnd    code

page

createSeg _INIT,init,word,public,CODE
sBegin init
assumes cs,init



;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
ifndef  NEC_98
IBMmodel proc near
      push  ax
      push  bx
      push  es

      mov   ah, 0c0h
      int   15h
      jc    IBMmodel_exit

      assumes es,nothing

      cmp   by es:[bx+2], 0f8h      ; PS/2 80
      je    IBMmodel_exit       ;   return carry clear

      cmp   by es:[bx+2], 0fch      ; AT or PS/2 50 or 60
      jne   OldBios         ; assume OldBios

      cmp   by es:[bx+3], 04h       ; PS/2 50
      je    IBMmodel_exit       ;   return carry clear
      cmp   by es:[bx+3], 05h       ; PS/2 60
      je    IBMmodel_exit       ;   return carry clear

OldBios:
      stc

IBMmodel_exit:
      pop   es
      pop   bx
      pop   ax
      ret

IBMmodel endp
endif   ; NEC_98

cProc LoadLib, <FAR,PUBLIC,NODATA>,<si,di>
cBegin

ifndef  NEC_98
    push    ds
    mov ax, __F000H
    mov ds, ax
    assumes ds, ROMBios
    mov al, [MachineID]
    pop ds
    assumes ds,Data
    mov [$MachineID], al

    call    IBMmodel        ;Q: PS/2?
    jc  @F          ;   N:
    mov [default_table+2], 3    ;   Y: change COM3 default IRQ to 3
@@:

    push    ds
    mov ax, __0040H
    mov ds, ax
    assumes ds,nothing
    cmp word ptr ds:[RS232B], 2F8h  ;Q: COM2 base in COM1 slot?
    pop ds
    assumes ds,Data
    jne @F              ;   N: leave IRQ default as 4
    mov [default_table], 3      ;   Y: change IRQ default to 3
@@:
endif   ; NEC_98

    mov [fVPICD], -1        ; assume no

    xor di, di
    mov es, di
    mov ax, GET386API
    mov bx, VPICD
    int MULTIPLEX
    mov wo [lpfnVPICD], di
    mov wo [lpfnVPICD+2], es
    mov ax, es
    or  ax, di
    jz  short no_VPICD      ; jump if no bimodel services available
;
; version check VPICD
;
    mov ax, VPICD_API_Get_Ver
    call    [lpfnVPICD]
%OUT version check VPICD

    mov [fVPICD], 1     ; flag services are available

IFDEF No_DOSX_Bimodal_Services
    jmp short skip_dosx_stuff

no_VPICD:
    mov ax, __WinFlags
    and al, WF_PMODE or WF_WIN286
    cmp al, WF_PMODE or WF_WIN286
    jne skip_dosx_stuff

.286
    mov ax, Int31_Get_Version SHL 8
    int 31h
    test    bl, 10b         ;Q: processor goes to real mode
                    ;   for int reflection?
    jz  skip_dosx_stuff     ;   N:
    mov [Using_DPMI], 0FFh  ;   Y: flag use of DPMI

    mov ax, ds
    cCall   GetSelectorBase,<ax>    ;DX:AX = segment of selector
    shr ax, 4
    shl dl, 4
    or  ah, dl          ;AX now points to interrupt *segment*
    push    ax          ;save on stack
    mov ax, _INTERRUPT      ;write data SEGMENT into _INTERRUPT
    cCall   AllocCStoDSAlias,<ax>   ; code segment -- requires a data alias
    mov es, ax
    pop ax
    mov es:[RM_IntDataSeg],ax
    push    ds
    push    es
    mov ax, ds
    mov es, ax
    mov ax, _INTERRUPT
    mov ds, ax
    mov ax, (Int31_Trans_Serv SHL 8) + Trans_Call_Back
    mov si, IntCodeOFFSET Entry_From_RM
    mov di, DataOFFSET RM_Call_Struc
    int 31h
    pop es
    pop ds
    mov ax, 0
    jnc @f
    jmp short LoadExit
@@:
    mov wo es:[RM_CallBack], dx
    mov wo es:[RM_CallBack+2], cx
    cCall   FreeSelector,<es>    ;don't need CS alias any longer
.8086
skip_dosx_stuff:
ELSE
no_VPICD:
ENDIF

ifndef  NEC_98
;
; find base values for LPT ports
;
    mov cx, __0040h
    mov es, cx
    mov cx, MAXLPT+1
    mov si, DataOFFSET LPT1
ll_initl_lp:
    mov bx, [si.BIOSPortLoc]
    or  bx, bx
    jz  ll_not_phys_lpt
    mov ax, es:[bx]
    or  ah, ah          ;Q: lpt redirected, or 0?
    jz  ll_not_phys_lpt     ;   Y:
    cmp bx, LPTB        ;Q: first LPT?
    je  ll_got_lpt_base     ;   Y:
    cmp ax, es:[bx-2]       ;Q: base same as previous (redirected)?
    jne ll_got_lpt_base     ;   N: must be real
ll_not_phys_lpt:
%OUT attempt to read base from SYSTEM.INI

ll_got_lpt_base:
    mov [si.Port], ax
    loop    ll_initl_lp
endif   ; NEC_98

;
; create system timer for signalling chars in receive buffer
;

ifndef WOW
    mov ax, 100         ; create 100msec timer
    push    ax
    mov ax, _INTERRUPT
    push    ax
    mov ax, IntCodeOFFSET TimerProc
    push    ax
    call    CreateSystemTimer   ; ax = 0, if failed
%OUT should I display an error message here?

endif
    assumes es,nothing
LoadExit:
cEnd

sEnd    init

End LoadLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\gdi.asm ===
TITLE   GDI.ASM
        PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; GDI.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   25-Jan-1991 Jeff Parsons (jeffpar)
;   Created.
;

        ; Some applications require that USER have a heap.  This means
        ; we must always have: LIBINIT equ 1
        LIBINIT equ 1

        .286p

        .xlist
        include wow.inc
        include wowgdi.inc
        include cmacros.inc
        include metacons.inc
        .list

        __acrtused = 0
        public  __acrtused      ;satisfy external C ref.

externFP WOW16Call

ifdef LIBINIT
externFP LocalInit
endif

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  DATA
Reserved        db  16 dup (0)      ;reserved for Windows  //!!!!! what is this

GDI_Identifier  db      'GDI16 Data Segment'

 Stocks  dw  17 dup (0)  ; Stock Object Handles
public FTRAPPING0
FTRAPPING0 dw 0
sEnd    DATA

;
; GP fault exception handler table definition
;

createSeg _GPFIX0,GPFIX0,WORD,PUBLIC,CODE,IGROUP  ; GP fault trapping

sBegin  GPFIX0
__GP    label   word
public __GP
sEnd    GPFIX0

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

externFP GetStockObject
cProc   GDI16,<PUBLIC,FAR,PASCAL,NODATA,ATOMIC>

        cBegin  <nogen>
        IFDEF   LIBINIT
        ; push params and call user initialisation code

        push di                 ;hModule

        ; if we have a local heap declared then initialize it

        jcxz no_heap

        push 0                  ;segment
        push 0                  ;start
        push cx                 ;length
        call LocalInit

no_heap:
        ;
        ; I didn't put a call to LibMain here, because I didn't think we
        ; had anything to do.
        ;
        pop     di
        mov     ax,1
        ELSE
        mov     ax,1
        ENDIF

        push ax
        push di
        push si

        xor  si,si
        xor  di,di
my_loop:
        push si
        call GetStockObject
        mov  ds:[di + offset Stocks],ax
        add  di,2
        inc  si
        cmp  si,16       ; Stock Objects have an index range of 0 through 16
        jna  my_loop

        pop  si
        pop  di
        pop  ax
        ret
        cEnd    <nogen>

assume DS:nothing

cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
        parmW   iExit           ;DLL exit code

        cBegin
        mov     ax,1            ;always indicate success
        cEnd

assume DS:nothing

;*--------------------------------------------------------------------------*
;*
;*  CheckStockObject()
;*
;*  Checks to see if the stock object is already fetched.
;*
;*--------------------------------------------------------------------------*

cProc CheckStockObject, <PUBLIC, NEAR>
parmW  nIndex
parmD lpReturn          ; Callers Return Address
;parmW wBP           ; Thunk saved BP
;parmW wDS           ; Thunk saved DS
cBegin
    mov  bx,nIndex
    cmp  bx,16
    ja   @f
    push ds
    mov  ax,seg Stocks
    mov  ds,ax
    shl  bx,1
    mov  ax,ds:[bx+offset Stocks]
    pop  ds
    or   ax,ax
    jz   @f

    pop  bp
    add  sp,2         ; skip thunk IP

 ;   mov  sp,bp
 ;   pop  bp
 ;   lea  sp,-2[bp]
 ;   pop  ds
 ;   pop  bp
 ;   dec  bp
    retf 2        ; 2 bytes to pop
@@:
    mov  sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop  bp
    ret

cEnd <nogen>


externFP GlobalHandle

cProc IGetMetafileBits, <PUBLIC, FAR>
parmW  hmf
cBegin
        ; return (GlobalHandle(hMF) & 0xffff) ? hMF : FALSE;

    push    hmf
    call    GlobalHandle
    cmp     ax, 0
    je      @f
    mov     ax, hmf
@@:
cEnd


cProc ISetMetafileBits, <PUBLIC, FAR>
parmW  hmf
cBegin
        ; return (hBits)
    mov     ax, hmf
cEnd

externFP GlobalReAlloc
cProc ISetMetafileBitsBetter, <PUBLIC, FAR>
parmW  hmf
cBegin
        ; return (GlobalReAlloc(hBits, 0L, GMEM_MODIFY | GMEM_SHAREALL));
    push    hmf
    push    0
    push    0
    push    2080h               ;; GMEM_MODIFY or GMEM_SHAREALL
    call    GlobalReAlloc
cEnd



        GDIThunk    CLOSEMETAFILE
        GDIThunk    COPYMETAFILE
        GDIThunk    CREATEMETAFILE
        GDIThunk    DELETEMETAFILE
        GDIThunk    GETMETAFILE
     ;   GDIThunk    GETMETAFILEBITS
        GDIThunk    ENUMMETAFILE
        DGDIThunk   ISVALIDMETAFILE, 0
        GDIThunk    PLAYMETAFILE
        GDIThunk    PLAYMETAFILERECORD
     ;   GDIThunk    SETMETAFILEBITS

FUN_WOWADDFONTRESOURCE EQU FUN_ADDFONTRESOURCE
        DGDIThunk    WOWADDFONTRESOURCE %(size ADDFONTRESOURCE16)

        GDIThunk    ANIMATEPALETTE
        GDIThunk    ARC
        GDIThunk    BITBLT
;        DGDIThunk   BRUTE
        GDIThunk    CHORD
        DGDIThunk   CLOSEJOB
        GDIThunk    COMBINERGN
        GDIThunk    COMPATIBLEBITMAP,6
        DGDIThunk   COPY,10
        GDIThunk    CREATEBITMAP
        GDIThunk    CREATEBITMAPINDIRECT
        GDIThunk    CREATEBRUSHINDIRECT
        GDIThunk    CREATECOMPATIBLEBITMAP
        GDIThunk    CREATECOMPATIBLEDC
        GDIThunk    CREATEDC
        GDIThunk    CREATEDIBITMAP
FUN_WOWCREATEDIBPATTERNBRUSH EQU FUN_CREATEDIBPATTERNBRUSH
        DGDIThunk   WOWCREATEDIBPATTERNBRUSH, %(size CREATEDIBPATTERNBRUSH16)
        GDIThunk    CREATEDISCARDABLEBITMAP
        DGDIThunk   CREATEELLIPTICRGN
        GDIThunk    CREATEELLIPTICRGNINDIRECT
        GDIThunk    CREATEFONT
        GDIThunk    CREATEFONTINDIRECT
        GDIThunk    CREATEHATCHBRUSH
        GDIThunk    CREATEIC
        GDIThunk    CREATEPALETTE
        GDIThunk    CREATEPATTERNBRUSH
        GDIThunk    CREATEPEN
        GDIThunk    CREATEPENINDIRECT
        GDIThunk    CREATEPOLYGONRGN
        GDIThunk    CREATEPOLYPOLYGONRGN
;;;        DGDIThunk   CREATEPQ,2
        GDIThunk    CREATEREALBITMAP,14
        GDIThunk    CREATEREALBITMAPINDIRECT,6
        DGDIThunk   CREATERECTRGN
        GDIThunk    CREATERECTRGNINDIRECT
        DGDIThunk   CREATEROUNDRECTRGN
        DGDIThunk   CREATESOLIDBRUSH
        DGDIThunk   CREATEUSERBITMAP
        DGDIThunk   CREATEUSERDISCARDABLEBITMAP,6
        DGDIThunk   DEATH,2
        GDIThunk    DELETEDC
        DGDIThunk   DELETEJOB,4
        GDIThunk    DELETEOBJECT
;;;        DGDIThunk   DELETEPQ,2
        DGDIThunk   DEVICECOLORMATCH,8
        GDIThunk    DEVICEMODE
        DGDIThunk   DMBITBLT
        DGDIThunk   DMCOLORINFO,12
        DGDIThunk   DMENUMDFONTS,16
        DGDIThunk   DMENUMOBJ,14
        DGDIThunk   DMOUTPUT,28
        DGDIThunk   DMPIXEL,16
        DGDIThunk   DMREALIZEOBJECT,18
        DGDIThunk   DMSCANLR,14
        DGDIThunk   DMSTRBLT,30
        DGDIThunk   DMTRANSPOSE,10
        GDIThunk    DPTOLP
        GDIThunk    DPXLATE,8
        GDIThunk    ELLIPSE
        DGDIThunk   ENDSPOOLPAGE,2
        GDIThunk    ENUMCALLBACK,14
        GDIThunk    ENUMFONTS
        GDIThunk    ENUMOBJECTS
        GDIThunk    EQUALRGN
        GDIThunk    ESCAPE
        GDIThunk    EXCLUDECLIPRECT
        DGDIThunk   EXCLUDEVISRECT,10
        GDIThunk    EXTDEVICEMODE
        GDIThunk    EXTFLOODFILL
;;;        DGDIThunk   EXTRACTPQ,2
        GDIThunk    EXTTEXTOUT
        DGDIThunk   FASTWINDOWFRAME,14
        GDIThunk    FILLRGN
        DGDIThunk   FINALGDIINIT,2
        GDIThunk    FLOODFILL
        GDIThunk    FRAMERGN
        DGDIThunk   GDIINIT2,4
        DGDIThunk   GDIMOVEBITMAP,2
        DGDIThunk   GDIREALIZEPALETTE,2
        DGDIThunk   GDISELECTPALETTE,6
        GDIThunk    GETASPECTRATIOFILTER
        GDIThunk    GETBITMAPBITS
        GDIThunk    GETBITMAPDIMENSION
        DGDIThunk   GETBKCOLOR
        DGDIThunk   GETBKMODE
        DGDIThunk   GETBRUSHORG
        GDIThunk    GETCHARWIDTH
        GDIThunk    GETCLIPBOX
        DGDIThunk   GETCLIPRGN
        DGDIThunk   GETCURLOGFONT,2
        GDIThunk    GETCURRENTOBJECT
        DGDIThunk   GETCURRENTPOSITION
        DGDIThunk   GETDCORG
        DGDIThunk   GETDCSTATE,2
        GDIThunk    GETDEVICECAPS
        GDIThunk    GETDIBITS
        GDIThunk    GETENVIRONMENT
        DGDIThunk   GETMAPMODE
        GDIThunk    GETNEARESTCOLOR
        GDIThunk    GETNEARESTPALETTEINDEX
        GDIThunk    GETOBJECT
        GDIThunk    GETPALETTEENTRIES
        DGDIThunk   GETPHYSICALFONTHANDLE,2
        GDIThunk    GETPIXEL
        DGDIThunk   GETPOLYFILLMODE
        DGDIThunk   GETRELABS
        DGDIThunk   GETREGIONDATA
        GDIThunk    GETRGNBOX
        DGDIThunk   GETROP2
        DGDIThunk   GETSPOOLJOB,6
        PGDIThunk   GETSTOCKOBJECT,CheckStockObject
        DGDIThunk   GETSTRETCHBLTMODE
        GDIThunk    GETSYSTEMPALETTEENTRIES
        GDIThunk    GETSYSTEMPALETTEUSE
        DGDIThunk   GETTEXTALIGN
        GDIThunk    GETTEXTCHARACTEREXTRA
        DGDIThunk   GETTEXTCOLOR
        GDIThunk    GETTEXTEXTENT
        GDIThunk    GETTEXTFACE
        GDIThunk    GETTEXTMETRICS
        DGDIThunk   GETVIEWPORTEXT
        DGDIThunk   GETVIEWPORTORG
        DGDIThunk   GETWINDOWEXT
        DGDIThunk   GETWINDOWORG
        GDIThunk    GSV,2
        DGDIThunk   INQUIREVISRGN
;;;        DGDIThunk   INSERTPQ,6
        GDIThunk    INTERNALCREATEDC,16
        GDIThunk    INTERSECTCLIPRECT
        DGDIThunk   INTERSECTVISRECT,10
        GDIThunk    INVERTRGN
        DGDIThunk   ISDCCURRENTPALETTE,2
        DGDIThunk   ISDCDIRTY,6
        GDIThunk    LINEDDA
        GDIThunk    LINETO
        GDIThunk    LPTODP
        GDIThunk    LVBUNION,10
        GDIThunk    MFDRAWTEXT,14
;;;        DGDIThunk   MINPQ,2
        GDIThunk    MOVETO
;       DGDIThunk   MULDIV ; thunk locally
        GDIThunk    OFFSETCLIPRGN
        GDIThunk    OFFSETORG,6
        GDIThunk    OFFSETRGN
        GDIThunk    OFFSETVIEWPORTORG
        DGDIThunk   OFFSETVISRGN,6
        GDIThunk    OFFSETWINDOWORG
        DGDIThunk   OPENJOB,10
        GDIThunk    PAINTRGN
        GDIThunk    PATBLT
        GDIThunk    PIE
        GDIThunk    PIXTOLINE,16
        GDIThunk    POLYGON
        GDIThunk    POLYLINE
        GDIThunk    POLYPOLYGON
        GDIThunk    POLYPOLYLINEWOW     ; New for ACAD guys.
        GDIThunk    PTINREGION
        GDIThunk    PTVISIBLE
        DGDIThunk   QUERYJOB,4
        GDIThunk    RCOS,4
        DGDIThunk   REALIZEDEFAULTPALETTE,2
        GDIThunk    RECTANGLE
        GDIThunk    RECTINREGION
        GDIThunk    RECTSTUFF,10
        GDIThunk    RECTVISIBLE

FUN_WOWREMOVEFONTRESOURCE EQU FUN_REMOVEFONTRESOURCE
        DGDIThunk    WOWREMOVEFONTRESOURCE %(size REMOVEFONTRESOURCE16)

        GDIThunk    RESIZEPALETTE
        GDIThunk    RESTOREDC
        DGDIThunk   RESTOREVISRGN,2
        DGDIThunk   RESURRECTION,14
        GDIThunk    ROUNDRECT
        GDIThunk    RSIN,4
        GDIThunk    SAVEDC
        DGDIThunk   SAVEVISRGN,2
        GDIThunk    SCALEEXT,10
        GDIThunk    SCALEVIEWPORTEXT
        GDIThunk    SCALEWINDOWEXT
        DGDIThunk   SCANLR,12
        GDIThunk    SELECTCLIPRGN
        GDIThunk    SELECTOBJECT
        DGDIThunk   SELECTVISRGN,4
        GDIThunk    SETBITMAPBITS
        GDIThunk    SETBITMAPDIMENSION
        GDIThunk    SETBKCOLOR
        GDIThunk    SETBKMODE
        GDIThunk    SETBRUSHORG
        DGDIThunk   SETDCORG,6
        DGDIThunk   SETDCSTATE,4
        DGDIThunk   SETDCSTATUS,8
        GDIThunk    SETDIBITS
        GDIThunk    SETDIBITSTODEVICE
        GDIThunk    SETENVIRONMENT
        GDIThunk    SETMAPMODE
        GDIThunk    SETMAPPERFLAGS
        GDIThunk    SETPALETTEENTRIES
        GDIThunk    SETPIXEL
        GDIThunk    SETPOLYFILLMODE
        GDIThunk    SETRECTRGN
        DGDIThunk   SETRELABS
        GDIThunk    SETROP2
        GDIThunk    SETSTRETCHBLTMODE
        GDIThunk    SETSYSTEMPALETTEUSE
        GDIThunk    SETTEXTALIGN
        GDIThunk    SETTEXTCHARACTEREXTRA
        GDIThunk    SETTEXTCOLOR
        GDIThunk    SETTEXTJUSTIFICATION
        GDIThunk    SETVIEWPORTEXT
        GDIThunk    SETVIEWPORTORG
        GDIThunk    SETWINDOWEXT
        GDIThunk    SETWINDOWORG
        GDIThunk    SETWINVIEWEXT,6
        DGDIThunk   SHRINKGDIHEAP, 0
;;;        DGDIThunk   SIZEPQ,4
        DGDIThunk   STARTSPOOLPAGE,2
        GDIThunk    STRETCHBLT
        GDIThunk    STRETCHDIBITS
        GDIThunk    STUFFINREGION,6
        GDIThunk    STUFFVISIBLE,6
        GDIThunk    TEXTOUT
        GDIThunk    UNREALIZEOBJECT
        GDIThunk    UPDATECOLORS
        GDIThunk    WORDSET,4
        DGDIThunk   WRITEDIALOG,8
        DGDIThunk   WRITESPOOL,8

; New Win 3.1 thunks

        DGDIThunk   BITMAPBITS,10                       ;Internal

        DGDIThunk    SETDCHOOK,10                       ;Internal
        DGDIThunk    GETDCHOOK,6                        ;Internal
        DGDIThunk   SETHOOKFLAGS,4                      ;Internal
        DGDIThunk   SETBOUNDSRECT
        DGDIThunk   GETBOUNDSRECT
        DGDIThunk   SELECTBITMAP,4                      ;Internal
      ;  GDIThunk    SETMETAFILEBITSBETTER               ;New for 3.1

        DGDIThunk   DMEXTTEXTOUT,40
        DGDIThunk   DMGETCHARWIDTH,24
        DGDIThunk   DMSTRETCHBLT,40
        DGDIThunk   DMDIBBITS,26
        DGDIThunk   DMSTRETCHDIBITS,50
        DGDIThunk   DMSETDIBTODEV,32


        DGDIThunk   DELETESPOOLPAGE,2                   ; new for 3.1
        DGDIThunk   SPOOLFILE                           ; new for 3.1

        DGDIThunk   ENGINEENUMERATEFONT,12              ;Internal
        DGDIThunk   ENGINEDELETEFONT,4                  ;Internal
        DGDIThunk   ENGINEREALIZEFONT,12                ;Internal
        DGDIThunk   ENGINEGETCHARWIDTH,12               ;Internal
        DGDIThunk   ENGINESETFONTCONTEXT,6              ;Internal
        DGDIThunk   ENGINEGETGLYPHBMP,22                ;Internal
        DGDIThunk   ENGINEMAKEFONTDIR,10                ;Internal
        GDIThunk    GETCHARABCWIDTHS
        GDIThunk    GETOUTLINETEXTMETRICS
        GDIThunk    GETGLYPHOUTLINE
        GDIThunk    CREATESCALABLEFONTRESOURCE
        GDIThunk    GETFONTDATA
        DGDIThunk   CONVERTOUTLINEFONTFILE,12           ;internal
        DGDIThunk   GETRASTERIZERCAPS
        DGDIThunk   ENGINEEXTTEXTOUT,42                 ;internal
        GDIThunk    ENUMFONTFAMILIES
        GDIThunk    GETKERNINGPAIRS


        GDIThunk    RESETDC
        GDIThunk    STARTDOC
        GDIThunk    ENDDOC
        GDIThunk    STARTPAGE
        GDIThunk    ENDPAGE
        GDIThunk    SETABORTPROC
        GDIThunk    ABORTDOC


        DGDIThunk   GDISEEGDIDO,8                       ;Internal

        DGDIThunk   GDITASKTERMINATION,2                ;Internal
        DGDIThunk   SETOBJECTOWNER,4                    ;Internal
        DGDIThunk   ISGDIOBJECT
        DGDIThunk   MAKEOBJECTPRIVATE,4                 ;Internal
        DGDIThunk   FIXUPBOGUSPUBLISHERMETAFILE,6       ;Internal
        DGDIThunk   RECTVISIBLE_EHH,6
        DGDIThunk   RECTINREGION_EHH,6
        DGDIThunk   UNICODETOANSI,8                     ;Internal


        GDIThunk    GETBITMAPDIMENSIONEX
        DGDIThunk   GETBRUSHORGEX
        DGDIThunk   GETCURRENTPOSITIONEX
        GDIThunk    GETTEXTEXTENTPOINT
        DGDIThunk   GETVIEWPORTEXTEX
        DGDIThunk   GETVIEWPORTORGEX
        DGDIThunk   GETWINDOWEXTEX
        DGDIThunk   GETWINDOWORGEX
        GDIThunk    OFFSETVIEWPORTORGEX
        GDIThunk    OFFSETWINDOWORGEX
        GDIThunk    SETBITMAPDIMENSIONEX
        GDIThunk    SETVIEWPORTEXTEX
        GDIThunk    SETVIEWPORTORGEX
        GDIThunk    SETWINDOWEXTEX
        GDIThunk    SETWINDOWORGEX
        GDIThunk    MOVETOEX
        GDIThunk    SCALEVIEWPORTEXTEX
        GDIThunk    SCALEWINDOWEXTEX
        GDIThunk    GETASPECTRATIOFILTEREX

        DGDITHUNK   CREATEDIBSECTION                     ; new for chicago
        DGDITHUNK   GETDIBCOLORTABLE                     ; new for chicago
        DGDITHUNK   SETDIBCOLORTABLE                     ; new for chicago

;
; New for NT 5.0 Win95 compatibility
;

        DGDIThunk   ABORTPATH
        DGDIThunk   ABORTPRINTER
        DGDIThunk   ADDLPKTOGDI
        DGDIThunk   BEGINPATH
        DGDIThunk   BUILDINVERSETABLEDIB
        DGDIThunk   CLOSEENHMETAFILE
        DGDIThunk   CLOSEFIGURE
        DGDIThunk   CLOSEPRINTER
        DGDIThunk   COPYENHMETAFILE
        DGDIThunk   CREATEENHMETAFILE
        DGDIThunk   CREATEHALFTONEPALETTE
        DGDIThunk   DELETEENHMETAFILE
        DGDIThunk   DRVGETPRINTERDATA
        DGDIThunk   DRVSETPRINTERDATA
        DGDIThunk   ENDDOCPRINTER
        DGDIThunk   ENDPAGEPRINTER
        DGDIThunk   ENDPATH
        DGDIThunk   ENGINEGETCHARWIDTHEX
        DGDIThunk   ENGINEGETCHARWIDTHSTR
        DGDIThunk   ENGINEGETGLYPHBMPEXT
        DGDIThunk   ENGINEREALIZEFONTEXT
        DGDIThunk   ENUMFONTFAMILIESEX
        DGDIThunk   EXTCREATEREGION
        DGDIThunk   EXTCREATEPEN
        DGDIThunk   EXTSELECTCLIPRGN
        DGDIThunk   FILLPATH
        DGDIThunk   FLATTENPATH
        DGDIThunk   GDICOMMENT
        DGDIThunk   GDIPARAMETERSINFO
        DGDIThunk   GDISIGNALPROC32
        DGDIThunk   GETARCDIRECTION
        DGDIThunk   GETCHARACTERPLACEMENT
        DGDIThunk   GETENHMETAFILE
        DGDIThunk   GETENHMETAFILEBITS
        DGDIThunk   GETENHMETAFILEDESCRIPTION
        DGDIThunk   GETENHMETAFILEHEADER
        DGDIThunk   GETENHMETAFILEPALETTEENTRIES
        DGDIThunk   GETFONTLANGUAGEINFO
        DGDIThunk   GETMITERLIMIT
        DGDIThunk   GETPATH
        DGDIThunk   GETRANDOMRGN
        DGDIThunk   GETREALDRIVERINFO
        DGDIThunk   GETTEXTCHARSET
        DGDIThunk   GETTEXTEXTENTEX
        DGDIThunk   GETTTGLYPHINDEXMAP
        DGDIThunk   ICMCHECKCOLORSINGAMUT
        DGDIThunk   ICMCREATETRANSFORM
        DGDIThunk   ICMDELETETRANSFORM
        DGDIThunk   ICMTRANSLATERGB
        DGDIThunk   ICMTRANSLATERGBS
        DGDIThunk   OPENPRINTERA
        DGDIThunk   PATHTOREGION
        DGDIThunk   PLAYENHMETAFILERECORD
        DGDIThunk   POLYBEZIER
        DGDIThunk   POLYBEZIERTO
        DGDIThunk   SELECTCLIPPATH
        DGDIThunk   SETARCDIRECTION
        DGDIThunk   SETENHMETAFILEBITS
        DGDIThunk   SETMAGICCOLORS
        DGDIThunk   SETMETARGN
        DGDIThunk   SETMITERLIMIT
        DGDIThunk   SETSOLIDBRUSH
        DGDIThunk   STARTDOCPRINTERA
        DGDIThunk   STARTPAGEPRINTER
        DGDIThunk   STROKEANDFILLPATH
        DGDIThunk   STROKEPATH
        DGDIThunk   SYSDELETEOBJECT
        DGDIThunk   WIDENPATH
        DGDIThunk   WRITEPRINTER

;
; Queryabort
;

cProc QUERYABORT,<PUBLIC,FAR,PASCAL,NODATA,WIN>
        parmw hdc
        parmw res
cBegin
        ; Not Supported
        mov   ax,1
cEnd

ifdef FE_SB
FUN_IGETFONTASSOCSTATUS EQU FUN_GETFONTASSOCSTATUS
        DGDIThunk  IGETFONTASSOCSTATUS %(size GETFONTASSOCSTATUS16)
endif  ;FE_SB

cProc GdiFreeResources,<PUBLIC,FAR,PASCAL,NODATA,WIN>
        ParmD cbBaseline
cBegin
        mov   ax,90      ; % free
cEnd


sEnd    CODE

end     GDI16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\gdimacro.inc ===
;/*	GDIMACRO.INC - GDI macros

LMHLockCnt	equ	byte ptr 3
wptr	equ	word ptr
bptr	equ	byte ptr

PtoLMH	macro r1,r2
ifnb <r2>
	mov	r1,[r2 - 2]
else
	mov	r1,[r1 - 2]
endif
endm

LMHtoP macro r1,r2		;; Local Movable Handle to pointer
ifnb <r2>
	mov	r1,[r2]
else
	mov	r1,[r1]
endif
endm

LMHtoPES macro r1,r2		 ;; Local Movable Handle to ptr, deref vi ES
ifnb <r2>
	mov	r1,es:[r2]
else
	mov	r1,es:[r1]
endif
endm

LMPsize macro r1,r2		;; Local Movable pointer size
	mov	r1,-4[r2]
endm


LockDataSegment macro
endm


UnlockDataSegment macro
endm

farLockDataSegment macro
endm


farUnlockDataSegment macro
endm


;	NOTE:	The lock/unlock macros are not going to check
;		for under/overflow.  Its highly unlikely that
;		it will occur, and if it does, we'll be hosed
;		anyway....


LLock	macro	r
	inc	LMHLockCnt[r]		;;Increment ref count
endm

LUnlock macro	r
	dec	LMHLockCnt[r]		;;Decrement reference count
endm

LLocked? macro	r
	cmp	LMHLockCnt[r],0		;; is the handle locked?
endm

LLockES macro	r
	inc	es:LMHLockCnt[r]	;;Increment ref count
endm

LUnlockES macro   r
	dec	es:LMHLockCnt[r]	 ;;Decrement reference count
endm

LLockedES? macro  r
	cmp	es:LMHLockCnt[r],0	 ;; is the handle locked?
endm

;	The jmpnext macro and associated symbols are used to generate
;	the fall-through chain and generate the labels required for
;	error checking.

??ji	=	0			;;Initial index value

jmpnext macro e
jn %??ji,%(??ji+1),e			;;Set next label
endm

jn macro i,j,e
.sall
??ji&i:
.xall
ifb <e> 				;;If not the end of the chain
	db	03dh			;;mov bx, next two bytes
errn$	??ji&j,+2			;;mext lable must be two bytes away
endif
??ji=j					;;increment counter
endm

ifdef DEBUG
ifndef ?HELPER
ExternFP ValidateHandle
endif
endif

;*
;*      Valid? macro Handle,Error_exit,LowLimit,UpLimit
;*
;*      Validate an object handle. A valid handle must 1)not be NULL 2)be for
;*      an object of the specified type.
;*
;*
;*	Macro Arguments:
;*
;*          Handle  -   object handle
;*          Error_exit - the next instruction to execute if an invalid obj
;*          LowLimit, UpLimit - Range of the possible object type
;*
;*      Return:
;*          DS:BX   -   pointer to the object
;*
;*	Trashes:
;*		AX,BX,CX,DX
;*

Valid? macro	Handle,Error_exit,LowLimit,UpLimit
	local	ValidHandle,Invalidexit

ifdef DISABLE
ifdef DEBUG

;******************************************************************************
;
; Object handle validation in a debug version
;
;******************************************************************************

	push	dx
mov	bx, LowLimit
	ifnb	<UpLimit>
mov	dx, UpLimit
	else
mov	dx, LowLimit
	endif

	cCall	<far ptr ValidateHandle>,<Handle,bx,dx>
	pop	dx
        or      ax,ax
	jnz	ValidHandle
        jmp     Error_exit
else

;******************************************************************************
;
; Object handle validation in a retail version
;
;******************************************************************************

	mov	bx,Handle                   ; NULL handle validation
	or	bx,bx
	jz	Invalidexit

        LMHtoP  bx                          ; dereference for object pointer

	mov	ax,ilObjType[bx]            ; Validate the object type

irp     stock_type,<OBJ_PEN,OBJ_BRUSH,OBJ_FONT,OBJ_BITMAP,OBJ_PALETTE>
ife     stock_type-LowLimit
	and	ax,NOT OBJ_FLAGS            ; mask only for possible stock obj
endif
endm

ifnb    <UpLimit>
	cmp	ax,LowLimit                 ; Check object type range
	jl	Invalidexit
	cmp	ax,UpLimit
	jle	ValidHandle
else
	cmp	ax,LowLimit                 ; Check a particular object type
	je	ValidHandle
endif

Invalidexit:
        xor     ax,ax
        jmp     Error_exit                  ; it is not a valid handle

endif

ValidHandle:

else	; !DISABLE

	mov	bx,Handle
	LMHtoP	bx

endif	; !DISABLE
	endm

ValidDebug? macro	Handle,LowLimit,UpLimit

ifdef DEBUG

	push	bx
	push	dx
mov	bx, LowLimit
	ifnb	<UpLimit>
mov	dx, UpLimit
	else
mov	dx, LowLimit
	endif

	cCall	<far ptr ValidateHandle>,<Handle,bx,dx>
	pop	dx
	pop	bx

endif
        endm

;*
;*	Notify? macro
;*
;*	Tests if the given dc is hooked, and if it is, calls off to
;*	send a notification to whomever is hooked into the dc notification
;*	hook.
;*
;*	Macro Arguments:
;*
;*		hDC - the actual DC handle
;*		lParam - the notification code to send via the hook
;*		errLbl - optional parameter, which gives label to
;*			jump to if notification returns 0
;*
;*	Trashes:
;*		AX,BX,flags
;*
ifdef LATER
ifndef ?LVB
ExternFP SendDCNotify
ExternFP SendInvalidVisRgn
endif
Notify? macro hDC,code,param1,param2,errLbl
	mov	bx,hDC
	mov	bx,[bx]
	mov	ax,word ptr lpNotifyProc[bx]
	or	ax,word ptr lpNotifyProc+2[bx]
	jz	@F
	push	hDC
	mov	ax,code
	push	ax
	mov	ax,param1
	push	ax
	mov	ax,param2
	push	ax
	cCall	<far ptr SendDCNotify>
ifnb	<errLbl>
	or	ax,ax
endif
ifnb	<errLbl>
	jnz	@F
	jmp	errLbl
endif
@@:
	endm


;*	VNotify?
;*
;*	Tests if the given dc is hooked and has an invalid visrgn.  If
;*	it does, then a notification is sent to the dc hook.
;*
;*	Warning:
;*		if we call the call-back, the gdi heap can be compacted,
;*		so no dereferenced handles can be relied on after making
;*		this call.
;*
;*	Entry:
;*		hDC - handle to dc to check and send notifications
;*		reg - scratch register to use
;*
;*	Exit:
;*		reg - trashed
;*		flags - trashed
;*
VNotify? macro	hDC,reg
	mov	reg,hDC
	LMHtoP	reg
	test	byte ptr DCFlags[reg],BadVisRgn
	jz	@F
	cCall	<far ptr SendInvalidVisRgn>,<hDC>
@@:
	endm

VNotifyPtr? macro reg,hDC
	test	byte ptr DCFlags[reg],BadVisRgn
	jz	@F
	cCall	<far ptr SendInvalidVisRgn>,<hDC>
@@:
	endm
endif

;-----------------------------------------------------------------------
; cProcVDO  - cProc "Validate Debug Only"
;
; Same as cProc, except used for "Validate in Debug Only" entry points.
; Declares Iname if debug, name if retail.
;
cProcVDO macro  name,opts,savelist
  ifdef DEBUG
        cProc   <I&name>,<opts>,<savelist>
  else
        LabelFP <PUBLIC, I&name>
        cProc   <name>,<opts>,<savelist>
  endif
endm

GDIGLOBALLOCK macro Handle,segRegister,offsetRegister
.lall
ifndef	    GlobalLock
ExternFP    GlobalLock
endif
	cCall	<far ptr GlobalLock>,<Handle>
ifnb <segRegister>
	mov	segRegister,dx
endif
ifnb <offsetRegister>
	mov	offsetRegister,ax
endif
.sall
	endm


GDIGLOBALUNLOCK macro Handle
ifndef	    GlobalUnlock
ExternFP    GlobalUnlock
endif
	cCall	<far ptr GlobalUnlock>,<Handle>
	endm

GDIRequestSem macro
	endm

GDIClearSem macro
	endm


;	setlbl generates a macro which will declare labels public
;	if "debug" has been defined.  The symbol generated will
;	be of the form:
;
;	    filename_label
;
;	where
;
;	    filename is the parameter given to the setlbl macro,
;	    and label is the first parameter given to the lbl macro
;	    which is generated by setlbl.
;
;
;	lbl is the macro which will define the given label and
;	if "debug" is defined, declare it public.
;
;
;	    lbl foo,<opt1>,opt2
;
;	where
;
;	    foo     is the name of the label
;	    opt1    is an optional second parameter.  If present,
;		    it must be some combination of
;			proc, label, near, far, byte, word, dword
;	    opt2    is an optional third parameter which if present
;		    must be "public".  It forces the declaration of
;		    "foo" to be public.



setlbl macro filename
  lbl &macro n,opt1,opt2
    .sall
    ifnb <opt1>
      n opt1
      ifdef debug
	filename&&_&&n equ n
	public filename&&_&&n
      endif
    else
      n:
      ifdef debug
	filename&&_&&n:
	public filename&&_&&n
      endif
    endif
    ifnb <opt2>
    public n
    endif
    .xall
  &endm
endm


smov	macro	segreg1,segreg2
	push	segreg2
	pop	segreg1
	endm

jmps	macro	there
	jmp	short there
	endm

; structure to allow easy access to components of DWORD.

HILO	struc
lo	dw	?
hi	dw	?
HILO	ends

; structure to allow easy access to components of LP.

OFFSEL	struc
off	dw	?
sel	dw	?
OFFSEL	ends


;--------------------------------------------------------------------------;
; ABS
;	Maps the signed integer in AX to a positive signed integer to be
; 	returned in AX.  If FOO is blank then 8000h is mapped to 7fffh.
;	Since GDI defines MININT as 8000h, we should deal with this case.
;	If FOO is non-blank, 8000h is mapped to 8000h.  (Usually bad!)
;	All other integers behave as one would expect with Absolute Value.
; Entry:
;	AX	= signed integer (8000h to 7fffh)
; Returns:
;	AX	= ABS(AX)
; Trashes:
;	DX, FLAGS
;
; History:
;   Tue 29 October 1991		-by-	Raymond E. Endres	[rayen]
; Wrote it.
;--------------------------------------------------------------------------;


ABS	macro	FOO			;NOTE: default FOO is blank!
	cwd
	xor	ax,dx
	sub	ax,dx
ifb	<FOO>				;if FOO is blank
	cwd				;remove the 8000h case
	xor	ax,dx
endif
	endm


;--------------------------------------------------------------------------;
; min_ax
;	returns min of AX and REG
; Entry:
;	AX	= integer
;	REG	= general purpose register containing an integer
; Returns:
;	AX	= min(AX,REG)
; Error Returns:
;	none
; Registers Destroyed:
;	DX,FLAGS
; Registers Preserved:
;	BX,CX,SI,DI,DS,ES,BP
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:39:04p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


min_ax	macro	REG
	sub	ax,REG
	cwd
	and	ax,dx
	add	ax,REG
	endm



;--------------------------------------------------------------------------;
; max_ax
;	returns max of AX and REG
; Entry:
;	AX	= integer
;	REG	= general purpose register containing an integer
; Returns:
;	AX	= max(AX, REG)
; Error Returns:
;	none
; Registers Destroyed:
;	DX,FLAGS
; Registers Preserved:
;	BX,CX,SI,DI,DS,ES,BP
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:41:38p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;

maxintoax	macro	mem1,mem2
	mov	ax,mem1
	max_ax	mem2
	endm


max_ax	macro	REG
	sub	ax,REG
	cwd
	not	dx
	and	ax,dx
	add	ax,REG
	endm



;	The following equates are used for defining the target
;	processor to the shift macros.


GENERIC	equ	0

;CPU	equ	GENERIC
;CPU	equ	88
;CPU	equ	86
;CPU	equ	186
CPU	equ	286
;CPU	equ	386



;--------------------------------------------------------------------------;
; shiftl
;
; shiftl is used to implement the advanced shift left immediate
; (SHL dest,count) functionality of the 286 and 386.
;
; Entry:
;	DEST	= var to shift
;	COUNT	= number to shift by
; Returns:
;	DEST	= DEST shl COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:44:30p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


shiftl	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	shl	DEST,COUNT
else
	REPT	COUNT
	shl	DEST,1
	ENDM
endif
	endm



;--------------------------------------------------------------------------;
; shiftr
;
; shiftr is used to implement the advanced shift right immediate
; (SHR dest,count) functionality of the 286 and 386.
;
; Entry:
;	DEST	= var to shift
;	COUNT	= number to shift by
; Returns:
;	DEST	= DEST shr COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:44:52p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


shiftr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	shr	DEST,COUNT
else
	REPT	COUNT
	shr	DEST,1
	ENDM
endif
	endm


;--------------------------------------------------------------------------;
; nop32
;
; compensate for bug in the 386 chip and 32-bit string operations.
;
;--------------------------------------------------------------------------;
nop32	macro
	db	067h
	nop
	endm

	if	0
*/

#ifndef DEBUG 
#include "igdi.inc"
#endif

#define MAX(a,b)	((a)>(b)?(a):(b))
#define MIN(a,b)	((a)<=(b)?(a):(b))
#define ABS(x)		(((x) >= 0) ? (x) : (-(x)))
#define LBYTE(x)	((BYTE)((x)&0xFF))
#define HBYTE(y)	((BYTE)(((y)>>8)&0xFF))
#define LWORD(x)	((short)((x)&0xFFFF))
#define HWORD(y)	((short)(((y)>>16)&0xFFFF))
#define MAKELONG(h,l)  ((long)(((WORD)l)|(((long)h)<<16)))

extern far PASCAL ValidateHandle(HANDLE, short, short);
#ifdef DISABLE
#define Valid(Handle, Low, High)    ValidateHandle(Handle, Low, High)
#else
#define Valid(Handle, Low, High)    TRUE
#endif

#ifdef  DEBUG
#define ValidDebug(Handle, Low, High)    {if(!ValidateHandle(Handle, Low, High)) return(NULL);}
#else
#define ValidDebug(Handle, Low, High)	TRUE
#endif

#define GDIGLOBALLOCK(x)	GlobalLock(x)
#define GDIGLOBALUNLOCK(x)	GlobalUnlock(x)
#define GDILOCKRESOURCE(x)	LockResource(x)
#define GDIENTERCRITSEC()
#define GDIEXITCRITSEC()
#define LockDataSegment()	
#define UnlockDataSegment()	
#define farLockDataSegment()	
#define farUnlockDataSegment()	
#define GDIRequestSem()
#define GDIClearSem()

#define LOWORD(l)	((WORD)(l))
#define HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define SELECTOROF(lp)	HIWORD(lp)
#define OFFSETOF(lp)	LOWORD(lp)

/*
	endif

;*/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\gdimem.inc ===
;definitions pasted in from WINDOWS.INC for memory management call to KERNEL:
;
; Memory manager flags
;
LMEM_FIXED      =   0000h
LMEM_MOVEABLE   =   0002h
LMEM_NOCOMPACT  =   0010H
LMEM_NODISCARD  =   0020H
LMEM_ZEROINIT   =   0040h
LMEM_MODIFY     =   0080H
LMEM_DISCARDABLE=   0F00h
LHND    =    LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR    =    LMEM_FIXED+LMEM_ZEROINIT
; Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE)
LMEM_DISCARDED  =   4000H
LMEM_LOCKCOUNT  =   00FFH

NONZEROLHND     =    LMEM_MOVEABLE
NONZEROLPTR     =    LMEM_FIXED

LNOTIFY_OUTOFMEM  =  0
LNOTIFY_MOVE      =  1
LNOTIFY_DISCARD   =  2


GMEM_FIXED      =   0000h
GMEM_MOVEABLE   =   0002h
GMEM_NOCOMPACT  =   0010h
GMEM_NODISCARD  =   0020h
GMEM_ZEROINIT   =   0040h
GMEM_MODIFY     =   0080h
GMEM_DISCARDABLE=   0100h
GMEM_NOT_BANKED =   1000h
GMEM_DDESHARE   =   2000h
GMEM_SHARE	=   2000h
GMEM_NOTIFY     =   4000h
GMEM_LOWER      =   GMEM_NOT_BANKED
GHND    =    GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR    =    GMEM_FIXED+GMEM_ZEROINIT

; Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE)
GMEM_DISCARDED  =    4000h
GMEM_LOCKCOUNT  =    00FFh

; Debug fill constants

DBGFILL_ALLOC   equ     0fdh
DBGFILL_FREE    equ     0fbh
DBGFILL_BUFFER  equ     0f9h
DBGFILL_STACK   equ     0f7h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\layer.asm ===
title LAYER.ASM - Parameter validation layer

.xlist

LAYER_INCLUDE=1

include layer.inc
include gpfix.inc
;include gditype.inc
ilObjType   = 2
;include gdiobj.inc

createSeg _DATA,DATA,WORD,PUBLIC,DATA,DGROUP

.list

_GPFIX SEGMENT WORD PUBLIC 'CODE'
_GPFIX ENDS

.lall

LAYER_START

include gdi.api

LAYER_END

;LAYER_EXPAND	INIT
LAYER_EXPAND	TEXT
;LAYER_EXPAND	PALETTE
;LAYER_EXPAND	ESC
;LAYER_EXPAND	DCSTUFF
;LAYER_EXPAND	LOGMISC
;LAYER_EXPAND	FONTLOAD
;LAYER_EXPAND	FONTRES
;LAYER_EXPAND	FONTINQ
;LAYER_EXPAND	FONTSIMS
;LAYER_EXPAND	METAREC
;LAYER_EXPAND	METAPLAY
;LAYER_EXPAND	ARCDDA
;LAYER_EXPAND	OUTMAN
;LAYER_EXPAND	POLYGON
;LAYER_EXPAND	RGOUT
;LAYER_EXPAND	MISC
;LAYER_EXPAND	PIXDDA
;LAYER_EXPAND	DIBITMAP
;LAYER_EXPAND	FLOODFILL
;LAYER_EXPAND	 RECT

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\gdi16.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  GDI16.H
 *
 *  History:
 *  Created 01-Jul-1991 by John Colleran (johnc)
 *
 *  Warning!!!
 *    The same code is used to play 16 bit metafiles in WOW (16 bit code)
 *    and GDI (32 bit code)
 *
--*/

#ifdef WOW
    #define WIN16
    #define UINT    WORD
    #define HUGE_T  huge
#else
    #define WIN32
    #include "port1632.h"
    #include "firewall.h"
    #ifdef FIREWALLS
    #define DEBUG
    #endif
#endif

#define GDIENTRY    FAR  PASCAL
#define INTERNAL    NEAR PASCAL


// If this is 32 bit code append a 16 to all the exported APIs

#ifdef WIN32
    HANDLE FAR PASCAL GetMetaFile16(LPSTR);
    BOOL   FAR PASCAL PlayMetaFile16(HDC, HANDLE);
    void   FAR PASCAL PlayMetaFileRecord16(HDC, LPHANDLETABLE, LPMETARECORD, WORD);

    #define GetMetaFile 	    GetMetaFile16
    #define DeleteMetaFile	    DeleteMetaFile16
    #define PlayMetaFile	    PlayMetaFile16
    #define PlayMetaFileRecord	    PlayMetaFileRecord16
    #define IsValidMetaFile	    IsValidMetaFile16

    #define AnimatePalettePriv	    AnimatePalette
    #define DeleteObjectPriv	    DeleteObject
    #define ResizePalettePriv	    ResizePalette
    #define SetPaletteEntriesPriv   SetPaletteEntries

    #define GetViewportExt(hdc)     GetViewportExt32(hdc)
    #define GetWindowExt(hdc)	    GetWindowExt32(hdc)
    #define SetViewportExt(h,x,y)   SetViewportExt32(h,x,y)
    #define SetWindowExt(h,x,y)     SetWindowExt32(h,x,y)

    LPINT   ConvertInts( signed short * pWord, UINT cWords );
    DWORD   GetViewportExt32(HDC hdc);
    DWORD   GetWindowExt32(HDC hdc);
    DWORD   SetViewportExt32(HDC hdc, UINT x, UINT y);
    DWORD   SetWindowExt32(HDC hdc, UINT x, UINT y);

    #define CONVERTPTS(p,c)	    (LPPOINT)CONVERTINTS((signed short *)p,(c)*2)
    #define CONVERTINTS(p,c)	    ConvertInts((signed short *)p,c)

    #define FREECONVERT(p)	    LocalFree(p)

    #define PlayIntoAMetafile(a,b)  0
    #define DEFIFWIN16(a)	    0

    #pragma pack(2)
    typedef struct
    {
	WORD	    mtType;
	WORD	    mtHeaderSize;
	WORD	    mtVersion;
	WORD	    mtSize;
	WORD	    mtSize2;
	WORD	    mtNoObjects;
	DWORD	    mtMaxRecord;
	WORD	    mtNoParameters;
    } METAHEADER16;
    #define METAHEADER METAHEADER16

    typedef struct tagLOGFONT16
      {
	int	  lfHeight;
	int	  lfWidth;
	int	  lfEscapement;
	int	  lfOrientation;
	int	  lfWeight;
	BYTE	  lfItalic;
	BYTE	  lfUnderline;
	BYTE	  lfStrikeOut;
	BYTE	  lfCharSet;
	BYTE	  lfOutPrecision;
	BYTE	  lfClipPrecision;
	BYTE	  lfQuality;
	BYTE	  lfPitchAndFamily;
	BYTE	  lfFaceName[LF_FACESIZE];
      } LOGFONT16;
    typedef LOGFONT16 FAR  *LPLOGFONT16;
    #pragma pack()

    #define LOGFONT32FROM16( plf32, plf16 )			   \
    {	plf32->lfHeight 	  = plf16->lfHeight;		   \
	plf32->lfWidth		  = plf16->lfWidth;		   \
	plf32->lfEscapement	  = plf16->lfEscapement;	   \
	plf32->lfOrientation	  = plf16->lfOrientation;	   \
	plf32->lfWeight 	  = plf16->lfWeight;		   \
	plf32->lfItalic 	  = plf16->lfItalic;		   \
	plf32->lfUnderline	  = plf16->lfUnderline; 	   \
	plf32->lfStrikeOut	  = plf16->lfStrikeOut; 	   \
	plf32->lfCharSet	  = plf16->lfCharSet;		   \
	plf32->lfOutPrecision	  = plf16->lfOutPrecision;	   \
	plf32->lfClipPrecision	  = plf16->lfClipPrecision;	   \
	plf32->lfQuality	  = plf16->lfQuality;		   \
	plf32->lfPitchAndFamily   = plf16->lfPitchAndFamily;	   \
	memcpy( &plf32->lfItalic, &plf16->lfItalic, LF_FACESIZE);  \
    }

    #define ISDCVALID(hdc)	TRUE
    #define ISMETADC(hdc)	FALSE
#else
    #define CONVERTPTS(p,c)	    (LPPOINT)(p)
    #define CONVERTINTS(p,c)	    (p)
    #define FREECONVERT(p)
    #define DEFIFWIN16(a)	    a

    #define LOGFONT32FROM16( plf32, plf16 )	 {plf32 = plf16;}
    #define ISDCVALID(hdc)	IsDCValid(hdc)
    #define ISMETADC(hdc)       IsMetaDC(hdc)

    typedef struct _RGNDATAHEADER {
        DWORD   dwSize;
        DWORD   iType;
        DWORD   nCount;
    } RGNDATAHEADER, *PRGNDATAHEADER;

    typedef struct _RGNDATA {
        RGNDATAHEADER   rdh;
        char            Buffer[1];
    } RGNDATA,FAR *LPRGNDATA;

    typedef struct _RECTL {
        LONG            xLeft;
        LONG            yTop;
        LONG            xRight;
        LONG            yBottom;
    } RECTL,FAR *LPRECTL;
#endif

/*** MetaFile Internal Constants and Macros ***/

#define METAVERSION         0x0300
#define METAVERSION100      0x0100

/* Metafile constants not in Windows.h */
#define META_RESETDC        0x0149
#define META_STARTDOC       0x0150
#define META_STARTPAGE      0x0051
#define META_ENDPAGE        0x0052
#define META_ENDDOC         0x0053
#define META_ABORTDOC       0x0054
#define META_EXTFLOODFILL   0x0548

#define MAXFILECHUNK        ((unsigned)63*1024)

#define METAFILEFAILURE     1

#define METAEXITCODE        0  /* arbitrary value */

#define MEMORYMETAFILE      1
#define DISKMETAFILE        2

#define DATASIZE            100
#define HEADERSIZE          (sizeof(METAHEADER)/sizeof(WORD))

#define RECHDRSIZE          (sizeof(WORD) + sizeof(DWORD))

#define LMHtoP(handle)      (*((char * *)(handle)))

#define ID_METADC           0x444D      // "MD"
#define METADCBIT           0x1         // Set if DC is a MetaFile DC
#define MAKEMETADC(h)       (h|METADCBIT)
#define HANDLEFROMMETADC(h) (((UINT)h) & (~METADCBIT))
#define HMFFROMNPMF(h)      (LocalHandle((WORD)h)|METADCBIT)
#define NPFROMMETADC(h)     (LMHtoP((h&(~METADCBIT))))

//!!!!!! assert this
#define MAXOBJECTSIZE sizeof(LOGFONT)

/*** MetaFile Internal TypeDefs ***/

typedef BYTE near          *NPBYTE;
typedef BYTE HUGE_T        *HPBYTE;
typedef WORD HUGE_T        *HPWORD;

typedef HANDLE		   HMETAFILE;

typedef struct _METADATA { /* md */
    METAHEADER      dataHeader;
    WORD            metaDataStuff[DATASIZE];
} METADATA;
typedef METADATA       *NPMETADATA;
typedef METADATA   FAR *LPMETADATA;

typedef struct _METAFILE { /* mf */
    METAHEADER  MetaFileHeader;
    UINT        MetaFileNumber;
    DWORD       MetaFilePosition;
    OFSTRUCT    MetaFileBuffer;
    HANDLE      MetaFileRecordHandle;
} METAFILE;
typedef METAFILE         *NPMETAFILE;
typedef METAFILE  FAR    *LPMETAFILE;
typedef METAFILE  HUGE_T *HPMETAFILE;

typedef struct _METACACHE {
    HANDLE      hCache;
    HANDLE      hMF;
    WORD        wCacheSize;
    WORD        wCachePos;
} METACACHE;

typedef struct _ILOBJHEAD {
    WORD    ident;
    WORD    nextinchain;
    int     ilObjType;
    long    ilObjCount;
    HANDLE  ilObjMetaList;
} ILOBJHEAD;

typedef struct _METARECORDER {
    ILOBJHEAD       metaDCHeader;
    METAHEADER      recordHeader;
    DWORD           recFilePosition;
    OFSTRUCT        recFileBuffer;
    DWORD           sizeBuffer;
    WORD            recFileNumber;
    WORD            recFlags;
    HANDLE	    hMetaData;
    HANDLE          hObjectTable;
    HANDLE          recCurObjects[6];           // Current Selected Object
} METARECORDER;
typedef METARECORDER        *NPMETARECORDER;
typedef METARECORDER    FAR *LPMETARECORDER;

typedef METARECORD HUGE_T   *HPMETARECORD;

typedef struct _OBJECTTABLE {
    DWORD     objectIndex;
    HANDLE    objectCurHandle;
} OBJECTTABLE;
typedef OBJECTTABLE     *NPOBJECTTABLE;
typedef OBJECTTABLE FAR *LPOBJECTTABLE;

typedef struct _OBJMETALIST {
    WORD        omlCount;
    HANDLE      omlMetaDC[1];
} OBJMETALIST;

typedef struct _WIN2OBJHEAD {
    WORD    nextinchain;
    int     w2ObjType;
    long    w2ObjCount;
} WIN2OBJHEAD;
typedef WIN2OBJHEAD      *NPWIN2OBJHEAD;
typedef WIN2OBJHEAD  FAR *LPWIN2OBJHEAD;

typedef struct _SCAN  {
    WORD    scnPntCnt;                      // Scan point count
    WORD    scnPntTop;                      // Top of scan
    WORD    scnPntBottom;                   // Bottom of scan
    WORD    scnPntsX[2];                    // Start of points in scan
    WORD    scnPtCntToo;                    // Point count-- to allow UP travel
} SCAN;
typedef SCAN     *NPSCAN;
typedef SCAN FAR *LPSCAN;

typedef struct _WIN3REGION {
    WORD    nextInChain;                    // Not used should be zero
    WORD    ObjType;                        // Must always be 6 (Windows OBJ_RGN)
    DWORD   ObjCount;                       // Not used
    WORD    cbRegion;                       // size of following region struct
    WORD    cScans;
    WORD    maxScan;
    RECT    rcBounding;
    SCAN    aScans[1];
} WIN3REGION;
typedef WIN3REGION     *NPWIN3REGION;
typedef WIN3REGION FAR *LPWIN3REGION;

typedef struct _EXTTEXTDATA {
    int         xPos;
    int         yPos;
    WORD        cch;
    RECT        rcClip;
    LPSTR       lpString;
    LPWORD      lpWidths;
}EXTTEXTDATA;
typedef EXTTEXTDATA      *NPEXTTEXTDATA;
typedef EXTTEXTDATA  FAR *LPEXTTEXTDATA;

// These are from wingdi.h
#define OBJ_PEN             1
#define OBJ_BRUSH           2
#define OBJ_DC              3
#define OBJ_METADC          4
#define OBJ_PALETTE         5
#define OBJ_FONT            6
#define OBJ_BITMAP          7
#define OBJ_RGN             8
#define OBJ_METAFILE        9
#define OBJ_MEMDC          10

#define MIN_OBJ         OBJ_PEN
#define MAX_OBJ         OBJ_MEMDC


// These Function have no DC; so these function allow you to call them directly
#ifdef WIN16
HANDLE	     GDIENTRY GetCurrentObject(HDC hdc, WORD wObjType);
DWORD        GDIENTRY GetRegionData(HRGN, DWORD, LPRGNDATA);
void         GDIENTRY AnimatePalettePriv(HPALETTE, WORD, WORD, LPPALETTEENTRY);
BOOL         GDIENTRY DeleteObjectPriv(HANDLE);
BOOL         GDIENTRY ResizePalettePriv(HPALETTE, WORD);
WORD         GDIENTRY SetPaletteEntriesPriv(HPALETTE,WORD,WORD,LPPALETTEENTRY);
#endif // WIN16

BOOL         GDIENTRY GdiFlush(VOID);
DWORD        GDIENTRY GetObjectType(HANDLE h);
BOOL         GDIENTRY IsValidMetaFile(HANDLE hMetaData);

// Internal Function Declarations
VOID         INTERNAL AddToHandleTable(LPHANDLETABLE lpHandleTable, HANDLE hObject, WORD noObjs);
HANDLE       INTERNAL AllocBuffer(LPWORD iBufferSize);
DWORD        INTERNAL BigRead(UINT fileNumber, LPSTR lpRecord, DWORD dwSizeRec);
VOID         INTERNAL CallMetaFunction(HDC, FARPROC, WORD, LPWORD );
BOOL         INTERNAL GDIsSelectPalette(HDC hdc, HPALETTE pal, BOOL f);
LPMETARECORD INTERNAL GetEvent(LPMETAFILE pmf,HPMETARECORD pmr,BOOL bFree);
int          INTERNAL GetObjectAndType(HANDLE hObj, LPSTR lpObjectBuf);
HANDLE       INTERNAL GetPMetaFile(HDC hdc);
BOOL         INTERNAL InitializeGdi(VOID);
BOOL         INTERNAL IsDIBBlackAndWhite(LPBITMAPINFOHEADER lpDIBInfo);
BOOL         INTERNAL IsDCValid(HDC hdc);
BOOL         INTERNAL IsMetaDC(HDC hdc);
BOOL         INTERNAL IsObjectStock(HANDLE hObj);
BOOL         INTERNAL LPtoSP(HDC,LPPOINT,int);
BOOL	     INTERNAL PlayIntoAMetafile(LPMETARECORD lpMR, HDC hdcDest);
int          INTERNAL RecordObject(HANDLE hMF, WORD magic, WORD count, LPWORD lpParm);
BOOL         INTERNAL RecordParms(HANDLE hDC, WORD magic, DWORD count, LPWORD lpParm);
BOOL         INTERNAL RecordOther(HANDLE hMF, WORD magic, WORD count, LPWORD lpParm);
BOOL         INTERNAL Valid( HANDLE hnd, int l, int h);


/****************************************************************************

    debugging support

****************************************************************************/

// Put a wrapper around 16 bit memory Allocation to help track down bugs
#ifdef DEBUG
#ifndef WIN32
PSTR	INTERNAL _LocalLock(HANDLE h );
BOOL	INTERNAL _LocalUnlock(HANDLE h );
HANDLE	INTERNAL _LocalAlloc(WORD w, WORD w2);
LPSTR	INTERNAL _GlobalLock(HANDLE h );
BOOL	INTERNAL _GlobalUnlock(HANDLE h );
HANDLE	INTERNAL _GlobalAlloc(WORD w, DWORD dw );

#define LocalLock(h)	    _LocalLock(h)
#define GlobalLock(h)	    _GlobalLock(h)
#define LocalUnlock(h)	    _LocalUnlock(h)
#define GlobalUnlock(h)     _GlobalUnlock(h)
#define LocalAlloc(w, w2 )  _LocalAlloc(w, w2)
#define GlobalAlloc(w, dw ) _GlobalAlloc(w, dw)
#endif
#endif


#ifdef DEBUG
    extern void dDbgOut(int iLevel, LPSTR lpszFormat, ...);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

#ifdef WIN32
    #define dprintf
    #define GdiLogFunc(str)
    #define GdiLogFunc2(str)
    #define GdiLogFunc3(str)
    #define ASSERTGDIW(exp,str,w)   ASSERTGDI(exp,str)
#else
    #define dprintf		    dDbgOut
    #define GdiLogFunc(str)	    {dDbgOut(3, str );}
    #define GdiLogFunc2(str)	    {dDbgOut(6, str );}
    #define GdiLogFunc3(str)	    {dDbgOut(7, str );}
    #define ASSERTGDI(exp,str) \
        {((exp) ? (void)0 : dDbgAssert(str, __FILE__, __LINE__));}
    #define ASSERTGDIW(exp,str,w)			\
        { char buf[256];                                \
         ((exp) ? 0 :                                   \
           ( wsprintf(buf, (LPSTR)str, (WORD)w),        \
             dDbgAssert(buf, __FILE__, __LINE__),0));   \
        }                                               \

#endif //WIN32
#else  // !DEBUG
#ifdef i386
    #define dprintf /##/
#else
    #define dprintf
#endif

    #define GdiLogFunc(str)
    #define GdiLogFunc2(str)
    #define GdiLogFunc3(str)
    #define ASSERTGDI(exp,str)
    #define ASSERTGDIW(exp, str, w)

#endif // else DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\muldiv.asm ===
Title   Muldiv - (A*B)/C With Correct Rounding
        %out    MulDiv
	page	,132
;----------------------------Module-Header------------------------------;
; Module Name: muldiv.asm
;
; (w * Numer) / Denom with correct rounding.
; 
; Created:
; Author:
;
; Copyright (c) 1985, 1986, 1987  Microsoft Corporation
;
; MulDiv(w, Numer, Denom) returns (w * Numer) / Denom rounded to the nearest
; integer.  A check is made so that division by zero is not attempted.
;-----------------------------------------------------------------------;


        .xlist
        include cmacros.inc
;        include gditype.inc
        .list


sBegin  code
assumes cs,code

;--------------------------Public-Routine-------------------------------;
; short FAR PASCAL MulDiv(short, short, short)
; short w;
; short Numer;
; short Denom;
;
; (w * Numer)/ Denom with correct rounding.
;
; Returns: AX = result.
;	   DX = 1 if no overflow.
;	   DX = 0 if overflow.
;
; Preserves: BX,CX
; Doesn't lose: SI,DI,ES,DS
;
; Warnings:
;
; Effects:
;
; History:
;  Mon 22-Dec-1986 17:08:55	-by-	Kent Settle	    [kentse]
; Added headers and comments.
;-----------------------------------------------------------------------;

cProc MulDiv,<FAR,PUBLIC>,<bx,cx>

        parmW  <w, Numer, Denom>

cBegin MulDiv

    mov     bx,Denom    ; get the demoninator
    mov     cx,bx	; CX holds the final sign
    or      bx,bx       ; ensure the denominator is positive
    jns     md1
    neg     bx

md1:
    mov     ax,w        ; get the word we are multiplying
    xor     cx,ax	; make CX reflect any sign change
    or      ax,ax       ; ensure this word is positive
    jns     md2
    neg     ax

md2:
    mov     dx,Numer    ; get the numerator
    xor     cx,dx	; make CX reflect any sign change
    or      dx,dx       ; ensure the numerator is positive
    jns     md3
    neg     dx

md3:
    mul     dx          ; multiply
    mov     cl,bl       ; get half of the demoninator to adjust for rounding
    sar     bx,1
    add     ax,bx       ; adjust for possible rounding error
    adc     dx,0        ; this is really a long addition
    sal     bx,1        ; restore the demoninator
    or      bl,cl
    cmp     dx,bx       ; check for overflow
    jae     md5         ; (ae handles /0 case)
    div     bx          ; divide
    or      ax,ax       ; If sign is set, then overflow occured
    js      md5         ; Overflow.
    or      cx,cx       ; put the sign on the result
    jns     md4
    neg     ax
md4:
   mov	    dx,1	; indicate no overflow.
md6:

cEnd MulDiv


md5:
    xor     dx,dx	; indicate overflow.
    mov     ax,7FFFh    ; return the largest integer
    or      cx,cx       ; with the correct sign
    jns     md6
    not     ax
    jmp     md6

sEnd    code
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\meta.c ===
/****************************** Module Header ******************************\
* Module Name: Meta.c
*
* This file contains the routines for playing the GDI metafile.  Most of these
* routines are adopted from windows gdi code. Most of the code is from
* win3.0 except for the GetEvent code which is taken from win2.1
*
* Created: 11-Oct-1989
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
*
* Public Functions:
*   PlayMetaFile
*   PlayMetaFileRecord
*   GetMetaFile
*   DeleteMetaFile
* Private Functions:
*   GetEvent
*   IsDIBBlackAndWhite
*
* History:
*  02-Jul-1991 -by-  John Colleran [johnc]
* Combined From Win 3.1 and WLO 1.0 sources
\***************************************************************************/

#include <windows.h>
#include <string.h>
#ifdef WIN32
#include "firewall.h"
#endif
#include "gdi16.h"

HDC	    hScreenDC = 0;
METACACHE   MetaCache = { 0, 0, 0, 0 };

UINT    INTERNAL GetFileNumber (LPMETAFILE lpMF);
HANDLE  INTERNAL CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo);
WORD    INTERNAL GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo);

#define MAX_META_DISPATCH  0x48
FARPROC alpfnMetaFunc[MAX_META_DISPATCH+1] =
/* 00 */ {(FARPROC)ScaleWindowExt,
/* 01 */  (FARPROC)SetBkColor,
/* 02 */  (FARPROC)SetBkMode,
/* 03 */  (FARPROC)SetMapMode,
/* 04 */  (FARPROC)SetROP2,
/* 05 */  DEFIFWIN16((FARPROC)SetRelAbs),
/* 06 */  (FARPROC)SetPolyFillMode,
/* 07 */  (FARPROC)SetStretchBltMode,
/* 08 */  (FARPROC)SetTextCharacterExtra,
/* 09 */  (FARPROC)SetTextColor,
/* 0A */  (FARPROC)SetTextJustification,
/* 0B */  (FARPROC)SetWindowOrg,
/* 0C */  (FARPROC)SetWindowExt,
/* 0D */  (FARPROC)SetViewportOrg,
/* 0E */  (FARPROC)SetViewportExt,
/* 0F */  (FARPROC)OffsetWindowOrg,
/* 10 */  0,
/* 11 */  DEFIFWIN16((FARPROC)OffsetViewportOrg),
/* 12 */  DEFIFWIN16((FARPROC)ScaleViewportExt),
/* 13 */  (FARPROC)LineTo,
/* 14 */  DEFIFWIN16((FARPROC)MoveTo),
/* 15 */  (FARPROC)ExcludeClipRect,
/* 16 */  (FARPROC)IntersectClipRect,
/* 17 */  (FARPROC)Arc,
/* 18 */  (FARPROC)Ellipse,
/* 19 */  (FARPROC)FloodFill,
/* 1A */  (FARPROC)Pie,
/* 1B */  (FARPROC)Rectangle,
/* 1C */  (FARPROC)RoundRect,
/* 1D */  (FARPROC)PatBlt,
/* 1E */  (FARPROC)SaveDC,
/* 1F */  (FARPROC)SetPixel,
/* 20 */  (FARPROC)OffsetClipRgn,
/* 21 */  0,	// TextOut,
/* 22 */  0,	// BitBlt,
/* 23 */  0,	// StretchBlt.
/* 24 */  0,	// Polygon,
/* 25 */  0,	// Polyline,
/* 26 */  0,	// Escape,
/* 27 */  (FARPROC)RestoreDC,
/* 28 */  0,	// FillRegion,
/* 29 */  0,	// FrameRegion,
/* 2A */  0,	// InvertRegion,
/* 2B */  0,	// PaintRegion,
/* 2C */  (FARPROC)SelectClipRgn,
/* 2D */  0,	// SelectObject,
/* 2E */  (FARPROC)SetTextAlign,
/* 2F */  0,	// DrawText,
/* 30 */  (FARPROC)Chord,
/* 31 */  (FARPROC)SetMapperFlags,
/* 32 */  0,	// ExtTextOut,
/* 33 */  0,	// SetDibsToDevice,
/* 34 */  0,	// SelectPalette,
/* 35 */  0,	// RealizePalette,
/* 36 */  0,	// AnimatePalette,
/* 37 */  0,	// SetPaletteEntries,
/* 38 */  0,	// PolyPolygon,
/* 39 */  0,	// ResizePalette,
/* 3A */  0,
/* 3B */  0,
/* 3C */  0,
/* 3D */  0,
/* 3E */  0,
/* 3F */  0,
/* 40 */  0,	// DIBBitblt,
/* 41 */  0,	// DIBStretchBlt,
/* 42 */  0,	// DIBCreatePatternBrush,
/* 43 */  0,	// StretchDIB,
/* 44 */  0,
/* 45 */  0,
/* 46 */  0,
/* 47 */  0,
/* 48 */  (FARPROC)ExtFloodFill };


#if 0 // this is going to gdi.dll

/***************************** Public Function ****************************\
* BOOL  APIENTRY PlayMetaFile(hdc, hmf)
* HDC           hDC;
* HMETAFILE     hMF;
*
* Play a windows metafile.
*
* History:
*   Tue 27-Mar-1990 11:11:45  -by-  Paul Klingler [paulk]
* Ported from Windows
\***************************************************************************/

BOOL	GDIENTRY PlayMetaFile(HDC hdc, HMETAFILE hmf)
{
    WORD            i;
    WORD            noObjs;
    BOOL            bPrint=FALSE;
    LPMETAFILE      lpmf;
    int 	    oldMapMode = -1;
    LPMETARECORD    lpmr = NULL;
    LPHANDLETABLE   pht = NULL;
    HANDLE          hht = NULL;
#ifndef WIN32
    HFONT           hLFont;
    HBRUSH          hLBrush;
    HPALETTE        hLPal;
    HPEN            hLPen;
    HRGN            hClipRgn;
    HRGN            hRegion;
    DWORD           oldWndExt;
    DWORD           oldVprtExt;
#endif //WIN32

    GdiLogFunc("PlayMetaFile");

    if(!IsValidMetaFile(hmf))
        goto exitPlayMetaFile;

    if(lpmf = (LPMETAFILE)GlobalLock(hmf))
        {
        if((noObjs = lpmf->MetaFileHeader.mtNoObjects) > 0)
            {
            if(!(hht = GlobalAlloc(GMEM_ZEROINIT|GMEM_MOVEABLE,
                                   (sizeof(HANDLE) * lpmf->MetaFileHeader.mtNoObjects) + sizeof(WORD  ))))
                {
                goto exitPlayMetaFile10;
                }
            pht = (LPHANDLETABLE)GlobalLock(hht);
            }
#ifdef CR1
IMP: Optmizations playing into another metafile. Look at the win3.0
IMP: code
#endif

// !!!!! what if this is a metafile DC
#ifndef WIN32
        /* save the old objects so we can put them back */
	hLPen	 = GetCurrentObject( hdc, OBJ_PEN );
	hLBrush  = GetCurrentObject( hdc, OBJ_BRUSH);
	hLFont	 = GetCurrentObject( hdc, OBJ_FONT);
	hClipRgn = GetCurrentObject( hdc, OBJ_RGN);
	hLPal	 = GetCurrentObject( hdc, OBJ_PALETTE);

	if(hRegion = GetCurrentObject( hdc, OBJ_RGN))
            {
            if(hClipRgn = CreateRectRgn(0,0,0,0))
                CombineRgn(hClipRgn,hRegion,hRegion,RGN_COPY);
            }
#endif // WIN32

        // we should really remove this abort proc thing.

        while(lpmr = GetEvent(lpmf,lpmr,FALSE))
            {
#if 0  //!!!!!
            if(GET_pAbortProc(pdc))
#else
            if( 0 )
#endif //!!!!!
                {
//!!!!!         if((bPrint = (*(pdc->pAbortProc))(hdc,0)) == FALSE)
                    {
                    GetEvent(lpmf,lpmr,TRUE);
                    RestoreDC(hdc,0);
                    goto exitPlayMetaFile20;
                    }
                }
            PlayMetaFileRecord(hdc,pht,lpmr,noObjs);
            }

        bPrint = TRUE;
exitPlayMetaFile20:
        /* if we fail restoring an object, we need to select some
           default object so that we can DeleteObject any Metafile-
           selected objects */

#ifndef WIN32
        if(!SelectObject(hdc,hLPen))
            SelectObject(hdc,GetStockObject(BLACK_PEN));
        if(!SelectObject(hdc,hLBrush))
            SelectObject(hdc,GetStockObject(BLACK_BRUSH));
	if(!SelectPalette(hdc, GetCurrentObject( hdc, OBJ_PALETTE), FALSE))
            SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);

        if(!SelectObject(hdc,hLFont))
            {
            /* if we cannot select the original font back in, we
            ** select the system font.  this will allow us to delete
            ** the metafile font selected.  to insure that the system
            ** font gets selected, we reset the DC's transform to
            ** default.  after the selection, we restore this stuff
            */
            oldVprtExt = GetViewportExt(hdc);
            oldWndExt  = GetWindowExt(hdc);
            oldMapMode = SetMapMode(hdc,MM_TEXT);

            SelectObject(hdc,GetStockObject(SYSTEM_FONT));

            SetMapMode(hdc,oldMapMode);
            SetWindowExt(hdc,LOWORD  (oldWndExt),HIWORD  (oldWndExt));
            SetViewportExt(hdc,LOWORD  (oldVprtExt),HIWORD  (oldVprtExt));
            }

        if(hClipRgn)
            {
            SelectObject(hdc,hClipRgn);
            DeleteObject(hClipRgn);
            }
#endif // WIN32

        for(i = 0; i < lpmf->MetaFileHeader.mtNoObjects; ++i)
            {
            if(pht->objectHandle[i])
                DeleteObject(pht->objectHandle[i]);
            }

#ifndef WIN32
        /* if we fiddled with the map mode because we could not
        ** restore the original font, then maybe we can restore the
        ** font now */
        if(oldMapMode > 0)
            SelectObject(hdc,hLFont);
#endif // WIN32

        if(hht)
            {
            GlobalUnlock(hht);
            GlobalFree(hht);
            }

exitPlayMetaFile10:
        GlobalUnlock(hmf);
        }

exitPlayMetaFile:
    return(bPrint);
}
#endif // this is going to gdi.dll

/***************************** Internal Function **************************\
* BOOL NEAR PASCAL IsDIBBlackAndWhite
*
* Check to see if this DIB is a black and white DIB (and should be
* converted into a mono bitmap as opposed to a color bitmap).
*
* Returns: TRUE         it is a B&W bitmap
*          FALSE        this is for color
*
* Effects: ?
*
* Warnings: ?
*
* History:
\***************************************************************************/

BOOL INTERNAL IsDIBBlackAndWhite(LPBITMAPINFOHEADER lpDIBInfo)
{
    LPDWORD lpRGB;

    GdiLogFunc3( "  IsDIBBlackAndWhite");

    /* pointer color table */
    lpRGB = (LPDWORD)((LPBITMAPINFO)lpDIBInfo)->bmiColors;

    if ((lpDIBInfo->biBitCount == 1 && lpDIBInfo->biPlanes == 1)
                && (lpRGB[0] == (DWORD)0)
                && (lpRGB[1] == (DWORD)0xFFFFFF))
        return(TRUE);
    else
        return(FALSE);
}


/***************************** Internal Function **************************\
* BigRead
*
* allows reads of greater than 64K
*
* Returns: Number of bytes read
*
\***************************************************************************/

DWORD INTERNAL BigRead(UINT fileNumber, LPSTR lpRecord, DWORD dwSizeRec)
{
    DWORD   dwRead = dwSizeRec;
    HPBYTE  hpStuff;

    GdiLogFunc2( "  BigRead");

    hpStuff = (HPBYTE)lpRecord;

    while (dwRead > MAXFILECHUNK)
        {
        if (_lread(fileNumber, (LPSTR)hpStuff, MAXFILECHUNK) != MAXFILECHUNK)
                return(0);

        dwRead -= MAXFILECHUNK;
        hpStuff += MAXFILECHUNK;
        }

    if (_lread(fileNumber, (LPSTR)hpStuff, (UINT)dwRead) != (UINT)dwRead)
        return(0);

    return(dwSizeRec);
}


/***************************** Internal Function **************************\
* UseStretchDIBits
*
* set this directly to the device using StretchDIBits.
* if DIB is black&white, don't do this.
*
* Returns:
*               TRUE --- operation successful
*               FALSE -- decided not to use StretchDIBits
*
* Effects: ?
*
* Warnings: ?
*
* History:
\***************************************************************************/

BOOL INTERNAL UseStretchDIB(HDC hDC, WORD magic, LPMETARECORD lpMR)
{
    LPBITMAPINFOHEADER lpDIBInfo;
    int sExtX, sExtY;
    int sSrcX, sSrcY;
    int DstX, DstY, DstXE, DstYE;

    if (magic == META_DIBBITBLT)
        {
        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMR->rdParm[8];

        DstX = lpMR->rdParm[7];
        DstY = lpMR->rdParm[6];

        sSrcX = lpMR->rdParm[3];
        sSrcY = lpMR->rdParm[2];
        DstXE = sExtX = lpMR->rdParm[5];
        DstYE = sExtY = lpMR->rdParm[4];
        }
    else
        {
        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMR->rdParm[10];

        DstX = lpMR->rdParm[9];
        DstY = lpMR->rdParm[8];
        DstXE = lpMR->rdParm[7];
        DstYE = lpMR->rdParm[6];

        sSrcX = lpMR->rdParm[5];
        sSrcY = lpMR->rdParm[4];
        sExtX = lpMR->rdParm[3];
        sExtY = lpMR->rdParm[2];
        }

    /* if DIB is black&white, we don't really want to do this */
    if (IsDIBBlackAndWhite(lpDIBInfo))
        return(FALSE);

    StretchDIBits(hDC, DstX, DstY, DstXE, DstYE,
                        sSrcX, sSrcY, sExtX, sExtY,
			(LPBYTE)((LPSTR)lpDIBInfo + lpDIBInfo->biSize
                                + GetSizeOfColorTable(lpDIBInfo)),
                        (LPBITMAPINFO)lpDIBInfo, DIB_RGB_COLORS,
                        (MAKELONG(lpMR->rdParm[1], lpMR->rdParm[0])));
    return(TRUE);
}

/***************************** Internal Function **************************\
* GetEvent
*
* This routine will now open a disk metafile in READ_ONLY mode. This will
* allow us to play read-only metafiles or to share such file.
*
* [amitc: 06/19/91]
\***************************************************************************/

LPMETARECORD INTERNAL GetEvent(LPMETAFILE lpMF, HPMETARECORD lpMR, BOOL bFree)
// BOOL        bFree;              /* non-zero ==> done with metafile */
{
    int         fileNumber = 0;
    WORD        i;
    LPWORD      lpCache = NULL;
    LPWORD      lpMRbuf;
    HANDLE      hMF;
    DWORD       rdSize;

    GdiLogFunc2( "  GetEvent");

#ifdef WIN32
    hMF = GlobalHandle(lpMF);
#else
    hMF = LOWORD(GlobalHandle(HIWORD((DWORD)(lpMF))));
#endif

    ASSERTGDI( hMF != (HANDLE)NULL, "GetEvent: Global Handle failed");

    if (lpMF->MetaFileHeader.mtType == MEMORYMETAFILE)
        {
        /* Are we at the end of the metafile */
        if(lpMR && lpMR->rdFunction == 0)
            return((LPMETARECORD)0);

        /* done with metafile, so free up the temp selector */
        else if (bFree)
            {
            if (lpMR)
		#ifndef WIN32
                FreeSelector(HIWORD(lpMR));
		#endif
            return((LPMETARECORD)0);
            }
        else
            {
            /* if we don't already have a selector, get one */
            if (lpMR == NULL)
		{
		#ifdef WIN32
		lpMR = (HPMETARECORD)((LPMETADATA)lpMF)->metaDataStuff;
	    //	lpMR = (LPMETARECORD)GlobalLock(lpMF->hMetaData);
                #else
                lpMR = (LPMETARECORD)MAKELP(AllocSelector(HIWORD((DWORD)&lpMF->MetaFileNumber)),LOWORD((DWORD)&lpMF->MetaFileNumber));
                #endif
                }
            else
                lpMR = (LPMETARECORD) (((HPWORD)lpMR)+lpMR->rdSize);

            /* end of the metafile.  free up the selector we were using */
            if (lpMR->rdFunction == 0)
                {
		#ifndef WIN32
		FreeSelector(HIWORD(lpMR));
		#endif
                return((LPMETARECORD)0);
                }
            }
        return(lpMR);
        }
    else if (lpMF->MetaFileHeader.mtType == DISKMETAFILE)
        {
        if (bFree)
            goto errGetEvent;   /* never TRUE on the first call to GetEvent */

        if (lpMR == NULL)
            {
            if ((fileNumber = OpenFile((LPSTR)lpMF->MetaFileBuffer.szPathName, (LPOFSTRUCT)&(lpMF->MetaFileBuffer), (WORD)OF_PROMPT|OF_REOPEN|OF_READ)) != -1)
                {
                if (lpMF->MetaFileRecordHandle = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,(DWORD)(lpMF->MetaFileHeader.mtMaxRecord * sizeof(WORD))))
                    {
                    lpMR = (LPMETARECORD)GlobalLock(lpMF->MetaFileRecordHandle);
                    lpMF->MetaFilePosition = _lread(lpMF->MetaFileNumber = fileNumber, (LPSTR)&lpMF->MetaFileHeader, sizeof(METAHEADER));

                    // Check for an Aldus header
                    if (*((LPDWORD)&(lpMF->MetaFileHeader)) == 0x9AC6CDD7)
                        {
                        _llseek( fileNumber, 22, 0);
                        lpMF->MetaFilePosition = 22 + _lread(fileNumber,(LPSTR)(&(lpMF->MetaFileHeader)),sizeof(METAHEADER));
                        }

                    lpMF->MetaFileHeader.mtType = DISKMETAFILE;

                    if (!MetaCache.hCache)
                        {
                        MetaCache.hCache = AllocBuffer(&MetaCache.wCacheSize);
                        MetaCache.wCacheSize >>= 1;
                        MetaCache.hMF = hMF;

                        /* force cache fill on first access */
                        MetaCache.wCachePos = MetaCache.wCacheSize;
                        }

                    if (!(lpMF->MetaFileBuffer.fFixedDisk))
                        {
                        _lclose(fileNumber);

                        /* need to update the following for floppy files -- amitc */
                        fileNumber = 0 ;
                        lpMF->MetaFileNumber = 0 ;
                        }
                    }
                }
            else
                return((LPMETARECORD)0);
            }

        /* update fileNumber, this is so that floopy based files can be closed
           and not left open -- amitc */

        fileNumber = lpMF->MetaFileNumber ;

        if (lpMR)
            {
            if (MetaCache.hMF == hMF)
                {

                lpCache = (LPWORD) GlobalLock(MetaCache.hCache);
                lpMRbuf = (LPWORD) lpMR;

                // Make sure we can read the size and function fields
                if (MetaCache.wCachePos >= (WORD)(MetaCache.wCacheSize - 2))
                    {
                    WORD   cwCopy;

                    if (!fileNumber)
                        if ((fileNumber = GetFileNumber(lpMF)) == -1)
                            goto errGetEvent;

                    // We need to fill up the cache but save any data already
                    // in the cache
                    cwCopy = MetaCache.wCacheSize - MetaCache.wCachePos;
                    for (i = 0; i < cwCopy; i++)
                        {
                        lpCache[i] = lpCache[MetaCache.wCacheSize-(cwCopy-i)];
                        }
                    lpMF->MetaFilePosition += _lread(fileNumber,
                                                (LPSTR) (lpCache + cwCopy),
                                                (MetaCache.wCacheSize-cwCopy) << 1);
                    MetaCache.wCachePos = 0;
                    }

                lpCache += MetaCache.wCachePos;
                rdSize = ((LPMETARECORD)lpCache)->rdSize;

                /* Check for end */
                if (!((LPMETARECORD)lpCache)->rdFunction)
                    goto errGetEvent;

                // Make sure we can read the rest of the metafile record
                if (rdSize + MetaCache.wCachePos > MetaCache.wCacheSize)
                    {
                    if (!fileNumber)
                        if ((fileNumber = GetFileNumber(lpMF))
                                    == -1)
                                    goto errGetEvent;

                    for (i=MetaCache.wCachePos; i < MetaCache.wCacheSize; ++i)
                         *lpMRbuf++ = *lpCache++;

                    lpMF->MetaFilePosition +=
                    BigRead(fileNumber, (LPSTR) lpMRbuf,
                                    (DWORD)(rdSize
                                    + (DWORD)MetaCache.wCachePos
                                    - (DWORD)MetaCache.wCacheSize) << 1);

                    // Mark the cache as depleted because we just read
                    // directly into the metafile record rather than the cache
                    MetaCache.wCachePos = MetaCache.wCacheSize;
                    }
                else
                    {
		    ASSERTGDI( HIWORD(rdSize) == 0, "Huge rdsize");
                    for (i = 0; i < LOWORD(rdSize); ++i)
                        *lpMRbuf++ = *lpCache++;

		    MetaCache.wCachePos += LOWORD(rdSize);
                    }

                GlobalUnlock(MetaCache.hCache);

                return lpMR;
                }

            if ((fileNumber = GetFileNumber(lpMF)) == -1)
                goto errGetEvent;

            lpMF->MetaFilePosition += _lread(fileNumber, (LPSTR)&lpMR->rdSize, sizeof(DWORD));
            lpMF->MetaFilePosition += BigRead(fileNumber, (LPSTR)&lpMR->rdFunction, (DWORD)(lpMR->rdSize * sizeof(WORD)) - sizeof(DWORD));
            if (!(lpMF->MetaFileBuffer.fFixedDisk))
                {
                _lclose(fileNumber);
                lpMF->MetaFileNumber = 0 ;
                fileNumber = 0 ;
                }

            if (lpMR->rdFunction == 0)
                {
errGetEvent:;

                if (lpMF->MetaFileBuffer.fFixedDisk || fileNumber)
                    _lclose(lpMF->MetaFileNumber);
                GlobalUnlock(lpMF->MetaFileRecordHandle);
                GlobalFree(lpMF->MetaFileRecordHandle);
                lpMF->MetaFileNumber = 0;

                if (MetaCache.hMF == hMF)
                    {
                    if (lpCache)
                            GlobalUnlock(MetaCache.hCache);
                    GlobalFree(MetaCache.hCache);
                    MetaCache.hCache = MetaCache.hMF = 0;
                    }

                return((LPMETARECORD)0);
            }
        }
        return(lpMR);

    }

    return((LPMETARECORD)0);
}


/***************************** Internal Function **************************\
* void GDIENTRY PlayMetaFileRecord
*
* Plays a metafile record by executing the GDI function call contained
* withing the metafile record
*
* Effects:
*
\***************************************************************************/
#if 0 // this is going to gdi.dll

void
GDIENTRY PlayMetaFileRecord(
    HDC             hdc,
    LPHANDLETABLE   lpHandleTable,
    LPMETARECORD    lpMR,
    WORD            noObjs
    )

{
    WORD    magic;
    HANDLE  hObject;
    HANDLE  hOldObject;
    HBRUSH  hBrush;
    HRGN    hRgn;
    HANDLE  hPal;
    BOOL    bExtraSel = FALSE;

    dprintf( 3,"  PlayMetaFileRecord 0x%lX", lpMR);

    if (!ISDCVALID(hdc))
        return;

    magic = lpMR->rdFunction;

    /* being safe, make sure that the lp will give us full access to
    ** the record header without overstepping a segment boundary.
    */
    #ifndef WIN32
    if ((unsigned)(LOWORD((DWORD)lpMR)) > 0x7000)
        {
        lpMR = (LPMETARECORD)MAKELP(AllocSelector(HIWORD((DWORD)lpMR)),LOWORD((DWORD)lpMR));
        bExtraSel = TRUE;
        }
    #endif // WIN32

    switch (magic & 255)
        {
        case (META_BITBLT & 255):
        case (META_STRETCHBLT & 255):
            {
            HDC         hSDC;
            HANDLE      hBitmap;
            LPBITMAP    lpBitmap;
            int         delta = 0;

            /* if playing into another Metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
                goto errPlayMetaFileRecord20;

            if ((lpMR->rdSize - 3) == (magic >> 8))
                {
                hSDC = hdc;
                delta = 1;
                }
            else
                {
                if (hSDC = CreateCompatibleDC(hdc))
                    {
                    if (magic == META_BITBLT)
                        lpBitmap = (LPBITMAP)&lpMR->rdParm[8];
                    else
                        lpBitmap = (LPBITMAP)&lpMR->rdParm[10];

                    //!!!!! ALERT DWORD align on NT
                    if (hBitmap  = CreateBitmap(lpBitmap->bmWidth,
						lpBitmap->bmHeight,
						lpBitmap->bmPlanes,
						lpBitmap->bmBitsPixel,
						(LPBYTE)&lpBitmap->bmBits))
                        hOldObject = SelectObject(hSDC, hBitmap);
                    else
                        goto errPlayMetaFileRecord10;
                    }
                else
                    goto errPlayMetaFileRecord20;
                }

            if (hSDC)
                {
                if (magic == META_BITBLT)
                    BitBlt(hdc, lpMR->rdParm[7 + delta],
                                lpMR->rdParm[6 + delta],
                                lpMR->rdParm[5 + delta],
                                lpMR->rdParm[4 + delta],
                                hSDC,
                                lpMR->rdParm[3],
                                lpMR->rdParm[2],
                                MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));
                else
                    StretchBlt(hdc, lpMR->rdParm[9 + delta],
                                    lpMR->rdParm[8 + delta],
                                    lpMR->rdParm[7 + delta],
                                    lpMR->rdParm[6 + delta],
                                    hSDC,
                                    lpMR->rdParm[5],
                                    lpMR->rdParm[4],
                                    lpMR->rdParm[3],
                                    lpMR->rdParm[2],
                                    MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));
                }
            if (hSDC != hdc)
                {
                if (SelectObject(hSDC, hOldObject))
                    DeleteObject(hBitmap);
errPlayMetaFileRecord10:;
                    DeleteDC(hSDC);
errPlayMetaFileRecord20:;
                }
            }
            break;

        case (META_DIBBITBLT & 255):
        case (META_DIBSTRETCHBLT & 255):
            {
                HDC         hSDC;
                HANDLE      hBitmap;
                LPBITMAPINFOHEADER lpDIBInfo ;
                int         delta = 0;
                HANDLE      hOldPal;

                /* if playing into another metafile, do direct copy */
                if (PlayIntoAMetafile(lpMR, hdc))
                    goto errPlayMetaFileRecord40;

                if ((lpMR->rdSize - 3) == (magic >> 8))
                    {
                    hSDC = hdc;
                    delta = 1;
                    }
                else
                    {
                    if( (magic & 255) == (META_DIBSTRETCHBLT & 255) )
                        if (UseStretchDIB(hdc, magic, lpMR))
                            goto errPlayMetaFileRecord40;

                    if (hSDC = CreateCompatibleDC(hdc))
                        {
                        /* set up the memDC to have the same palette */
			hOldPal = SelectPalette(hSDC, GetCurrentObject(hdc,OBJ_PALETTE), TRUE);

                        if (magic == META_DIBBITBLT)
                            lpDIBInfo = (LPBITMAPINFOHEADER)&lpMR->rdParm[8];
                        else
                            lpDIBInfo = (LPBITMAPINFOHEADER)&lpMR->rdParm[10];

                        /* now create the bitmap for the MemDC and fill in the bits */

                        /* the processing for old and new format of metafiles is
                                    different here (till hBitmap is obtained) */

                        /* new metafile version */
                        hBitmap = CreateBitmapForDC (hdc,lpDIBInfo);

                        if (hBitmap)
                            hOldObject = SelectObject (hSDC, hBitmap) ;
                        else
                            goto errPlayMetaFileRecord30 ;
                        }
                    else
                        goto errPlayMetaFileRecord40;
                    }

                if (hSDC)
                    {
                    if (magic == META_DIBBITBLT)
                        BitBlt(hdc, lpMR->rdParm[7 + delta],
                                    lpMR->rdParm[6 + delta],
                                    lpMR->rdParm[5 + delta],
                                    lpMR->rdParm[4 + delta],
                                    hSDC,
                                    lpMR->rdParm[3],
                                    lpMR->rdParm[2],
                                    MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));
                    else
                        StretchBlt(hdc, lpMR->rdParm[9 + delta],
                                        lpMR->rdParm[8 + delta],
                                        lpMR->rdParm[7 + delta],
                                        lpMR->rdParm[6 + delta],
                                        hSDC,
                                        lpMR->rdParm[5],
                                        lpMR->rdParm[4],
                                        lpMR->rdParm[3],
                                        lpMR->rdParm[2],
                                        MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));
                    }

                if (hSDC != hdc)
                    {
                    /* Deselect hDC's palette from memDC */
                    SelectPalette(hSDC, hOldPal, TRUE);
                    if (SelectObject(hSDC, hOldObject))
                        DeleteObject(hBitmap);
errPlayMetaFileRecord30:;
                    DeleteDC(hSDC);
errPlayMetaFileRecord40:;
                    }
            }
            break;

        case (META_SELECTOBJECT & 255):
            {
            HANDLE  hObject;

            if (hObject = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                SelectObject(hdc, hObject);
            }
            break;

        case (META_CREATEPENINDIRECT & 255):
            {
            #ifdef WIN32
            LOGPEN lp;

            lp.lopnStyle   = lpMR->rdParm[0];
            lp.lopnWidth.x = lpMR->rdParm[1];
            lp.lopnColor   = *((COLORREF *)&lpMR->rdParm[3]);
            if (hObject = CreatePenIndirect(&lp))
            #else
            if (hObject = CreatePenIndirect((LPLOGPEN)&lpMR->rdParm[0]))
            #endif
                AddToHandleTable(lpHandleTable, hObject, noObjs);
            break;
            }

        case (META_CREATEFONTINDIRECT & 255):
            {
            LOGFONT   lf;
            LPLOGFONT lplf = &lf;

            LOGFONT32FROM16( lplf, ((LPLOGFONT)&lpMR->rdParm[0]));
            if (hObject = CreateFontIndirect(lplf))
                AddToHandleTable(lpHandleTable, hObject, noObjs);
            }
            break;

        case (META_CREATEPATTERNBRUSH & 255):
            {
            HANDLE    hBitmap;
            LPBITMAP  lpBitmap;

            lpBitmap = (LPBITMAP)lpMR->rdParm;

            //!!!!! ALERT DWORD align on NT
            if (hBitmap = CreateBitmapIndirect(lpBitmap))
                {
                LPBITMAPINFO lpbmInfo;
                HANDLE       hmemInfo;

                hmemInfo = GlobalAlloc( GMEM_ZEROINIT | GMEM_MOVEABLE,
                        sizeof(BITMAPINFO) + 2<<(lpBitmap->bmPlanes*lpBitmap->bmBitsPixel));

                lpbmInfo = (LPBITMAPINFO)GlobalLock( hmemInfo);

                lpbmInfo->bmiHeader.biPlanes   = lpBitmap->bmPlanes;
                lpbmInfo->bmiHeader.biBitCount = lpBitmap->bmBitsPixel;
                SetDIBits( (HDC)NULL, hBitmap, 0, lpBitmap->bmHeight,
                        (LPBYTE)&lpMR->rdParm[8], lpbmInfo, DIB_RGB_COLORS );

                if (hObject = CreatePatternBrush(hBitmap))
                    AddToHandleTable(lpHandleTable, hObject, noObjs);

                GlobalUnlock(hmemInfo);
                GlobalFree(hmemInfo);
                DeleteObject(hBitmap);
                }
            }
            break;

        case (META_DIBCREATEPATTERNBRUSH & 255):
            {
            HDC         hMemDC ;
            HANDLE      hBitmap;
            LPBITMAPINFOHEADER lpDIBInfo ;
            WORD        nDIBSize;          /* number of WORDs in packed DIB */
            HANDLE      hDIB;
            LPWORD      lpDIB;
            LPWORD      lpSourceDIB;
            WORD        i;


            if (lpMR->rdParm[0] == BS_PATTERN)
                {
                /* the address of the second paramter is the address of the DIB
                   header, extract it */
                lpDIBInfo = (BITMAPINFOHEADER FAR *) &lpMR->rdParm[2];

                /* now create a device dependend bitmap compatible to the default
                   screen DC - hScreenDC and extract the bits from the DIB into it.
                    The following function does all these, and returns a HANDLE
                    to the device dependent BItmap. */

                /* we will use a dummy memory DC compatible to the screen DC */
		hMemDC = CreateCompatibleDC (hScreenDC) ;

		hBitmap = CreateBitmapForDC (hScreenDC,lpDIBInfo) ;

                if (hBitmap)
                    {
                    if (hObject = CreatePatternBrush(hBitmap))
                        AddToHandleTable(lpHandleTable, hObject, noObjs);
                    DeleteObject(hBitmap);
                    }

                /* delete the dummy memory DC for new version Metafiles*/
                DeleteDC (hMemDC) ;
                }

            /* this is a DIBPattern brush */
            else
                {
                /* get size of just the packed DIB */
                nDIBSize = (WORD) (lpMR->rdSize - 4);
                if ((hDIB = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,(LONG)(nDIBSize << 1))))
                    {
                    lpDIB = (WORD FAR *) GlobalLock (hDIB);
                    lpSourceDIB = (WORD FAR *)&lpMR->rdParm[2];

                    /* copy the DIB into our new memory block */
                    for (i = 0; i < nDIBSize; i++)
                        *lpDIB++ = *lpSourceDIB++;

                    GlobalUnlock (hDIB);

                    if (hObject = CreateDIBPatternBrush(hDIB, lpMR->rdParm[1]))
                        AddToHandleTable(lpHandleTable, hObject, noObjs);

                    GlobalFree(hDIB);
                    }
                }
            }
            break;

        case (META_CREATEBRUSHINDIRECT & 255):
            {
            #ifdef WIN32
            LOGBRUSH    lb;

            lb.lbStyle = lpMR->rdParm[0];
            lb.lbColor = *((COLORREF *)&lpMR->rdParm[1]);
            lb.lbHatch = lpMR->rdParm[3];

            if (hObject = CreateBrushIndirect(&lb))
            #else
            if (hObject = CreateBrushIndirect((LPLOGBRUSH)&lpMR->rdParm[0]))
            #endif
                AddToHandleTable(lpHandleTable, hObject, noObjs);
            break;
            }

        case (META_POLYLINE & 255):
            {
            LPPOINT lppt;
            Polyline(hdc, (lppt=CONVERTPTS(&lpMR->rdParm[1],lpMR->rdParm[0])), lpMR->rdParm[0]);
            FREECONVERT(lppt);
            break;
            }

        case (META_POLYGON & 255):
            {
            LPPOINT lppt;
            Polygon(hdc, (lppt=CONVERTPTS(&lpMR->rdParm[1],lpMR->rdParm[0])), lpMR->rdParm[0]);
            FREECONVERT(lppt);
            break;
            }

        case (META_POLYPOLYGON & 255):
            {
            LPPOINT lppt;
            #ifdef WIN32
            WORD    cPts=0;
            WORD    ii;

            for(ii=0; ii<lpMR->rdParm[0]; ii++)
                cPts += ((LPWORD)&lpMR->rdParm[1])[ii];
            #endif // WIN32

            PolyPolygon(hdc,
                         (lppt=CONVERTPTS(&lpMR->rdParm[1] + lpMR->rdParm[0], cPts)),
                         (LPINT)&lpMR->rdParm[1],
                         lpMR->rdParm[0]);
            FREECONVERT(lppt);
            }
            break;

        case (META_EXTTEXTOUT & 255):
            {
            LPWORD  lpdx;
            LPSTR   lpch;
            LPRECT  lprt;

            lprt = (lpMR->rdParm[3] & (ETO_OPAQUE|ETO_CLIPPED)) ? (LPRECT)&lpMR->rdParm[4] : 0;
            lpch = (LPSTR)&lpMR->rdParm[4] + ((lprt) ?  sizeof(RECT) : 0);

            /* dx array starts at next word boundary after char string */
            lpdx = (LPWORD)(lpch + ((lpMR->rdParm[2] + 1) & 0xFFFE));

            /* check to see if there is a Dx array by seeing if
               structure ends after the string itself
            */
            if (  ((DWORD)((LPWORD)lpdx - (LPWORD)(lpMR))) >= lpMR->rdSize)
                lpdx = NULL;
            else
		lpdx = (LPWORD)CONVERTINTS((signed short FAR *)lpdx, lpMR->rdParm[2]);

            ExtTextOut(hdc, lpMR->rdParm[1], lpMR->rdParm[0], lpMR->rdParm[3],
                lprt, (LPSTR)lpch, lpMR->rdParm[2], (LPINT)lpdx);
            if (lpdx != (LPWORD)NULL)
                FREECONVERT(lpdx);
            break;
            }

        case (META_TEXTOUT & 255):
            TextOut(hdc, lpMR->rdParm[lpMR->rdSize-4], lpMR->rdParm[lpMR->rdSize-5], (LPSTR)&lpMR->rdParm[1], lpMR->rdParm[0]);
            break;

        case (META_ESCAPE & 255):
            {
            LPSTR       lpStuff;

            if (lpMR->rdParm[0] != MFCOMMENT)
                {
                lpStuff = (LPSTR)&lpMR->rdParm[2];
#ifdef OLDEXTTEXTOUT
                if (lpMR->rdParm[0] == EXTTEXTOUT)
                    {
                    EXTTEXTDATA ExtData;

                    ExtData.xPos     = lpMR->rdParm[2];
                    ExtData.yPos     = lpMR->rdParm[3];
                    ExtData.cch      = lpMR->rdParm[4];
                    ExtData.rcClip   = *((LPRECT)&lpMR->rdParm[5]);
                    ExtData.lpString = (LPSTR)&lpMR->rdParm[9];
                    ExtData.lpWidths = (WORD FAR *)&lpMR->rdParm[9+((ExtData.cch+1)/2)];
                    lpStuff = (LPSTR)&ExtData;
                    }
#endif
                Escape(hdc, lpMR->rdParm[0], lpMR->rdParm[1], lpStuff, (LPSTR)0);
                }
            }
            break;

        case (META_FRAMEREGION & 255):
            if((hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            && (hBrush = lpHandleTable->objectHandle[lpMR->rdParm[1]]))
                FrameRgn(hdc, hRgn, hBrush, lpMR->rdParm[3], lpMR->rdParm[2]);
            break;

        case (META_PAINTREGION & 255):
            if(hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                PaintRgn(hdc, hRgn);
            break;

        case (META_INVERTREGION & 255):
            if(hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                InvertRgn(hdc, hRgn);
            break;

        case (META_FILLREGION & 255):
            if((hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            && (hBrush = lpHandleTable->objectHandle[lpMR->rdParm[1]]))
                FillRgn(hdc, hRgn, hBrush);
            break;

#ifdef DEADCODE
#ifdef GDI104
        case (META_DRAWTEXT & 255):
            MFDrawText(hdc, (LPPOINT)&lpMR->rdParm[6], lpMR->rdParm[1], (LPPOINT)&lpMR->rdParm[2], lpMR->rdParm[0]);
            break;
#endif
#endif

/*
*** in win2, METACREATEREGION records contained an entire region object,
*** including the full header.  this header changed in win3.
***
*** to remain compatible, the region records will be saved with the
*** win2 header.  here we read a win2 header with region, and actually
*** create a win3 header with same region internals
*/

        case (META_CREATEREGION & 255):
            {
#if 0 //!!!!!
            HANDLE      hRgn;
            WORD        *pRgn;
            WORD        iChar;
            LPWORD     *lpTemp;

            iChar = lpMR->rdSize*2 - sizeof(WIN2OBJHEAD) - RECHDRSIZE;
            if (hRgn = LocalAlloc(LMEM_ZEROINIT, iChar + sizeof(ILOBJHEAD)))

                {
		pRgn = (WORD *)Lock IT(hRgn);

                *((WIN2OBJHEAD *)pRgn) = *((WIN2OBJHEAD FAR *)&lpMR->rdParm[0]);
                ((ILOBJHEAD *)pRgn)->ilObjMetaList = 0;

                lpTemp = (LPWORD)&(lpMR->rdParm[0]);
                ((WIN2OBJHEAD FAR *)lpTemp)++;

                ((ILOBJHEAD *)pRgn)++;      /* --> actual region */

                for(i = 0; i < (iChar >> 1) ; i++)
                   *pRgn++ = *lpTemp++;
		pRgn = (WORD *)lock IT(hRgn);
                ((PRGN)pRgn)->rgnSize = iChar + sizeof(ILOBJHEAD);

                AddToHandleTable(lpHandleTable, hRgn, noObjs);
                }
#endif //!!!!!
            HANDLE          hRgn = NULL;
            HANDLE          hRgn2 = NULL;
            WORD            cScans;
	    WORD	    cPnts;
	    WORD	    cbIncr;
            LPWIN3REGION    lpW3Rgn = (LPWIN3REGION)lpMR->rdParm;
            LPSCAN          lpScan = lpW3Rgn->aScans;
            LPWORD          lpXs;

            for( cScans=lpW3Rgn->cScans; cScans>0; cScans--)
                {

                // If this is the first scan then hRgn2 IS the region
                // otherwise OR it in
                if( hRgn == NULL )
                    {
                    // Create the first region in this scan
                    hRgn = CreateRectRgn( lpScan->scnPntsX[0], lpScan->scnPntTop,
                            lpScan->scnPntsX[1], lpScan->scnPntBottom);

                    // Allocate a worker region
                    hRgn2 = CreateRectRgn( 1, 1, 2, 2);
                    }
                else
                    {
                    SetRectRgn( hRgn2, lpScan->scnPntsX[0], lpScan->scnPntTop,
                            lpScan->scnPntsX[1], lpScan->scnPntBottom );
                    CombineRgn( hRgn, hRgn, hRgn2, RGN_OR );
                    }

                lpXs = &lpScan->scnPntsX[2];

                // If there are more regions on this scan OR them in
                for(cPnts = (WORD)(lpScan->scnPntCnt-2); cPnts>0; cPnts-=2)
                    {
                    SetRectRgn( hRgn2, *lpXs++, lpScan->scnPntTop,
                            *lpXs++, lpScan->scnPntBottom );

                    CombineRgn( hRgn, hRgn, hRgn2, RGN_OR );
                    }

		cbIncr = (WORD)sizeof(SCAN) + (WORD)(lpScan->scnPntCnt-2);
		cbIncr = (WORD)sizeof(WORD)*(WORD)(lpScan->scnPntCnt-2);
		cbIncr = (WORD)sizeof(SCAN) + (WORD)sizeof(WORD)*(WORD)(lpScan->scnPntCnt-2);
		cbIncr = (WORD)sizeof(SCAN) + (WORD)(sizeof(WORD)*(lpScan->scnPntCnt-2));
		lpScan = (LPSCAN)((LPBYTE)lpScan + cbIncr);
                }

            if( hRgn2 != NULL )
                DeleteObject( hRgn2 );

            AddToHandleTable(lpHandleTable, hRgn, noObjs);
            }
            break;

        case (META_DELETEOBJECT & 255):
            {
            HANDLE h;

            if (h = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                {
                DeleteObjectPriv(h);
                lpHandleTable->objectHandle[lpMR->rdParm[0]] = NULL;
                }
            }
            break;

        case (META_CREATEPALETTE & 255):
            if (hObject = CreatePalette((LPLOGPALETTE)&lpMR->rdParm[0]))
                AddToHandleTable(lpHandleTable, hObject, noObjs);
            break;

        case (META_SELECTPALETTE & 255):
            if(hPal = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                {
                SelectPalette(hdc, hPal, 0);
                }
            break;

        case (META_REALIZEPALETTE & 255):
            RealizePalette(hdc);
            break;

        case (META_SETPALENTRIES & 255):
            /* we know the palette being set is the current palette */
	    SetPaletteEntriesPriv(GetCurrentObject(hdc,OBJ_PALETTE), lpMR->rdParm[0],
                        lpMR->rdParm[1], (LPPALETTEENTRY)&lpMR->rdParm[2]);
            break;

        case (META_ANIMATEPALETTE & 255):
	    AnimatePalettePriv(GetCurrentObject(hdc,OBJ_PALETTE), lpMR->rdParm[0],
                        lpMR->rdParm[1], (LPPALETTEENTRY)&lpMR->rdParm[2]);

            break;

        case (META_RESIZEPALETTE & 255):
	    ResizePalettePriv(GetCurrentObject(hdc,OBJ_PALETTE), lpMR->rdParm[0]);
            break;

        case (META_SETDIBTODEV & 255):
            {
            LPBITMAPINFOHEADER lpBitmapInfo;
            WORD ColorSize;

            /* if playing into another metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
                goto DontReallyPlay;

            lpBitmapInfo = (LPBITMAPINFOHEADER)&(lpMR->rdParm[9]);

            if (lpBitmapInfo->biClrUsed)
                {
                ColorSize = ((WORD)lpBitmapInfo->biClrUsed) *
                              (WORD)(lpMR->rdParm[0] == DIB_RGB_COLORS ?
                                    sizeof(RGBQUAD) :
                                    sizeof(WORD));
                }
            else if (lpBitmapInfo->biBitCount == 24)
                ColorSize = 0;
            else
                ColorSize = (WORD)(1 << lpBitmapInfo->biBitCount) *
                              (WORD)(lpMR->rdParm[0] == DIB_RGB_COLORS ?
                                    sizeof(RGBQUAD) :
                                    sizeof(WORD));

            ColorSize += sizeof(BITMAPINFOHEADER);

            SetDIBitsToDevice(hdc, lpMR->rdParm[8], lpMR->rdParm[7],
                            lpMR->rdParm[6], lpMR->rdParm[5],
                            lpMR->rdParm[4], lpMR->rdParm[3],
                            lpMR->rdParm[2], lpMR->rdParm[1],
                            (BYTE FAR *)(((BYTE FAR *)lpBitmapInfo) + ColorSize),
                            (LPBITMAPINFO) lpBitmapInfo,
                            lpMR->rdParm[0]);
DontReallyPlay:;
            }
            break;

        case (META_STRETCHDIB & 255):
            {
            LPBITMAPINFOHEADER lpBitmapInfo;
            WORD ColorSize;

            /* if playing into another metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
                goto DontReallyPlay2;

            lpBitmapInfo = (LPBITMAPINFOHEADER)&(lpMR->rdParm[11]);

            if (lpBitmapInfo->biClrUsed)
                {
                ColorSize = ((WORD)lpBitmapInfo->biClrUsed) *
                              (WORD)(lpMR->rdParm[2] == DIB_RGB_COLORS ?
                                    sizeof(RGBQUAD) :
                                    sizeof(WORD));
                }
            else if (lpBitmapInfo->biBitCount == 24)
                ColorSize = 0;
            else
                ColorSize = (WORD)(1 << lpBitmapInfo->biBitCount) *
                              (WORD)(lpMR->rdParm[2] == DIB_RGB_COLORS ?
                                    sizeof(RGBQUAD) :
                                    sizeof(WORD));

            ColorSize += sizeof(BITMAPINFOHEADER);

            StretchDIBits(hdc, lpMR->rdParm[10], lpMR->rdParm[9],
                            lpMR->rdParm[8], lpMR->rdParm[7],
                            lpMR->rdParm[6], lpMR->rdParm[5],
                            lpMR->rdParm[4], lpMR->rdParm[3],
                            (LPBYTE)(((BYTE FAR *)lpBitmapInfo) + ColorSize),
                            (LPBITMAPINFO) lpBitmapInfo,
                            lpMR->rdParm[2],
                            MAKELONG(lpMR->rdParm[1], lpMR->rdParm[0]));
DontReallyPlay2:;
            }
            break;

// Function that have new parameters on WIN32
// Or have DWORDs that stayed DWORDs; all other INTs to DWORDs
#ifdef WIN32
        case (META_MOVETO & 255):
            MoveTo( hdc, (long)lpMR->rdParm[1], (long)lpMR->rdParm[0], NULL );
            break;

        case (META_RESTOREDC & 255):
            RestoreDC( hdc, (long)(signed short)lpMR->rdParm[0] );
            break;

        case (META_SETBKCOLOR & 255):
            SetBkColor( hdc, (UINT)*((LPDWORD)lpMR->rdParm) );
            break;

        case (META_SETTEXTCOLOR & 255):
            SetTextColor( hdc, (UINT)*((LPDWORD)lpMR->rdParm) );
            break;

        case (META_SETPIXEL & 255):
            SetPixel( hdc, (UINT)lpMR->rdParm[3], (UINT)lpMR->rdParm[2],
                    (UINT)*((LPDWORD)lpMR->rdParm) );
            break;

        case (META_SETMAPPERFLAGS & 255):
            SetMapperFlags( hdc, (UINT)*((LPDWORD)lpMR->rdParm) );
            break;

        case (META_FLOODFILL & 255):
            FloodFill( hdc, (UINT)lpMR->rdParm[3], (UINT)lpMR->rdParm[2],
                    (UINT)*((LPDWORD)lpMR->rdParm) );
            break;

        case (META_EXTFLOODFILL & 255):
            ExtFloodFill( hdc, (UINT)lpMR->rdParm[4], (UINT)lpMR->rdParm[3],
                    (UINT)*((LPDWORD)&lpMR->rdParm[1]), (UINT)lpMR->rdParm[0] );
	    break;

        // These puppies all got a new NULL and have only two parameters and a DC.
        case (META_SETWINDOWORG & 255):
        case (META_SETWINDOWEXT & 255):
        case (META_SETVIEWPORTORG & 255):
        case (META_SETVIEWPORTEXT & 255):
        case (META_OFFSETWINDOWORG & 255):
        case (META_SCALEWINDOWEXT & 255):
        case (META_OFFSETVIEWPORTORG & 255):
        case (META_SCALEVIEWPORTEXT & 255):
            {
            FARPROC lpProc;

	    ASSERTGDI((magic&0x00ff) <= MAX_META_DISPATCH, "Unknown function to dispatch1");

            lpProc = alpfnMetaFunc[magic&0x00ff];

	    ASSERTGDI( lpProc != (FARPROC)NULL, "function not in dispatch table1 ");

	    if (lpProc != (FARPROC)NULL)
                (*lpProc)(hdc, (long)(short)lpMR->rdParm[1], (long)(short)lpMR->rdParm[0], NULL );
            }
            break;
#endif // WIN32

        default:
            {
            FARPROC lpProc;
	    signed short *pshort;

	    ASSERTGDI((magic&0x00ff) <= MAX_META_DISPATCH, "Unknown function to dispatch");

            lpProc = alpfnMetaFunc[magic&0x00ff];

	    ASSERTGDI( (lpProc != (FARPROC)NULL) || (magic == META_SETRELABS), "function not in dispatch table");

	    if ((lpProc == (FARPROC)NULL))
		return;

            // Switch to the corresponding dispatcher by number of parameters
            // The number of parameters in the dispatch number does not include the DC.
            switch (magic >> 8)
                {
		typedef int (FAR PASCAL *META1PROC)(HDC);
                typedef int (FAR PASCAL *META2PROC)(HDC, int);
                typedef int (FAR PASCAL *META3PROC)(HDC, int, int);
                typedef int (FAR PASCAL *META4PROC)(HDC, int, int, int);
                typedef int (FAR PASCAL *META5PROC)(HDC, int, int, int, int);
		typedef int (FAR PASCAL *META6PROC)(HDC, int, int, int, int, int);
                typedef int (FAR PASCAL *META7PROC)(HDC, int, int, int, int, int, int);
                typedef int (FAR PASCAL *META9PROC)(HDC, int, int, int, int, int, int, int, int);

		case 0:
		    (*((META1PROC)lpProc))(hdc);
		    break;
                case 1:
                    (*((META2PROC)lpProc))(hdc,lpMR->rdParm[0]);
                    break;
                case 2:
                    (*((META3PROC)lpProc))(hdc,lpMR->rdParm[1],lpMR->rdParm[0]);
                    break;
                case 3:
                    (*((META4PROC)lpProc))(hdc,lpMR->rdParm[2],lpMR->rdParm[1],lpMR->rdParm[0]);
                    break;
                case 4:
                    (*((META5PROC)lpProc))(hdc,lpMR->rdParm[3],lpMR->rdParm[2],lpMR->rdParm[1],lpMR->rdParm[0]);
                    break;
		case 5:
		    (*((META6PROC)lpProc))(hdc,lpMR->rdParm[4],lpMR->rdParm[3],lpMR->rdParm[2],lpMR->rdParm[1],lpMR->rdParm[0]);
		    break;
                case 6:
                    (*((META7PROC)lpProc))(hdc,lpMR->rdParm[5],lpMR->rdParm[4],lpMR->rdParm[3],lpMR->rdParm[2],lpMR->rdParm[1],lpMR->rdParm[0]);
                    break;
                case 8:
                    (*((META9PROC)lpProc))(hdc,lpMR->rdParm[7],lpMR->rdParm[6],lpMR->rdParm[5],lpMR->rdParm[4],lpMR->rdParm[3],lpMR->rdParm[2],lpMR->rdParm[1],lpMR->rdParm[0]);
                    break;

                default:
		    ASSERTGDI( FALSE, "No dispatch for this count of args");
                    break;
                }
            }
            break;
    }
#ifndef WIN32
    if (bExtraSel)
        FreeSelector(HIWORD(lpMR));
#endif // WIN32
}

#endif  // this is going to gdi.dll

/****************************** Internal Function **************************\
* AddToHandleTable
*
* Adds an object to the metafile table of objects
*
*
\***************************************************************************/

VOID INTERNAL AddToHandleTable(LPHANDLETABLE lpHandleTable, HANDLE hObject, WORD noObjs)
{
    WORD    i;

    GdiLogFunc3( "  AddToHandleTable");

    /* linear search through table for first open slot */
    for (i = 0; ((lpHandleTable->objectHandle[i] != NULL) && (i < noObjs));
            ++i);

    if (i < noObjs)                     /* ok index */
        lpHandleTable->objectHandle[i] = hObject;
    else
        {
	ASSERTGDI( 0, "Too many objects in table");
        FatalExit(METAEXITCODE);        /* Why can't we store the handle? */
        }
}


/****************************** Internal Function **************************\
* GetFileNumber
*
* Returns the DOS file number for a metafiles file
* -1 if failure
*
\***************************************************************************/

UINT INTERNAL GetFileNumber(LPMETAFILE lpMF)
{
    int   fileNumber;

    GdiLogFunc3( "  GetFileNumber");

    if (!(fileNumber = lpMF->MetaFileNumber))
        {
        if ((fileNumber = OpenFile((LPSTR) lpMF->MetaFileBuffer.szPathName,
                    (LPOFSTRUCT) &(lpMF->MetaFileBuffer),
                    (WORD)OF_PROMPT | OF_REOPEN | OF_READ)
                    ) != -1)
            {
	    _llseek(fileNumber, (long)lpMF->MetaFilePosition, 0);

            /* need to update MetaFileNumber for floppy files -- amitc */
            lpMF->MetaFileNumber = fileNumber ;
            }
        }

    return fileNumber;
}

#if 0
/****************************** Internal Function **************************\
* IsValidMetaFile(HANDLE hMetaData)
*
* Validates a metafile
*
* Returns TRUE iff hMetaData is a valid metafile
*
\***************************************************************************/

BOOL GDIENTRY IsValidMetaFile(HANDLE hMetaData)
{
    LPMETADATA      lpMetaData;
    BOOL            status = FALSE;

    GdiLogFunc3( "  IsValidMetaFile");

    /* if this is a valid metafile we will save the version in a global variable */

    if (hMetaData && (lpMetaData = (LPMETADATA) GlobalLock(hMetaData)))
        {
        status =   (
                    (lpMetaData->dataHeader.mtType == MEMORYMETAFILE ||
                     lpMetaData->dataHeader.mtType == DISKMETAFILE) &&
                    (lpMetaData->dataHeader.mtHeaderSize == HEADERSIZE) &&
                    ((lpMetaData->dataHeader.mtVersion ==METAVERSION) ||
                        (lpMetaData->dataHeader.mtVersion ==METAVERSION100))
                );
        GlobalUnlock(hMetaData);
        }
    return status;
}
#endif

#define INITIALBUFFERSIZE       16384

/****************************** Internal Function **************************\
*
* AllocBuffer - Allocates a buffer as "large" as possible
*
\***************************************************************************/

HANDLE INTERNAL AllocBuffer(LPWORD piBufferSize)
{
    WORD    iCurBufferSize = INITIALBUFFERSIZE;
    HANDLE  hBuffer;

    GdiLogFunc3( "  AllocBuffer");

    while (!(hBuffer = GlobalAlloc(GMEM_MOVEABLE |
                                   GMEM_NODISCARD, (LONG) iCurBufferSize))
            && iCurBufferSize)
            iCurBufferSize >>= 1;

    *piBufferSize = iCurBufferSize;
    return (iCurBufferSize) ? hBuffer : NULL;
}


/****************************** Internal Function **************************\
* CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo)
*
* This routine takes a memory device context and a DIB bitmap, creates a
* compatible bitmap for the DC and fills it with the bits from the DIB (co-
* -nverting to the device dependent format). The pointer to the DIB bits
* start immediately after the color table in the INFO header.                              **
*                                                                                                                                        **
* The routine returns the handle to the bitmap with the bits filled in if
* everything goes well else it returns NULL.                                                                       **
\***************************************************************************/

HANDLE INTERNAL CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo)
{
    HBITMAP hBitmap ;
    LPBYTE  lpDIBits ;

    GdiLogFunc3( "  CreateBitmapForDC");

    /* preserve monochrome if it started out as monochrome
    ** and check for REAL Black&white monochrome as opposed
    ** to a 2-color DIB
    */
    if (IsDIBBlackAndWhite(lpDIBInfo))
        hBitmap = CreateBitmap ((WORD)lpDIBInfo->biWidth,
                        (WORD)lpDIBInfo->biHeight,
			1, 1, (LPBYTE) NULL);
    else
    /* otherwise, make a compatible bitmap */
        hBitmap = CreateCompatibleBitmap (hMemDC,
                    (WORD)lpDIBInfo->biWidth,
                    (WORD)lpDIBInfo->biHeight);

    if (!hBitmap)
        goto CreateBitmapForDCErr ;

    /* take a pointer past the header of the DIB, to the start of the color
       table */
    lpDIBits = (LPBYTE) lpDIBInfo + sizeof (BITMAPINFOHEADER) ;

    /* take the pointer past the color table */
    lpDIBits += GetSizeOfColorTable (lpDIBInfo) ;

    /* get the bits from the DIB into the Bitmap */
    if (!SetDIBits (hMemDC, hBitmap, 0, (WORD)lpDIBInfo->biHeight,
                    lpDIBits, (LPBITMAPINFO)lpDIBInfo, 0))
       {
       DeleteObject(hBitmap);
       goto CreateBitmapForDCErr ;
       }

   /* return success */
   return (hBitmap) ;

CreateBitmapForDCErr:

   /* returm failure for function */
   return (NULL) ;
}


/****************************** Internal Function **************************\
* GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
*
* Returns the number of bytes in the color table for the giving info header
*
\***************************************************************************/

WORD INTERNAL GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
{

    GdiLogFunc3( "GetSizeOfColorTable");

    if (lpDIBInfo->biClrUsed)
        return((WORD)lpDIBInfo->biClrUsed * (WORD)sizeof(RGBQUAD));
    else
        {
        switch (lpDIBInfo->biBitCount)
            {
            case 1:
                return (2 * sizeof (RGBQUAD)) ;
                break ;
            case 4:
                return (16 * sizeof (RGBQUAD)) ;
                break ;
            case 8:
                return (256 * sizeof (RGBQUAD)) ;
                break ;
            default:
                return (0) ;
                break ;
            }
        }
}

#if 0 // this is going to gdi.dll

/***************************** Public Function ****************************\
* BOOL APIENTRY DeleteMetaFile(hmf)
*
* Frees a metafile handle.
*
* Effects:
*
\***************************************************************************/

BOOL GDIENTRY DeleteMetaFile(HMETAFILE hmf)
{
    GdiLogFunc("DeleteMetaFile");

    GlobalFree(hmf);

    return(TRUE);
}


/***************************** Public Function ****************************\
* HMETAFILE APIENTRY GetMetaFile(pzFilename)
*
* Returns a metafile handle for a disk based metafile.
*
* Effects:
*
* History:
*  Sat 14-Oct-1989 14:21:37  -by-  Paul Klingler [paulk]
* Wrote it.
\***************************************************************************/

HMETAFILE GDIENTRY GetMetaFile(LPSTR pzFilename)
{
    BOOL            status=FALSE;
    UINT            cBytes;
    int             file;
    HMETAFILE       hmf;
    LPMETAFILE      lpmf;

    GdiLogFunc("GetMetaFile");

    // Allocate the Metafile
    if(hmf = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,(DWORD)sizeof(METAFILE)))
        {
        lpmf = (LPMETAFILE)GlobalLock(hmf);

        // Make sure the file Exists
        if((file = OpenFile(pzFilename,
                    &(lpmf->MetaFileBuffer),
                    (WORD)OF_PROMPT | OF_EXIST)) == -1L)
            {
	    ASSERTGDI( FALSE, "GetMetaFile: Metafile does not exist");
            goto exitGetMetaFile;
            }

        // Open the file
        if((file = OpenFile(pzFilename,
                    &(lpmf->MetaFileBuffer),
                    (WORD)OF_PROMPT | OF_REOPEN | OF_READWRITE)) == -1)
            {
	    ASSERTGDI( FALSE, "GetMetaFile: Unable to open Metafile");
            goto exitGetMetaFile;
            }

	cBytes = (UINT)_lread(file,(LPSTR)(&(lpmf->MetaFileHeader)),sizeof(METAHEADER));

        // Check for an Aldus header
        if (*((LPDWORD)&(lpmf->MetaFileHeader)) == 0x9AC6CDD7)
            {

            _llseek( file, 22, 0);
	    cBytes = (UINT)_lread(file,(LPSTR)(&(lpmf->MetaFileHeader)),sizeof(METAHEADER));
            }

        _lclose(file);

        // Validate the metafile
        if(cBytes == sizeof(METAHEADER))
            {
            lpmf->MetaFileHeader.mtType = DISKMETAFILE;
            status = TRUE;
            }

        exitGetMetaFile:
        GlobalUnlock(hmf);
        }

    if(status == FALSE)
        {
        GlobalFree(hmf);
        hmf = NULL;
        }

    return(hmf);
}
#endif  // this is going to gdi.dll

#ifdef WIN32
#undef GetViewportExt
DWORD GetViewportExt32(HDC hdc)
{
    SIZE sz;
    GetViewportExt( hdc, &sz );
    return(MAKELONG(LOWORD(sz.cx),LOWORD(sz.cy)));
}

#undef GetWindowExt
DWORD GetWindowExt32(HDC hdc)
{
    SIZE sz;
    GetWindowExt( hdc, &sz );
    return(MAKELONG(LOWORD(sz.cx),LOWORD(sz.cy)));
}

#undef SetViewportExt
DWORD SetViewportExt32(HDC hdc, UINT x, UINT y)
{
    SIZE  sz;
    SetViewportExt( hdc, x, y, &sz );
    return(MAKELONG(LOWORD(sz.cx),LOWORD(sz.cy)));
}

#undef SetWindowExt
DWORD SetWindowExt32(HDC hdc, UINT x, UINT y)
{
    SIZE  sz;
    SetWindowExt( hdc, x, y, &sz );
    return(MAKELONG(LOWORD(sz.cx),LOWORD(sz.cy)));
}

/* Convert WORD arrays into DWORDs */
LPINT ConvertInts( signed short * pWord, UINT cWords )
{
    UINT    ii;
    LPINT   pInt;

    pInt = (LPINT)LocalAlloc( LMEM_FIXED, cWords * sizeof(UINT));

    for( ii=0; ii<cWords; ii++)
    {
        pInt[ii] = (long)(signed)pWord[ii];
    }

    return(pInt);
}

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\metarec.c ===
/****************************** Module Header ******************************\
*
* Module Name: MetaRec.c
*
*
* DESCRIPTIVE NAME:   Metafile Recorder
*
* FUNCTION:   Records GDI functions in memory and disk metafiles.
*
* PUBLIC ENTRY POINTS:
*   CloseMetaFile
*   CopyMetaFile
*   CreateMetaFile
*   GetMetaFileBits
*   SetMetaFileBits
* PRIVATE ENTRY POINTS:
*   RecordParms
*   AttemptWrite
*   MarkMetaFile
*   RecordOther
*   RecordObject
*   ProbeSize
*   AddToTable
*
* History:
*  02-Jul-1991 -by-  John Colleran [johnc]
* Combined From Win 3.1 and WLO 1.0 sources
\***************************************************************************/

#include <windows.h>
#include <drivinit.h>
#include "gdi16.h"

#define SP_OUTOFDISK	(-4)    /* simply no disk to spool */

extern HANDLE	 hStaticBitmap ;    // MetaSup.c
extern METACACHE MetaCache;	    // Meta.c
extern HDC	 hScreenDC;


WORD	INTERNAL AddToTable(HANDLE hMF, HANDLE hObject, LPWORD position, BOOL bRealAdd);
HANDLE	INTERNAL AllocateSpaceForDIB (LPBITMAP, LPBYTE, LPWORD, LPDWORD);
BOOL	INTERNAL AttemptWrite(HANDLE, WORD, DWORD, BYTE huge *);
BOOL	INTERNAL CopyFile(LPSTR lpSFilename, LPSTR lpDFilename);
LPWORD	INTERNAL InitializeDIBHeader (LPBITMAPINFOHEADER, LPBITMAP, BYTE, WORD);
VOID	INTERNAL MarkMetaFile(HANDLE hMF);
HANDLE	INTERNAL ProbeSize(NPMETARECORDER pMF, DWORD dwLength);

HANDLE	hFirstMetaFile = 0;	    // Linked list of all open MetaFiles


/****************************************************************************
*									    *
* RecordParms								    *
*									    *
* Parameters: 1.hMF handle to a metafile header.			    *
*	      2.The magic number of the function being recorded.	    *
*	      3.The number of parmmeter of the function (size of lpParm     *
*		  in words)						    *
*	      4.A long pointer to parameters stored in reverse order	    *
*									    *
****************************************************************************/

BOOL INTERNAL RecordParms(HANDLE hdc, WORD magic, DWORD count, LPWORD lpParm)
{
    BOOL			status = FALSE;
    DWORD			i;
    DWORD			dwLength;
    HPWORD			hpwSpace;
    HPWORD			hpHugeParm;
    LPWORD			lpCache;
    HANDLE			hSpace;
    WORD			fileNumber;
    METARECORD			recPair;
    HANDLE			hMF;

    NPMETARECORDER		npMF;

    dprintf( 6,"  RecordParms 0x%X", magic);

    hpHugeParm = (HPWORD)lpParm;

    // Validate the metafile handle

    if(npMF = (NPMETARECORDER)LocalLock(HANDLEFROMMETADC(hdc)))
	{
	if(npMF->metaDCHeader.ident != ID_METADC )
	    {
	    LocalUnlock(HANDLEFROMMETADC(hdc));
	    ASSERTGDI( FALSE, "RecordParms: invalid metafile ID");
	    return(FALSE);
	    }
	}
    else
	{
	ASSERTGDI( FALSE, "RecordParms: invalid metafile");
	return(FALSE);
	}

    hMF = HANDLEFROMMETADC(hdc);

    if (!(npMF->recFlags & METAFILEFAILURE))
	{
	if (npMF->recordHeader.mtType == MEMORYMETAFILE)
	    {
	    if (hSpace = ProbeSize(npMF, dwLength = count + RECHDRSIZE / 2))
		{
		hpwSpace = (HPWORD) GlobalLock(hSpace);

		hpwSpace = (HPWORD) ((LPMETADATA) hpwSpace)->metaDataStuff;
		hpwSpace = hpwSpace + npMF->recFilePosition;

		// write length out at a pair of words because we
		// are not DWORD aligned, so we can't use "DWORD huge *"

		*hpwSpace++ = LOWORD(dwLength);
		*hpwSpace++ = HIWORD(dwLength);

		*hpwSpace++ = magic;
		for (i = 0; i < count; ++i)
		    *hpwSpace++ = *hpHugeParm++;
		npMF->recFilePosition += dwLength;
		GlobalUnlock(hSpace);
		}
	    else
		{
		goto Exit_RecordParms;
		}
	    }
	else if (npMF->recordHeader.mtType == DISKMETAFILE)
	    {
	    dwLength = count + RECHDRSIZE / 2;
	    if (npMF->recFileBuffer.fFixedDisk)
		{
		fileNumber = npMF->recFileNumber;
		}
	    else
		{
		if ((fileNumber =
			    OpenFile((LPSTR)npMF->recFileBuffer.szPathName,
				     (LPOFSTRUCT)&(npMF->recFileBuffer),
				     OF_PROMPT|OF_REOPEN|READ_WRITE))
			    == -1)
		    {
		    goto Exit_RecordParms;
		    }
		_llseek(fileNumber, (LONG) 0, 2);
		}

	    if (hMF == MetaCache.hMF)
		{
		lpCache = (LPWORD) GlobalLock(MetaCache.hCache);
		if (dwLength + MetaCache.wCachePos >= MetaCache.wCacheSize)
		    {
		    if (!AttemptWrite(hdc,
				      fileNumber,
				      (DWORD)(MetaCache.wCachePos << 1),
				      (BYTE huge *) lpCache))
			{
			MarkMetaFile(hMF);
			GlobalUnlock(MetaCache.hCache);
			goto Exit_RecordParms;
			}
		    MetaCache.wCachePos = 0;

		    if (dwLength >= MetaCache.wCacheSize)
			{
			GlobalUnlock(MetaCache.hCache);
			goto NOCACHE;
			}
		    }

		lpCache += MetaCache.wCachePos;

		*((LPDWORD) lpCache)++ = dwLength;
		*lpCache++ = magic;

		for (i = 0; i < count; ++i)
		    *lpCache++ = *lpParm++;

		MetaCache.wCachePos += dwLength;
		GlobalUnlock(MetaCache.hCache);
		}
	    else
		{
NOCACHE:
		recPair.rdSize = dwLength;
		recPair.rdFunction = magic;
		if (!AttemptWrite(hdc,
				    fileNumber,
				    (DWORD)RECHDRSIZE,
				    (BYTE huge *) &recPair))
		    {
		    goto Exit_RecordParms;
		    }
		if (count)
		    {
		    if (!AttemptWrite(hdc,
					fileNumber,
					(DWORD)(count * sizeof(WORD)),
					(BYTE huge *) lpParm))
			{
			goto Exit_RecordParms;
			}
		    }
		}
	    if (!(npMF->recFileBuffer.fFixedDisk))
		_lclose(fileNumber);
	    }
	}

	if (npMF->recordHeader.mtMaxRecord < dwLength)
	    npMF->recordHeader.mtMaxRecord = dwLength;

	npMF->recordHeader.mtSize += dwLength;
	status = TRUE;

Exit_RecordParms:
    if (status == FALSE)
	{
	ASSERTGDI( FALSE, "RecordParms: failing");
	MarkMetaFile(hMF);
	}

    LocalUnlock(HANDLEFROMMETADC(hdc));

    return(status);

}  /* RecordParms */


/***************************** Internal Function ***************************\
* AttempWrite
*
* Tries to write data to a metafile disk file
*
* Returns TRUE iff the write was sucessful
*
*
\***************************************************************************/

BOOL INTERNAL AttemptWrite(hdc, fileNumber, dwBytes, lpData)
HANDLE		hdc;
DWORD		dwBytes;
WORD		fileNumber;
HPBYTE		lpData;
{
    WORD	cShort;
    WORD	cbWritten;
    WORD	cBytes;


    GdiLogFunc2( "  AttemptWrite" );

    while(dwBytes > 0)
	{
	cBytes = (dwBytes > MAXFILECHUNK ? MAXFILECHUNK : (WORD) dwBytes);

	if ((cbWritten = _lwrite(fileNumber, (LPSTR)lpData, cBytes)) != cBytes)
	    {
	    cShort = cBytes - cbWritten;
	    lpData +=  cbWritten;

	    ASSERTGDI( 0, "Disk full?");
// !!!!! handle disk full   -- diskAvailable

	    if( !IsMetaDC(hdc) )
		return(FALSE);
	    }

	/* how many bytes are left? */
	dwBytes -= cBytes;
	lpData	+= cbWritten;
	}
    return(TRUE);
}


/***************************** Internal Function ***************************\
* VOID INTERNAL MarkMetaFile(hmr)
*
* Marks a metafile as failed
*
* Effects:
*   Frees the metafile resources
*
\***************************************************************************/

VOID INTERNAL MarkMetaFile(HANDLE hMF)
{
    NPMETARECORDER	npMF;

    GdiLogFunc2( "  MarkMetaFile" );

    npMF = (NPMETARECORDER) NPFROMMETADC(hMF);
    npMF->recFlags |= METAFILEFAILURE;

    if (npMF->recordHeader.mtType == MEMORYMETAFILE)
	{
	if (npMF->hMetaData)
	    GlobalFree(npMF->hMetaData);
	}
    else if (npMF->recordHeader.mtType == DISKMETAFILE)
	{
	if (npMF->recFileBuffer.fFixedDisk)
	    _lclose(npMF->recFileNumber);

	OpenFile((LPSTR) npMF->recFileBuffer.szPathName,
		 (LPOFSTRUCT) &(npMF->recFileBuffer),
		 OF_PROMPT|OF_DELETE);
	}
}


/***************************** Internal Function **************************\
* MakeLogPalette
*
* Records either CreatePalette or SetPaletteEntries
*
* Returns
*
*
\***************************************************************************/

WORD NEAR MakeLogPalette(HANDLE hMF, HANDLE hPal, WORD magic)
{
    WORD	cPalEntries;
    WORD	status = 0xFFFF;
    HANDLE	hSpace;
    WORD	cbPalette;
    LPLOGPALETTE lpPalette;

    GdiLogFunc2( "  MakeLogPalette" );

    cPalEntries = GetObject( hPal, 0, NULL );

    /* alloc memory and get the palette entries */
    if (hSpace = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,
	    cbPalette = sizeof(LOGPALETTE)+sizeof(PALETTEENTRY)*(cPalEntries)))
	{
	lpPalette = (LPLOGPALETTE)GlobalLock(hSpace);

	lpPalette->palNumEntries = cPalEntries;

	GetPaletteEntries( hPal, 0, cPalEntries, lpPalette->palPalEntry);

	if (magic == (META_CREATEPALETTE & 255))
	    {
	    lpPalette->palVersion = 0x300;
	    magic = META_CREATEPALETTE;
	    }
	else if (magic == (META_SETPALENTRIES & 255))
	    {
	    lpPalette->palVersion = 0;	 /* really "starting index" */
	    magic = META_SETPALENTRIES;
	    }

	status = RecordParms(hMF, magic, (DWORD)cbPalette >> 1, (LPWORD)lpPalette);

	GlobalUnlock(hSpace);
    	GlobalFree(hSpace);
	}

    return(status);
}


/****************************************************************************
*									    *
*   Routine: RecordOther, records parameters for certain "hard functions"   *
*									    *
*   Parameters: 1. hMF handle to a metafile header.			    *
*		2. The magic number of the function being recorded.	    *
*		3. The number of parmmeter of the function (size of lpParm  *
*		   in words)						    *
*		4. A long pointer to parameters stored in reverse order	    *
*									    *
****************************************************************************/

BOOL INTERNAL RecordOther(HDC hdc, WORD magic, WORD count, LPWORD lpParm)
{
    NPMETARECORDER  npMF;
    WORD	    buffer[5];
    WORD	    i;
    WORD	    status = FALSE;
    WORD	    iChar;
    WORD	    position;
    HANDLE	    hSpace = NULL;
    WORD	    iWords;
    LPWORD	    lpSpace;
    LPWORD	    lpTemp;
    HANDLE	    hMF;

    dprintf( 6,"  RecordOther 0x%X", magic);

    if ((hMF = GetPMetaFile(hdc)) != -1 )
	{
	// Handle functions with no DC.
	if( hMF == 0 )
	    {
	    HANDLE	hmfSearch = hFirstMetaFile;

	    // Play these records into all active metafiles
	    while( hmfSearch )
		{
		npMF = (NPMETARECORDER)LocalLock( hmfSearch );
		if (!(npMF->recFlags & METAFILEFAILURE))
		    {
		    switch (magic & 255)
			{
			case (META_ANIMATEPALETTE & 255):
			    {
			    HANDLE hSpace;
			    LPSTR  lpSpace;
			    LPSTR  lpHolder;
			    WORD   SpaceSize;
			    LPPALETTEENTRY lpColors;

			    SpaceSize = 4 + (lpParm[2] * sizeof(PALETTEENTRY));
			    if ((hSpace = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,(LONG) SpaceSize)))
				{
				lpHolder = lpSpace = GlobalLock(hSpace);

				*((LPWORD)lpSpace)++ = lpParm[3];
				*((LPWORD)lpSpace)++ = lpParm[2];
				lpColors = (LPPALETTEENTRY)lpParm;

				for (i=0; i<lpParm[2]; i++)
				    *((LPPALETTEENTRY)lpSpace)++ = *lpColors++;

				status = RecordParms(HMFFROMNPMF(npMF), magic, (DWORD)(SpaceSize >> 1),
					  (LPWORD) lpHolder);

				GlobalUnlock(hSpace);
				GlobalFree(hSpace);
				}
			    }
			    break;

			case (META_RESIZEPALETTE & 255):
			    {
			    status = RecordParms(HMFFROMNPMF(npMF), magic, (DWORD)1, (LPWORD)&lpParm[0]);
			    }
			    break;

			case (META_DELETEOBJECT & 255):
			    if (AddToTable(HMFFROMNPMF(npMF), *lpParm, (LPWORD) &position, FALSE) == 1)
				{
				status = RecordParms(HMFFROMNPMF(npMF), META_DELETEOBJECT, 1UL, &position);
				}
			    break;
			}  /* switch */
		    }

		LocalUnlock( hmfSearch );
		hmfSearch = npMF->metaDCHeader.nextinchain;
		}  /* while */
	    }


	npMF = (NPMETARECORDER) NPFROMMETADC(hMF);
	if (!(npMF->recFlags & METAFILEFAILURE))
	    {

	    switch (magic & 255)
	    {



	    case (META_FRAMEREGION & 255):
	    case (META_FILLREGION & 255):
	    case (META_INVERTREGION & 255):
	    case (META_PAINTREGION & 255):
		// Each region function has at least a region to record
		buffer[0] = RecordObject(hMF, magic, count, (LPWORD)&(lpParm[count-1]));

		/* Is there a brush too; FillRgn */
		if(count > 1 )
		    buffer[1] = RecordObject(hMF, magic, count, (LPWORD)&(lpParm[count-2]));

		/* Are there are extents too; FrameRegion */
		if(count > 2)
		    {
		    buffer[2] = lpParm[0];
		    buffer[3] = lpParm[1];
		    }

		status = RecordParms(hMF, magic, (DWORD)count, (LPWORD)buffer);
		break;

	    case (META_FLOODFILL & 255):
		buffer[0] = 0;	// Regular FloodFill
		buffer[1] = lpParm[0];
		buffer[2] = lpParm[1];
		buffer[3] = lpParm[2];
		buffer[4] = lpParm[3];
		status = RecordParms(hMF, META_EXTFLOODFILL, (DWORD)count+1, (LPWORD)buffer);
		break;

	    case (META_ESCAPE & 255):
		/* record the function number */
		{
		WORD		iBytes;
		WORD		count;
		char *		pSpace;
		char *		pTemp;
		LPSTR		lpInData;
		LPEXTTEXTDATA	lpTextData;
		WORD		function;

		*((WORD FAR * FAR *) lpParm)++;
		lpInData = (LPSTR) *((WORD FAR * FAR *) lpParm)++;
		lpTextData = (LPEXTTEXTDATA) lpInData;
		count = iBytes = *lpParm++;

		function = *lpParm++;
#ifdef OLDEXTTEXTOUT
		if (function == EXTTEXTOUT)
		    {
		    iBytes = (lpTextData->cch * (sizeof(WORD)+sizeof(char)))
			     + 1 + sizeof(EXTTEXTDATA);
		    }
#endif

		if (!(pTemp = pSpace =
		     (char *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, (iBytes + (sizeof(WORD) * 2)))))
		    return(FALSE);

		*((WORD *) pTemp)++ = function;
		*((WORD *) pTemp)++ = count;

#ifdef OLDEXTTEXTOUT
		if (function != EXTTEXTOUT) {
#endif
		    for (i = 0; i < iBytes; ++i)
			*pTemp++ = *lpInData++;
#ifdef OLDEXTTEXTOUT
		} else {
		    *((WORD *) pTemp)++ = lpTextData->xPos;
		    *((WORD *) pTemp)++ = lpTextData->yPos;
		    *((WORD *) pTemp)++ = lpTextData->cch;
		    *((RECT *) pTemp)++ = lpTextData->rcClip;
		    for (i = 0; i < ((lpTextData->cch + 1) & ~1) ; ++i)
			*pTemp++ = lpTextData->lpString[i];

		    for (i = 0; i < lpTextData->cch; ++i)
			*((WORD *) pTemp)++ = lpTextData->lpWidths[i];
		}
#endif

		/* info block + 2 words for function and count */
		status = RecordParms(hMF, magic,
				  (DWORD)((iBytes + 1) >> 1) + 2,
				  (LPWORD) pSpace);

		LocalFree((HANDLE) pSpace);
		}
		break;

	    case (META_POLYLINE & 255):
	    case (META_POLYGON & 255):
		{
		WORD	iPoints;
		WORD   *pSpace;
		WORD   *pTemp;
		LPWORD	lpPoints;

		iPoints = *lpParm++;

		iWords = iPoints * 2;
		if (!(pTemp = pSpace = (WORD *) LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT,
				(iPoints * sizeof(POINT)) + sizeof(WORD))))
			return(FALSE);

		lpPoints = *((WORD FAR * FAR *) lpParm)++;
		*pTemp++ = iPoints;

		for (i = 0; i < iWords; ++i)
		    *pTemp++ = *lpPoints++;
		status = RecordParms(hMF, magic, (DWORD)iWords + 1, (LPWORD) pSpace);
		LocalFree((HANDLE) pSpace);
		}
		break;

	    case (META_POLYPOLYGON & 255):
		{
		WORD	iPoints;
		WORD	iPolys;
		WORD	*pSpace;
		WORD	*pTemp;
		LPWORD	lpPoints;
		LPWORD	lpNumPoints;

		/* get the number of polygons */
		iPolys = *lpParm++;

		/* get the pointers to Points and NumPoints */
		lpNumPoints = *((WORD FAR * FAR *) lpParm)++;
		lpPoints  =	*((WORD FAR * FAR *) lpParm)++;

		/* count the total number of points */
		iPoints = 0 ;
		for (i=0; i<iPolys; i++)
		    iPoints += *(lpNumPoints + i) ;

		/* allocate space needed for Points, NumPoints and Count */
		if (!(pTemp = pSpace = (WORD *) LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT,
				(iPoints * sizeof(POINT)) +
				 iPolys  * sizeof(WORD) +
				 sizeof(WORD))))
			return(FALSE);

		/* save the Count parameter */
		*pTemp++ = iPolys;

		/* now copy the NumPoints array*/
		for (i = 0; i < iPolys; ++i)
		    *pTemp++ = *lpNumPoints++;

		/* finally copy the number of words in the Points array, remember
		   the number of words there are double the number of points */
		iWords = iPoints * 2;
		for (i = 0; i < iWords; ++i)
		    *pTemp++ = *lpPoints++;

		/* total number of words in the parameter list =
		   iPoints*2(for Points) + iPolys(for NumPoints) + 1(for Count)
			and iWords has already iPoints*2 */

		iWords += iPolys + 1 ;

		/* finally record all the parameters */
		status = RecordParms(hMF, magic, (DWORD)iWords , (LPWORD) pSpace);
		LocalFree((HANDLE) pSpace);
		}
		break;

#ifdef	DEADCODE

	    case (META_DRAWTEXT & 255):
		{
		WORD	wFormat;
		WORD	count;
		WORD   *pSpace;
		WORD   *pTemp;
		LPBYTE	lpString;
		LPBYTE	lpS;
		LPWORD	lpRect;

		wFormat = *lpParm++;
		lpRect = *((WORD FAR * FAR *) lpParm)++;
		count = *lpParm++;
		lpString = (LPBYTE) *((WORD FAR * FAR *) lpParm)++;

		if(count == -1){    /* another null terminated string */
		    lpS = lpString;
		    for (count = 0 ; *lpS++ != 0; count++) ;
		}

		if (!(pTemp = pSpace = (WORD *) LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT,
			count + 6 * sizeof(WORD))))
		    return(FALSE);

		*pTemp++ = wFormat;
		*pTemp++ = count;
		for (i = 0; i < 4; ++i)
		    *pTemp++ = *lpRect++;

		for (i = 0; i < count; ++i)
		    *((BYTE *) pTemp)++ = *lpString++;

		count = (count + 1) >> 1;
		status = RecordParms(hMF, magic, (DWORD)count + 6, (LPWORD) pSpace);
		LocalFree((HANDLE) pSpace);
		}
		break;
#endif

	    case (META_EXTTEXTOUT & 255):
		{
		WORD		iBytes;
		WORD		count;
		WORD		options;
		WORD		*pTemp;
		WORD		*pSpace;
		LPINT		lpdx;
		LPWORD		lpString;
		LPRECT		lprt;
		WORD		ii;

		lpdx = *((WORD FAR * FAR *) lpParm)++;
		count = iBytes = *lpParm++;

		lpString =  (LPWORD) *((LPSTR FAR *) lpParm)++;
		lprt = (LPRECT) *((LPSTR FAR *) lpParm)++;
		options = *lpParm++;

		/* how much space do we need?
		**  room for the char string
		**  room for the 4 words that are the fixed parms
		**  if there is a dx array, we need room for it
		**  if the rectangle is being used, we need room for it
		**  and we need extra byte for eventual word roundoff
		*/
		iBytes = (count * (((lpdx) ? sizeof(WORD) : 0)
			     + sizeof(BYTE)))
			  + ((options & (ETO_OPAQUE | ETO_CLIPPED))
						    ? sizeof(RECT) : 0)
			  + 1 + (sizeof(WORD) * 4);

		if (!(pTemp = pSpace = (WORD *) LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT,iBytes)))
		    return(FALSE);

		/* record YPos and XPos */

		*pTemp++ = *lpParm++;
		*pTemp++ = *lpParm++;
		*pTemp++ = count;
		*pTemp++ = options;

		/* if there's an opaquing rect copy it */
		if (options & (ETO_OPAQUE|ETO_CLIPPED))
		    {
		    *pTemp++ = lprt->left;
		    *pTemp++ = lprt->top;
		    *pTemp++ = lprt->right;
		    *pTemp++ = lprt->bottom;
		    }

		/* need to copy bytes because it may not be even */
		for (ii = 0; ii < count; ++ii)
		    *((BYTE *)pTemp)++ = *((LPBYTE)lpString)++;
		if (count & 1)		    /* word align */
		    *((BYTE *)pTemp)++;

		if (lpdx)
		    for (ii = 0; ii < count; ++ii)
			*pTemp++ = *lpdx++;

		status = RecordParms(hMF, magic, (DWORD)iBytes >> 1,
				  (LPWORD) pSpace);

		LocalFree((HANDLE)pSpace);

		}
		break;

	    case (META_TEXTOUT & 255):
		{
		LPWORD	lpString;
		WORD   *pSpace;
		WORD   *pTemp;
		POINT	pt;

		iChar = *lpParm++;
		if (!(pTemp = pSpace = (WORD *) LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT,
			iChar + (sizeof(WORD) * 4))))
		    return(FALSE);

		*pTemp++ = iChar;
		lpString = (LPWORD) *((LPSTR FAR *) lpParm)++;

		for (i = 0; i < iChar; ++i)
		    *((BYTE *)pTemp)++ = *((LPBYTE)lpString)++;
		if (iChar & 1)		/* word align */
		    *((BYTE *)pTemp)++;

		pt.y = *pTemp++ = *lpParm++;
		pt.x = *pTemp++ = *lpParm++;

		status = RecordParms(hMF, magic, (DWORD)((iChar + 1) >> 1) + 3,
				  (LPWORD) pSpace);

		LocalFree((HANDLE) pSpace);
		}
		break;

	    case (META_DIBBITBLT & 255):
	    case (META_DIBSTRETCHBLT & 255):
		{
		LPBITMAPINFOHEADER lpDIBInfo ;
		DWORD	    iWords;
		DWORD	    iBits;
		WORD	    wColorTableSize ;
		BOOL	    bSame=FALSE;
		HANDLE	    hSpace=FALSE;
		HBITMAP     hBitmap;
		HDC	    hSDC;
		BYTE	    bBitsPerPel ;
		BITMAP	    logBitmap;

		iWords = (WORD)count;
		hSDC = lpParm[iWords - 5];

		if (hMF == hSDC || hSDC == NULL)
		    bSame = TRUE;
		else
		    {
		    WORD    iParms;

		    if( GetObjectType( (HANDLE)hSDC ) == OBJ_MEMDC)
			{
			HBITMAP hBitmap;

			hBitmap = GetCurrentObject( hSDC, OBJ_BITMAP );

			GetObject( hBitmap, sizeof(BITMAP), (LPSTR)&logBitmap);

			/* allocate space for the DIB header and bits */
			if (!(hSpace = AllocateSpaceForDIB (&logBitmap,
					    &bBitsPerPel,
					    &wColorTableSize,
					    &iBits )))
			    return (FALSE) ;
			lpTemp = lpSpace = (LPWORD) GlobalLock(hSpace);

/*--------------------------------------------------------------------------**
** copy the parameters from the end of the list which is at the top of the  **
** stack till the hSrcDC parameter,skip the hSrcDC parameter and copy the   **
** rest of the parameters.						    **								       **
**--------------------------------------------------------------------------*/

			iParms = (magic == META_DIBBITBLT) ? 4 : 6;

			for (i = 0; i < iParms; ++i)
			    *lpSpace++ = *lpParm++;

			/* skip the hSrcDC parameter and reduce parameter count */
			*lpParm++;
			iWords--;

			/* copy the rest of the parameters in the call */
			for ( ; i < (WORD)iWords; ++i)
			    *lpSpace++ = *lpParm++;


			/* save the start of the bitmap info header field */
			lpDIBInfo = (LPBITMAPINFOHEADER) lpSpace ;

			/* preapare the header and return lpSpace pointing to area
				for thr bits */
			lpSpace = InitializeDIBHeader (lpDIBInfo,
				    &logBitmap, bBitsPerPel,wColorTableSize) ;

			/* lpSpace now points to the area to hold DIB bits */

			}
		    else
			return(FALSE);
		    }

	    if (bSame)
	       status = RecordParms(hMF, magic, (DWORD)count, lpParm);
	    else
		{
		/* get the bits into the DIB */
		hBitmap = SelectObject (hSDC, hStaticBitmap) ;
		GetDIBits(hSDC, hBitmap, 0, logBitmap.bmHeight,
			      (LPBYTE) lpSpace, (LPBITMAPINFO)lpDIBInfo, 0 ) ;
		SelectObject (hSDC,hBitmap) ;

		/* finally record the parameters into the file*/
		status = RecordParms(hMF, magic, (DWORD)(iWords
			       + (iBits >> 1)) , (LPWORD) lpTemp ) ;

		if (hSpace)
		    {
		    GlobalUnlock(hSpace);
		    GlobalFree(hSpace);
		    }
		}
	    }
	    break;

	    case (META_SETDIBTODEV & 255):
		{
		HANDLE	hSpace;
		LPWORD	lpSpace;
		LPWORD	lpHolder;
		DWORD	SpaceSize;
		WORD	ColorSize;
		DWORD	BitmapSize;
		LPBITMAPINFOHEADER lpBitmapInfo;
		HPWORD	lpBits;
		WORD	wUsage;
		LPBITMAPCOREHEADER lpBitmapCore;    /* used for old DIBs */
		DWORD	dwi;
		HPWORD	lpHugeSpace;

		wUsage = *lpParm++;

		lpBitmapInfo = (LPBITMAPINFOHEADER) *((WORD FAR * FAR *) lpParm)++;
		lpBits = (WORD huge *) *((WORD FAR * FAR *) lpParm)++;

		/* old style DIB header */
		if (lpBitmapInfo->biSize == sizeof(BITMAPCOREHEADER))
		    {
		    lpBitmapCore = (LPBITMAPCOREHEADER)lpBitmapInfo;

		    if (lpBitmapCore->bcBitCount == 24)
			ColorSize = 0;
		    else
			ColorSize = (1 << lpBitmapCore->bcBitCount) *
			      (wUsage == DIB_RGB_COLORS ?
				    sizeof(RGBQUAD) :
				    sizeof(WORD));

		    /* bits per scanline */
		    BitmapSize = lpBitmapCore->bcWidth *
				    lpBitmapCore->bcBitCount;

		    /* bytes per scanline (rounded to DWORD boundary) */
		    BitmapSize = ((BitmapSize + 31) & (~31)) >> 3;
		    /* bytes for the NumScans of the bitmap */
		    BitmapSize *= lpParm[0];
		    }
		/* new style DIB header */
		else
		    {
		    if (lpBitmapInfo->biClrUsed)
			{
			ColorSize = ((WORD)lpBitmapInfo->biClrUsed) *
				    (wUsage == DIB_RGB_COLORS ?
				    sizeof(RGBQUAD) :
				    sizeof(WORD));
			}
		    else if (lpBitmapInfo->biBitCount == 24)
			ColorSize = 0;
		    else
			ColorSize = (1 << lpBitmapInfo->biBitCount) *
			      (wUsage == DIB_RGB_COLORS ?
				    sizeof(RGBQUAD) :
				    sizeof(WORD));

		    /* if biSizeImage is already there and we are
		    ** getting a full image, there is no more work
		    ** to be done.
		    ** ****** what about partial RLEs? *****
		    */
		    if (!(BitmapSize = lpBitmapInfo->biSizeImage) ||
			    (lpBitmapInfo->biHeight != lpParm[0]))
			{
			/* bits per scanline */
			BitmapSize = lpBitmapInfo->biWidth *
				    lpBitmapInfo->biBitCount;
			/* bytes per scanline (rounded to DWORD boundary) */
			BitmapSize = ((BitmapSize + 31) & (~31)) >> 3;
			/* bytes for the NumScans of the bitmap */
			BitmapSize *= lpParm[0];
			}
		    }

		SpaceSize = (DWORD)sizeof(BITMAPINFOHEADER) + (DWORD)ColorSize +
					    (DWORD)BitmapSize +
					    (DWORD)(9*sizeof(WORD));

		if ((hSpace = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,SpaceSize)))
		    {
		    lpHolder = lpSpace = (LPWORD) GlobalLock(hSpace);

		    /* copy over call parameters */
		    *lpSpace++ = wUsage;
		    for (i=0; i<8; i++)
			*lpSpace++ = *lpParm++;

		    /* copy the bitmap header */
		    if (lpBitmapInfo->biSize == sizeof(BITMAPCOREHEADER))
			{
			LPBITMAPINFOHEADER lpDIBInfo;

			lpDIBInfo = (LPBITMAPINFOHEADER) lpSpace;

			lpDIBInfo->biSize = sizeof (BITMAPINFOHEADER);
			lpDIBInfo->biWidth = (DWORD)lpBitmapCore->bcWidth;
			lpDIBInfo->biHeight = (DWORD)lpBitmapCore->bcHeight;
			lpDIBInfo->biPlanes = lpBitmapCore->bcPlanes;
			lpDIBInfo->biBitCount = lpBitmapCore->bcBitCount;

			lpDIBInfo->biCompression = 0;
			lpDIBInfo->biSizeImage = 0;
			lpDIBInfo->biXPelsPerMeter = 0;
			lpDIBInfo->biYPelsPerMeter = 0;
			lpDIBInfo->biClrUsed = 0;
			lpDIBInfo->biClrImportant = 0;

			/* get lpSpace to point at color table location */
			((LPBITMAPINFOHEADER)lpSpace)++;

			/* copy the color table */

			lpBitmapCore++;     /* get to color table */
			if (wUsage == DIB_RGB_COLORS)
			    {
			    for (i=0; i< (ColorSize/(sizeof(RGBQUAD))); i++)
				{
				    /* copy the triple */
				*((RGBTRIPLE FAR *)lpSpace)++ =
				    *((RGBTRIPLE FAR *)lpBitmapCore)++;
				    /* zero out reserved byte */
				*((LPBYTE)lpSpace)++ = 0;
				}
			    }
			else
			    {
			    /* copy over indices */
			    for (i=0; i< (ColorSize/2); i++)
				*lpSpace++ = *((LPWORD)lpBitmapCore)++;
			    }
			}
		    else
			{
			*((LPBITMAPINFOHEADER)lpSpace)++ = *lpBitmapInfo++;

			/* copy the color table */
			for (i=0; i< (ColorSize/2); i++)
			    *lpSpace++ = *((LPWORD)lpBitmapInfo)++;
			}

		    /* copy the actual bits */
		    lpHugeSpace = (HPWORD) lpSpace;
		    for (dwi=0; dwi < (BitmapSize/2); dwi++)
			*lpHugeSpace++ = *lpBits++;

		    status = RecordParms(hMF, magic, (DWORD) (SpaceSize >> 1),
			      (LPWORD) lpHolder);

		    GlobalUnlock(hSpace);
		    GlobalFree(hSpace);
		    }
		}
	        break;

/* **** this should be combined with the above, but to eliminate possible
** **** breakage right before shipping, keep it separate.
*/
	    case (META_STRETCHDIB & 255):
		{
		LPBITMAPINFOHEADER lpBitmapInfo;
		LPBITMAPCOREHEADER lpBitmapCore;    /* used for old DIBs */
		HANDLE	hSpace;
		LPWORD	lpSpace;
		LPWORD	lpHolder;
		DWORD	SpaceSize;
		WORD	ColorSize;
		DWORD	BitmapSize;
		HPWORD	lpBits;
		WORD	wUsage;
		DWORD	dwi;
		HPWORD	lpHugeSpace;
		DWORD	dwROP;

		dwROP = *((LPDWORD)lpParm)++;
		wUsage = *lpParm++;

		lpBitmapInfo = (LPBITMAPINFOHEADER) *((WORD FAR * FAR *) lpParm)++;
		lpBits = (HPWORD) *((WORD FAR * FAR *) lpParm)++;

		/* old style DIB header */
		if (lpBitmapInfo->biSize == sizeof(BITMAPCOREHEADER))
		    {
		    lpBitmapCore = (LPBITMAPCOREHEADER)lpBitmapInfo;

		    if (lpBitmapCore->bcBitCount == 24)
			ColorSize = 0;
		    else
			ColorSize = (1 << lpBitmapCore->bcBitCount) *
			      (wUsage == DIB_RGB_COLORS ?
				    sizeof(RGBQUAD) :
				    sizeof(WORD));

		    /* bits per scanline */
		    BitmapSize = lpBitmapCore->bcWidth *
				    lpBitmapCore->bcBitCount;

		    /* bytes per scanline (rounded to DWORD boundary) */
		    BitmapSize = ((BitmapSize + 31) & (~31)) >> 3;
		    /* bytes for the height of the bitmap */
		    BitmapSize *= lpBitmapCore->bcHeight;
		    }
		/* new style DIB header */
		else
		    {
		    if (lpBitmapInfo->biClrUsed)
			{
			ColorSize = ((WORD)lpBitmapInfo->biClrUsed) *
				    (wUsage == DIB_RGB_COLORS ?
				    sizeof(RGBQUAD) :
				    sizeof(WORD));
			}
		    else if (lpBitmapInfo->biBitCount == 24)
			ColorSize = 0;
		    else
			ColorSize = (1 << lpBitmapInfo->biBitCount) *
			      (wUsage == DIB_RGB_COLORS ?
				    sizeof(RGBQUAD) :
				    sizeof(WORD));

		    /* if biSizeImage is already there and we are
		    ** getting a full image, there is no more work
		    ** to be done.
		    */
		    if (!(BitmapSize = lpBitmapInfo->biSizeImage))
			{
			/* bits per scanline */
			BitmapSize = lpBitmapInfo->biWidth *
				    lpBitmapInfo->biBitCount;
			/* bytes per scanline (rounded to DWORD boundary) */
			BitmapSize = ((BitmapSize + 31) & (~31)) >> 3;
			/* bytes for the height of the bitmap */
			BitmapSize *= (WORD)lpBitmapInfo->biHeight;
			}

		    }

		SpaceSize = (DWORD)sizeof(BITMAPINFOHEADER) + (DWORD)ColorSize +
					    (DWORD)BitmapSize +
					    (DWORD)(11*sizeof(WORD));

		if ((hSpace = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,SpaceSize)))
		    {
		    lpHolder = lpSpace = (LPWORD) GlobalLock(hSpace);

		    /* copy over call parameters */
		    *((LPDWORD)lpSpace)++ = dwROP;
		    *lpSpace++ = wUsage;
		    for (i=0; i<8; i++)
			*lpSpace++ = *lpParm++;

		    /* copy the bitmap header */
		    if (lpBitmapInfo->biSize == sizeof(BITMAPCOREHEADER))
			{
			LPBITMAPINFOHEADER lpDIBInfo;

			lpDIBInfo = (LPBITMAPINFOHEADER) lpSpace;

			lpDIBInfo->biSize = sizeof (BITMAPINFOHEADER);
			lpDIBInfo->biWidth = (DWORD)lpBitmapCore->bcWidth;
			lpDIBInfo->biHeight = (DWORD)lpBitmapCore->bcHeight;
			lpDIBInfo->biPlanes = lpBitmapCore->bcPlanes;
			lpDIBInfo->biBitCount = lpBitmapCore->bcBitCount;

			lpDIBInfo->biCompression = 0;
			lpDIBInfo->biSizeImage = 0;
			lpDIBInfo->biXPelsPerMeter = 0;
			lpDIBInfo->biYPelsPerMeter = 0;
			lpDIBInfo->biClrUsed = 0;
			lpDIBInfo->biClrImportant = 0;

			/* get lpSpace to point at color table location */
			((LPBITMAPINFOHEADER)lpSpace)++;

			/* copy the color table */

			lpBitmapCore++;     /* get to color table */
			if (wUsage == DIB_RGB_COLORS)
			    {
			    for (i=0; i< (ColorSize/(sizeof(RGBQUAD))); i++)
				{
				    /* copy the triple */
				*((RGBTRIPLE FAR *)lpSpace)++ =
				    *((RGBTRIPLE FAR *)lpBitmapCore)++;
				    /* zero out reserved byte */
				*((LPBYTE)lpSpace)++ = 0;
				}
			    }
			else
			    {
			    /* copy over indices */
			    for (i=0; i< (ColorSize/2); i++)
				*lpSpace++ = *((LPWORD)lpBitmapCore)++;
			    }
			}
		    else
			{
			*((LPBITMAPINFOHEADER)lpSpace)++ = *lpBitmapInfo++;

			/* copy the color table */
			for (i=0; i< (ColorSize/2); i++)
			    *lpSpace++ = *((LPWORD)lpBitmapInfo)++;
			}

		    /* copy the actual bits */
		    lpHugeSpace = (HPWORD) lpSpace;
		    for (dwi=0; dwi < (BitmapSize/2); dwi++)
			*lpHugeSpace++ = *lpBits++;

		    status = RecordParms(hMF, magic, (DWORD) (SpaceSize >> 1),
			      (LPWORD) lpHolder);

		    GlobalUnlock(hSpace);
		    GlobalFree(hSpace);
		    }
		}
	        break;

	    case (META_REALIZEPALETTE & 255):
		{
		/* we need to see if the palette has changed since
		** it was selected into the DC.  if so, we need to
		** adjust things with a SetPaletteEntries call
		*/

		status = MakeLogPalette(hMF, npMF->recCurObjects[OBJ_PALETTE-1], META_SETPALENTRIES);

		if (status)
		    status = RecordParms(hMF, META_REALIZEPALETTE, (DWORD)0, (LPWORD) NULL);
		}
		break;

	    case (META_SELECTPALETTE & 255):
	    	lpParm++;		/* skip over fore/back flag */
		npMF->recCurObjects[OBJ_PALETTE-1] = *lpParm; /* pal used in this DC */
		if ((position = RecordObject(hMF, magic, count, lpParm)) != -1)
		    status = RecordParms(hMF, META_SELECTPALETTE, 1UL, &position);
		break;

	    case (META_SELECTOBJECT & 255):
		if (*lpParm)
		    {
		    if ((position = RecordObject(hMF, magic, count, lpParm)) == -1)
			return(FALSE);
		    else
			{
			HANDLE	hObject;

			status = RecordParms(hMF, META_SELECTOBJECT, 1UL, &position);

			/* maintain the new selection in the CurObject table */
			hObject = *lpParm;
			npMF->recCurObjects[GetObjectType(hObject)-1] = hObject;
			}
		    }
		break;

	    case (META_RESETDC & 255):
		status = RecordParms( hMF, magic,
			((LPDEVMODE)lpParm)->dmSize +
			    ((LPDEVMODE)lpParm)->dmDriverExtra,
			lpParm );
		break;

	    case (META_STARTDOC & 255):
		{
		short	iBytes;
		LPSTR	lpSpace;
		LPSTR	lpsz;
		short	n;

		lpsz = (LPSTR)lpParm;	  // point to lpDoc
		n = lstrlen((LPSTR)lpsz + 2) + 1;
		iBytes = n + lstrlen((LPSTR)lpsz + 6) + 1;

		lpSpace = (char *) LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT,iBytes);
		lstrcpy(lpSpace, (LPSTR)lpsz + 2);
		lstrcpy(lpSpace + n + 1, lpsz + 6);
		status = RecordParms(hMF, magic, (DWORD)(iBytes >> 1), (LPWORD)lpSpace);
		LocalFree((HANDLE)(DWORD)lpSpace);
		}
		break;

	    }
	    return(status);
	}
    }
}  /* RecordOther */


/***************************** Internal Function ***************************\
* RecordObject
*
* Records the use of an object by creating the object
*
* Returns: index of object in table
*
*
\***************************************************************************/

int INTERNAL RecordObject(HANDLE hMF, WORD magic, WORD count, LPWORD lpParm)
{
    LPBITMAPINFOHEADER lpDIBInfo ;
    WORD	status;
    WORD	position;
    HANDLE	hObject;
    WORD	objType;
    BYTE	bBitsPerPel;
    WORD	wColorTableSize;
    DWORD	iBits ;
    WORD	i;
    HANDLE	hSpace = NULL ;
    LPWORD	lpSpace;
    LPWORD	lpTemp ;
    BYTE	objBuf[MAXOBJECTSIZE];


    dprintf( 6,"  RecordObject 0x%X", magic);

    hObject = *lpParm;				       

    hMF = MAKEMETADC(hMF);
    ASSERTGDI( IsMetaDC(hMF), "RecordObject: Expects only valid metafiles");

    // Add the object to the metafiles list
    if ((status = AddToTable(hMF,  hObject, (LPWORD) &position, TRUE)) == -1)
	return(status);
    else if (status == FALSE)
	{
	objType = GetObjectAndType( hObject, objBuf );

	switch (objType)
	    {
	    case OBJ_PEN:
		status = RecordParms(hMF, META_CREATEPENINDIRECT,
				  (DWORD)((sizeof(LOGPEN) + 1) >> 1), 

				  (LPWORD)objBuf );
		break;

	    case OBJ_FONT:
		/* size of LOGFONT adjusted based on the length of the facename */
		status = RecordParms(hMF, META_CREATEFONTINDIRECT,
			    (DWORD)((1 + lstrlen((LPSTR) ((LPLOGFONT)objBuf)->lfFaceName) +
			    sizeof(LOGFONT) - LF_FACESIZE + 1) >> 1),
				  (LPWORD) objBuf);
		break;

/*
!!! in win2, METACREATEREGION records contained an entire region object, 
!!! including the full header.  this header changed in win3.  
!!!
!!! to remain compatible, the region records will be saved with the
!!! win2 header.  here we save our region with a win2 header.
*/
	    case OBJ_RGN:
		{
                LPWIN3REGION lpw3rgn = (LPWIN3REGION)NULL;
                DWORD       cbNTRgnData;
                WORD        sel;
                DWORD       curRectl = 0;
                WORD        cScans = 0;
                WORD        maxScanEntry = 0;
                WORD        curScanEntry;
                WORD        cbw3data;
                LPRGNDATA   lprgn = (LPRGNDATA)NULL;
                LPRECTL     lprcl;
                LPSCAN      lpScan;

                status = FALSE;         // just in case something goes wrong

                // Get the NT Region Data
                cbNTRgnData = GetRegionData( hObject, 0, NULL );
                if (cbNTRgnData == 0)
                    break;

                sel = GlobalAlloc( GMEM_FIXED, cbNTRgnData);
                if (!sel)
                    break;

                lprgn = (LPRGNDATA)MAKELONG(0, sel);

                cbNTRgnData = GetRegionData( hObject, cbNTRgnData, lprgn );
                if (cbNTRgnData == 0)
                    break;

                lprcl = (LPRECTL)lprgn->Buffer;

                // Create the Windows 3.x equivalent

                // worst case is one scan for each rect
                cbw3data = 2*sizeof(WIN3REGION) + (WORD)lprgn->rdh.nCount*sizeof(SCAN);

                sel = GlobalAlloc( GMEM_FIXED, cbw3data);
                if (!sel)
                    break;

                lpw3rgn = (LPWIN3REGION)MAKELONG(0, sel);
                GetRgnBox( hObject, &lpw3rgn->rcBounding );

                cbw3data = sizeof(WIN3REGION) - sizeof(SCAN) + 2;

                // visit all the rects
                lpScan = lpw3rgn->aScans;
                while(curRectl < lprgn->rdh.nCount)
                {
                    LPWORD  lpXEntry;
                    WORD    cbScan;

                    curScanEntry = 0;       // Current X pair in this scan

                    lpScan->scnPntTop    = (WORD)lprcl[curRectl].yTop;
                    lpScan->scnPntBottom = (WORD)lprcl[curRectl].yBottom;

                    lpXEntry = lpScan->scnPntsX;

                    // handle rects on this scan
                    do
                    {
                        lpXEntry[curScanEntry + 0] = (WORD)lprcl[curRectl].xLeft;
                        lpXEntry[curScanEntry + 1] = (WORD)lprcl[curRectl].xRight;
                        curScanEntry += 2;
                        curRectl++;
                    } while ( (curRectl < lprgn->rdh.nCount)
                            && (lprcl[curRectl-1].yTop    == lprcl[curRectl].yTop)
                            && (lprcl[curRectl-1].yBottom == lprcl[curRectl].yBottom)
                            );

                    lpScan->scnPntCnt      = curScanEntry;
                    lpXEntry[curScanEntry] = curScanEntry;  // Count also follows Xs
                    cScans++;

                    if (curScanEntry > maxScanEntry)
                        maxScanEntry = curScanEntry;

                    // account for each new scan + each X1 X2 Entry but the first
                    cbScan = sizeof(SCAN)-(sizeof(WORD)*2) + (curScanEntry*sizeof(WORD));
                    cbw3data += cbScan;
                    lpScan = (LPSCAN)(((LPBYTE)lpScan) + cbScan);
                }

                // Initialize the header
                lpw3rgn->nextInChain = 0;
                lpw3rgn->ObjType = 6;           // old Windows OBJ_RGN identifier
                lpw3rgn->ObjCount= 0x2F6;
                lpw3rgn->cbRegion = cbw3data;   // don't count type and next
                lpw3rgn->cScans = cScans;
                lpw3rgn->maxScan = maxScanEntry;

		status = RecordParms(hMF, META_CREATEREGION,
                        cbw3data-1 >> 1,  // Convert to count of words
                        (LPWORD) lpw3rgn);

                GlobalFree( HIWORD(lprgn) );
                GlobalFree( HIWORD(lpw3rgn) );
		}

		break;


	    case OBJ_BRUSH:
		switch (((LPLOGBRUSH)objBuf)->lbStyle)
		    {
		    case BS_DIBPATTERN:
			{
			WORD	cbDIBBits;
			BITMAP	logBitmap;

			/* get the pattern DIB */
			GetObject( (HANDLE)((LPLOGBRUSH)objBuf)->lbHatch, sizeof(BITMAP), (LPSTR)&logBitmap );

			cbDIBBits = logBitmap.bmWidthBytes * logBitmap.bmHeight;
			if ((hSpace = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,(LONG)(cbDIBBits + 4))))
			    {
			    lpTemp = lpSpace = (LPWORD)GlobalLock (hSpace) ;

			    /* mark this as a DIB pattern brush */
			    *lpSpace++ = BS_DIBPATTERN;

			    /* set the usage word */
			    *lpSpace++ = (WORD)((LPLOGBRUSH)objBuf)->lbColor;

	      //	    lpPackedDIB = (LPWORD)GlobalLock(hPatBits);

			    /* copy the bits to the new buffer */
			    for (i = 0; i < (cbDIBBits >> 1); i++)
				*lpSpace++ = *logBitmap.bmBits++;

			    status = RecordParms (hMF, META_DIBCREATEPATTERNBRUSH,
					    (DWORD)(cbDIBBits >> 1) + 2, (LPWORD)lpTemp);

			    /* release the allocated space */
			    GlobalUnlock (hSpace) ;
			    GlobalFree (hSpace) ;
			    }
			}
			break;

		    case BS_PATTERN:
			{
			BITMAP	logBitmap;

			if (GetObject((HANDLE)((LPLOGBRUSH)objBuf)->lbHatch, sizeof(logBitmap), (LPSTR)&logBitmap))
			    {
			    /* allocate space for the device independent bitmap */
			    if (hSpace = AllocateSpaceForDIB (&logBitmap,
						    (LPBYTE)&bBitsPerPel,
						    (LPWORD) &wColorTableSize ,
						    (LPDWORD) &iBits))
				{
				/* get a pointer to the allocated space */
				lpTemp = lpSpace = (LPWORD) GlobalLock (hSpace) ;

				/* mark this as a normal pattern brush */
				*lpSpace++ = BS_PATTERN;

				/* use RGB colors */
				*lpSpace++ = DIB_RGB_COLORS;

				/* this also will be a pointer to the DIB header */
				lpDIBInfo = (LPBITMAPINFOHEADER) lpSpace ;

				/* prepare the header of the bitmap and get a pointer to the
				    start of the area which is to hold the bits */
				lpSpace = InitializeDIBHeader (lpDIBInfo,
						&logBitmap, bBitsPerPel, wColorTableSize);

				/* convert the bits into the DIB format */
				// !!! validate that the DC is ignored
				GetDIBits (hScreenDC, (HBITMAP)((LPLOGBRUSH)objBuf)->lbHatch,
					0, logBitmap.bmHeight,
					(LPSTR) lpSpace, (LPBITMAPINFO)lpDIBInfo,0) ;

				/* now	record the Header and Bits as parameters */
				status = RecordParms (hMF, META_DIBCREATEPATTERNBRUSH,
						(DWORD)(iBits >> 1) + 2, (LPWORD) lpTemp);

				/* release the allocated space */
				GlobalUnlock (hSpace) ;
				GlobalFree (hSpace) ;
				}
			    }
			}
			break;

		    default:
			/* non-pattern brush */
			status = RecordParms(hMF, META_CREATEBRUSHINDIRECT,
		    		      (DWORD)((sizeof(LOGBRUSH) + 1) >> 1), 
				      (LPWORD)objBuf);
			break;
		    }  /* Brush Type switch */
		break;	/* Brush object case */

	    case OBJ_PALETTE:
		status = MakeLogPalette(hMF, hObject, META_CREATEPALETTE);
	    break;

	    default:
		ASSERTGDIW( 0, "unknown case RecordObject: %d", objType );
		break;
	    }
// RecordObj10:
	}

    ASSERTGDI( status == TRUE, "RecordObject: Failing");
    return ((status == TRUE) ? position : -1);
} /* RecordObject */


/***************************** Internal Function ***************************\
* ProbeSize
*
* Determines if there is sufficient space for metafiling the dwLength
* words into the memory metafile
*
* Returns: a global handle of where next metafile is to be recorded
*	   or FALSE if unable to allocate more memory
*
\***************************************************************************/

HANDLE INTERNAL ProbeSize(NPMETARECORDER npMF, DWORD dwLength)
{
    DWORD   nWords;
    DWORD   totalWords;
    BOOL    status = FALSE;
    HANDLE  hand;

    GdiLogFunc3( "  ProbeSize");

    if (npMF->hMetaData == NULL)
	{
	nWords = ((DWORD)DATASIZE > dwLength) ? (DWORD)DATASIZE : dwLength;
	totalWords = (nWords * sizeof(WORD)) + sizeof(METAHEADER);
	if (npMF->hMetaData = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, totalWords))
	    {
	    npMF->sizeBuffer = nWords;
	    npMF->recFilePosition = 0;
	    status = TRUE;
	    }
	}
    else if(npMF->sizeBuffer < (npMF->recFilePosition + dwLength))
	{
	nWords = ((DWORD)DATASIZE > dwLength) ? (DWORD)DATASIZE : dwLength;
	nWords += npMF->sizeBuffer;
	totalWords = (nWords * sizeof(WORD)) + sizeof(METAHEADER);
	if (hand = GlobalReAlloc(npMF->hMetaData, totalWords, GMEM_MOVEABLE))
	    {
	    npMF->hMetaData = hand;
	    npMF->sizeBuffer = nWords;
	    status = TRUE;
	    }
	}
    else
	{
	status = TRUE;
	}
    return ((status) ? npMF->hMetaData : NULL);
}


/***************************** Internal Function ***************************\
* AddToTable
*
* Add an object (brush, pen...) to a list of objects associated with the
* metafile.
*
*
*
* Returns: TRUE if object is already in table
*	   FALSE if object was just added to table
*	   -1 if failure
*
* Remarks
*   bAdd is TRUE iff the object is being added otherwise it is being deleted
*
\***************************************************************************/

WORD INTERNAL AddToTable(HANDLE hMF, HANDLE hObject, LPWORD pPosition, BOOL bAdd)
{
    NPMETARECORDER  npMF;
    WORD	    iEmptySpace = -1;
    WORD	    i;
    WORD	    status = -1;
    HANDLE	    hTable;
    OBJECTTABLE    *pHandleTable;


    GdiLogFunc2("  AddToTable");

    if ((hMF = GetPMetaFile(hMF)) != -1 )
	{
	npMF = (NPMETARECORDER) LocalLock(hMF);

	if (hTable = npMF->hObjectTable)
	    {
	    pHandleTable = (NPOBJECTTABLE) LMHtoP(hTable);
	    for (i = 0; i < npMF->recordHeader.mtNoObjects; ++i)
		{
		if (hObject == pHandleTable[i].objectCurHandle )  //!!!!! used to be check unique ID#
		    {
		    *pPosition = i;
		    status = TRUE;

		    // if we are doing a METADELETEOBJECT.
		    //	delete object from table
		    if (!bAdd)
			{
			pHandleTable[i].objectIndex = NULL;
			pHandleTable[i].objectCurHandle = NULL;
			}
		    goto AddToTable10;
		    }

    /* if the entry has been deleted, we want to add a new object 
    ** in its place.  iEmptySpace will tell us where that place is.
    */
		else if ((pHandleTable[i].objectIndex == NULL) && (iEmptySpace == -1))
		    iEmptySpace = i;
		}
	    }

	if (bAdd)
	    {
	    // If there is no object table for this MetaFile then Allocate one.
	    if (hTable == NULL)
		{
		npMF->hObjectTable = hTable = LocalAlloc(LMEM_MOVEABLE, sizeof(OBJECTTABLE));
		}
	    else if (iEmptySpace == -1)
		hTable = LocalReAlloc(hTable, (npMF->recordHeader.mtNoObjects + 1)
					  * sizeof(OBJECTTABLE), LMEM_MOVEABLE);

	    if (hTable)
		{
		pHandleTable = (NPOBJECTTABLE) LMHtoP(hTable);
		if (iEmptySpace == -1)
		    *pPosition = npMF->recordHeader.mtNoObjects++;
		else
		    *pPosition = iEmptySpace;
		pHandleTable[*pPosition].objectIndex = hObject; //!!!!! pObjHead->ilObjCount;
		pHandleTable[*pPosition].objectCurHandle = hObject;
		status = FALSE;
		}
	    }
AddToTable10:;
	LocalUnlock(hMF);
	}

    ASSERTGDI( status != -1, "AddToTable: Failing");
    return(status);
}

#if 0 // this is going to gdi.dll

/***************************** Internal Function **************************\
* HDC GDIENTRY CreateMetaFile
*
* Creates a MetaFile DC
*
*
* Effects:
*
\***************************************************************************/

HDC GDIENTRY CreateMetaFile(LPSTR lpFileName)
{
    BOOL	    status=FALSE;
    GLOBALHANDLE    hMF;
    NPMETARECORDER  npMF;

    GdiLogFunc("CreateMetaFile");

    if (hMF = LocalAlloc(LMEM_MOVEABLE|LMEM_ZEROINIT, sizeof(METARECORDER)))
	{
	npMF = (NPMETARECORDER) LocalLock(hMF);
	npMF->metaDCHeader.ilObjType	= OBJ_METAFILE;
	npMF->metaDCHeader.ident	= ID_METADC;

	npMF->recordHeader.mtHeaderSize = HEADERSIZE;
	npMF->recordHeader.mtVersion	= METAVERSION;
	npMF->recordHeader.mtSize	= HEADERSIZE;

	if (lpFileName)
	    {
	    npMF->recordHeader.mtType = DISKMETAFILE;
	    if (((npMF->recFileNumber = OpenFile(lpFileName,
						(LPOFSTRUCT) &(npMF->recFileBuffer),
						OF_CREATE|READ_WRITE)) 
					!= -1)
	    && (_lwrite(npMF->recFileNumber, (LPSTR)npMF, sizeof(METAHEADER))
	    		== sizeof(METAHEADER)))
		{
		status = TRUE;
		}
	    if (npMF->recFileNumber != -1)
		{
		if (!(npMF->recFileBuffer.fFixedDisk))
		    _lclose(npMF->recFileNumber);
		}

	    if (!MetaCache.hCache)
		{
	    	MetaCache.hCache = AllocBuffer(&MetaCache.wCacheSize);
		MetaCache.wCacheSize >>= 1;
		MetaCache.hMF = hMF;
		MetaCache.wCachePos = 0;
		}
	    }

	else
	    {
	    npMF->recordHeader.mtType = MEMORYMETAFILE;
	    status = TRUE;
	    }
	}

    // If successfull then add the metafile to the linked list
    if( status != FALSE )
	{
	if( hFirstMetaFile == 0 )
	    {
	    hFirstMetaFile = hMF;
	    }
	else
	    {
	    npMF->metaDCHeader.nextinchain = hFirstMetaFile;
	    hFirstMetaFile = hMF;
	    }
	LocalUnlock( hMF );
	}

    return ((status) ? MAKEMETADC(hMF) : FALSE);
}


/***************************** Internal Function **************************\
* HANDLE GDIENTRY CloseMetaFile
*
* The CloseMetaFile function closes the metafile device context and creates a
* metafile handle that can be used to play the metafile by using the
* PlayMetaFile function.
*
* Effects:
*
\***************************************************************************/

HANDLE GDIENTRY CloseMetaFile(HANDLE hdc)
{
    BOOL	    status = FALSE;
    HANDLE	    hMetaFile=NULL;
    LPMETADATA	    lpMetaData;
    LPMETAFILE	    lpMFNew;
    WORD	    fileNumber;
    NPMETARECORDER  npMF;
    DWORD	    metafileSize;
    LPWORD	    lpCache;
    HANDLE	    hMF;
    HANDLE	    hMFSearch;
    int		    rc;

    GdiLogFunc("CloseMetaFile");

    hMF = HANDLEFROMMETADC(hdc);

    if (hMF && RecordParms(hMF, 0, (DWORD)0, (LONG)0))
	{

	npMF = (NPMETARECORDER)LocalLock(hMF);
	if (!(npMF->recFlags & METAFILEFAILURE))
	    {
	    if (npMF->recordHeader.mtType == MEMORYMETAFILE)
		{
		lpMetaData = (LPMETADATA) GlobalLock(npMF->hMetaData);
		lpMetaData->dataHeader = npMF->recordHeader;
		metafileSize = (npMF->recordHeader.mtSize * sizeof(WORD))
				+ sizeof(METAHEADER);
		GlobalUnlock(hMetaFile = npMF->hMetaData);
		if (!(status = (BOOL) GlobalReAlloc(hMetaFile,
						 (LONG)metafileSize, 
						 GMEM_MOVEABLE)))
		    GlobalFree(hMetaFile);
		}
	    else
		/* rewind the file and write the header out */
		if (hMetaFile = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,(LONG) sizeof(METAFILE)))
		    {
		    lpMFNew = (LPMETAFILE) GlobalLock(hMetaFile);
		    lpMFNew->MetaFileHeader = npMF->recordHeader;
		    npMF->recordHeader.mtType = MEMORYMETAFILE;
		    if (npMF->recFileBuffer.fFixedDisk)
			fileNumber = npMF->recFileNumber;
		    else
			{
			if ((fileNumber = OpenFile((LPSTR) npMF->recFileBuffer.szPathName,
				    (LPOFSTRUCT) &(npMF->recFileBuffer),
				    OF_PROMPT | OF_REOPEN | READ_WRITE))
				    == -1)
			    {
			    GlobalUnlock(hMetaFile);
			    GlobalFree(hMetaFile);
			    LocalUnlock(hMF);

			    if (MetaCache.hMF == hMF)
				{
				GlobalFree(MetaCache.hCache);
				MetaCache.hCache = MetaCache.hMF = 0;
				}

			    goto errCloseMetaFile;
			    }
			}

		    if (MetaCache.hCache && MetaCache.hMF == hMF)
			{
		    	_llseek(fileNumber, (LONG) 0, 2);
			lpCache = (LPWORD) GlobalLock(MetaCache.hCache);
			rc = (MetaCache.wCachePos) ?
			     AttemptWrite(hMF,
					  fileNumber, 
					  (DWORD)(MetaCache.wCachePos << 1), 
					  (LPSTR) lpCache)
			     : TRUE;
			GlobalUnlock(MetaCache.hCache);
			GlobalFree(MetaCache.hCache);
			MetaCache.hCache = MetaCache.hMF = 0;

			if (!rc)
			    {
			    MarkMetaFile(hMF);
			    goto errCloseMetaFile;
			    }
			}

		    _llseek(fileNumber, (LONG) 0, 0);
		    if(_lwrite(fileNumber, (LPSTR) (&npMF->recordHeader),
				sizeof(METAHEADER)) == sizeof(METAHEADER))
			{
			status = TRUE;
			}
		    lpMFNew->MetaFileBuffer = npMF->recFileBuffer;
		    _lclose(fileNumber);
		    GlobalUnlock(hMetaFile);
		    }

	    if (npMF->hObjectTable)
		{
		LocalFree((HANDLE) npMF->hObjectTable);
		}
	    }

	/* Remove the meta file from the list of active metafiles */
	hMFSearch = hFirstMetaFile;

	if( hFirstMetaFile == hMF )
	    {
	    hFirstMetaFile = npMF->metaDCHeader.nextinchain;
	    }
	else
	    {
	    while( hMFSearch )
		{
		NPMETARECORDER npMFSearch;
		HANDLE	       hNext;

		npMFSearch = (NPMETARECORDER)LocalLock(hMFSearch);
		hNext = npMFSearch->metaDCHeader.nextinchain;
		if( hNext == hMF )
		    {
		    npMFSearch->metaDCHeader.nextinchain =
			    npMF->metaDCHeader.nextinchain;
		    }
		else
		    {
		    hNext = npMFSearch->metaDCHeader.nextinchain;
		    }
		LocalUnlock(hMFSearch);
		hMFSearch = hNext;
		}
	    }
	LocalUnlock(hMF);
	LocalFree(hMF);
	}

errCloseMetaFile:
    return ((status) ? hMetaFile : FALSE);
}


/***************************** Internal Function **************************\
* CopyMetaFile(hSrcMF, lpFileName)
*
*    Copies the metafile (hSrcMF) to a new metafile with name lpFileName. The
*    function then returns a handle to this new metafile if the function was
*    successful.
*
* Retuns      a handle to a new metafile, 0 iff failure
*
* IMPLEMENTATION:
*     The source and target metafiles are checked to see if they are both memory
*     metafile and if so a piece of global memory is allocated and the metafile
*     is simply copied.
*     If this is not the case CreateMetaFile is called with lpFileName and then
*     records are pulled out of the source metafile (using GetEvent) and written
*     into the destination metafile one at a time (using RecordParms).
*
*     Lock the source
*     if source is a memory metafile and the destination is a memory metafile
*	  alloc the same size global memory as the source
*	  copy the bits directly
*     else
*	  get a metafile handle by calling CreateMetaFile
*	  while GetEvent returns records form the source
*	      record the record in the new metafile
*
*	  close the metafile
*
*     return the new metafile handle
*
\***************************************************************************/

HANDLE GDIENTRY CopyMetaFile(HANDLE hSrcMF, LPSTR lpFileName)
{
    DWORD	    i;
    DWORD	    iBytes;
    LPMETAFILE	    lpMF;
    LPMETAFILE	    lpDstMF;
    LPMETARECORD    lpMR = NULL;
    HANDLE	    hTempMF;
    HANDLE	    hDstMF;
    NPMETARECORDER  pDstMF;
    WORD            state;

    GdiLogFunc( "CopyMetaFile" );

    if (!IsValidMetaFile(hSrcMF))
        return NULL;

    if (hSrcMF && (lpMF = (LPMETAFILE) GlobalLock(hSrcMF)))
	{
    	state = (lpMF->MetaFileHeader.mtType == MEMORYMETAFILE) ? 0 : 2;
	state |= (lpFileName) ? 1 : 0;

	switch (state)
	    {
	    case 0: /* memory -> memory */
		iBytes = GlobalSize(hSrcMF);
		if (hDstMF = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, (DWORD) iBytes))
		    {
		    lpDstMF = (LPMETAFILE) GlobalLock(hDstMF);
		    iBytes = iBytes/2;	 /* get WORD count */
		    for (i = 0; i < iBytes; ++i)
		       *((WORD huge *) lpDstMF)++ = *((WORD huge *) lpMF)++;

		    GlobalUnlock(hDstMF);
		    }
	    break;

	    case 3: /* disk -> disk */
		hDstMF = CopyFile(lpMF->MetaFileBuffer.szPathName,
				 lpFileName)
			    ? GetMetaFile(lpFileName) : NULL;
		break;

	    case 1:
	    case 2:
		if (hDstMF = CreateMetaFile(lpFileName))
		    {
		    while (lpMR = GetEvent(lpMF, lpMR, FALSE))
			if (!RecordParms(hDstMF, lpMR->rdFunction,
				      lpMR->rdSize - 3,
				      (LPWORD) lpMR->rdParm))
			    {
			    MarkMetaFile(hDstMF);
			    LocalFree(hDstMF);
			    goto CopyMetaFile10;
			    }
		    pDstMF = (NPMETARECORDER) NPFROMMETADC(hDstMF);
		    pDstMF->recordHeader = lpMF->MetaFileHeader;

		    pDstMF->recordHeader.mtType = (lpFileName) ? DISKMETAFILE
								: MEMORYMETAFILE;

		    hDstMF = (hTempMF = CloseMetaFile(hDstMF)) ? hTempMF : NULL;

		    }
		break;
	    }

CopyMetaFile10:;
	GlobalUnlock(hSrcMF);
	}
    return(hDstMF);
}			    


/***************************** Internal Function ***************************\
* HANDLE GDIENTRY GetMetaFileBits(HANDLE hMF)
*
* The GetMetaFileBits function returns a handle to a global memory block that
* contains the specified metafile as a collection of bits. The memory block
* can be used to determine the size of the metafile or to save the metafile as
* a file. The memory block should not be modified.
*
* Effects:
*
\***************************************************************************/

HANDLE GDIENTRY GetMetaFileBits(HANDLE hMF)
{
    GdiLogFunc( "GetMetaFileBits");

/*  6/3/88 t-kensy: This code does nothing, except make sure hMF is valid 
    BOOL	status = FALSE;
    LPMETAFILE	lpMF;

    if (hMF && (lpMF = (LPMETAFILE) GlobalLock(hMF)))
	{
	if (lpMF->MetaFileHeader.mtType == MEMORYMETAFILE)
	    {
	    if (hMF = GlobalReAlloc(hMF, GlobalSize(hMF), 
	    			    GLOBALMOVABLENONSHARED))
		status = TRUE;
	    }
	GlobalUnlock(hMF);
	}
    return(status ? hMF : status);
*/
    return (GlobalHandle(hMF) & 0xffff) ? hMF : FALSE;
}


/***************************** Internal Function **************************\
* HANDLE GDIENTRY SetMetaFileBits(HANDLE hMF)
*
*
*
* Effects:
*
\***************************************************************************/

HANDLE GDIENTRY SetMetaFileBits(HANDLE hBits)
{
    GdiLogFunc( "SetMetaFileBits");

/*    return (GlobalReAlloc(hBits, GlobalSize(hBits), GLOBALMOVABLE));*/


//---------------------------------------------------------------------------------
// We will make GDI take over the ownership of this memory block. This is
// done to help OLE, where either the server or the client could end while 
// the other still had the handle to the memory block. This will prevent
// the block to dissapear after the creator exits. The strategy could be
// changed if this causes memory leaks with other application.
//
// Amit Chatterjee. 6/18/91.
//---------------------------------------------------------------------------------

    return (GlobalReAlloc (hBits, 0L, GMEM_MODIFY | GMEM_DDESHARE)) ;
}
#endif // this is going to gdi.dll


/***************************** Internal Function **************************\
* CopyFile
*
*
* Returns  TRUE iff success
*
*
\***************************************************************************/

BOOL INTERNAL CopyFile(LPSTR lpSFilename, LPSTR lpDFilename)
{
    int 	ihSrc, ihDst, iBufferSize;
    int 	iBytesRead;
    OFSTRUCT	ofStruct;
    HANDLE	hBuffer;
    LPSTR	lpBuffer;
    BOOL	fUnlink = FALSE;

    GdiLogFunc3( "CopyFile");

    /* Open the source file for reading */
    if ((ihSrc = OpenFile(lpSFilename, &ofStruct, READ)) == -1)
	goto CopyError10;

    /* Open the destination file for writing */
    if ((ihDst = OpenFile(lpDFilename, &ofStruct, OF_CREATE |
						  WRITE))
			    == -1)
	goto CopyError20;

    /* Get a buffer to transfer the file with */
    if (!(hBuffer = AllocBuffer((LPWORD)&iBufferSize)))
	goto CopyError30;

    /* Lock the buffer and get a pointer to the storage */
    if (!(lpBuffer = GlobalLock(hBuffer)))
	goto CopyError40;

    /* Copy the file, reading chunks at a time into the buffer */
    do
	{
	if ((iBytesRead = _lread(ihSrc, lpBuffer, iBufferSize))
		== -1)
		goto CopyError40;

	if (_lwrite(ihDst, lpBuffer, iBytesRead) != (WORD)iBytesRead)
		goto CopyError40;
	} while (iBytesRead == iBufferSize);

#ifdef	FIREWALL
    /*	if we are able to read anything from the source file at this
     *	point, then something is wrong!
     */
    if (_lread(ihSrc, lpBuffer, iBufferSize))
	{
	fUnlink = TRUE;
	goto CopyError40;
	}
#endif

    /* Everything's fine.  Close up and exit successfully */
    if (_lclose(ihSrc) == -1 || _lclose(ihDst) == -1)
	goto CopyError40;

    GlobalUnlock(hBuffer);
    GlobalFree(hBuffer);

    return TRUE;

/* Error exit points */
CopyError40:;
    GlobalUnlock(hBuffer);
    GlobalFree(hBuffer);
CopyError30:;
    _lclose(ihDst);
    if (fUnlink)
	OpenFile(lpDFilename, &ofStruct, OF_DELETE);

CopyError20:;
    _lclose(ihSrc);

CopyError10:;
    return FALSE;
}


/***************************** Internal Function **************************\
* AllocateSpaceForDIB
*
* The following routine takes as input a device dependent bitmap structure
* and calculates the size needed to store the corresponding DIB structure
* including the DIB bits. It then proceeds to allocate space for it and
* returns a HANDLE to the caller (HANDLE could be NULL if allocation fails)
*
* Returns a global handle to memory or FALSE
*
\***************************************************************************/

HANDLE INTERNAL AllocateSpaceForDIB (lpBitmap, pbBitsPerPel, pwColorTableSize,
				      pdwcBits )
LPBITMAP    lpBitmap ;
LPBYTE	    pbBitsPerPel ;
LPWORD	    pwColorTableSize;
LPDWORD     pdwcBits ;
{
    int     InputPrecision ;
    DWORD   iBits ;

    GdiLogFunc3( "  AllocateSpaceForDIB");

    /* calculate the number of bits per pel that we are going to have in
       the DIB format. This value should correspond to the number of planes
       and bits per pel in the device dependent bitmap format */


    /* multiply the number of planes and the bits pel pel in the device
       dependent bitmap */

    InputPrecision = lpBitmap->bmPlanes * lpBitmap->bmBitsPixel ;


    /* DIB precision should be more than or equal this precison, though
	   the limit is 24 bits per pel */

    if (InputPrecision == 1)
	{
	*pbBitsPerPel = 1 ;
	*pwColorTableSize = 2 * sizeof (RGBQUAD) ;
	}
    else if (InputPrecision <= 4)
	{
	*pbBitsPerPel = 4 ;
	*pwColorTableSize = 16 * sizeof (RGBQUAD) ;
	}
    else if (InputPrecision <= 8)
	{
	*pbBitsPerPel = 8 ;
	*pwColorTableSize = 256 * sizeof (RGBQUAD) ;
	}
    else
	{
	*pbBitsPerPel = 24 ;
	*pwColorTableSize = 0 ;
	}

/*--------------------------------------------------------------------------**
** calulate the size of the DIB. Each scan line is going to be a mutiple of **
** a DWORD. Also we shall need to allocate space for the color table.       **
**--------------------------------------------------------------------------*/

    /* get the number of bits we need for a scanline */
    iBits = lpBitmap->bmWidth * (*pbBitsPerPel);
    iBits = (iBits + 31) & (~31) ;

    /* convert to number of bytes and get the size of the DIB */
    iBits = (iBits >> 3) * lpBitmap->bmHeight ;

    /* add the space needed for the color table */
    iBits += *pwColorTableSize ;

    /* add the size for the BITMAPINFOHeader */
    iBits += sizeof(BITMAPINFOHEADER) ;

    /* return back the value for iBits */
    *pdwcBits = iBits ;

    /* actually allocate about 100 bytes more for params */
    iBits += 100 ;

/*--------------------------------------------------------------------------**
** alocate space for the bitmap info header, the color table and the bits   **
** Return the value of the HANDLE.														 **
**--------------------------------------------------------------------------*/

    return (GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE,(LONG) iBits)) ;
}


/***************************** Internal Function **************************\
* InitializeDIBHeader
*
* This function takes as input a pointer to a BITMAPINFO header structure
* and a pointer to a device dependendent bitmap pointer together with the
* number of bitsperpel requested for the DIB and the color table size. It
* initializes the DIB header and returns a pointer pointing to the first
* word after the color table.														   **
*
\***************************************************************************/

LPWORD INTERNAL InitializeDIBHeader (lpDIBInfo, lpBitmap, bBitsPerPel, wColorTableSize)

LPBITMAPINFOHEADER lpDIBInfo ;
LPBITMAP    lpBitmap ;
BYTE	    bBitsPerPel ;
WORD	    wColorTableSize ;

{
    LPBYTE lpSpace ;

    GdiLogFunc3( "  InitializeDIBHeader");

    /* Initialize the fields till the start of the color table */
    lpDIBInfo->biSize	  = sizeof (BITMAPINFOHEADER) ;
    lpDIBInfo->biWidth	  = (DWORD)lpBitmap->bmWidth ;
    lpDIBInfo->biHeight   = (DWORD)lpBitmap->bmHeight ;
    lpDIBInfo->biPlanes   = 1 ;
    lpDIBInfo->biBitCount = (WORD) bBitsPerPel ;

    lpDIBInfo->biCompression   = 0;
    lpDIBInfo->biSizeImage     = 0;
    lpDIBInfo->biXPelsPerMeter = 0;
    lpDIBInfo->biYPelsPerMeter = 0;
    lpDIBInfo->biClrUsed       = 0;
    lpDIBInfo->biClrImportant  = 0;

    /* take the pointer past the HEADER and cast it to a BYTE ptr */
    lpDIBInfo ++ ;
    lpSpace = (LPBYTE) lpDIBInfo ;

    /* take the pointer past the color table structure */
    lpSpace += wColorTableSize ;

    /* return this pointer as a WORD pointer */
    return ((LPWORD) lpSpace) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\sort.asm ===
;----------------------M O D U L E    H E A D E R----------------------------;
;      									     ;
; Module Name:       SORT.ASM  						     ;
; 								             ;
; History:           SORT.C						     ; 
;                             Created by    Charles Whitmer    12/30/1986    ;
;                             Modified by   Mitchel B. London  08/05/1987    ;
;								             ;
;                    SORT.ASM - translation of SORT.C                        ;
;                             CreateModule  David Weise                      ;
;                             Other Modules Amit Chatterjee    08/09/1988    ;
; 									     ;
; Copyright (c) 1985 - 1988 Microsoft Corporation		             ;
;								             ;
; General Description:							     ;
;                     							     ;
;         The SORT module creates and maintains a tree of nodes, each node   ;
;         having a KEY value and a TAG field. The KEY field is used to or-   ;
;         -ganize the tree into a heap.                                      ;
;                  The heap tree is implemented using an array, where if     ;
;         parent node occurs in position i, its left child will be at index  ;
;         (2 * i) and the right chaild at  index (2 * i + 1).                ;
;                  The Module ensures that at any instant, the root node     ;
;         of any subtree has the least key value in the subtree.             ;
;                  First few positions in the array are used for storing     ;
;         a header for the tree.				             ;
;									     ;
; SubModules:								     ;
;           								     ;
;         1.  CreatePQ:    						     ;
;                        Allocates space for the heaptree and its header     ;
;                        and initializes the header.		             ;
;         2.  InsertPQ:							     ;
;                        Inserts a node into the heap ensuring that the heap ;
;                        property is not violated.		             ;
;         3.  MinPQ: 							     ;
;                        Returns the tag value associated with the lowest    ;
;                        key in the heap. (node is not deleted)              ;
;         4.  ExtractPQ:					             ;
;                        Return the tag value associated with the lowest key ;
;                        in the heap and deletes the node. The heap is then  ;
;                        reconstructed with the remaining nodes.             ;
;         5.  DeletePQ:						             ;
;                        Deletes the entire heap by freeing the allocated    ;
;                        area.						     ;
;         6.  SizePQ:							     ;
;		         Increases the size of the heap by adding space      ;
;		         for a requested number of entries		     ;
; Heap Data Structure:						             ;
;									     ;
; The heap data structure has two parts, a header and a set of nodes and     ;
; these are blocked one after the other.				     ;
; The header maintains:						             ;
;                       (i)  A pointer to the next available node slot       ;
;                            relative to start of the node area	             ;
;		       (ii)  A pointer to the first valid node slot          ;
;                            node slots between the header and this pointer  ;
;			     are actually deleted nodes			     ;
;		      (iii)  A pointer past the last allocated node slot     ;
;		       (iv)  A last key value, which either holds the largest;
;                            key value as long as the nodes are sequentially ;
;                            ordered, or a very large value to indicate there;
;                            is no sequential ordering			     ;
;                     							     ;
;         ----------------						     ;
;        |     INDEX      |     ----   Pointer to next available node slot   ;
;         ---------------- 					             ;
;        |    MAXENTRY    |     ----   Pointer past last allocated node slot ;
;         ----------------                                                   ;
; START  |    LASTKEY     |     ----   Aslong as possible holds max key      ;
; NODE   |     START      |     ----   pointer to first active node slot     ;
;         ---------------- 						     ;
;        |      KEY       |     ----   Node 1.				     ;
;        |      TAG       |     					     ;
;        //---------------//					             ;
;        |      KEY       |     ----   Last allocated node slot              ;
;        |      TAG       |           					     ;
;         ---------------- 						     ;
;									     ;
; All pointers to nodes are relative to node 1 (pointer to node 1 is ZERO)   ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
; Include File Section and definitions:				             ;
;									     ;
  							
	.xlist
	include cmacros.inc
	include	gdimacro.inc
	include gdimem.inc
	.286p
	.list

START 	equ	SIZE PQ - SIZE ENTRY	; The header includes Node 0	

VERYLARGE	equ	4000h		; assumed to be larger than any key
PQERROR		equ	-1		; return value on error
TRUE		equ	1
FALSE		equ	0

Entry	struc
	e_key	dw	?		; key value of node
	e_tag	dw	?		; corresponding tag value	
Entry	ends

PQ	struc				; HEAP Header Structure + Start Node
	pq_index	dw	?	
	pq_maxentry	dw	?	; excludes START NODE
	pq_lastkey	dw	?
	pq_start	dw	?
PQ	ends


	externFP	GlobalLock
	externFP	GlobalUnlock
	externFP 	GlobalReAlloc
	externFP	GlobalFree
	externFP	GlobalAlloc ; Defined in HELPER.ASM

createSeg	_SORT,SORT,byte,public,CODE
sBegin SORT

;-----------------------------------------------------------------------------;
;									      ;
;CreatePQ:								      ;
;       Inputs:								      ;
;                Max Number of entries the tree will hold		      ;
;       Outputs:					    		      ;
;                HANDLE to Heap  -- if creation successful				      ;
;                PQERROR if failure				              ;
;       Registers Preserved: 					              ;
;                DI,SI					                      ;
;								              ;
; -by- David Weise [davidw]						      ;
;								              ;
;-----------------------------------------------------------------------------;

	assumes	cs,SORT
	assumes	ds,nothing

cProc   farGDIGlobalAlloc,<FAR,PUBLIC>

        parmd   amount
cBegin
        cCall   GlobalAlloc,<GMEM_MOVEABLE+GMEM_SHARE,amount>
cEnd

cProc	CreatePQ,<FAR,PUBLIC,NODATA>,<di,si>
	parmW	cEntries

cBegin
	mov	ax,cEntries		; max no of nodes the tree will hold
	shl	ax,1
	shl	ax,1			; ax <---- ax * SIZE ENTRY
	.errnz  (SIZE ENTRY - 4)	
	mov	si,ax			; save number of bytes in node array
	add	ax, SIZE PQ		; size of header including NODE 0
	xor	dx,dx
	cCall	farGDIGlobalAlloc,<dx,ax>
	mov	bx,ax			; Handle returned
	dec	ax			; set to -1 if handle returned == 0
	.errnz	(-1 - PQERROR)
	or	bx,bx			; test for succesfull memory allocation
	jz	cPQ_Done		; error return.
	push	bx
	cCall	GlobalLock,<bx> 	; lock handle get back segment
	pop	bx
	mov	es,dx
	mov	di,ax			; es:di points to start of structure
	
; now initialize the header part of the structure with values 
; si has size of the node array

	stosw				; index set to zero
	.errnz	(0 - pq_index)
	mov	ax,si			; pointer past end of node array	
	stosw				; max no of entries
	.errnz 	(2 - pq_maxentry)
	xor	ax,ax			; last key = 0, as heap empty
	stosw
	.errnz	(4 - pq_lastkey)
	stosw				; START = 0, implies no deleted slot 
	.errnz	(6 - pq_start)

	push	bx
	cCall	GlobalUnlock,<bx>	; unlock the handle to heap
	pop	ax			; return the handle

cPQ_Done:

cEnd

;-----------------------------------------------------------------------------;
;									      ;
; InsertPQ:    								      ;
;          Inputs:						              ;
;                 hPQ -- handle to heap structure segment		      ;
;                 tag -- tag value for new node				      ;
;	          key -- key value for new node				      ;
;          Outputs:							      ;
;                 return TRUE if insertion was successful		      ;
;                 return PQERROR if heap was already packed		      ;
;	   Preserves:						              ;
;                 DS,SI						              ;
;									      ;
; -by-  Amit Chatterjee [amitc]    Tue Aug 9  10:45:25			      ;
;-----------------------------------------------------------------------------

	assumes	cs,SORT
	assumes ds,nothing

cProc	InsertPQ,<FAR,PUBLIC,NODATA>,<di,si>
	parmW	hPQ 
	parmW	tag
	parmW	key

cBegin
	mov	di,hPQ		
	cCall	GlobalLock,<di>		; lock heap and get back segment addres
	or	ax,dx			; Invalid handle causes zero return
	jz	Ins_Cant_Proceed
	mov	es,dx 
	xor	si,si			; offset in segment always zero
	mov	ax,es:[si]   		; pointer to next available slot
	sub	ax,es:[si].pq_start	; convert it relative to 1st active node
	cmp	ax,es:[si].pq_maxentry  ; compare with pointer past last slot
        jb	Insertion_Possible
	cCall	GlobalUnlock,<di>        
Ins_Cant_Proceed:
	mov	ax,PQERROR		; error return
	jmp	cInsert_Done		

Insertion_Possible:
        push	es			; HEAP structure segment
        smov	es,ds			; save local segment in es
        pop	ds			; change DS to heap segment
	mov	ax,[si].pq_index	; next available slot in node area
	cmp	ax,[si].pq_maxentry	
	jb	Enough_Space_Atend	; insertion possible w/o compaction

; Deleted nodes exist near the head of the tree, compaction necessary
        call    CompactList             ; removes all deleted elements
       
; LASTKEY still holds the max key value in the tree

Enough_Space_Atend:
        mov	bx,[si].pq_index	; pointer to next available slot
	mov	dx,bx			; save value in register
	add	bx,SIZE PQ              ; area for header
	mov	ax,tag
	mov	[si][bx].e_tag,ax	; insert new tag and key
	mov	ax,key
	mov	[si][bx].e_key,ax	; key in ax will be used below
	mov	bx,dx			; bx points to last occupied slot
        add	dx,SIZE ENTRY           ; available slot points to next node
	mov	[si].pq_index,dx	; save in the structure 

; Now test whether the heap property is valid still.
; ax has key, dx has  pointer to next slot after addition
; bx points to last valid node

	cmp	ax,[si].pq_lastkey	; compare with new key
	jb	Heap_Violated		
        mov	[si].pq_lastkey,ax	; new key is the largest key in tree
	jmp	short Heap_Restructured	; Insertion over

comment ~

        node i has lchild at 2*i and rchild at 2*i+1. But we maintain their
        address relative to start of node array. [ie node 1 has addr 0,
        node 2 has 4, node 3 12 and so on.]
        so if x happens to be the address of a node, the address of its
        parent is (x/2 -2) AND 0fffch.
        if x is the address of a parent, the address of its lchild is 2*x + 4
	and that of its rchild is 2*x + 8  

end comment ~

Heap_Violated:
        call    CompactList             ; make sure heap is compacted first!
	mov	[si].pq_lastkey,VERYLARGE ; to imply heap nolonger seq. ordered
        mov     bx,[si].pq_index                ; bx = offset of inserted elem.
        sub     bx,SIZE ENTRY

Heap_Walk_Loop:
	cmp	bx,[si].pq_start	; traversed to top of heap ?
	jz	Heap_Restructured
	mov	cx,bx
	shr	cx,1			; cx points to parent of current node
	dec	cx
	dec	cx			
	and	cx,0fffch		; refer to comment above
	.errnz	(SIZE ENTRY - 4)

; Test whether current node has to move up or not, if not it resets carry
; else it swaps the two nodes and sets carry

        call	TestShuffle
	mov	bx,cx			; next node to inspect ifnec. is parent
	jc	Heap_Walk_Loop

Heap_Restructured:
	smov	ds,es			; get back own segment in ds
	cCall	GlobalUnlock,<di>	; di still has the handle
	mov	ax,di			; return true

cInsert_Done:
cEnd

        	
;-----------------------------------------------------------------------------;
; TestShuffle:							              ;
;									      ;
;  Takes as input the node addresses of a parent and on of it's childs. If the;
;  key of the parent is >= key of the child, it returns with carry clear, else;
;  it swaps the two nodes and returns with carry set.			      ;
;									      ;
;	bx	has current node address in HEAP, relative to start NODE 1    ;
;       cx      has address of parent node of bx         	              ;
;									      ;
;  -by- Amit Chatterjee [amitc]         Tue Aug 9  12:00:00                   ;
;-----------------------------------------------------------------------------;

cProc	TestShuffle,<NEAR,PUBLIC>,<si,di>

cBegin
        lea	di,[si][SIZE PQ]        ; di points to node 1
        add	di,cx			; di points to parent
        lea	si,[bx].SIZE PQ		; si points to child node
	mov	ax,[si].e_key    	; childs key
	cmp	ax,[di].e_key		; key of parent
	jb	Nodes_Tobe_Swapped
;
; Carry cleared by comparision, use for return
;
	jmp	short TestShuffle_Ret

Nodes_Tobe_Swapped:
;
; Carry has been set by comparision, use for return
;
	xchg	ax,[di].e_key
	mov	[si].e_key,ax
	mov	ax,[si].e_tag
	xchg	ax,[di].e_tag
	mov	[si].e_tag,ax		; swap complete
TestShuffle_Ret:

cEnd 

;-----------------------------------------------------------------------------;
; MinPQ:							              ;
;       Inputs:								      ;
;	       hPQ  --  Handle to the heap structure	                      ;
;       Outputs:						              ;
;              minimum tag value in the tree or PQERROR(if invalid handle)    ;
;								              ;
; Calls Local Procedure GetMinPQ.					      ;
;       GetMinPQ takes the handle and a flag as parameter.		      ;
;                If the flag is TRUE, the node with the least key is deleted ;
;                GetMinPQ also returns the tag value of least key in AX       ;
;						                              ;
;             								      ;
; -by-  Amit Chatterjee  [amitc]   Tue Aug 9  12:46:10			      ;
;-----------------------------------------------------------------------------;

	assumes	cs,SORT
	assumes	ds,nothing

cProc	MinPQ,<FAR,PUBLIC,NODATA>
;	parmW 	hPQ

cBegin  nogen

        mov	cl,FALSE		; to imply node not to be deleted
        jmpnext				; fall through trick, refer cmacros

cEnd 	nogen

;-----------------------------------------------------------------------------;
; ExtractPQ:								      ;
;          Inputs:						              ;
;		 hPQ  -- Handle to the heap structure			      ;
;	   Outputs:					                      ;
;                minimum tag value if heap handle is valid and heap not empty ;
;                return PQERROR otherwise				      ;
;                The node with min key is deleted			      ;
;          Calls Local Procedure GetMinPQ				      ;
;									      ;
; -by-  Amit Chatterjee [amitc]    Tue Aug 9 12:54:00		              ;
;-----------------------------------------------------------------------------;

	assumes	cs,SORT
	assumes ds,nothing

cProc	ExtractPQ,<FAR,PUBLIC,NODATA>
;	parmW	hPQ


cBegin	nogen

	mov	cl,TRUE  		; to imply that node to be deleted
        jmpnext	stop			; fall through trick, refer cmacros

cEnd	nogen

;-----------------------------------------------------------------------------;
; GetMinPQ:								      ;
;									      ;
; One of the inputs is a flag. If the flag is FALSE it simply returns the tag ;
; associated with the lease key value in the heap. If the flag is TRUE besides;
; returnning the above tag value it also deletes the node.		      ;
;								              ;
;								              ;
;      hPQ ---  handle of HEAP segment	                                      ;
;       cl ---  Deletion Flag ( Delete node if TRUE)                          ;
;							                      ;
; -by- Amit Chatterjee [amitc]      Tue Aug 9 13:00:00			      ;
;-----------------------------------------------------------------------------;

cProc	GetMinPQ,<FAR,PUBLIC,NODATA>,<di,si>
 	parmW	hPQ
cBegin
	mov	di,hPQ
	push	cx			; save flag
	cCall	GlobalLock,<di>  
	pop	cx			; get back flag into cl
	or	dx,ax			; invalid handle implies zero return
	jz	Min_Cant_Proceed
	mov	es,dx
	mov	si,ax			; ds:si points to heap start
	mov	bx,es:[si].pq_start	; pointer to 1st. available slot
	cmp	bx,es:[si].pq_index     ; empty if equal to next available node
	jb	Heap_Not_Empty
	cCall	GlobalUnlock,<di>
	
Min_Cant_Proceed:
	mov	ax,PQERROR
	jmp	cGetMin_Done		; error return

; bx still has [si].pq_start

Heap_Not_Empty:
	push	es			; save heap segment
	smov	es,ds			; save local segment is es
	pop	ds			; ds:si points to start of heap
        lea	dx,[si][SIZE PQ]
	add	dx,bx            	; points past deleted nodes
        xchg	di,dx			; save di in dx and use dx's value
	mov	ax,[di].e_tag		; get the tag associated with least key
        xchg	di,dx			; get back values
        or	cl,cl			; test for bl = FALSE
	.errnz	(0 - FALSE)
	jnz	Delete_Node		; TRUE implies get tag and delete node
	jmp	cGetMin_Ret		; return after unlocking heap

Delete_Node:

; bx retains [si].start

        add	bx,SIZE ENTRY		; one more node deleted
	cmp	bx,[si].pq_index	; is tree empty ?
	jb 	Tree_Not_Empty
	xor	cx,cx 
	mov	[si].pq_lastkey,cx	; initialize for empty tree
	mov	[si].pq_start,cx	; initialize for empty tree
	mov	[si].pq_index,cx
	jmp	cGetMin_Ret		; return after unlocking heap

Tree_Not_Empty:

; ax has return tag value
; bx has [si].pq_start + SIZE ENTRY

	cmp	[si].pq_lastkey,VERYLARGE ; implies keys in random order
	jae	Min_Restructure_Heap	; maybe restructuring necessary
	mov	[si].pq_start,bx	; updates past deleted entry
	jmp	cGetMin_Ret

Min_Restructure_Heap:

; dx still has offset to NODE 1, because
; if LASTKEY = VERYLARGE, pq_start has to be zero 

        push	ax			; save return tag value
	mov	bx,dx			; offset to first active node
        xchg	di,dx			; get pointer into di ,save di
	add	di,[si].pq_index	; dx points to next available slot
	sub	di,SIZE ENTRY		; point to last filled node
        mov	ax,di           	; last node being moved upfront
        sub	ax,SIZE PQ		; point ax one node ahead of last
	mov	[si].pq_index,ax	; update it
	mov	cx,[di].e_key
	mov	[bx].e_key,cx		; move from last position to NODE 1
	mov	cx,[di].e_tag
	mov	[bx].e_tag,cx
        xchg 	di,dx			; restore di,dx
	xor	cx,cx			; start traversing heap from root


Min_Traverse_Heap:
	mov	bx,cx
	shl	bx,1
	add	bx,SIZE ENTRY		; bx has left child addr of parent in cx
	cmp	bx,[si].pq_index       	; compare with next available slot
	jae	Min_Heap_Fixed		; heap restored
	push	cx			; save current parent 
	mov	cx,bx			; have lchild in cx
	add	cx,SIZE ENTRY		; cx now get address of rchild
	cmp	cx,[si].pq_index        ; test against last node
	jae	Right_Child_Not_Present
	call	GetLesserChild		; gets child with lesser key in bx

Right_Child_Not_Present: 
	pop	cx			; get back parent
;
; cx has node number of parent node and bx has node no of child node with
; least key. If parents key value is greater it should be swapped
;
	call	TestShuffle

; swaps the two nodes if necessary.

	mov	cx,bx			; lesser child is next parent
	jmp	Min_Traverse_Heap

Min_Heap_Fixed:
	pop	ax			; get back return tag value
cGetMin_Ret:
	push	ax			; save return value
	smov	ds,es			; get back own ds
	cCall	GlobalUnlock,<di>	; unlock heap
        pop	ax			; get back return value
cGetMin_Done:

cEnd

;-----------------------------------------------------------------------------;
; GetLesserChild:					                      ;
;                						              ;
; Given two child node numbers, it returns the child which has a lesser key   ;
;									      ;
;	cx	has RCHILD NODE address				              ;
;	bx	has LCHILD NODE address			                      ;
;	si      points to start of heap					      ;
;	will  return node address of lesser child in bx			      ;
;									      ;
; -by-  Amit Chatterjee  [amitc]   Tue Aug 9  13:50			      ;
;-----------------------------------------------------------------------------;
 

cProc	GetLesserChild,<NEAR,PUBLIC,NODATA>,<di,si>

cBegin
        lea	di,[si][SIZE PQ]        ; dx now points to NODE 1
	mov	si,di			; si also points to start of NODE 1
        add	di,cx			; di get address of rchild
	mov	ax,[si+bx].e_key	; rchilds key
	cmp	ax,[di].e_key		; compare with rchild
	jb	Right_Child_Lesser	; bx still has the correct child no.
        mov	bx,cx			; get RCHILD address into bx
Right_Child_Lesser:

cEnd
;
;-----------------------------------------------------------------------------;
; DeletePQ:							              ;
;       Inputs:							              ;
;	       hPQ ---  handle to a heap structure			      ;
;       OutPuts: nothing					              ;
;	Preserves: DI						              ;
;									      ;
; -by-  Amit Chatterjee [amitc]    Tue Aug 9  14:15:45		              ;
;-----------------------------------------------------------------------------
;
	assumes	cs,SORT
	assumes	ds,nothing

cProc	DeletePQ,<FAR,PUBLIC,NODATA>
	parmW	hPQ

cBegin
	cCall	GlobalFree,<hPQ>		; free the handle
cEnd

;-----------------------------------------------------------------------------;
;SizePQ:							              ;
;       Input:	        					              ;
;	      hPQ   ---   Handle to a heap structure			      ;
;	      entry ---   number of nodes by which heap is to be expanded     ;
;	Output:								      ;
;             Returns the total number of node slots in new heap, if successful
;	      else return PQERROR				              ;
;									      ;
; -by-  Amit Chatterjee  [amitc]   Tue Aug 9   14:31:40                       ;
;-----------------------------------------------------------------------------

	assumes	cs,SORT
	assumes	ds,nothing 

cProc	SizePQ,<FAR,PUBLIC,NODATA>,<si,di>
	parmW	hPQ
	parmW 	cEntry

cBegin
	mov	di,hPQ			
	cCall	GlobalLock,<di>		; lock to get back segment address
	or	ax,dx			; Invalid handle implies NULL return
	jz	Siz_Cant_Proceed
	mov	es,dx
        xor	si,si			; offset will always be zro
	mov	ax,cEntry		; additional nodes
	or	ax,ax			; if zero return original numof nodes
	jnz	Size_Tobe_Increased
	mov	ax,es:[si].pq_maxentry	; offset past last node
	shr	ax,1
	shr	ax,1			; ax <--- ax / SIZE ENTRY
	.errnz	(SIZE ENTRY - 4)
	jmp	short cSize_Ret		; return after unlocking handle
	
Size_Tobe_Increased:
	shl	ax,1
	shl	ax,1			; ax <-- ax * SIZE ENTRY, = extra bytes
	.errnz	(SIZE ENTRY - 4)
	add	ax,es:[si].pq_maxentry	; number of byte for new node array 
	cmp	ax,es:[si].pq_index	; next available slot
	jae	Valid_Increase
	mov	ax,PQERROR		; error code
	jmp	short cSize_Ret		; return after releasing handle
	
Valid_Increase:
	push	ax			; save number of bytes in node block
	add	ax,SIZE PQ		; size of header
	push	ax
	cCall	GlobalUnlock,<di>	; unlock handle
	xor	dx,dx			; high word for size
	pop	ax			; get back size
	cCall	GlobalReAlloc,<di,dx,ax,GMEM_MOVEABLE>
        or	ax,ax
	jz	Siz_Cant_Proceed
	mov	di,ax			; new handle
        cCall   GlobalLock,<ax>		; lock it
	mov	es,dx			; set new segment
	pop	cx			; get back total no of nodes into cx
        jmp	short Reloc_Successful
Siz_Cant_Proceed:
        pop	cx			; balance stack
	dec	ax 
	.errnz	(-1 - PQERROR)
	jmp	short cSize_End

Reloc_Successful:
	mov	es:[si].pq_maxentry,cx	; total number of slots now
	shr	cx,1
	shr	cx,1			; no of nodes = bytes / SIZE ENTRY
	.errnz	(SIZE ENTRY - 4)
	mov	ax,cx			; return value
cSize_Ret:
	cCall	GlobalUnlock,<di>
cSize_End:

cEnd

;-----------------------------------------------------------------------------;
;CompactList:							              ;
;       Input:	        					              ;
;	      ds:si ---   pointer to heap structure			      ;
;	Output:								      ;
;             all deleted elements are removed from heap structure            ;  
;       Registers trashed:
;             AX,BX,CX,DX  
;
; -by-  Ken Sykes  [kensy]   Tue Nov 12 1991  10:20:00am                      ;
;-----------------------------------------------------------------------------

CompactList     proc    near
	mov	ax,[si].pq_index	; next available slot in node area
	sub	ax,[si].pq_start	; ax had pointer to available slot
	mov	[si].pq_index,ax	; next available slot will come up
        lea	dx,[si][SIZE PQ]	; points to NODE 1
	mov	ax,[si].pq_start	; pointer to 1st active node rel to 1 
	add	ax,dx			; ax has offset to first valid node.
	mov	bx,ax	
	mov	cx,[si].pq_maxentry	; pointer past end of node slots
	sub	cx,[si].pq_start	; pointer to strt of active block
	shr	cx,1			; will do a REP MOVSW
	.errnz	(1 and SIZE ENTRY)
	push	es			; es has local segment
        smov	es,ds			; moth es ds point to heap segment
	push	si
	push	di			; save start to heap and its handle
	mov	si,bx			; si points to start of valid nodes
	mov	di,dx			; dx points to node 1
        cld
	rep	movsw			; Compacted 
        pop	di
	pop	si
	pop	es			; restore local segment in es
	mov	[si].pq_start,cx	; after compaction deleted nodes = 0
        ret
CompactList     endp

;-----------------------------------------------------------------------------;
	
sEnd	SORT

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\metacons.inc ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   MetaCons.inc
;   Windows.h Metafile Constants
;
;   History:
;
;   Created 28-May-1991 by John Colleran (johnc)
;   Derived from Windows.h (using h2inc was not successful over the whole file)
;--


METASETBKCOLOR	EQU	0201H 
METASETBKMODE	EQU	0102H 
METASETMAPMODE	EQU	0103H 
METASETROP2	EQU	0104H 
METASETRELABS	EQU	0105H 
METASETPOLYFILLMODE	EQU	0106H 
METASETSTRETCHBLTMODE	EQU	0107H 
METASETTEXTCHAREXTRA	EQU	0108H 
METASETTEXTCOLOR	EQU	0209H 
METASETTEXTJUSTIFICATION	EQU	020aH 
MFCOMMENT	EQU	15 
METASETWINDOWORG	EQU	020bH 
METASETWINDOWEXT	EQU	020cH 
METASETVIEWPORTORG	EQU	020dH 
METASETVIEWPORTEXT	EQU	020eH 
METAOFFSETWINDOWORG	EQU	020fH 
METASCALEWINDOWEXT	EQU	0400H 
METAOFFSETVIEWPORTORG	EQU	0211H 
METASCALEVIEWPORTEXT	EQU	0412H 
METALINETO	EQU	0213H 
METAMOVETO	EQU	0214H 
METAEXCLUDECLIPRECT	EQU	0415H 
METAINTERSECTCLIPRECT	EQU	0416H 
METAARC	EQU	0817H 
METAELLIPSE	EQU	0418H 
METAFLOODFILL	EQU	0419H 
METAPIE	EQU	081aH 
METARECTANGLE	EQU	041bH 
METAROUNDRECT	EQU	061cH 
METAPATBLT	EQU	061dH 
METASAVEDC	EQU	001eH 
METASETPIXEL	EQU	041fH 
METAOFFSETCLIPRGN	EQU	0220H 
METATEXTOUT	EQU	0521H 
METABITBLT	EQU	0922H 
METASTRETCHBLT	EQU	0b23H 
METAPOLYGON	EQU	0324H 
METAPOLYLINE	EQU	0325H 
METAESCAPE	EQU	0626H 
METARESTOREDC	EQU	0127H 
METAFILLREGION	EQU	0228H 
METAFRAMEREGION	EQU	0529H 
METAINVERTREGION	EQU	012aH 
METAPAINTREGION	EQU	012bH 
METASELECTCLIPREGION	EQU	012cH 
METASELECTOBJECT	EQU	012dH 
METASETTEXTALIGN	EQU	012eH 
METADRAWTEXT	EQU	062fH 
METACHORD	EQU	0830H 
METASETMAPPERFLAGS	EQU	0231H 
METAEXTTEXTOUT	EQU	0a32H  
METASETDIBTODEV	EQU	0d33H 
METASELECTPALETTE	EQU	0234H 
METAREALIZEPALETTE	EQU	0035H 
METAANIMATEPALETTE	EQU	0436H 
METASETPALENTRIES	EQU	0037H 
METAPOLYPOLYGON	EQU	0538H 
METARESIZEPALETTE	EQU	0139H 
METADIBBITBLT	EQU	0940H 
METADIBSTRETCHBLT	EQU	0b41H 
METADIBCREATEPATTERNBRUSH	EQU	0142H 
METASTRETCHDIB	EQU	0f43H 
METAPMMETAFILE	EQU	0ff44H 
METAEXTFLOODFILL	EQU	0548H 
METADELETEOBJECT	EQU	01f0H 
METACREATEPALETTE	EQU	00f7H 
METACREATEBRUSH	EQU	00f8H 
METACREATEPATTERNBRUSH	EQU	01f9H 
METACREATEPENINDIRECT	EQU	02faH 
METACREATEFONTINDIRECT	EQU	02fbH 
METACREATEBRUSHINDIRECT	EQU	02fcH 
METACREATEBITMAPINDIRECT	EQU	02fdH 
METACREATEBITMAP	EQU	06feH 
METACREATEREGION	EQU	06ffH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\metasup.c ===
/****************************** Module Header ******************************\
* Module Name: MetaSup.c
*
* This file contains the routines for playing the GDI metafile.  Most of these
* routines are adopted from windows gdi code. Most of the code is from
* win3.0 except for the GetEvent code which is taken from win2.1
*
*
* Public Functions:
*   EnumMetaFile
* Private Functions:
*
*
* Created: 02-Jul-1991
*
* Copyright (c) 1985, 1991  Microsoft Corporation
*
* History:
*  02-Jul-1991 -by-  John Colleran [johnc]
* Combined From Win 3.1 and WLO 1.0 sources
\***************************************************************************/

#include <windows.h>
#include "gdi16.h"

extern	HANDLE hFirstMetaFile;
extern	HDC    hScreenDC;

#define MYSTOCKBITMAP (SYSTEM_FIXED_FONT+1)
#define MYSTOCKRGN    (SYSTEM_FIXED_FONT+2)
#define CNT_GDI_STOCK_OBJ (MYSTOCKRGN+1)

HANDLE	ahStockObject[CNT_GDI_STOCK_OBJ] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
HBITMAP hStaticBitmap;

// Provide a Mapping from Object type to a stock object; See GetCurObject
int	mpObjectToStock[] =
	{ -1,			// UNUSED	    0
	  WHITE_PEN,		// OBJ_PEN	    1
	  BLACK_BRUSH,		// OBJ_BRUSH	    2
	  -1,			// OBJ_DC	    3
	  -1,			// OBJ_METADC	    4
	  DEFAULT_PALETTE,	// OBJ_PALETTE	    5
	  SYSTEM_FONT,		// OBJ_FONT	    6
	  MYSTOCKBITMAP,	// OBJ_BITMAP	    7
	  MYSTOCKRGN,		// OBJ_RGN	    8  //!!!!! init
	  -1,			// OBJ_METAFILE     9
	  -1 }; 		// OBJ_MEMDC	   10


HANDLE INTERNAL GetCurObject(HDC hdc, WORD wObjType)
{
    HANDLE cur;


//!!!!! fix to work with meta DCs as well

    GdiLogFunc3( "  GetCurObject" );

    ASSERTGDI( wObjType <= MAX_OBJ, "GetCurObject invalid Obj" );

//!!!!! fix regions when new API is done
    if( wObjType == OBJ_RGN )
	{
	return(0);
	}

    if( wObjType == OBJ_PALETTE)
	{
	cur = SelectPalette( hdc, ahStockObject[DEFAULT_PALETTE], FALSE );
	SelectPalette( hdc, cur, FALSE );
	}
    else
	{
	cur = SelectObject(hdc,ahStockObject[mpObjectToStock[wObjType]]);
	SelectObject( hdc, cur );
	}

    ASSERTGDIW( cur, "GetCurObect Failed. Type %d", wObjType );
    return(cur);
}

#if 0 // this is going to gdi.dll

/******************************** Public Function **************************\
* BOOL GDIENTRY EnumMetaFile(hmf)
*
* The EnumMetaFile function enumerates the GDI calls within the metafile
* identified by the hMF parameter. The EnumMetaFile function retrieves each
* GDI call within the metafile and passes it to the function pointed to by the
* lpCallbackFunc parameter. This callback function, an application-supplied
* function, can process each GDI call as desired. Enumeration continues until
* there are no more GDI calls or the callback function returns zero.
*
*
* Effects:
*
\***************************************************************************/

BOOL GDIENTRY EnumMetaFile(hdc, hMF, lpCallbackFunction, lpClientData)
HDC             hdc;
LOCALHANDLE     hMF;
FARPROC         lpCallbackFunction;
LPBYTE          lpClientData;
{
    WORD            i;
    WORD            noObjs;
    BOOL            bPrint=TRUE;
    HANDLE          hObject;
    HANDLE          hLBrush;
    HANDLE          hLPen;
    HANDLE          hLFont;
    HANDLE          hRegion;
    HANDLE          hPalette;
    LPMETAFILE      lpMF;
    LPMETARECORD    lpMR = NULL;
    LPHANDLETABLE   lpHandleTable = NULL;
    GLOBALHANDLE    hHandleTable = NULL;


    GdiLogFunc( "EnumMetaFile");

    if (!ISDCVALID(hdc))
        {
	ASSERTGDI( FALSE, "EnumMetaFile: DC is invalid");
        return (FALSE);
        }

/* use GlobalFix() instead of GlobalLock() to insure that the
** memory never moves, keeping our aliased selector pointing to the
** right place
*/
// !!!!! replaced GlobalFix with GlobalLock
    if (hMF && (lpMF = (LPMETAFILE)(DWORD)(0xFFFF0000 & (DWORD)GlobalLock(hMF))))
        {
        if ((noObjs = lpMF->MetaFileHeader.mtNoObjects) > 0)
            {
            if (!(hHandleTable =
                    GlobalAlloc((WORD)(GMEM_ZEROINIT | GMEM_MOVEABLE), (LONG)
                        ((sizeof(HANDLE) * lpMF->MetaFileHeader.mtNoObjects) +
                         sizeof(WORD)))))
                {
                goto ABRRT2;
                }
            lpHandleTable = (LPHANDLETABLE)GlobalLock(hHandleTable);
            }

        /* only do object save/reselect for real DC's */
	if (hdc && !ISMETADC(hdc))
            {
            hLPen    = GetCurObject( hdc, OBJ_PEN );  /* save the old objects so */
            hLBrush  = GetCurObject( hdc, OBJ_BRUSH); /* we can put them back    */
            hLFont   = GetCurObject( hdc, OBJ_FONT);
            hRegion  = GetCurObject( hdc, OBJ_RGN);
            hPalette = GetCurObject( hdc, OBJ_PALETTE);
            }

        while(lpMR = GetEvent(lpMF, lpMR, FALSE))
            {
            typedef int (FAR PASCAL *ENUMPROC)(HDC, LPHANDLETABLE, LPMETARECORD, int, LPBYTE);

            if ((bPrint = (*((ENUMPROC)lpCallbackFunction))(hdc, lpHandleTable, lpMR, noObjs, lpClientData))
                    == 0)
                {
                GetEvent(lpMF,lpMR,TRUE);
                break;
                }
            }

	if (hdc && !ISMETADC(hdc))
            {
            SelectObject(hdc, hLPen);
            SelectObject(hdc, hLBrush);
            SelectObject(hdc, hLFont);
            if (hRegion)
                SelectObject(hdc, hRegion);
            SelectPalette(hdc, hPalette, 0);
            }

        for(i = 0; i < lpMF->MetaFileHeader.mtNoObjects; ++i)
            if (hObject = lpHandleTable->objectHandle[i])
                DeleteObject(hObject);

        if (hHandleTable)
            {
            GlobalUnlock(hHandleTable);
            GlobalFree(hHandleTable);
            }
ABRRT2:;
        GlobalUnfix(hMF);
        }
    return(bPrint);
}
#endif // this is going to gdi.dll

/***************************** Internal Function **************************\
* BOOL FAR PASCAL PlayIntoAMetafile
*
* if this record is being played into another metafile, simply record
* it into that metafile, without hassling with a real playing.
*
* Returns: TRUE if record was played (copied) into another metafile
*          FALESE if destination DC was a real (non-meta) DC
*
* Effects: ?
*
* Warnings: ?
*
\***************************************************************************/

BOOL INTERNAL PlayIntoAMetafile(LPMETARECORD lpMR, HDC hdcDest)
{
    GdiLogFunc3( "  PlayIntoAMetafile");

    if (!ISMETADC(hdcDest))
        return(FALSE);
    else
        {
        /* the size is the same minus 3 words for the record header */
        RecordParms(hdcDest, lpMR->rdFunction, (DWORD)lpMR->rdSize - 3,
                (LPWORD)&(lpMR->rdParm[0]));
        return(TRUE);
        }
}

BOOL INTERNAL IsDCValid(HDC hdc)
{
    NPMETARECORDER  npdc;

    hdc = (HDC)HANDLEFROMMETADC(hdc);

    // Is the DC a valid Real DC
    switch (GetObjectType(hdc))
    {
        case OBJ_DC:
        case OBJ_METADC:
        case OBJ_MEMDC:
            return(TRUE);
            break;
    }

    // Is the DC a GDI16 metafile DC
    if (npdc = (NPMETARECORDER)LocalLock(hdc))
    {
        if( npdc->metaDCHeader.ident == ID_METADC )
            return(TRUE);
    }

    ASSERTGDI(FALSE, "Invalid DC");
    return(FALSE);
}


/***************************** Internal Function **************************\
* IsMetaDC(hdc)
*
*
* Returns TRUE iff hdc is a valid GDI16 Metafile
*
*
\***************************************************************************/

BOOL INTERNAL IsMetaDC(HDC hdc)
{
    NPMETARECORDER  npdc;
    BOOL            fMeta = FALSE;

    GdiLogFunc3("  IsMetaDC");

    if( ((UINT)hdc) & METADCBIT )
        if( npdc = (NPMETARECORDER)LocalLock( (HANDLE)HANDLEFROMMETADC(hdc)))
            {
            if( npdc->metaDCHeader.ident == ID_METADC )
                fMeta = TRUE;

            LocalUnlock( (HANDLE)HANDLEFROMMETADC(hdc) );
            }

    return( fMeta );
}


/***************************** Public Function ****************************\
* HANDLE INTERNAL GetPMetaFile( HDC hdc )
*
* if hdc is a DC it is validated as a metafile
* if hdc is a PALETTE the metafile the palette is selected into is returned
*
* Returns:
*   -1 iff Error
*   HANDLE to metafile if valid meta DC
*   0 if valid object
*
* Effects:
*
* History:
*  08-Jul-1991	-by-  John Colleran [johnc]
* Wrote it.
\***************************************************************************/

HANDLE INTERNAL GetPMetaFile( HDC hdc )
{
    NPMETARECORDER  npMR;

    GdiLogFunc3( "  GetPMetaFile");


    if( hdc & METADCBIT )
	{
	if( npMR = (NPMETARECORDER)LocalLock(HANDLEFROMMETADC(hdc)) )
	    {
	    if(npMR->metaDCHeader.ident == ID_METADC )
		{
		LocalUnlock(HANDLEFROMMETADC(hdc));
		return( HANDLEFROMMETADC(hdc) );
		}
	    LocalUnlock(HANDLEFROMMETADC(hdc));
	    }
	}

    // is hdc really a palette or object for the strange no-DC APIs
    // Validate the object is real
    if( (hdc != (HDC)NULL) && (GetObjectType( hdc ) == 0))
	{
	extern int iLogLevel;		// Gdi.asm
	// WinWord has a bug where it deletes valid objects so
	// only log this error if the loglevel is high.
	ASSERTGDI( (iLogLevel < 5), "GetPMetaFile: Invalid metafile or object")
	return( -1 );	    // Not a valid object
	}
    else
	return( 0 );	    // Valid Object
}


BOOL INTERNAL IsObjectStock(HANDLE hObj)
{
    int     ii;

    // handle Bitmaps and regions !!!!!

    // Get all the Stock Objects
    for( ii=WHITE_BRUSH; ii<=NULL_PEN; ii++ )
	if( ahStockObject[ii] == hObj )
	    return( TRUE );

    for( ii=OEM_FIXED_FONT; ii<=SYSTEM_FIXED_FONT; ii++ )
	if( ahStockObject[ii] == hObj )
	    return( TRUE );

    return( FALSE );
}

/***************************** Internal Function **************************\
* GetObjectAndType
*
*
* Returns the object type, eg OBJ_FONT, as well as a the LogObject
*
*
\***************************************************************************/

int INTERNAL GetObjectAndType(HANDLE hObj, LPSTR lpObjectBuf)
{
    int     iObj = -1;

    GdiLogFunc3( "  GetObjectAndType" );

    GetObject(hObj, MAXOBJECTSIZE, lpObjectBuf);
    switch( iObj = (int)GetObjectType(hObj) )
	{
	case OBJ_PEN:
	case OBJ_BITMAP:
	case OBJ_BRUSH:
	case OBJ_FONT:
	    break;

	// Watch out for Palettes; returns the number of entries.
	case OBJ_PALETTE:
	    GetPaletteEntries( hObj, 0, 1, (LPPALETTEENTRY)lpObjectBuf );
		iObj = OBJ_PALETTE;
	    break;

	case OBJ_RGN:
	    break;

	default:
		ASSERTGDIW( 0, "GetObject unknown object type: %d", iObj);
	    break;
	}
    return( iObj );
}


/***************************** Internal Function **************************\
* BOOL GDIENTRY InitializeGdi
*
* Initializes the GDI16.exe
*
*
* Effects:
*
* Returns:  TRUE iff GDI was initilized successfully
*
\***************************************************************************/

BOOL INTERNAL InitializeGdi(void)
{
BOOL	status;
int	ii;

    GdiLogFunc2 ( "  InitializeGDI");
    if( !(hScreenDC = CreateCompatibleDC(NULL)))
	goto ExitInit;

    // Get all the Stock Objects
    for( ii=WHITE_BRUSH; ii<=NULL_PEN; ii++ )
	ahStockObject[ii] = GetStockObject( ii );

    for( ii=OEM_FIXED_FONT; ii<=SYSTEM_FIXED_FONT; ii++ )
	ahStockObject[ii] = GetStockObject( ii );

    // Create a fake Stock Region and Bitmap
    ahStockObject[MYSTOCKRGN] = CreateRectRgn(1,1,3,3);
    hStaticBitmap = ahStockObject[MYSTOCKBITMAP] = CreateBitmap(1,1,1,1,NULL);

    status = TRUE;

 ExitInit:
    ASSERTGDI( status, "GDI16 Failed to initialized correctly");
    return( status );
}


/***************************************************************************

    debugging support

***************************************************************************/

#ifdef DEBUG

void dDbgOut(int iLevel, LPSTR lpszFormat, ...)
{
    char buf[256];
    char far *lpcLogLevel;
    extern int iLogLevel;	    // Gdi.asm
    extern int iBreakLevel;	    // Gdi.asm

    // Get the external logging level from the emulated ROM

    (LONG)lpcLogLevel = 0x00400042;
    if (*lpcLogLevel >= '0' && *lpcLogLevel <= '9')
	iLogLevel = (*lpcLogLevel-'0')*10+(*(lpcLogLevel+1)-'0');

    if (iLevel<=iLogLevel)
	{
	OutputDebugString("     W16GDI:");
	wvsprintf(buf, lpszFormat, (LPSTR)(&lpszFormat + 1));
	OutputDebugString(buf);
	OutputDebugString("\r\n");

	if( iLevel<=iBreakLevel )
	    _asm int 3;
	}
}

void dDbgAssert(LPSTR str, LPSTR file, int line)
{
    static char buf3[256];

    wsprintf(buf3, "Assertion FAILED: %s %d : %s", file, line, str );
    OutputDebugString(buf3);
    OutputDebugString("\r\n");
    _asm int 3;
}



#undef LocalLock
#undef LocalUnlock
#undef LocalAlloc
#undef GlobalLock
#undef GlobalUnlock
#undef GlobalAlloc
PSTR INTERNAL _LocalLock(HANDLE h )
{
PSTR p;
dDbgOut(7, "LocalLock 0x%X", h );
p = LocalLock(h);
if( p == NULL )
    _asm int 3
return( p );
}
BOOL INTERNAL _LocalUnlock(HANDLE h )
{
dDbgOut(7, "LocalUnlock 0x%X", h );
return( LocalUnlock(h) );
}
HANDLE INTERNAL _LocalAlloc(WORD w, WORD w2)
{
dDbgOut(7, "LocalAlloc");
return( LocalAlloc(w,w2) );
}
LPSTR INTERNAL _GlobalLock(HANDLE h )
{
dDbgOut(7, "GlobalLock 0x%X", h );
return( GlobalLock(h) );
}
BOOL INTERNAL _GlobalUnlock(HANDLE h )
{
dDbgOut(7, "GlobalUnlock 0x%X", h );
return( GlobalUnlock(h) );
}
HANDLE INTERNAL _GlobalAlloc(WORD w, DWORD dw )
{
dDbgOut(7, "GlobalAlloc");
return( GlobalAlloc(w,dw) );
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
 	 DBCS_FLAGS="-DFE_SB"  
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\cmstrip.c ===
/*
   stripper: strips asm comments, blanks lines, and spurious spaces
   (except spaces following the exception strings, listed below.)
*/

#include <stdio.h>

char *
ScanWhite( ps )
char **ps;
{
    char *s = *ps;

    while (*s != ' ' && *s != '\t' && *s)
	s++;
    *ps = s;
    if (*s)
	return s;
    else
	return NULL;
}

char *
SkipWhite( ps )
char **ps;
{
    char *s = *ps;

    while (*s == ' ' || *s == '\t')
	s++;
    *ps = s;
    if (*s)
	return s;
    else
	return NULL;
}

char inBuf[ 256 ];
char outBuf[ 256 ];


main()
{
    char
	*inStr,
	*outStr,
	*str;
    int inLen,
	outLen,
	tabcnt;

    long totSaved = 0L;

    unlink( "cmacros.bak" );			    /*	    */
    rename( "cmacros.bak", "cmacros.inc" );	    /*	    */
    freopen( "cmacros.mas", "r", stdin );	    /*	    */
    freopen( "cmacros.inc", "w", stdout );	    /*	    */
    fprintf( stderr, "cmacros.mas => cmacros.inc" );
    fflush( stderr );

    while (inStr = gets( inBuf ))
    {
	inLen = strlen( inBuf );
	outStr = outBuf;

	tabcnt=0;
	if (inBuf[inLen-1] == '@')
	    tabcnt=1;

	while (SkipWhite( &inStr ))
	{
	    if (*inStr == ';')
		break;

	    str = inStr;
	    ScanWhite( &inStr );
	    if (tabcnt > 0 && tabcnt < 3)
	    {
		*outStr++ = '\t';
		tabcnt++;
	    }
	    else
	    {
		if (outStr != outBuf)
		    *outStr++ = ' ';
	    }
	    while (str != inStr)
		*outStr++ = *str++;
	}

	if (outLen = outStr - outBuf)
	{
	    *outStr++ = 0;
	    puts( outBuf );
	}

	totSaved += (inLen - outLen);
    }

    fprintf( stderr, " [OK]  %ld blanks stripped\n", totSaved );
    exit( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\gdi\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
ifndef ?QUIET
?QUIET  equ 1
endif
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\commdlg.h ===
/*****************************************************************************\
*                                                                             *
* commdlg.h -   Common dialog functions, types, and definitions               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

typedef struct tagOFN
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    LPCSTR  lpstrFilter;
    LPSTR   lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    LPSTR   lpstrFile;
    DWORD   nMaxFile;
    LPSTR   lpstrFileTitle;
    DWORD   nMaxFileTitle;
    LPCSTR  lpstrInitialDir;
    LPCSTR  lpstrTitle;
    DWORD   Flags;
    UINT    nFileOffset;
    UINT    nFileExtension;
    LPCSTR  lpstrDefExt;
    LPARAM  lCustData;
    UINT    (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
}   OPENFILENAME;
typedef OPENFILENAME FAR* LPOPENFILENAME;

BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR*);
BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR*);
int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT);

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000

/* Return values for the registered message sent to the hook function
 * when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
 * filename to be accepted, OFN_SHARENOWARN rejects the name but puts
 * up no warning (returned when the app has already put up a warning
 * message), and OFN_SHAREWARN puts up the default warning message
 * for sharing violations.
 *
 * Note:  Undefined return values map to OFN_SHAREWARN, but are
 *        reserved for future use.
 */

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef struct tagCHOOSECOLOR
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HWND    hInstance;
    COLORREF rgbResult;
    COLORREF FAR* lpCustColors;
    DWORD   Flags;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
} CHOOSECOLOR;
typedef CHOOSECOLOR FAR *LPCHOOSECOLOR;

BOOL    WINAPI ChooseColor(CHOOSECOLOR FAR*);

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040

typedef struct tagFINDREPLACE
{
    DWORD    lStructSize;            /* size of this struct 0x20 */
    HWND     hwndOwner;              /* handle to owner's window */
    HINSTANCE hInstance;             /* instance handle of.EXE that
                                      * contains cust. dlg. template
                                      */
    DWORD    Flags;                  /* one or more of the FR_?? */
    LPSTR    lpstrFindWhat;          /* ptr. to search string    */
    LPSTR    lpstrReplaceWith;       /* ptr. to replace string   */
    UINT     wFindWhatLen;           /* size of find buffer      */
    UINT     wReplaceWithLen;        /* size of replace buffer   */
    LPARAM   lCustData;              /* data passed to hook fn.  */
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                     /* ptr. to hook fn. or NULL */
    LPCSTR   lpTemplateName;         /* custom template name     */
} FINDREPLACE;
typedef FINDREPLACE FAR *LPFINDREPLACE;

#define FR_DOWN 			0x00000001
#define FR_WHOLEWORD			0x00000002
#define FR_MATCHCASE			0x00000004
#define FR_FINDNEXT			0x00000008
#define FR_REPLACE			0x00000010
#define FR_REPLACEALL			0x00000020
#define FR_DIALOGTERM			0x00000040
#define FR_SHOWHELP			0x00000080
#define FR_ENABLEHOOK			0x00000100
#define FR_ENABLETEMPLATE		0x00000200
#define FR_NOUPDOWN			0x00000400
#define FR_NOMATCHCASE			0x00000800
#define FR_NOWHOLEWORD			0x00001000
#define FR_ENABLETEMPLATEHANDLE 	0x00002000
#define FR_HIDEUPDOWN			0x00004000
#define FR_HIDEMATCHCASE		0x00008000
#define FR_HIDEWHOLEWORD		0x00010000

HWND    WINAPI FindText(FINDREPLACE FAR*);
HWND    WINAPI ReplaceText(FINDREPLACE FAR*);

typedef struct tagCHOOSEFONT
{
    DWORD	    lStructSize;	/* */
    HWND	    hwndOwner;		/* caller's window handle   */
    HDC 	    hDC;		/* printer DC/IC or NULL    */
    LOGFONT FAR*    lpLogFont;          /* ptr. to a LOGFONT struct */
    int		    iPointSize;		/* 10 * size in points of selected font */
    DWORD	    Flags;		/* enum. type flags	    */
    COLORREF        rgbColors;          /* returned text color      */
    LPARAM          lCustData;          /* data passed to hook fn.  */
    UINT (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
					/* ptr. to hook function    */
    LPCSTR          lpTemplateName;     /* custom template name     */
    HINSTANCE       hInstance;          /* instance handle of.EXE that
					 * contains cust. dlg. template
					 */
    LPSTR	    lpszStyle;		/* return the style field here 
					 * must be LF_FACESIZE or bigger */
    UINT            nFontType;          /* same value reported to the EnumFonts
					 * call back with the extra FONTTYPE_ 
					 * bits added */
    int		    nSizeMin;		/* minimum pt size allowed & */
    int		    nSizeMax;		/* max pt size allowed if    */
					/* CF_LIMITSIZE is used      */
} CHOOSEFONT;
typedef CHOOSEFONT FAR *LPCHOOSEFONT;

BOOL WINAPI ChooseFont(CHOOSEFONT FAR*);

#define CF_SCREENFONTS		     0x00000001
#define CF_PRINTERFONTS 	     0x00000002
#define CF_BOTH 		     (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP		     0x00000004L
#define CF_ENABLEHOOK		     0x00000008L
#define CF_ENABLETEMPLATE	     0x00000010L
#define CF_ENABLETEMPLATEHANDLE      0x00000020L
#define CF_INITTOLOGFONTSTRUCT       0x00000040L
#define CF_USESTYLE		     0x00000080L
#define CF_EFFECTS		     0x00000100L
#define CF_APPLY		     0x00000200L
#define CF_ANSIONLY		     0x00000400L
#define CF_NOVECTORFONTS	     0x00000800L
#define CF_NOOEMFONTS		     CF_NOVECTORFONTS
#define CF_NOSIMULATIONS	     0x00001000L
#define CF_LIMITSIZE		     0x00002000L
#define CF_FIXEDPITCHONLY	     0x00004000L
#define CF_WYSIWYG		     0x00008000L /* must also have CF_SCREENFONTS & CF_PRINTERFONTS */
#define CF_FORCEFONTEXIST	     0x00010000L
#define CF_SCALABLEONLY		     0x00020000L
#define CF_TTONLY		     0x00040000L
#define CF_NOFACESEL		     0x00080000L
#define CF_NOSTYLESEL		     0x00100000L
#define CF_NOSIZESEL		     0x00200000L

/* these are extra nFontType bits that are added to what is returned to the
 * EnumFonts callback routine */

#define SIMULATED_FONTTYPE	0x8000
#define PRINTER_FONTTYPE	0x4000
#define SCREEN_FONTTYPE		0x2000
#define BOLD_FONTTYPE		0x0100
#define ITALIC_FONTTYPE		0x0200
#define REGULAR_FONTTYPE	0x0400

#define WM_CHOOSEFONT_GETLOGFONT	(WM_USER + 1)


/* strings used to obtain unique window message for communication
 * between dialog and caller
 */
#define LBSELCHSTRING  "commdlg_LBSelChangedNotify"
#define SHAREVISTRING  "commdlg_ShareViolation"
#define FILEOKSTRING   "commdlg_FileNameOK"
#define COLOROKSTRING  "commdlg_ColorOK"
#define SETRGBSTRING   "commdlg_SetRGBColor"
#define FINDMSGSTRING  "commdlg_FindReplace"
#define HELPMSGSTRING  "commdlg_help"

/* HIWORD values for lParam of commdlg_LBSelChangeNotify message */
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef struct tagPD
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    HDC     hDC;
    DWORD   Flags;
    UINT    nFromPage;
    UINT    nToPage;
    UINT    nMinPage;
    UINT    nMaxPage;
    UINT    nCopies;
    HINSTANCE hInstance;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnPrintHook)(HWND, UINT, WPARAM, LPARAM);
    UINT    (CALLBACK* lpfnSetupHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpPrintTemplateName;
    LPCSTR  lpSetupTemplateName;
    HGLOBAL hPrintTemplate;
    HGLOBAL hSetupTemplate;
} PRINTDLG;
typedef PRINTDLG  FAR* LPPRINTDLG;

BOOL    WINAPI PrintDlg(PRINTDLG FAR*);

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000

typedef struct tagDEVNAMES
{
    UINT wDriverOffset;
    UINT wDeviceOffset;
    UINT wOutputOffset;
    UINT wDefault;
} DEVNAMES;
typedef DEVNAMES FAR* LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD   WINAPI CommDlgExtendedError(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\convdll.inc ===
WLOINITDLL      macro
                local cd_start, cd_patch, cd_init, WIN_NOP, WIN_PPLI
                local cd_end
         EXTRN   GETMODULEUSAGE:FAR
         EXTRN   INITTASK:FAR
         EXTRN   __WINFLAGS:abs

cd_start:
                push    ax
                push    bx
                push    cx
                push    dx
                push    es

                mov	ax, __WINFLAGS
                or	ax,ax
                jns     WIN_NOP

                pop     es
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                call    INITTASK-5
cd_patch:
                jmp     short cd_init
                nop
                xor     ax, ax
                retf
cd_init:        jmp     short cd_end

WIN_NOP:
                jmp     short WIN_PPLI
                jmp     short WIN_PPLI
                push    di
                call    GETMODULEUSAGE
                dec     ax
                jz      WIN_PPLI
                inc     ax
                add     sp,10
                retf

WIN_PPLI:
                pop     es
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                jmp     short cd_end
                db      "C", "D", "D", 1, 0
		dw      cd_patch - cd_start
		dw      WIN_NOP - cd_start
		dw      cd_end - cd_start
cd_end:

endm
        WLOINITDLL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\custcntl.h ===
/*****************************************************************************\
*                                                                             *
* custcntl.h -  Custom Control Library header file                            *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CUSTCNTL
#define _INC_CUSTCNTL

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*
 * Every custom control DLL must have three functions present,
 * and they must be exported by the following ordinals.
 */
#define CCINFOORD       2       /* information function ordinal */
#define CCSTYLEORD      3       /* styles function ordinal */
#define CCFLAGSORD      4       /* translate flags function ordinal */

/* general size definitions */
#define CTLTYPES        12      /* max number of control types */
#define CTLDESCR        22      /* max size of description */
#define CTLCLASS        20      /* max size of class name */
#define CTLTITLE        94      /* max size of control text */

/*
 * CONTROL STYLE DATA STRUCTURE
 *
 * This data structure is used by the class style dialog function
 * to set and/or reset various control attributes.
 *
 */
typedef struct tagCTLSTYLE
{
    UINT    wX;                 /* x origin of control */
    UINT    wY;                 /* y origin of control */
    UINT    wCx;                /* width of control */
    UINT    wCy;                /* height of control */
    UINT    wId;                /* control child id */
    DWORD   dwStyle;            /* control style */
    char    szClass[CTLCLASS];  /* name of control class */
    char    szTitle[CTLTITLE];  /* control text */
} CTLSTYLE;
typedef CTLSTYLE *      PCTLSTYLE;
typedef CTLSTYLE FAR*   LPCTLSTYLE;

/*
 * CONTROL DATA STRUCTURE
 *
 * This data structure is returned by the control options function
 * when inquiring about the capabilities of a particular control.
 * Each control may contain various types (with predefined style
 * bits) under one general class.
 *
 * The width and height fields are used to provide the host
 * application with a suggested size.  The values in these fields
 * are in rc coordinates.
 *
 */
typedef struct tagCTLTYPE
{
    UINT    wType;              /* type style */
    UINT    wWidth;             /* suggested width */
    UINT    wHeight;            /* suggested height */
    DWORD   dwStyle;            /* default style */
    char    szDescr[CTLDESCR];  /* description */
} CTLTYPE;

typedef struct tagCTLINFO
{
    UINT    wVersion;           /* control version */
    UINT    wCtlTypes;          /* control types */
    char    szClass[CTLCLASS];  /* control class name */
    char    szTitle[CTLTITLE];  /* control title */
    char    szReserved[10];     /* reserved for future use */
    CTLTYPE Type[CTLTYPES];     /* control type list */
} CTLINFO;
typedef CTLINFO *       PCTLINFO;
typedef CTLINFO FAR*    LPCTLINFO;

/* These two function prototypes are used by the dialog editor */
#ifdef STRICT
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPCSTR);
#else
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPSTR);
#endif
typedef UINT    (CALLBACK* LPFNIDTOSTR)(UINT, LPSTR, UINT);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_CUSTCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\dde.h ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DDE
#define _INC_DDE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	    (WM_DDE_FIRST+4)
#define WM_DDE_DATA	    (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	    (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	    (WM_DDE_FIRST+8)

/****************************************************************************\
*       DDEACK structure
*
*       Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
*       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
*       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
*
\****************************************************************************/

typedef struct tagDDEACK
{
    WORD    bAppReturnCode:8,
            reserved:6,
            fBusy:1,
            fAck:1;
} DDEACK;

/****************************************************************************\
*       DDEADVISE structure
*
*       WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
*
\****************************************************************************/

typedef struct tagDDEADVISE
{
    WORD    reserved:14,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDEADVISE;

/****************************************************************************\
*       DDEDATA structure
*
*       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEDATA
{
    WORD    unused:12,
            fResponse:1,
            fRelease:1,
            reserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE     Value[1];
} DDEDATA;


/****************************************************************************\
*       DDEPOKE structure
*
*       WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEPOKE
{
    WORD    unused:13,  /* Earlier versions of DDE.H incorrectly */
                        /* 12 unused bits.                       */
            fRelease:1,
            fReserved:2;
    short   cfFormat;
    BYTE    Value[1];   /* This member was named rgb[1] in previous */
                        /* versions of DDE.H                        */

} DDEPOKE;

/****************************************************************************\
* The following typedef's were used in previous versions of the Windows SDK.
* They are still valid.  The above typedef's define exactly the same structures
* as those below.  The above typedef names are recommended, however, as they
* are more meaningful.
*
* Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
* not correctly define the bit positions.
\****************************************************************************/

typedef struct tagDDELN
{
    WORD    unused:13,
            fRelease:1,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDELN;

typedef struct tagDDEUP
{
    WORD    unused:12,
            fAck:1,
            fRelease:1,
            fReserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE    rgb[1];
} DDEUP;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_DDE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\dbcs.c ===
/*
** dbcs.c - DBCS functions for DOS apps.
**
** Written by RokaH and DavidDi.
*/


/* Headers
**********/

#include <dos.h>
#include <ctype.h>

#include <dbcs.h>


/*
** int IsDBCSLeadByte(unsigned char uch);
**
** Check to see if a character is a DBCS lead byte.
**
** Arguments:  uch - charcter to examine
**
** Returns:    int - 1 if the character is a DBCS lead byte.  0 if not.
**
** Globals:    none
*/
int IsDBCSLeadByte(unsigned char uch)
{
   static unsigned char far *DBCSLeadByteTable = 0;
   union REGS inregs, outregs;
   struct SREGS segregs;
   unsigned char far *puch;

   if (DBCSLeadByteTable == 0)
   {
      /*
      ** Get DBCS lead byte table.  This function has been supported since
      ** DBCS MS-DOS 2.21.
      */
      inregs.x.ax = 0x6300;
      intdosx(&inregs, &outregs, &segregs);

      FP_OFF(DBCSLeadByteTable) = outregs.x.si;
      FP_SEG(DBCSLeadByteTable) = segregs.ds;
   }

   /* See if the given byte is in any of the table's lead byte ranges. */
   for (puch = DBCSLeadByteTable; puch[0] || puch[1]; puch += 2)
      if (uch >= puch[0] && uch <= puch[1])
         return(1);

   return(0);
}


/*
** unsigned char *AnsiNext(unsigned char *puch);
**
** Moves to the next character in a string.
**
** Arguments:  puch - pointer to current location in string
**
** Returns:    char * - Pointer to next character in string.
**
** Globals:    none
**
** N.b., if puch points to a null character, AnsiNext() will return puch.
*/
unsigned char far *AnsiNext(unsigned char far *puch)
{
   if (*puch == '\0')
      return(puch);
   else if (IsDBCSLeadByte(*puch))
      puch++;

   puch++;

   return(puch);
}


/*
** unsigned char *AnsiPrev(unsigned char *psz, unsigned char *puch);
**
** Moves back one character in a string.
**
** Arguments:  psz  - pointer to start of string
**             puch - pointer to current location in string
**
** Returns:    char * - Pointer to previous character in string.
**
** Globals:    none
**
** N.b., if puch <= psz, AnsiPrev() will return psz.
**
** This function is implemented in a very slow fashion because we do not wish
** to trust that the given string is necessarily DBCS "safe," i.e., contains
** only single-byte characters and valid DBCS characters.  So we start from
** the beginning of the string and work our way forward.
*/
unsigned char far *AnsiPrev(unsigned char far *psz, unsigned char far *puch)
{
   unsigned char far *puchPrevious;

   do
   {
      puchPrevious = psz;
      psz = AnsiNext(psz);
   } while (*psz != '\0' && psz < puch);

   return(puchPrevious);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\cpl.h ===
/*****************************************************************************\
*                                                                             *
* cpl.h -       Control panel extension DLL definitions                       *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
******************************************************************************
*  General rules for being installed in the Control Panel:
*
*      1) The DLL must export a function named CPlApplet which will handle
*         the messages discussed below.
*      2) If the applet needs to save information in CONTROL.INI minimize
*         clutter by using the application name [MMCPL.appletname].
*      2) If the applet is refrenced in CONTROL.INI under [MMCPL] use
*         the following form:
*              ...
*              [MMCPL]
*              uniqueName=c:\mydir\myapplet.dll
*              ...
*
*
*  The order applet DLL's are loaded by CONTROL.EXE is:
*
*      1) MAIN.CPL is loaded from the windows system directory.
*
*      2) Installable drivers that are loaded and export the
*         CplApplet() routine.
*
*      3) DLL's specified in the [MMCPL] section of CONTROL.INI.
*
*      4) DLL's named *.CPL from windows system directory.
*
*/
#ifndef _INC_CPL
#define _INC_CPL

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * CONTROL.EXE will answer this message and launch an applet
 *
 * WM_CPL_LAUNCH
 *
 *      wParam      - window handle of calling app
 *      lParam      - LPSTR of name of applet to launch
 *
 * WM_CPL_LAUNCHED
 *
 *      wParam      - TRUE/FALSE if applet was launched
 *      lParam      - NULL
 *
 * CONTROL.EXE will post this message to the caller when the applet returns
 * (ie., when wParam is a valid window handle)
 *
 */
#define WM_CPL_LAUNCH   (WM_USER+1000)
#define WM_CPL_LAUNCHED (WM_USER+1001)

/* A function prototype for CPlApplet() */

typedef LRESULT (CALLBACK *APPLET_PROC)(HWND hwndCpl, UINT msg, LPARAM lParam1, LPARAM lParam2);

/* The data structure CPlApplet() must fill in. */

typedef struct tagCPLINFO
{
    int     idIcon;     /* icon resource id, provided by CPlApplet() */
    int     idName;     /* name string res. id, provided by CPlApplet() */
    int     idInfo;     /* info string res. id, provided by CPlApplet() */
    LONG    lData;      /* user defined data */
} CPLINFO, *PCPLINFO, FAR *LPCPLINFO;

typedef struct tagNEWCPLINFO
{
    DWORD       dwSize;         /* similar to the commdlg */
    DWORD	dwFlags;
    DWORD       dwHelpContext;  /* help context to use */
    LONG        lData;          /* user defined data */
    HICON       hIcon;          /* icon to use, this is owned by CONTROL.EXE (may be deleted) */
    char        szName[32];     /* short name */
    char        szInfo[64];     /* long name (status line) */
    char        szHelpFile[128];/* path to help file to use */
} NEWCPLINFO, *PNEWCPLINFO, FAR *LPNEWCPLINFO;


/* The messages CPlApplet() must handle: */

#define CPL_INIT        1
/*  This message is sent to indicate CPlApplet() was found. */
/*  lParam1 and lParam2 are not defined. */
/*  Return TRUE or FALSE indicating whether the control panel should proceed. */


#define CPL_GETCOUNT    2
/*  This message is sent to determine the number of applets to be displayed. */
/*  lParam1 and lParam2 are not defined. */
/*  Return the number of applets you wish to display in the control */
/*  panel window. */


#define CPL_INQUIRE     3
/*  This message is sent for information about each applet. */
/*  lParam1 is the applet number to register, a value from 0 to */
/*  (CPL_GETCOUNT - 1).  lParam2 is a far ptr to a CPLINFO structure. */
/*  Fill in CPL_INFO's idIcon, idName, idInfo and lData fields with */
/*  the resource id for an icon to display, name and description string ids, */
/*  and a long data item associated with applet #lParam1. */


#define CPL_SELECT      4
/*  This message is sent when the applet's icon has been clicked upon. */
/*  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */


#define CPL_DBLCLK      5
/*  This message is sent when the applet's icon has been double-clicked */
/*  upon.  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */
/*  This message should initiate the applet's dialog box. */


#define CPL_STOP        6
/*  This message is sent for each applet when the control panel is exiting. */
/*  lParam1 is the applet number.  lParam2 is the applet's lData  value. */
/*  Do applet specific cleaning up here. */


#define CPL_EXIT        7
/*  This message is sent just before the control panel calls FreeLibrary. */
/*  lParam1 and lParam2 are not defined. */
/*  Do non-applet specific cleaning up here. */


#define CPL_NEWINQUIRE	8
/* this is the same as CPL_INQUIRE execpt lParam2 is a pointer to a */
/* NEWCPLINFO structure.  this will be sent before the CPL_INQUIRE */
/* and if it is responed to (return != 0) CPL_INQUIRE will not be sent */

#define CPL_DO_PRINTER_SETUP	100	/* ;Internal */
#define CPL_DO_NETPRN_SETUP	101	/* ;Internal */

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_CPL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\ddeml.h ===
/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEML
#define _INC_DDEML

#ifndef RC_INVOKED
#pragma pack(1)
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {                /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef _INC_WINDOWS    /* If not included with 3.1 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifndef DECLARE_HANDLE32
#ifdef STRICT
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ _far* name
#else   /* STRICT */
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */
#endif  /* !DECLARE_HANDLE32 */

#define EXPENTRY    WINAPI

/******** public types ********/

DECLARE_HANDLE32(HCONVLIST);
DECLARE_HANDLE32(HCONV);
DECLARE_HANDLE32(HSZ);
DECLARE_HANDLE32(HDDEDATA);

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR
{
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT
{
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;

/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO
{
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* Added to allow access for NetDDE. */
    HWND    hwndPartner;   /* Added to allow access for NetDDE. */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED        0x0001
#define     ST_ADVISE           0x0002
#define     ST_ISLOCAL          0x0004
#define     ST_BLOCKED          0x0008
#define     ST_CLIENT           0x0010
#define     ST_TERMINATED       0x0020
#define     ST_INLIST           0x0040
#define     ST_BLOCKNEXT        0x0080
#define     ST_ISSELF           0x0100

/* DDE constants for wStatus field */

#define DDE_FACK	  	0x8000
#define DDE_FBUSY	  	0x4000
#define DDE_FDEFERUPD		0x4000
#define DDE_FACKREQ	        0x8000
#define DDE_FRELEASE  		0x2000
#define DDE_FREQUESTED		0x1000
#define DDE_FACKRESERVED	0x3ff0
#define DDE_FADVRESERVED	0x3fff
#define DDE_FDATRESERVED	0x4fff
#define DDE_FPOKRESERVED	0xdfff
#define DDE_FAPPSTATUS		0x00ff
#define DDE_FNOTPROCESSED   0x0000

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           -1L

/***** Transaction ID constants *****/

#define     QID_SYNC                -1L

/****** public strings used in DDE ******/

#define SZDDESYS_TOPIC          "System"
#define SZDDESYS_ITEM_TOPICS    "Topics"
#define SZDDESYS_ITEM_SYSITEMS  "SysItems"
#define SZDDESYS_ITEM_RTNMSG    "ReturnMessage"
#define SZDDESYS_ITEM_STATUS    "Status"
#define SZDDESYS_ITEM_FORMATS   "Formats"
#define SZDDESYS_ITEM_HELP      "Help"
#define SZDDE_ITEM_ITEMLIST     "TopicItemList"


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef FNCALLBACK *PFNCALLBACK;

#define     CBR_BLOCK                0xffffffffL

/* DLL registration functions */

UINT    WINAPI DdeInitialize(DWORD FAR* pidInst, PFNCALLBACK pfnCallback,
                DWORD afCmd, DWORD ulRes);

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL


BOOL    WINAPI DdeUninitialize(DWORD idInst);

/* conversation enumeration functions */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
            HCONVLIST hConvList, CONVCONTEXT FAR* pCC);
HCONV   WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL    WINAPI DdeDisconnectList(HCONVLIST hConvList);

/* conversation control functions */

HCONV   WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
            CONVCONTEXT FAR* pCC);
BOOL    WINAPI DdeDisconnect(HCONV hConv);
HCONV   WINAPI DdeReconnect(HCONV hConv);

UINT    WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, CONVINFO FAR* pConvInfo);
BOOL    WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);

BOOL    WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/* app server interface functions */

BOOL    WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL    WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2

HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/* app client interface functions */

HDDEDATA WINAPI DdeClientTransaction(void FAR* pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, DWORD FAR* pdwResult);

/* data transfer functions */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, void FAR* pSrc, DWORD cb,
            DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, void FAR* pSrc, DWORD cb, DWORD cbOff);
DWORD   WINAPI DdeGetData(HDDEDATA hData, void FAR* pDst, DWORD cbMax, DWORD cbOff);
BYTE FAR* WINAPI DdeAccessData(HDDEDATA hData, DWORD FAR* pcbDataSize);
BOOL    WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL    WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001



UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ     WINAPI DdeCreateStringHandle(DWORD idInst, LPCSTR psz, int iCodePage);
DWORD   WINAPI DdeQueryString(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
BOOL    WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL    WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int     WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/* */
/* DDEML public debugging header file info */
/* */

typedef struct tagMONMSGSTRUCT
{
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
} MONMSGSTRUCT;

typedef struct tagMONCBSTRUCT
{
    UINT   cb;
    WORD   wReserved;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
} MONCBSTRUCT;

typedef struct tagMONHSZSTRUCT
{
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WORD   wReserved;
    char   str[1];
} MONHSZSTRUCT;

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4


typedef struct tagMONERRSTRUCT
{
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT;

typedef struct tagMONLINKSTRUCT
{
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT
{
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;
    HCONV   hConvServer;
} MONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif /* _INC_DDEML */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\dbcs.h ===
/*
** dbcs.h - DBCS functions prototypes for DOS apps.
*/

extern int IsDBCSLeadByte(unsigned char uch);
extern unsigned char far *AnsiNext(unsigned char far *puch);
extern unsigned char far *AnsiPrev(unsigned char far *psz, unsigned char far *puch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\dlgs.h ===
/*****************************************************************************\
*                                                                             *
* dlgs.h -      Common dialog's dialog element ID numbers                     *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DLGS
#define _INC_DLGS

#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#endif  /* !_INC_DLGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\dosx.inc ===
;******************************************************************************
;
;   Copyright (c) Microsoft Corporation 1989-1990.
;
;   Title:	DOSX.INC - Equates and Structures for 286 DOS Extender
;			   Int 2Fh Interface
;
;   Version:	3.00
;
;   Date:	27-Jun-1989
;
;   Author:	JEM
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   27-Jun-1989 JEM Original
;
;==============================================================================


DOSXFunc	EQU	46h		;286 DOS Extender Int 2Fh Multiplex ID


; DOSX Int 2Fh subfunctions

DOSXQuery	EQU	00h		;Query DOS Extender installation
DOSXSuspend	EQU	01h		;Suspend Network posting call
DOSXResume	EQU	02h		;Resume Network posting call
DOSXAbort	EQU	03h		;Abort Child application call
DOSXInfo	EQU	04h		;Get Info structure pointer call

DOSXLast	EQU	DOSXInfo	;Last valid Int 2Fh request


; Structure returned in ES:BX by DOSXInfo call

DOSXInfoTbl	struc
DOSXInfoVer	dw	?		;version # of info structure
hXMSHeap	dw	?		;XMS handle to DOSX heap block
selAppBlk	dw	?		;1st selector to application memory blk
cbAppBlk	dd	?		;size in bytes of app memory block
ckReservedLow	dw	?		;size in K of low memory to reserve
DOSXInfoTbl	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\drivinit.h ===
/* OBSOLETE: Use print.h instead */
#include <print.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\gpfix.inc ===
; GPFix.inc - definitions for GP exception handler code
; usage -
;  1) include gpfix.inc
;  2) bracket critical code with "beg_fault_trap handler" and
;     "end_fault_trap"
;  3) define a handler entry point where execution should continue
;    a) this must be in the same code segment as the faulty code
;    b) two extra words (fault IP/fault) will be pushed on the stack when
;	an exception occurs.  They should be popped before continuing.
;	This can be done with the 'fault_fix_stack' macro.
;	They are there if you want to determine which instruction faulted.
;    c) This handler can do whatever it likes.	Usually, it will return
;	an error code to the caller.
;  4) if you don't want to worry about the extra values on the stack,
;     use the fix_fault_stack macro to remove them

_bft_count = 0
_eft_count = 0

_bft_	macro	handler, count
	_bft_&count:
	_hft_&count = handler
endm

;
; Begin fault critical region.  'handler' is the address of
; the exception handler to jmp to if a fault occurs.
;
beg_fault_trap	macro	handler
	if _bft_count - _eft_count
		.err
		%out Mismatched beg_fault_trap/end_fault_trap pairs in beg_fault_trap
	endif
	_bft_ handler, %_bft_count
	_bft_count = _bft_count + 1
endm

_eft_	macro	count
	_eft_&count:
  _GPFIX    SEGMENT
        dw  seg _bft_&count, _bft_&count, _eft_&count, _hft_&count
  _GPFIX    ENDS
endm

;
; End fault critical region.
;
end_fault_trap  macro
	_eft_ %_eft_count
	_eft_count = _eft_count+1
	if _bft_count - _eft_count
            .err
            %out Mismatched beg_fault_trap/end_fault_trap pairs in end_fault_trap
	endif
endm

;
; Clean up stack in fault handler.
;
fault_fix_stack	macro
        add     sp, 4
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\gdidefs.inc ===
;/*
;***************************************************************************
;									   *
;   Copyright (C) 1983,1984,1985 by Microsoft Inc.			   *
;									   *
;***************************************************************************



;	GDI Definitions for Device Drivers
;
;	Since most of the routines only need a portion of these definitions,
;	conditional assembly flags have been defined in the various files
;	to only include portions as needed (as opposed to having a lot of
;	include files to mess with).  The flags are as follows:
;
;	incFont 	include font definitions
;	incDevice	include device definitions
;	incLogical	include logical object definitions
;	incDrawmode	include DrawMode structure definition
;	incOutput	include Output definitions
;	incControl	include Control definitions

page
;	General definitions that almost everyone will use.



;	Physical Bitmap Structure
;
;	Bitmap data structure passed to OEM routines.  Defines the location and
;	size of a main memory bitmap.



BITMAP		struc							    ;*/ typedef struct {		 /*

  bmType	    dw	0	; 0 means main memory bitmap.  Non-zero     ;*/ short int bmType;		 /*
				; is number of physical display and format
				; of the rest of the structure known only
				; to device driver
  bmWidth	    dw	0	; Width of bitmap in pixels		    ;*/ unsigned short int bmWidth;	 /*
  bmHeight	    dw	0	; Height of bitmap in pixels		    ;*/ unsigned short int bmHeight;	 /*
  bmWidthBytes	    dw	0	; #bytes per scan line			    ;*/ unsigned short int bmWidthBytes; /*
  bmPlanes	    db	0	; # of planes in bitmap 		    ;*/ BYTE		   bmPlanes;	 /*
  bmBitsPixel	    db	0	; # of bits per pixel			    ;*/ BYTE		   bmBitsPixel;  /*
  bmBits	    dd	0	; Far pointer to bits of main memory bitmap ;*/ BYTE FAR	  *bmBits;	 /*
  bmWidthPlanes     dd	0	; Product of bmWidthBytes and bmHeight	    ;*/ unsigned long int  bmWidthPlanes;/*
  bmlpPDevice	    dd	0	; Pointer to associated PDevice 	    ;*/ BYTE FAR	  *bmlpPDevice;  /*
  bmSegmentIndex    dw	0	; Index to plaens next segment if non-zero  ;*/ unsigned short int bmSegmentIndex; /*
  bmScanSegment     dw	0	; Number of scans per segment		    ;*/ unsigned short int bmScanSegment; /*
  bmFillBytes	    dw	0	; Number of unused bytes per segment	    ;*/ unsigned short int bmFillBytes;   /*
		    dw	0						    ;*/ unsigned short int futureUse4;	  /*
		    dw	0						    ;*/ unsigned short int futureUse5;	  /*
BITMAP		    ends						    ;*/ } BITMAP;			  /*

; structures used for Device Independent Bitmap (DIB) processing.
; all taken out of Presentation Manager's documentation 
;  Tuesday 25-October-1988 15:04   -by-   Ron Gery [rong]

; C definitions are provided below (separately).

; triple used in PM1.1 (BitmapCoreInfo) format color table
RGBTriple	    struc	
  rgbtBlue 	    db	0
  rgbtGreen 	    db	0
  rgbtRed 	    db	0
RGBTriple	    ends

; RGB DWORD used in PM2.0 format color table
RGBQuad		    struc
  rgbBlue 	    db	0
  rgbGreen 	    db	0
  rgbRed 	    db	0
  rgbReserved 	    db	0
RGBQuad		    ends

BitmapCoreHeader    struc
  bcSize 	    dd	0
  bcWidth 	    dw	0
  bcHeight 	    dw	0
  bcPlanes 	    dw	0
  bcBitCount 	    dw	0
BitmapCoreHeader    ends

; new format bitmap structure based on PM2.0 format DCR.
;  Tuesday 23-May-1989 16:05   -by-   Ron Gery [rong]

BitmapInfoHeader    struc
  biSize 	    dd	0
  biWidth 	    dd	0
  biHeight 	    dd	0
  biPlanes 	    dw	0
  biBitCount 	    dw	0

  biCompression	    dd  0
  biSizeImage 	    dd	0
  biXPelsPerMeter   dd	0
  biYPelsPerMeter   dd	0
  biClrUsed	    dd	0
  biClrImportant    dd	0
BitmapInfoHeader    ends

BitmapInfo	    struc
  bmiHeader	db (size BitmapInfoHeader) DUP (?)
  bmiColors	db ?			; array of RGBQUADS
BitmapInfo	    ends

BitmapCoreInfo	    struc
  bmciHeader	db (size BitmapCoreHeader) DUP (?)
  bmciColors	db ?			; array of RGBTRIPLES
BitmapCoreInfo	    ends

BI_RGB          equ    0h
BI_RLE8         equ    1h
BI_RLE4         equ    2h

	if	0

*/
/* C definitions for DIBs, as defined in windows.h */

typedef struct {
	DWORD	bcSize;
	WORD	bcWidth;
	WORD	bcHeight;
	WORD	bcPlanes;
	WORD	bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR *LPBITMAPCOREHEADER;
typedef BITMAPCOREHEADER *PBITMAPCOREHEADER;

typedef struct {
  	DWORD	   biSize;
  	DWORD	   biWidth;
  	DWORD	   biHeight;
  	WORD	   biPlanes;
  	WORD	   biBitCount;

	DWORD	   biCompression;
	DWORD	   biSizeImage;
	DWORD	   biXPelsPerMeter;
	DWORD	   biYPelsPerMeter;
	DWORD	   biClrUsed;
	DWORD	   biClrImportant;
} BITMAPINFOHEADER;

typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;
typedef BITMAPINFOHEADER *PBITMAPINFOHEADER;

typedef struct {
	BYTE	rgbtBlue;
	BYTE	rgbtGreen;
	BYTE	rgbtRed;
} RGBTRIPLE;

typedef struct {
	BYTE	rgbBlue;
	BYTE	rgbGreen;
	BYTE	rgbRed;
	BYTE	rgbReserved;
} RGBQUAD;

typedef struct { 
    BITMAPCOREHEADER	bmicHeader;
    RGBQUAD		bmiColors[1];
} BITMAPINFO;

typedef BITMAPINFO FAR *LPBITMAPINFO;
typedef BITMAPINFO *PBITMAPINFO;


/* currently, if the low byte of biCompression is non zero, 
 * it must be one of following */

#define BI_RGB              0x00
#define BI_RLE8             0x01
#define BI_RLE4             0x02

#define BITMAP_SELECTED     0x01
#define BITMAP_64K	    0x01

#define DIBSIGNATURE	    0x4944
/*
	endif

    if	    0
*/
#ifndef NOPTRC
/*
    endif


PTTYPE		struc							    ;*/ typedef     struct {	    /*

  xcoord	dw	0		;x coordinate of point		    ;*/ short int xcoord;	    /*
  ycoord	dw	0		;y coordinate of point		    ;*/ short int ycoord;	    /*

PTTYPE		ends							    ;*/ } PTTYPE;		    /*
									    ;*/ typedef PTTYPE *PPOINT;     /*
									    ;*/ typedef PTTYPE FAR *LPPOINT; /*
    if	    0
*/
#define     POINT   PTTYPE
/*
    endif



RECT		struc							    ;*/ typedef struct {	    /*

  left		dw	0						    ;*/ short int left, 	    /*
  top		dw	0						    ;*/ 	  top,		    /*
  right 	dw	0						    ;*/ 	  right,	    /*
  bottom	dw	0						    ;*/ 	  bottom;	    /*

RECT		ends							    ;*/ } RECT; 		    /*
									    ;*/ typedef RECT  *PRECT;	    /*

    if	    0
*/
#endif
/*
    endif


BOXTYPE 	struc							    ;*/ typedef     struct {	    /*

  min		db	SIZE PTTYPE dup (?)   ;x,y starting coord	    ;*/ PTTYPE min;		    /*
  ext		db	SIZE PTTYPE dup (?)   ;x,y extents		    ;*/ PTTYPE ext;		    /*

BOXTYPE 	ends							    ;*/ } BOXTYPE;		    /*


									    ;*/ typedef RECT  FAR * LPRECT; /*

page
;	Logical Object Definitions  - incLogical
		ifdef	incLogical
		if	incLogical



OBJ_PEN 	equ	1
OBJ_BRUSH	equ	2
OBJ_FONT	equ	3

    if	0
*/
/* Object definitions used by GDI support routines written in C */

#define OBJ_PEN 	1
#define OBJ_BRUSH	2
#define OBJ_FONT	3
/*
    endif


LogBrush	struc							    ;*/ typedef struct {	    /*

  lbStyle	dw	0		;Style of logical BRUSH 	    ;*/ unsigned short int lbStyle; /*
  lbColor	dd	0		;RGB color			    ;*/ unsigned long int  lbColor; /*
  lbHatch	dw	0		;Hatching style 		    ;*/ unsigned short int lbHatch; /*
  lbBkColor	dd	0		;Background color for hatched brush ;*/ unsigned long int lbBkColor;/*

LogBrush	ends							    ;*/ } LOGBRUSH;		    /*

lbPattern      =       lbColor		; pointer to physical pattern

    if	0
*/
#define lbPattern	lbColor
/*
    endif



;	Brush styles defined by GDI

BS_SOLID	equ	0
BS_HOLLOW	equ	1
BS_HATCHED	equ	2
BS_PATTERN	equ	3

MaxBrushStyle	equ	3



;	Hatched Brush hatching styles defined by GDI

HS_HORIZONTAL	equ	0		; Horizontal		 -----
HS_VERTICAL	equ	1		; Vertical		 |||||
HS_FDIAGONAL	equ	2		; Foreward Diagonal	 /////
HS_BDIAGONAL	equ	3		; Backward Diagonal	 \\\\\
HS_CROSS	equ	4		; Cross 		 +++++
HS_DIAGCROSS	equ	5		; Diagonal Cross	 XXXXX

MaxHatchStyle	equ	5

    if	0
*/
/* Brush Style definitions used by GDI support routines written in C */

#define     BS_SOLID		0
#define     BS_HOLLOW		1
#define     BS_HATCHED		2
#define     BS_PATTERN		3

#define     MaxBrushStyle	3


/* Hatch Style definitions used by GDI support routines written in C */

#define     HS_HORIZONTAL	0	/* ----- */
#define     HS_VERTICAL 	1	/* ||||| */
#define     HS_FDIAGONAL	2	/* ///// */
#define     HS_BDIAGONAL	3	/* \\\\\ */
#define     HS_CROSS		4	/* +++++ */
#define     HS_DIAGCROSS	5	/* xxxxx */

#define     MaxHatchStyle	5
/*
    endif




;	Logical Pen Structure

LogPen		struc							    ;*/ typedef struct {	    /*

  lopnStyle	dw	0		;(solid, hollow, dashed..)	    ;*/ unsigned short int lopnStyle;/*
  lopnWidth	dw	0		;This is really a point type	    ;*/ PTTYPE		   lopnWidth;/*
		dw	0
  lopnColor	dd	0						    ;*/ unsigned long int  lopnColor;/*

LogPen		ends							    ;*/ } LOGPEN;		    /*

		errnz	<(SIZE PTTYPE) -4>



;	Line Style definitions

LS_SOLID	equ	  0
LS_DASHED	equ	  1
LS_DOTTED	equ	  2
LS_DOTDASHED	equ	  3
LS_DASHDOTDOT	equ	  4
LS_NOLINE	equ	  5
LS_INSIDEFRAME	equ	  6

MaxLineStyle	equ	LS_NOLINE

    if	0
*/
/* Line Style definitions used by GDI support routines written in C */

#define     LS_SOLID		0
#define     LS_DASHED		1
#define     LS_DOTTED		2
#define     LS_DOTDASHED	3
#define     LS_DASHDOTDOT	4
#define     LS_NOLINE		5
#define     LS_INSIDEFRAME	6
#define     MaxLineStyle	LS_NOLINE
/*
    endif



; Various constants for defining a logical font.
OUT_DEFAULT_PRECIS	equ	0
OUT_STRING_PRECIS	equ	1
OUT_CHARACTER_PRECIS	equ	2
OUT_STROKE_PRECIS	equ	3
OUT_TT_PRECIS		equ	4
OUT_DEVICE_PRECIS	equ	5
OUT_RASTER_PRECIS	equ	6
OUT_TT_ONLY_PRECIS	equ	7

CLIP_DEFAULT_PRECIS	equ	0
CLIP_CHARACTER_PRECIS	equ	1
CLIP_STROKE_PRECIS	equ	2
CLIP_MASK		equ	00Fh
CLIP_LH_ANGLES		equ	010h
CLIP_TT_ALWAYS		equ	020h
CLIP_EMBEDDED		equ	080h

DEFAULT_QUALITY 	equ	0
DRAFT_QUALITY		equ	1
PROOF_QUALITY		equ	2

DEFAULT_PITCH		equ	0
FIXED_PITCH		equ	1
VARIABLE_PITCH		equ	2

ANSI_CHARSET		equ	0
DEFAULT_CHARSET 	equ	1
SYMBOL_CHARSET		equ	2
SHIFTJIS_CHARSET	equ	128
HANGEUL_CHARSET 	equ	129
CHINESEBIG5_CHARSET	equ	136
OEM_CHARSET		equ	255



;	GDI font families.
FF_DONTCARE		equ 00000000b	; Don't care or don't know.
FF_ROMAN		equ 00010000b	; Variable stroke width, serifed.
					; Times Roman, Century Schoolbook, etc.
FF_SWISS		equ 00100000b	; Variable stroke width, sans-serifed.
					; Helvetica, Swiss, etc.
FF_MODERN		equ 00110000b	; Constant stroke width, serifed or sans-serifed.
					; Pica, Elite, Courier, etc.
FF_SCRIPT		equ 01000000b	; Cursive, etc.
FF_DECORATIVE		equ 01010000b	; Old English, etc.


;	Font weights lightest to darkest.
FW_DONTCARE		equ	0d
FW_THIN 		equ	100d
FW_EXTRALIGHT		equ	200d
FW_LIGHT		equ	300d
FW_NORMAL		equ	400d
FW_MEDIUM		equ	500d
FW_SEMIBOLD		equ	600d
FW_BOLD 		equ	700d
FW_EXTRABOLD		equ	800d
FW_HEAVY		equ	900d

FW_ULTRALIGHT		equ	FW_EXTRALIGHT
FW_REGULAR		equ	FW_NORMAL
FW_DEMIBOLD		equ	FW_SEMIBOLD
FW_ULTRABOLD		equ	FW_EXTRABOLD
FW_BLACK		equ	FW_HEAVY


; Enumeration font types.
RASTER_FONTTYPE 	equ	1
DEVICE_FONTTYPE 	equ	2

    if	0
*/

/* The size to allocate for the lfFaceName field in the logical font. */
#ifndef     LF_FACESIZE
#define     LF_FACESIZE     32
#endif

/* Various constants for defining a logical font. */
#define     OUT_DEFAULT_PRECIS	    0
#define     OUT_STRING_PRECIS	    1
#define     OUT_CHARACTER_PRECIS    2
#define     OUT_STROKE_PRECIS	    3
#define     OUT_TT_PRECIS	    4
#define     OUT_DEVICE_PRECIS	    5
#define     OUT_RASTER_PRECIS	    6
#define     OUT_TT_ONLY_PRECIS	    7

#define     CLIP_DEFAULT_PRECIS     0
#define     CLIP_CHARACTER_PRECIS   1
#define     CLIP_STROKE_PRECIS	    2
#define     CLIP_MASK		    0x0F
#define     CLIP_LH_ANGLES	    0x10
#define     CLIP_TT_ALWAYS	    0x20
#define     CLIP_EMBEDDED	    0x80

#define     DEFAULT_QUALITY	    0
#define     DRAFT_QUALITY	    1
#define     PROOF_QUALITY	    2

#define     DEFAULT_PITCH	    0
#define     FIXED_PITCH 	    1
#define     VARIABLE_PITCH	    2

#define     ANSI_CHARSET	    0
#define     DEFAULT_CHARSET	    1
#define     SYMBOL_CHARSET	    2
#define     SHIFTJIS_CHARSET	    128
#define     HANGEUL_CHARSET	    129
#define     CHINESEBIG5_CHARSET     136
#define     OEM_CHARSET 	    255


/*	GDI font families.						*/
#define FF_DONTCARE	(0<<4)	/* Don't care or don't know.		*/
#define FF_ROMAN	(1<<4)	/* Variable stroke width, serifed.	*/
				/* Times Roman, Century Schoolbook, etc.*/
#define FF_SWISS	(2<<4)	/* Variable stroke width, sans-serifed. */
				/* Helvetica, Swiss, etc.		*/
#define FF_MODERN	(3<<4)	/* Constant stroke width, serifed or sans-serifed. */
				/* Pica, Elite, Courier, etc.		*/
#define FF_SCRIPT	(4<<4)	/* Cursive, etc.			*/
#define FF_DECORATIVE	(5<<4)	/* Old English, etc.			*/


/*	Font weights lightest to darkest.				*/
#define FW_DONTCARE		0
#define FW_THIN 		100
#define FW_EXTRALIGHT		200
#define FW_LIGHT		300
#define FW_NORMAL		400
#define FW_MEDIUM		500
#define FW_SEMIBOLD		600
#define FW_BOLD 		700
#define FW_EXTRABOLD		800
#define FW_HEAVY		900

#define FW_ULTRALIGHT		FW_EXTRALIGHT
#define FW_REGULAR		FW_NORMAL
#define FW_DEMIBOLD		FW_SEMIBOLD
#define FW_ULTRABOLD		FW_EXTRABOLD
#define FW_BLACK		FW_HEAVY

/* Enumeration font types. */
#define     RASTER_FONTTYPE	    1
#define     DEVICE_FONTTYPE	    2

/*
    endif


LogFont 	struc							    ;*/ typedef     struct  {	       /*

  lfHeight	      dw      0 					    ;*/ short int lfHeight;	       /*
  lfWidth	      dw      0 					    ;*/ short int lfWidth;	       /*
  lfEscapement	      dw      0 					    ;*/ short int lfEscapement;        /*
  lfOrientation       dw      0 					    ;*/ short int lfOrientation;       /*
  lfWeight	      dw      0 					    ;*/ short int lfWeight;	       /*
  lfItalic	      db      0 					    ;*/ BYTE lfItalic;		       /*
  lfUnderline	      db      0 					    ;*/ BYTE lfUnderline;	       /*
  lfStrikeOut	      db      0 					    ;*/ BYTE lfStrikeOut;	       /*
  lfCharSet	      db      0 					    ;*/ BYTE lfCharSet; 	       /*
  lfOutPrecision      db      0 					    ;*/ BYTE lfOutPrecision;	       /*
  lfClipPrecision     db      0 					    ;*/ BYTE lfClipPrecision;	       /*
  lfQuality	      db      0 					    ;*/ BYTE lfQuality; 	       /*
  lfPitchAndFamily    db      0 					    ;*/ BYTE lfPitchAndFamily;	       /*
  lfFaceName	      db      0 ; A variable length field for the face name.;*/ BYTE lfFaceName[LF_FACESIZE];  /*

LogFont 	ends							    ;*/ } LOGFONT;		       /*


		endif
		endif
page
;		Device Definitions - incDevice


		ifdef	incDevice
		if	incDevice


InquireInfo	=	00000001b	;Inquire Device GDI Info
EnableDevice	=	00000000b	;Enable Device
InfoContext	=	    8000h	;Inquire/Enable for information context



;		Device Technologies

DT_PLOTTER	equ	0		; Vector plotter
DT_RASDISPLAY	equ	1		; Raster display
DT_RASPRINTER	equ	2		; Raster printer
DT_RASCAMERA	equ	3		; Raster camera
DT_CHARSTREAM	equ	4		; Character-stream, PLP
DT_METAFILE	equ	5		; Metafile, VDM
DT_DISPFILE	equ	6		; Display-file


;		Curve Capabilities

CC_NONE 	equ	00000000B	; Curves not supported
CC_CIRCLES	equ	00000001B	; Can do circles
CC_PIE		equ	00000010B	; Can do pie wedges
CC_CHORD	equ	00000100B	; Can do chord arcs
CC_ELLIPSES	equ	00001000B	; Can do ellipese
CC_WIDE 	equ	00010000B	; Can do wide lines
CC_STYLED	equ	00100000B	; Can do styled lines
CC_WIDESTYLED	equ	01000000B	; Can do wide styled lines
CC_INTERIORS	equ	10000000B	; Can do interiors
CC_ROUNDRECT	equ    0100000000B	; Can do round rectangles


;		Line Capabilities

LC_NONE 	equ	00000000B	; Lines not supported
;		equ	00000001B	;
LC_POLYLINE	equ	00000010B	; Can do polylines
LC_MARKER	equ	00000100B	; Can do markers
LC_POLYMARKER	equ	00001000B	; Can do polymarkers
LC_WIDE 	equ	00010000B	; Can do wide lines
LC_STYLED	equ	00100000B	; Can do styled lines
LC_WIDESTYLED	equ	01000000B	; Can do wide styled lines
LC_INTERIORS	equ	10000000B	; Can do interiors


;		Polygonal Capabilities

PC_NONE 	equ	00000000B	; Polygonals not supported
PC_POLYGON	equ	00000001B	; Can do polygons
PC_RECTANGLE	equ	00000010B	; Can do rectangles
PC_WINDPOLYGON	equ	00000100B	; Can do winding polygons
PC_TRAPEZOID	equ	00000100B	; Can do trapezoids
PC_SCANLINE	equ	00001000B	; Can do scanlines
PC_WIDE 	equ	00010000B	; Can do wide borders
PC_STYLED	equ	00100000B	; Can do styled borders
PC_WIDESTYLED	equ	01000000B	; Can do wide styled borders
PC_INTERIORS	equ	10000000B	; Can do interiors

;		Clipping Capabilities

CP_NONE 	equ	00000000B	; No clipping at device level
CP_RECTANGLE	equ	00000001B	; Device Output clips to rectangles

;		Text Capabilities

TC_NONE 	equ 0000000000000000B	; Text not supported
TC_OP_CHARACTER equ 0000000000000001B	; Can do OutputPrecision   CHARACTER
TC_OP_STROKE	equ 0000000000000010B	; Can do OutputPrecision   STROKE
TC_CP_STROKE	equ 0000000000000100B	; Can do ClipPrecision	   STROKE
TC_CR_90	equ 0000000000001000B	; Can do CharRotAbility    90
TC_CR_ANY	equ 0000000000010000B	; Can do CharRotAbility    ANY
TC_SF_X_YINDEP	equ 0000000000100000B	; Can do ScaleFreedom	   X_YINDEPENDENT
TC_SA_DOUBLE	equ 0000000001000000B	; Can do ScaleAbility	   DOUBLE
TC_SA_INTEGER	equ 0000000010000000B	; Can do ScaleAbility	   INTEGER
TC_SA_CONTIN	equ 0000000100000000B	; Can do ScaleAbility	   CONTINUOUS
TC_EA_DOUBLE	equ 0000001000000000B	; Can do EmboldenAbility   DOUBLE
TC_IA_ABLE	equ 0000010000000000B	; Can do ItalisizeAbility  ABLE
TC_UA_ABLE	equ 0000100000000000B	; Can do UnderlineAbility  ABLE
TC_SO_ABLE	equ 0001000000000000B	; Can do StrikeOutAbility  ABLE
TC_RA_ABLE	equ 0010000000000000B	; Can do RasterFontAble    ABLE
TC_VA_ABLE	equ 0100000000000000B	; Can do VectorFontAble    ABLE
TC_RESERVED	equ 1000000000000000B	; Reserved. Must be returned zero.


;		Raster Capabilities

RC_NONE 	equ 0000000000000000b	; No Raster Capabilities
RC_BITBLT	equ 0000000000000001b	; Can do bitblt
RC_BANDING	equ 0000000000000010b	; Requires banding support
RC_SCALING	equ 0000000000000100b	; Requires scaling support
RC_BITMAP64	equ 0000000000001000b	; supports >64k bitmaps
RC_GDI20_OUTPUT	equ 0000000000010000b	; supports Window 2.0 output functions
RC_GDI20_STATE	equ 0000000000100000b	; DC has state block
RC_SAVEBITMAP	equ 0000000001000000b	; can save bitmaps locally
RC_DI_BITMAP	equ 0000000010000000b	; can do device independent bitmaps
RC_PALETTE	equ 0000000100000000b	; can do color palette management
RC_DIBTODEV	equ 0000001000000000b	; can do SetDIBitsToDevice
RC_BIGFONT	equ 0000010000000000b	; does BIGFONTs
RC_STRETCHBLT	equ 0000100000000000b	; can do StretchBlt
RC_FLOODFILL	equ 0001000000000000b	; can do FloodFill
RC_STRETCHDIB	equ 0010000000000000b	; can do StretchDIBits
RC_OP_DX_OUTPUT equ 0100000000000000b   ; can do opaque ext text out

;	DC Management Flags

DC_SPDevice   equ 00000001b	;Seperate PDevice required per device/filename
DC_1PDevice   equ 00000010b	;Only 1 PDevice allowed per device/filename
DC_IgnoreDFNP equ 00000100b	;Ignore device/filename pairs when matching


;	dpCaps1 capability bits

C1_TRANSPARENT	equ 0000000000000001b	; supports transparency
TC_TT_ABLE	equ 0000000000000010b	; can do TT fonts through DDI or brute
C1_TT_CR_ANY	equ 0000000000000100b	; can do rotated TT fonts

    if	0
*/

#define     InquireInfo     0x01	/* Inquire Device GDI Info	   */
#define     EnableDevice    0x00	/* Enable Device		   */
#define     InfoContext     0x8000	/* Inquire/Enable for info context */


/*		Device Technologies				   */

#define     DT_PLOTTER		0	/* Vector plotter	   */
#define     DT_RASDISPLAY	1	/* Raster display	   */
#define     DT_RASPRINTER	2	/* Raster printer	   */
#define     DT_RASCAMERA	3	/* Raster camera	   */
#define     DT_CHARSTREAM	4	/* Character-stream, PLP   */
#define     DT_METAFILE 	5	/* Metafile, VDM	   */
#define     DT_DISPFILE 	6	/* Display-file 	   */

/*		Curve Capabilities				   */

#define     CC_NONE	    00000000	/* Curves not supported    */
#define     CC_CIRCLES	    00000001	/* Can do circles	   */
#define     CC_PIE	    00000002	/* Can do pie wedges	   */
#define     CC_CHORD	    00000004	/* Can do chord arcs	   */
#define     CC_ELLIPSES     00000010	/* Can do ellipese	   */
#define     CC_WIDE	    00000020	/* Can do wide lines	   */
#define     CC_STYLED	    00000040	/* Can do styled lines	   */
#define     CC_WIDESTYLED   00000100	/* Can do wide styled lines*/
#define     CC_INTERIORS    00000200	/* Can do interiors	   */
#define     CC_ROUNDRECT    0x0100	/* Can do round rectangles */

/*		 Line Capabilities				   */

#define     LC_NONE	    00000000	/* Lines not supported	   */
#define     LC_POLYLINE     00000002	/* Can do polylines	   */
#define     LC_MARKER	    00000004	/* Can do markers	   */
#define     LC_POLYMARKER   00000010	/* Can do polymarkers	   */
#define     LC_WIDE	    00000020	/* Can do wide lines	   */
#define     LC_STYLED	    00000040	/* Can do styled lines	   */
#define     LC_WIDESTYLED   00000100	/* Can do wide styled lines*/
#define     LC_INTERIORS    00000200	/* Can do interiors	   */

/*		 Polygonal Capabilities 			   */

#define     PC_NONE	    00000000	/* Polygonals not supported*/
#define     PC_POLYGON	    00000001	/* Can do polygons	   */
#define     PC_RECTANGLE    00000002	/* Can do rectangles	   */
#define     PC_WINDPOLYGON  00000004	/* Can do winding polygons */
#define     PC_TRAPEZOID    00000004	/* Can do trapezoids	   */
#define     PC_SCANLINE     00000010	/* Can do scanlines	   */
#define     PC_WIDE	    00000020	/* Can do wide borders	   */
#define     PC_STYLED	    00000040	/* Can do styled borders   */
#define     PC_WIDESTYLED   00000100	/* Can do wide styled borders*/
#define     PC_INTERIORS    00000200	/* Can do interiors	   */

/*		 Polygonal Capabilities 			   */

#define     CP_NONE	    00000000	/* no clipping of Output   */
#define     CP_RECTANGLE    00000001	/* Output clipped to Rects */

/*		 Text Capabilities					    */

#define TC_OP_CHARACTER 0000001     /* Can do OutputPrecision	CHARACTER      */
#define TC_OP_STROKE	0000002     /* Can do OutputPrecision	STROKE	       */
#define TC_CP_STROKE	0000004     /* Can do ClipPrecision	STROKE	       */
#define TC_CR_90	0000010     /* Can do CharRotAbility	90	       */
#define TC_CR_ANY	0000020     /* Can do CharRotAbility	ANY	       */
#define TC_SF_X_YINDEP	0000040     /* Can do ScaleFreedom	X_YINDEPENDENT */
#define TC_SA_DOUBLE	0000100     /* Can do ScaleAbility	DOUBLE	       */
#define TC_SA_INTEGER	0000200     /* Can do ScaleAbility	INTEGER        */
#define TC_SA_CONTIN	0000400     /* Can do ScaleAbility	CONTINUOUS     */
#define TC_EA_DOUBLE	0001000     /* Can do EmboldenAbility	DOUBLE	       */
#define TC_IA_ABLE	0002000     /* Can do ItalisizeAbility	ABLE	       */
#define TC_UA_ABLE	0004000     /* Can do UnderlineAbility	ABLE	       */
#define TC_SO_ABLE	0010000     /* Can do StrikeOutAbility	ABLE	       */
#define TC_RA_ABLE	0020000     /* Can do RasterFontAble	ABLE	       */
#define TC_VA_ABLE	0040000     /* Can do VectorFontAble	ABLE	       */
#define TC_RESERVED	0100000     /* Reserved. Must be returned zero.        */

/*		 Raster Capabilities				   */

#define RC_NONE 	00000000    /* No Raster Capabilities	   */
#define RC_BITBLT	00000001    /* Can do bitblt		   */
#define RC_BANDING	00000002    /* Requires banding support    */
#define RC_SCALING	00000004    /* Requires scaling support    */
#define RC_BITMAP64	00000010    /* supports >64k bitmaps	   */
#define RC_GDI20_OUTPUT 00000020    /* support Windows 2.0 functions */
#define RC_GDI20_STATE	00000040    /* dc has a state block	   */
#define	RC_SAVEBITMAP	00000100    /* can save bitmaps locally	   */

#define RC_DI_BITMAP	00000200    /* can do device independent bitmaps*/
#define RC_PALETTE	00000400    /* can do color palette management	*/
#define RC_DIBTODEV	00001000    /* can do SetDIBitsToDevice 	*/
#define RC_BIGFONT	00002000    /* does BIGFONTs			*/
#define RC_STRETCHBLT	00004000    /* can do StretchBlt		*/
#define RC_FLOODFILL	00010000    /* can do FloodFill 		*/
#define RC_STRETCHDIB	00020000    /* can do StretchDIBits		*/

/*	DC Management Flags					   */

#define DC_SPDevice	0000001     /* Seperate PDevice required per device/filename */
#define DC_1PDevice	0000002     /* Only 1 PDevice allowed per device/filename    */
#define DC_IgnoreDFNP	0000004     /* Ignore device/filename pairs when matching    */

/*	dpCaps1 capability bits 					    */

#define C1_TRANSPARENT	0x0001	    /* supports transparency		    */
#define TC_TT_ABLE	0x0002	    /* can do TT fonts through DDI or brute */
#define C1_TT_CR_ANY	0x0004	    /* can do rotated TT fonts	    */

/*
	endif

GDIINFO 	struc							    ;*/ typedef struct {	   /*

  dpVersion	dw	0	; Version = 0100h for now		    ;*/ short int dpVersion;	   /*
  dpTechnology	dw	0	; Device classification 		    ;*/ short int dpTechnology;    /*
  dpHorzSize	dw	0	; Horizontal size in millimeters	    ;*/ short int dpHorzSize;	   /*
  dpVertSize	dw	0	; Vertical   size in millimeters	    ;*/ short int dpVertSize;	   /*
  dpHorzRes	dw	0	; Horizontal width in pixels		    ;*/ short int dpHorzRes;	   /*
  dpVertRes	dw	0	; Vertical   width in pixels		    ;*/ short int dpVertRes;	   /*
  dpBitsPixel	dw	0	; Number of bits per pixel		    ;*/ short int dpBitsPixel;	   /*
  dpPlanes	dw	0	; Number of planes			    ;*/ short int dpPlanes;	   /*
  dpNumBrushes	dw	0	; Number of brushes the device has	    ;*/ short int dpNumBrushes;    /*
  dpNumPens	dw	0	; Number of pens the device has 	    ;*/ short int dpNumPens;	   /*
		dw	0	; Number of markers the device has	    ;*/ short int futureuse;	   /*
  dpNumFonts	dw	0	; Number of fonts the device has	    ;*/ short int dpNumFonts;	   /*
  dpNumColors	dw	0	; Number of colors in color table	    ;*/ short int dpNumColors;	   /*
  dpDEVICEsize	dw	0	; Size required for the device descriptor   ;*/ short int dpDEVICEsize;    /*
  dpCurves	dw	0	; Curves    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpCurves;	   /*
  dpLines	dw	0	; Line	    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpLines;	   /*
  dpPolygonals	dw	0	; Polygonal capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpPolygonals; /*
  dpText	dw	0	; Text	    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpText;	   /*
  dpClip	dw	0	; Clipping  capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpClip;	   /*
  dpRaster	dw	0	; Bitblt    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpRaster;	   /*
  dpAspectX	dw	0	; Length of X leg			    ;*/ short int dpAspectX;	   /*
  dpAspectY	dw	0	; Length of Y leg			    ;*/ short int dpAspectY;	   /*
  dpAspectXY	dw	0	; Length of hypotenuse			    ;*/ short int dpAspectXY;	   /*
  dpStyleLen	dw	0	; Length of segment for line styles	    ;*/ short int dpStyleLen;	   /*
  dpMLoWin	dw	0	; Metric  Lo res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpMLoWin;	   /*
		dw	0
  dpMLoVpt	dw	0	; Metric  Lo res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpMLoVpt;	   /*
		dw	0
  dpMHiWin	dw	0	; Metric  Hi res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpMHiWin;	   /*
		dw	0
  dpMHiVpt	dw	0	; Metric  Hi res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpMHiVpt;	   /*
		dw	0
  dpELoWin	dw	0	; English Lo res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpELoWin;	   /*
		dw	0
  dpELoVpt	dw	0	; English Lo res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpELoVpt;	   /*
		dw	0
  dpEHiWin	dw	0	; English Hi res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpEHiWin;	   /*
		dw	0
  dpEHiVpt	dw	0	; English Hi res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpEHiVpt;	   /*
		dw	0
  dpTwpWin	dw	0	; Twips 	 WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpTwpWin;	   /*
		dw	0
  dpTwpVpt	dw	0	; Twips 	 VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpTwpVpt;	   /*
		dw	0
  dpLogPixelsX	dw	0	;Logical pixels/inch in X		    ;*/ short int dpLogPixelsX;    /*
  dpLogPixelsY	dw	0	;Logical pixels/inch in Y		    ;*/ short int dpLogPixelsY;    /*
  dpDCManage	dw	0	;DC Management flags			    ;*/ short int dpDCManage;	   /*
  dpCaps1	dw	0	; more capability bits			    ;*/ unsigned short int dpCaps1;	/*
  dpSpotSizeX	dw	0						    ;*/ short int futureuse4;		/*
		dw	0						    ;*/ short int futureuse5;		/*
  dpSpotSizeY	dw	0						    ;*/ short int futureuse6;		/*
		dw	0						    ;*/ short int futureuse7;		/*

; start of entries in version 3.0 of this structure

  dpNumPalReg	dw	0	; Number of entries in device's palette	    ;*/ WORD dpNumPalReg;	   /*
  dpPalReserved	dw	0	; Number of reserved entries palette	    ;*/ WORD dpPalReserved;	   /*
  dpColorRes	dw	0	; bits of color resolution (total)	    ;*/ WORD dpColorRes;	   /*
GDIINFO 	ends							    ;*/ } GDIINFO;		   /*

		endif
		endif


page
;	Font Definitions
		ifdef	incFont
		if	incFont


PF_BITS_IS_ADDRESS  equ     4
PF_DEVICE_REALIZED  equ     10000000B
PF_RASTER_TYPE	    equ     0
PF_VECTOR_TYPE	    equ     1
PF_OTHER1_TYPE	    equ     2
PF_OTHER2_TYPE	    equ     3


    if	0
*/

/* This bit in the dfType field signals that the dfBitsOffset field is an
   absolute memory address and should not be altered. */
#define PF_BITS_IS_ADDRESS  4

/* This bit in the dfType field signals that the font is device realized. */
#define PF_DEVICE_REALIZED  0x80

/* These bits in the dfType give the fonttype -
       raster, vector, other1, other2. */
#define PF_RASTER_TYPE	    0
#define PF_VECTOR_TYPE	    1
#define PF_OTHER1_TYPE	    2
#define PF_OTHER2_TYPE	    3

/* The size to allocate for the dfMaps field in the physical font. */
#ifndef     DF_MAPSIZE
#define     DF_MAPSIZE	    1
#endif

/*
    endif


;	Font data structure passed to OEM routines.  Refer to chapters 12 and
;	13 of the OEM adaptation guide for a complete description.


FONTINFO	struc							    ;*/ typedef     struct  {	       /*

  dfType	    dw	    0	; Type field for the font.		    ;*/ short int   dfType;	       /*
  dfPoints	    dw	    0	; Point size of font.			    ;*/ short int   dfPoints;	       /*
  dfVertRes	    dw	    0	; Vertical digitization.		    ;*/ short int   dfVertRes;	       /*
  dfHorizRes	    dw	    0	; Horizontal digitization.		    ;*/ short int   dfHorizRes;        /*
  dfAscent	    dw	    0	; Baseline offset from char cell top.	    ;*/ short int   dfAscent;	       /*
  dfInternalLeading dw	    0	; Internal leading included in font	    ;*/ short int   dfInternalLeading; /*
  dfExternalLeading dw	    0	; Prefered extra space between lines	    ;*/ short int   dfExternalLeading; /*
  dfItalic	    db	    0	; Flag specifying if italic.		    ;*/ BYTE	    dfItalic;	       /*
  dfUnderline	    db	    0	; Flag specifying if underlined.	    ;*/ BYTE	    dfUnderline;       /*
  dfStrikeOut	    db	    0	; Flag specifying if struck out.	    ;*/ BYTE	    dfStrikeOut;       /*
  dfWeight	    dw	    0	; Weight of font.			    ;*/ short int   dfWeight;	       /*
  dfCharSet	    db	    0	; Character set of font.		    ;*/ BYTE	    dfCharSet;	       /*
  dfPixWidth	    dw	    0	; Width field for the font.		    ;*/ short int   dfPixWidth;        /*
  dfPixHeight	    dw	    0	; Height field for the font.		    ;*/ short int   dfPixHeight;       /*
  dfPitchAndFamily  db	    0	; Flag specifying variable pitch, family.   ;*/ BYTE	    dfPitchAndFamily;  /*
  dfAvgWidth	    dw	    0	; Average character width.		    ;*/ short int   dfAvgWidth;        /*
  dfMaxWidth	    dw	    0	; Maximum character width.		    ;*/ short int   dfMaxWidth;        /*
  dfFirstChar	    db	    0	; First character in the font.		    ;*/ BYTE	    dfFirstChar;       /*
  dfLastChar	    db	    0	; Last character in the font.		    ;*/ BYTE	    dfLastChar;        /*
  dfDefaultChar     db	    0	; Default character for out of range.	    ;*/ BYTE	    dfDefaultChar;     /*
  dfBreakChar	    db	    0	; Character to define wordbreaks.	    ;*/ BYTE	    dfBreakChar;       /*
  dfWidthBytes	    dw	    0	; Number of bytes in each row.		    ;*/ short int   dfWidthBytes;      /*
  dfDevice	    dd	    0	; Offset to device name.		    ;*/ unsigned long int   dfDevice;  /*
  dfFace	    dd	    0	; Offset to face name.			    ;*/ unsigned long int   dfFace;    /*
  dfBitsPointer     dd	    0	; Bits pointer. 			    ;*/ unsigned long int   dfBitsPointer;/*
  dfBitsOffset	    dd	    0	; Offset to the begining of the bitmap.     ;*/ unsigned long int   dfBitsOffset;/*
				; On the disk, this is relative to the
				; begining of the file. In memory this is
				; relative to the begining of this structure.
  dfReservedByte    db	    0	; filler byte to WORD-align charoffset      ;*/ BYTE dfReservedByte;		/*
  dfCharOffset	    dw	    0	; Area for storing the character offsets,   ;*/ unsigned short dfMaps[DF_MAPSIZE];/*
				; facename, device name (opt), and bitmap.

FONTINFO	ends							    ;*/ } FONTINFO;		       /*

SCALABLEFONTINFO    struc						    ;*/ typedef     struct  {	       /*
  erType	    dw	    0	; Type field for the font.		    ;*/ short int   erType;	       /*
  erPoints	    dw	    0	; Point size of font.			    ;*/ short int   erPoints;	       /*
  erVertRes	    dw	    0	; Vertical digitization.		    ;*/ short int   erVertRes;	       /*
  erHorizRes	    dw	    0	; Horizontal digitization.		    ;*/ short int   erHorizRes;        /*
  erAscent	    dw	    0	; Baseline offset from char cell top.	    ;*/ short int   erAscent;	       /*
  erInternalLeading dw	    0	; Internal leading included in font	    ;*/ short int   erInternalLeading; /*
  erExternalLeading dw	    0	; Prefered extra space between lines	    ;*/ short int   erExternalLeading; /*
  erItalic	    db	    0	; Flag specifying if italic.		    ;*/ BYTE	    erItalic;	       /*
  erUnderline	    db	    0	; Flag specifying if underlined.	    ;*/ BYTE	    erUnderline;       /*
  erStrikeOut	    db	    0	; Flag specifying if struck out.	    ;*/ BYTE	    erStrikeOut;       /*
  erWeight	    dw	    0	; Weight of font.			    ;*/ short int   erWeight;	       /*
  erCharSet	    db	    0	; Character set of font.		    ;*/ BYTE	    erCharSet;	       /*
  erPixWidth	    dw	    0	; Width field for the font.		    ;*/ short int   erPixWidth;        /*
  erPixHeight	    dw	    0	; Height field for the font.		    ;*/ short int   erPixHeight;       /*
  erPitchAndFamily  db	    0	; Flag specifying pitch and family.	    ;*/ BYTE	    erPitchAndFamily;  /*
  erAvgWidth	    dw	    0	; Average character width.		    ;*/ short int   erAvgWidth;        /*
  erMaxWidth	    dw	    0	; Maximum character width.		    ;*/ short int   erMaxWidth;        /*
  erFirstChar	    db	    0	; First character in the font.		    ;*/ BYTE	    erFirstChar;       /*
  erLastChar	    db	    0	; Last character in the font.		    ;*/ BYTE	    erLastChar;        /*
  erDefaultChar     db	    0	; Default character for out of range.	    ;*/ BYTE	    erDefaultChar;     /*
  erBreakChar	    db	    0	; Character to define wordbreaks.	    ;*/ BYTE	    erBreakChar;       /*
  erWidthBytes	    dw	    0	; Number of bytes in each row.		    ;*/ short int   erWidthBytes;      /*
  erDevice	    dd	    0	; Offset to device name.		    ;*/ unsigned long int   erDevice;  /*
  erFace	    dd	    0	; Offset to face name.			    ;*/ unsigned long int   erFace;    /*
  erBitsPointer     dd	    0	; Bits pointer. 			    ;*/ unsigned long int   erBitsPointer;/*
  erBitsOffset	    dd	    0	; Offset to the begining of the bitmap.     ;*/ unsigned long int   erBitsOffset;/*
  erFlags	    db	    0	; flags, and word align the stuff to come   ;*/ BYTE erReservedByte;		/*
  erUnderlinePos    dw	    0	; underline position relative to cell origin	;*/ short int	erUnderlinePos;  /*
  erUnderlineThick  dw	    0	; underline thickness				;*/ short int	erUnderlineThick;/*
  erStrikeoutPos    dw	    0	; Strikeout position relative to cell origin	;*/ short int	erStrikeoutPos;  /*
  erStrikeoutThick  dw	    0	; strikeout thickness				;*/ short int	erStrikeoutThick;/*
SCALABLEFONTINFO    ends						    ;*/ } SCALABLEFONTINFO;	       /*




TEXTXFORM	struc							    ;*/ typedef     struct  {	       /*

  ftHeight	      dw  0						    ;*/ short int ftHeight;	       /*
  ftWidth	      dw  0						    ;*/ short int ftWidth;	       /*
  ftEscapement	      dw  0						    ;*/ short int ftEscapement;        /*
  ftOrientation       dw  0						    ;*/ short int ftOrientation;       /*
  ftWeight	      dw  0						    ;*/ short int ftWeight;	       /*
  ftItalic	      db  0						    ;*/ BYTE ftItalic;		       /*
  ftUnderline	      db  0						    ;*/ BYTE ftUnderline;	       /*
  ftStrikeOut	      db  0						    ;*/ BYTE ftStrikeOut;	       /*
  ftOutPrecision      db  0						    ;*/ BYTE ftOutPrecision;	       /*
  ftClipPrecision     db  0						    ;*/ BYTE ftClipPrecision;	       /*
  ftAccelerator       dw  0						    ;*/ unsigned short int	       /*
									    ;*/ 		ftAccelerator; /*
  ftOverhang	      dw  0						    ;*/ short int ftOverhang;	       /*

TEXTXFORM	ends							    ;*/ } TEXTXFORM;		       /*



TEXTMETRIC	struc							    ;*/ typedef struct {	       /*

  tmHeight		dw  0	  ; Ascent+Descent			    ;*/ short int tmHeight;	       /*
  tmAscent		dw  0	  ; Pixels above the baseline		    ;*/ short int tmAscent;	       /*
  tmDescent		dw  0	  ; Pixels below the baseline		    ;*/ short int tmDescent;	       /*
  tmInternalLeading	dw  0	  ; Internal leading included in font	    ;*/ short int tmInternalLeading;   /*
  tmExternalLeading	dw  0	  ; Prefered extra space between lines	    ;*/ short int tmExternalLeading;   /*
  tmAveCharWidth	dw  0	  ; Of the letter 'X'			    ;*/ short int tmAveCharWidth;      /*
  tmMaxCharWidth	dw  0						    ;*/ short int tmMaxCharWidth;      /*
  tmWeight		dw  0						    ;*/ short int tmWeight;	       /*
  tmItalic		db  0						    ;*/ BYTE	  tmItalic;	       /*
  tmUnderlined		db  0						    ;*/ BYTE	  tmUnderlined;        /*
  tmStruckOut		db  0						    ;*/ BYTE	  tmStruckOut;	       /*
  tmFirstChar		db  0						    ;*/ BYTE	  tmFirstChar;	       /*
  tmLastChar		db  0						    ;*/ BYTE	  tmLastChar;	       /*
  tmDefaultChar 	db  0	  ; dfDefaultChar+dfFirstChar		    ;*/ BYTE	  tmDefaultChar;       /*
  tmBreakChar		db  0	  ; dfBreakChar+dfFirstChar		    ;*/ BYTE	  tmBreakChar;	       /*
  tmPitchAndFamily	db  0	  ; Low bit zero if fixed pitch, one if     ;*/ BYTE	  tmPitchAndFamily;    /*
				  ; variable. Family in high nibble.
  tmCharSet		db  0						    ;*/ BYTE	  tmCharSet;	       /*
  tmOverhang		dw  0						    ;*/ short int tmOverhang;	       /*
  tmDigitizedAspectX	dw  0	  ; Digitization aspect ratio		    ;*/ short int tmDigitizedAspectX;  /*
  tmDigitizedAspectY	dw  0	  ; in X and Y. 			    ;*/ short int tmDigitizedAspectY;  /*

TEXTMETRIC     ends							    ;*/ } TEXTMETRIC;		       /*



		endif
		endif
page
;	Drawing mode definitions - incDrawMode


		ifdef	incDrawMode
		if	incDrawMode


DRAWMODE	struc							    ;*/ typedef     struct {	     /*

  Rop2		dw	0	;The 16-bit encoded Logical op		    ;*/ short int	  Rop2;       /*
  bkMode	dw	0	;Background Mode (for text only)	    ;*/ short int	  bkMode;     /*
  bkColor	dd	0	;Physical background Color		    ;*/ unsigned long int bkColor;    /*
  TextColor	dd	0	;Physical text (forground) color	    ;*/ unsigned long int TextColor;  /*
  TBreakExtra	dw	0	; total pixles to stuff into a line	    ;*/ short int	  TBreakExtra;/*
  BreakExtra	dw	0	; div(TBreakExtra, BreakCount)		    ;*/ short int	  BreakExtra; /*
  BreakErr	dw	0	; running error term			    ;*/ short int	  BreakErr;   /*
  BreakRem	dw	0	; mod(TBreakExtra, BreakCount)		    ;*/ short int	  BreakRem;   /*
  BreakCount	dw	0	; count of breaks in the line		    ;*/ short int	  BreakCount; /*
  CharExtra	dw	0	; extra pixles to stuff after each char     ;*/ short int	  CharExtra;  /*
				;   (used to space out a font)
  LbkColor	dd	0	;Logical background color		    ;*/ unsigned long int LbkColor;   /*
  LTextColor	dd	0	;Logical Text (forground) color 	    ;*/ unsigned long int LTextColor; /*

DRAWMODE	ends							    ;*/ } DRAWMODE;		      /*



;	Background Mode definitions

TRANSPARENT	equ	1
OPAQUE		equ	2

    if	0
*/
/* Background Mode definitions used by GDI support routines written in C */

#define     TRANSPARENT 	1
#define     OPAQUE		2
/*
    endif



		endif
		endif
page
;	Output Definitions - incOutput

		ifdef	incOutput
		if	incOutput


;	Output Style definitions used by GDI


OS_ARC		equ	3
OS_SCANLINES	equ	4
OS_RECTANGLE	equ	6
OS_ELLIPSE	equ	7
OS_MARKER	equ	8
OS_POLYLINE	equ	18
OS_TRAPEZOID	equ	20
OS_POLYGON	equ	22
OS_PIE		equ	23
OS_POLYMARKER	equ	24
OS_CHORD	equ	39
OS_CIRCLE	equ	55

OS_BEGINNSCAN	equ	80
OS_ENDNSCAN	equ	81
    if	0
*/

/* Output Style definitions used by GDI support routines written in C */

#define     OS_ARC		3
#define     OS_SCANLINES	4
#define     OS_RECTANGLE	6
#define     OS_ELLIPSE		7
#define     OS_MARKER		8
#define     OS_POLYLINE 	18
#define     OS_TRAPEZOID	20
#define     OS_POLYGON		22
#define     OS_PIE		23
#define     OS_POLYMARKER	24
#define     OS_CHORD		39
#define     OS_CIRCLE		55

#define	    OS_BEGINNSCAN	80
#define	    OS_ENDNSCAN		81
/*
    endif


		endif
		endif


		ifdef	incControl
		if	incControl

OEM_FAILED	equ	8000000

;	GDI escape constants

NEWFRAME          equ     1
ABORTDOC	  equ     2
NEXTBAND          equ     3
SETCOLORTABLE     equ     4
GETCOLORTABLE     equ     5
FLUSHOUTPUT       equ     6
DRAFTMODE         equ     7
QUERYESCSUPPORT   equ     8
SETPRINTERDC	  equ	  9
SETABORTPROC      equ     9
STARTDOC          equ     10
ENDDOC            equ     11
GETPHYSPAGESIZE   equ     12
GETPRINTINGOFFSET equ     13
GETSCALINGFACTOR  equ     14
MFCOMMENT         equ     15
GETPENWIDTH       equ     16
SETCOPYCOUNT      equ     17
SELECTPAPERSOURCE equ     18
DEVICEDATA	  equ     19
PASSTHROUGH       equ     19
GETTECHNOLGY	  equ     20
GETTECHNOLOGY	  equ     20
SETLINECAP	  equ	  21
SETLINEJOIN	   equ 	  22
SETMITERLIMIT	   equ 	  23
BANDINFO	   equ 	  24
DRAWPATTERNRECT    equ 	  25
GETVECTORPENSIZE   equ 	  26
GETVECTORBRUSHSIZE equ 	  27
ENABLEDUPLEX	   equ 	  28
GETSETPAPERBINS    equ 	  29
GETSETPRINTORIENT  equ 	  30
ENUMPAPERBINS	   equ 	  31
SETDIBSCALING	   equ 	  32
EPSPRINTING        equ 	  33
ENUMPAPERMETRICS   equ 	  34
GETSETPAPERMETRICS equ 	  35
POSTSCRIPT_DATA	   equ 	  37
POSTSCRIPT_IGNORE  equ 	  38
MOUSETRAILS	   equ 	  39
RESETDEVICE	   equ	  128
GETEXTENDEDTEXTMETRICS equ 256
GETEXTENTTABLE         equ 257
GETPAIRKERNTABLE       equ 258
GETTRACKKERNTABLE      equ 259
EXTTEXTOUT             equ 512
GETFACENAME	       equ 513
ENABLERELATIVEWIDTHS   equ 768
ENABLEPAIRKERNING      equ 769
SETKERNTRACK           equ 770
SETALLJUSTVALUES       equ 771
SETCHARSET	       equ 772

STRETCHBLT             equ 2048
BEGIN_PATH	       equ 4096
CLIP_TO_PATH	       equ 4097
END_PATH	       equ 4098
EXT_DEVICE_CAPS	       equ 4099
RESTORE_CTM	       equ 4100
SAVE_CTM	       equ 4101
SET_ARC_DIRECTION      equ 4102
SET_BACKGROUND_COLOR   equ 4103
SET_POLY_MODE	       equ 4104
SET_SCREEN_ANGLE       equ 4105
SET_SPREAD	       equ 4106
TRANSFORM_CTM	       equ 4107
SET_CLIP_BOX	       equ 4108
SET_BOUNDS             equ 4109


    if 0
*/
#define OEM_FAILED	    0x80000000L

#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETPRINTERDC		     9		// DDK - between GDI and Driver
#define SETABORTPROC		     9		// SDK - between APP and GDI
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define RESETDEVICE		     128
#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048
#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

typedef FONTINFO    FAR *LPFONTINFO;
typedef DRAWMODE    FAR *LPDRAWMODE;
typedef TEXTXFORM   FAR *LPTEXTXFORM;
typedef TEXTMETRIC  FAR *LPTEXTMETRIC;
typedef LOGFONT     FAR *LPLOGFONT;
typedef LOGPEN	    FAR *LPLOGPEN;
typedef LOGBRUSH    FAR *LPLOGBRUSH;
typedef BITMAP	    FAR *LPBITMAP;
typedef FARPROC     FAR *LPFARPROC;
typedef GDIINFO     FAR *LPGDIINFO;
typedef SCALABLEFONTINFO FAR * LPSCALABLEFONTINFO;


/*
    endif



		endif
		endif
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\debug.h ===
/* This include file contains the functions needed by debuggers which run
 * under windows. 
 */

/* USER functions */
BOOL FAR PASCAL QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
BOOL FAR PASCAL LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG FAR PASCAL GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState. 
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004

/* Kernel procedures */
void FAR PASCAL DirectedYield(HANDLE hTask);

/* Debug hook to support debugging through other hooks. 
 */
#define WH_DEBUG        9

typedef struct tagDEBUGHOOKSTRUCT
  {
    WORD   hAppHookTask;   //"hTask" of the task that installed the app hook
    DWORD  dwUnUsed;       // This field is unused.
    LONG   lAppHooklParam; //"lParam" of the App hook.
    WORD   wAppHookwParam; //"wParam" of the App hook.
    int	   iAppHookCode;   //"iCode" of the App hook.
  } DEBUGHOOKSTRUCT;

typedef DEBUGHOOKSTRUCT FAR *LPDEBUGHOOKSTRUCT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\debugsys.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	DEBUGSYS.INC - VMM debugging include file
;
;   Version:	1.00
;
;   Date:	13-Jun-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;	       README	README	 README	   README    README
;
; The "master copy" of this file lives in the WIN386 include directory.
; If another copy of this file is ever checked in anywhere, the copy
; should be checked periodically to make sure it is identical with the
; master copy.
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   13-Jun-1988 RAL
;   24-Oct-1988 RAP changed INT from 2E to 41, and added functions for
;		    Windows to notify the debugger about segment selectors
;   14-Dec-1988 RAP split services into ones available through INT 41h
;		    for non-ring 0 clients and those available through INT 21h
;		    for ring 0 clients
;   11-Dec-1990 ERH Merged WIN386 copy with file actually used by the
;		    debugger.
;   11-Dec-1990 ERH Merged file describing real mode services with this
;		    one.
;
;==============================================================================

;******************************************************************************
;
;  Real mode Debugger services:
;
;

D386_RM_Int		equ 68h	; hooked by the debugger in real mode.

D386_Id			equ 0F386h ; debugger identification code

D386_MIN		equ 43h	; minimum INT 68 function code

D386_Identify		equ 43h	; returns debugger identification, if debugger
				; loaded

D386_Prepare_PMode	equ 44h	; partially prepare for protected mode operation
				; a pointer to a procedure is returned so that
				; the IDT can also be set in protected mode
				; INPUT:
				;   AL	0  - retail version of Win386
				;	1  - debugging version
				;   BX	a valid selector that gives access
				;	to all of memory
				;   CX	first of 2 selectors reserved for
				;	WDeb386 to use
				;   DX	is GDT selector
				;   DS:SI pointer to working copy of GDT
				;   ES:DI pointer to working copy of IDT
				;
				; RETURN:
				;   ES:EDI points to a protected mode procedure
				;   (selector:offset32) that can be called
				;   to set the IDT when it has been created.
				;   This protected mode procedure takes a
				;   pointer to the PMode IDT in ES:EDI.

D386_Real_Mode_Init	equ 45h	; re-init fro real mode after entering pmode

D386_Set_Switches	equ 46h	; set debugging switches
				;  BL = verbose switch
				;	- 00b - no segment display
				;	- 01b - display win386 segments only
				;	- 10b - display ring 1 segments only
				;	- 11b - display win386 & ring 1 segs
				;  BH = conditional brkpts
				;	0 - off
				;	1 - on
				; -1 for BX means no change (default)

D386_Execute_Cond	equ 47h	; execute conditional BP (/B option)
				; ES:SI points to NUL terminated string
				; to print if conditional flag set.

D386_Set_Baudrate	equ 49h	; set com port baud rate
				; BX = baud rate

D386_Reinit		equ 4ah	; reinitialize debugger for protected mode
				;  AL  0  - retail version of Win386
				;	  1  - debugging version of Win386
				;	  2  - 286 DOS extender (3.0)
				;	  3  - 286 DOS extender under VCPI (3.1)
				;	  4  - 286 DOS extender (3.1)
				;  BX  a valid selector that gives access
				;      to all of memory
				;  CX  first of 2 selectors reserved for
				;      wdeb386 to use
				;  DX  is GDT selector
				;
				;  This function can after a function 45h only
				;  if function	44 was executed in the past on
				;  the IDT/GDT.

D386_Def_Deb_Segs	equ 4bh	; define debugger's segments

D386_Set_Com_Port	equ 4ch	; set com port number
				; BX = com port number
				; returns AX != 0, error bad com port

D386_Link_Sym		equ 4dh	; link sym file map
				; ES:DI pointer to AddrS struc in front of
				; sym file map.
				; BX = loader ID (used to unlink sym file maps)
				; A loader ID of 0 is used for all the maps
				; wdeb386 loads via /S is ran as a program and
				; -1 is used by the device driver version.  All
				; loader IDs of 0 are automaticly unlinked when
				; wdeb386 exits.

D386_Unlink_Sym		equ 4eh	; unlink sym file maps
				; BX = loader ID - this routine looks at all
				; of the maps that are currently linked and
				; removes the ones that were loaded with this
				; ID.

D386_Remove_Segs	equ 4fh	; remove any undefined segments from the
				;  name module's symbols
				; ES:DI pointer to module name

D386_Load_Segment	equ 50h	; defines the actual segment/selector for a
				; loaded segment to allow for symbol processing
				; INPUT:
				;  AL segment type   0	- code selector
				;		     1	- data selector
				;		    10h - code segment
				;		    11h - data segment
				;		    40h - code segment & sel
				;		    41h - data segment & sel
				;		    80h - device driver code seg
				;		    81h - device driver data seg
				;  If AL < 80h then
				;    BX segment #
				;    CX actual segment/selector
				;    DX actual selector	 (if 40h or 41h)
				;    ES:DI pointer to module name
				;  Else
				;    ES:DI points to D386_Device_Params struc
				;
				; RETURN:
				;    AL = 1, if successful, else 0

D386_Display_Char	equ 51h	; display a character to the debugging terminal
				; AL = char to display

D386_Display_Str	equ 52h	; display a string to the debugging terminal
				; ES:SI points to NUL terminated string

D386_IsVxDInstalled	equ 53h	; returns if debug VxD has been installed
				; AL == 0 if not install, AL != 0 if installed

D386_VxDInstall		equ 54h	; sets that the debug VxD installed/uninstalled
				; BL == 0 if uninstall, BL != 0 if installed

D386_RegisterDotCmd	equ 55h	; registers dot command
				; BL = command letter
				; CX:SI = address of dot command routine
				; DX:DI = address of help text
				; returns AX == 0, no errors
				;	  AX != 0, dot command already used
				;		   or out of dot commands
				; Dot command routine:
				;   AL = command character
				;   DS:SI = linear address of command line
				;	    terminated by a NULL or ";".
				;   DS,ES = debugger's data selector
				;   returns AX == 0, no errors
				;	    AX !=0, command line or option error

D386_DeRegisterDotCmd	equ 56h	; de-registers dot command
				; BL = command letter

D386_Printf		equ 57h	; Printf
				; (DS:SI) = address of format string
				; (ES:DI) = address of the start of parameters
				; set DS_Printf for format char information

D386_Link_Sym_Phys	equ 58h	; link symbol file with physical address
				; (DX:CX) = physical address of one extra 
	 			;  paragraph front of map file image.
				; (SI) = XMS handle (0 if just physical)
				; (BX) = load id

D386_CheckMap		equ 59h	; DX:DI = pointer to module name
				; returns AX != 0, map found
				;	  AX == 0, map not found

D386_SetAutoLoadSym	equ 5ah	; (BL) != 0, auto load symbols
				; (BL) == 0, don't auto load symbols

D386_SetTeftiPort	equ 5bh	; (BX) = TEFTI port address

D386_ExecDebugCommand	equ 5ch	; execute debugger command script
				; (DS:SI) = ptr to debugger command script str
				; (CX) = size of script

D386_LoadCodeDataHigh	equ 5dh	; makes the debugger copy its code/data high
				; (DX:BX) = physical address to put debugger

D386_SetWinVersion	equ 5eh	; sets Windows version number
				; (DI) = Version number (default if this
				; api not called is 0300h).

D386_MAX		equ 5eh	; maximum INT 68 function code

; D386_Load_Segment type equates:

ST_code_sel	equ 0		; code selector
ST_data_sel	equ 1		; data selector
ST_code_seg	equ 10h		; code segment
ST_data_seg	equ 11h		; data segment
ST_dual_code	equ 40h		; code segment and selector
ST_dual_data	equ 41h		; data segment and selector
ST_device_code	equ 80h		; device driver code segment
ST_device_data	equ 81h		; device driver data segment

; D386_Load_Segment device load parameters structure

D386_Device_Params STRUC
DD_logical_seg	dw  ?	; logical segment # from map
DD_actual_sel	dw  ?	; actual selector value
DD_base		dd  ?	; linear address offset for start of segment
DD_length	dd  ?	; actual length of segment
DD_name		df  ?	; 16:32 ptr to null terminated device name
DD_sym_name	df  ?	; 16:32 ptr to null terminated symbolic
			; module name  (i.e. Win386)
DD_alias_sel	dw  ?	; alias selector value (0 = none)
D386_Device_Params ENDS

;
; VCPI information, passed to debugger when client is DOS Extender
; running as a VCPI client.  This information is used to get into
; and out of protected mode when running under a VCPI server.
;
;
; This structure is also used by the DOS Extender.
;
WdebVCPIInfo	  STRUC
;
; Enter protected mode information.
;
	fnVCPI	df	?	; VCPI protect mode server entry point
	rdsVCPI	dw	?	; Selector for VCPI server
;
; Enter v86 mode information.
;
	laVTP	dd	?	; linear address of data structure containing
				; values for system registers.
	Port67	dw	?	; Qualitas magic port for emulating INT 67h
WdebVCPIInfo	  ENDS
;
; The following structure contains the system register contents for the
; VCPI server to use when switching to protected mode.  It is taken
; from dxvcpi.inc in the DOSX project, and is part of the VCPI spec.
;
VTP	struc
	zaCr3VTP	dd	0	; physical addr of page directory
	laGdtrVTP	dd	0	; linear addr in first meg of gdtr
	laIdtrVTP	dd	0	; linear addr in first meg of idtr
	selLdtVTP	dw	0	; selector of ldt
	selTrVTP	dw	0	; selector of tr
	ipVTP		dw	0	; 48-bit address of protect
	unusedVTP	dw	0	;   mode entry point to xfer to
	csVTP		dw	0	;
VTP	ends

VCPI_RM_CALLOUT_INT	equ	67h	; v86 mode call to VCPI server
;
; Send this value in AX to the VCPI server to request V86 to protected
; mode switch or protected to V86 mode switch.
;
VCPI_PROT_ENTRY		equ	0DE0CH


;******************************************************************************
;
;  Protected mode Debugger services:
;
;


Debug_Serv_Int	     equ 41h	; Interrupt that calls Deb386 to perform
				; debugging I/O, AX selects the function as
				; described by the following equates

DS_Out_Char	equ	0	; function to display the char in DL
DS_In_Char	equ	1	; function to read a char into AL
DS_Out_Str	equ	2	; function to display a NUL terminated string
				; pointed to by DS:ESI
DS_Is_Char	equ	3	; Non blocking In_Chr

DS_DebLoaded	equ    4Fh	; check to see if the debugger is installed and
				; knows how to deal with protected mode programs
				; return AX = F386h, if true
DS_DebPresent	equ   0F386h

DS_Out_Str16	equ    12h	; function to display a NUL terminated string
				; pointed to by DS:SI
				; (same as function 2, but for 16 bit callers)

DS_ForcedGO16	equ    40h	; enter the debugger and perform the equivalent
				; of a GO command to force a stop at the
				; specified CS:IP
				; CX is the desired CS
				; BX is the desired IP

DS_LinkMap	equ    45h	; DX:(E)DI = ptr to paragraph in front of map

DS_UnlinkMap	equ    46h	; DX:(E)DI = ptr to paragraph in front of map

DS_CheckMap	equ    47h	; DX:(E)DI = pointer to module name
				; returns AX != 0, map found
				;	  AX == 0, map not found

DS_IsAutoLoadSym equ   48h	; returns AX != 0, auto load symbols
				; 	  AX == 0, don't auto load symbols

DS_LoadSeg	equ    50h	; define a segment value for the
				; debugger's symbol handling
				; SI type   0  - code selector
				;	    1  - data selector
				;	   80h - code segment
				;	   81h - data segment
				; BX segment #
				; CX actual segment/selector
				; DX data instance
				; ES:(E)DI pointer to module name

DS_LoadSeg_32	equ  0150h	; Define a 32-bit segment for Windows 32
				; SI type   0  - code selector
				;	    1  - data selector
				; DX:EBX points to a D386_Device_Params STRUC
				; with all the necessaries in it

DS_MoveSeg	equ    51h	; notify the debugger that a segment has moved
				; BX old segment value
				; CX new segment value

DS_FreeSeg	equ    52h	; notify the debugger that a segment has been
				; freed
				; BX segment value

DS_FreeSeg_32	equ  0152h	; notify the debugger that a segment has been
				; freed
				; BX segment number
				; DX:EDI pointer to module name

DS_DGH		equ    56h	; register "dump global heap" handler
				; BX is code offset
				; CX is code segment
DS_DFL		equ    57h	; register "dump free list" handler
				; BX is code offset
				; CX is code segment
DS_DLL		equ    58h	; register "dump LRU list" handler
				; BX is code offset
				; CX is code segment

DS_StartTask	equ    59h	; notify debugger that a new task is starting
				; BX is task handle
				; task's initial registers are stored on the
				; stack:
				;	push	cs
				;	push	ip
				;	pusha
				;	push	ds
				;	push	es
				;	push	ss
				;	push	sp

DS_Kernel_Vars	equ    5ah	; Used by the Windows kernel to tell the
				; debugger the location of kernel variables
				; used in the heap dump commands.
				; BX = version number of this data (03a0h)
				; DX:CX points to:
				;	WORD	 hGlobalHeap	****
				;	WORD	 pGlobalHeap	****
				;	WORD	 hExeHead	****
				;	WORD	 hExeSweep
				;	WORD	 topPDB
				;	WORD	 headPDB
				;	WORD	 topsizePDB
				;	WORD	 headTDB	****
				;	WORD	 curTDB		****
				;	WORD	 loadTDB
				;	WORD	 LockTDB
				;	WORD	 SelTableLen	****
				;	DWORD	 SelTableStart	****
				;
				; The starred fields are used by the
				; heap dump commands which are internal
				; to WDEB386.


DS_VCPI_Notify	equ    5bh	; notify debugger that DOS extender is
				; running under a VCPI implementation,
				; and register VCPI protect mode interface
				; ES:DI points to a data structure used to
				; get from V86 mode to Pmode under VCPI.
				; This is defined in the VCPI version
				; 1.0 spec.
DS_ReleaseSeg	equ    5ch	; This does the same as a DS_FreeSeg, but
				; it restores any breakpoints first.

DS_POSTLOAD	=	60h	; Used by the RegisterPTrace interface
DS_EXITCALL	=	62h	; Somebody will fill these in if we ever
DS_INT2		=	63h	; figure out what they are supposed to do.
DS_LOADDLL	=	64h
DS_DELMODULE	=	65h

DS_NEWTASK	=	0BH
DS_FLUSHTASK	=	0CH
DS_SWITCHOUT	=	0DH
DS_SWITCHIN	=	0EH

DS_IntRings	equ    20h	; function to tell debugger which INT 1's & 3's
				; to grab
				; BX = 0, grab only ring 0 ints
				; BX != 0, grab all ints
DS_IncludeSegs	equ    21h	; function to tell debugger to go ahead and
				; process INT 1's & 3's which occur in this
				; DX:DI points to list of selectors
				;   (1 word per entry)
				; CX = # of selectors (maximum of 20)
				;   CX = 0, to remove the list of segs
MaxDebugSegs = 20

DS_CondBP	equ 0F001h	; conditional break pt, if the command line
				; switch /B is given when the debugger is run
				; or the conditional flag is later set, then
				; this int should cause the program to break
				; into the debugger, else this int should be
				; ignored!
				; ESI points to a nul terminated string to
				; display if break is to happen.

DS_ForcedBP	equ 0F002h	; break pt, which accomplishes the same thing
				; as an INT 1 or an INT 3, but is a break point
				; that should be permanently left in the code,
				; so that a random search of source code would
				; not result in the accidental removal of this
				; necessary break_pt

DS_ForcedGO	equ 0F003h	; enter the debugger and perform the equivalent
				; of a GO command to force a stop at the
				; specified CS:EIP
				; CX is the desired CS
				; EBX is the desired EIP

DS_HardINT1	equ 0F004h	; check to see if INT 1 hooked for all rings
				; ENTER: nothing
				; EXIT: AX = 0, if no, 1, if yes

DS_FatalFault	equ 0F005h	; check if fault is hooked by debugger via VSF
				; ENTRY BX = trap number
				;	DX = error code
				;	CX:(E)SI = address of CS:(E)IP
				; EXIT: AL == 0, handle fault normally
				;	AL != 0, handled by debugger

DS_Out_Symbol	equ    0Fh	; find the symbol nearest to the address in
				; CX:EBX and display the result in the format
				; symbol name <+offset>
				; the offset is only included if needed, and
				; no CR&LF is displayed

DS_Disasm_Ins	equ    10h	; function to disassemble the instruction
				; pointed to by DS:ESI

DS_RegisterDotCommand  equ 70h	; registers a 32 bit dot command handler

;	This interface is used to register wdeb386 dot commands by FLAT 32
;	bit code.  The following conditions apply:
;
;	* The code will be run at ring 0
;	* Interrupts may not be enabled
;	* Must not access any not present pages or load invalid selectors
;	* Must stay on the stack called with when calling INT 41 services
;	* Must not change DS or ES from the FLAT selector
;
;	The help text is printed when .? is executed in the order of
;	registration.  The text must include CR/LF at the end; nothing
;	is added to the help text.
;
;	ENTRY:	(AX) = 0070h
;		(BL) = dot command to register
;		(ESI) = linear address of dot command routine
;		    Dot command routine:
;			ENTRY:	(AL) = command character
;				(DS, ES) = flat data selector
;
;			EXIT:	(AX) == 0, no errors
;				(AX) !=0, command line or option error
;
;			NOTE:	MUST return with a 32 bit FAR return (retfd)
;		(EDI) = linear address of help text
;
;	EXIT:	(AX) == 0, no errors
;		(AX) != 0, dot command already used or out of dot commands

DS_RegisterDotCommand16 equ 71h	; registers a 16 bit dot command handler

;	This interface is used to register wdeb386 dot commands by 16 bit
;	code.  The following conditions apply:
;
;	* The code will be run at ring 0 or in real mode
;	* Interrupts may not be enabled
;	* Must not access any not present pages or load invalid selectors
;	* Must stay on the stack called with when calling INT 41 services
;
;	The help text is printed when .? is executed in the order of
;	registration.  The text must include CR/LF at the end; nothing
;	is added to the help text.
;
;	ENTRY:	(AX) = 0071h
;		(BL) = dot command to register
;		(CX:SI) = address of dot command routine
;		    Dot command routine:
;			ENTRY:	(AL) = command character
;				(DS, ES) = debugger's data selector
;
;			EXIT:	(AX) == 0, no errors
;				(AX) != 0, command line or option error
;
;			NOTE:	MUST return with a 16 bit FAR return (retf)
;		(DX:DI) = address of help text
;
;	EXIT:	(AX) == 0, no errors
;		(AX) != 0, dot command already used or out of dot commands

DS_DeRegisterDotCommand equ 72h	; de-registers 16 or 32 bit dot command

;	This interface is used to de-register wdeb386 dot commands registered
;	by the above 16 or 32 bit services.  Care should be used not to
;	de-register dot commands that weren't registered by your code.
;
;	ENTRY:	(AX) = 0072h
;		(BL) = dot command to de-register
;
;	EXIT:	NONE

DS_Printf	equ	73h	; print formatted output

;	This function allows formatted output with the standard "C"
;	printf syntax.
;
;	ENTRY:	(AX) = 0073h
;		(DS:ESI) = address of format string
;		(ES:EDI) = address of the start of the dword arguments
;
;	EXIT:	NONE
;
;	Supported types are:
;
;	%%							%
;	%[l][h]c						character
;	%[-][+][ ][0][width][.precision][l][h][p][n]d		decimal
;	%[-][0][width][.precision][l][h][p][n]u			unsigned decimal
;	%[-][#][0][width][.precision][l][h][p][n]x		hex
;	%[-][#][0][width][.precision][l][h][p][n]X		hex
;	%[-][0][width][.precision][l][h][p][n]o			octal
;	%[-][0][width][.precision][l][h][p][n]b			binary
;	%[-][width][.precision][l][h][a][F]s			string
;	%[-][width][.precision][l][h][a][p][n][F][L][H][N]S	symbol
;	%[-][width][.precision][l][h][a][p][n][F][L][H][N]G	group:symbol
;	%[-][width][.precision][l][h][a][p][n][F][L][H][N]M	map:group:symbol
;	%[-][width][.precision][l][h][a][p][n][F][L][H][N]A	address
;
;	Where "width" or "precision" is a decimal number or the '*' 
;	character; '*' causes the field width or precision to be picked
;	up from the next parameter. []'ed parameters are optional.
;
;	"\r", "\t", "\n", "\a", "\b", are supported directly.
;
;	Prefixes
;	--------
;
;	Used with c,d,u,x,X,o,b:
;
;	Parameter Argument Size
;	-----------------------
;	word					h
;	dword					l
;
;	Used with s,S,G,M,A:
;
;	Address Argument Size
;	---------------------
;	16 bit DS relative			h
;	16:16 segment:offset			hF or Fh
;	32 bit flat relative			l
;	16:32 segment:offset (2 dwords)		lF or Fl
;	pointer to AddrS structure		a
;
;	Used with S,G,M,A:
;
;	Address Display Size or Format
;	------------------------------
;	16 bit offset				H
;	32 bit offset				L
;	offset only				N
;
;	Default display size depends on the "386env" flag setting.
;
;	Used with S,G,M:
;
;	gets the previous symbol		p
;	gets the next symbol			n
;
;	Used with A:
;
;	gets the previous symbol address	p
;	gets the next symbol address		n
;
;	Used with d,u,x,X,o,b:
;
;	gets the previous symbol offset		p
;	gets the next symbol offset		n
;

DS_Printf16	equ	74h	; print formatted 16 bit output

;	This function allows formatted output with the standard "C"
;	printf syntax.
;
;	ENTRY:	(AX) = 0074h
;		(DS:SI) = address of format string
;		(ES:DI) = address of the start of the word or dword arguments
;
;	EXIT:	NONE
;
;	The format options and parameters are the same as DS_Printf except
;	the default parameter size is a word (the h option is implicit).
;

DS_GetRegisterSet equ 75h	; get the debugger's registers

;	This function copies the current register set.
;
;	ENTRY:	(AX) = 0075h
;		(DS:ESI) = address of SaveRegs_Struc structure
;
;	EXIT:	NONE
;

DS_SetAlternateRegisterSet equ 76h	; set the debugger's registers

;	This function temporary sets the debugger's registers to values
;	passed in the structure.  If an "r" command is executed or the
;	debugged code is returned to (via the "g", "t" or "p" commands),
;	the register set reverts to the debugged code's registers.
;
;	ENTRY:	(AX) = 0076h
;		(CX) = thread ID, 0 use current thread ID
;		(DS:ESI) = address of SaveRegs_Struc structure
;
;	EXIT:	NONE
;

DS_GetCommandLineChar equ  77h	; get a character from the command line

;	This services gets the next character off the command line.
;
;	ENTRY:	(AX) = 0077h
;		(BL) == 0 just peek the character, don't increment text pointer
;		          leading white space isn't ignored
;		(BL) != 0 get the character, increment text pointer
;			  leading white space is skipped
;
;	EXIT:	(AL) = command line character
;		(AH) == 0 if no more characters (EOL)
;		(AH) != 0 if more characters
;

DS_EvaluateExpression equ  78h	; evaluate debugger command line expression

;	Expressions can be numbers of various radices, symbols, addresses
;	or an combination of the above hooked together with various
;	operators.  Expressions are separated by blanks or commas.  This
;	function is passed a pointer to the beginning of the text of the
;	expression (i.e. "%80003444+4232").  The expression is either
;	evaluated down into a dword value if there are no addresses or 
;	into a linear address.
;
;	ENTRY:	(AX) = 0078h
;
;	EXIT:	(AX) == 0, returning a data value
;		(AX) != 0, returning a linear address
;		(EBX) = return value
;
;	NOTE:	If the expression is invalid, this service will not
;		return.  A message is printed and control returns to
;		the command loop.
;

DS_VerifyMemory	equ	79h	; verify the memory is valid and present

;	ENTRY:	(AX) = 0079h
;		(ECX) = length of memory region
;		(DS:ESI) = address of memory to verify
;
;	EXIT:	(AX) == 0, no errors
;		(AX) != 0, invalid memory

DS_PrintRegisters equ 7ah	; print the register set (the "r" command)

;	This function prints (just like the "r" command) the either the
;	debugged code's registers or the alternate register set, set with
;	DS_SetAlternateRegisterSet function.
;
;	ENTRY:	(AX) = 007ah
;
;	EXIT:	NONE
;
;	NOTE:	If the CS:EIP is invalid, this service will not return
;		because of an error when the code is disassembled.  A 
;		message is printed and control returns to the command loop.
;

DS_PrintStackDump equ 7bh	; dumps the [E]BP stack chain (the "k" command)

;	This function prints (just like the "k" command) the stack dump
;	based on the current register set that may have been set with 
;	DS_SetAlternateRegisterSet function.
;
;	ENTRY:	(AX) = 007bh
;		(BX) = flags
;			01h - verbose stack dump
;			02h - 16 bit stack dump
;			04h - 32 bit stack dump
;
;	EXIT:	NONE
;
;	NOTE:	If the CS:EIP or SS:EBP are invalid, this service will not
;		return because of an error when accessing the stack.  A 
;		message is printed and control returns to the command loop.
;

DS_SetThreadID	equ  7ch	; sets the debugger's thread ID

;	This function sets what the debugger thinks the thread ID is
;	for memory address in other address contexts.  It stays set
;	until the debugged code is returned to (via "g", "t" or "p")
;	or set back to 0.
;
;	ENTRY:	(AX) = 007ch
;		(CX) = thread ID or 0 for currently executed thread
;
;	EXIT:	NONE

DS_ExecDebugCommand equ  7dh	; execute debugger command script

;	This service allows any debugger command to be executed.  In can
;	be a multi-lined script with the lines separated by CR, LF.  MUST
;	have a "g" command at the end of script so the debugger doesn't
;	stop while in the INT 41.
;
;	ENTRY:	(AX) = 007dh
;		(DS:ESI) = pointer to debugger command script string
;		(CX) = size of script
;
;	EXIT:	NONE

;
;   Interupt and services that Win386 provides to the debugger
;

Win386_Query_Int    equ 22h	; interrupt for Win386 protected mode
				; interface requests

Win386_Alive	    equ 0	; function 0, query Win386 installation
Win386_Q_Ack	    equ 0F386h	;	good response from func 43h, of
				;	INT 68h & func 4fh of INT 41h

Win386_Query	    equ 1	; function 1, query Win386 state
				;	ds:esi points to command string
				;	that Win386 needs to process
				;	ds:edi points to the SaveRegs_Struc
				;	that the debugger has stored all the
				;	client register state into.
				;	(Win386 just writes the query
				;	answers directly to the output
				;	device, so no response is
				;	returned)

Win386_PhysToLinr   equ 2	; function 2, have Win386 convert a
				;	physical address into a valid
				;	linear address that Deb386 can
				;	use.  esi is physicaladdress
				;	cx is # of bytes required
				;	returns esi as linear address
				;	returns ax = 1, if okay, else
				;	0, if request couldn't be
				;	completed

Win386_AddrValid    equ 3	; function 3, have Win386 check the
				;	validity of a linear address
				;	esi is linear address to check
				;	cx is # of bytes required
				;	returns ax = 1, if address okay
				;	else ax = 0

Win386_MapVM	    equ 4	; function 4, make sure that the VM's
				;	low memory is mapped in, in case
				; it is touched (a count is maintained)
Win386_UnmapVM	    equ 5	; function 5, map out the VM's low
				; memory (dec the count)
Win386_GetDLAddr    equ 6	; function 6, return offset of dyna-link
				;	service.  EBX = Device ID << 10h +
				;	Service #.  Returns EAX = Offset.
Max_Win386_Services equ 6


SaveRegs_Struc STRUC
Debug_EAX	dd	?
Debug_EBX	dd	?
Debug_ECX	dd	?
Debug_EDX	dd	?
Debug_ESP	dd	?
Debug_EBP	dd	?
Debug_ESI	dd	?
Debug_EDI	dd	?
Debug_ES	dw	?
Debug_SS	dw	?
Debug_DS	dw	?
Debug_FS	dw	?
Debug_GS	dw	?
Debug_EIP	dd	?
Debug_CS	dw	?
		dd	?
Debug_EFlags	dd	?
Debug_CR0	dd	?
Debug_GDT	dq	?
Debug_IDT	dq	?
Debug_LDT	dw	?
Debug_TR	dw	?
Debug_CR2	dd	?
Debug_CR3	dd	?
Debug_DR0	dd	?
Debug_DR1	dd	?
Debug_DR2	dd	?
Debug_DR3	dd	?
Debug_DR6	dd	?
Debug_DR7	dd	?
Debug_DR7_2	dd	?
Debug_TR6	dd	?
Debug_TR7	dd	?
Debug_TrapNumber dw	-1		; -1 means no trap number
Debug_ErrorCode	dw	0		; 0 means no error code
SaveRegs_Struc ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\ime.h ===
//
//
//  IME.H - East Asia Input Method Editor definitions
//
//

#ifdef DBCS_IME

#ifdef KOREA     // BeomOh - 10/05/92
#define CP_HWND                 0
#define CP_OPEN                 1
#define CP_DIRECT               2
#define CP_LEVEL                3

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)
#endif   // ifdef KOREA

//
//  virtual key
//
#ifdef KOREA    // BeomOh - 9/29/92
#define VK_FINAL        0x18    /* dummy VK to make final on mouse down */
#define VK_CONVERT      0x1C
#define VK_NONCONVERT   0x1D
#define VK_ACCEPT       0x1E
#define VK_MODECHANGE   0x1F
#endif  // ifdef KOREA

#ifdef JAPAN
#define VK_DBE_ALPHANUMERIC	0x0f0
#define VK_DBE_KATAKANA		0x0f1
#define VK_DBE_HIRAGANA		0x0f2
#define VK_DBE_SBCSCHAR		0x0f3
#define VK_DBE_DBCSCHAR		0x0f4
#define VK_DBE_ROMAN		0x0f5
#define VK_DBE_NOROMAN		0x0f6
#define VK_DBE_ENTERWORDREGISTERMODE 0x0f7 /* 3.1 */
#define VK_DBE_IME_WORDREGISTER VK_DBE_ENTERWORDREGISTERMODE /* for 3.0 */
#define VK_DBE_ENTERIMECONFIGMODE       0x0f8 /* 3.1 */
#define VK_DBE_IME_DIALOG       VK_DBE_ENTERIMECONFIGMODE    /* for 3.0 */
#define VK_DBE_FLUSHSTRING      0x0f9   /* 3.1 */
#define VK_DBE_FLUSH            VK_DBE_FLUSHSTRING      /* for 3.0 */
#define VK_DBE_CODEINPUT        0x0fa
#define VK_DBE_NOCODEINPUT      0x0fb
#define VK_DBE_DETERMINESTRING          0x0fc /* 3.1 */
#define VK_DBE_ENTERDLGCONVERSIONMODE 0xfd /* 3.1 */
#endif // JAPAN
#ifdef TAIWAN
#define VK_OEM_SEMICLN		0x0ba	//   ;	** :
#define VK_OEM_EQUAL		0x0bb	//   =	** +
#define VK_OEM_COMMA		0x0bc	//   ,	** <
#define VK_OEM_MINUS		0x0bd	//   -	** _
#define VK_OEM_PERIOD		0x0be	//   .	** >
#define VK_OEM_SLASH		0x0bf	//   /	** ?
#define VK_OEM_3		0x0c0	//   `	** ~
#define VK_OEM_LBRACKET 	0x0db	//   [	** {
#define VK_OEM_BSLASH		0x0dc	//   \  ** |
#define VK_OEM_RBRACKET 	0x0dd	//   ]	** |
#define VK_OEM_QUOTE		0x0de	//   '  ** "
#endif // TAIWAN

#ifdef PRC
#define VK_OEM_SEMICLN		0x0ba	//   ;	** :
#define VK_OEM_EQUAL		0x0bb	//   =	** +
#define VK_OEM_COMMA		0x0bc	//   ,	** <
#define VK_OEM_MINUS		0x0bd	//   -	** _
#define VK_OEM_PERIOD		0x0be	//   .	** >
#define VK_OEM_SLASH		0x0bf	//   /	** ?
#define VK_OEM_3		    0x0c0	//   `	** ~
#define VK_OEM_LBRACKET 	0x0db	//   [	** {
#define VK_OEM_BSLASH		0x0dc	//   \  ** |
#define VK_OEM_RBRACKET 	0x0dd	//   ]	** |
#define VK_OEM_QUOTE		0x0de	//   '  ** "
#endif // PRC


//
//  switch for wParam of IME_MOVECONVERTWINDOW
//
#define MCW_DEFAULT		0x00
#define MCW_RECT		0x01
#define MCW_WINDOW		0x02
#define MCW_SCREEN		0x04
#define MCW_VERTICAL		0x08
#define MCW_HIDDEN      	0x10
#define MCW_CMD 		0x06	// command mask

//
//  switch for wParam of IME_SET_MODE and IME_GET_MODE
//
//
#if defined(JAPAN) || defined(TAIWAN) || defined(PRC)
#define IME_MODE_ALPHANUMERIC	0x0001
#define IME_MODE_KATAKANA	0x0002
#define IME_MODE_HIRAGANA	0x0004
#define IME_MODE_SBCSCHAR	0x0008
#define IME_MODE_DBCSCHAR	0x0010
#define IME_MODE_ROMAN		0x0020
#define IME_MODE_NOROMAN	0x0040
#define IME_MODE_CODEINPUT	0x0080
#define IME_MODE_NOCODEINPUT	0x0100
#endif // JAPAN || TAIWAN || PRC
#ifdef KOREA
#define IME_MODE_ALPHANUMERIC	0x0001
#define IME_MODE_SBCSCHAR       0x0002
#define IME_MODE_HANJACONVERT   0x0004
#endif // KOREA

//
//  IME function code
//
#define IME_GETIMECAPS          0x03    /* 3.1 */
#define IME_QUERY               IME_GETIMECAPS           /* for 3.0 */
#define IME_SETOPEN		0x04
#define	IME_GETOPEN		0x05
#define IME_ENABLE		0x06							/* ;Internal */
#define IME_GETVERSION          0x07    /* 3.1 */
#define IME_SETCONVERSIONWINDOW 0x08    /* 3.1 */
#ifdef  KOREA
#define IME_MOVEIMEWINDOW       IME_SETCONVERSIONWINDOW  /* for 3.0 */
#else
#define IME_MOVECONVERTWINDOW   IME_SETCONVERSIONWINDOW  /* for 3.0 */
#endif
#define IME_SETCONVERSIONMODE   0x10    /* 3.1 */
#ifdef KOREA    // BeomOh - 10/23/92
#define IME_SET_MODE            0x12
#else
#define IME_SET_MODE            IME_SETCONVERSIONMODE    /* for 3.0 */
#endif
#define IME_GETCONVERSIONMODE   0x11    /* 3.1 */
#define IME_GET_MODE            IME_GETCONVERSIONMODE    /* for 3.0 */
#define IME_SETCONVERSIONFONT   0x12    /* 3.1 */
#define IME_SETFONT             IME_SETCONVERSIONFONT    /* for 3.0 */
#define IME_SENDVKEY            0x13    /* 3.1 */
#define IME_SENDKEY             IME_SENDVKEY             /* for 3.0 */
#define IME_DESTROY		0x14							/* ;Internal */
#define IME_PRIVATE		0x15
#define IME_WINDOWUPDATE	0x16
#define	IME_SELECT		0x17							/* ;Internal */
#define IME_ENTERWORDREGISTERMODE       0x18    /* 3.1 */
#define IME_WORDREGISTER        IME_ENTERWORDREGISTERMODE /* for 3.0 */
#define IME_SETCONVERSIONFONTEX 0x19            /* New for 3.1 */
#ifdef KOREA
#define IME_CODECONVERT         0x20
#define IME_CONVERTLIST         0x21
#define IME_AUTOMATA            0x30
#define IME_HANJAMODE           0x31
#define IME_GETLEVEL            0x40
#define IME_SETLEVEL            0x41
#endif // KOREA
#ifdef TAIWAN
#define IME_SETUSRFONT		0x20
#define IME_QUERYUSRFONT	0x21
#define IME_INPUTKEYTOSEQUENCE	0x22
#define IME_SEQUENCETOINTERNAL	0x23
#define IME_QUERYIMEINFO	0x24
#define IME_DIALOG		0x25
#endif // TAIWAN

#ifdef PRC
#define IME_SETUSRFONT			0x20
#define IME_QUERYUSRFONT		0x21
#define IME_INPUTKEYTOSEQUENCE	0x22
#define IME_SEQUENCETOINTERNAL	0x23
#define IME_QUERYIMEINFO		0x24
#define IME_DIALOG				0x25
#endif // PRC

#define IME_SETUNDETERMINESTRING        0x50    /* New for 3.1 (PENWIN) */
#define IME_SETCAPTURE                  0x51    /* New for 3.1 (PENWIN) */

#define IME_PRIVATEFIRST        0x0100   /* New for 3.1 */
#define IME_PRIVATELAST         0x04FF   /* New for 3.1 */

//
//  error code
//
#define IME_RS_ERROR		0x01	// genetal error
#define IME_RS_NOIME		0x02	// IME is not installed
#define IME_RS_TOOLONG		0x05	// given string is too long
#define IME_RS_ILLEGAL		0x06	// illegal charactor(s) is string
#define IME_RS_NOTFOUND 	0x07	// no (more) candidate
#define IME_RS_NOROOM		0x0a	// no disk/memory space
#define IME_RS_DISKERROR	0x0e	// disk I/O error
#define IME_RS_CAPTURED         0x10    // IME is captured (PENWIN)
#define IME_RS_INVALID          0x11    // invalid sub-function was specified
#define IME_RS_NEST             0x12    // called nested
#define IME_RS_SYSTEMMODAL      0x13    // called when system mode

//
//  messge id
//
#define WM_IME_REPORT		0x0280	// WM_KANJIFIRST
#define IR_STRINGSTART		0x100
#define IR_STRINGEND		0x101
#define IR_MOREROOM		0x110
#define IR_OPENCONVERT		0x120
#define IR_CHANGECONVERT	0x121
#define IR_CLOSECONVERT		0x122
#define IR_FULLCONVERT		0x123
#define IR_IMESELECT		0x130
#define IR_STRING		0x140
#define IR_DBCSCHAR             0x160   /* New for 3.1 */
#define IR_UNDETERMINE          0x170   /* New for 3.1 */
#define IR_STRINGEX             0x180   /* New for 3.1 */

#define WM_IMEKEYDOWN           0x290
#define WM_IMEKEYUP             0x291

//
//  IMM functions
//
typedef struct tagIMESTRUCT {
    WORD	fnc;		// function code
    WORD	wParam; 	// word parameter
    WORD	wCount; 	// word counter
    WORD	dchSource;	// offset to src from top of memory object
    WORD	dchDest;	// offset to dst from top of memory object
    LONG	lParam1;
    LONG	lParam2;
    LONG	lParam3;
} IMESTRUCT;
typedef IMESTRUCT      *PIMESTRUCT;
typedef IMESTRUCT NEAR *NPIMESTRUCT;
typedef IMESTRUCT FAR  *LPIMESTRUCT;

short FAR PASCAL SendIMEMessage( HWND, DWORD );
LONG WINAPI SendIMEMessageEx( HWND, LPARAM ); /* New for 3.1 */
#if defined(TAIWAN) || defined(PRC)
LONG FAR PASCAL WINNLSIMEControl(HWND,HWND,LPIMESTRUCT);
#endif

typedef struct tagOLDUNDETERMINESTRUCT {
    UINT        uSize;
    UINT        uDefIMESize;
    UINT        uLength;
    UINT        uDeltaStart;
    UINT        uCursorPos;
    BYTE        cbColor[16];
/*  -- These members will have variable length. --
    BYTE        cbAttrib[];
    BYTE        cbText[];
    BYTE        cbIMEDef[];
*/
} OLDUNDETERMINESTRUCT,
  NEAR *NPOLDUNDETERMINESTRUCT,
  FAR *LPOLDUNDETERMINESTRUCT;

typedef struct tagUNDETERMINESTRUCT {
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT,
  NEAR *NPUNDETERMINESTRUCT,
  FAR *LPUNDETERMINESTRUCT;

typedef struct tagSTRINGEXSTRUCT {
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT,
  NEAR *NPSTRINGEXSTRUCT,
  FAR *LPSTRINGEXSTRUCT;

//
//  miscellaneous
//
#if defined(TAIWAN) || defined(PRC)
#define STATUSWINEXTRA		10
#endif


#ifdef KOREA
//
//  ----- definitions for level2 apps -----
//

typedef unsigned char far *LPKSTR ;

/* VK from the keyboard driver */
#define VK_FINAL		0x18	// dummy VK to make final on mouse down
#define VK_IME_DIALOG		0xf1

#define CP_HWND			0
#define CP_OPEN			1
//#define CP_DIRECT		2
#define CP_LEVEL                3

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)

//
//  ----- definitions for level3 apps -----
//

/* VK to send to Applications */
#define VK_CONVERT		0x1C
#define VK_NONCONVERT		0x1D
#define VK_ACCEPT		0x1E
#define VK_MODECHANGE		0x1F

/* IME_CODECONVERT subfunctions */
#define IME_BANJAtoJUNJA        0x13
#define IME_JUNJAtoBANJA        0x14
#define IME_JOHABtoKS           0x15
#define IME_KStoJOHAB           0x16

/* IME_AUTOMATA subfunctions */
#define IMEA_INIT               0x01
#define IMEA_NEXT               0x02
#define IMEA_PREV               0x03

/* IME_HANJAMODE subfunctions */
#define IME_REQUEST_CONVERT     0x01
#define IME_ENABLE_CONVERT      0x02

/* IME_MOVEIMEWINDOW subfunctions */
#define INTERIM_WINDOW          0x00
#define MODE_WINDOW             0x01
#define HANJA_WINDOW            0x02

#endif // KOREA

#endif // DBCS_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\int31.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT31.INC - Equates and Structures for Int 31h Interface
;
;   Version:	3.00
;
;   Date:	22-May-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   22-May-1989 RAL Original
;
;==============================================================================



Int31_Sel_Mgt		EQU	00h
    SelMgt_Alloc_Sel	EQU	00h
    SelMgt_Free_Sel	EQU	01h
    SelMgt_Seg_To_Sel	EQU	02h
    SelMgt_Get_LDT_Base EQU	03h
    SelMgt_Lock_Sel	EQU	04h
    SelMgt_Unlock_Sel	EQU	05h
    SelMgt_Get_Base	EQU	06h
    SelMgt_Set_Base	EQU	07h
    SelMgt_Set_Limit	EQU	08h
    SelMgt_Set_Acc_Bits EQU	09h
    SelMgt_Alias_Sel	EQU	0Ah
    SelMgt_Get_Desc	EQU	0Bh
    SelMgt_Set_Desc	EQU	0Ch

Int31_DOS_Mem_Mgt	EQU	01h
    DOSMem_Allocate	EQU	00h
    DOSMem_Free 	EQU	01h
    DOSMem_Resize	EQU	02h

Int31_Int_Serv		EQU	02h
    Int_Get_Real_Vec	EQU	00h
    Int_Set_Real_Vec	EQU	01h
    Int_Get_Excep_Vec	EQU	02h
    Int_Set_Excep_Vec	EQU	03h

Int31_Trans_Serv	EQU	03h
    Trans_Sim_Int	EQU	00h
    Trans_Far_Call	EQU	01h
    Trans_Call_Int_Proc EQU	02h
    Trans_Call_Back	EQU	03h
    Trans_Free_CB	EQU	04h

Int31_Get_Version	EQU	04h

Int31_Mem_Mgt		EQU	05h
    MemMgt_Get_Info	EQU	00h
    MemMgt_Allocate	EQU	01h
    MemMgt_Free 	EQU	02h
    MemMgt_Resize	EQU	03h

Int31_Page_Lock 	EQU	06h
    Lock_Region 	EQU	00h
    Unlock_Region	EQU	01h
    Mark_Pageable	EQU	02h
    Mark_Not_Pageable	EQU	03h

Int31_Demand_Page_Tune	EQU	07h
    Page_Candidate	EQU	00h
    Page_Discard	EQU	01h

Int31_Map_Phys_Addr	EQU	08h

Int31_Virt_Int_State	EQU	09h
    Get_Clear_Int_State EQU	00h
    Get_Set_Int_State	EQU	01h
    Get_Int_State	EQU	02h


Real_Mode_Call_Struc	STRUC
RealMode_EDI	dd	?
RealMode_ESI	dd	?
RealMode_EBP	dd	?
		dd	?
RealMode_EBX	dd	?
RealMode_EDX	dd	?
RealMode_ECX	dd	?
RealMode_EAX	dd	?
RealMode_Flags	dw	?
RealMode_ES	dw	?
RealMode_DS	dw	?
RealMode_FS	dw	?
RealMode_GS	dw	?
RealMode_IP	dw	?
RealMode_CS	dw	?
RealMode_SP	dw	?
RealMode_SS	dw	?
Real_Mode_Call_Struc	ENDS


Real_Mode_Word_Regs	STRUC
RealMode_DI	dw	?
		dw	?
RealMode_SI	dw	?
		dw	?
RealMode_BP	dw	?
		dw	?
		dd	?
RealMode_BX	dw	?
		dw	?
RealMode_DX	dw	?
		dw	?
RealMode_CX	dw	?
		dw	?
RealMode_AX	dw	?
Real_Mode_Word_Regs	ENDS


Real_Mode_Byte_Regs	STRUC
		dd	4 dup (?)
RealMode_BL	db	?
RealMode_BH	db	?
		dw	?
RealMode_DL	db	?
RealMode_DH	db	?
		dw	?
RealMode_CL	db	?
RealMode_CH	db	?
		dw	?
RealMode_AL	db	?
RealMode_AH	db	?
Real_Mode_Byte_Regs	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\layer.inc ===
;=======================================================
;
; Macros stolen from cmacros.inc (so we don't have to include it all)
;
    .286p

externNP    macro   n
    irp x,<n>
	extrn x:near
    endm
endm

externFP    macro   n
    irp x,<n>
	extrn x:far
    endm
endm

externW     macro   w
    irp x,<w>
        extrn x:word
    endm
endm

assumes     macro s,ln
    assume  s:_&ln
endm

createSeg   macro n,ln,a,co,cl,grp
    n segment a co '&cl'
    n ends
endm

sBegin	    macro   seg
    assume  cs:_&seg
    _&seg   segment
endm

sEnd	    macro   seg
    _&seg ends
    assume  cs:nothing
endm

errnz macro x				;;display error if expression is <>0
  if2
    if x				;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm

errn$ macro l,x 			;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm

createSeg _DATA,DATA,WORD,PUBLIC,DATA

;=======================================================
;
; Error API definitions
;
ExternFP    <HandleParamError>

; error codes
include logerror.inc

;================================================================
;   Variable and temporary initialization

VLseg  equ <>	   ; Holds current segment name

VLopen = 0
VLerrnotinvoked  = 0
ifndef VLnogenpall
VLnogenpall = 0
endif

VLnogen        = 0
VLnogenparm    = 0

VLsavees       = 0
VLsavebx       = 0

;if1
if 1

;================================================================
;   Utility macros

;---------------------------------------------------------------------------
;
; lodsw cs:[si]
;
cslodsw macro
	db  2eh     ;; CS override
	lodsw
endm

;---------------------------------------------------------------------------
;
; lodsb cs:[si]
;
cslodsb macro
	db  2eh     ;; CS override
	lodsb
endm

SkipTwoBytes macro
	db	0A9h	;; Opcode for CMP AX,(immediate word)
endm

;---------------------------------------------------------------------------
;
; Define a as the concatenation of b & c
;
concat	macro	a,b,c,d,e,f
a	equ	<b&c&d&e&f>
endm

;---------------------------------------------------------------------------
;
; Assign a to b.
;
equate	macro	a,b
	a   = b
endm

;
; Print a message
;
_print	macro a,b,c
if2
	%out   a&b&c
endif
endm


;===============================================================

;---------------------------------------------------------------------------
;
; _gensub   LABEL
;
; Causes per-segment subroutine code associated with type LABEL
; to be generated, by setting the genLABEL&lseg flag.
;
_gensub2    macro   l,s
    gen&l&s = 1
endm

_gensub macro   l
        _gensub2    <l>,%VLseg
endm

;---------------------------------------------------------------------------
; _SwitchSeg
;
; Switches current segment to seg, creating the segment if needed.
;
_SwitchSeg   macro   seg,oldseg
    ifdifi  <&seg>,<oldseg>

      ifnb  <oldseg>
sEnd oldseg
      endif

    concat  <VLseg>,seg,

;createSeg _&seg,seg,BYTE,PUBLIC,CODE
createSeg _&seg,seg,WORD,PUBLIC,CODE

sBegin seg
assumes CS,seg

    endif
endm


;---------------------------------------------------------------------------
; API
;
API	macro	rettype,name,seg,optlist

    if	VLopen
	APIEND
    endif

VLname equ <name>
VLcbparms      = 0
VLcbskip       = 0
VLerrnotinvoked= 1
VLopen	       = 1
VLnogen        = 0
VLnogenparm    = 0
VLasm	       = 0
VLfunnyframe   = 0
VLnodata       = 0
VLcargs        = 0
VLplist        equ <>
VLATMframe     = 0	    ; special entry/exit code sequence for ATM's patching
VLATMfrmds     = 0	    ; ATM entry/exit code: mov ax,_DATA at beginning.

VLsavees	= 0
VLsavebx        = 0
	_SwitchSeg seg,%VLseg

    irp opt,<optlist>

      ifidni  <opt>,<NOGEN>
      VLnogen = 1
      endif

      ifidni  <opt>,<VOID>
      VLnogen = 1
      endif

      ifidni  <opt>,<ASM>
      VLasm = 1
      endif

ifndef WOW
      ; don't need that bp and ds stuff

      ifidni  <opt>,<ATMFRAME>
      VLATMframe = 1
      endif

      ifidni  <opt>,<ATMFRAMEDS>
      VLATMfrmds = 1
      VLATMframe = 1
      endif
endif

      ifidni  <opt>,<FUNNYFRAME>
      VLfunnyframe = 1
      endif

      ifidni  <opt>,<NODATA>
      VLnodata = 1
      endif

      ifidni  <opt>,<DEBUGONLY>
        ifndef DEBUG
        VLnogen = 1
        endif
      endif

      ifidni  <opt>,<C>
      VLcargs  = 1
      endif

      ifidni  <opt>,<SAVEES>
      VLsavees  = 2     ; sizeof(ES)
      endif

      ifidni  <opt>,<SAVEBX>
      VLsavebx  = 2     ; sizeof(BX)
      endif

    endm

concat	<VLsegoffset>,<seg>,<offset>
concat	<VLnameerror>,<name>,<_error>
concat	<VLnamecbparms>,<name>,<cbparms>

    if1
equate %VLnamecbparms, %VLcbparms
    else
equate %VLnamecbparms, %VLnamecbparms
    endif

    ife VLnogen

    ife VLcargs
concat	<VLiname>,<I>,<name>
ExternNP I&name

public	name
name:

    else
concat	<VLiname>,<_I>,<name>
ExternNP _I&name

public	_&name
_&name:

    endif

VLframe =   0			; no frame set up yet.

    endif  ; VLnogen

endm	;; VL

;---------------------------------------------------------------------------
; APIERR
;
; Optionally used after parameter decls to begin error handling code
;
APIERR	macro	opts

    ife VLnogen
      ife VLframe
	_print	<Nothing to validate for >,%VLiname
      else
	pop	dx		; pop off error handler address
	pop	bp		; restore BP
       if VLATMframe
	dec	bp		; fix BP back up
       endif
       if VLsavees
	pop	es
       endif
       if VLsavebx
        pop     bx
       endif
      endif
	jmp	VLiname 	; jmp to internal routine.

equate %VLnamecbparms, %VLcbparms

VLnameerror:
	VLerrnotinvoked  = 0

    endif ; VLnogen

endm	;; APIERR

;---------------------------------------------------------------------------
; APIEND
;
; Used after APIERR to terminate error handling code.
;
APIEND	macro

_PurgeParms %VLplist

    ife VLnogen

    if	VLerrnotinvoked
	APIERR
    endif
    if VLsavees
	pop	es
    endif
    if VLsavebx
        pop     bx
    endif
    ife VLcargs
	retf	VLcbparms
    else
	retf
    endif

VLopen = 0

    endif   ; VLnogen

endm	;; APIEND

;---------------------------------------------------------------------------
;
; _FlsFrame - Generate frame code
;
_FlsFrame   macro
    ife VLframe
     if VLATMfrmds
	mov	ax,_DATA
     endif
     if VLsavebx
        push    bx
     endif
     if VLsavees
	push	es
     endif
     if VLATMframe
	inc	bp
	push	bp
	mov	bp,sp
	push	ds		    ; push ds and pop it off.
	pop	ds		    ; (we need to pop DS rather than
				    ;  something fast like pop AX because
				    ; ATM doesn't preserve DS itself)
     else
	push	bp
	mov	bp,sp
     endif
	push	offset VLnameerror  ; push address of error handler
    VLframe = 1
    endif
endm

;---------------------------------------------------------------------------
; _ChkName
;
; Ensure name was specified

_ChkName    macro name
    ifb <name>
	_print <Missing parameter name in >,%VLiname
    endif
endm

;---------------------------------------------------------------------------
; _ParmOpts
;
; Parse parameter option flags
;
_ParmOpts  macro opts

    VLnogenparm = VLnogenpall

    irp opt,<opts>
	ifidni	<opt>,<DEBUGONLY>
	ifndef DEBUG
	    VLnogenparm = 1
	endif
	ifidni	<opt>,<NOGEN>
	    VLnogenparm = 1
	endif
	endif
    endm
endm

;---------------------------------------------------------------------------
; _DefParm name,cb,opts
;
; Take care of default parameter stuff, such as defining argument.
;
_DP_Add     macro   old,new
    ifb     <old>
VLplist equ <new>
    else
VLplist equ <old,new>
    endif
endm

_DefParm   macro   name,cb,opts
	_ChkName    <name>
	_ParmOpts   <opts>

  if VLcargs
concat  _P_&name,<[bp]+6+>,%(VLcbparms+VLsavees+VLsavebx)
	VLcbparms=VLcbparms+(cb)
  else
	VLcbparms=VLcbparms+(cb)
concat  _P_&name,<[bp]+6->,%VLcbparms,<+>,%(VLnamecbparms+VLsavees+VLsavebx)
  endif

_DP_Add     %VLplist,<_P_&name>

    VLgen = 1
    if VLnogenparm or VLnogen
        VLgen = 0
    endif
endm

;----------------------------------------------------------------------------
;
; _GenParm  name, cb, opts
;
_GenParm    macro   name,cb,opts
    _DefParm	<name>,<cb>,<opts>
    if VLgen
	_FlsFrame
    endif
endm

lcall2	macro	op,label,seg
	op	label&seg
endm

lcall	macro	label
	lcall2	<call>,<label>,%VLseg
endm

ljmp	macro	label
	lcall2	<jmp>,<label>,%VLseg
endm

;
; _PurgeParms - purge list of parameters we've defined
;
_PurgeParms   macro   list
    irp sym,<list>
sym equ <>
    endm
endm

;---------------------------------------------------------------------------
; LAYER_START
;
; Used before any VL invocations
;
LAYER_START macro
assumes ds,DATA

endm

;---------------------------------------------------------------------------
; LAYER_END
;
; Ends all VL definitions
;
LAYER_END   macro
    if VLsopen
	ENDSTRUCT
    endif
    if VLopen
	APIEND
    endif
    if VLerrnotinvoked
	APIERR
    endif
endm

;=========================================================================
;
; Structure related macros
;
; Structure globals

VLsopen =0

;
; STRUCT - begins a structure declaration
;
STRUCT	macro	name,opts
  if VLsopen
	ENDSTRUCT
  endif
  VLsopen=1

concat	VLcbs,<VLcbs>,name
VLcbstruct  =	0
endm

;
; ENDSTRUCT macro - terminates a STRUCT declaration
;
ENDSTRUCT   macro
equate	%VLcbs,%VLcbstruct

VLsopen =0
endm

;
; Define simple field macro, given:
;   f = macro name
;   cb = size of field
;
_SSize	macro	cb,opts
VLcbstruct  =	VLcbstruct + (cb)
endm

_DefSimpleF macro   f,cb
    f	&macro	name,opts
	equate	_F_&&name,%VLcbstruct
	_SSize	cb
    &endm
endm

_DefSimpleF F_char,1
_DefSimpleF F_BYTE,1

_DefSimpleF F_int,2
_DefSimpleF F_WORD,2
_DefSimpleF F_BOOL,2
_DefSimpleF F_FLAGS,2

_DefSimpleF F_LONG,4
_DefSimpleF F_DWORD,4

_DefSimpleF F_intMBZ,2
_DefSimpleF F_DWORDMBZ,4

_DefSimpleF F_LPVOID,4
_DefSimpleF F_CLPSTR,4
_DefSimpleF F_CLPSTR0,4
_DefSimpleF F_LPSTR,4

_DefSimpleF F_POINT,4
_DefSimpleF F_RECT,8

ifdef WOW
_DefSimpleF F_LARGEPOINT,8
endif

F_RGB	macro	name,cb,opts
    equate  _F_&name,%VLcbstruct
    _SSize  cb
endm

F_RGCH	equ	<F_RGB>

F_RGW	macro	name,cw,opts
    equate  _F_&name,%VLcbstruct
    _SSize  (cw*2)
endm

;
; Generate a P_?LP???? macro, given:
;
; n = parameter macro name (e.g., P_LPRECT)
; r = handler routine name (e.g., LP)
; cb = size of buffer
;
; The generated macro checks only whether the
; buffer is big enough.
;
_GenLP	macro	n,r,cb
    &n	    &macro   name,opts
        _GenParm    <name>,4,<opts>
        if VLgen
	    mov     ax,_P_&&name
	    mov     cx,_P_&&name+2
	    mov     bx,cb
	    lcall   &r
            _gensub <LP>
	endif
    &endm
endm

;=========================================================================
;
; Generic parameter macros
;
P_2	macro	name, opts
	_DefParm      <name>,2,<opts>
endm

P_4	macro	name, opts
	_DefParm      <name>,4,<opts>
endm

P_8     macro   name, opts
        _DefParm      <name>,8,<opts>
endm

P_char	    equ <P_2>
P_int	    equ <P_2>
P_BYTE	    equ <P_2>
P_BOOL	    equ <P_2>
P_WORD	    equ <P_2>

P_WORDMBZ   equ <P_2>
P_WORDMBNZ  equ <P_2>

P_LONG	    equ <P_4>
P_DWORD     equ <P_4>

;
; Generic handle
;
P_H	macro	name, opts
    _GenParm    <name>,2,<opts>
    if VLgen
;	mov	ax,_P_&name
;	lcall	H
;	 _gensub H
    endif
endm

;
; Generic handle or NULL
;
P_H0	equ	<P_2>

;
; Ensure signed value is min <= value <= max
;
P_RVALUE    macro   name, min, max, opts
        local   valok
    _GenParm    <name>,2,<opts>
    if VLgen
	mov	ax,_P_&name
	cmp	ax,min
	jl	@F
	cmp	ax,max
        jle     valok
@@:
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
valok:
    endif
endm

;
; Ensure signed value is 0 <= value <= max
;
P_VALUE     macro   name, max, opts
    _GenParm    <name>,2,<opts>
    if VLgen
	mov	ax,_P_&name
	cmp	ax,max
	jbe	@F		    ;; unsigned comparison to catch < 0.
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
endm

;
; Ensure unsigned value is value <= max
;
P_UVALUE    equ <P_VALUE>

;
; Ensure signed value is 0 <= value <= max
;
P_VALUEW     macro   name, max, opts
    _GenParm    <name>,2,<opts>
    if VLgen
	mov	ax,_P_&name
	cmp	ax,max
	jbe	@F		    ;; unsigned comparison to catch < 0.
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
endm

;
; Ensure unsigned value is value <= max
;
P_UVALUEW    equ <P_VALUEW>

;
; Ensure signed byte value is min <= value <= max
;
if 0
P_BVALUE	macro	name,max,opts
    _GenParm    <name>,2,<opts>
    if VLGen
	mov	al,_P_&name
	cmp	al,max
	jle	@F
	lcall	ErrorBValue
@@:
    endif
endm
else
P_BVALUE    equ <P_2>
endif

;
; Ensure that no incorrect bits are set in a flags word
; (i.e., (name & ~valid) == 0)
;
P_FLAGS     macro   name, valid, opts
  _DefParm  <name>,2,<opts>
  if not(valid)
    if VLgen
	_FlsFrame
	mov	ax,_P_&name
      ife (low(not(valid)))
	test	ah,high(not(valid))
      else
       ife (high(not(valid)))
	test	al,low(not(valid))
       else
	test	ax,not(valid)
       endif
      endif
	jz	@F
        mov     bx,ERR_BAD_FLAGS or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
  endif
endm

;
; Ensure that no incorrect bits are set in a flags dword
; (i.e., (name & ~valid) == 0)
;
P_DFLAGS    macro   name, valid_l, valid_h, opts
        local   flagok
  _DefParm   <name>,4,<opts>
  if not(valid_l) or not(valid_h)
    if VLgen
	_FlsFrame
	mov	ax,_P_&name
	mov	cx,_P_&name+2
      if not(valid_l)
	test	ax,not(valid_l)
       if not(valid_h)
	jnz	@F
       else
        jz      flagok
       endif
      endif
      if not(valid_h)
	test	cx,not(valid_h)
        jz      flagok
@@:
      endif
        mov     bx,ERR_BAD_DFLAGS or ERR_WARNING
        lcall   Inval_Param_
flagok:
    endif
  endif
endm

;
; P_LPFN   - function pointer
; P_LPFN0  - function pointer or NULL
;
P_LPFN	macro	name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
	lcall	LPFN
        _gensub LPFN
    endif
endm

P_LPFN0 macro	name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
	lcall	LPFN0
        _gensub LPFN
    endif
endm

_GenBuf macro p,r
    P_&p  &macro   lpch, cch, opts
	_DefParm    <lpch>,4,<opts>
	_DefParm    <cch>,2,<opts>
        if VLgen
	    _FlsFrame
	    mov     ax,_P_&&lpch
	    mov     cx,_P_&&lpch+2
	    mov     bx,_P_&&cch
	    lcall   &r
            _gensub LP
	endif
    &endm
endm

_GenBufspl macro p,r
    P_&p  &macro   lpch, cch, opts
	_DefParm    <lpch>,4,<opts>
	_DefParm    <cch>,2,<opts>
        if VLgen
	    _FlsFrame
	    mov     ax,_P_&&lpch
	    mov     cx,_P_&&lpch+2
	    lea	    bx,_P_&&cch
	    lcall   &r
            _gensub LPBUF
	endif
    &endm
endm

_GenBufspl <LPBUFFER>,<LPBUF>
_GenBuf <CLPBUFFER>,<CLP>
_GenBufspl <LPBUFFER0>,<LPBUF0>
_GenBuf <CLPBUFFER0>,<CLP0>

;
; If pszBuf is valid, set its first byte to 0
;
E_SETEMPTY  macro   pszBuf,cchBuf,opts
        push    bp
	mov	bp,sp
	mov	cx,_P_&cchBuf
        mov     bx,_P_&pszBuf
        mov     dx,_P_&pszBuf+2
	pop	bp
        lcall   SETEMPTY
        _gensub SETEMPTY
endm

; Same as above, but with no supplied count
;
E_SETEMPTYNC  macro   pszBuf,opts
        push    bp
        mov     bp,sp
        mov     cx,1
        mov     bx,_P_&pszBuf
        mov     dx,_P_&pszBuf+2
        pop     bp
        lcall   SETEMPTY
        _gensub SETEMPTY
endm

_GenLP	<P_LPSTR>,<LP>,1
_GenLP	<P_LPSTR0>,<LP0>,1

P_CLPSTR macro   name,cch,opts
    _GenParm    <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
    ifb <cch>
        mov     bx,-1
    else
        mov     bx,cch
    endif
	lcall	CLPSZ
        _gensub LPSZ
    endif
endm

P_CLPSTR0 macro   name,cch,opts
    _GenParm    <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
    ifb <cch>
        mov     bx,-1
    else
        mov     bx,cch
    endif
	lcall	CLPSZ0
        _gensub LPSZ
    endif
endm

_GenLP	<P_LPVOID>,<LP>,1
_GenLP	<P_LPVOID0>,<LP0>,1
_GenLP	<P_CLPVOID>,<CLP>,1
_GenLP	<P_CLPVOID0>,<CLP0>,1

_GenLP	<P_LPBYTE>,<LP>,1
_GenLP	<P_LPBYTE0>,<LP0>,1
_GenLP	<P_CLPBYTE>,<CLP>,1
_GenLP	<P_CLPBYTE0>,<CLP0>,1

_GenLP	<P_LPINT>,<LP>,2
_GenLP	<P_LPINT0>,<LP0>,2
_GenLP	<P_CLPINT>,<CLP>,2
_GenLP	<P_CLPINT0>,<CLP0>,2

_GenLP	<P_LPWORD>,<LP>,2
_GenLP	<P_LPWORD0>,<LP0>,2
_GenLP	<P_CLPWORD>,<CLP>,2
_GenLP	<P_CLPWORD0>,<CLP0>,2

_GenLP	<P_LPBOOL>,<LP>,2
_GenLP	<P_LPBOOL0>,<LP0>,2
_GenLP	<P_CLPBOOL>,<CLP>,2
_GenLP	<P_CLPBOOL0>,<CLP0>,2

_GenLP	<P_LPLONG>,<LP>,4
_GenLP	<P_LPLONG0>,<LP0>,4
_GenLP	<P_CLPLONG>,<CLP>,4
_GenLP	<P_CLPLONG0>,<CLP0>,4

_GenLP	<P_LPDWORD>,<LP>,4
_GenLP	<P_LPDWORD0>,<LP0>,4
_GenLP	<P_CLPDWORD>,<CLP>,4
_GenLP	<P_CLPDWORD0>,<CLP0>,4

;=======================================================================
;
; Common USER types
;
STRUCT	<POINT>
F_int	     x
F_int	     y
ENDSTRUCT

STRUCT <LARGEPOINT>
F_LONG      x
F_LONG      y
ENDSTRUCT


_GenLP	<P_LPPOINT>,<LP>,%VLcbsPOINT
_GenLP	<P_LPPOINT0>,<LP0>,%VLcbsPOINT
_GenLP	<P_CLPPOINT>,<CLP>,%VLcbsPOINT
_GenLP	<P_CLPPOINT0>,<CLP0>,%VLcbsPOINT
P_POINT     equ <P_4>

_GenLP  <P_LPLARGEPOINT>,<LP>,%VLcbsLARGEPOINT
P_LARGEPOINT equ <P_8>

STRUCT	<RECT>
F_int	     left
F_int	     top
F_int	     right
F_int	     bottom
ENDSTRUCT

_GenLP	<P_LPRECT>,<LP>,%VLcbsRECT
_GenLP	<P_LPRECT0>,<LP0>,%VLcbsRECT
_GenLP	<P_CLPRECT>,<CLP>,%VLcbsRECT
_GenLP	<P_CLPRECT0>,<CLP0>,%VLcbsRECT

;=======================================================================
;
; Common KERNEL types
;
P_GHANDLE   macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
       mov     ax,_P_&h
       lcall   GHANDLE
        _gensub GHANDLE
    endif

endm

P_GHANDLE0  macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
       mov     ax,_P_&h
       lcall   GHANDLE0
        _gensub GHANDLE
    endif
endm

P_GHANDLE32  macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
       mov ax,_P_&h
       test al, 0100b    ;let zero & BOGUSGDT hInst's through
       jz   @F
       lcall   GHANDLE
        _gensub GHANDLE
       @@:
    endif
endm

P_HANDLE    equ <P_H>
P_HANDLE0   equ <P_H0>

P_ATOM	    equ <P_H>

P_HINSTANCE equ <P_GHANDLE>
P_HINSTANCE0 equ <P_GHANDLE0>
P_HINSTANCE32 equ <P_GHANDLE32>

P_HMODULE   equ <P_GHANDLE>
P_HMODULE0  equ <P_GHANDLE0>

P_HTASK     equ <P_GHANDLE>
P_HTASK0    equ <P_GHANDLE0>

P_CLPSTRATOM macro   name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
	lcall	CLPSTRATOM
        _gensub LPSZ
    endif
endm

P_CLPSTRATOM0 macro name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
	lcall	CLPSTRATOM0
        _gensub LPSZ
    endif
endm

P_CLPSTRRSRC  equ <P_CLPSTRATOM>
P_CLPSTRRSRC0 equ <P_CLPSTRATOM0>

;---------------------------------------------------------------------------
; LAYER_EXPAND	lseg
;
; Expands per-segment validation boilerplate code into segment lseg
;
LAYER_EXPAND	macro	lseg
.list
.lall
    _SwitchSeg	&lseg,%VLseg

public	VStart&lseg
VStart&lseg:

EXTRA_EXPAND    lseg

;
; Handle validation
;
ifdef genH&lseg

public H&lseg
H&lseg:
	or	ax,ax
        jz      @F
	ret
@@:
        mov     bx,ERR_BAD_HANDLE
        jmp     short Inval_Param_&lseg

endif   ; genH&lseg

ifdef genGHANDLE&lseg

public GHANDLE0&lseg
GHANDLE0&lseg:
	or	ax,ax		; accept NULL
	jz	GHexit&lseg

public GHANDLE&lseg
GHANDLE&lseg:
	test	al,0100b	; Reject GDT selectors
        jz      GHerr&lseg
	cmp	ax,0ffffh	; special case: -1 -> DS
	jz	GHexit&lseg
	lar	dx,ax		; is it a valid selector?
        jnz     GHerr&lseg
GHexit&lseg:
	ret

GHerr&lseg:
        mov     bx,ERR_BAD_GLOBAL_HANDLE
        jmp     short Inval_Param_&lseg

endif   ; genGHANDLE&lseg

ifdef genLPFN&lseg

;
; Function pointer validation
;
public LPFN0&lseg
LPFN0&lseg:
	mov	bx,ax	    ; Allow NULL
	or	bx,cx
	jz	LPFN_exit&lseg

public LPFN&lseg
LPFN&lseg:
beg_fault_trap  LPFNbad&lseg
        lar     bx,cx
        jnz     LPFNerr&lseg
        test    bh,8
        jz      LPFNerr&lseg
        mov     es,cx       ; validate pointer & offset
        mov     bx,ax
        mov     al,es:[bx]
end_fault_trap

ifdef DEBUG
;
; Make sure the function is exported by
; ensuring that the first instructions are NOT
; push ds, pop ax or mov ax,ds.
;
	mov	bx,es:[bx]+2

        cmp     bx,0581eh                   ; Push ds, pop ax instructions?
        jz      LPFNerr&lseg                ; Yes, must be an error.
        cmp     bx,0d88ch                   ; Mov ax,ds instruction?
        jz      LPFNerr&lseg                ; No, we're ok, so jump ahead
endif	; DEBUG

LPFN_exit&lseg:
	ret

LPFNbad&lseg:
	fault_fix_stack
LPFNerr&lseg:
        mov     bx,ERR_BAD_FUNC_PTR
        jmp     short Inval_Param_&lseg

endif   ; genLPFN&lseg

public Inval_Param_&lseg
Inval_Param_&lseg:
        pop     dx          ; convert near return addr to far
        push    cs
	push	dx
	jmp	HandleParamError

ifdef genLP&lseg

public LP0&lseg
LP0&lseg:
	or	ax,ax	    ; if cx:ax == NULL, exit
	jnz	@F
	jcxz	CLPexit&lseg
@@:
public LP&lseg
LP&lseg:
beg_fault_trap  CLPbad&lseg
        mov     es,cx
        or      bx,bx           ; cb == 0?
        jz      CLPexit&lseg    ; yes: just check selector
        dec     bx
        add     bx,ax
        jc      CLPbad1&lseg    ; check 16 bit overflow
        or      byte ptr es:[bx],0  ; check write permission, limit
end_fault_trap
        ret

public CLP0&lseg
CLP0&lseg:
        or      ax,ax           ; Accept ax:cx == 0
	jnz	@F
	jcxz	CLPexit&lseg
@@:
public CLP&lseg
CLP&lseg:
beg_fault_trap  CLPbad&lseg
        mov     es,cx
        or      bx,bx           ; cb == 0?
        jz      CLPexit&lseg    ; yes: just check selector
        dec     bx
        add     bx,ax
        jc      CLPbad1&lseg    ; check 16 bit overflow
        mov     bl,es:[bx]      ; check read permission, limit
end_fault_trap

public CLPexit&lseg
CLPexit&lseg:
	ret

CLPbad&lseg:
	fault_fix_stack
CLPbad1&lseg:
        mov     bx,ERR_BAD_PTR
	jmp	Inval_Param_&lseg

endif   ; genLP&lseg

ifdef	genLPBUF&lseg
public LPBUF0&lseg
LPBUF0&lseg:
	or	ax,ax	    ; if cx:ax == NULL, exit
	jnz	@F
	jcxz	LPBUFexit&lseg
@@:
public LPBUF&lseg
LPBUF&lseg:
beg_fault_trap  LPBUFbad&lseg
        mov     es,cx
        mov     cx, word ptr ss:[bx]	; cb == 0?
        jcxz    LPBUFexit&lseg		; yes: just check selector
	mov	dx, bx		
	mov	bx, ax
        or      byte ptr es:[bx],0  	; check write permission, start
	mov	bx, dx
LPBUFpast1&lseg:
        dec     cx
        add     cx,ax
	jnc	@f			; 16-bit overflow
	mov	bx, 0ffffh
	mov	cx, bx
        or      byte ptr es:[bx],0  	; check write permission, 64k-1
	jmp	LPBUFov&lseg
@@:
	mov	bx, cx
        or      byte ptr es:[bx],0  	; check write permission, end
	ret
end_fault_trap

public LPBUFexit&lseg
LPBUFexit&lseg:
	ret
LPBUFbad&lseg:
	mov	bx, dx
	pop	dx			; fault ip
	add	sp, 2			; fault
	cmp	dx, offset LPBUFpast1&lseg
	jb	LPBUFbad1&lseg

	mov	dx, es
	lsl	cx, dx
	jnz	LPBUFbad1&lseg		; should not occur, we have loaded es
LPBUFov&lseg:
	sub	cx, ax			; max legal cb
	inc	cx
	mov	word ptr ss:[bx], cx	; fix cb passed by user on stack
	mov	cx, es			; HandleParamError prints cx:ax
        mov     bx,ERR_BAD_PTR or ERR_WARNING
	jmp	Inval_Param_&lseg
LPBUFbad1&lseg:
	mov	cx, es			; HandleParamError prints cx:ax
        mov     bx,ERR_BAD_PTR
	jmp	Inval_Param_&lseg
endif	; genLPBUF&lseg

ifdef   genLPSZ&lseg

;
; cx:ax -> const pointer to z-terminated string or MAKEINTATOM atom.
;
public CLPSTRATOM0&lseg
CLPSTRATOM0&lseg:
        jcxz    CLPSZexit&lseg  ; If selector is NULL, then all is well.

public CLPSTRATOM&lseg
CLPSTRATOM&lseg:
	jcxz	@F		; if selector == 0, then may be atom.
        mov     bx,256          ; max string length of 255 characters.
	jmp	short CLPSZ&lseg
@@:
	or	ax,ax		; offset == 0? if so, it's bogus
	jz	ErrorStrPtr&lseg
CLPSZexit&lseg:
	ret
;
; cx:ax => const pointer to zero-terminated string.
; bx    => Maximum string length (including zero terminator)
;
public CLPSZ0&lseg
CLPSZ0&lseg:
        mov     dx,ax
        or      dx,cx
        jz      CLPSZexit&lseg
public CLPSZ&lseg
CLPSZ&lseg:
        push    di              ; preserve these regs
        push    cx
        mov     dx,ax           ; preserve original ax in dx
beg_fault_trap  LPSZfault&lseg
        mov     es,cx
        mov     di,ax

	xor	ax,ax
	mov	cx,-1
	cld
	repnz	scasb
end_fault_trap
        neg     cx              ; cx = string length + 1
        dec     cx
        cmp     cx,bx           ; error if string length + 1 > cchMax

        pop     cx              ; restore regs before branching
        pop     di
        xchg    ax,dx

        ja      ErrorStrPtr&lseg ; jump if error
        ret

LPSZfault&lseg:
        fault_fix_stack
        pop     cx              ; restore regs
        pop     di
        xchg    ax,dx

public ErrorStrPtr&lseg
ErrorStrPtr&lseg:
	mov	bx,ERR_BAD_STRING_PTR
	jmp	Inval_Param_&lseg

endif   ; genLPSZ&lseg

ifdef   genSETEMPTY&lseg

public  SETEMPTY&lseg
SETEMPTY&lseg:
        jcxz    SETEMPTYexit&lseg   ; 0-length buffer: do nothing.
beg_fault_trap    SETEMPTYbad&lseg
        mov     es,dx
        mov     byte ptr es:[bx],0  ; jam in a zero terminator
end_fault_trap
SETEMPTYexit&lseg:
	xor	ax,ax
	cwd
        ret

SETEMPTYbad&lseg:
        fault_fix_stack
        jmp     short SETEMPTYexit&lseg

endif   ; genSETEMPTY&lseg

public VEnd&lseg
VEnd&lseg:

sEnd	%VLseg
VLseg equ <>

endm	;LAYER_EXPAND

endif	;; IF1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\lzdos.h ===
/* OBSOLETE: Replaced by #define LIB/#include <lzexpand.h> */
#ifndef LIB
#define LIB
#endif
#include <lzexpand.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the low-level
*	file handling and I/O functions.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* function prototypes */

int _FAR_ _cdecl access(const char _FAR_ *, int);
int _FAR_ _cdecl chmod(const char _FAR_ *, int);
int _FAR_ _cdecl chsize(int, long);
int _FAR_ _cdecl close(int);
int _FAR_ _cdecl creat(const char _FAR_ *, int);
int _FAR_ _cdecl dup(int);
int _FAR_ _cdecl dup2(int, int);
int _FAR_ _cdecl eof(int);
long _FAR_ _cdecl filelength(int);
int _FAR_ _cdecl isatty(int);
int _FAR_ _cdecl locking(int, int, long);
long _FAR_ _cdecl lseek(int, long, int);
char _FAR_ * _FAR_ _cdecl mktemp(char _FAR_ *);
int _FAR_ _cdecl open(const char _FAR_ *, int, ...);
int _FAR_ _cdecl _pipe(int _FAR_ *, unsigned int, int);
int _FAR_ _cdecl read(int, void _FAR_ *, unsigned int);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl setmode(int, int);
int _FAR_ _cdecl sopen(const char _FAR_ *, int, int, ...);
long _FAR_ _cdecl tell(int);
int _FAR_ _cdecl umask(int);
int _FAR_ _cdecl unlink(const char _FAR_ *);
int _FAR_ _cdecl write(int, const void _FAR_ *, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\klayer.inc ===
;=======================================================
;
; Macros stolen from cmacros.inc (so we don't have to include it all)
;
    .286p

externNP    macro   n
    irp x,<n>
    extrn x:near
    endm
endm

externFP    macro   n
    irp x,<n>
    extrn x:far
    endm
endm

externW     macro   w
    irp x,<w>
        extrn x:word
    endm
endm

assumes     macro s,ln
    assume  s:_&ln
endm

createSeg   macro n,ln,a,co,cl,grp
    n segment a co '&cl'
    n ends
endm

sBegin      macro   seg
    assume  cs:_&seg
    _&seg   segment
endm

sEnd        macro   seg
    _&seg ends
    assume  cs:nothing
endm

errnz macro x               ;;display error if expression is <>0
  if2
    if x                ;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm

errn$ macro l,x             ;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm

createSeg _DATA,DATA,WORD,PUBLIC,DATA

;=======================================================
;
; Error API definitions
;
ExternFP    <HandleParamError>

; error codes
include logerror.inc

;================================================================
;   Variable and temporary initialization

VLseg  equ <>      ; Holds current segment name

VLopen = 0
VLerrnotinvoked  = 0
ifndef VLnogenpall
VLnogenpall = 0
endif

VLnogen        = 0
VLnogenparm    = 0

VLsavees       = 0
VLsavebx       = 0

;if1
if 1

;================================================================
;   Utility macros

;---------------------------------------------------------------------------
;
; lodsw cs:[si]
;
cslodsw macro
    db  2eh     ;; CS override
    lodsw
endm

;---------------------------------------------------------------------------
;
; lodsb cs:[si]
;
cslodsb macro
    db  2eh     ;; CS override
    lodsb
endm

SkipTwoBytes macro
    db  0A9h    ;; Opcode for CMP AX,(immediate word)
endm

;---------------------------------------------------------------------------
;
; Define a as the concatenation of b & c
;
concat  macro   a,b,c,d,e,f
a   equ <b&c&d&e&f>
endm

;---------------------------------------------------------------------------
;
; Assign a to b.
;
equate  macro   a,b
    a   = b
endm

;
; Print a message
;
_print  macro a,b,c
if2
    %out   a&b&c
endif
endm


;===============================================================

;---------------------------------------------------------------------------
;
; _gensub   LABEL
;
; Causes per-segment subroutine code associated with type LABEL
; to be generated, by setting the genLABEL&lseg flag.
;
_gensub2    macro   l,s
    gen&l&s = 1
endm

_gensub macro   l
        _gensub2    <l>,%VLseg
endm

;---------------------------------------------------------------------------
; _SwitchSeg
;
; Switches current segment to seg, creating the segment if needed.
;
_SwitchSeg   macro   seg,oldseg
    ifdifi  <&seg>,<oldseg>

      ifnb  <oldseg>
sEnd oldseg
      endif

    concat  <VLseg>,seg,

createSeg _&seg,seg,WORD,PUBLIC,CODE

sBegin seg
assumes CS,seg

    endif
endm


;---------------------------------------------------------------------------
; API
;
API macro   rettype,name,seg,optlist

    if  VLopen
    APIEND
    endif

VLname equ <name>
VLcbparms      = 0
VLcbskip       = 0
VLerrnotinvoked= 1
VLopen         = 1
VLnogen        = 0
VLnogenparm    = 0
VLasm          = 0
VLfunnyframe   = 0
VLnodata       = 0
VLcargs        = 0
VLplist        equ <>
VLATMframe     = 0      ; special entry/exit code sequence for ATM's patching
VLATMfrmds     = 0      ; ATM entry/exit code: mov ax,_DATA at beginning.

VLsavees    = 0
VLsavebx        = 0
    _SwitchSeg seg,%VLseg

    irp opt,<optlist>

      ifidni  <opt>,<NOGEN>
      VLnogen = 1
      endif

      ifidni  <opt>,<VOID>
      VLnogen = 1
      endif

      ifidni  <opt>,<ASM>
      VLasm = 1
      endif

      ifidni  <opt>,<ATMFRAME>
      VLATMframe = 1
      endif

      ifidni  <opt>,<ATMFRAMEDS>
      VLATMfrmds = 1
      VLATMframe = 1
      endif

      ifidni  <opt>,<FUNNYFRAME>
      VLfunnyframe = 1
      endif

      ifidni  <opt>,<NODATA>
      VLnodata = 1
      endif

      ifidni  <opt>,<DEBUGONLY>
        ifndef DEBUG
        VLnogen = 1
        endif
      endif

      ifidni  <opt>,<C>
      VLcargs  = 1
      endif

      ifidni  <opt>,<SAVEES>
      VLsavees  = 2     ; sizeof(ES)
      endif

      ifidni  <opt>,<SAVEBX>
      VLsavebx  = 2     ; sizeof(BX)
      endif

    endm

concat  <VLsegoffset>,<seg>,<offset>
concat  <VLnameerror>,<name>,<_error>
concat  <VLnamecbparms>,<name>,<cbparms>

    if1
equate %VLnamecbparms, %VLcbparms
    else
equate %VLnamecbparms, %VLnamecbparms
    endif

    ife VLnogen

    ife VLcargs
concat  <VLiname>,<I>,<name>
ExternNP I&name

public  name
name:
    else
concat  <VLiname>,<_I>,<name>
ExternNP _I&name

public  _&name
_&name:
    endif

VLframe =   0           ; no frame set up yet.

    endif  ; VLnogen

endm    ;; VL

;---------------------------------------------------------------------------
; APIERR
;
; Optionally used after parameter decls to begin error handling code
;
APIERR  macro   opts

    ife VLnogen
      ife VLframe
    _print  <Nothing to validate for >,%VLiname
      else
    pop dx      ; pop off error handler address
    pop bp      ; restore BP
       if VLATMframe
    dec bp      ; fix BP back up
       endif
       if VLsavees
    pop es
       endif
       if VLsavebx
        pop     bx
       endif
      endif
    jmp VLiname     ; jmp to internal routine.

equate %VLnamecbparms, %VLcbparms

VLnameerror:
    VLerrnotinvoked  = 0

    endif ; VLnogen

endm    ;; APIERR

;---------------------------------------------------------------------------
; APIEND
;
; Used after APIERR to terminate error handling code.
;
APIEND  macro

_PurgeParms %VLplist

    ife VLnogen

    if  VLerrnotinvoked
    APIERR
    endif
    if VLsavees
    pop es
    endif
    if VLsavebx
        pop     bx
    endif
    ife VLcargs
    retf    VLcbparms
    else
    retf
    endif

VLopen = 0

    endif   ; VLnogen

endm    ;; APIEND

;---------------------------------------------------------------------------
;
; _FlsFrame - Generate frame code
;
_FlsFrame   macro
    ife VLframe
     if VLATMfrmds
    mov ax,_DATA
     endif
     if VLsavebx
        push    bx
     endif
     if VLsavees
    push    es
     endif
     if VLATMframe
    inc bp
    push    bp
    mov bp,sp
    push    ds          ; push ds and pop it off.
    pop ds          ; (we need to pop DS rather than
                    ;  something fast like pop AX because
                    ; ATM doesn't preserve DS itself)
     else
    push    bp
    mov bp,sp
     endif
    push    offset VLnameerror  ; push address of error handler
    VLframe = 1
    endif
endm

;---------------------------------------------------------------------------
; _ChkName
;
; Ensure name was specified

_ChkName    macro name
    ifb <name>
    _print <Missing parameter name in >,%VLiname
    endif
endm

;---------------------------------------------------------------------------
; _ParmOpts
;
; Parse parameter option flags
;
_ParmOpts  macro opts

    VLnogenparm = VLnogenpall

    irp opt,<opts>
    ifidni  <opt>,<DEBUGONLY>
    ifndef DEBUG
        VLnogenparm = 1
    endif
    ifidni  <opt>,<NOGEN>
        VLnogenparm = 1
    endif
    endif
    endm
endm

;---------------------------------------------------------------------------
; _DefParm name,cb,opts
;
; Take care of default parameter stuff, such as defining argument.
;
_DP_Add     macro   old,new
    ifb     <old>
VLplist equ <new>
    else
VLplist equ <old,new>
    endif
endm

_DefParm   macro   name,cb,opts
    _ChkName    <name>
    _ParmOpts   <opts>

  if VLcargs
concat  _P_&name,<[bp]+6+>,%(VLcbparms+VLsavees+VLsavebx)
    VLcbparms=VLcbparms+(cb)
  else
    VLcbparms=VLcbparms+(cb)
concat  _P_&name,<[bp]+6->,%VLcbparms,<+>,%(VLnamecbparms+VLsavees+VLsavebx)
  endif

_DP_Add     %VLplist,<_P_&name>

    VLgen = 1
    if VLnogenparm or VLnogen
        VLgen = 0
    endif
endm

;----------------------------------------------------------------------------
;
; _GenParm  name, cb, opts
;
_GenParm    macro   name,cb,opts
    _DefParm    <name>,<cb>,<opts>
    if VLgen
    _FlsFrame
    endif
endm

lcall2  macro   op,label,seg
    op  label&seg
endm

lcall   macro   label
    lcall2  <call>,<label>,%VLseg
endm

ljmp    macro   label
    lcall2  <jmp>,<label>,%VLseg
endm

;
; _PurgeParms - purge list of parameters we've defined
;
_PurgeParms   macro   list
    irp sym,<list>
sym equ <>
    endm
endm

;---------------------------------------------------------------------------
; LAYER_START
;
; Used before any VL invocations
;
LAYER_START macro
assumes ds,DATA

endm

;---------------------------------------------------------------------------
; LAYER_END
;
; Ends all VL definitions
;
LAYER_END   macro
    if VLsopen
    ENDSTRUCT
    endif
    if VLopen
    APIEND
    endif
    if VLerrnotinvoked
    APIERR
    endif
endm

;=========================================================================
;
; Structure related macros
;
; Structure globals

VLsopen =0

;
; STRUCT - begins a structure declaration
;
STRUCT  macro   name,opts
  if VLsopen
    ENDSTRUCT
  endif
  VLsopen=1

concat  VLcbs,<VLcbs>,name
VLcbstruct  =   0
endm

;
; ENDSTRUCT macro - terminates a STRUCT declaration
;
ENDSTRUCT   macro
equate  %VLcbs,%VLcbstruct

VLsopen =0
endm

;
; Define simple field macro, given:
;   f = macro name
;   cb = size of field
;
_SSize  macro   cb,opts
VLcbstruct  =   VLcbstruct + (cb)
endm

_DefSimpleF macro   f,cb
    f   &macro  name,opts
    equate  _F_&&name,%VLcbstruct
    _SSize  cb
    &endm
endm

_DefSimpleF F_char,1
_DefSimpleF F_BYTE,1

_DefSimpleF F_int,2
_DefSimpleF F_WORD,2
_DefSimpleF F_BOOL,2
_DefSimpleF F_FLAGS,2

_DefSimpleF F_LONG,4
_DefSimpleF F_DWORD,4

_DefSimpleF F_intMBZ,2
_DefSimpleF F_DWORDMBZ,4

_DefSimpleF F_LPVOID,4
_DefSimpleF F_CLPSTR,4
_DefSimpleF F_CLPSTR0,4
_DefSimpleF F_LPSTR,4

_DefSimpleF F_POINT,4
_DefSimpleF F_RECT,8

F_RGB   macro   name,cb,opts
    equate  _F_&name,%VLcbstruct
    _SSize  cb
endm

F_RGCH  equ <F_RGB>

F_RGW   macro   name,cw,opts
    equate  _F_&name,%VLcbstruct
    _SSize  (cw*2)
endm

;
; Generate a P_?LP???? macro, given:
;
; n = parameter macro name (e.g., P_LPRECT)
; r = handler routine name (e.g., LP)
; cb = size of buffer
;
; The generated macro checks only whether the
; buffer is big enough.
;
_GenLP  macro   n,r,cb
    &n      &macro   name,opts
        _GenParm    <name>,4,<opts>
        if VLgen
        mov     ax,_P_&&name
        mov     cx,_P_&&name+2
        mov     bx,cb
        lcall   &r
            _gensub <LP>
    endif
    &endm
endm

;=========================================================================
;
; Generic parameter macros
;
P_2 macro   name, opts
    _DefParm      <name>,2,<opts>
endm

P_4 macro   name, opts
    _DefParm      <name>,4,<opts>
endm

P_char      equ <P_2>
P_int       equ <P_2>
P_BYTE      equ <P_2>
P_BOOL      equ <P_2>
P_WORD      equ <P_2>

P_WORDMBZ   equ <P_2>
P_WORDMBNZ  equ <P_2>

P_LONG      equ <P_4>
P_DWORD     equ <P_4>

;
; Generic handle
;
P_H macro   name, opts
    _GenParm    <name>,2,<opts>
    if VLgen
    mov ax,_P_&name
    lcall   H
        _gensub H
    endif
endm

;
; Generic handle or NULL
;
P_H0    equ <P_2>

;
; Ensure signed value is min <= value <= max
;
P_RVALUE    macro   name, min, max, opts
        local   valok
    _GenParm    <name>,2,<opts>
    if VLgen
    mov ax,_P_&name
    cmp ax,min
    jl  @F
    cmp ax,max
        jle     valok
@@:
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
valok:
    endif
endm

;
; Ensure signed value is 0 <= value <= max
;
P_VALUE     macro   name, max, opts
    _GenParm    <name>,2,<opts>
    if VLgen
    mov ax,_P_&name
    cmp ax,max
    jbe @F          ;; unsigned comparison to catch < 0.
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
endm

;
; Ensure unsigned value is value <= max
;
P_UVALUE    equ <P_VALUE>

;
; Ensure signed value is 0 <= value <= max
;
P_VALUEW     macro   name, max, opts
    _GenParm    <name>,2,<opts>
    if VLgen
    mov ax,_P_&name
    cmp ax,max
    jbe @F          ;; unsigned comparison to catch < 0.
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
endm

;
; Ensure unsigned value is value <= max
;
P_UVALUEW    equ <P_VALUEW>

;
; Ensure signed byte value is min <= value <= max
;
if 0
P_BVALUE    macro   name,max,opts
    _GenParm    <name>,2,<opts>
    if VLGen
    mov al,_P_&name
    cmp al,max
    jle @F
    lcall   ErrorBValue
@@:
    endif
endm
else
P_BVALUE    equ <P_2>
endif

;
; Ensure that no incorrect bits are set in a flags word
; (i.e., (name & ~valid) == 0)
;
P_FLAGS     macro   name, valid, opts
  _DefParm  <name>,2,<opts>
  if not(valid)
    if VLgen
    _FlsFrame
    mov ax,_P_&name
      ife (low(not(valid)))
    test    ah,high(not(valid))
      else
       ife (high(not(valid)))
    test    al,low(not(valid))
       else
    test    ax,not(valid)
       endif
      endif
    jz  @F
        mov     bx,ERR_BAD_FLAGS or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
  endif
endm

;
; Ensure that no incorrect bits are set in a flags dword
; (i.e., (name & ~valid) == 0)
;
P_DFLAGS    macro   name, valid_l, valid_h, opts
        local   flagok
  _DefParm   <name>,4,<opts>
  if not(valid_l) or not(valid_h)
    if VLgen
    _FlsFrame
    mov ax,_P_&name
    mov cx,_P_&name+2
      if not(valid_l)
    test    ax,not(valid_l)
       if not(valid_h)
    jnz @F
       else
        jz      flagok
       endif
      endif
      if not(valid_h)
    test    cx,not(valid_h)
        jz      flagok
@@:
      endif
        mov     bx,ERR_BAD_DFLAGS or ERR_WARNING
        lcall   Inval_Param_
flagok:
    endif
  endif
endm

;
; P_LPFN   - function pointer
; P_LPFN0  - function pointer or NULL
;
P_LPFN  macro   name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    lcall   LPFN
        _gensub LPFN
    endif
endm

P_LPFN0 macro   name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    lcall   LPFN0
        _gensub LPFN
    endif
endm

_GenBuf macro p,r
    P_&p  &macro   lpch, cch, opts
    _DefParm    <lpch>,4,<opts>
    _DefParm    <cch>,2,<opts>
        if VLgen
        _FlsFrame
        mov     ax,_P_&&lpch
        mov     cx,_P_&&lpch+2
        mov     bx,_P_&&cch
        lcall   &r
            _gensub LP
    endif
    &endm
endm

_GenBufspl macro p,r
    P_&p  &macro   lpch, cch, opts
    _DefParm    <lpch>,4,<opts>
    _DefParm    <cch>,2,<opts>
        if VLgen
        _FlsFrame
        mov     ax,_P_&&lpch
        mov     cx,_P_&&lpch+2
        lea     bx,_P_&&cch
        lcall   &r
            _gensub LPBUF
    endif
    &endm
endm

_GenBufspl <LPBUFFER>,<LPBUF>
_GenBuf <CLPBUFFER>,<CLP>
_GenBufspl <LPBUFFER0>,<LPBUF0>
_GenBuf <CLPBUFFER0>,<CLP0>

;
; If pszBuf is valid, set its first byte to 0
;
E_SETEMPTY  macro   pszBuf,cchBuf,opts
        push    bp
    mov bp,sp
    mov cx,_P_&cchBuf
        mov     bx,_P_&pszBuf
        mov     dx,_P_&pszBuf+2
    pop bp
        lcall   SETEMPTY
        _gensub SETEMPTY
endm

; Same as above, but with no supplied count
;
E_SETEMPTYNC  macro   pszBuf,opts
        push    bp
        mov     bp,sp
        mov     cx,1
        mov     bx,_P_&pszBuf
        mov     dx,_P_&pszBuf+2
        pop     bp
        lcall   SETEMPTY
        _gensub SETEMPTY
endm

_GenLP  <P_LPSTR>,<LP>,1
_GenLP  <P_LPSTR0>,<LP0>,1

P_CLPSTR macro   name,cch,opts
    _GenParm    <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    ifb <cch>
        mov     bx,-1
    else
        mov     bx,cch
    endif
    lcall   CLPSZ
        _gensub LPSZ
    endif
endm

P_CLPSTR0 macro   name,cch,opts
    _GenParm    <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    ifb <cch>
        mov     bx,-1
    else
        mov     bx,cch
    endif
    lcall   CLPSZ0
        _gensub LPSZ
    endif
endm

_GenLP  <P_LPVOID>,<LP>,1
_GenLP  <P_LPVOID0>,<LP0>,1
_GenLP  <P_CLPVOID>,<CLP>,1
_GenLP  <P_CLPVOID0>,<CLP0>,1

_GenLP  <P_LPBYTE>,<LP>,1
_GenLP  <P_LPBYTE0>,<LP0>,1
_GenLP  <P_CLPBYTE>,<CLP>,1
_GenLP  <P_CLPBYTE0>,<CLP0>,1

_GenLP  <P_LPINT>,<LP>,2
_GenLP  <P_LPINT0>,<LP0>,2
_GenLP  <P_CLPINT>,<CLP>,2
_GenLP  <P_CLPINT0>,<CLP0>,2

_GenLP  <P_LPWORD>,<LP>,2
_GenLP  <P_LPWORD0>,<LP0>,2
_GenLP  <P_CLPWORD>,<CLP>,2
_GenLP  <P_CLPWORD0>,<CLP0>,2

_GenLP  <P_LPBOOL>,<LP>,2
_GenLP  <P_LPBOOL0>,<LP0>,2
_GenLP  <P_CLPBOOL>,<CLP>,2
_GenLP  <P_CLPBOOL0>,<CLP0>,2

_GenLP  <P_LPLONG>,<LP>,4
_GenLP  <P_LPLONG0>,<LP0>,4
_GenLP  <P_CLPLONG>,<CLP>,4
_GenLP  <P_CLPLONG0>,<CLP0>,4

_GenLP  <P_LPDWORD>,<LP>,4
_GenLP  <P_LPDWORD0>,<LP0>,4
_GenLP  <P_CLPDWORD>,<CLP>,4
_GenLP  <P_CLPDWORD0>,<CLP0>,4

;=======================================================================
;
; Common USER types
;
STRUCT  <POINT>
F_int        x
F_int        y
ENDSTRUCT

_GenLP  <P_LPPOINT>,<LP>,%VLcbsPOINT
_GenLP  <P_LPPOINT0>,<LP0>,%VLcbsPOINT
_GenLP  <P_CLPPOINT>,<CLP>,%VLcbsPOINT
_GenLP  <P_CLPPOINT0>,<CLP0>,%VLcbsPOINT
P_POINT     equ <P_4>

STRUCT  <RECT>
F_int        left
F_int        top
F_int        right
F_int        bottom
ENDSTRUCT

_GenLP  <P_LPRECT>,<LP>,%VLcbsRECT
_GenLP  <P_LPRECT0>,<LP0>,%VLcbsRECT
_GenLP  <P_CLPRECT>,<CLP>,%VLcbsRECT
_GenLP  <P_CLPRECT0>,<CLP0>,%VLcbsRECT

;=======================================================================
;
; Common KERNEL types
;
P_GHANDLE   macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
    mov ax,_P_&h
    lcall   GHANDLE
        _gensub GHANDLE
    endif

endm

P_GHANDLE0  macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
    mov ax,_P_&h
    lcall   GHANDLE0
        _gensub GHANDLE
    endif
endm

P_GHANDLE32  macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
    mov ax,_P_&h
    test al, 0100b;
    jz   @F
    lcall   GHANDLE
    @@:
    endif
endm

P_HANDLE    equ <P_H>
P_HANDLE0   equ <P_H0>

P_ATOM      equ <P_H>

P_HINSTANCE equ <P_GHANDLE>
P_HINSTANCE0 equ <P_GHANDLE0>

P_HMODULE   equ <P_GHANDLE>
P_HMODULE0  equ <P_GHANDLE0>
P_HMODULE32 equ <P_GHANDLE32>

P_HTASK     equ <P_GHANDLE>
P_HTASK0    equ <P_GHANDLE0>

P_CLPSTRATOM macro   name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    lcall   CLPSTRATOM
        _gensub LPSZ
    endif
endm

P_CLPSTRATOM0 macro name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    lcall   CLPSTRATOM0
        _gensub LPSZ
    endif
endm

P_CLPSTRRSRC  equ <P_CLPSTRATOM>
P_CLPSTRRSRC0 equ <P_CLPSTRATOM0>

;---------------------------------------------------------------------------
; LAYER_EXPAND  lseg
;
; Expands per-segment validation boilerplate code into segment lseg
;
LAYER_EXPAND    macro   lseg
.list
.lall
    _SwitchSeg  &lseg,%VLseg

public  VStart&lseg
VStart&lseg:

EXTRA_EXPAND    lseg

;
; Handle validation
;
ifdef genH&lseg

public H&lseg
H&lseg:
    or  ax,ax
        jz      @F
    ret
@@:
        mov     bx,ERR_BAD_HANDLE
        jmp     short Inval_Param_&lseg

endif   ; genH&lseg

ifdef genGHANDLE&lseg

public GHANDLE0&lseg
GHANDLE0&lseg:
    or  ax,ax       ; accept NULL
    jz  GHexit&lseg

public GHANDLE&lseg
GHANDLE&lseg:
    test    al,0100b    ; Reject GDT selectors
    jnz      GHldt&lseg
                        ; not yet. Some WOW cursor/icon handles
    cmp  ax, 0f000h     ; look like GDT sels and are > 0xf000
    ifdef JAPAN
    jb   GHerr&lseg     ; Reject GDT sels now.
    else
    jae  GHexit&lseg
    jmp  GHerr&lseg     ; Reject GDT sels now.
    endif		; JAPAN
GHldt&lseg:
    cmp ax,0ffffh   ; special case: -1 -> DS
    jz  GHexit&lseg
    lar dx,ax       ; is it a valid selector?
        jnz     GHerr&lseg
GHexit&lseg:
    ret

GHerr&lseg:
        mov     bx,ERR_BAD_GLOBAL_HANDLE
        jmp     short Inval_Param_&lseg

endif   ; genGHANDLE&lseg

ifdef genLPFN&lseg

;
; Function pointer validation
;
public LPFN0&lseg
LPFN0&lseg:
    mov bx,ax       ; Allow NULL
    or  bx,cx
    jz  LPFN_exit&lseg

public LPFN&lseg
LPFN&lseg:
beg_fault_trap  LPFNbad&lseg
        lar     bx,cx
        jnz     LPFNerr&lseg
        test    bh,8
        jz      LPFNerr&lseg
        mov     es,cx       ; validate pointer & offset
        mov     bx,ax
        mov     al,es:[bx]
end_fault_trap

ifdef DEBUG
;
; Make sure the function is exported by
; ensuring that the first instructions are NOT
; push ds, pop ax or mov ax,ds.
;
    mov bx,es:[bx]+2

        cmp     bx,0581eh                   ; Push ds, pop ax instructions?
        jz      LPFNerr&lseg                ; Yes, must be an error.
        cmp     bx,0d88ch                   ; Mov ax,ds instruction?
        jz      LPFNerr&lseg                ; No, we're ok, so jump ahead
endif   ; DEBUG

LPFN_exit&lseg:
    ret

LPFNbad&lseg:
    fault_fix_stack
LPFNerr&lseg:
        mov     bx,ERR_BAD_FUNC_PTR
        jmp     short Inval_Param_&lseg

endif   ; genLPFN&lseg

public Inval_Param_&lseg
Inval_Param_&lseg:
        pop     dx          ; convert near return addr to far
        push    cs
        push    dx
        jmp     HandleParamError

ifdef genLP&lseg

public LP0&lseg
LP0&lseg:
    or  ax,ax       ; if cx:ax == NULL, exit
    jnz @F
    jcxz    CLPexit&lseg
@@:
public LP&lseg
LP&lseg:
beg_fault_trap  CLPbad&lseg
        mov     es,cx
        or      bx,bx           ; cb == 0?
        jz      CLPexit&lseg    ; yes: just check selector
        dec     bx
        add     bx,ax
        jc      CLPbad1&lseg    ; check 16 bit overflow
        or      byte ptr es:[bx],0  ; check write permission, limit
end_fault_trap
        ret

public CLP0&lseg
CLP0&lseg:
        or      ax,ax           ; Accept ax:cx == 0
    jnz @F
    jcxz    CLPexit&lseg
@@:
public CLP&lseg
CLP&lseg:
beg_fault_trap  CLPbad&lseg
        mov     es,cx
        or      bx,bx           ; cb == 0?
        jz      CLPexit&lseg    ; yes: just check selector
        dec     bx
        add     bx,ax
        jc      CLPbad1&lseg    ; check 16 bit overflow
        mov     bl,es:[bx]      ; check read permission, limit
end_fault_trap

public CLPexit&lseg
CLPexit&lseg:
    ret

CLPbad&lseg:
    fault_fix_stack
CLPbad1&lseg:
        mov     bx,ERR_BAD_PTR
    jmp Inval_Param_&lseg

endif   ; genLP&lseg

ifdef   genLPBUF&lseg
public LPBUF0&lseg
LPBUF0&lseg:
    or  ax,ax       ; if cx:ax == NULL, exit
    jnz @F
    jcxz    LPBUFexit&lseg
@@:
public LPBUF&lseg
LPBUF&lseg:
beg_fault_trap  LPBUFbad&lseg
        mov     es,cx
        mov     cx, word ptr ss:[bx]    ; cb == 0?
        jcxz    LPBUFexit&lseg      ; yes: just check selector
    mov dx, bx
    mov bx, ax
        or      byte ptr es:[bx],0      ; check write permission, start
    mov bx, dx
LPBUFpast1&lseg:
        dec     cx
        add     cx,ax
    jnc @f          ; 16-bit overflow
    mov bx, 0ffffh
    mov cx, bx
        or      byte ptr es:[bx],0      ; check write permission, 64k-1
    jmp LPBUFov&lseg
@@:
    mov bx, cx
        or      byte ptr es:[bx],0      ; check write permission, end
    ret
end_fault_trap

public LPBUFexit&lseg
LPBUFexit&lseg:
    ret
LPBUFbad&lseg:
    mov bx, dx
    pop dx          ; fault ip
    add sp, 2           ; fault
    cmp dx, offset LPBUFpast1&lseg
    jb  LPBUFbad1&lseg

    mov dx, es
    lsl cx, dx
    jnz LPBUFbad1&lseg      ; should not occur, we have loaded es
LPBUFov&lseg:
    sub cx, ax          ; max legal cb
    inc cx
    mov word ptr ss:[bx], cx    ; fix cb passed by user on stack
    mov cx, es          ; HandleParamError prints cx:ax
        mov     bx,ERR_BAD_PTR or ERR_WARNING
    jmp Inval_Param_&lseg
LPBUFbad1&lseg:
    mov cx, es          ; HandleParamError prints cx:ax
        mov     bx,ERR_BAD_PTR
    jmp Inval_Param_&lseg
endif   ; genLPBUF&lseg

ifdef   genLPSZ&lseg

;
; cx:ax -> const pointer to z-terminated string or MAKEINTATOM atom.
;
public CLPSTRATOM0&lseg
CLPSTRATOM0&lseg:
        jcxz    CLPSZexit&lseg  ; If selector is NULL, then all is well.

public CLPSTRATOM&lseg
CLPSTRATOM&lseg:
    jcxz    @F      ; if selector == 0, then may be atom.
        mov     bx,256          ; max string length of 255 characters.
    jmp short CLPSZ&lseg
@@:
    or  ax,ax       ; offset == 0? if so, it's bogus
    jz  ErrorStrPtr&lseg
CLPSZexit&lseg:
    ret
;
; cx:ax => const pointer to zero-terminated string.
; bx    => Maximum string length (including zero terminator)
;
public CLPSZ0&lseg
CLPSZ0&lseg:
        mov     dx,ax
        or      dx,cx
        jz      CLPSZexit&lseg
public CLPSZ&lseg
CLPSZ&lseg:
        push    di              ; preserve these regs
        push    cx
        mov     dx,ax           ; preserve original ax in dx
beg_fault_trap  LPSZfault&lseg
        mov     es,cx
        mov     di,ax

    xor ax,ax
    mov cx,-1
    cld
    repnz   scasb
end_fault_trap
        neg     cx              ; cx = string length + 1
        dec     cx
        cmp     cx,bx           ; error if string length + 1 > cchMax

        pop     cx              ; restore regs before branching
        pop     di
        xchg    ax,dx

        ja      ErrorStrPtr&lseg ; jump if error
        ret

LPSZfault&lseg:
        fault_fix_stack
        pop     cx              ; restore regs
        pop     di
        xchg    ax,dx

public ErrorStrPtr&lseg
ErrorStrPtr&lseg:
    mov bx,ERR_BAD_STRING_PTR
    jmp Inval_Param_&lseg

endif   ; genLPSZ&lseg

ifdef   genSETEMPTY&lseg

public  SETEMPTY&lseg
SETEMPTY&lseg:
        jcxz    SETEMPTYexit&lseg   ; 0-length buffer: do nothing.
beg_fault_trap    SETEMPTYbad&lseg
        mov     es,dx
        mov     byte ptr es:[bx],0  ; jam in a zero terminator
end_fault_trap
SETEMPTYexit&lseg:
    xor ax,ax
    cwd
        ret

SETEMPTYbad&lseg:
        fault_fix_stack
        jmp     short SETEMPTYexit&lseg

endif   ; genSETEMPTY&lseg

public VEnd&lseg
VEnd&lseg:

sEnd    %VLseg
VLseg equ <>

endm    ;LAYER_EXPAND

endif   ;; IF1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\logerror.h ===
/****************************************************************************\
 *
 * LogError() and LogParamError() definitions
 *
 * Excerpted from WINDOWS.H, since that file isn't included by GDI & KERNEL.
\****************************************************************************/

/* If windows.h already included, don't redefine any of this. */
/* Include the stuff if NOLOGERROR was defined, though. */
#if (!defined(_INC_WINDOWS) || defined(NOLOGERROR))

#ifdef WINAPI
void WINAPI LogError(WORD err, void FAR* lpInfo);
void WINAPI LogParamError(WORD err, FARPROC lpfn, void FAR* param);
#endif

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

/* Internal error value masks */	    /* ;Internal */
#define ERR_TYPE_MASK		0x0fff	    /* ;Internal */
#define ERR_FLAGS_MASK		0xc000	    /* ;Internal */
					    /* ;Internal */
#define ERR_SIZE_MASK		0x3000
#define ERR_SIZE_SHIFT		12
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/* Debug fill constants */

#define DBGFILL_ALLOC		0xfd
#define DBGFILL_FREE		0xfb
#define DBGFILL_BUFFER		0xf9
#define DBGFILL_STACK		0xf7

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001  /* GlobalAlloc Failed */
#define ERR_GREALLOC            0x0002  /* GlobalReAlloc Failed */
#define ERR_GLOCK               0x0003  /* GlobalLock Failed */
#define ERR_LALLOC              0x0004  /* LocalAlloc Failed */
#define ERR_LREALLOC            0x0005  /* LocalReAlloc Failed */
#define ERR_LLOCK               0x0006  /* LocalLock Failed */
#define ERR_ALLOCRES            0x0007  /* AllocResource Failed */
#define ERR_LOCKRES             0x0008  /* LockResource Failed */
#define ERR_LOADMODULE          0x0009  /* LoadModule failed  */

/* USER errors */
#define ERR_CREATEDLG           0x0040  /* Create Dlg failure due to LoadMenu failure */
#define ERR_CREATEDLG2          0x0041  /* Create Dlg failure due to CreateWindow Failure */
#define ERR_REGISTERCLASS       0x0042  /* RegisterClass failure due to Class already registered */
#define ERR_DCBUSY              0x0043  /* DC Cache is full */
#define ERR_CREATEWND           0x0044  /* Create Wnd failed due to class not found */
#define ERR_STRUCEXTRA          0x0045  /* Unallocated Extra space is used */
#define ERR_LOADSTR             0x0046  /* LoadString() failed */
#define ERR_LOADMENU            0x0047  /* LoadMenu Failed     */
#define ERR_NESTEDBEGINPAINT    0x0048  /* Nested BeginPaint() calls */
#define ERR_BADINDEX            0x0049  /* Bad index to Get/Set Class/Window Word/Long */
#define ERR_CREATEMENU          0x004a  /* Error creating menu */

/* GDI errors */
#define ERR_CREATEDC            0x0080  /* CreateDC/CreateIC etc., failure */
#define ERR_CREATEMETA          0x0081  /* CreateMetafile failure */
#define ERR_DELOBJSELECTED      0x0082  /* Bitmap being deleted is selected into DC */
#define ERR_SELBITMAP           0x0083  /* Bitmap being selected is already selected elsewhere */

/* Debugging information support (DEBUG SYSTEM ONLY) */

#ifdef WINAPI

typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);
void WINAPI DebugFillBuffer(void FAR* lpb, UINT cb);

#endif

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004
#define WDI_VALID           0x0007  /* ;Internal */

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_FREEFILL        0x0002
#define DBO_BUFFERFILL      0x0004
#define DBO_COMPAT          0x0008
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020
#define DBO_RIP_STACK	    0x0040

#define DBO_SILENT          0x8000

#define DBO_PARAMBREAK      0x0000  /* ;Internal *//* Obsolete: was 0x4000 */
#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_TRACEON         0x0000  /* ;Internal *//* Obsolete: was 0x0200 */
#define DBO_INT3BREAK       0x0100

/* dwFilter values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000
#define DBF_SEVMASK         0xc000  /* ;Internal */
#define DBF_FILTERMASK      0x3fff  /* ;Internal */
#define DBF_INTERNAL        0x0000  /* ;Internal *//* Obsolete: was 0x2000 */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_COMPAT          0x0000  /* ;Internal *//* Obsolete: was 0x0200 */
#define DBF_LOGERROR        0x0000  /* ;Internal *//* Obsolete: was 0x0100 */
#define DBF_PARAMERROR      0x0000  /* ;Internal *//* Obsolete: was 0x0080 */
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0010
#define DBF_DRIVER          0x0008

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\lzexpand.h ===
/*****************************************************************************\
*                                                                             *
* lzexpand.h    Public interfaces for LZEXPAND.DLL.                           *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               NOTE: windows.h must be included first if LIB is NOT #defined *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with LZEXP?.LIB (default is for LZEXPAND.DLL)
*                 NOTE: Not compatible with windows.h if LIB is #defined
*
\*****************************************************************************/

#ifndef _INC_LZEXPAND
#define _INC_LZEXPAND

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#define LZAPI       _pascal

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#endif  /* WINAPI */

#else   /* LIB */

#define LZAPI       _far _pascal

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/****** Error return codes ***************************************************/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of range */
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */

/****** Public functions *****************************************************/

int     LZAPI LZStart(void);
void    LZAPI LZDone(void);
LONG    LZAPI CopyLZFile(HFILE, HFILE);
LONG    LZAPI LZCopy(HFILE, HFILE);
HFILE   LZAPI LZInit(HFILE);
int     LZAPI GetExpandedName(LPCSTR, LPSTR);
HFILE   LZAPI LZOpenFile(LPCSTR, OFSTRUCT FAR*, UINT);
LONG    LZAPI LZSeek(HFILE, LONG, int);
int     LZAPI LZRead(HFILE, void FAR*, int);
void    LZAPI LZClose(HFILE);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif  /* _INC_LZEXPAND */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\logerror.inc ===
;---------------------------------------------------------------------------
; Added for Win 31 style Parameter Validation.
;
; Note: This file was copied AS IT IS from Win 31 golden sources and MUST
;	NOT be changed unless it changes in Win 31.
;
; History : Added on 14-April-92 by Chandan Chauhan (ChandanC)
;
;---------------------------------------------------------------------------


;/****** LogParamError/LogError values */

;/* Error modifier bits */

ERR_WARNING             equ 08000h
ERR_PARAM               equ 04000h

;/* Internal error value masks */       ;/* ;Internal */
ERR_TYPE_MASK           equ 00fffh      ;/* ;Internal */
ERR_FLAGS_MASK          equ 0c000h      ;/* ;Internal */
                                        ;/* ;Internal */
ERR_SIZE_MASK           equ 03000h
ERR_SIZE_SHIFT          equ 12
ERR_BYTE                equ 01000h
ERR_WORD                equ 02000h
ERR_DWORD               equ 03000h

;/****** LogParamError() values */

;/* Generic parameter values */
ERR_BAD_VALUE           equ 06001h
ERR_BAD_FLAGS           equ 06002h
ERR_BAD_INDEX           equ 06003h
ERR_BAD_DVALUE          equ 07004h
ERR_BAD_DFLAGS          equ 07005h
ERR_BAD_DINDEX          equ 07006h
ERR_BAD_PTR             equ 07007h
ERR_BAD_FUNC_PTR        equ 07008h
ERR_BAD_SELECTOR        equ 06009h
ERR_BAD_STRING_PTR      equ 0700ah
ERR_BAD_HANDLE          equ 0600bh

;/* KERNEL parameter errors */
ERR_BAD_HINSTANCE       equ 06020h
ERR_BAD_HMODULE         equ 06021h
ERR_BAD_GLOBAL_HANDLE   equ 06022h
ERR_BAD_LOCAL_HANDLE    equ 06023h
ERR_BAD_ATOM            equ 06024h
ERR_BAD_HFILE           equ 06025h

;/* USER parameter errors */
ERR_BAD_HWND            equ 06040h
ERR_BAD_HMENU           equ 06041h
ERR_BAD_HCURSOR         equ 06042h
ERR_BAD_HICON           equ 06043h
ERR_BAD_HDWP            equ 06044h
ERR_BAD_CID             equ 06045h
ERR_BAD_HDRVR           equ 06046h

;/* GDI parameter errors */
ERR_BAD_COORDS          equ 07060h
ERR_BAD_GDI_OBJECT      equ 06061h
ERR_BAD_HDC             equ 06062h
ERR_BAD_HPEN            equ 06063h
ERR_BAD_HFONT           equ 06064h
ERR_BAD_HBRUSH          equ 06065h
ERR_BAD_HBITMAP         equ 06066h
ERR_BAD_HRGN            equ 06067h
ERR_BAD_HPALETTE        equ 06068h
ERR_BAD_HMETAFILE       equ 06069h

;/* Debug fill constants */

DBGFILL_ALLOC           equ 0fdh
DBGFILL_FREE            equ 0fbh
DBGFILL_BUFFER          equ 0f9h
DBGFILL_STACK           equ 0f7h

;/**** LogError() values */

;/* KERNEL errors */
ERR_GALLOC              equ 00001h  ;/* GlobalAlloc Failed */
ERR_GREALLOC            equ 00002h  ;/* GlobalReAlloc Failed */
ERR_GLOCK               equ 00003h  ;/* GlobalLock Failed */
ERR_LALLOC              equ 00004h  ;/* LocalAlloc Failed */
ERR_LREALLOC            equ 00005h  ;/* LocalReAlloc Failed */
ERR_LLOCK               equ 00006h  ;/* LocalLock Failed */
ERR_ALLOCRES            equ 00007h  ;/* AllocResource Failed */
ERR_LOCKRES             equ 00008h  ;/* LockResource Failed */
ERR_LOADMODULE          equ 00009h  ;/* LoadModule failed  */

;/* USER errors */
ERR_CREATEDLG           equ 00040h  ;/* Create Dlg failure due to LoadMenu failure */
ERR_CREATEDLG2          equ 00041h  ;/* Create Dlg failure due to CreateWindow Failure */
ERR_REGISTERCLASS       equ 00042h  ;/* RegisterClass failure due to Class already registered */
ERR_DCBUSY              equ 00043h  ;/* DC Cache is full */
ERR_CREATEWND           equ 00044h  ;/* Create Wnd failed due to class not found */
ERR_STRUCEXTRA          equ 00045h  ;/* Unallocated Extra space is used */
ERR_LOADSTR             equ 00046h  ;/* LoadString() failed */
ERR_LOADMENU            equ 00047h  ;/* LoadMenu Failed     */
ERR_NESTEDBEGINPAINT    equ 00048h  ;/* Nested BeginPaint() calls */
ERR_BADINDEX            equ 00049h  ;/* Bad index to Get/Set Class/Window Word/Long */
ERR_CREATEMENU          equ 0004ah  ;/* Error creating menu */

;/* GDI errors */
ERR_CREATEDC            equ 00080h  ;/* CreateDC/CreateIC etc., failure */
ERR_CREATEMETA          equ 00081h  ;/* CreateMetafile failure */
ERR_DELOBJSELECTED      equ 00082h  ;/* Bitmap being deleted is selected into DC */
ERR_SELBITMAP           equ 00083h  ;/* Bitmap being selected is already selected elsewhere */

;****** DebugOutput definitions

; [Windows] DebugOptions field values

DBO_CHECKHEAP       equ 00001h

DBO_BUFFERFILL      equ 00004h
DBO_COMPAT          equ 00008h
DBO_DISABLEGPTRAPPING equ 00010h
DBO_CHECKFREE       equ 00020h
DBO_RIP_STACK	    equ 00040h

DBO_SILENT          equ 08000h

DBO_PARAMBREAK      equ 00000h  ; Obsolete: was 04000h
DBO_TRACEBREAK      equ 02000h
DBO_WARNINGBREAK    equ 01000h
DBO_NOERRORBREAK    equ 00800h
DBO_NOFATALBREAK    equ 00400h
DBO_TRACEON         equ 00000h  ; Obsolete: was 00200h
DBO_INT3BREAK       equ 00100h

; flags values

DBF_TRACE           equ 00000h
DBF_WARNING         equ 04000h
DBF_ERROR           equ 08000h
DBF_FATAL           equ 0c000h

DBF_SEVMASK         equ 0c000h
DBF_FILTERMASK      equ 03fffh

; [Windows] DebugFilter and flags values

DBF_INTERNAL        equ 00000h  ; Obsolete: was 02000h
DBF_KERNEL          equ 01000h
DBF_KRN_MEMMAN      equ 00001h
DBF_KRN_LOADMODULE  equ 00002h
DBF_KRN_SEGMENTLOAD equ 00004h
DBF_USER            equ 00800h
DBF_GDI             equ 00400h
DBF_COMPAT          equ 00000h  ; Obsolete: was 00200h
DBF_LOGERROR        equ 00000h  ; Obsolete: was 00100h
DBF_PARAMERROR      equ 00000h  ; Obsolete: was 00080h
DBF_MMSYSTEM        equ 00040h
DBF_PENWIN          equ 00020h
DBF_APPLICATION     equ 00010h
DBF_DRIVER          equ 00008h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the
*	buffer (memory) manipulation routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);


/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\mmddk.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1991, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/


/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef  NOMIDIDEV               /* ;Internal */
#define MMNOMIDIDEV             /* ;Internal */
#endif  /*ifdef NOMIDIDEV */    /* ;Internal */
#ifdef  NOWAVEDEV               /* ;Internal */
#define MMNOWAVEDEV             /* ;Internal */
#endif  /*ifdef NOWAVEDEV */    /* ;Internal */
#ifdef  NOAUXDEV                /* ;Internal */
#define MMNOAUXDEV              /* ;Internal */
#endif  /*ifdef NOAUXDEV */     /* ;Internal */
#ifdef  NOTIMERDEV              /* ;Internal */
#define MMNOTIMERDEV            /* ;Internal */
#endif  /*ifdef NOTIMERDEV */   /* ;Internal */
#ifdef  NOJOYDEV                /* ;Internal */
#define MMNOJOYDEV              /* ;Internal */
#endif  /*ifdef NOJOYDEV */     /* ;Internal */
#ifdef  NOMCIDEV                /* ;Internal */
#define MMNOMCIDEV              /* ;Internal */
#endif  /*ifdef NOMCIDEV */     /* ;Internal */
#ifdef  NOTASKDEV               /* ;Internal */
#define MMNOTASKDEV             /* ;Internal */
#endif  /*ifdef NOTASKDEV*/     /* ;Internal */

#ifndef _INC_MMDDK
#define _INC_MMDDK   /* #defined if mmddk.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#define DCB_NOSWITCH   0x0008           /* don't switch stacks for callback */
#define DCB_TYPEMASK   0x0007           /* callback type mask */
#define DCB_NULL       0x0000           /* unknown callback type */

/* flags for wFlags parameter of DriverCallback() */
#define DCB_WINDOW     0x0001           /* dwCallback is a HWND */
#define DCB_TASK       0x0002           /* dwCallback is a HTASK */
#define DCB_FUNCTION   0x0003           /* dwCallback is a FARPROC */

BOOL WINAPI DriverCallback(DWORD dwCallback, UINT uFlags,
    HANDLE hDevice, UINT uMessage, DWORD dwUser, DWORD dwParam1, DWORD dwParam2);
void WINAPI StackEnter(void);
void WINAPI StackLeave(void);

/* generic prototype for audio device driver entry-point functions */
/* midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage() */
typedef DWORD (CALLBACK SOUNDDEVMSGPROC)(UINT uDeviceID, UINT uMessage,
    DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

/* device ID for 386 AUTODMA VxD */
#define VADMAD_Device_ID    0X0444

#ifndef MMNOWAVEDEV
/****************************************************************************
 
                       Waveform device driver support
 
****************************************************************************/

/* maximum number of wave device drivers loaded */
#define MAXWAVEDRIVERS 10


/* waveform input and output device open information structure */
typedef struct waveopendesc_tag {
    HWAVE          hWave;             /* handle */
    const WAVEFORMAT FAR* lpFormat;   /* format of wave data */
    DWORD          dwCallback;        /* callback */
    DWORD          dwInstance;        /* app's private instance information */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

#define DRVM_USER             0x4000

/* 
 * Message sent by mmsystem to wodMessage(), widMessage(), modMessage(),
 * and midMessage() when it initializes the wave and midi drivers 
 */

#define DRVM_INIT             100
#define WODM_INIT             DRVM_INIT
#define WIDM_INIT             DRVM_INIT
#define MODM_INIT             DRVM_INIT
#define MIDM_INIT             DRVM_INIT
#define AUXM_INIT             DRVM_INIT

/* messages sent to wodMessage() entry-point function */
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12 
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20

/* messages sent to widMessage() entry-point function */
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60

#endif  /*ifndef MMNOWAVEDEV */


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

/* maximum number of MIDI device drivers loaded */
#define MAXMIDIDRIVERS 10

/* MIDI input and output device open information structure */
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             /* handle */
    DWORD          dwCallback;        /* callback */
    DWORD          dwInstance;        /* app's private instance information */
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;

/* messages sent to modMessage() entry-point function */
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12      
#define MODM_CACHEDRUMPATCHES   13     

/* messages sent to midMessage() entry-point function */
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif  /*ifndef MMNOMIDIDEV */


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

/* maximum number of auxiliary device drivers loaded */
#define MAXAUXDRIVERS 10

/* messages sent to auxMessage() entry-point function */
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif  /*ifndef MMNOAUXDEV */


#ifndef MMNOTIMERDEV
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    UINT                wDelay;         /* delay required */
    UINT                wResolution;    /* resolution required */
    LPTIMECALLBACK      lpFunction;     /* ptr to callback function */
    DWORD               dwUser;         /* user DWORD */
    UINT                wFlags;         /* defines how to program event */
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

/* messages sent to tddMessage() function */
#define TDD_KILLTIMEREVENT  DRV_RESERVED+0  /* indices into a table of */
#define TDD_SETTIMEREVENT   DRV_RESERVED+4  /* functions; thus offset by */
#define TDD_GETSYSTEMTIME   DRV_RESERVED+8  /* four each time... */
#define TDD_GETDEVCAPS      DRV_RESERVED+12 /* room for future expansion */
#define TDD_BEGINMINPERIOD  DRV_RESERVED+16 /* room for future expansion */
#define TDD_ENDMINPERIOD    DRV_RESERVED+20 /* room for future expansion */

#endif  /*ifndef MMNOTIMERDEV */


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* joystick calibration info structure */
typedef struct joycalibrate_tag {
    UINT    wXbase;
    UINT    wXdelta;
    UINT    wYbase;
    UINT    wYdelta;
    UINT    wZbase;
    UINT    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

/* prototype for joystick message function */
typedef UINT (CALLBACK JOYDEVMSGPROC)(DWORD dwID, UINT uMessage, LPARAM lParam1, LPARAM lParam2);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

/* messages sent to joystick driver's DriverProc() function */
#define JDD_GETNUMDEVS      DRV_RESERVED+0x0001
#define JDD_GETDEVCAPS      DRV_RESERVED+0x0002
#define JDD_GETPOS          DRV_RESERVED+0x0101
#define JDD_SETCALIBRATION  DRV_RESERVED+0x0102

#endif  /*ifndef MMNOJOYDEV */


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/

/* internal MCI messages */
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

/* string return values only used with MAKEMCIRESOURCE */
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

/* resource string return values */
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

/* parameters for internal version of MCI_OPEN message sent from */
/* mciOpenDevice() to the driver */
typedef struct {
    UINT    wDeviceID;             /* device ID */
    LPCSTR  lpstrParams;           /* parameter string for entry in SYSTEM.INI */
    UINT    wCustomCommandTable;   /* custom command table (0xFFFF if none) */
                                   /* filled in by the driver */
    UINT    wType;                 /* driver type */
                                   /* filled in by the driver */
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

/* maximum length of an MCI device type */
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

/* flags for mciSendCommandInternal() which direct mciSendString() how to */
/* interpret the return value */
#define MCI_RESOURCE_RETURNED       0x00010000  /* resource ID */
#define MCI_COLONIZED3_RETURN       0x00020000  /* colonized ID, 3 bytes data */
#define MCI_COLONIZED4_RETURN       0x00040000  /* colonized ID, 4 bytes data */
#define MCI_INTEGER_RETURNED        0x00080000  /* integer conversion needed */
#define MCI_RESOURCE_DRIVER         0x00100000  /* driver owns returned resource */

/* invalid command table ID */
#define MCI_NO_COMMAND_TABLE    0xFFFF

/* command table information type tags */
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9

/* function prototypes for MCI driver functions */
DWORD WINAPI mciGetDriverData(UINT uDeviceID);
BOOL  WINAPI mciSetDriverData(UINT uDeviceID, DWORD dwData);
UINT  WINAPI mciDriverYield(UINT uDeviceID);
BOOL  WINAPI mciDriverNotify(HWND hwndCallback, UINT uDeviceID,
    UINT uStatus);
UINT  WINAPI mciLoadCommandResource(HINSTANCE hInstance,
    LPCSTR lpResName, UINT uType);
BOOL  WINAPI mciFreeCommandResource(UINT uTable);

#endif  /*ifndef MMNOMCIDEV */


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

/* error return values */
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

/* task support function prototypes */
#ifdef  BUILDDLL                                                /* ;Internal */
typedef void (FAR PASCAL TASKCALLBACK) (DWORD dwInst);          /* ;Internal */
#else   /*ifdef BUILDDLL*/                                      /* ;Internal */
typedef void (CALLBACK TASKCALLBACK) (DWORD dwInst);
#endif  /*ifdef BUILDDLL*/                                      /* ;Internal */

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    WINAPI mmTaskCreate(LPTASKCALLBACK lpfnTaskProc, HTASK FAR * lphTask, DWORD dwInst);
UINT    WINAPI mmTaskBlock(HTASK h);
BOOL    WINAPI mmTaskSignal(HTASK h);
void    WINAPI mmTaskYield(void);
HTASK   WINAPI mmGetCurrentTask(void);

#endif  /*ifndef MMNOTASKDEV */

#define MMDDKINC                /* ;Internal */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif  /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\mmsystem.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;         MMSYSTEM.INC - Multimedia assembly language structures & constants
;
;         Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;     If defined, the following flags inhibit inclusion
;     of the indicated items:
; 
;       MMNODRV          - Installable driver support
;       MMNOSOUND        - Sound support
;       MMNOWAVE         - Waveform support
;       MMNOMIDI         - MIDI support
;       MMNOAUX          - Auxiliary audio support
;       MMNOTIMER        - Timer support
;       MMNOJOY          - Joystick support
;       MMNOMCI          - MCI support
;       MMNOMMIO         - Multimedia file I/O support
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   General constants and data types
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; general constants
MAXPNAMELEN        equ    32     ; max product name length (including NULL)
MAXERRORLENGTH     equ    128    ; max error text length (including NULL)

; MMTIME data structure
MMTIME	struc
    mmt_wType           dw    ?  ; indicates the contents of the union
    mmt_TimeUnion       dd    ?  ; union
MMTIME	ends

SMPTE struc
    smpte_hour      db    ?  ; hours
    smpte_min       db    ?  ; minutes
    smpte_sec       db    ?  ; seconds
    smpte_frame     db    ?  ; frames
    smpte_fps       db    ?  ; frames per second
    smpte_reserved  db    ?  ; pad
SMPTE ends

; types for wType field in MMTIME struct
TIME_MS         equ    0001h   ; time in milliseconds
TIME_SAMPLES    equ    0002h   ; number of wave samples
TIME_BYTES      equ    0004h   ; current byte offset
TIME_SMPTE      equ    0008h   ; SMPTE time
TIME_MIDI       equ    0010h   ; MIDI time


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   Multimedia Extensions Window Messages
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MM_JOY1MOVE         equ    3A0h            ; joystick
MM_JOY2MOVE         equ    3A1h
MM_JOY1ZMOVE        equ    3A2h
MM_JOY2ZMOVE        equ    3A3h
MM_JOY1BUTTONDOWN   equ    3B5h
MM_JOY2BUTTONDOWN   equ    3B6h
MM_JOY1BUTTONUP     equ    3B7h
MM_JOY2BUTTONUP     equ    3B8h

MM_MCINOTIFY        equ    3B9h            ; MCI
MM_MCISYSTEM_STRING equ    3CAh

MM_WOM_OPEN         equ    3BBh            ; waveform output
MM_WOM_CLOSE        equ    3BCh
MM_WOM_DONE         equ    3BDh

MM_WIM_OPEN         equ    3BEh            ; waveform input
MM_WIM_CLOSE        equ    3BFh
MM_WIM_DATA         equ    3C0h

MM_MIM_OPEN         equ    3C1h            ; MIDI input
MM_MIM_CLOSE        equ    3C2h
MM_MIM_DATA         equ    3C3h
MM_MIM_LONGDATA     equ    3C4h
MM_MIM_ERROR        equ    3C5h
MM_MIM_LONGERROR    equ    3C6h

MM_MOM_OPEN         equ    3C7h            ; MIDI output
MM_MOM_CLOSE        equ    3C8h
MM_MOM_DONE         equ    3C9h


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;               String resource number bases (internal use)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MMSYSERR_BASE          equ    0
WAVERR_BASE            equ    32
MIDIERR_BASE           equ    64
TIMERR_BASE            equ    96
JOYERR_BASE            equ    160
MCIERR_BASE            equ    256

MCI_STRING_OFFSET      equ    512
MCI_VD_OFFSET          equ    1024
MCI_CD_OFFSET          equ    1088
MCI_WAVE_OFFSET        equ    1152
MCI_SEQ_OFFSET         equ    1216

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       General error return values
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; general error return values
MMSYSERR_NOERROR      equ    0                    ; no error
MMSYSERR_ERROR        equ    (MMSYSERR_BASE + 1)  ; unspecified error
MMSYSERR_BADDEVICEID  equ    (MMSYSERR_BASE + 2)  ; device ID out of range
MMSYSERR_NOTENABLED   equ    (MMSYSERR_BASE + 3)  ; driver failed enable
MMSYSERR_ALLOCATED    equ    (MMSYSERR_BASE + 4)  ; device already allocated
MMSYSERR_INVALHANDLE  equ    (MMSYSERR_BASE + 5)  ; device handle is invalid
MMSYSERR_NODRIVER     equ    (MMSYSERR_BASE + 6)  ; no device driver present
MMSYSERR_NOMEM        equ    (MMSYSERR_BASE + 7)  ; memory allocation error
MMSYSERR_NOTSUPPORTED equ    (MMSYSERR_BASE + 8)  ; function isn't supported
MMSYSERR_BADERRNUM    equ    (MMSYSERR_BASE + 9)  ; error value out of range
MMSYSERR_INVALFLAG    equ    (MMSYSERR_BASE + 10) ; invalid flags passed
MMSYSERR_INVALPARAM   equ    (MMSYSERR_BASE + 11) ; invalid parameter passed
MMSYSERR_LASTERROR    equ    (MMSYSERR_BASE + 11) ; last error in range


ifndef MMNODRV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Installable driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DRV_MCI_FIRST          equ    DRV_RESERVED
DRV_MCI_LAST           equ    (DRV_RESERVED + 0FFFh)

endif  ;ifndef MMNODRV


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                         Driver callback support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and
; midiOutOpen() to specify the type of the dwCallback parameter.
CALLBACK_TYPEMASK   equ    00070000h     ; callback type mask
CALLBACK_NULL       equ    00000000h     ; no callback
CALLBACK_WINDOW     equ    00010000h     ; dwCallback is a HWND
CALLBACK_TASK       equ    00020000h     ; dwCallback is a HTASK
CALLBACK_FUNCTION   equ    00030000h     ; dwCallback is a FARPROC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                        Manufacturer and product IDs
;        
;   Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS, 
;   MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; manufacturer IDs
MM_MICROSOFT            equ    1       ; Microsoft Corp.

; product IDs
MM_MIDI_MAPPER          equ    1       ; MIDI Mapper
MM_WAVE_MAPPER          equ    2       ; Wave Mapper

MM_SNDBLST_MIDIOUT      equ    3       ; Sound Blaster MIDI output port
MM_SNDBLST_MIDIIN       equ    4       ; Sound Blaster MIDI input port
MM_SNDBLST_SYNTH        equ    5       ; Sound Blaster internal synthesizer
MM_SNDBLST_WAVEOUT      equ    6       ; Sound Blaster waveform output
MM_SNDBLST_WAVEIN       equ    7       ; Sound Blaster waveform input

MM_ADLIB                equ    9       ; Ad Lib-compatible synthesizer

MM_MPU401_MIDIOUT       equ    10      ; MPU401-compatible MIDI output port
MM_MPU401_MIDIIN        equ    11      ; MPU401-compatible MIDI input port

MM_PC_JOYSTICK          equ    12      ; Joystick adapter


ifndef MMNOSOUND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Sound support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; flag values for wFlags parameter
SND_SYNC            equ    0000h   ; play synchronously (default)
SND_ASYNC           equ    0001h   ; play asynchronously
SND_NODEFAULT       equ    0002h   ; don't use default sound
SND_MEMORY          equ    0004h   ; lpszSoundName points to a memory file
SND_LOOP            equ    0008h   ; loop the sound until next sndPlaySound
SND_NOSTOP          equ    0010h   ; don't stop any currently playing sound
SND_VALID           equ    001Fh   ;Internal

endif  ;ifndef MMNOSOUND


ifndef MMNOWAVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Waveform audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; waveform audio error return values
WAVERR_BADFORMAT      equ    (WAVERR_BASE + 0)    ; unsupported wave format
WAVERR_STILLPLAYING   equ    (WAVERR_BASE + 1)    ; still something playing
WAVERR_UNPREPARED     equ    (WAVERR_BASE + 2)    ; header not prepared
WAVERR_SYNC           equ    (WAVERR_BASE + 3)    ; device is synchronous
WAVERR_LASTERROR      equ    (WAVERR_BASE + 3)    ; last error in range

; wave callback messages
WOM_OPEN        equ    MM_WOM_OPEN
WOM_CLOSE       equ    MM_WOM_CLOSE
WOM_DONE        equ    MM_WOM_DONE
WIM_OPEN        equ    MM_WIM_OPEN
WIM_CLOSE       equ    MM_WIM_CLOSE
WIM_DATA        equ    MM_WIM_DATA

; device ID for wave device mapper
WAVE_MAPPER     equ    (-1)

; flags for dwFlags parameter in waveOutOpen() and waveInOpen()
WAVE_FORMAT_QUERY     equ    0001h
WAVE_ALLOWSYNC        equ    0002h
WAVE_VALID            equ    0003h      ;Internal

; wave data block header
WAVEHDR struc
    lpWaveData               dd    ?     ; pointer to locked data buffer
    dwWaveBufferLength       dd    ?     ; length of data buffer
    dwWaveBytesRecorded      dd    ?     ; used for input only
    dwWaveUser               dd    ?     ; for client's use
    dwWaveFlags              dd    ?     ; assorted flags (see defines)
    dwWaveLoops              dd    ?     ; loop control counter
    lpWaveNext               dd    ?     ; reserved for driver
    Wavereserved             dd    ?     ; reserved for driver
WAVEHDR ends

; flags for dwFlags field of WAVEHDR
WHDR_DONE       equ    00000001h   ; done bit
WHDR_PREPARED   equ    00000002h   ; set if this header has been prepared
WHDR_BEGINLOOP  equ    00000004h   ; loop start block
WHDR_ENDLOOP    equ    00000008h   ; loop end block
WHDR_INQUEUE    equ    00000010h   ; reserved for driver
WHDR_VALID      equ    0000001Fh   ;Internal

; waveform output device capabilities structure
WAVEOUTCAPS struc
    woc_wMid            dw      ?      ; manufacturer ID
    woc_wPid            dw      ?      ; product ID
    woc_vDriverVersion  dw      ?      ; version of the driver
    woc_szPname         db MAXPNAMELEN dup (?)  ; product name (NULL terminated string)
    woc_dwFormats       dd      ?      ; formats supported
    woc_wChannels       dw      ?      ; number of sources supported
    woc_dwSupport       dd      ?      ; functionality supported by driver
WAVEOUTCAPS ends

; flags for dwSupport field of WAVEOUTCAPS
WAVECAPS_PITCH          equ    0001h    ; supports pitch control
WAVECAPS_PLAYBACKRATE   equ    0002h    ; supports playback rate control
WAVECAPS_VOLUME         equ    0004h    ; supports volume control
WAVECAPS_LRVOLUME       equ    0008h    ; separate left-right volume control
WAVECAPS_SYNC           equ    0010h

; waveform input device capabilities structure
WAVEINCAPS struc
    wic_wMid            dw      ?      ; manufacturer ID
    wic_wPid            dw      ?      ; product ID
    wic_vDriverVersion  dw      ?      ; version of the driver
    wic_szPname         db MAXPNAMELEN dup (?)  ; product name (NULL terminated string)
    wic_dwFormats       dd      ?      ; formats supported
    wic_wChannels       dw      ?      ; number of channels supported
WAVEINCAPS ends

; defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
WAVE_INVALIDFORMAT     equ    00000000h        ; invalid format
WAVE_FORMAT_1M08       equ    00000001h        ; 11.025 kHz, Mono,   8-bit
WAVE_FORMAT_1S08       equ    00000002h        ; 11.025 kHz, Stereo, 8-bit
WAVE_FORMAT_1M16       equ    00000004h        ; 11.025 kHz, Mono,   16-bit
WAVE_FORMAT_1S16       equ    00000008h        ; 11.025 kHz, Stereo, 16-bit
WAVE_FORMAT_2M08       equ    00000010h        ; 22.05  kHz, Mono,   8-bit
WAVE_FORMAT_2S08       equ    00000020h        ; 22.05  kHz, Stereo, 8-bit
WAVE_FORMAT_2M16       equ    00000040h        ; 22.05  kHz, Mono,   16-bit
WAVE_FORMAT_2S16       equ    00000080h        ; 22.05  kHz, Stereo, 16-bit
WAVE_FORMAT_4M08       equ    00000100h        ; 44.1   kHz, Mono,   8-bit
WAVE_FORMAT_4S08       equ    00000200h        ; 44.1   kHz, Stereo, 8-bit
WAVE_FORMAT_4M16       equ    00000400h        ; 44.1   kHz, Mono,   16-bit
WAVE_FORMAT_4S16       equ    00000800h        ; 44.1   kHz, Stereo, 16-bit

; general waveform format structure (information common to all formats)
WAVEFORMAT struc
    wfmt_wFormatTag       dw    ?   ; format type
    wfmt_nChannels        dw    ?   ; number of channels (i.e. mono, stereo, etc.)
    wfmt_nSamplesPerSec   dd    ?   ; sample rate
    wfmt_nAvgBytesPerSec  dd    ?   ; for buffer estimation
    wfmt_nBlockAlign      dw    ?   ; block size of data
WAVEFORMAT ends

; flags for wFormatTag field of WAVEFORMAT
WAVE_FORMAT_PCM     equ    1

; specific waveform format structure for PCM data
PCMWAVEFORMAT struc
    pcm_wf               db (SIZE WAVEFORMAT) dup (?)
    pcm_wBitsPerSample   dw    ?
PCMWAVEFORMAT ends

endif  ;ifndef MMNOWAVE


ifndef MMNOMIDI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MIDI audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MIDI error return values
MIDIERR_UNPREPARED    equ    (MIDIERR_BASE + 0)   ; header not prepared
MIDIERR_STILLPLAYING  equ    (MIDIERR_BASE + 1)   ; still something playing
MIDIERR_NOMAP         equ    (MIDIERR_BASE + 2)   ; no current map
MIDIERR_NOTREADY      equ    (MIDIERR_BASE + 3)   ; hardware is still busy
MIDIERR_NODEVICE      equ    (MIDIERR_BASE + 4)   ; port no longer connected
MIDIERR_INVALIDSETUP  equ    (MIDIERR_BASE + 5)   ; invalid setup
MIDIERR_LASTERROR     equ    (MIDIERR_BASE + 5)   ; last error in range

; MIDI audio data types
MIDIPATCHSIZE   equ    128

; MIDI callback messages
MIM_OPEN        equ    MM_MIM_OPEN
MIM_CLOSE       equ    MM_MIM_CLOSE
MIM_DATA        equ    MM_MIM_DATA
MIM_LONGDATA    equ    MM_MIM_LONGDATA
MIM_ERROR       equ    MM_MIM_ERROR
MIM_LONGERROR   equ    MM_MIM_LONGERROR
MOM_OPEN        equ    MM_MOM_OPEN
MOM_CLOSE       equ    MM_MOM_CLOSE
MOM_DONE        equ    MM_MOM_DONE

; device ID for MIDI mapper
MIDIMAPPER     equ    (-1)
MIDI_MAPPER    equ    (-1)

; flags for wFlags parm of midiOutCachePatches(),       
; midiOutCacheDrumPatches()                             
MIDI_CACHE_ALL      equ    1                            
MIDI_CACHE_BESTFIT  equ    2                            
MIDI_CACHE_QUERY    equ    3                            
MIDI_UNCACHE        equ    4                            

; MIDI output device capabilities structure
MIDIOUTCAPS struc
    moc_wMid            dw    ?        ; manufacturer ID
    moc_wPid            dw    ?        ; product ID
    moc_vDriverVersion  dw    ?        ; version of the driver
    moc_szPname         db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    moc_wTechnology     dw    ?        ; type of device
    moc_wVoices         dw    ?        ; # of voices (internal synth only)
    moc_wNotes          dw    ?        ; max # of notes (internal synth only)
    moc_wChannelMask    dw    ?        ; channels used (internal synth only)
    moc_dwSupport       dd    ?        ; functionality supported by driver
MIDIOUTCAPS ends

; flags for wTechnology field of MIDIOUTCAPS structure
MOD_MIDIPORT    equ    1  ; output port
MOD_SYNTH       equ    2  ; generic internal synth
MOD_SQSYNTH     equ    3  ; square wave internal synth
MOD_FMSYNTH     equ    4  ; FM internal synth
MOD_MAPPER      equ    5  ; MIDI mapper

; flags for dwSupport field of MIDIOUTCAPS structure
MIDICAPS_VOLUME          equ    0001h   ; supports volume control
MIDICAPS_LRVOLUME        equ    0002h   ; separate left-right volume control
MIDICAPS_CACHE           equ    0004h  

; MIDI output device capabilities structure
MIDIINCAPS struc
    mic_wMid            dw    ?       ; manufacturer ID
    mic_wPid            dw    ?       ; product ID
    mic_vDriverVersion  dw    ?       ; version of the driver
    mic_szPname         db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
MIDIINCAPS ends

; MIDI data block header
MIDIHDR struc
    lpMidiData            dd    ?      ; pointer to locked data block
    dwMidiBufferLength    dd    ?      ; length of data in data block
    dwMidiBytesRecorded   dd    ?      ; used for input only
    dwMidiUser            dd    ?      ; for client's use
    dwMidiFlags           dd    ?      ; assorted flags (see defines)
    lpMidiNext            dd    ?      ; reserved for driver
    Midireserved          dd    ?      ; reserved for driver
MIDIHDR ends

; flags for dwFlags field of MIDIHDR structure
MHDR_DONE       equ    00000001h        ; done bit
MHDR_PREPARED   equ    00000002h        ; set if header prepared
MHDR_INQUEUE    equ    00000004h        ; reserved for driver
MHDR_VALID      equ    00000007h        ;Internal

endif  ;ifndef MMNOMIDI


ifndef MMNOAUX
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Auxiliary audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; device ID for aux device mapper
AUX_MAPPER     equ    (-1)

; Auxiliary audio device capabilities structure
AUXCAPS struc
    acaps_wMid              dw    ?      ; manufacturer ID
    acaps_wPid              dw    ?      ; product ID
    acaps_vDriverVersion    dw    ?      ; version of the driver
    acaps_szPname           db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    acaps_wTechnology       dw    ?      ; type of device
    acaps_dwSupport         dd    ?      ; functionality supported by driver
AUXCAPS ends

; flags for wTechnology field in AUXCAPS structure
AUXCAPS_CDAUDIO    equ    1       ; audio from internal CD-ROM drive
AUXCAPS_AUXIN      equ    2       ; audio from auxiliary input jacks

; flags for dwSupport field in AUXCAPS structure
AUXCAPS_VOLUME          equ    0001h   ; supports volume control
AUXCAPS_LRVOLUME        equ    0002h   ; separate left-right volume control

endif  ;ifndef MMNOAUX


ifndef MMNOTIMER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Timer support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; timer error return values
TIMERR_NOERROR        equ    (0)                  ; no error
TIMERR_NOCANDO        equ    (TIMERR_BASE+1)      ; request not completed
TIMERR_STRUCT         equ    (TIMERR_BASE+33)     ; time struct size

; flags for wFlags parameter of timeSetEvent() function
TIME_ONESHOT    equ    0   ; program timer for single event
TIME_PERIODIC   equ    1   ; program for continuous periodic event

; timer device capabilities data structure
TIMECAPS struc
    tc_wPeriodMin    dw    ?     ; minimum period supported
    tc_wPeriodMax    dw    ?     ; maximum period supported
TIMECAPS ends

endif  ;ifndef MMNOTIMER


ifndef MMNOJOY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Joystick support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; joystick error return values
JOYERR_NOERROR        equ    (0)                  ; no error
JOYERR_PARMS          equ    (JOYERR_BASE+5)      ; bad parameters
JOYERR_NOCANDO        equ    (JOYERR_BASE+6)      ; request not completed
JOYERR_UNPLUGGED      equ    (JOYERR_BASE+7)      ; joystick is unplugged

; constants used with JOYINFO structure and MM_JOY* messages
JOY_BUTTON1         equ    0001h
JOY_BUTTON2         equ    0002h
JOY_BUTTON3         equ    0004h
JOY_BUTTON4         equ    0008h
JOY_BUTTON1CHG      equ    0100h
JOY_BUTTON2CHG      equ    0200h
JOY_BUTTON3CHG      equ    0400h
JOY_BUTTON4CHG      equ    0800h

; joystick ID constants
JOYSTICKID1         equ    0
JOYSTICKID2         equ    1

; joystick device capabilities data structure
JOYCAPS struc
    jcaps_wMid         dw    ?    ; manufacturer ID
    jcaps_wPid         dw    ?    ; product ID
    jcaps_szPname      db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    jcaps_wXmin        dw    ?    ; minimum x position value
    jcaps_wXmax        dw    ?    ; maximum x position value
    jcaps_wYmin        dw    ?    ; minimum y position value
    jcaps_wYmax        dw    ?    ; maximum y position value
    jcaps_wZmin        dw    ?    ; minimum z position value
    jcaps_wZmax        dw    ?    ; maximum z position value
    jcaps_wNumButtons  dw    ?    ; number of buttons
    jcaps_wPeriodMin   dw    ?    ; minimum message period when captured
    jcaps_wPeriodMax   dw    ?    ; maximum message period when captured
JOYCAPS ends

; joystick information data structure
JOYINFO struc
    jinfo_wXpos        dw    ?  ; x position
    jinfo_wYpos        dw    ?  ; y position
    jinfo_wZpos        dw    ?  ; z position
    jinfo_wButtons     dw    ?  ; button states
JOYINFO ends

endif  ;ifndef MMNOJOY

ifndef MMNOMMIO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Multimedia File I/O support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MMIO error return values
MMIOERR_BASE            equ    256
MMIOERR_FILENOTFOUND    equ    (MMIOERR_BASE + 1)  ; file not found
MMIOERR_OUTOFMEMORY     equ    (MMIOERR_BASE + 2)  ; out of memory
MMIOERR_CANNOTOPEN      equ    (MMIOERR_BASE + 3)  ; cannot open
MMIOERR_CANNOTCLOSE     equ    (MMIOERR_BASE + 4)  ; cannot close
MMIOERR_CANNOTREAD      equ    (MMIOERR_BASE + 5)  ; cannot read
MMIOERR_CANNOTWRITE     equ    (MMIOERR_BASE + 6)  ; cannot write
MMIOERR_CANNOTSEEK      equ    (MMIOERR_BASE + 7)  ; cannot seek
MMIOERR_CANNOTEXPAND    equ    (MMIOERR_BASE + 8)  ; cannot expand file
MMIOERR_CHUNKNOTFOUND   equ    (MMIOERR_BASE + 9)  ; chunk not found
MMIOERR_UNBUFFERED      equ    (MMIOERR_BASE + 10) ; file is unbuffered

; MMIO constants
CFSEPCHAR    equ   '+'             ; compound file name separator char.

; general MMIO information data structure
MMIOINFO struc
        ; general fields
    mmio_dwFlags        dd    ?      ; general status flags
    mmio_fccIOProc      dd    ?      ; pointer to I/O procedure
    mmio_pIOProc        dd    ?      ; pointer to I/O procedure
    mmio_wErrorRet      dw    ?      ; place for error to be returned
    mmio_htask          dw    ?      ; alternate local task

        ; fields maintained by MMIO functions during buffered I/O
    mmio_cchBuffer      dd    ?      ; size of I/O buffer (or 0L)
    mmio_pchBuffer      dd    ?      ; start of I/O buffer (or NULL)
    mmio_pchNext        dd    ?      ; pointer to next byte to read/write
    mmio_pchEndRead     dd    ?      ; pointer to last valid byte to read
    mmio_pchEndWrite    dd    ?      ; pointer to last byte to write
    mmio_lBufOffset     dd    ?      ; disk offset of start of buffer

        ; fields maintained by I/O procedure
    mmio_lDiskOffset    dd    ?      ; disk offset of next read or write
    mmio_adwInfo        dd 3 dup (?) ; data specific to type of MMIOPROC

        ; other fields maintained by MMIO
    mmio_dwReserved1    dd    ?      ; reserved for MMIO use
    mmio_dwReserved2    dd    ?      ; reserved for MMIO use
    mmio_hmmio          dw    ?      ; handle to open file
MMIOINFO ends

; RIFF chunk information data structure
MMCKINFO struc
    mmck_ckid          dd    ?  ; chunk ID
    mmck_cksize        dd    ?  ; chunk size
    mmck_fccType       dd    ?  ; form type or list type
    mmck_dwDataOffset  dd    ?  ; offset of data portion of chunk
    mmck_dwFlags       dd    ?  ; flags used by MMIO functions
MMCKINFO ends

; bit field masks
MMIO_RWMODE     equ    00000003h       ; open file for reading/writing/both
MMIO_SHAREMODE  equ    00000070h       ; file sharing mode number

; constants for dwFlags field of MMIOINFO
MMIO_CREATE     equ    00001000h       ; create new file (or truncate file)
MMIO_PARSE      equ    00000100h       ; parse new file returning path
MMIO_DELETE     equ    00000200h       ; create new file (or truncate file)
MMIO_EXIST      equ    00004000h       ; checks for existence of file
MMIO_ALLOCBUF   equ    00010000h       ; mmioOpen() should allocate a buffer
MMIO_GETTEMP    equ    00020000h       ; mmioOpen() should retrieve temp name

MMIO_DIRTY      equ    10000000h       ; I/O buffer is dirty

MMIO_OPEN_VALID equ    0003FFFFh       ;Internal

; read/write mode numbers (bit field MMIO_RWMODE)
MMIO_READ       equ    00000000h       ; open file for reading only
MMIO_WRITE      equ    00000001h       ; open file for writing only
MMIO_READWRITE  equ    00000002h       ; open file for reading and writing

; share mode numbers (bit field MMIO_SHAREMODE)
MMIO_COMPAT     equ    00000000h       ; compatibility mode
MMIO_EXCLUSIVE  equ    00000010h       ; exclusive-access mode
MMIO_DENYWRITE  equ    00000020h       ; deny writing to other processes
MMIO_DENYREAD   equ    00000030h       ; deny reading to other processes
MMIO_DENYNONE   equ    00000040h       ; deny nothing to other processes

; various MMIO flags
MMIO_FHOPEN             equ    0010h   ; mmioClose: keep file handle open
MMIO_EMPTYBUF           equ    0010h   ; mmioFlush: empty the I/O buffer
MMIO_TOUPPER            equ    0010h   ; mmioStringToFOURCC: to u-case
MMIO_INSTALLPROC    equ    00010000h   ; mmioInstallIOProc: install MMIOProc
MMIO_GLOBALPROC     equ    10000000h   ; mmioInstallIOProc: install globally
MMIO_REMOVEPROC     equ    00020000h   ; mmioInstallIOProc: remove MMIOProc
MMIO_FINDPROC       equ    00040000h   ; mmioInstallIOProc: find an MMIOProc
MMIO_FINDCHUNK          equ    0010h   ; mmioDescend: find a chunk by ID
MMIO_FINDRIFF           equ    0020h   ; mmioDescend: find a LIST chunk
MMIO_FINDLIST           equ    0040h   ; mmioDescend: find a RIFF chunk
MMIO_CREATERIFF         equ    0020h   ; mmioCreateChunk: make a LIST chunk
MMIO_CREATELIST         equ    0040h   ; mmioCreateChunk: make a RIFF chunk

MMIO_VALIDPROC          equ    10070000h  ;Internal

; message numbers for MMIOPROC I/O procedure functions
MMIOM_READ      equ    MMIO_READ       ; read
MMIOM_WRITE    equ    MMIO_WRITE       ; write
MMIOM_SEEK              equ    2       ; seek to a new position in file
MMIOM_OPEN              equ    3       ; open file
MMIOM_CLOSE             equ    4       ; close file
MMIOM_WRITEFLUSH        equ    5       ; write and flush
MMIOM_RENAME            equ    6       ; rename specified file
MMIOM_USER         equ    8000h        ; beginning of user-defined messages

mmioFOURCC MACRO ch0,ch1,ch2,ch3
        mov     al,ch0
        mov     ah,ch1
        mov     dl,ch2
        mov     dh,ch3
        ENDM

; standard four character codes
FOURCC_RIFF     equ    mmioFOURCC('R', 'I', 'F', 'F')
FOURCC_LIST     equ    mmioFOURCC('L', 'I', 'S', 'T')

; four character codes used to identify standard built-in I/O procedures
FOURCC_DOS      equ    mmioFOURCC('D', 'O', 'S', ' ')
FOURCC_MEM      equ    mmioFOURCC('M', 'E', 'M', ' ')

; flags for mmioSeek()
ifndef SEEK_SET
SEEK_SET        equ    0               ; seek to an absolute position
SEEK_CUR        equ    1               ; seek relative to current position
SEEK_END        equ    2               ; seek relative to end of file
endif  ;ifndef SEEK_SET

; other constants
MMIO_DEFAULTBUFFER      equ    8192    ; default buffer size

endif	;ifndef MMNOMMIO

ifndef MMNOMCI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MCI support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MCI error return values
MCIERR_INVALID_DEVICE_ID        equ    (MCIERR_BASE + 1)
MCIERR_UNRECOGNIZED_KEYWORD     equ    (MCIERR_BASE + 3)
MCIERR_UNRECOGNIZED_COMMAND     equ    (MCIERR_BASE + 5)
MCIERR_HARDWARE                 equ    (MCIERR_BASE + 6)
MCIERR_INVALID_DEVICE_NAME      equ    (MCIERR_BASE + 7)
MCIERR_OUT_OF_MEMORY            equ    (MCIERR_BASE + 8)
MCIERR_DEVICE_OPEN              equ    (MCIERR_BASE + 9)
MCIERR_CANNOT_LOAD_DRIVER       equ    (MCIERR_BASE + 10)
MCIERR_MISSING_COMMAND_STRING   equ    (MCIERR_BASE + 11)
MCIERR_PARAM_OVERFLOW           equ    (MCIERR_BASE + 12)
MCIERR_MISSING_STRING_ARGUMENT  equ    (MCIERR_BASE + 13)
MCIERR_BAD_INTEGER              equ    (MCIERR_BASE + 14)
MCIERR_PARSER_INTERNAL          equ    (MCIERR_BASE + 15)
MCIERR_DRIVER_INTERNAL          equ    (MCIERR_BASE + 16)
MCIERR_MISSING_PARAMETER        equ    (MCIERR_BASE + 17)
MCIERR_UNSUPPORTED_FUNCTION     equ    (MCIERR_BASE + 18)
MCIERR_FILE_NOT_FOUND           equ    (MCIERR_BASE + 19)
MCIERR_DEVICE_NOT_READY         equ    (MCIERR_BASE + 20)
MCIERR_INTERNAL                 equ    (MCIERR_BASE + 21)
MCIERR_DRIVER                   equ    (MCIERR_BASE + 22)
MCIERR_CANNOT_USE_ALL           equ    (MCIERR_BASE + 23)
MCIERR_MULTIPLE                 equ    (MCIERR_BASE + 24)
MCIERR_EXTENSION_NOT_FOUND      equ    (MCIERR_BASE + 25)
MCIERR_OUTOFRANGE               equ    (MCIERR_BASE + 26)
MCIERR_FLAGS_NOT_COMPATIBLE     equ    (MCIERR_BASE + 28)
MCIERR_FILE_NOT_SAVED           equ    (MCIERR_BASE + 30)
MCIERR_DEVICE_TYPE_REQUIRED     equ    (MCIERR_BASE + 31)
MCIERR_DEVICE_LOCKED            equ    (MCIERR_BASE + 32)
MCIERR_DUPLICATE_ALIAS          equ    (MCIERR_BASE + 33)
MCIERR_BAD_CONSTANT             equ    (MCIERR_BASE + 34)
MCIERR_MUST_USE_SHAREABLE       equ    (MCIERR_BASE + 35)
MCIERR_MISSING_DEVICE_NAME      equ    (MCIERR_BASE + 36)
MCIERR_BAD_TIME_FORMAT          equ    (MCIERR_BASE + 37)
MCIERR_NO_CLOSING_QUOTE         equ    (MCIERR_BASE + 38)
MCIERR_DUPLICATE_FLAGS          equ    (MCIERR_BASE + 39)
MCIERR_INVALID_FILE             equ    (MCIERR_BASE + 40)
MCIERR_NULL_PARAMETER_BLOCK     equ    (MCIERR_BASE + 41)
MCIERR_UNNAMED_RESOURCE         equ    (MCIERR_BASE + 42)
MCIERR_NEW_REQUIRES_ALIAS       equ    (MCIERR_BASE + 43)
MCIERR_NOTIFY_ON_AUTO_OPEN      equ    (MCIERR_BASE + 44)
MCIERR_NO_ELEMENT_ALLOWED       equ    (MCIERR_BASE + 45)
MCIERR_NONAPPLICABLE_FUNCTION   equ    (MCIERR_BASE + 46)
MCIERR_ILLEGAL_FOR_AUTO_OPEN    equ    (MCIERR_BASE + 47)
MCIERR_FILENAME_REQUIRED        equ    (MCIERR_BASE + 48)
MCIERR_EXTRA_CHARACTERS         equ    (MCIERR_BASE + 49)
MCIERR_DEVICE_NOT_INSTALLED     equ    (MCIERR_BASE + 50)
MCIERR_GET_CD                   equ    (MCIERR_BASE + 51)
MCIERR_SET_CD                   equ    (MCIERR_BASE + 52)
MCIERR_SET_DRIVE                equ    (MCIERR_BASE + 53)
MCIERR_DEVICE_LENGTH            equ    (MCIERR_BASE + 54)
MCIERR_DEVICE_ORD_LENGTH        equ    (MCIERR_BASE + 55)
MCIERR_NO_INTEGER               equ    (MCIERR_BASE + 56)

MCIERR_WAVE_OUTPUTSINUSE        equ    (MCIERR_BASE + 64)
MCIERR_WAVE_SETOUTPUTINUSE      equ    (MCIERR_BASE + 65)
MCIERR_WAVE_INPUTSINUSE         equ    (MCIERR_BASE + 66)
MCIERR_WAVE_SETINPUTINUSE       equ    (MCIERR_BASE + 67)
MCIERR_WAVE_OUTPUTUNSPECIFIED   equ    (MCIERR_BASE + 68)
MCIERR_WAVE_INPUTUNSPECIFIED    equ    (MCIERR_BASE + 69)
MCIERR_WAVE_OUTPUTSUNSUITABLE   equ    (MCIERR_BASE + 70)
MCIERR_WAVE_SETOUTPUTUNSUITABLE equ    (MCIERR_BASE + 71)
MCIERR_WAVE_INPUTSUNSUITABLE    equ    (MCIERR_BASE + 72)
MCIERR_WAVE_SETINPUTUNSUITABLE  equ    (MCIERR_BASE + 73)

MCIERR_SEQ_DIV_INCOMPATIBLE     equ    (MCIERR_BASE + 80)
MCIERR_SEQ_PORT_INUSE           equ    (MCIERR_BASE + 81)
MCIERR_SEQ_PORT_NONEXISTENT     equ    (MCIERR_BASE + 82)
MCIERR_SEQ_PORT_MAPNODEVICE     equ    (MCIERR_BASE + 83)
MCIERR_SEQ_PORT_MISCERROR       equ    (MCIERR_BASE + 84)
MCIERR_SEQ_TIMER                equ    (MCIERR_BASE + 85)
MCIERR_SEQ_PORTUNSPECIFIED      equ    (MCIERR_BASE + 86)
MCIERR_SEQ_NOMIDIPRESENT        equ    (MCIERR_BASE + 87)

MCIERR_NO_WINDOW                equ    (MCIERR_BASE + 90)
MCIERR_CREATEWINDOW             equ    (MCIERR_BASE + 91)
MCIERR_FILE_READ                equ    (MCIERR_BASE + 92)
MCIERR_FILE_WRITE               equ    (MCIERR_BASE + 93)

; all custom device driver errors must be >= than this value
MCIERR_CUSTOM_DRIVER_BASE       equ    (MCIERR_BASE + 256)

; MCI command message identifiers
MCI_OPEN                        equ    0803h
MCI_CLOSE                       equ    0804h
MCI_ESCAPE                      equ    0805h
MCI_PLAY                        equ    0806h
MCI_SEEK                        equ    0807h
MCI_STOP                        equ    0808h
MCI_PAUSE                       equ    0809h
MCI_INFO                        equ    080Ah
MCI_GETDEVCAPS                  equ    080Bh
MCI_SPIN                        equ    080Ch
MCI_SET                         equ    080Dh
MCI_STEP                        equ    080Eh
MCI_RECORD                      equ    080Fh
MCI_SYSINFO                     equ    0810h
MCI_BREAK                       equ    0811h
MCI_SOUND                       equ    0812h
MCI_SAVE                        equ    0813h
MCI_STATUS                      equ    0814h
MCI_CUE                         equ    0830h
MCI_REALIZE                     equ    0840h
MCI_WINDOW                      equ    0841h
MCI_PUT                         equ    0842h
MCI_WHERE                       equ    0843h
MCI_FREEZE                      equ    0844h
MCI_UNFREEZE                    equ    0845h
MCI_LOAD                        equ    0850h
MCI_CUT                         equ    0851h
MCI_COPY                        equ    0852h
MCI_PASTE                       equ    0853h
MCI_UPDATE                      equ    0854h
MCI_RESUME                      equ    0855h
MCI_DELETE                      equ    0856h

; all custom MCI command messages must be >= than this value
MCI_USER_MESSAGES               equ    (400h + DRV_MCI_FIRST)


; device ID for "all devices"
MCI_ALL_DEVICE_ID               equ    0FFFFh

; constants for predefined MCI device types
MCI_DEVTYPE_VCR                 equ    (MCI_STRING_OFFSET + 1)
MCI_DEVTYPE_VIDEODISC           equ    (MCI_STRING_OFFSET + 2)
MCI_DEVTYPE_OVERLAY             equ    (MCI_STRING_OFFSET + 3)
MCI_DEVTYPE_CD_AUDIO            equ    (MCI_STRING_OFFSET + 4)
MCI_DEVTYPE_DAT                 equ    (MCI_STRING_OFFSET + 5)
MCI_DEVTYPE_SCANNER             equ    (MCI_STRING_OFFSET + 6)
MCI_DEVTYPE_ANIMATION           equ    (MCI_STRING_OFFSET + 7)
MCI_DEVTYPE_DIGITAL_VIDEO       equ    (MCI_STRING_OFFSET + 8)
MCI_DEVTYPE_OTHER               equ    (MCI_STRING_OFFSET + 9)
MCI_DEVTYPE_WAVEFORM_AUDIO      equ    (MCI_STRING_OFFSET + 10)
MCI_DEVTYPE_SEQUENCER           equ    (MCI_STRING_OFFSET + 11)

MCI_DEVTYPE_FIRST               equ    MCI_DEVTYPE_VCR
MCI_DEVTYPE_LAST                equ    MCI_DEVTYPE_SEQUENCER

; return values for 'status mode' command
MCI_MODE_NOT_READY              equ    (MCI_STRING_OFFSET + 12)
MCI_MODE_STOP                   equ    (MCI_STRING_OFFSET + 13)
MCI_MODE_PLAY                   equ    (MCI_STRING_OFFSET + 14)
MCI_MODE_RECORD                 equ    (MCI_STRING_OFFSET + 15)
MCI_MODE_SEEK                   equ    (MCI_STRING_OFFSET + 16)
MCI_MODE_PAUSE                  equ    (MCI_STRING_OFFSET + 17)
MCI_MODE_OPEN                   equ    (MCI_STRING_OFFSET + 18)

; constants used in 'set time format' and 'status time format' commands
MCI_FORMAT_MILLISECONDS         equ    0
MCI_FORMAT_HMS                  equ    1
MCI_FORMAT_MSF                  equ    2
MCI_FORMAT_FRAMES               equ    3
MCI_FORMAT_SMPTE_24             equ    4
MCI_FORMAT_SMPTE_25             equ    5
MCI_FORMAT_SMPTE_30             equ    6
MCI_FORMAT_SMPTE_30DROP         equ    7
MCI_FORMAT_BYTES                equ    8
MCI_FORMAT_SAMPLES              equ    9
MCI_FORMAT_TMSF                 equ    10

; flags for wParam of MM_MCINOTIFY message
MCI_NOTIFY_SUCCESSFUL           equ    0001h
MCI_NOTIFY_SUPERSEDED           equ    0002h
MCI_NOTIFY_ABORTED              equ    0004h
MCI_NOTIFY_FAILURE              equ    0008h


; common flags for dwFlags parameter of MCI command messages
MCI_NOTIFY                      equ    00000001h
MCI_WAIT                        equ    00000002h
MCI_FROM                        equ    00000004h
MCI_TO                          equ    00000008h
MCI_TRACK                       equ    00000010h

; flags for dwFlags parameter of MCI_OPEN command message
MCI_OPEN_SHAREABLE              equ    00000100h
MCI_OPEN_ELEMENT                equ    00000200h
MCI_OPEN_ALIAS                  equ    00000400h
MCI_OPEN_ELEMENT_ID             equ    00000800h
MCI_OPEN_TYPE_ID                equ    00001000h
MCI_OPEN_TYPE                   equ    00002000h

; flags for dwFlags parameter of MCI_SEEK command message
MCI_SEEK_TO_START               equ    00000100h
MCI_SEEK_TO_END                 equ    00000200h

; flags for dwFlags parameter of MCI_STATUS command message
MCI_STATUS_ITEM                 equ    00000100h
MCI_STATUS_START                equ    00000200h

; flags for dwItem field of the MCI_STATUS_PARMS parameter block
MCI_STATUS_LENGTH               equ    00000001h
MCI_STATUS_POSITION             equ    00000002h
MCI_STATUS_NUMBER_OF_TRACKS     equ    00000003h
MCI_STATUS_MODE                 equ    00000004h
MCI_STATUS_MEDIA_PRESENT        equ    00000005h
MCI_STATUS_TIME_FORMAT          equ    00000006h
MCI_STATUS_READY                equ    00000007h
MCI_STATUS_CURRENT_TRACK        equ    00000008h

; flags for dwFlags parameter of MCI_INFO command message
MCI_INFO_PRODUCT                equ    00000100h
MCI_INFO_FILE                   equ    00000200h

; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_ITEM             equ    00000100h

; flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
MCI_GETDEVCAPS_CAN_RECORD       equ    00000001h
MCI_GETDEVCAPS_HAS_AUDIO        equ    00000002h
MCI_GETDEVCAPS_HAS_VIDEO        equ    00000003h
MCI_GETDEVCAPS_DEVICE_TYPE      equ    00000004h
MCI_GETDEVCAPS_USES_FILES       equ    00000005h
MCI_GETDEVCAPS_COMPOUND_DEVICE  equ    00000006h
MCI_GETDEVCAPS_CAN_EJECT        equ    00000007h
MCI_GETDEVCAPS_CAN_PLAY         equ    00000008h
MCI_GETDEVCAPS_CAN_SAVE         equ    00000009h

; flags for dwFlags parameter of MCI_SYSINFO command message
MCI_SYSINFO_QUANTITY            equ    00000100h
MCI_SYSINFO_OPEN                equ    00000200h
MCI_SYSINFO_NAME                equ    00000400h
MCI_SYSINFO_INSTALLNAME         equ    00000800h

; flags for dwFlags parameter of MCI_SET command message
MCI_SET_DOOR_OPEN               equ    00000100h
MCI_SET_DOOR_CLOSED             equ    00000200h
MCI_SET_TIME_FORMAT             equ    00000400h
MCI_SET_AUDIO                   equ    00000800h
MCI_SET_VIDEO                   equ    00001000h
MCI_SET_ON                      equ    00002000h
MCI_SET_OFF                     equ    00004000h

; flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
MCI_SET_AUDIO_ALL               equ    00000000h
MCI_SET_AUDIO_LEFT              equ    00000001h
MCI_SET_AUDIO_RIGHT             equ    00000002h

; flags for dwFlags parameter of MCI_BREAK command message
MCI_BREAK_KEY                   equ    00000100h
MCI_BREAK_HWND                  equ    00000200h
MCI_BREAK_OFF                   equ    00000400h

; flags for dwFlags parameter of MCI_RECORD command message
MCI_RECORD_INSERT               equ    00000100h
MCI_RECORD_OVERWRITE            equ    00000200h

; flags for dwFlags parameter of MCI_SOUND command message
MCI_SOUND_NAME                  equ    00000100h

; flags for dwFlags parameter of MCI_SAVE command message
MCI_SAVE_FILE                   equ    00000100h

; flags for dwFlags parameter of MCI_LOAD command message
MCI_LOAD_FILE                   equ    00000100h

; generic parameter block for MCI command messages with no special parameters
MCI_GENERIC_PARMS struc
    mcigen_dwCallback         dd    ?
MCI_GENERIC_PARMS ends

; parameter block for MCI_OPEN command message
MCI_OPEN_PARMS struc
    mciopen_dwCallback        dd    ?
    mciopen_wDeviceID         dw    ?
    mciopen_wReserved0        dw    ?
    mciopen_lpstrDeviceType   dd    ?
    mciopen_lpstrElementName  dd    ?
    mciopen_lpstrAlias        dd    ?
MCI_OPEN_PARMS ends

; parameter block for MCI_PLAY command message
MCI_PLAY_PARMS struc
    mciplay_dwCallback        dd    ?
    mciplay_dwFrom            dd    ?
    mciplay_dwTo              dd    ?
MCI_PLAY_PARMS ends

; parameter block for MCI_SEEK command message
MCI_SEEK_PARMS struc
    mciseek_dwCallback        dd    ?
    mciseek_dwTo              dd    ?
MCI_SEEK_PARMS ends

; parameter block for MCI_STATUS command message
MCI_STATUS_PARMS struc
    mcistat_dwCallback        dd    ?
    mcistat_dwReturn          dd    ?
    mcistat_dwItem            dd    ?
    mcistat_dwTrack           dd    ?
MCI_STATUS_PARMS ends

; parameter block for MCI_INFO command message
MCI_INFO_PARMS struc
    mciinfo_dwCallback        dd    ?
    mciinfo_lpstrReturn       dd    ?
    mciinfo_dwRetSize         dd    ?
MCI_INFO_PARMS ends

; parameter block for MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_PARMS struc
    mcigdc_dwCallback         dd    ?
    mcigdc_dwReturn           dd    ?
    mcigdc_dwItem             dd    ?
MCI_GETDEVCAPS_PARMS ends

; parameter block for MCI_SYSINFO command message
MCI_SYSINFO_PARMS struc
    mcisi_dwCallback          dd    ?
    mcisi_lpstrReturn         dd    ?
    mcisi_dwRetSize           dd    ?
    mcisi_dwNumber            dd    ?
    mcisi_wDeviceType         dw    ?
    mcisi_wReserved0          dw    ?
MCI_SYSINFO_PARMS ends

; parameter block for MCI_SET command message
MCI_SET_PARMS struc
    mciset_dwCallback         dd    ?
    mciset_dwTimeFormat       dd    ?
    mciset_dwAudio            dd    ?
MCI_SET_PARMS ends

; parameter block for MCI_BREAK command message
MCI_BREAK_PARMS struc
    mcibreak_dwCallback       dd    ?
    mcibreak_nVirtKey         dw    ?
    mcibreak_wReserved0       dw    ?
    mcibreak_hwndBreak        dw    ?
    mcibreak_wReserved1       dw    ?
MCI_BREAK_PARMS ends

; parameter block for MCI_SOUND command message
MCI_SOUND_PARMS struc
    mcisnd_dwCallback         dd    ?
    mcisnd_lpstrSoundName     dd    ?
MCI_SOUND_PARMS ends

; parameter block for MCI_SAVE command message
MCI_SAVE_PARMS struc
    mcisave_dwCallback        dd    ?
    mcisave_lpfilename        dd    ?
MCI_SAVE_PARMS ends

; parameter block for MCI_LOAD command message
MCI_LOAD_PARMS struc
    mciload_dwCallback        dd    ?
    mciload_lpfilename        dd    ?
MCI_LOAD_PARMS ends

; parameter block for MCI_RECORD command message
MCI_RECORD_PARMS struc
    mcirec_dwCallback         dd    ?
    mcirec_dwFrom             dd    ?
    mcirec_dwTo               dd    ?
MCI_RECORD_PARMS ends


;
; MCI extensions for videodisc devices
;

; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
MCI_VD_MODE_PARK                equ    (MCI_VD_OFFSET + 1)

; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
MCI_VD_MEDIA_CLV                equ    (MCI_VD_OFFSET + 2)
MCI_VD_MEDIA_CAV                equ    (MCI_VD_OFFSET + 3)
MCI_VD_MEDIA_OTHER              equ    (MCI_VD_OFFSET + 4)

MCI_VD_FORMAT_TRACK             equ    4001h

; flags for dwFlags parameter of MCI_PLAY command message
MCI_VD_PLAY_REVERSE             equ    00010000h
MCI_VD_PLAY_FAST                equ    00020000h
MCI_VD_PLAY_SPEED               equ    00040000h
MCI_VD_PLAY_SCAN                equ    00080000h
MCI_VD_PLAY_SLOW                equ    00100000h

; flag for dwFlags parameter of MCI_SEEK command message
MCI_VD_SEEK_REVERSE             equ    00010000h

; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_VD_STATUS_SPEED             equ    00004002h
MCI_VD_STATUS_FORWARD           equ    00004003h
MCI_VD_STATUS_MEDIA_TYPE        equ    00004004h
MCI_VD_STATUS_SIDE              equ    00004005h
MCI_VD_STATUS_DISC_SIZE         equ    00004006h

; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_VD_GETDEVCAPS_CLV           equ    00010000h
MCI_VD_GETDEVCAPS_CAV           equ    00020000h

MCI_VD_SPIN_UP                  equ    0001h
MCI_VD_SPIN_DOWN                equ    0002h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_VD_GETDEVCAPS_CAN_REVERSE   equ    00004002h
MCI_VD_GETDEVCAPS_FAST_RATE     equ    00004003h
MCI_VD_GETDEVCAPS_SLOW_RATE     equ    00004004h
MCI_VD_GETDEVCAPS_NORMAL_RATE   equ    00004005h

; flags for the dwFlags parameter of MCI_STEP command message
MCI_VD_STEP_FRAMES              equ    00010000h
MCI_VD_STEP_REVERSE             equ    00020000h

; flag for the MCI_ESCAPE command message
MCI_VD_ESCAPE_STRING            equ    00000100h

; parameter block for MCI_PLAY command message
MCI_VD_PLAY_PARMS struc
    mcivdplay_dwCallback      dd    ?
    mcivdplay_dwFrom          dd    ?
    mcivdplay_dwTo            dd    ?
    mcivdplay_dwSpeed         dd    ?
MCI_VD_PLAY_PARMS ends

; parameter block for MCI_STEP command message
MCI_VD_STEP_PARMS struc
    mcivdstep_dwCallback      dd    ?
    mcivdstep_dwFrames        dd    ?
MCI_VD_STEP_PARMS ends

; parameter block for MCI_ESCAPE command message
MCI_VD_ESCAPE_PARMS struc
    mcivcesc_dwCallback       dd    ?
    mcivcesc_lpstrCommand     dd    ?
MCI_VD_ESCAPE_PARMS ends


;
; MCI extensions for waveform audio devices
;

; flags for the dwFlags parameter of MCI_OPEN command message
MCI_WAVE_OPEN_BUFFER            equ    00010000h

; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_FORMATTAG          equ    00010000h
MCI_WAVE_SET_CHANNELS           equ    00020000h
MCI_WAVE_SET_SAMPLESPERSEC      equ    00040000h
MCI_WAVE_SET_AVGBYTESPERSEC     equ    00080000h
MCI_WAVE_SET_BLOCKALIGN         equ    00100000h
MCI_WAVE_SET_BITSPERSAMPLE      equ    00200000h

; flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
MCI_WAVE_INPUT                  equ    00400000h
MCI_WAVE_OUTPUT                 equ    00800000h

; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_WAVE_STATUS_FORMATTAG       equ    00004001h
MCI_WAVE_STATUS_CHANNELS        equ    00004002h
MCI_WAVE_STATUS_SAMPLESPERSEC   equ    00004003h
MCI_WAVE_STATUS_AVGBYTESPERSEC  equ    00004004h
MCI_WAVE_STATUS_BLOCKALIGN      equ    00004005h
MCI_WAVE_STATUS_BITSPERSAMPLE   equ    00004006h
MCI_WAVE_STATUS_LEVEL           equ    00004007h

; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_ANYINPUT           equ    04000000h
MCI_WAVE_SET_ANYOUTPUT          equ    08000000h

; flags for the dwFlags parameter of MCI_GETDEVCAPS command message
MCI_WAVE_GETDEVCAPS_INPUTS      equ    00004001h
MCI_WAVE_GETDEVCAPS_OUTPUTS     equ    00004002h

; parameter block for MCI_OPEN command message
MCI_WAVE_OPEN_PARMS struc
    mciwopen_dwCallback       dd    ?
    mciwopen_wDeviceID        dw    ?
    mciwopen_wReserved0       dw    ?
    mciwopen_lpstrDeviceType  dd    ?
    mciwopen_lpstrElementName dd    ?
    mciwopen_lpstrAlias       dd    ?
    mciwopen_dwBufferSeconds  dd    ?
MCI_WAVE_OPEN_PARMS ends

; parameter block for MCI_DELETE command message
MCI_WAVE_DELETE_PARMS struc
    mciwdel_dwCallback        dd    ?
    mciwdel_dwFrom            dd    ?
    mciwdel_dwTo              dd    ?
MCI_WAVE_DELETE_PARMS ends

; parameter block for MCI_SET command message
MCI_WAVE_SET_PARMS struc
    mciwset_dwCallback        dd    ?
    mciwset_dwTimeFormat      dd    ?
    mciwset_dwAudio           dd    ?
    mciwset_wInput            dw    ?
    mciwset_wReserved0        dw    ?
    mciwset_wOutput           dw    ?
    mciwset_wReserved1        dw    ?
    mciwset_wFormatTag        dw    ?
    mciwset_wReserved2        dw    ?
    mciwset_nChannels         dw    ?
    mciwset_wReserved3        dw    ?
    mciwset_nSamplesPerSec    dw    ?
    mciwset_nAvgBytesPerSec   dw    ?
    mciwset_nBlockAlign       dw    ?
    mciwset_wReserved4        dw    ?
    mciwset_wBitsPerSample    dw    ?
    mciwset_wReserved5        dw    ?
MCI_WAVE_SET_PARMS ends


;
; MCI extensions for MIDI sequencer devices
;

; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
MCI_SEQ_DIV_PPQN            equ    (0 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_24        equ    (1 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_25        equ    (2 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30DROP    equ    (3 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30        equ    (4 + MCI_SEQ_OFFSET)

; flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
; MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
MCI_SEQ_FORMAT_SONGPTR      equ    4001h
MCI_SEQ_FILE                equ    4002h
MCI_SEQ_MIDI                equ    4003h
MCI_SEQ_SMPTE               equ    4004h
MCI_SEQ_NONE                equ    65533

; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_SEQ_STATUS_TEMPO            equ    00004002h
MCI_SEQ_STATUS_PORT             equ    00004003h
MCI_SEQ_STATUS_SLAVE            equ    00004007h
MCI_SEQ_STATUS_MASTER           equ    00004008h
MCI_SEQ_STATUS_OFFSET           equ    00004009h
MCI_SEQ_STATUS_DIVTYPE          equ    0000400Ah

; flags for the dwFlags parameter of MCI_SET command message
MCI_SEQ_SET_TEMPO               equ    00010000h
MCI_SEQ_SET_PORT                equ    00020000h
MCI_SEQ_SET_SLAVE               equ    00040000h
MCI_SEQ_SET_MASTER              equ    00080000h
MCI_SEQ_SET_OFFSET              equ    01000000h

; parameter block for MCI_SET command message
MCI_SEQ_SET_PARMS struc
    mcisset_dwCallback        dd    ?
    mcisset_dwTimeFormat      dd    ?
    mcisset_dwAudio           dd    ?
    mcisset_dwTempo           dd    ?
    mcisset_dwPort            dd    ?
    mcisset_dwSlave           dd    ?
    mcisset_dwMaster          dd    ?
    mcisset_dwOffset          dd    ?
MCI_SEQ_SET_PARMS ends


;
; MCI extensions for animation devices
;

; flags for dwFlags parameter of MCI_OPEN command message
MCI_ANIM_OPEN_WS                equ    00010000h
MCI_ANIM_OPEN_PARENT            equ    00020000h
MCI_ANIM_OPEN_NOSTATIC          equ    00040000h

; flags for dwFlags parameter of MCI_PLAY command message
MCI_ANIM_PLAY_SPEED             equ    00010000h
MCI_ANIM_PLAY_REVERSE           equ    00020000h
MCI_ANIM_PLAY_FAST              equ    00040000h
MCI_ANIM_PLAY_SLOW              equ    00080000h
MCI_ANIM_PLAY_SCAN              equ    00100000h

; flags for dwFlags parameter of MCI_STEP command message
MCI_ANIM_STEP_REVERSE           equ    00010000h
MCI_ANIM_STEP_FRAMES            equ    00020000h

; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_ANIM_STATUS_SPEED           equ    00004001h
MCI_ANIM_STATUS_FORWARD         equ    00004002h
MCI_ANIM_STATUS_HWND            equ    00004003h
MCI_ANIM_STATUS_HPAL            equ    00004004h
MCI_ANIM_STATUS_STRETCH         equ    00004005h

; flags for the dwFlags parameter of MCI_INFO command message
MCI_ANIM_INFO_TEXT              equ    00010000h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_ANIM_GETDEVCAPS_CAN_REVERSE equ    00004001h
MCI_ANIM_GETDEVCAPS_FAST_RATE   equ    00004002h
MCI_ANIM_GETDEVCAPS_SLOW_RATE   equ    00004003h
MCI_ANIM_GETDEVCAPS_NORMAL_RATE equ    00004004h
MCI_ANIM_GETDEVCAPS_PALETTES    equ    00004006h
MCI_ANIM_GETDEVCAPS_CAN_STRETCH equ    00004007h
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS equ    00004008h

; flags for the MCI_REALIZE command message
MCI_ANIM_REALIZE_NORM           equ    00010000h
MCI_ANIM_REALIZE_BKGD           equ    00020000h

; flags for dwFlags parameter of MCI_WINDOW command message
MCI_ANIM_WINDOW_HWND            equ    00010000h
MCI_ANIM_WINDOW_STATE           equ    00040000h
MCI_ANIM_WINDOW_TEXT            equ    00080000h
MCI_ANIM_WINDOW_ENABLE_STRETCH  equ    00100000h
MCI_ANIM_WINDOW_DISABLE_STRETCH equ    00200000h

; flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
; MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
MCI_ANIM_WINDOW_DEFAULT         equ    00000000h

; flags for dwFlags parameter of MCI_PUT command message
MCI_ANIM_RECT                   equ    00010000h
MCI_ANIM_PUT_SOURCE             equ    00020000h
MCI_ANIM_PUT_DESTINATION        equ    00040000h

; flags for dwFlags parameter of MCI_WHERE command message
MCI_ANIM_WHERE_SOURCE           equ    00020000h
MCI_ANIM_WHERE_DESTINATION      equ    00040000h

; flags for dwFlags parameter of MCI_UPDATE command message
MCI_ANIM_UPDATE_HDC             equ    00020000h

; parameter block for MCI_OPEN command message
MCI_ANIM_OPEN_PARMS struc
    mciaopen_dwCallback       dd    ?
    mciaopen_wDeviceID        dw    ?
    mciaopen_wReserved0       dw    ?
    mciaopen_lpstrDeviceType  dd    ?
    mciaopen_lpstrElementName dd    ?
    mciaopen_lpstrAlias       dd    ?
    mciaopen_dwStyle          dd    ?
    mciaopen_hWndParent       dw    ?
    mciaopen_wReserved1       dw    ?
MCI_ANIM_OPEN_PARMS ends

; parameter block for MCI_PLAY command message
MCI_ANIM_PLAY_PARMS struc
    mciaplay_dwCallback       dd    ?
    mciaplay_dwFrom           dd    ?
    mciaplay_dwTo             dd    ?
    mciaplay_dwSpeed          dd    ?
MCI_ANIM_PLAY_PARMS ends

; parameter block for MCI_STEP command message
MCI_ANIM_STEP_PARMS struc
    mciastep_dwCallback       dd    ?
    mciastep_dwFrames         dd    ?
MCI_ANIM_STEP_PARMS ends

; parameter block for MCI_WINDOW command message
MCI_ANIM_WINDOW_PARMS struc
    mciawin_dwCallback        dd    ?
    mciawin_hWnd              dw    ?
    mciawin_wReserved1        dw    ?
    mciawin_nCmdShow          dw    ?
    mciawin_wReserved2        dw    ?
    mciawin_lpstrText         dd    ?
MCI_ANIM_WINDOW_PARMS ends

; parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages
MCI_ANIM_RECT_PARMS struc
    mciarect_dwCallback       dd    ?
ifdef MCI_USE_OFFEXT
    mciarect_ptOffset         db (SIZE POINT) dup (?)
    mciarect_ptExtent         db (SIZE POINT) dup (?)
else	;ifdef MCI_USE_OFFEXT
    mciarect_rc               db (SIZE RECT) dup (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_ANIM_RECT_PARMS ends

; parameter block for MCI_UPDATE PARMS
MCI_ANIM_UPDATE_PARMS struc
    mciaupd_dwCallback        dd    ?
    mciaupd_rc                db (SIZE RECT) dup (?)
    mciaupd_hDC               dw    ?
MCI_ANIM_UPDATE_PARMS ends


;
; MCI extensions for video overlay devices
;

; flags for dwFlags parameter of MCI_OPEN command message
MCI_OVLY_OPEN_WS                equ    00010000h
MCI_OVLY_OPEN_PARENT            equ    00020000h

; flags for dwFlags parameter of MCI_STATUS command message
MCI_OVLY_STATUS_HWND            equ    00004001h
MCI_OVLY_STATUS_STRETCH         equ    00004002h

; flags for dwFlags parameter of MCI_INFO command message
MCI_OVLY_INFO_TEXT              equ    00010000h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_OVLY_GETDEVCAPS_CAN_STRETCH equ    00004001h
MCI_OVLY_GETDEVCAPS_CAN_FREEZE  equ    00004002h
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS equ    00004003h

; flags for dwFlags parameter of MCI_WINDOW command message
MCI_OVLY_WINDOW_HWND            equ    00010000h
MCI_OVLY_WINDOW_STATE           equ    00040000h
MCI_OVLY_WINDOW_TEXT            equ    00080000h
MCI_OVLY_WINDOW_ENABLE_STRETCH  equ    00100000h
MCI_OVLY_WINDOW_DISABLE_STRETCH equ    00200000h

; flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
MCI_OVLY_WINDOW_DEFAULT         equ    00000000h

; flags for dwFlags parameter of MCI_PUT command message
MCI_OVLY_RECT                   equ    00010000h
MCI_OVLY_PUT_SOURCE             equ    00020000h
MCI_OVLY_PUT_DESTINATION        equ    00040000h
MCI_OVLY_PUT_FRAME              equ    00080000h
MCI_OVLY_PUT_VIDEO              equ    00100000h

; flags for dwFlags parameter of MCI_WHERE command message
MCI_OVLY_WHERE_SOURCE           equ    00020000h
MCI_OVLY_WHERE_DESTINATION      equ    00040000h
MCI_OVLY_WHERE_FRAME            equ    00080000h
MCI_OVLY_WHERE_VIDEO            equ    00100000h

; parameter block for MCI_OPEN command message
MCI_OVLY_OPEN_PARMS struc
    mcioopen_dwCallback       dd    ?
    mcioopen_wDeviceID        dw    ?
    mcioopen_wReserved0       dw    ?
    mcioopen_lpstrDeviceType  dd    ?
    mcioopen_lpstrElementName dd    ?
    mcioopen_lpstrAlias       dd    ?
    mcioopen_dwStyle          dd    ?
    mcioopen_hWndParent       dw    ?
    mcioopen_wReserved1       dw    ?
MCI_OVLY_OPEN_PARMS ends

; parameter block for MCI_WINDOW command message
MCI_OVLY_WINDOW_PARMS struc
    mciowin_dwCallback        dd    ?
    mciowin_hWnd              dw    ?
    mciowin_wReserved1        dw    ?
    mciowin_nCmdShow          dw    ?
    mciowin_wReserved2        dw    ?
    mciowin_lpstrText         dd    ?
MCI_OVLY_WINDOW_PARMS ends

; parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages
MCI_OVLY_RECT_PARMS struc
    mciorect_dwCallback       dd    ?
ifdef MCI_USE_OFFEXT
    mciorect_ptOffset         db (SIZE POINT) dup (?)
    mciorect_ptExtent         db (SIZE POINT) dup (?)
else	;ifdef MCI_USE_OFFEXT
    mciorect_rc               db (SIZE RECT) dup (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_OVLY_RECT_PARMS ends

; parameter block for MCI_SAVE command message
MCI_OVLY_SAVE_PARMS struc
    mciosave_dwCallback       dd    ?
    mciosave_lpfilename       dd    ?
    mciosave_rc               db (SIZE RECT) dup (?)
MCI_OVLY_SAVE_PARMS ends

; parameter block for MCI_LOAD command message
MCI_OVLY_LOAD_PARMS struc
    mcioload_dwCallback       dd    ?
    mcioload_lpfilename       dd    ?
    mcioload_rc               db (SIZE RECT) dup (?)
MCI_OVLY_LOAD_PARMS ends

endif  ;ifndef MMNOMCI

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       DISPLAY Driver extensions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef C1_TRANSPARENT
    CAPS1           equ    94          ; other caps
    C1_TRANSPARENT  equ    0001h       ; new raster cap
    NEWTRANSPARENT  equ    3           ; use with SetBkMode()

    QUERYROPSUPPORT equ    40          ; use to determine ROP support
endif  ;ifndef C1_TRANSPARENT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       DIB Driver extensions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SELECTDIB       equ    41                      ; DIB.DRV select dib escape
DIBINDEX MACRO a
        mov     ax,a
        mov     dx,10ffh
        ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       ScreenSaver support
;
;   The current application will receive a syscommand of SC_SCREENSAVE just
;   before the screen saver is invoked.  If the app wishes to prevent a
;   screen save, return non-zero value, otherwise call DefWindowProc().
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SC_SCREENSAVE

    SC_SCREENSAVE   equ    0F140h

endif  ;ifndef SC_SCREENSAVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\mmsystem.h ===
/****************************************************************************/
/*                                                                          */
/*        MMSYSTEM.H - Include file for Multimedia APIs                     */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/
#define BUILDDLL



/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *      MMNODRV          - Installable driver support
 *      MMNOSOUND        - Sound support
 *      MMNOWAVE         - Waveform support
 *      MMNOMIDI         - MIDI support
 *      MMNOAUX          - Auxiliary audio support
 *      MMNOTIMER        - Timer support
 *      MMNOJOY          - Joystick support
 *      MMNOMCI          - MCI support
 *      MMNOMMIO         - Multimedia file I/O support
 *      MMNOMMSYSTEM     - General MMSYSTEM functions
 */

#ifndef _INC_MMSYSTEM
#define _INC_MMSYSTEM   /* #defined if mmsystem.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef  BUILDDLL                                /* ;Internal */
#undef  WINAPI                                  /* ;Internal */
#define WINAPI          _loadds _far _pascal    /* ;Internal */
#undef  CALLBACK                                /* ;Internal */
#define CALLBACK        _loadds _far _pascal    /* ;Internal */
#endif  /* ifdef BUILDDLL */                    /* ;Internal */

/****************************************************************************

                    General constants and data types

****************************************************************************/

/* general constants */
#define MAXPNAMELEN      32     /* max product name length (including NULL) */
#define MAXERRORLENGTH   128    /* max error text length (including NULL) */

/* general data types */
typedef WORD    VERSION;        /* major (high byte), minor (low byte) */

/* MMTIME data structure */
typedef struct mmtime_tag {
    UINT    wType;              /* indicates the contents of the union */
    union {
        DWORD ms;               /* milliseconds */
        DWORD sample;           /* samples */
        DWORD cb;               /* byte count */
        struct {                /* SMPTE */
            BYTE hour;          /* hours */
            BYTE min;           /* minutes */
            BYTE sec;           /* seconds */
            BYTE frame;         /* frames  */
            BYTE fps;           /* frames per second */
            BYTE dummy;         /* pad */
            } smpte;
        struct {                /* MIDI */
            DWORD songptrpos;   /* song pointer position */
            } midi;
        } u;
    } MMTIME;
typedef MMTIME       *PMMTIME;
typedef MMTIME NEAR *NPMMTIME;
typedef MMTIME FAR  *LPMMTIME;

/* types for wType field in MMTIME struct */
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */


/****************************************************************************

                    Multimedia Extensions Window Messages

****************************************************************************/

#define MM_JOY1MOVE         0x3A0           /* joystick */
#define MM_JOY2MOVE         0x3A1
#define MM_JOY1ZMOVE        0x3A2
#define MM_JOY2ZMOVE        0x3A3
#define MM_JOY1BUTTONDOWN   0x3B5
#define MM_JOY2BUTTONDOWN   0x3B6
#define MM_JOY1BUTTONUP     0x3B7
#define MM_JOY2BUTTONUP     0x3B8

#define MM_MCINOTIFY        0x3B9           /* MCI */
#define MM_MCISYSTEM_STRING 0x3CA           /* ;Internal */

#define MM_WOM_OPEN         0x3BB           /* waveform output */
#define MM_WOM_CLOSE        0x3BC
#define MM_WOM_DONE         0x3BD

#define MM_WIM_OPEN         0x3BE           /* waveform input */
#define MM_WIM_CLOSE        0x3BF
#define MM_WIM_DATA         0x3C0

#define MM_MIM_OPEN         0x3C1           /* MIDI input */
#define MM_MIM_CLOSE        0x3C2
#define MM_MIM_DATA         0x3C3
#define MM_MIM_LONGDATA     0x3C4
#define MM_MIM_ERROR        0x3C5
#define MM_MIM_LONGERROR    0x3C6

#define MM_MOM_OPEN         0x3C7           /* MIDI output */
#define MM_MOM_CLOSE        0x3C8
#define MM_MOM_DONE         0x3C9


/****************************************************************************

                String resource number bases (internal use)

****************************************************************************/

#define MMSYSERR_BASE          0
#define WAVERR_BASE            32
#define MIDIERR_BASE           64
#define TIMERR_BASE            96
#define JOYERR_BASE            160
#define MCIERR_BASE            256

#define MCI_STRING_OFFSET      512
#define MCI_VD_OFFSET          1024
#define MCI_CD_OFFSET          1088
#define MCI_WAVE_OFFSET        1152
#define MCI_SEQ_OFFSET         1216

/****************************************************************************

                        General error return values

****************************************************************************/

/* general error return values */
#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 11) /* last error in range */


#if (WINVER < 0x030a)
DECLARE_HANDLE(HDRVR);
#endif /* ifdef WINVER < 0x030a */

#ifndef MMNODRV
/****************************************************************************

                        Installable driver support

****************************************************************************/

#if (WINVER < 0x030a)

/* return values from DriverProc() function */
#define DRV_CANCEL              0x0000
#define DRV_OK                  0x0001
#define DRV_RESTART             0x0002

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO        *PDRVCONFIGINFO;
typedef DRVCONFIGINFO  NEAR *NPDRVCONFIGINFO;
typedef DRVCONFIGINFO  FAR  *LPDRVCONFIGINFO;

/* installable driver function prototypes */
LRESULT   WINAPI DrvClose(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);
HDRVR     WINAPI DrvOpen(LPCSTR szDriverName, LPCSTR szSectionName,
    LPARAM lParam2);
LRESULT   WINAPI DrvSendMessage(HDRVR hDriver, UINT uMessage,
    LPARAM lParam1, LPARAM lParam2);
HINSTANCE WINAPI DrvGetModuleHandle(HDRVR hDriver);

LRESULT WINAPI DrvDefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID,
    UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#define DefDriverProc DrvDefDriverProc

#endif /* ifdef WINVER < 0x030a */

#if (WINVER >= 0x030a)

#ifdef DEBUG                                          /* ;Internal */
        LRESULT WINAPI DrvClose(HDRVR,LPARAM,LPARAM); /* ;Internal */
        HDRVR   WINAPI DrvOpen(LPCSTR,LPCSTR,LPARAM); /* ;Internal */
        #define OpenDriver DrvOpen                    /* ;Internal */
        #define CloseDriver DrvClose                  /* ;Internal */
#endif                                                /* ;Internal */

/* return values from DriverProc() function */
#define DRV_CANCEL             DRVCNF_CANCEL
#define DRV_OK                 DRVCNF_OK
#define DRV_RESTART            DRVCNF_RESTART

#endif /* ifdef WINVER >= 0x030a */

#define DRV_MCI_FIRST          DRV_RESERVED
#define DRV_MCI_LAST           (DRV_RESERVED + 0xFFF)

#endif  /* ifndef MMNODRV */


/****************************************************************************

                          Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

#define CALLBACK_TYPEMASK   0x00070000l    /* callback type mask */
#define CALLBACK_NULL       0x00000000l    /* no callback */
#define CALLBACK_WINDOW     0x00010000l    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x00020000l    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */

/* driver callback prototypes */
#ifdef  BUILDDLL                                /* ;Internal */
typedef void (FAR PASCAL DRVCALLBACK) (HDRVR h, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);          /* ;Internal */
#else   /* ifdef BUILDDLL */                    /* ;Internal */
typedef void (CALLBACK DRVCALLBACK) (HDRVR h, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);
#endif  /* ifdef BUILDDLL */                    /* ;Internal */

typedef DRVCALLBACK FAR *LPDRVCALLBACK;

/****************************************************************************

                         Manufacturer and product IDs

    Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS,
    MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.

****************************************************************************/

/* manufacturer IDs */
#define MM_MICROSOFT            1       /* Microsoft Corp. */

/* product IDs */
#define MM_MIDI_MAPPER          1       /* MIDI Mapper */
#define MM_WAVE_MAPPER          2       /* Wave Mapper */

#define MM_SNDBLST_MIDIOUT      3       /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4       /* Sound Blaster MIDI input port  */
#define MM_SNDBLST_SYNTH        5       /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6       /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7       /* Sound Blaster waveform input */

#define MM_ADLIB                9       /* Ad Lib-compatible synthesizer */

#define MM_MPU401_MIDIOUT       10      /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN        11      /* MPU401-compatible MIDI input port */

#define MM_PC_JOYSTICK          12      /* Joystick adapter */


#ifndef MMNOMMSYSTEM
/****************************************************************************

                    General MMSYSTEM support

****************************************************************************/

WORD WINAPI mmsystemGetVersion(void);
void WINAPI OutputDebugStr(LPCSTR);

#endif  /* ifndef MMNOMMSYSTEM */


#ifndef MMNOSOUND
/****************************************************************************

                            Sound support

****************************************************************************/

BOOL WINAPI sndPlaySound(LPCSTR lpszSoundName, UINT uFlags);

/* flag values for wFlags parameter */
#define SND_SYNC            0x0000  /* play synchronously (default) */
#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* don't use default sound */
#define SND_MEMORY          0x0004  /* lpszSoundName points to a memory file */
#define SND_LOOP            0x0008  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x0010  /* don't stop any currently playing sound */
#define SND_VALID           0x001F  /* valid flags */         /* ;Internal */

#endif  /* ifndef MMNOSOUND */


#ifndef MMNOWAVE
/****************************************************************************

                        Waveform audio support

****************************************************************************/

/* waveform audio error return values */
#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* waveform audio data types */
DECLARE_HANDLE(HWAVE);
DECLARE_HANDLE(HWAVEIN);
DECLARE_HANDLE(HWAVEOUT);
typedef HWAVEIN FAR *LPHWAVEIN;
typedef HWAVEOUT FAR *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK FAR *LPWAVECALLBACK;

/* wave callback messages */
#define WOM_OPEN        MM_WOM_OPEN
#define WOM_CLOSE       MM_WOM_CLOSE
#define WOM_DONE        MM_WOM_DONE
#define WIM_OPEN        MM_WIM_OPEN
#define WIM_CLOSE       MM_WIM_CLOSE
#define WIM_DATA        MM_WIM_DATA

/* device ID for wave device mapper */
#define WAVE_MAPPER     (-1)

/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY     0x0001
#define  WAVE_ALLOWSYNC        0x0002
#define  WAVE_VALID            0x0003       /* ;Internal */

/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    struct wavehdr_tag far *lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR;
typedef WAVEHDR       *PWAVEHDR;
typedef WAVEHDR NEAR *NPWAVEHDR;
typedef WAVEHDR FAR  *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */
#define WHDR_VALID      0x0000001F  /* valid flags */     /* ;Internal */

/* waveform output device capabilities structure */
typedef struct waveoutcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    UINT    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS;
typedef WAVEOUTCAPS       *PWAVEOUTCAPS;
typedef WAVEOUTCAPS NEAR *NPWAVEOUTCAPS;
typedef WAVEOUTCAPS FAR  *LPWAVEOUTCAPS;

/* flags for dwSupport field of WAVEOUTCAPS */
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010

/* waveform input device capabilities structure */
typedef struct waveincaps_tag {
    UINT    wMid;                    /* manufacturer ID */
    UINT    wPid;                    /* product ID */
    VERSION vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    UINT    wChannels;               /* number of channels supported */
} WAVEINCAPS;
typedef WAVEINCAPS       *PWAVEINCAPS;
typedef WAVEINCAPS NEAR *NPWAVEINCAPS;
typedef WAVEINCAPS FAR  *LPWAVEINCAPS;

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT       *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;

/* waveform audio function prototypes */
UINT WINAPI waveOutGetNumDevs(void);
UINT WINAPI waveOutGetDevCaps(UINT uDeviceID, WAVEOUTCAPS FAR* lpCaps,
    UINT uSize);
UINT WINAPI waveOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
UINT WINAPI waveOutSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI waveOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI waveOutOpen(HWAVEOUT FAR* lphWaveOut, UINT uDeviceID,
    const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI waveOutClose(HWAVEOUT hWaveOut);
UINT WINAPI waveOutPrepareHeader(HWAVEOUT hWaveOut,
     WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
UINT WINAPI waveOutUnprepareHeader(HWAVEOUT hWaveOut,
    WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
UINT WINAPI waveOutWrite(HWAVEOUT hWaveOut, WAVEHDR FAR* lpWaveOutHdr,
    UINT uSize);
UINT WINAPI waveOutPause(HWAVEOUT hWaveOut);
UINT WINAPI waveOutRestart(HWAVEOUT hWaveOut);
UINT WINAPI waveOutReset(HWAVEOUT hWaveOut);
UINT WINAPI waveOutBreakLoop(HWAVEOUT hWaveOut);
UINT WINAPI waveOutGetPosition(HWAVEOUT hWaveOut, MMTIME FAR* lpInfo,
    UINT uSize);
UINT WINAPI waveOutGetPitch(HWAVEOUT hWaveOut, DWORD FAR* lpdwPitch);
UINT WINAPI waveOutSetPitch(HWAVEOUT hWaveOut, DWORD dwPitch);
UINT WINAPI waveOutGetPlaybackRate(HWAVEOUT hWaveOut, DWORD FAR* lpdwRate);
UINT WINAPI waveOutSetPlaybackRate(HWAVEOUT hWaveOut, DWORD dwRate);
UINT WINAPI waveOutGetID(HWAVEOUT hWaveOut, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI waveOutMessage(HWAVEOUT hWaveOut, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI waveInGetNumDevs(void);
UINT WINAPI waveInGetDevCaps(UINT uDeviceID, WAVEINCAPS FAR* lpCaps,
    UINT uSize);
UINT WINAPI waveInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI waveInOpen(HWAVEIN FAR* lphWaveIn, UINT uDeviceID,
    const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI waveInClose(HWAVEIN hWaveIn);
UINT WINAPI waveInPrepareHeader(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInUnprepareHeader(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInAddBuffer(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInStart(HWAVEIN hWaveIn);
UINT WINAPI waveInStop(HWAVEIN hWaveIn);
UINT WINAPI waveInReset(HWAVEIN hWaveIn);
UINT WINAPI waveInGetPosition(HWAVEIN hWaveIn, MMTIME FAR* lpInfo,
    UINT uSize);
UINT WINAPI waveInGetID(HWAVEIN hWaveIn, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI waveInMessage(HWAVEIN hWaveIn, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOWAVE */


#ifndef MMNOMIDI
/****************************************************************************

                            MIDI audio support

****************************************************************************/

/* MIDI error return values */
#define MIDIERR_UNPREPARED    (MIDIERR_BASE + 0)   /* header not prepared */
#define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   /* still something playing */
#define MIDIERR_NOMAP         (MIDIERR_BASE + 2)   /* no current map */
#define MIDIERR_NOTREADY      (MIDIERR_BASE + 3)   /* hardware is still busy */
#define MIDIERR_NODEVICE      (MIDIERR_BASE + 4)   /* port no longer connected */
#define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   /* invalid setup */
#define MIDIERR_LASTERROR     (MIDIERR_BASE + 5)   /* last error in range */

/* MIDI audio data types */
DECLARE_HANDLE(HMIDI);
DECLARE_HANDLE(HMIDIIN);
DECLARE_HANDLE(HMIDIOUT);
typedef HMIDIIN FAR *LPHMIDIIN;
typedef HMIDIOUT FAR *LPHMIDIOUT;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK FAR *LPMIDICALLBACK;
#define MIDIPATCHSIZE   128
typedef WORD PATCHARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPPATCHARRAY;
typedef WORD KEYARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPKEYARRAY;

/* MIDI callback messages */
#define MIM_OPEN        MM_MIM_OPEN
#define MIM_CLOSE       MM_MIM_CLOSE
#define MIM_DATA        MM_MIM_DATA
#define MIM_LONGDATA    MM_MIM_LONGDATA
#define MIM_ERROR       MM_MIM_ERROR
#define MIM_LONGERROR   MM_MIM_LONGERROR
#define MOM_OPEN        MM_MOM_OPEN
#define MOM_CLOSE       MM_MOM_CLOSE
#define MOM_DONE        MM_MOM_DONE

/* device ID for MIDI mapper */
#define MIDIMAPPER     (-1)
#define MIDI_MAPPER    (-1)

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */
#define MIDI_CACHE_ALL      1
#define MIDI_CACHE_BESTFIT  2
#define MIDI_CACHE_QUERY    3
#define MIDI_UNCACHE        4
#define	MIDI_CACHE_VALID    (MIDI_CACHE_ALL | MIDI_CACHE_BESTFIT | MIDI_CACHE_QUERY | MIDI_UNCACHE)	/* ;Internal */

/* MIDI output device capabilities structure */
typedef struct midioutcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT    wTechnology;           /* type of device */
    UINT    wVoices;               /* # of voices (internal synth only) */
    UINT    wNotes;                /* max # of notes (internal synth only) */
    UINT    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS;
typedef MIDIOUTCAPS       *PMIDIOUTCAPS;
typedef MIDIOUTCAPS NEAR *NPMIDIOUTCAPS;
typedef MIDIOUTCAPS FAR  *LPMIDIOUTCAPS;

/* flags for wTechnology field of MIDIOUTCAPS structure */
#define MOD_MIDIPORT    1  /* output port */
#define MOD_SYNTH       2  /* generic internal synth */
#define MOD_SQSYNTH     3  /* square wave internal synth */
#define MOD_FMSYNTH     4  /* FM internal synth */
#define MOD_MAPPER      5  /* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
#define MIDICAPS_VOLUME          0x0001  /* supports volume control */
#define MIDICAPS_LRVOLUME        0x0002  /* separate left-right volume control */
#define MIDICAPS_CACHE           0x0004

/* MIDI output device capabilities structure */
typedef struct midiincaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
} MIDIINCAPS;
typedef MIDIINCAPS      *PMIDIINCAPS;
typedef MIDIINCAPS NEAR *NPMIDIINCAPS;
typedef MIDIINCAPS FAR  *LPMIDIINCAPS;

/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD       dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag far *lpNext;   /* reserved for driver */
    DWORD       reserved;             /* reserved for driver */
} MIDIHDR;
typedef MIDIHDR       *PMIDIHDR;
typedef MIDIHDR NEAR *NPMIDIHDR;
typedef MIDIHDR FAR  *LPMIDIHDR;

/* flags for dwFlags field of MIDIHDR structure */
#define MHDR_DONE       0x00000001       /* done bit */
#define MHDR_PREPARED   0x00000002       /* set if header prepared */
#define MHDR_INQUEUE    0x00000004       /* reserved for driver */
#define MHDR_VALID      0x00000007       /* valid flags */ /* ;Internal */

/* MIDI function prototypes */
UINT WINAPI midiOutGetNumDevs(void);
UINT WINAPI midiOutGetDevCaps(UINT uDeviceID,
    MIDIOUTCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI midiOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
UINT WINAPI midiOutSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI midiOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI midiOutOpen(HMIDIOUT FAR* lphMidiOut, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI midiOutClose(HMIDIOUT hMidiOut);
UINT WINAPI midiOutPrepareHeader(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutUnprepareHeader(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutShortMsg(HMIDIOUT hMidiOut, DWORD dwMsg);
UINT WINAPI midiOutLongMsg(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutReset(HMIDIOUT hMidiOut);
UINT WINAPI midiOutCachePatches(HMIDIOUT hMidiOut,
    UINT uBank, WORD FAR* lpwPatchArray, UINT uFlags);
UINT WINAPI midiOutCacheDrumPatches(HMIDIOUT hMidiOut,
    UINT uPatch, WORD FAR* lpwKeyArray, UINT uFlags);
UINT WINAPI midiOutGetID(HMIDIOUT hMidiOut, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI midiOutMessage(HMIDIOUT hMidiOut, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI midiInGetNumDevs(void);
UINT WINAPI midiInGetDevCaps(UINT uDeviceID,
    LPMIDIINCAPS lpCaps, UINT uSize);
UINT WINAPI midiInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI midiInOpen(HMIDIIN FAR* lphMidiIn, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI midiInClose(HMIDIIN hMidiIn);
UINT WINAPI midiInPrepareHeader(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInUnprepareHeader(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInAddBuffer(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInStart(HMIDIIN hMidiIn);
UINT WINAPI midiInStop(HMIDIIN hMidiIn);
UINT WINAPI midiInReset(HMIDIIN hMidiIn);
UINT WINAPI midiInGetID(HMIDIIN hMidiIn, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI midiInMessage(HMIDIIN hMidiIn, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOMIDI */


#ifndef MMNOAUX
/****************************************************************************

                        Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */
#define AUX_MAPPER     (-1)

/* Auxiliary audio device capabilities structure */
typedef struct auxcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS;
typedef AUXCAPS       *PAUXCAPS;
typedef AUXCAPS NEAR *NPAUXCAPS;
typedef AUXCAPS FAR  *LPAUXCAPS;

/* flags for wTechnology field in AUXCAPS structure */
#define AUXCAPS_CDAUDIO    1       /* audio from internal CD-ROM drive */
#define AUXCAPS_AUXIN      2       /* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
#define AUXCAPS_VOLUME          0x0001  /* supports volume control */
#define AUXCAPS_LRVOLUME        0x0002  /* separate left-right volume control */

/* auxiliary audio function prototypes */
UINT WINAPI auxGetNumDevs(void);
UINT WINAPI auxGetDevCaps(UINT uDeviceID, AUXCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI auxGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);

#if (WINVER >= 0x030a)
DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOAUX */


#ifndef MMNOTIMER
/****************************************************************************

                            Timer support

****************************************************************************/

/* timer error return values */
#define TIMERR_NOERROR        (0)                  /* no error */
#define TIMERR_NOCANDO        (TIMERR_BASE+1)      /* request not completed */
#define TIMERR_STRUCT         (TIMERR_BASE+33)     /* time struct size */

/* timer data types */
#ifdef  BUILDDLL                                   /* ;Internal */
typedef void (FAR PASCAL TIMECALLBACK) (UINT uTimerID, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);           /* ;Internal */
#else   /* ifdef BUILDDLL */                       /* ;Internal */
typedef void (CALLBACK TIMECALLBACK) (UINT uTimerID, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);
#endif  /* ifdef BUILDDLL */                       /* ;Internal */

typedef TIMECALLBACK FAR *LPTIMECALLBACK;

/* flags for wFlags parameter of timeSetEvent() function */
#define TIME_ONESHOT    0   /* program timer for single event */
#define TIME_PERIODIC   1   /* program for continuous periodic event */

/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */
    UINT    wPeriodMax;     /* maximum period supported  */
    } TIMECAPS;
typedef TIMECAPS       *PTIMECAPS;
typedef TIMECAPS NEAR *NPTIMECAPS;
typedef TIMECAPS FAR  *LPTIMECAPS;

/* timer function prototypes */
UINT WINAPI timeGetSystemTime(MMTIME FAR* lpTime, UINT uSize);
DWORD WINAPI timeGetTime(void);
UINT WINAPI timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK lpFunction, DWORD dwUser, UINT uFlags);
UINT WINAPI timeKillEvent(UINT uTimerID);
UINT WINAPI timeGetDevCaps(TIMECAPS FAR* lpTimeCaps, UINT uSize);
UINT WINAPI timeBeginPeriod(UINT uPeriod);
UINT WINAPI timeEndPeriod(UINT uPeriod);

#endif  /* ifndef MMNOTIMER */


#ifndef MMNOJOY
/****************************************************************************

                            Joystick support

****************************************************************************/

/* joystick error return values */
#define JOYERR_NOERROR        (0)                  /* no error */
#define JOYERR_PARMS          (JOYERR_BASE+5)      /* bad parameters */
#define JOYERR_NOCANDO        (JOYERR_BASE+6)      /* request not completed */
#define JOYERR_UNPLUGGED      (JOYERR_BASE+7)      /* joystick is unplugged */

/* constants used with JOYINFO structure and MM_JOY* messages */
#define JOY_BUTTON1         0x0001
#define JOY_BUTTON2         0x0002
#define JOY_BUTTON3         0x0004
#define JOY_BUTTON4         0x0008
#define JOY_BUTTON1CHG      0x0100
#define JOY_BUTTON2CHG      0x0200
#define JOY_BUTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1

/* joystick device capabilities data structure */
typedef struct joycaps_tag {
    UINT wMid;                  /* manufacturer ID */
    UINT wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
    } JOYCAPS;
typedef JOYCAPS       *PJOYCAPS;
typedef JOYCAPS NEAR *NPJOYCAPS;
typedef JOYCAPS FAR  *LPJOYCAPS;

/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
    } JOYINFO;
typedef JOYINFO       *PJOYINFO;
typedef JOYINFO NEAR *NPJOYINFO;
typedef JOYINFO FAR  *LPJOYINFO;

/* joystick function prototypes */
UINT WINAPI joyGetDevCaps(UINT uJoyID, JOYCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI joyGetNumDevs(void);
UINT WINAPI joyGetPos(UINT uJoyID, JOYINFO FAR* lpInfo);
UINT WINAPI joyGetThreshold(UINT uJoyID, UINT FAR* lpuThreshold);
UINT WINAPI joyReleaseCapture(UINT uJoyID);
UINT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL bChanged);
UINT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);
UINT WINAPI joySetCalibration(UINT uJoyID, UINT FAR* puXbase, /* ;Internal */
    UINT FAR* puXdelta, UINT FAR* puYbase, UINT FAR* puYdelta,/* ;Internal */
    UINT FAR* puZbase, UINT FAR* puZdelta);                   /* ;Internal */

#endif  /* ifndef MMNOJOY */


#ifndef MMNOMMIO
/****************************************************************************

                        Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE            256
#define MMIOERR_FILENOTFOUND    (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY     (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN      (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE     (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD      (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE     (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK      (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND    (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND   (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED      (MMIOERR_BASE + 10) /* file is unbuffered */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMessage,
            LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
        /* general fields */
        DWORD           dwFlags;        /* general status flags */
        FOURCC          fccIOProc;      /* pointer to I/O procedure */
        LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
        UINT            wErrorRet;      /* place for error to be returned */
        HTASK           htask;          /* alternate local task */

        /* fields maintained by MMIO functions during buffered I/O */
        LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
        HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
        HPSTR           pchNext;        /* pointer to next byte to read/write */
        HPSTR           pchEndRead;     /* pointer to last valid byte to read */
        HPSTR           pchEndWrite;    /* pointer to last byte to write */
        LONG            lBufOffset;     /* disk offset of start of buffer */

        /* fields maintained by I/O procedure */
        LONG            lDiskOffset;    /* disk offset of next read or write */
        DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

        /* other fields maintained by MMIO */
        DWORD           dwReserved1;    /* reserved for MMIO use */
        DWORD           dwReserved2;    /* reserved for MMIO use */
        HMMIO           hmmio;          /* handle to open file */
} MMIOINFO;
typedef MMIOINFO       *PMMIOINFO;
typedef MMIOINFO NEAR *NPMMIOINFO;
typedef MMIOINFO FAR  *LPMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
        FOURCC          ckid;           /* chunk ID */
        DWORD           cksize;         /* chunk size */
        FOURCC          fccType;        /* form type or list type */
        DWORD           dwDataOffset;   /* offset of data portion of chunk */
        DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO;
typedef MMCKINFO       *PMMCKINFO;
typedef MMCKINFO NEAR *NPMMCKINFO;
typedef MMCKINFO FAR  *LPMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */

#define MMIO_OPEN_VALID 0x0003FFFF      /* valid flags for mmioOpen */ /* ;Internal */
#define	MMIO_FLUSH_VALID MMIO_EMPTYBUF	/* valid flags for mmioFlush */ /* ;Internal */
#define	MMIO_ADVANCE_VALID (MMIO_WRITE | MMIO_READ)	/* valid flags for mmioAdvance */ /* ;Internal */
#define	MMIO_FOURCC_VALID MMIO_TOUPPER	/* valid flags for mmioStringToFOURCC */ /* ;Internal */
#define	MMIO_DESCEND_VALID (MMIO_FINDCHUNK | MMIO_FINDRIFF | MMIO_FINDLIST) /* ;Internal */
#define	MMIO_CREATE_VALID (MMIO_CREATERIFF | MMIO_CREATELIST)	/* ;Internal */

/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */

#define MMIO_VALIDPROC      0x10070000  /* valid for mmioInstallIOProc */ /* ;Internal */

/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif /* ifdef WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

/* MMIO function prototypes */
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc,
    DWORD dwFlags);
HMMIO WINAPI mmioOpen(LPSTR szFileName, MMIOINFO FAR* lpmmioinfo,
    DWORD dwOpenFlags);

#if (WINVER >= 0x030a)
UINT WINAPI mmioRename(LPCSTR szFileName, LPCSTR szNewFileName,
     MMIOINFO FAR* lpmmioinfo, DWORD dwRenameFlags);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI mmioClose(HMMIO hmmio, UINT uFlags);
LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
UINT WINAPI mmioGetInfo(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
UINT WINAPI mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* lpmmioinfo, UINT uFlags);
UINT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT uFlags);
UINT WINAPI mmioFlush(HMMIO hmmio, UINT uFlags);
UINT WINAPI mmioAdvance(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMessage,
    LPARAM lParam1, LPARAM lParam2);
UINT WINAPI mmioDescend(HMMIO hmmio, MMCKINFO FAR* lpck,
    const MMCKINFO FAR* lpckParent, UINT uFlags);
UINT WINAPI mmioAscend(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);
UINT WINAPI mmioCreateChunk(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);

#endif  /* ifndef MMNOMMIO */


#ifndef MMNOMCI
/****************************************************************************

                            MCI support

****************************************************************************/

typedef UINT (CALLBACK *YIELDPROC) (UINT uDeviceID, DWORD dwYieldData);

/* MCI function prototypes */
DWORD WINAPI mciSendCommand (UINT uDeviceID, UINT uMessage,
    DWORD dwParam1, DWORD dwParam2);
DWORD WINAPI mciSendString (LPCSTR lpstrCommand,
    LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
UINT WINAPI mciGetDeviceID (LPCSTR lpstrName);
UINT WINAPI mciGetDeviceIDFromElementID (DWORD dwElementID,
    LPCSTR lpstrType);
BOOL WINAPI mciGetErrorString (DWORD wError, LPSTR lpstrBuffer,
    UINT uLength);
BOOL WINAPI mciSetYieldProc (UINT uDeviceID, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if (WINVER >= 0x030a)
HTASK WINAPI mciGetCreatorTask(UINT uDeviceID);
YIELDPROC WINAPI mciGetYieldProc (UINT uDeviceID, DWORD FAR* lpdwYieldData);
#endif /* ifdef WINVER >= 0x030a */

#if (WINVER < 0x030a)
BOOL WINAPI mciExecute (LPCSTR lpstrCommand);
#endif /* ifdef WINVER < 0x030a */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SOUND                       0x0812
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (0x400 + DRV_MCI_FIRST)


/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               0xFFFF

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 (MCI_STRING_OFFSET + 1)
#define MCI_DEVTYPE_VIDEODISC           (MCI_STRING_OFFSET + 2)
#define MCI_DEVTYPE_OVERLAY             (MCI_STRING_OFFSET + 3)
#define MCI_DEVTYPE_CD_AUDIO            (MCI_STRING_OFFSET + 4)
#define MCI_DEVTYPE_DAT                 (MCI_STRING_OFFSET + 5)
#define MCI_DEVTYPE_SCANNER             (MCI_STRING_OFFSET + 6)
#define MCI_DEVTYPE_ANIMATION           (MCI_STRING_OFFSET + 7)
#define MCI_DEVTYPE_DIGITAL_VIDEO       (MCI_STRING_OFFSET + 8)
#define MCI_DEVTYPE_OTHER               (MCI_STRING_OFFSET + 9)
#define MCI_DEVTYPE_WAVEFORM_AUDIO      (MCI_STRING_OFFSET + 10)
#define MCI_DEVTYPE_SEQUENCER           (MCI_STRING_OFFSET + 11)

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
                                                  ((WORD)(s)<<8)) | \
                                                 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
                                                  ((WORD)(m)<<8)) | \
                                                 (((DWORD)(BYTE)(s) | \
                                                   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
                                                  ((WORD)(m)<<8)) | \
                                                 (((DWORD)(BYTE)(s))<<16)))


/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008


/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SOUND command message */
#define MCI_SOUND_NAME                  0x00000100L

/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L

/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS;
typedef MCI_GENERIC_PARMS FAR *LPMCI_GENERIC_PARMS;

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
} MCI_OPEN_PARMS;
typedef MCI_OPEN_PARMS FAR *LPMCI_OPEN_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS;
typedef MCI_PLAY_PARMS FAR *LPMCI_PLAY_PARMS;

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS;
typedef MCI_SEEK_PARMS FAR *LPMCI_SEEK_PARMS;

/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS;
typedef MCI_STATUS_PARMS FAR * LPMCI_STATUS_PARMS;

/* parameter block for MCI_INFO command message */
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS;
typedef MCI_INFO_PARMS FAR * LPMCI_INFO_PARMS;

/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS;
typedef MCI_GETDEVCAPS_PARMS FAR * LPMCI_GETDEVCAPS_PARMS;

/* parameter block for MCI_SYSINFO command message */
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
    UINT    wReserved0;
} MCI_SYSINFO_PARMS;
typedef MCI_SYSINFO_PARMS FAR * LPMCI_SYSINFO_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS;
typedef MCI_SET_PARMS FAR *LPMCI_SET_PARMS;

/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
    int     nVirtKey;
    UINT    wReserved0;
    HWND    hwndBreak;
    UINT    wReserved1;
} MCI_BREAK_PARMS;
typedef MCI_BREAK_PARMS FAR * LPMCI_BREAK_PARMS;

/* parameter block for MCI_SOUND command message */
typedef struct tagMCI_SOUND_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS;
typedef MCI_SOUND_PARMS FAR * LPMCI_SOUND_PARMS;

/* parameter block for MCI_SAVE command message */
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS;
typedef MCI_SAVE_PARMS FAR * LPMCI_SAVE_PARMS;

/* parameter block for MCI_LOAD command message */
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS;
typedef MCI_LOAD_PARMS FAR * LPMCI_LOAD_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS;
typedef MCI_RECORD_PARMS FAR *LPMCI_RECORD_PARMS;


/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
    } MCI_VD_PLAY_PARMS;
typedef MCI_VD_PLAY_PARMS FAR *LPMCI_VD_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS;
typedef MCI_VD_STEP_PARMS FAR *LPMCI_VD_STEP_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS;
typedef MCI_VD_ESCAPE_PARMS FAR *LPMCI_VD_ESCAPE_PARMS;


/* MCI extensions for waveform audio devices */

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS;
typedef MCI_WAVE_OPEN_PARMS FAR *LPMCI_WAVE_OPEN_PARMS;

/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS;
typedef MCI_WAVE_DELETE_PARMS FAR *LPMCI_WAVE_DELETE_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    UINT    wInput;
    UINT    wReserved0;
    UINT    wOutput;
    UINT    wReserved1;
    UINT    wFormatTag;
    UINT    wReserved2;
    UINT    nChannels;
    UINT    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    UINT    nBlockAlign;
    UINT    wReserved4;
    UINT    wBitsPerSample;
    UINT    wReserved5;
} MCI_WAVE_SET_PARMS;
typedef MCI_WAVE_SET_PARMS FAR * LPMCI_WAVE_SET_PARMS;


/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS;
typedef MCI_SEQ_SET_PARMS FAR * LPMCI_SEQ_SET_PARMS;


/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
    UINT    wReserved1;
} MCI_ANIM_OPEN_PARMS;
typedef MCI_ANIM_OPEN_PARMS FAR *LPMCI_ANIM_OPEN_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS;
typedef MCI_ANIM_PLAY_PARMS FAR *LPMCI_ANIM_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS;
typedef MCI_ANIM_STEP_PARMS FAR *LPMCI_ANIM_STEP_PARMS;

/* parameter block for MCI_WINDOW command message */
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    wReserved1;
    UINT    nCmdShow;
    UINT    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS;
typedef MCI_ANIM_WINDOW_PARMS FAR * LPMCI_ANIM_WINDOW_PARMS;

/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;

/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS;
typedef MCI_ANIM_UPDATE_PARMS FAR * LPMCI_ANIM_UPDATE_PARMS;


/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
    UINT    wReserved1;
 } MCI_OVLY_OPEN_PARMS;
typedef MCI_OVLY_OPEN_PARMS FAR *LPMCI_OVLY_OPEN_PARMS;

/* parameter block for MCI_WINDOW command message */
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    wReserved1;
    UINT    nCmdShow;
    UINT    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS;
typedef MCI_OVLY_WINDOW_PARMS FAR * LPMCI_OVLY_WINDOW_PARMS;

/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS;
typedef MCI_OVLY_RECT_PARMS FAR * LPMCI_OVLY_RECT_PARMS;

/* parameter block for MCI_SAVE command message */
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS;
typedef MCI_OVLY_SAVE_PARMS FAR * LPMCI_OVLY_SAVE_PARMS;

/* parameter block for MCI_LOAD command message */
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS;
typedef MCI_OVLY_LOAD_PARMS FAR * LPMCI_OVLY_LOAD_PARMS;

#endif  /* ifndef MMNOMCI */

/****************************************************************************

                        DISPLAY Driver extensions

****************************************************************************/

#ifndef C1_TRANSPARENT
    #define CAPS1           94          /* other caps */
    #define C1_TRANSPARENT  0x0001      /* new raster cap */
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef C1_TRANSPARENT */

/****************************************************************************

                        DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)


/****************************************************************************

                        ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif  /* _INC_MMSYSTEM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\multires.h ===
/************************************************************************/
/*									*/
/*	MultiRes.H							*/
/*									*/
/*		This contains the data structures of the new format 	*/
/*	for the resources;						*/
/*									*/
/*	History:							*/
/*	    Created Nov, 1988  by Sankar				*/
/*									*/
/************************************************************************/



/*  The width of the name field in the Data for the group resources */
#define  NAMELEN    14

/*  The bits per pixel can be 1, 4, 8 or 24 in the PM bitmap format */
#define  MAXBITSPERPIXEL   24

#define  DEVICEDEP   1
#define  DEVICEINDEP 2


/* Header of the resource file in the new format */

struct   tagNEWHEADER
{
	WORD  Reserved;
	WORD  ResType;
	WORD  ResCount;
};

typedef struct tagNEWHEADER  FAR *LPNEWHEADER;

struct   tagICONDIR
{
        BYTE  Width;            /* 16, 32, 64 */
        BYTE  Height;           /* 16, 32, 64 */
        BYTE  ColorCount;       /* 2, 8, 16 */
        BYTE  reserved;
};

struct   tagCURSORDIR
{
	WORD  Width;
	WORD  Height;
};


/*  Structure of each entry in resource directory */

struct  tagRESDIR
{
	union  
	{
	    struct  tagICONDIR  Icon;
	    struct  tagCURSORDIR  Cursor;
	}   ResInfo;

	WORD   Planes;
	WORD   BitCount;
	DWORD  BytesInRes;
        WORD   idIcon; 
};

typedef struct tagRESDIR  FAR *LPRESDIR;

typedef   BITMAPINFOHEADER   *PBMPHEADER;
typedef	  BITMAPINFOHEADER FAR  *LPBMPHEADER;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\mmddk.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   MMDDK.INC - Multimedia assembly language structures & constants
;               for the Development Kit
;
;   Copyright (c) Microsoft Corporation 1990. All rights reserved
;
;
;   If defined, the following flags inhibit inclusion of the indicated items:
;
;        NOTIMERDEV        - The Timer Device
;        NOJOYDEV          - The Joystick Device
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;     If defined, the following flags inhibit inclusion
;     of the indicated items:
; 
;         MMNOMIDIDEV         - MIDI support
;         MMNOWAVEDEV         - Waveform support
;         MMNOAUXDEV          - Auxiliary output support
;         MMNOTIMERDEV        - Timer support
;         MMNOJOYDEV          - Joystick support
;         MMNOMCIDEV          - MCI support
;         MMNOTASKDEV         - Task support
;

OFFSEL	STRUC
Off	dw  ?
Sel	dw  ?
OFFSEL	ENDS

LOHI	STRUC
Lo	dw  ?
Hi	dw  ?
LOHI	ENDS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                      Helper functions for drivers
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DCB_NOSWITCH    equ   0008h           ; don't switch stacks for callback
DCB_TYPEMASK    equ   0007h           ; callback type mask
DCB_NULL        equ   0000h           ; unknown callback type

; flags for wFlags parameter of DriverCallback()
DCB_WINDOW     equ    0001h           ; dwCallback is a HWND
DCB_TASK       equ    0002h           ; dwCallback is a HTASK
DCB_FUNCTION   equ    0003h           ; dwCallback is a FARPROC

; device ID for 386 AUTODMA VxD 
VADMAD_Device_ID    equ    0444h

ifndef	MMNOWAVEDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
;                      Waveform device driver support
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of wave device drivers loaded
MAXWAVEDRIVERS equ    10


; waveform input and output device open information structure
WAVEOPENDESC struc
    wod_hWave         dw    ?        ; handle
    wod_lpFormat      dd    ?        ; format of wave data
    wod_dwCallback    dd    ?        ; callback
    wod_dwInstance    dd    ?        ; app's private instance information
WAVEOPENDESC ends

;  message sent by mmsystem to wodMessage(), widMessage(), modMessage(),
;  and midMessage() when it initializes the wave and midi drivers 

DRVM_USER             equ    4000h
DRVM_INIT             equ    100
WODM_INIT             equ    DRVM_INIT
WIDM_INIT             equ    DRVM_INIT
MODM_INIT             equ    DRVM_INIT
MIDM_INIT             equ    DRVM_INIT
AUXM_INIT             equ    DRVM_INIT

; messages sent to wodMessage() entry-point function
WODM_GETNUMDEVS       equ    3
WODM_GETDEVCAPS       equ    4
WODM_OPEN             equ    5
WODM_CLOSE            equ    6
WODM_PREPARE          equ    7
WODM_UNPREPARE        equ    8
WODM_WRITE            equ    9
WODM_PAUSE            equ    10
WODM_RESTART          equ    11
WODM_RESET            equ    12 
WODM_GETPOS           equ    13
WODM_GETPITCH         equ    14
WODM_SETPITCH         equ    15
WODM_GETVOLUME        equ    16
WODM_SETVOLUME        equ    17
WODM_GETPLAYBACKRATE  equ    18
WODM_SETPLAYBACKRATE  equ    19
WODM_BREAKLOOP        equ    20

; messages sent to widMessage() entry-point function
WIDM_GETNUMDEVS  equ    50
WIDM_GETDEVCAPS  equ    51
WIDM_OPEN        equ    52
WIDM_CLOSE       equ    53
WIDM_PREPARE     equ    54
WIDM_UNPREPARE   equ    55
WIDM_ADDBUFFER   equ    56
WIDM_START       equ    57
WIDM_STOP        equ    58
WIDM_RESET       equ    59
WIDM_GETPOS      equ    60

endif	;ifndef MMNOWAVEDEV


ifndef	MMNOMIDIDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                         MIDI device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of MIDI device drivers loaded
MAXMIDIDRIVERS equ    10

; MIDI input and output device open information structure
MIDIOPENDESC struc
    mod_hMidi         dw    ?        ; handle
    mod_dwCallback    dd    ?        ; callback
    mod_dwInstance    dd    ?        ; app's private instance information
MIDIOPENDESC ends

; messages sent to modMessage() entry-point function
MODM_GETNUMDEVS     equ    1
MODM_GETDEVCAPS     equ    2
MODM_OPEN           equ    3
MODM_CLOSE          equ    4
MODM_PREPARE        equ    5
MODM_UNPREPARE      equ    6
MODM_DATA           equ    7
MODM_LONGDATA       equ    8
MODM_RESET          equ    9
MODM_GETVOLUME      equ    10
MODM_SETVOLUME      equ    11
MODM_CACHEPATCHES       equ    12      
MODM_CACHEDRUMPATCHES   equ    13     

; messages sent to midMessage() entry-point function
MIDM_GETNUMDEVS  equ    53
MIDM_GETDEVCAPS  equ    54
MIDM_OPEN        equ    55
MIDM_CLOSE       equ    56
MIDM_PREPARE     equ    57
MIDM_UNPREPARE   equ    58
MIDM_ADDBUFFER   equ    59
MIDM_START       equ    60
MIDM_STOP        equ    61
MIDM_RESET       equ    62

endif	;ifndef MMNOMIDIDEV


ifndef	MMNOAUXDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   Auxiliary audio device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of auxiliary device drivers loaded
MAXAUXDRIVERS equ    10

; messages sent to auxMessage() entry-point function
AUXDM_GETNUMDEVS    equ    3
AUXDM_GETDEVCAPS    equ    4
AUXDM_GETVOLUME     equ    5
AUXDM_SETVOLUME     equ    6

endif	;ifndef MMNOAUXDEV


ifndef	MMNOTIMERDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Timer device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TIMEREVENT struc
    te_wDelay         dw    ?     ; delay required
    te_wResolution    dw    ?     ; resolution required
    te_lpFunction     dd    ?     ; ptr to callback function
    te_dwUser         dd    ?     ; user DWORD
    te_wFlags         dw    ?     ; defines how to program event
TIMEREVENT ends

; messages sent to tddMessage() function
TDD_KILLTIMEREVENT  equ    DRV_RESERVED+0  ; indices into a table of
TDD_SETTIMEREVENT   equ    DRV_RESERVED+4  ; functions; thus offset by
TDD_GETSYSTEMTIME   equ    DRV_RESERVED+8  ; four each time...
TDD_GETDEVCAPS      equ    DRV_RESERVED+12 ; room for future expansion
TDD_BEGINMINPERIOD  equ    DRV_RESERVED+16 ; room for future expansion
TDD_ENDMINPERIOD    equ    DRV_RESERVED+20 ; room for future expansion

endif	;ifndef MMNOTIMERDEV


ifndef	MMNOJOYDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                      Joystick device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; joystick calibration info structure
JOYCALIBRATE struc
    jcal_wXbase     dw    ?
    jcal_wXdelta    dw    ?
    jcal_wYbase     dw    ?
    jcal_wYdelta    dw    ?
    jcal_wZbase     dw    ?
    jcal_wZdelta    dw    ?
JOYCALIBRATE ends

; messages sent to joystick driver's DriverProc() function
JDD_GETNUMDEVS      equ    DRV_RESERVED+0001h
JDD_GETDEVCAPS      equ    DRV_RESERVED+0002h
JDD_GETPOS          equ    DRV_RESERVED+0101h
JDD_SETCALIBRATION  equ    DRV_RESERVED+0102h

endif	;ifndef MMNOJOYDEV


ifndef	MMNOMCIDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       MCI device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; internal MCI messages
MCI_OPEN_DRIVER             equ    0801h
MCI_CLOSE_DRIVER            equ    0802h

MAKEMCIRESOURCE MACRO a,b
        mov     ax,a
        mov     dx,b
        ENDM

; string return values only used with MAKEMCIRESOURCE
MCI_FALSE                       equ    (MCI_STRING_OFFSET + 19)
MCI_TRUE                        equ    (MCI_STRING_OFFSET + 20)

; resource string return values
MCI_FORMAT_RETURN_BASE          equ    MCI_FORMAT_MILLISECONDS_S
MCI_FORMAT_MILLISECONDS_S       equ    (MCI_STRING_OFFSET + 21)
MCI_FORMAT_HMS_S                equ    (MCI_STRING_OFFSET + 22)
MCI_FORMAT_MSF_S                equ    (MCI_STRING_OFFSET + 23)
MCI_FORMAT_FRAMES_S             equ    (MCI_STRING_OFFSET + 24)
MCI_FORMAT_SMPTE_24_S           equ    (MCI_STRING_OFFSET + 25)
MCI_FORMAT_SMPTE_25_S           equ    (MCI_STRING_OFFSET + 26)
MCI_FORMAT_SMPTE_30_S           equ    (MCI_STRING_OFFSET + 27)
MCI_FORMAT_SMPTE_30DROP_S       equ    (MCI_STRING_OFFSET + 28)
MCI_FORMAT_BYTES_S              equ    (MCI_STRING_OFFSET + 29)
MCI_FORMAT_SAMPLES_S            equ    (MCI_STRING_OFFSET + 30)
MCI_FORMAT_TMSF_S               equ    (MCI_STRING_OFFSET + 31)

MCI_VD_FORMAT_TRACK_S           equ    (MCI_VD_OFFSET + 5)

WAVE_FORMAT_PCM_S               equ    (MCI_WAVE_OFFSET + 0)
WAVE_MAPPER_S                   equ    (MCI_WAVE_OFFSET + 1)

MCI_SEQ_MAPPER_S                equ    (MCI_SEQ_OFFSET + 5)
MCI_SEQ_FILE_S                  equ    (MCI_SEQ_OFFSET + 6)
MCI_SEQ_MIDI_S                  equ    (MCI_SEQ_OFFSET + 7)
MCI_SEQ_SMPTE_S                 equ    (MCI_SEQ_OFFSET + 8)
MCI_SEQ_FORMAT_SONGPTR_S        equ    (MCI_SEQ_OFFSET + 9)
MCI_SEQ_NONE_S                  equ    (MCI_SEQ_OFFSET + 10)
MIDIMAPPER_S                    equ    (MCI_SEQ_OFFSET + 11)

; parameters for internal version of MCI_OPEN message sent from
; mciOpenDevice() to the driver
MCI_OPEN_DRIVER_PARMS struc
    mciodrv_wDeviceID           dw    ? ; device ID
    mciodrv_lpstrParams         dw    ? ; parameter string for entry in SYSTEM.INI
    mciodrv_wCustomCommandTable dw    ? ; custom command table (0FFFFh if none)
                                        ; filled in by the driver
    mciodrv_wType               dw    ? ; driver type filled in by the driver
MCI_OPEN_DRIVER_PARMS ends

; maximum length of an MCI device type
MCI_MAX_DEVICE_TYPE_LENGTH equ    80

; flags for mciSendCommandInternal() which direct mciSendString() how to
; interpret the return value
MCI_RESOURCE_RETURNED       equ    00010000h  ; resource ID
MCI_COLONIZED3_RETURN       equ    00020000h  ; colonized ID, 3 bytes data
MCI_COLONIZED4_RETURN       equ    00040000h  ; colonized ID, 4 bytes data
MCI_INTEGER_RETURNED        equ    00080000h  ; integer conversion needed
MCI_RESOURCE_DRIVER         equ    00100000h  ; driver owns returned resource

; invalid command table ID
MCI_NO_COMMAND_TABLE    equ    0FFFFh

; command table information type tags
MCI_COMMAND_HEAD        equ    0
MCI_STRING              equ    1
MCI_INTEGER             equ    2
MCI_END_COMMAND         equ    3
MCI_RETURN              equ    4
MCI_FLAG                equ    5
MCI_END_COMMAND_LIST    equ    6
MCI_RECT                equ    7
MCI_CONSTANT            equ    8
MCI_END_CONSTANT        equ    9

endif	;ifndef MMNOMCIDEV


ifndef	MMNOTASKDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                              Task support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; error return values
TASKERR_NOTASKSUPPORT equ    1
TASKERR_OUTOFMEMORY   equ    2

endif	;ifndef MMNOTASKDEV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\prd.inc ===
NAME_LEN    equ 32
BLOCK_SIZE  equ 512
DEV_PRD     equ 8888h
DEV_PORT    equ 8888h
DEV_LAND    equ 8889h

HSIZE       equ 8d              ;HorzSize
VSIZE       equ 11d             ;VertSize
VSIZE_LEGAL equ 14d             ;VertSize

MM_HSIZE    equ 203             ;Horizontal size in millimeter
MM_HSIZE0   equ 2032
MM_HSIZE00  equ 20320
MM_VSIZE    equ 279             ;Vertical size in millimeter
MM_VSIZE0   equ 2794
MM_VSIZE00  equ 27940
MM_VSIZE_LEGAL      equ 356             ;Vertical size in millimeter
MM_VSIZE0_LEGAL     equ 3556
MM_VSIZE00_LEGAL    equ 35560

EnglishLo1  equ 800             ;HorzSize * 1000 scaled (/254)
EnglishLo2  equ 1100            ;VertSize * 1000 scaled (/254)

EnglishHi1  equ  8000           ;HorzSize * 10000 scaled (/254)
EnglishHi2  equ  11000          ;VertSize * 10000 scaled (/254)
EnglishHi3  equ  EnglishLo3
EnglishHi4  equ  EnglishLo4

Twips1      equ  11520          ;HorzSize * 14400 scaled (/254)
Twips2      equ  15840          ;VertSize * 14400 scaled (/254)
Twips3      equ  EnglishLo3
Twips4      equ  EnglishLo4

EnglishLo2_LEGAL equ 1400
EnglishHi2_LEGAL  equ  14000          ;VertSize * 10000 scaled (/254)
EnglishHi4_LEGAL  equ  EnglishLo4_LEGAL

Twips2_LEGAL equ  20160
Twips4_LEGAL equ  EnglishLo4_LEGAL

yMinorDist   =  Hypotenuse-xMajorDist
xMinorDist   =  Hypotenuse-yMajorDist

MaxStyleErr  =  Hypotenuse*2    ;Max error before updating
                                ;rotating bit mask

DEVICE  struc
    deType      dw      0       ;
    deMode      dw      0       ;
    deJob       dw      0       ;job number
    deWheel     dw      0       ;font wheel number
    dePtr       dw      0       ;spooler buffer pointer
    deYPQ       dw      0
    deXPQ       dw      0
    deCurx      dw      0
    deCury      dw      0
    deXcurwidth dw      0
    deYcurwidth dw      0
    deDoc       dw      0       ;job spooled as a document or by the page
    deHeap      dw      0
    deHPsize    dw      0
    deHPptr     dw      0
    dePhySize   dd      0
DEVICE  ends

BUFFER      struc
  dePort        db      NAME_LEN     dup (?); port name
  deSpool       db      BLOCK_SIZE   dup (?)
BUFFER      ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\penwin.h ===
/*****************************************************************************\
*                                                                             *
* penwin.h -    Pen Windows functions, types, and definitions                 *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWS
#include <windows.h>    /* <windows.h> must be pre-included */
#endif /* _INC_WINDOWS */

#ifndef _INC_PENWIN     /* prevent multiple includes */
#define _INC_PENWIN

#ifndef RC_INVOKED
#pragma pack(1)
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {
#endif	/* __cplusplus */

/****** General Pen Windows Definitions *************************************/

typedef int                    REC;    
typedef LONG                   SYV;    
typedef SYV FAR                *LPSYV;
typedef HANDLE                 HREC;
typedef int                    CL;
typedef LONG                   ALC;
typedef UINT                   HKP;
typedef int (CALLBACK * LPDF)(int, LPVOID, LPVOID, int, DWORD, DWORD);

#define BITPENUP               0x8000
#define FPenUpX(x)             (((x) & BITPENUP)!=0)

/* Default pen cursor to indicate writing, points northwest */
#define IDC_PEN                MAKEINTRESOURCE(32631)

/* alternate select cursor: upsidedown standard arrow, points southeast */
#define IDC_ALTSELECT          MAKEINTRESOURCE(32501)

#define RC_WDEFAULT            (0xFFFF)
#define RC_LDEFAULT            (0xFFFFFFFFL)
#define RC_WDEFAULTFLAGS       (0x8000)
#define RC_LDEFAULTFLAGS       (0x80000000L)

/* HIWORD(SYV) defines and detection macros */

#define SYVHI_SPECIAL          0
#define FIsSpecial(syv)        (HIWORD((syv))==SYVHI_SPECIAL)
#define SYVHI_ANSI             1
#define FIsAnsi(syv)           (HIWORD((syv))==SYVHI_ANSI)
#define SYVHI_GESTURE          2
#define FIsGesture(syv)        (HIWORD((syv))==SYVHI_GESTURE)
#define SYVHI_KANJI            3
#define FIsKanji(syv)          (HIWORD((syv))==SYVHI_KANJI)
#define SYVHI_SHAPE            4
#define FIsShape(syv)          (HIWORD((syv))==SYVHI_SHAPE)
#define SYVHI_UNICODE          5
#define FIsUniCode(syv)        (HIWORD((syv))==SYVHI_UNICODE)
#define SYVHI_VKEY             6
#define FIsVKey(syv)           (HIWORD((syv))==SYVHI_VKEY)

/* Macros to convert between SYV and ANSI */

#define ChSyvToAnsi(syv)       ((BYTE) (LOBYTE(LOWORD((syv)))))
#define SyvCharacterToSymbol(c) ((LONG)(unsigned char)(c) | 0x00010000)
#define SyvKanjiToSymbol(c) ((LONG)(WORD)(c) | 0x00030000)

/* SYV values with special meanings to Pen Windows */

#define SYV_NULL               0x00000000L
#define SYV_UNKNOWN            0x00000001L
#define SYV_EMPTY              0x00000003L
#define SYV_BEGINOR            0x00000010L
#define SYV_ENDOR              0x00000011L
#define SYV_OR                 0x00000012L
#define SYV_SOFTNEWLINE        0x00000020L
#define SYV_SPACENULL          SyvCharacterToSymbol('\0')

/* SYV values for gestures (map into UNICODE space) */

#define SYV_KKCONVERT          0x0002FFD4L
#define SYV_CLEAR              0x0002FFD5L
#define SYV_EXTENDSELECT       0x0002FFD8L
#define SYV_UNDO               0x0002FFD9L
#define SYV_COPY               0x0002FFDAL
#define SYV_CUT                0x0002FFDBL
#define SYV_PASTE              0x0002FFDCL
#define SYV_CLEARWORD          0x0002FFDDL
#define SYV_USER               0x0002FFDEL	/* ;Reserved */
#define SYV_CORRECT            0x0002FFDFL

#define SYV_BACKSPACE          0x00020008L
#define SYV_TAB                0x00020009L
#define SYV_RETURN             0x0002000DL
#define SYV_SPACE              0x00020020L

#define FIsStdGesture(syv)     \
     ((syv) == SYV_CLEAR       \
   || (syv) == SYV_EXTENDSELECT\
   || (syv) == SYV_UNDO        \
   || (syv) == SYV_COPY        \
   || (syv) == SYV_CUT         \
   || (syv) == SYV_PASTE       \
   || (syv) == SYV_CLEARWORD   \
   || (syv) == SYV_KKCONVERT   \
   || (syv) == SYV_USER        \
   || (syv) == SYV_CORRECT)

#define FIsAnsiGesture(syv)    \
     ((syv) == SYV_BACKSPACE   \
   || (syv) == SYV_TAB         \
   || (syv) == SYV_RETURN      \
   || (syv) == SYV_SPACE)

/* Application specific gestures, Circle a-z and Circle A-Z */

#define SYV_APPGESTUREMASK     0x00020000L
#define SYV_CIRCLEUPA          0x000224B6L
#define SYV_CIRCLEUPZ          0x000224CFL
#define SYV_CIRCLELOA          0x000224D0L
#define SYV_CIRCLELOZ          0x000224E9L

/* Gesture Macros */

#define FIsLoAppGesture(syv)   (syv >= SYV_CIRCLELOA && syv <= SYV_CIRCLELOZ)
#define FIsUpAppGesture(syv)   (syv >= SYV_CIRCLEUPA && syv <= SYV_CIRCLEUPZ)
#define FIsAppGesture(syv)     (syv>=SYV_CIRCLEUPA && syv<=SYV_CIRCLELOZ)

#define SyvAppGestureFromLoAnsi(ansi) ((DWORD)(BYTE)ansi- 'a' + SYV_CIRCLELOA)
#define SyvAppGestureFromUpAnsi(ansi) ((DWORD)(BYTE)ansi- 'A' + SYV_CIRCLEUPA)
#define AnsiFromSyvAppGesture(syv) ChSyvToAnsi( \
    syv-(FIsUpAppGesture(syv)? SYV_CIRCLEUPA-(SYV)'A': SYV_CIRCLELOA-(SYV)'a'))

/* SYV definitions for shapes */

#define SYV_SHAPELINE          0x00040001L
#define SYV_SHAPEELLIPSE       0x00040002L
#define SYV_SHAPERECT          0x00040003L
#define SYV_SHAPEMIN           SYV_SHAPELINE
#define SYV_SHAPEMAX           SYV_SHAPERECT

/****** Recognition Error Codes *********************************************/

#define REC_OEM                (-1024)
#define REC_LANGUAGE           (-48)
#define REC_GUIDE              (-47)
#define REC_PARAMERROR         (-46)
#define REC_INVALIDREF         (-45)
#define REC_RECTEXCLUDE        (-44)
#define REC_RECTBOUND          (-43)
#define REC_PCM                (-42)
#define REC_RESULTMODE         (-41)
#define REC_HWND               (-40)
#define REC_ALC                (-39)
#define REC_ERRORLEVEL         (-38)
#define REC_CLVERIFY           (-37)
#define REC_DICT               (-36)
#define REC_HREC               (-35)
#define REC_BADEVENTREF        (-33)
#define REC_NOCOLLECTION       (-32)

#define REC_DEBUG              (-32)    

#define REC_POINTEREVENT       (-31)
#define REC_BADHPENDATA        (-9)    
#define REC_OOM                (-8)
#define REC_NOINPUT            (-7)
#define REC_NOTABLET           (-6)
#define REC_BUSY               (-5)
#define REC_BUFFERTOOSMALL     (-4)
#define REC_ABORT              (-3)

#define REC_OVERFLOW           (-1)

#define REC_OK                 0
#define REC_TERMBOUND          1
#define REC_TERMEX             2
#define REC_TERMPENUP          3
#define REC_TERMRANGE          4
#define REC_TERMTIMEOUT        5
#define REC_DONE               6
#define REC_TERMOEM            512

/****** Pen Driver Structures and Entry points ******************************/

typedef struct tagOEMPENINFO
   {
   UINT wPdt;
   UINT wValueMax;
   UINT wDistinct;
   }
   OEMPENINFO, FAR *LPOEMPENINFO;

#define PDT_NULL               0
#define PDT_PRESSURE           1
#define PDT_HEIGHT             2
#define PDT_ANGLEXY            3
#define PDT_ANGLEZ             4
#define PDT_BARRELROTATION     5
#define PDT_OEMSPECIFIC        16

#define MAXOEMDATAWORDS        6

typedef struct tagPENPACKET
   {
   UINT wTabletX;
   UINT wTabletY;
   UINT wPDK;
   UINT rgwOemData[MAXOEMDATAWORDS];
   }
   PENPACKET, FAR *LPPENPACKET;

typedef BOOL (CALLBACK * LPFNRAWHOOK)(LPPENPACKET);

typedef struct tagPENINFO
   {
   UINT cxRawWidth;       
   UINT cyRawHeight;       
   UINT wDistinctWidth;   
   UINT wDistinctHeight;  
   int nSamplingRate; 
   int nSamplingDist; 
   LONG lPdc;        
   int cPens;        
   int cbOemData;    
   OEMPENINFO rgoempeninfo[MAXOEMDATAWORDS];  
   UINT rgwReserved[8];     
   }
   PENINFO, FAR *LPPENINFO;

#define PDC_INTEGRATED         0x00000001L
#define PDC_PROXIMITY          0x00000002L
#define PDC_RANGE              0x00000004L
#define PDC_INVERT             0x00000008L
#define PDC_RELATIVE           0x00000010L
#define PDC_BARREL1            0x00000020L
#define PDC_BARREL2            0x00000040L
#define PDC_BARREL3            0x00000080L

typedef struct tagSTROKEINFO
   {
   UINT cPnt;        
   UINT cbPnts;    
   UINT wPdk;        
   DWORD dwTick;    
   }
   STROKEINFO, FAR *LPSTROKEINFO;

typedef struct tagCALBSTRUCT
   {
   int wOffsetX;
   int wOffsetY;
   int wDistinctWidth;
   int wDistinctHeight;
   }
   CALBSTRUCT, FAR *LPCALBSTRUCT;

/****** DRV_ values for pen driver specific messages ************************/

#define DRV_SetPenDriverEntryPoints    DRV_RESERVED+1
#define DRV_RemovePenDriverEntryPoints DRV_RESERVED+2
#define DRV_SetPenSamplingRate         DRV_RESERVED+3
#define DRV_SetPenSamplingDist         DRV_RESERVED+4
#define DRV_GetName                    DRV_RESERVED+5
#define DRV_GetVersion                 DRV_RESERVED+6
#define DRV_GetPenInfo                 DRV_RESERVED+7
#define DRV_GetCalibration             DRV_RESERVED+11
#define DRV_SetCalibration             DRV_RESERVED+12

VOID WINAPI UpdatePenInfo(LPPENINFO);
BOOL WINAPI EndPenCollection(REC);
REC  WINAPI GetPenHwData(LPPOINT, LPVOID, int, UINT, LPSTROKEINFO);
REC  WINAPI GetPenHwEventData(UINT, UINT, LPPOINT, LPVOID, int, LPSTROKEINFO);
VOID WINAPI PenPacket(VOID);
BOOL WINAPI SetPenHook(HKP, LPFNRAWHOOK);

/****** Pen Hardware Constants **********************************************/

#define PDK_UP                 0x0000    
#define PDK_DOWN               0x0001    
#define PDK_BARREL1            0x0002    
#define PDK_BARREL2            0x0004    
#define PDK_BARREL3            0x0008    
#define PDK_TRANSITION         0x0010    
#define PDK_INVERTED           0x0080    
#define PDK_OUTOFRANGE         0x4000    
#define PDK_DRIVER             0x8000    
#define PDK_TIPMASK            0x0001    
#define PDK_SWITCHES           (PDK_DOWN|PDK_BARREL1|PDK_BARREL2|PDK_BARREL3)

#define PCM_PENUP              0x00000001L
#define PCM_RANGE              0x00000002L
#define PCM_INVERT             0x00000020L
#define PCM_RECTEXCLUDE        0x00002000L
#define PCM_RECTBOUND          0x00004000L
#define PCM_TIMEOUT            0x00008000L
#define PCM_ADDDEFAULTS        RC_LDEFAULTFLAGS /* 0x80000000L */

/****** Virtual Event Layer *************************************************/

VOID WINAPI PostVirtualKeyEvent(UINT, BOOL);
VOID WINAPI PostVirtualMouseEvent(UINT, int, int);
VOID WINAPI AtomicVirtualEvent(BOOL);

#define VWM_MOUSEMOVE          0x0001
#define VWM_MOUSELEFTDOWN      0x0002
#define VWM_MOUSELEFTUP        0x0004
#define VWM_MOUSERIGHTDOWN     0x0008
#define VWM_MOUSERIGHTUP       0x0010

/****** RC Definition *************************************************************/

#define CL_NULL                0
#define CL_MINIMUM             1
#define CL_MAXIMUM             100
#define INKWIDTH_MINIMUM       0
#define INKWIDTH_MAXIMUM       15
#define ENUM_MINIMUM           1
#define ENUM_MAXIMUM           4096
#define MAXDICTIONARIES        16

typedef struct tagGUIDE
   {
   int xOrigin;    
   int yOrigin;
   int cxBox;
   int cyBox;
   int cxBase;
   int cyBase;
   int cHorzBox;
   int cVertBox;
   int cyMid;
   }
   GUIDE, FAR *LPGUIDE;

typedef BOOL (CALLBACK * RCYIELDPROC)(VOID);

#define cbRcLanguageMax        44
#define cbRcUserMax            32
#define cbRcrgbfAlcMax         32
#define cwRcReservedMax        8

typedef struct tagRC
   {
   HREC hrec;
   HWND hwnd;
   UINT wEventRef;        
   UINT wRcPreferences;
   LONG lRcOptions;
   RCYIELDPROC lpfnYield;
   BYTE lpUser[cbRcUserMax];
   UINT wCountry;
   UINT wIntlPreferences;
   char lpLanguage[cbRcLanguageMax];
   LPDF rglpdf[MAXDICTIONARIES];
   UINT wTryDictionary;
   CL clErrorLevel;
   ALC alc;
   ALC alcPriority;
   BYTE rgbfAlc[cbRcrgbfAlcMax];
   UINT wResultMode;
   UINT wTimeOut;
   LONG lPcm;
   RECT rectBound;
   RECT rectExclude;
   GUIDE guide;
   UINT wRcOrient;
   UINT wRcDirect;
   int nInkWidth;
   COLORREF rgbInk;
   DWORD dwAppParam;
   DWORD dwDictParam;
   DWORD dwRecognizer;
   UINT rgwReserved[cwRcReservedMax];
   }
   RC, FAR *LPRC;

typedef HANDLE HPENDATA;

typedef struct tagSYC
   {
   UINT wStrokeFirst;
   UINT wPntFirst;
   UINT wStrokeLast;
   UINT wPntLast;
   BOOL fLastSyc;
   }
   SYC, FAR *LPSYC;
    
#define wPntAll                (UINT)0xFFFF
#define iSycNull               (-1)

typedef struct tagSYE
   {
   SYV syv;
   LONG lRecogVal;
   CL cl;
   int iSyc;
   }
   SYE, FAR *LPSYE;

#define MAXHOTSPOT             8

typedef struct tagSYG
   {
   POINT rgpntHotSpots[MAXHOTSPOT];
   int cHotSpot;
   int nFirstBox;
   LONG lRecogVal;
   LPSYE lpsye;
   int cSye;
   LPSYC lpsyc;
   int cSyc;
   }
   SYG, FAR *LPSYG;

typedef int (CALLBACK *ENUMPROC)(LPSYV, int, VOID FAR *);

typedef struct tagRCRESULT
   {
   SYG syg;
   UINT wResultsType;
   int cSyv;
   LPSYV lpsyv;
   HANDLE hSyv;
   int nBaseLine;
   int nMidLine;
   HPENDATA hpendata;
   RECT rectBoundInk;
   POINT pntEnd;
   LPRC lprc;
   }
   RCRESULT, FAR *LPRCRESULT;

#define RCRT_DEFAULT           0x0000
#define RCRT_UNIDENTIFIED      0x0001 
#define RCRT_GESTURE           0x0002 
#define RCRT_NOSYMBOLMATCH     0x0004    
#define RCRT_PRIVATE           0x4000 
#define RCRT_NORECOG           0x8000 
#define RCRT_ALREADYPROCESSED  0x0008   
#define RCRT_GESTURETRANSLATED 0x0010 
#define RCRT_GESTURETOKEYS     0x0020 

#define HKP_SETHOOK            0
#define HKP_UNHOOK             0xFFFF
#define HWR_RESULTS            0
#define HWR_APPWIDE            1

#define PEN_NOINKWIDTH         0
#define LPDFNULL               ((LPDF)NULL)

#define RPA_DEFAULT            1

/* GetGlobalRC return codes */
#define GGRC_OK                0
#define GGRC_DICTBUFTOOSMALL   1
#define GGRC_PARAMERROR        2

/* SetGlobalRC return code flags */
#define SGRC_OK                0x0000
#define SGRC_USER              0x0001
#define SGRC_PARAMERROR        0x0002
#define SGRC_RC                0x0004
#define SGRC_RECOGNIZER        0x0008
#define SGRC_DICTIONARY        0x0010
#define SGRC_INIFILE           0x0020

#define GetWEventRef()         (LOWORD(GetMessageExtraInfo()))

HREC WINAPI InstallRecognizer(LPSTR);
VOID WINAPI UninstallRecognizer(HREC);
UINT WINAPI GetGlobalRC(LPRC, LPSTR, LPSTR, int);
UINT WINAPI SetGlobalRC(LPRC, LPSTR, LPSTR);
VOID WINAPI RegisterPenApp(UINT, BOOL);
UINT WINAPI IsPenAware(VOID);
BOOL WINAPI SetRecogHook(UINT, UINT, HWND);
VOID WINAPI InitRC(HWND, LPRC);
REC  WINAPI Recognize(LPRC);
REC  WINAPI RecognizeData(LPRC, HPENDATA);
BOOL WINAPI TrainInk(LPRC, HPENDATA, LPSYV);
BOOL WINAPI TrainContext(LPRCRESULT, LPSYE, int, LPSYC, int);
REC  WINAPI ProcessWriting(HWND, LPRC);    
BOOL WINAPI CorrectWriting(HWND, LPSTR, UINT, LPRC, DWORD, DWORD);
VOID WINAPI EmulatePen(BOOL);
int  WINAPI GetSymbolMaxLength(LPSYG);
int  WINAPI GetSymbolCount(LPSYG);
VOID WINAPI FirstSymbolFromGraph(LPSYG, LPSYV, int, int FAR *);
UINT WINAPI EnumSymbols(LPSYG, WORD, ENUMPROC, LPVOID);

/****** Miscellaneous Functions *********************************************/

BOOL WINAPI TPtoDP(LPPOINT, int);
BOOL WINAPI DPtoTP(LPPOINT, int);
VOID WINAPI BoundingRectFromPoints(LPPOINT, int, LPRECT);
BOOL WINAPI SymbolToCharacter(LPSYV, int, LPSTR, LPINT);
int  WINAPI CharacterToSymbol(LPSTR, int, LPSYV);
UINT WINAPI GetVersionPenWin(VOID);
BOOL WINAPI ExecuteGesture(HWND, SYV, LPRCRESULT);

/****** RC Options and Flags  ***********************************************/

#define ALC_ALL                0x000043FFL
#define ALC_DEFAULT            0x00000000L
#define ALC_LCALPHA            0x00000001L
#define ALC_UCALPHA            0x00000002L
#define ALC_ALPHA              0x00000003L
#define ALC_NUMERIC            0x00000004L
#define ALC_ALPHANUMERIC       0x00000007L
#define ALC_PUNC               0x00000008L
#define ALC_MATH               0x00000010L
#define ALC_MONETARY           0x00000020L
#define ALC_OTHER              0x00000040L
#define ALC_WHITE              0x00000100L
#define ALC_NONPRINT           0x00000200L
#define ALC_GESTURE            0x00004000L
#define ALC_USEBITMAP          0x00008000L
#define ALC_DBCS               0x00000400L
#define ALC_HIRAGANA           0x00010000L
#define ALC_KATAKANA           0x00020000L
#define ALC_KANJI              0x00040000L
#define ALC_OEM                0x0FF80000L
#define ALC_RESERVED           0xF0003800L
#define ALC_NOPRIORITY         0x00000000L
#define ALC_SYSMINIMUM (ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE | ALC_GESTURE)

#define MpAlcB(lprc,i) ((lprc)->rgbfAlc[((i) & 0xff) >> 3])
#define MpIbf(i)       ((BYTE)(1 << ((i) & 7)))

#define SetAlcBitAnsi(lprc,i)      do {MpAlcB(lprc,i) |= MpIbf(i);} while (0)
#define ResetAlcBitAnsi(lprc,i)    do {MpAlcB(lprc,i) &= ~MpIbf(i);} while (0)
#define IsAlcBitAnsi(lprc, i)      ((MpAlcB(lprc,i) & MpIbf(i)) != 0)

#define RCD_DEFAULT            0
#define RCD_LR                 1
#define RCD_RL                 2
#define RCD_TB                 3
#define RCD_BT                 4

#define RCO_NOPOINTEREVENT     0x00000001L
#define RCO_SAVEALLDATA        0x00000002L
#define RCO_SAVEHPENDATA       0x00000004L
#define RCO_NOFLASHUNKNOWN     0x00000008L
#define RCO_TABLETCOORD        0x00000010L
#define RCO_NOSPACEBREAK       0x00000020L
#define RCO_NOHIDECURSOR       0x00000040L
#define RCO_NOHOOK             0x00000080L
#define RCO_BOXED              0x00000100L
#define RCO_SUGGEST            0x00000200L
#define RCO_DISABLEGESMAP      0x00000400L
#define RCO_NOFLASHCURSOR      0x00000800L
#define RCO_COLDRECOG          0x00008000L

#define RCP_LEFTHAND           0x0001
#define RCP_MAPCHAR            0x0004

#define RCOR_NORMAL            1
#define RCOR_RIGHT             2
#define RCOR_UPSIDEDOWN        3
#define RCOR_LEFT              4

#define RRM_STROKE             0
#define RRM_SYMBOL             1
#define RRM_WORD               2
#define RRM_NEWLINE            3
#define RRM_COMPLETE           16

#define RCIP_ALLANSICHAR       0x0001
#define RCIP_MASK              0x0001

#define CWR_STRIPCR            0x00000001L
#define CWR_STRIPLF            0x00000002L
#define CWR_STRIPTAB           0x00000004L
#define CWR_SINGLELINEEDIT     0x00000007L
#define CWR_TITLE              0x00000010L
#define CWR_KKCONVERT          0x00000020L

#define MAP_GESTOGES				(RCRT_GESTURE|RCRT_GESTURETRANSLATED)
#define MAP_GESTOVKEYS			(RCRT_GESTURETOKEYS|RCRT_ALREADYPROCESSED)

#define IsGestureToGesture(lprcresult)	(((lprcresult)->wResultstype & MAP_GESTOGES \
													 ) == MAP_GESTOGES)

#define IsGestureToVkeys(lprcresult)	(((lprcresult)->wResultstype & MAP_GESTOVKEYS \
													 ) == MAP_GESTOVKEYS)

#define SetAlreadyProcessed(lprcresult) ((lprcresult)->wResultsType = ((lprcresult)->wResultsType \
														& ~RCRT_GESTURETOKEYS) | RCRT_ALREADYPROCESSED)

/****** Pen Data Type *******************************************************/

typedef struct tagPENDATAHEADER
   {
   UINT wVersion;
   UINT cbSizeUsed;        
   UINT cStrokes;          
   UINT cPnt;              
   UINT cPntStrokeMax;
   RECT rectBound;
   UINT wPndts;            
   int  nInkWidth;
   DWORD rgbInk;
   }
   PENDATAHEADER, FAR *LPPENDATAHEADER, FAR *LPPENDATA;

#define PDTS_LOMETRIC          0x0000
#define PDTS_HIMETRIC          0x0001
#define PDTS_HIENGLISH         0x0002
#define PDTS_SCALEMAX          0x0003
#define PDTS_DISPLAY           0x0003
#define PDTS_ARBITRARY         0x0004
#define PDTS_SCALEMASK         0x000F
#define PDTS_STANDARDSCALE     PDTS_HIENGLISH 

#define PDTS_NOPENINFO         0x0100  
#define PDTS_NOUPPOINTS        0x0200  
#define PDTS_NOOEMDATA         0x0400
#define PDTS_NOCOLINEAR        0x0800  
#define PDTS_COMPRESSED        0x8000
#define PDTS_COMPRESSMETHOD    0x00F0  
#define PDTS_COMPRESS2NDDERIV  0x0010 

#define PDTT_DEFAULT           0x0000         
#define PDTT_PENINFO           PDTS_NOPENINFO 
#define PDTT_UPPOINTS          PDTS_NOUPPOINTS
#define PDTT_OEMDATA           PDTS_NOOEMDATA
#define PDTT_COLINEAR          PDTS_NOCOLINEAR 
#define PDTT_COMPRESS          PDTS_COMPRESSED
#define PDTT_DECOMPRESS        0x4000
#define PDTT_ALL (PDTT_PENINFO|PDTT_UPPOINTS|PDTT_OEMDATA|PDTT_COLINEAR)

#define DestroyPenData(hpendata) (GlobalFree(hpendata)==NULL)
#define EndEnumStrokes(hpendata) GlobalUnlock(hpendata)

BOOL WINAPI IsPenEvent(UINT, LONG);
BOOL WINAPI GetPenAsyncState(UINT);

BOOL WINAPI GetPenDataInfo(HPENDATA, LPPENDATAHEADER, LPPENINFO, DWORD);
BOOL WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR *, LPVOID FAR *, LPSTROKEINFO );
BOOL WINAPI GetPointsFromPenData(HPENDATA, UINT, UINT, UINT, LPPOINT);
VOID WINAPI DrawPenData(HDC, LPRECT, HPENDATA);
BOOL WINAPI MetricScalePenData(HPENDATA, UINT);
BOOL WINAPI ResizePenData(HPENDATA, LPRECT);
BOOL WINAPI OffsetPenData(HPENDATA, int, int);
BOOL WINAPI RedisplayPenData(HDC, HPENDATA, LPPOINT, LPPOINT, int, DWORD);
HPENDATA  WINAPI CompactPenData(HPENDATA, UINT );
HPENDATA  WINAPI DuplicatePenData(HPENDATA, UINT);
HPENDATA  WINAPI CreatePenData(LPPENINFO, int, UINT, UINT); 
HPENDATA  WINAPI AddPointsPenData(HPENDATA, LPPOINT, LPVOID, LPSTROKEINFO);
LPPENDATA WINAPI BeginEnumStrokes(HPENDATA );

/****** New Windows Messages ************************************************/

#define WM_RCRESULT            (WM_PENWINFIRST+1)
#define WM_HOOKRCRESULT        (WM_PENWINFIRST+2)
#define WM_GLOBALRCCHANGE      (WM_PENWINFIRST+3)
#define WM_SKB                 (WM_PENWINFIRST+4)
#define WM_HEDITCTL            (WM_PENWINFIRST+5)

/****** Dictionary **********************************************************/

#define cbDictPathMax          255
#define DIRQ_QUERY             1
#define DIRQ_DESCRIPTION       2
#define DIRQ_CONFIGURE         3
#define DIRQ_OPEN              4
#define DIRQ_CLOSE             5
#define DIRQ_SETWORDLISTS      6
#define DIRQ_STRING            7
#define DIRQ_SUGGEST           8
#define DIRQ_ADD               9
#define DIRQ_DELETE            10
#define DIRQ_FLUSH             11
#define DIRQ_RCCHANGE          12
#define DIRQ_SYMBOLGRAPH       13
#define DIRQ_INIT					 14
#define DIRQ_CLEANUP				 15
#define DIRQ_COPYRIGHT			 16


#define DIRQ_USER              4096

BOOL WINAPI DictionarySearch(LPRC, LPSYE, int, LPSYV, int);

/****** Handwriting Edit Control ********************************************/

#define HE_GETRC               3
#define HE_SETRC               4
#define HE_GETINFLATE          5
#define HE_SETINFLATE          6
#define HE_GETUNDERLINE        7
#define HE_SETUNDERLINE        8
#define HE_GETINKHANDLE        9
#define HE_SETINKMODE          10
#define HE_STOPINKMODE         11
#define HE_GETRCRESULTCODE     12
#define HE_DEFAULTFONT         13
#define HE_CHARPOSITION        14
#define HE_CHAROFFSET          15

#define HE_GETRCRESULT         22

#define HE_KKCONVERT           30
#define HE_GETKKCONVERT        31
#define HE_CANCELKKCONVERT     32
#define HE_FIXKKCONVERT        33

#define HEKK_DEFAULT           0
#define HEKK_CONVERT           1
#define HEKK_CANDIDATE         2

#define HEP_NORECOG            0
#define HEP_RECOG              1
#define HEP_WAITFORTAP         2

#define HN_ENDREC              4
#define HN_DELAYEDRECOGFAIL    5

#define HN_RCRESULT            20

#define HN_ENDKKCONVERT        30

typedef struct tagRECTOFS
   {
   int dLeft;
   int dTop;
   int dRight;
   int dBottom;
   }
   RECTOFS, FAR *LPRECTOFS;

/****** Boxed Edit Control **************************************************/

typedef struct tagBOXLAYOUT
   {
   int cyCusp;      
   int cyEndCusp;
   UINT style;      
   DWORD rgbText;
   DWORD rgbBox; 
   DWORD rgbSelect;
   }
   BOXLAYOUT, FAR *LPBOXLAYOUT;

#define BXS_NONE               0U
#define BXS_RECT               1U
#define BXS_ENDTEXTMARK        2U
#define BXS_MASK               3U

#define HE_GETBOXLAYOUT        20
#define HE_SETBOXLAYOUT        21

#define BXD_CELLWIDTH          12
#define BXD_CELLHEIGHT         16
#define BXD_BASEHEIGHT         13
#define BXD_BASEHORZ           0
#define BXD_CUSPHEIGHT         2
#define BXD_ENDCUSPHEIGHT      4

/****** Screen Keyboard *****************************************************/

typedef struct tagSKBINFO
   {
   HWND hwnd;
   UINT nPad;
   BOOL fVisible;
   BOOL fMinimized;
   RECT rect;
   DWORD dwReserved;
   }
   SKBINFO, FAR *LPSKBINFO;

#define SKB_QUERY              0x0000
#define SKB_SHOW               0x0001
#define SKB_HIDE               0x0002
#define SKB_CENTER             0x0010
#define SKB_MOVE               0x0020
#define SKB_MINIMIZE           0x0040
#define SKB_FULL               0x0100
#define SKB_BASIC              0x0200
#define SKB_NUMPAD             0x0400

#define OBM_SKBBTNUP           32767
#define OBM_SKBBTNDOWN         32766
#define OBM_SKBBTNDISABLED     32765

#define SKN_CHANGED            1

#define SKN_POSCHANGED         1
#define SKN_PADCHANGED         2
#define SKN_MINCHANGED         4
#define SKN_VISCHANGED         8
#define SKN_TERMINATED         0xffff

BOOL WINAPI ShowKeyboard(HWND, UINT, LPPOINT, LPSKBINFO);

/****** New ComboBox Notifications  *****************************************/

#define CBN_ENDREC             16
#define CBN_DELAYEDRECOGFAIL   17
#define CBN_RCRESULT           18


#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif /* RC_INVOKED */

#endif /* #define _INC_PENWIN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\printer.h ===
/*  printer.h
    contains the definitions of the functions in _SORT,
       _BRUTE, _SPOOL.
*/

#ifdef OLDWAY

#define PASCAL
#define LONG        long
#define NULL        0
#define TRUE        1
#define FALSE       0
#define ERROR       (-1)
#define FAR  far
#define NEAR near
#define VOID void
#define REGISTER    register


/* file IO flags */

#define O_RDONLY        0x0000
#define O_WRONLY        0x0001
#define O_RDWR          0x0002
#define O_APPEND        0x0008  /* writes done at eof */

#define         OF_REOPEN       0x8000
#define         OF_EXIST        0x4000
#define         OF_PROMPT       0x2000
#define         OF_CREATE       0x1000
#define         OF_CANCEL       0x0800
#define         OF_VERIFY       0x0400
#define         OF_DELETE       0x0200

#define O_TEXT          0x4000  /* file mode is text (translated) */
#define O_BINARY        0x8000  /* file mode is binary (untranslated) */

#define SP_CREATE       O_WRONLY | OF_CREATE
#define SP_OPEN         O_RDONLY | OF_EXIST
#define SP_REOPEN       O_RDWR | OF_REOPEN | OF_PROMPT | OF_CANCEL

typedef int (FAR * FARPROC)();
typedef int (NEAR * NEARPROC)();
typedef unsigned LONG     DWORD;
typedef DWORD (FAR * DWORDFARPROC)();
typedef unsigned short int WORD;
typedef unsigned char      BYTE;
typedef WORD HANDLE;
typedef HANDLE HWND;
typedef HANDLE HDC;
typedef WORD ATOM;
typedef int  BOOLEAN;
typedef char *NEARP;
typedef char FAR *FARP;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;
typedef unsigned char     *PSTR;
typedef unsigned char far *LPSTR;
typedef short     BOOL;
typedef long FAR *LPLONG;

#define MAX(a,b)        ((a)>(b)?(a):(b))
#define MIN(a,b)        ((a)<=(b)?(a):(b))
#define ABS(x)          (((x) >= 0) ? (x) : (-(x)))
#define LWORD(x)        ((short)((x)&0xFFFF))
#define HWORD(y)        ((short)(((y)>>16)&0xFFFF))
#define MAKELONG(h,l)  ((long)(((WORD)l)|(((long)h)<<16)))
#define LOBYTE(w)       ((BYTE)w)
#define HIBYTE(w)       (((WORD)w >> 8) & 0xff)
#define MAKEPOINT(l)    (*((POINT *)&l))

/* Interface to global memory manager */

#define GMEM_SHAREALL       0x2000
#define GMEM_FIXED          0x00
#define GMEM_MOVEABLE       0x02
#define GMEM_ZEROINIT       0x40
#define GMEM_DISCARDABLE    0x0F00
#define GHND    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR    (GMEM_FIXED    | GMEM_ZEROINIT)

/* Interface to local memory manager */

#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

/* Exported procedures for KERNEL module */

/* Spooler escapes      */
#define SE_JOBTIME          0x0001  /* time out for printer     */
#define SE_SETCALLBACK      0x0002  /* set callback function    */
#define SE_MARKCALLBACK     0x0003  /* write mark for call back */


/* Exported procedures for KERNEL module */
VOID          far PASCAL FatalExit( int );

HANDLE        far PASCAL LoadModule(LPSTR, LPSTR);
VOID          far PASCAL FreeModule(HANDLE);
HANDLE        far PASCAL GetModuleHandle(FARP);
FARPROC       far PASCAL GetProcAddress(HANDLE, FARP);

HANDLE far PASCAL GlobalAlloc( WORD, DWORD );
HANDLE far PASCAL GlobalReAlloc( HANDLE, DWORD, WORD );
HANDLE far PASCAL GlobalFree( HANDLE );
FARP   far PASCAL GlobalLock( HANDLE );
BOOL   far PASCAL GlobalUnlock( HANDLE );
LONG   far PASCAL GlobalSize( HANDLE );
LONG   far PASCAL GlobalFlags( HANDLE );

/* task scheduler routines */

extern void          far PASCAL Yield(void);
extern BOOL          far PASCAL WaitEvent(HANDLE);
extern BOOL          far PASCAL PostEvent(HANDLE);
extern HANDLE        far PASCAL GetCurrentTask(void);

short       FAR PASCAL GetProfileString(LPSTR,  LPSTR,  LPSTR,  LPSTR,  short);
BOOL FAR PASCAL WriteProfileString( LPSTR, LPSTR, LPSTR );

/* Interface to the resource manager */

HANDLE      FAR PASCAL FindResource( HANDLE, LPSTR, LPSTR );
HANDLE      FAR PASCAL LoadResource( HANDLE, HANDLE );
BOOL        FAR PASCAL FreeResource( HANDLE );

char FAR *  FAR PASCAL LockResource( HANDLE );

FARPROC     FAR PASCAL SetResourceHandler( HANDLE, LPSTR, FARPROC );
HANDLE      FAR PASCAL AllocResource( HANDLE, HANDLE, DWORD );
WORD        FAR PASCAL SizeofResource( HANDLE, HANDLE );
int         FAR PASCAL AccessResource( HANDLE, HANDLE );


#define WM_INITDIALOG       0x0110
#define WM_COMMAND          0x0111
#define WM_ENDDIALOG        0x0088
#define WM_SPOOLERSTATUS    0x002a	/* ;Internal */
#define PR_JOBSTATUS        0x0000

typedef struct
{
        BYTE    cBytes;                 /* length of structure */
        BYTE    fFixedDisk;             /* non-zero if file located on non- */
                                        /* removeable media */
        WORD    nErrCode;               /* DOS error code if OpenFile fails */
        BYTE    reserved[ 4 ];
        BYTE    szPathName[ 128 ];
} OFSTRUCT;

typedef OFSTRUCT FAR * LPOFSTRUCT;

int         FAR PASCAL OpenFile( LPSTR, LPOFSTRUCT, WORD );
BYTE        FAR PASCAL GetTempDrive( BYTE );
int         far PASCAL OpenPathname( LPSTR, int );
int         far PASCAL DeletePathname( LPSTR );
int         far PASCAL _lopen( LPSTR, int );
void        far PASCAL _lclose( int );
int         far PASCAL _lcreat( LPSTR, int );
BOOL        far PASCAL _ldelete( LPSTR );
WORD        far PASCAL _ldup( int );
LONG        far PASCAL _llseek( int, long, int );
WORD        far PASCAL _lread( int, LPSTR, int );
WORD        far PASCAL _lwrite( int, LPSTR, int );

int         far PASCAL lstrcmp( LPSTR, LPSTR );
LPSTR       far PASCAL lstrcpy( LPSTR, LPSTR );
LPSTR       far PASCAL lstrcat( LPSTR, LPSTR );
int         far PASCAL lstrlen( LPSTR );
LPSTR       far PASCAL lstrbscan( LPSTR, LPSTR );
LPSTR	    far PASCAL lstrbskip( LPSTR, LPSTR );

/* new Escape support */
#define  GETEXTENDEDTEXTMETRICS  256
#define  GETEXTENTTABLE  257
#define  EXTTEXTOUT	 512

#else

#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMSG
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI

#include "Windows.h"
#include "winexp.h"

#undef NOATOM
#undef NOGDI
#undef NOGDICAPMASKS
#undef NOMETAFILE
#undef NOMSG
#undef NORASTEROPS
#undef NOSCROLL
#undef NOSOUND
#undef NOSYSMETRICS
#undef NOTEXTMETRIC
#undef NOWH
#undef NOCOMM
#undef NOKANJI

#define NOPTRC	/* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#endif /* OLDWAY */

/*  GDI internal routines */

short FAR PASCAL SetEnvironment(LPSTR, LPSTR, WORD);
short FAR PASCAL GetEnvironment(LPSTR, LPSTR, WORD);

/*  _SORT export routines */

HANDLE FAR  PASCAL CreatePQ(short);
short  FAR  PASCAL MinPQ(HANDLE);
short  FAR  PASCAL ExtractPQ(HANDLE);
short  FAR  PASCAL InsertPQ(HANDLE, short, short);
short  FAR  PASCAL SizePQ(HANDLE, short);
void   FAR  PASCAL DeletePQ(HANDLE);

/*  _SPOOL export routines */

HANDLE FAR  PASCAL OpenJob(LPSTR, LPSTR, HANDLE);
short FAR  PASCAL StartSpoolPage(HANDLE);
short FAR  PASCAL EndSpoolPage(HANDLE);
short FAR  PASCAL WriteSpool(HANDLE, LPSTR, short);
short FAR  PASCAL CloseJob(HANDLE);
short FAR  PASCAL DeleteJob(HANDLE, short);
short FAR  PASCAL WriteDialog(HANDLE, LPSTR, short);
short FAR  PASCAL WriteMark(HANDLE, LPSTR, short);
BOOL  FAR  PASCAL AddFileSpoolJob(LPSTR, LPSTR, BOOL, LPSTR);
BOOL  FAR  PASCAL SpoolEscape(HANDLE, short, short, LPSTR, LPSTR);


long  FAR  PASCAL QueryJob(HANDLE, short);
short FAR  PASCAL QueryAbort(HANDLE, short);

/* _SPOOL constants for queryjob */
#define SP_QUERYVALIDJOB    30
#define SP_QUERYDISKAVAIL   0x1004

#define USA_COUNTRYCODE 1

#define PQERROR (-1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\newexe.inc ===
savedCS = 4
savedIP = 2
savedBP = 0
savedDS = -2

EMAGIC  = 05A4Dh
ERESWDS =  0010h
ENEWHDR =  003Eh
ENEWEXE =  0040h

EXE_HDR     STRUC
e_magic     DW  ?               ; magic in same location
e_cblp      DW  ?
e_cp        DW  ?
e_crlc      DW  ?
e_cparhdr   DW  ?
e_minalloc  DW  ?
e_maxalloc  DW  ?
e_ss        DW  ?
e_sp        DW  ?
e_csum      DW  ?
e_cs        DW  ?
e_ip        DW  ?
e_lfarlc    DW  ?
e_ovno      DW  ?
e_res       DW  ERESWDS DUP (?)
e_lfanew    DD  ?
EXE_HDR     ENDS


NEMAGIC     = 454Eh
NERESBYTES  = 0

NEW_EXE         STRUC
ne_magic        DW  ?           ; Magic value 'NE'
ne_ver          DB  ?           ; version number
ne_rev          DB  ?           ; revision number
ne_enttab       DW  ?           ; offset to entry table
ne_cbenttab     DW  ?           ; number of bytes in entry table

ne_crc          DD  ?           ; CRC of file

ne_flags        DW  ?           ; flag word
ne_autodata     DW  ?           ; segment number of auto data segment
ne_heap         DW  ?           ; initial size of local heap
ne_stack        DW  ?           ; initial size of stack

ne_csip         DD  ?           ; CS:IP start address
ne_sssp         DD  ?           ; SS:SP initial stack pointer.  0 if
                                ; stack size word non-zero

ne_cseg         DW  ?           ; number of segment in segment table
ne_cmod         DW  ?           ; number of entries in module reference table
ne_cbnrestab    DW  ?           ; number of bytes in non-resident name table

ne_segtab       DW  ?           ; NE relative offset to segment table
ne_rsrctab      DW  ?           ; NE relative offset to resource table
ne_restab       DW  ?           ; NE relative offset to resident name table
ne_modtab       DW  ?           ; NE relative offset to module reference table
ne_imptab       DW  ?           ; NE relative offset to imported name table
ne_nrestab      DD  ?           ; file offset to non-resident name table
ne_cmovent      DW  ?           ; Count of movable entries
ne_align        DW  ?           ; Alignment shift count for segment data
ne_cres         DW  ?           ; Count of resource segments
ne_exetyp	DB  ?		; Target operating system
ne_flagsothers	DB  ?		; Other .EXE flags
ne_pretthunks   DW  ?           ; offset to return thunks
ne_psegrefbytes DW  ?           ; offset to segment ref. bytes
ne_swaparea     DW  ?           ; Minimum code swap area size
ne_expver       DW  ?           ; Expected Windows version number
NEW_EXE         ENDS

; Chksum not supported unless ne_psegcsum defined in NEW_EXE structure

ne_psegcsum = word ptr ne_exetyp
ne_onextexe = word ptr ne_crc

; New 3.0 Gang Load area description

ne_gang_start	= ne_pretthunks
ne_gang_length	= ne_psegrefbytes

NEW_EXE1        STRUC
                DW  ?
ne_usage        DW  ?
                DW  ?
ne_pnextexe     DW  ?
ne_pautodata    DW  ?
ne_pfileinfo    DW  ?
NEW_EXE1        ENDS

NENOTP          = 8000h         ; Not a process (i.e. a library module)
NEPRIVLIB       = 4000h         ; A library which lives above the line
NEIERR          = 2000h         ; Errors in image
NEAPPTYP        = 0700h         ; Application type mask
NENOTWINCOMPAT  = 0100h         ; Not compatible with P.M. Windowing
NEWINCOMPAT     = 0200h         ; Compatible with P.M. Windowing
NEWINAPI        = 0300h         ; Uses P.M. Windowing API
NEFLTP          = 0080h         ; Floating-point instructions
NEI386          = 0040h         ; 386 instructions
NEI286          = 0020h         ; 286 instructions
NEI086          = 0010h         ; 8086 instructions
NEPROT          = 0008h         ; Runs in protected mode only
NEPPLI          = 0004h         ; Per-Process Library Initialization
NEINST          = 0002h         ; Instance data
NESOLO          = 0001h         ; Solo data

; Below are the private bits used by the Windows 2.0 loader.  All are
; in the file, with the exception of NENONRES and NEWINPROT which are
; runtime only flags.
;

NEWINPROT	= NEIERR
NENONRES        = NEFLTP        ; Contains non-resident code segments
NEALLOCHIGH     = NEI386        ; Private allocs above the line okay
NEEMSSEPINST    = NEI286        ; Want each instance in separate
NELIM32         = NEI086        ; Uses LIM 3.2 API (Intel Above board)

; Following private bit is a runtime only flag used only ROM Windows.

NEMODINROM	= NEEMSSEPINST	; Module loaded from ROM

;
;  Format of NE_FLAGSOTHERS(x):
;
;      7 6 5 4 3 2 1 0	- bit no
;	       | | | |
;	       | | | +---------------- Support for long file names
;	       | | +------------------ 2.x app runs in protect mode
;	       | +-------------------- 2.x app gets prop. font
;	       +---------------------- Contains gangload area
;

NELONGNAMES     = 1h
NEINFONT        = 2h            ; WIN30 - 2.x app runs in 3.x prot mode
NEINPROT        = 4h            ; WIN30 - 2.x app gets proportional font
NEGANGLOAD      = 8h            ; WIN30 - Contains gangload area
NEASSUMENODEP   = 10h           ; WIN40 - DllEntryPoint known not to exit
NEINTLAPP       = 40h           ; WIN31 - intl versions use this.
NEHASPATCH      = 80h           ; WIN40 - Some segs of this module get patched

; Target operating systems

NE_UNKNOWN	= 0		; Unknown (any "new-format" OS)
NE_OS2		= 1		; Microsoft/IBM OS/2 (default)
NE_WINDOWS	= 2		; Microsoft Windows
NE_DOS4 	= 3		; Microsoft MS-DOS 4.x
NE_DEV386	= 4		; Microsoft Windows 386


ifndef NO_APPLOADER
NEAPPLOADER     = 0800h         ; set if application has its own loader
endif ;!NO_APPLOADER


NEW_SEG         STRUC
ns_sector       DW  ?   ; logical sector number in file of start of segment
ns_cbseg        DW  ?   ; number bytes in file
ns_flags        DW  ?   ; segment flags
ns_minalloc     DW  ?   ; minimum number bytes to allocate for segment
NEW_SEG         ENDS

NEW_SEG1        STRUC
                DB  SIZE NEW_SEG DUP (?)
ns_handle       DW  ?   ; Handle to segment (0 if not loaded)
NEW_SEG1        ENDS

NSTYPE          =  0007h    ; Segment type mask
NSCODE          =  0000h    ; Code segment
NSDATA          =  0001h    ; Data segment
NSITER          =  0008h    ; Iterated segment data
NSMOVE          =  0010h    ; Moveable segment
NSSHARE         =  0020h    ; Shareable segment
NSPRELOAD       =  0040h    ; Preload this segment
NSERONLY        =  0080h    ; EXECUTE ONLY code/READ ONLY data segment
NSRELOC         =  0100h    ; Relocation information following segment data
NSDPL           =  0C00h    ; 286 DPL bits
NSDISCARD       =  1000h    ; Discard priority bits
NS286DOS        = 0EE06h    ; These bits only used by 286DOS

NSALIGN         = 9         ; Default alignment shift count for seg. data

NSALLOCED       = 0002h     ; set if ns_handle points to uninitialized mem.
NSLOADED        = 0004h     ; set if ns_handle points to initialized mem.
NSUSESDATA      = 0400h     ; set if an entry point in this segment uses
                            ; the automatic data segment of a SOLO library

NSGETHIGH	= 0200h
NSINDIRECT	= 2000h
NSWINCODE	= 4000h     ; flag for code

NSKCACHED	= 0800h		; cached by kernel
NSPRIVLIB	= NSITER
NSNOTP		= 8000h

NSINROM 	= NSINDIRECT	; segment is loaded in ROM
NSCOMPR 	= NSGETHIGH	; segment is compressed in ROM

ifndef NO_APPLOADER
NSCACHED	= 8000h		;* in AppLoader Cache
endif ;!NO_APPLOADER


NEW_RSRC        STRUC
rs_align        DW  ?
NEW_RSRC        ENDS

RSORDID         = 08000h    ; If high bit of rt_id or rn_id set then integer id

RSRC_TYPEINFO   STRUC
rt_id           DW  ?
rt_nres         DW  ?
rt_proc         DD  ?
RSRC_TYPEINFO   ENDS

RSRC_NAMEINFO   STRUC
rn_offset       DW  ?
rn_length       DW  ?
rn_flags        DW  ?
rn_id           DW  ?
rn_handle       DW  ?
rn_usage        DW  ?
RSRC_NAMEINFO   ENDS
RNMOVE          = 00010h    ; Moveable resource
RNPURE          = 00020h    ; Pure resource (read only)
RNPRELOAD       = 00040h    ; Preload this resource
RNDISCARD       = 01000h    ; Discard bit
RNLOADED	= 00004h    ; True if handler proc return handle
RNCOMPR 	= 00200h    ; Resource is compressed in ROM
RNINROM 	= 02000h    ; Resource is loaded in ROM (run time flag)

RNUNUSED	= 0CD8Bh    ; Unused resource flags

ENTFIXED        STRUC
entflags        DB  ?
entoffset       DW  ?
ENTFIXED        ENDS

if SWAPPRO

ENTMOVEABLE	STRUC
		DB  ?			; Entry flags
entsar		DB  5 DUP (?)		; sar cs:[xxxx] instruction
		DW  ?			; INT 0F0H for swap profiler
entjmpfarop	DB  ?
entjmpfaroff	DW  ?
entjmpfarseg	DW  ?
ENTMOVEABLE	ENDS

ENTSWAPPED	STRUC
		DB  ?			; Entry flags
		DB  5 DUP (?)		; sar cs:[xxxx] instruction
		DW  ?			; INT 0F0H for swap profiler
entintop	DB  ?
entintvec	DB  ?
entintsegno	DB  ?
entintoff	DW  ?
ENTSWAPPED	ENDS

else		; no swap profiler

ENTMOVEABLE	STRUC
		DB  ?			; Entry flags
entsar		DB  5 DUP (?)		; sar cs:[xxxx] instruction
entjmpfarop	DB  ?
entjmpfaroff	DW  ?
entjmpfarseg	DW  ?
ENTMOVEABLE	ENDS

ENTSWAPPED	STRUC
		DB  ?			; Entry flags
		DB  5 DUP (?)		; sar cs:[xxxx] instruction
entintop	DB  ?
entintvec	DB  ?
entintsegno	DB  ?
entintoff	DW  ?
ENTSWAPPED	ENDS

endif		; if swap profiler

errnz <SIZE ENTMOVEABLE - SIZE ENTSWAPPED>

PENT		STRUC
penttype	DB  ?
pentflags	DB  ?
pentsegno	DB  ?
pentoffset	DW  ?
PENT		ENDS

PM_EntStruc	STRUC
PM_EntStart	dw	?
PM_EntEnd	dw	?
PM_EntNext	dw	?
PM_EntStruc	ENDS

ENT_UNUSED	= 000h
ENT_ABSSEG      = 0FEh
ENT_MOVEABLE    = 0FFh
ENT_PUBLIC      = 001h
ENT_DATA        = 002h
INTOPCODE       = 0CDh

if SWAPPRO
SWAPVECTOR	= 0F0h
endif

NEW_RLCINFO     STRUC
nr_nreloc       DW  ?
NEW_RLCINFO     ENDS

NEW_RLC         STRUC
nr_stype        DB  ?
nr_flags        DB  ?
nr_soff         DW  ?
nr_mod          DW  ?
nr_proc         DW  ?
NEW_RLC         ENDS
nr_segno        EQU nr_flags+3
nr_entry        EQU nr_proc

NRSTYP          = 07h
NRSBYTE         = 00h
NRSSEG          = 02h
NRSPTR          = 03h
NRSOFF          = 05h

NRADD           = 04h
NRRTYP          = 03h
NRRINT          = 00h
NRRORD          = 01h
NRRNAM          = 02h
OSFIXUP 	= 03h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\paswindw.inc ===
TYPE {Standard C types}
  int           = INTEGERC;
  short         = INTEGER;
  long          = INTEGER4;
  unsigned      = WORD;
  unsignedlong  = INTEGER4;
  LPshort       = ADS OF short;

CONST
  FALSE_             = 0;
  TRUE_              = 1;
  NULL_              = 0;

TYPE
  DWORD              = INTEGER4;
  BOOL               = int;
  PSTR               = ADR OF INTEGER1;
  NPSTR              = ADR OF INTEGER1;
  LPSTR              = ADS OF INTEGER1;
  LPINT              = ADS OF int;
  LPWORD             = ADS OF WORD;

CONST
  OBM_CLOSE          = 32767;
  OBM_SIZE           = 32766;
  OBM_UPARROW        = 32765;
  OBM_DNARROW        = 32764;
  OBM_RGARROW        = 32763;
  OBM_LfarROW        = 32762;
  OBM_BTSIZE         = 32761;
  OBM_CHECK          = 32760;
  OBM_CHECKBOXES     = 32759;
  OBM_BTNCORNERS     = 32758;
  OBM_REDUCE	     = 32757;
  OBM_ZOOM	     = 32756;
  OBM_RESTORE	     = 32755;
  OCR_NORMAL	     = 32512;
  OCR_IBEAM          = 32513;
  OCR_WAIT           = 32514;
  OCR_CROSS          = 32515;
  OCR_UP             = 32516;
  OCR_SIZE           = 32640;
  OCR_ICON	     = 32641;
  OCR_SIZENWSE	     = 32642;
  OCR_SIZENESW	     = 32643;
  OCR_SIZEWE	     = 32644;
  OCR_SIZENS	     = 32645;
  OCR_SIZEALL	     = 32646;

  OIC_SAMPLE         = 32512;
  OIC_HAND           = 32513;
  OIC_QUES           = 32514;
  OIC_BANG           = 32515;
  OIC_NOTE           = 32516;

(*  Scroll bar constants *)
  SB_HORZ            = 0;
  SB_VERT            = 1;
  SB_CTL	     = 2;
  SB_BOTH	     = 3;

(*  Scroll Commands *)
  SB_LINEUP          = 0;
  SB_LINEDOWN        = 1;
  SB_PAGEUP          = 2;
  SB_PAGEDOWN        = 3;
  SB_THUMBPOSITION   = 4;
  SB_THUMBTRACK      = 5;
  SB_TOP             = 6;
  SB_BOTTOM          = 7;
  SB_ENDSCROLL	     = 8;

(* ShowWindow commands *)

  SW_HIDE	     = 0;
  SW_SHOWNORMAL      = 1;
  SW_RESTORE	     = 1;
  SW_NORMAL	     = 1;
  SW_SHOWMINIMIZED   = 2;
  SW_SHOWMAXIMIZED   = 3;
  SW_MAXIMIZE	     = 3;
  SW_SHOWNOACTIVATE  = 4;
  SW_SHOW	     = 5;
  SW_MINIMIZE	     = 6;
  SW_SHOWMINNOACTIVE = 7;
  SW_SHOWNA	     = 8;


(* Old ShowWindow commands *)
  HIDE_WINDOW        = 0;
  SHOW_OPENWINDOW    = 1;
  SHOW_ICONWINDOW    = 2;
  SHOW_FULLSCREEN    = 3;
  SHOW_OPENNOACTIVATE = 4;

(* identifiers for the WM_SHOWWINDOW message *)
  SW_PARENTCLOSING    = 1;
  SW_OTHERZOOM        = 2;
  SW_PARENTOPENING    = 3;
  SW_OTHERUNZOOM      = 4;

(* flags for regions *)
  ERROR               = 0;
  NULLREGION          = 1;
  SIMPLEREGION        = 2;
  COMPLEXREGION       = 3;

(* styles for CombineRgn *)
  RGN_AND             = 1;
  RGN_OR              = 2;
  RGN_XOR             = 3;
  RGN_DIFF            = 4;
  RGN_COPY            = 5;

(* Virtual Keys, Standard Set *)

  VK_LBUTTON          = #01;
  VK_RBUTTON          = #02;
  VK_CANCEL           = #03;
  VK_MBUTTON          = #04    (* NOT contiguous with L & RBUTTON *);
  VK_BACK             = #08;
  VK_TAB              = #09;
  VK_CLEAR            = #0c;
  VK_RETURN           = #0d;
  VK_SHIFT            = #10;
  VK_CONTROL          = #11;
  VK_MENU             = #12;
  VK_PAUSE            = #13;
  VK_CAPITAL          = #14;
  VK_ESCAPE           = #1b;
  VK_SPACE            = #20;

  VK_PRIOR            = #21;
  VK_NEXT             = #22;
  VK_END              = #23;
  VK_HOME             = #24;
  VK_LEFT             = #25;
  VK_UP               = #26;
  VK_RIGHT            = #27;
  VK_DOWN             = #28;

(* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' *)
(* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' *)

  VK_SELECT           = #29;
  VK_PRINT            = #2a;
  VK_EXECUTE          = #2b;
  VK_INSERT           = #2d;
  VK_DELETE           = #2e;
  VK_HELP             = #2f;

  VK_NUMPAD0          = #60;
  VK_NUMPAD1          = #61;
  VK_NUMPAD2          = #62;
  VK_NUMPAD3          = #63;
  VK_NUMPAD4          = #64;
  VK_NUMPAD5          = #65;
  VK_NUMPAD6          = #66;
  VK_NUMPAD7          = #67;
  VK_NUMPAD8          = #68;
  VK_NUMPAD9          = #69;
  VK_MULTIPLY         = #6A;
  VK_ADD              = #6B;
  VK_SEPARATOR        = #6C;
  VK_SUBTRACT         = #6D;
  VK_DECIMAL          = #6E;
  VK_DIVIDE           = #6F;

  VK_F1               = #70;
  VK_F2               = #71;
  VK_F3               = #72;
  VK_F4               = #73;
  VK_F5               = #74;
  VK_F6               = #75;
  VK_F7               = #76;
  VK_F8               = #77;
  VK_F9               = #78;
  VK_F10              = #79;
  VK_F11              = #7a;
  VK_F12              = #7b;
  VK_F13              = #7c;
  VK_F14              = #7d;
  VK_F15              = #7e;
  VK_F16              = #7f;

  VK_NUMLOCK	      = #90;

(* SetWindowsHook codes *)
  WH_MSGFILTER        = -1;
  WH_JOURNALRECORD    = 0;
  WH_JOURNALPLAYBACK  = 1;
  WH_KEYBOARD         = 2;
  WH_GETMESSAGE       = 3;
  WH_CALLWNDPROC      = 4;
  WH_CBT	      = 5;
  WH_SYSMSGFILTER     = 6;
  WH_WINDOWMGR	      = 7;

(* HC_* Hook Codes *)
  HC_LPLPFNNEXT       = -2;
  HC_LPFNNEXT	      = -1;
  HC_ACTION	      =  0;
  HC_GETNEXT	      =  1;
  HC_SKIP	      =  2;
  HC_NOREM	      =  3;

(* CBT hook codes *)
  HCBT_MOVESIZE       =  0;
  HCBT_MINMAX	      =  1;
  HCBT_QS	      =  2;


(* WH_MSGFILTER filter proc codes *)
  MSGF_DIALOGBOX      = 0;
  MSGF_MESSAGEBOX     = 1;
  MSGF_MENU           = 2;
  MSGF_MOVE	      = 3;
  MSGF_SIZE	      = 4;
  MSGF_SCROLLBAR      = 5;
  MSGF_NEXTWINDOW     = 6;

(* Define window manager hook codes *)
  WC_INIT	      = 1;
  WC_SWP	      = 2;
  WC_DEFWINDOWPROC    = 3;
  WC_MINMAX	      = 4;
  WC_MOVE	      = 5;
  WC_SIZE	      = 6;
  WC_DRAWCAPTION      = 7;

(* message structure used in journaling  *)

TYPE

  EVENTMSG = RECORD
	message : unsigned;
	paramL	: WORD;
	paramH	: WORD;
	time	: DWORD;
  END;
  PEVENTMSGMSG	= ADR OF EVENTMSG;
  NPEVENTMSGMSG = ADR OF EVENTMSG;
  LPEVENTMSGMSG = ADS OF EVENTMSG;

CONST

(*  Binary raster ops *)
  R2_BLACK            = 1               (*  0       *);
  R2_NOTMERGEPEN      = 2               (* DPon     *);
  R2_MASKNOTPEN       = 3               (* DPna     *);
  R2_NOTCOPYPEN       = 4               (* PN       *);
  R2_MASKPENNOT       = 5               (* PDna     *);
  R2_NOT              = 6               (* Dn       *);
  R2_XORPEN           = 7               (* DPx      *);
  R2_NOTMASKPEN       = 8               (* DPan     *);
  R2_MASKPEN          = 9               (* DPa      *);
  R2_NOTXORPEN        = 10               (* DPxn     *);
  R2_NOP              = 11               (* D        *);
  R2_MERGENOTPEN      = 12               (* DPno     *);
  R2_COPYPEN          = 13               (* P        *);
  R2_MERGEPENNOT      = 14               (* PDno     *);
  R2_MERGEPEN         = 15               (* DPo      *);
  R2_WHITE            = 16               (*  1       *);

(*  Ternary raster operations *)
  SRCCOPY             = #00CC0020  (* dest=source                        *);
  SRCPAINT            = #00EE0086  (* dest=source OR dest                *);
  SRCAND              = #008800C6  (* dest = source AND dest             *);
  SRCINVERT           = #00660046  (* dest = source XOR      dest        *);
  SRCERASE            = #00440328  (* dest = source AND (not dest )      *);
  NOTSRCCOPY          = #00330008  (* dest = (not source)                *);
  NOTSRCERASE         = #001100A6  (* dest = (not source) AND (not dest) *);
  MERGECOPY           = #00C000CA  (* dest = (source AND pattern)        *);
  MERGEPAINT          = #00BB0226  (* dest = (NOT source) OR dest        *);
  PATCOPY             = #00F00021  (* dest = pattern                     *);
  PATPAINT            = #00FB0A09  (* dest = DPSnoo                      *);
  PATINVERT           = #005A0049  (* dest = pattern XOR     dest        *);
  DSTINVERT           = #00550009  (* dest = (not dest)                  *);
  BLACKNESS           = #00000042  (* dest = BLACK                       *);
  WHITENESS           = #00FF0062  (* dest = WHITE                       *);

(* StretchBlt() modes *)
  BLACKONWHITE        = 1;
  WHITEONBLACK        = 2;
  COLORONCOLOR        = 3;

(* PolyFill modes *)
  ALTERNATE           = 1;
  WINDING	      = 2;

(* text alignment options *)
  TA_UPDATECP	      = 1;
  TA_NOUPDATECP       = 0;

  TA_LEFT	      = 0;
  TA_RIGHT	      = 2;
  TA_CENTER	      = 6;

  TA_TOP	      = 0;
  TA_BOTTOM	      = 8;
  TA_BASELINE	      = 24;

  ETO_GRAYED	      = 1;
  ETO_OPAQUE	      = 2;
  ETO_CLIPPED	      = 4;



  ASPECT_FILTERING  = #0000001;

(* Meta file function numbers	*)
  META_SETBKCOLOR		= #201;
  META_SETBKMODE		= #102;
  META_SETMAPMODE		= #103;
  META_SETROP2			= #104;
  META_SETRELABS		= #105;
  META_SETPOLYFILLMODE		= #106;
  META_SETSTRETCHBLTMODE	= #107;
  META_SETTEXTCHAREXTRA 	= #108;
  META_SETTEXTCOLOR		= #209;
  META_SETTEXTJUSTIFICATION	= #20A;
  META_SETWINDOWORG		= #20B;
  META_SETWINDOWEXT		= #20C;
  META_SETVIEWPORTORG		= #20D;
  META_SETVIEWPORTEXT		= #20E;
  META_OFFSETWINDOWORG		= #20F;
  META_SCALEWINDOWEXT		= #400;
  META_OFFSETVIEWPORTORG	= #211;
  META_SCALEVIEWPORTEXT 	= #412;
  META_LINETO			= #213;
  META_MOVETO			= #214;
  META_EXCLUDECLIPRECT		= #415;
  META_INTERSECTCLIPRECT	= #416;
  META_ARC			= #817;
  META_ELLIPSE			= #418;
  META_FLOODFILL		= #419;
  META_PIE			= #81A;
  META_RECTANGLE		= #41B;
  META_ROUNDRECT		= #61C;
  META_PATBLT			= #61D;
  META_SAVEDC			= #01E;
  META_SETPIXEL 		= #41F;
  META_OFFSETCLIPRGN		= #220;
  META_TEXTOUT			= #521;
  META_BITBLT			= #922;
  META_STRETCHBLT		= #B23;
  META_POLYGON			= #324;
  META_POLYLINE 		= #325;
  META_ESCAPE			= #626;
  META_RESTOREDC		= #127;
  META_FILLREGION		= #228;
  META_FRAMEREGION		= #429;
  META_INVERTREGION		= #12A;
  META_PAINTREGION		= #12B;
  META_SELECTCLIPREGION 	= #12C;
  META_SELECTOBJECT		= #12D;
  META_SETTEXTALIGN		= #12E;
  META_DRAWTEXT 		= #62F;
  META_CHORD			= #630;
  META_CREATEBRUSH		= #0F8;
  META_CREATEPATTERNBRUSH	= #1F9;
  META_CREATEPENINDIRECT	= #2FA;
  META_CREATEFONTINDIRECT	= #2FB;
  META_CREATEBRUSHINDIRECT	= #2FC;
  META_CREATEBITMAPINDIRECT	= #2FD;
  META_CREATEBITMAP		= #6FE;
  META_CREATEREGION		= #6FF;

(* GDI escapes *)
  NEWFRAME            = 1;
  ABORTDOC            = 2;
  NEXTBAND            = 3;
  SETCOLORTABLE       = 4;
  GETCOLORTABLE       = 5;
  FLUSHOUTPUT         = 6;
  DRAFTMODE           = 7;
  QUERYESCSUPPORT     = 8;
  SETABORTPROC        = 9;
  STARTDOC            = 10;
  ENDDOC              = 11;
  GETPHYSPAGESIZE     = 12;
  GETPRINTINGOFFSET   = 13;
  GETSCALINGFACTOR    = 14;
  MFCOMMENT	      = 15;	   (* Metafile comment escape *)
  GETPENWIDTH	      = 16;
  SETCOPYCOUNT	      = 17;
  SELECTPAPERSOURCE   = 18;
  DEVICEDATA	      = 19;
  PASSTHROUGH	      = 19;
  GETTECHNOLGY	      = 20;
  SETENDCAP	      = 21;
  SETLINEJOIN	      = 22;
  SETMITERLIMIT       = 23;
  BANDINFO	      = 24;
  DRAWPATTERNRECT     = 25;
  GETVECTORPENSIZE    = 26;
  GETVECTORBRUSHSIZE  = 27;
  ENABLEDUPLEX	      = 28;
  ENABLEMANUALFEED    = 29;


(* spooler error code *)
  SP_NOTREPORTED      = #4000   (* set if GDI did not report error *);
  SP_ERROR            = -1      (* general errors who know what went wrong *);
  SP_APPABORT         = -2      (* app aborted the job - callback function returned false *);
  SP_USERABORT        = -3      (* user aborted the job through spooler's front end *);
  SP_OUTOFDISK        = -4      (* not enough disk space to spool *);
  SP_OUTOFMEMORY      = -5;

(* spooler WM_SPOOLERSTATUS wparm classes   *)

  PR_JOBSTATUS	      = #000;

(* Object definitions for GDI EnumObjects. *)
  OBJ_PEN             = 1;
  OBJ_BRUSH           = 2;


TYPE
  HANDLE             = WORD;
  PHANDLE            = ADR OF HANDLE;
  SPHANDLE           = ADR OF HANDLE;
  LPHANDLE           = ADS OF HANDLE;

  FARPROC            = ADSMEM;
  NEARPROC           = ADRMEM;
(*  GLOBALHANDLE       = HANDLE;  Conflict with function name *)
(*  LOCALHANDLE        = HANDLE;  Conflict with function name *)

  BITMAP = RECORD
    bmType           : short;
    bmWidth          : short;
    bmHeight         : short;
    bmWidthBytes     : short;
    bmPlanes         : BYTE;
    bmBitsPixel      : BYTE;
    bmBits           : LPSTR;
  END;
  PBITMAP            = ADR OF BITMAP;
  NPBITMAP           = ADR OF BITMAP;
  LPBITMAP           = ADS OF BITMAP;

  HSTR               = HANDLE;
  HICON              = HANDLE;
  HDC                = HANDLE;
  HMENU              = HANDLE;
  HPEN               = HANDLE;
  HFONT              = HANDLE;
  HBRUSH             = HANDLE;
  HBITMAP            = HANDLE;
  HCURSOR            = HANDLE;
  HRGN               = HANDLE;

  POINT = RECORD
    x                : int;
    y                : int;
  END;
  PPOINT             = ADR OF POINT;
  NPPOINT            = ADR OF POINT;
  LPPOINT            = ADS OF POINT;

  RECT = RECORD
    left             : int;
    top              : int;
    right            : int;
    bottom           : int;
  END;

  PRECT              = ADR OF RECT;
  NPRECT             = ADR OF RECT;
  LPRECT             = ADS OF RECT;

  WNDCLASS = RECORD
    style            : WORD;
    lpfnWndProc      : FARPROC;
    cbClsExtra       : int;
    cbWndExtra       : int;
    hInstance        : HANDLE;
    hIcon_           : HICON;
    hCursor_         : HCURSOR;
    hbrBackground    : HBRUSH;
    lpszMenuName     : LPSTR;
    lpszClassName    : LPSTR;
  END;
  PWNDCLASS          = ADR OF WNDCLASS;
  NPWNDCLASS         = ADR OF WNDCLASS;
  LPWNDCLASS         = ADS OF WNDCLASS;

  HWND               = HANDLE;

(* Message structure *)
  MSG = RECORD
    hwnd_            : HWND;
    message          : WORD;
    wParam           : WORD;
    lParam           : LONG;
    time             : DWORD;
    pt               : POINT;
  END;
  PMSG               = ADR OF MSG;
  NPMSG              = ADR OF MSG;
  LPMSG              = ADS OF MSG;

(* Window field offsets for GetWindowLong & GetWindowWord *)

CONST
  GWL_WNDPROC         = -4;
  GWW_HINSTANCE       = -6;
  GWW_HWNDPARENT      = -8;
  GWW_HWNDTEXT        = -10;
  GWW_ID              = -12;
  GWL_STYLE           = -16;

(* Class field offsets for GetClassLong & GetClassWord *)
  GCL_MENUNAME        = -8;
  GCW_HBRBACKGROUND   = -10;
  GCW_HCURSOR         = -12;
  GCW_HICON           = -14;
  GCW_HMODULE         = -16;
  GCW_CBWNDEXTRA      = -18;
  GCW_CBCLSEXTRA      = -20;
  GCL_WNDPROC         = -24;
  GCW_STYLE           = -26;

(* ** Window Procedure Messages *)

  WM_NULL             = #0000;
  WM_CREATE           = #0001;
  WM_DESTROY          = #0002;
  WM_MOVE             = #0003;
  WM_SIZEWAIT         = #0004;
  WM_SIZE             = #0005;
  WM_ACTIVATE         = #0006;
  WM_SETFOCUS_        = #0007;
  WM_KILLFOCUS_       = #0008;
  WM_SETVISIBLE       = #0009;
  WM_ENABLE           = #000a;
  WM_SETREDRAW        = #000b;
  WM_SETTEXT          = #000c;
  WM_GETTEXT          = #000d;
  WM_GETTEXTLENGTH    = #000e;
  WM_PAINT            = #000f;
  WM_CLOSE            = #0010;
  WM_QUERYENDSESSION  = #0011;
  WM_QUIT             = #0012;
  WM_QUERYOPEN        = #0013;
  WM_ERASEBKGND       = #0014;
  WM_SYSCOLORCHANGE   = #0015;
  WM_ENDSESSION       = #0016;
  WM_SYSTEMERROR      = #0017;
  WM_SHOWWINDOW       = #0018;
  WM_CTLCOLOR         = #0019;
  WM_WININICHANGE     = #001a;
  WM_DEVMODECHANGE    = #001b;
  WM_ACTIVATEAPP      = #001c;
  WM_FONTCHANGE       = #001d;
  WM_TIMECHANGE       = #001e;
  WM_CANCELMODE       = #001f;
  WM_SETCURSOR	      = #0020;
  WM_MOUSEACTIVATE    = #0021;
  WM_CHILDACTIVATE    = #0022;
  WM_QUEUESYNC	      = #0023;
  WM_GETMINMAXINFO    = #0024;
  WM_PAINTICON	      = #0026;
  WM_ICONERASEBKGND   = #0027;
  WM_NEXTDLGCTL       = #0028;
  WM_ALTTABACTIVE     = #0029;	      (* for win386 only *)
  WM_SPOOLERSTATUS    = #002A;


  WM_NCCREATE         = #0081;
  WM_NCDESTROY        = #0082;
  WM_NCCALCSIZE       = #0083;
  WM_NCHITTEST        = #0084;
  WM_NCPAINT          = #0085;
  WM_NCACTIVATE       = #0086;
  WM_GETDLGCODE       = #0087;
  WM_SYNCPAINT	      = #0088;
  WM_SYNCTASK	      = #0089;

  ST_BEGINSWP	      = 0;
  ST_ENDSWP	      = 1;


  WM_NCMOUSEMOVE      = #00a0;
  WM_NCLBUTTONDOWN    = #00a1;
  WM_NCLBUTTONUP      = #00a2;
  WM_NCLBUTTONDBLCLK  = #00a3;
  WM_NCRBUTTONDOWN    = #00a4;
  WM_NCRBUTTONUP      = #00a5;
  WM_NCRBUTTONDBLCLK  = #00a6;
  WM_NCMBUTTONDOWN    = #00a7;
  WM_NCMBUTTONUP      = #00a8;
  WM_NCMBUTTONDBLCLK  = #00a9;

(* WINWhere area codes *)
  HTERROR             = -2;
  HTTRANSPARENT       = -1;
  HTNOWHERE           = 0;
  HTCLIENT            = 1;
  HTCAPTION           = 2;
  HTSYSMENU           = 3;
  HTGROWBOX	      = 4;
  HTSIZE	      = HTGROWBOX;
  HTMENU              = 5;
  HTHSCROLL           = 6;
  HTVSCROLL           = 7;
  HTREDUCE	      = 8;
  HTZOOM	      = 9;
  HTLEFT	      = 10;
  HTRIGHT	      = 11;
  HTTOP 	      = 12;
  HTTOPLEFT	      = 13;
  HTTOPRIGHT	      = 14;
  HTBOTTOM	      = 15;
  HTBOTTOMLEFT	      = 16;
  HTBOTTOMRIGHT       = 17;
  HTSIZEFIRST	      = HTLEFT;
  HTSIZELAST	      = HTBOTTOMRIGHT;

(* WM_MOUSEACTIVATE return codes *)
  MA_ACTIVATE	      = 1;
  MA_ACTIVATEANDEAT   = 2;
  MA_NOACTIVATE       = 3;

  WM_KEYFIRST         = #0100;
  WM_KEYLAST          = #0107;

  WM_KEYDOWN          = #0100;
  WM_KEYUP            = #0101;
  WM_CHAR             = #0102;
  WM_DEADCHAR         = #0103;
  WM_SYSKEYDOWN       = #0104;
  WM_SYSKEYUP         = #0105;
  WM_SYSCHAR          = #0106;
  WM_SYSDEADCHAR      = #0107;
  WM_YOMICHAR         = #0108;
  WM_MOVECONVERTWINDOW = #0109;
  WM_CONVERTREQUEST    = #010A;
  WM_CONVERTRESULT     = #010B;

  WM_INITDIALOG        = #0110;
  WM_COMMAND           = #0111;
  WM_SYSCOMMAND        = #0112;
  WM_TIMER             = #0113;
  WM_HSCROLL           = #0114;
  WM_VSCROLL           = #0115;
  WM_INITMENU          = #0116;
  WM_INITMENUPOPUP     = #0117;
  WM_SYSTIMER          = #0118;
  WM_MENUSELECT        = #011f;
  WM_MENUCHAR	       = #0120;
  WM_ENTERIDLE	       = #0121;

  WM_MOUSEFIRST        = #0200;
  WM_MOUSELAST         = #0209;

  WM_MOUSEMOVE         = #0200      (* mouse related constants *);
  WM_LBUTTONDOWN       = #0201;
  WM_LBUTTONUP         = #0202;
  WM_LBUTTONDBLCLK     = #0203;
  WM_RBUTTONDOWN       = #0204;
  WM_RBUTTONUP         = #0205;
  WM_RBUTTONDBLCLK     = #0206;
  WM_MBUTTONDOWN       = #0207;
  WM_MBUTTONUP         = #0208;
  WM_MBUTTONDBLCLK     = #0209;

  WM_KANJIFIRST        = #0280;
  WM_KANJILAST	       = #029f;

(* clipboard messages *)
  WM_CUT               = #0300;
  WM_COPY              = #0301;
  WM_PASTE             = #0302;
  WM_CLEAR             = #0303;
  WM_UNDO              = #0304;
  WM_RENDERFORMAT      = #0305;
  WM_RENDERALLFORMATS  = #0306;
  WM_DESTROYCLIPBOARD  = #0307;
  WM_DRAWCLIPBOARD     = #0308;
  WM_PAINTCLIPBOARD    = #0309;
  WM_VSCROLLCLIPBOARD  = #030a;
  WM_SIZECLIPBOARD     = #030b;
  WM_ASKCBFORMATNAME   = #030c;
  WM_CHANGECBCHAIN     = #030d;
  WM_HSCROLLCLIPBOARD  = #030e;

(* 0x03f0 to 0x03ff are reserved *)
(* private window messages start here *)
  WM_USER              = #0400;



{ $IFDECL MAKELONG $THEN BEGIN }
  FUNCTION MAKELONG (
    w1_,w2_            : WORD
  )                    : LONG;
{ $END }

{ $IFDECL LOWORD $THEN BEGIN }
  FUNCTION LOWORD (
    l_                 : LONG
  )                    : WORD;
{ $END }

{ $IFDECL HIWORD $THEN BEGIN }
  FUNCTION HIWORD (
    l_                 : LONG
  )                    : WORD;
{ $END }

{ $IFDECL LOBYTE $THEN BEGIN }
  FUNCTION LOBYTE (
    w_                 : WORD
  )                    : BYTE;
{ $END }

{ $IFDECL HIBYTE $THEN BEGIN }
  FUNCTION HIBYTE (
    w_                 : WORD
  )                    : BYTE;
{ $END }

{ $IFDECL MAKEPOINT $THEN BEGIN }
  FUNCTION MAKEPOINT (
    l_                 : LONG
  )                    : POINT;
{ $END }

{ $IFDECL RegisterWindowMessage $THEN BEGIN }
  FUNCTION  RegisterWindowMessage (
    l_               : LPSTR
  )                  : WORD;
{ $END }

(* Size message commands *)

CONST
  SIZENORMAL           = 0;
  SIZEICONIC           = 1;
  SIZEFULLSCREEN       = 2;
  SIZEZOOMSHOW         = 3;
  SIZEZOOMHIDE         = 4;

(* Key state masks for mouse messages *)
  MK_LBUTTON           = #0001;
  MK_RBUTTON           = #0002;
  MK_SHIFT             = #0004;
  MK_CONTROL           = #0008;
  MK_MBUTTON           = #0010;

(* Window styles *)
  WS_TILED	       = #00000000;
  WS_OVERLAPPED        = WS_TILED;
  WS_ICONICPOPUP       = #c0000000;
  WS_POPUP	       = #80000000;
  WS_CHILD	       = #40000000;
  WS_MINIMIZE	       = #20000000;
  WS_VISIBLE	       = #10000000;
  WS_DISABLED	       = #08000000;
  WS_CLIPSIBLINGS      = #04000000;
  WS_CLIPCHILDREN      = #02000000;
  WS_MAXIMIZE	       = #01000000;

  WS_BORDER	       = #00800000;
  WS_CAPTION	       = #00c00000;
  WS_DLGFRAME	       = #00400000;
  WS_VSCROLL	       = #00200000;
  WS_HSCROLL	       = #00100000;
  WS_SYSMENU	       = #00080000;
  WS_SIZEBOX	       = #00040000;
  WS_THICKFRAME        = #00040000;
  WS_GROUP	       = #00020000;
  WS_TABSTOP	       = #00010000;

  WS_MINIMIZEBOX       = #00020000;
  WS_MAXIMIZEBOX       = #00010000;

  WS_ICONIC	  = WS_MINIMIZE;


(* Class styles *)
  CS_VREDRAW           = #0001;
  CS_HREDRAW           = #0002;
  CS_KEYCVTWINDOW      = #0004;
  CS_DBLCLKS           = #0008;
  CS_OEMCHARS          = #0010;
  CS_OWNDC             = #0020;
  CS_CLASSDC           = #0040;
  CS_PARENTDC	       = #0080;
  CS_NOKEYCVT          = #0100;
  CS_SAVEBITS	       = #0800;
  CS_NOCLOSE	       = #0200;
  CS_BYTEALIGNCLIENT   = #1000;
  CS_BYTEALIGNWINDOW   = #2000;

(* Shorthand for the common cases *)
  WS_TILEDWINDOW       = #00CF0000; (* WS_TILED | WS_CAPTION | WS_SYSMENU | WS_SIZEBOX *)
  WS_OVERLAPPEDWINDOW  = WS_TILEDWINDOW;
  WS_POPUPWINDOW       = #80880000; (* WS_POPUP | WS_BORDER | WS_SYSMENU *)
  WS_CHILDWINDOW       = (WS_CHILD);

(* clipboard metafile picture structure *)
TYPE
  HANDLETABLE = RECORD
    objectHandle[1] : HANDLE;
  END;
  PHANDLETABLE	= ADR OF HANDLETABLE;
  LPHANDLETABLE = ADS OF HANDLETABLE;

  METARECORD = RECORD
    rdSize     : DWORD;
    rdFunction : WORD;
    rdParm[1]  : WORD;
  END;
  PMETARECORD  = ADR OF METARECORD;
  LPMETARECORD = ADS OF METARECORD;

  METAFILEPICT = RECORD
    mm               : int;
    xExt             : int;
    yExt             : int;
    hMF              : HANDLE;
  END;
  LPMETAFILEPICT     = ADS OF METAFILEPICT;

(* predefined clipboard formats *)

CONST
  CF_TEXT              = 1;
  CF_BITMAP            = 2;
  CF_METAFILEPICT      = 3;
  CF_SYLK              = 4;
  CF_DIF               = 5;
  CF_TIFF	       = 6;
  CF_OEMTEXT	       = 7;

  CF_OWNERDISPLAY      = #80       (* owner display *);
  CF_DSPTEXT           = #81       (* display text *);
  CF_DSPBITMAP         = #82       (* display bitmap *);
  CF_DSPMETAFILEPICT   = #83       (* display metafile *);

(* Private clipboard format range *)
  CF_PRIVATEFIRST      = #200       (* Anything in this range doesn't *);
  CF_PRIVATELAST       = #2ff       (* get GlobalFree'd *);
  CF_GDIOBJFIRST       = #300       (* Anything in this range gets *);
  CF_GDIOBJLAST        = #3ff       (* DeleteObject'ed *);


TYPE
  PAINTSTRUCT = RECORD
    hdc_             : HDC;
    fErase           : BOOL;
    rcPaint          : RECT;
    fRestore         : BOOL;
    fIncUpdate       : BOOL;
    rgbReserved      : ARRAY [0..15] OF BYTE;
  END;
  PPAINTSTRUCT       = ADR OF PAINTSTRUCT;
  NPPAINTSTRUCT      = ADR OF PAINTSTRUCT;
  LPPAINTSTRUCT      = ADS OF PAINTSTRUCT;

  CREATESTRUCT = RECORD
    lpCreateParams   : LPSTR;
    hInstance        : HANDLE;
    hMenu            : HANDLE;
    hwndParent       : HWND;
    cy               : int;
    cx               : int;
    y                : int;
    x                : int;
    style            : long;
    lpszName         : LPSTR;
    lpszClass        : LPSTR;
  END;
  LPCREATESTRUCT     = ADS OF CREATESTRUCT;

(* TextMetric structure *)
  TEXTMETRIC = RECORD
    tmHeight         : INTEGER2;
    tmAscent         : INTEGER2;
    tmDescent        : INTEGER2;
    tmInternalLeading : INTEGER2;
    tmExternalLeading : INTEGER2;
    tmAveCharWidth    : INTEGER2;
    tmMaxCharWidth    : INTEGER2;
    tmWeight          : INTEGER2;
    tmItalic          : BYTE;
    tmUnderlined      : BYTE;
    tmStruckOut       : BYTE;
    tmFirstChar       : BYTE;
    tmLastChar        : BYTE;
    tmDefaultChar     : BYTE;
    tmBreakChar       : BYTE;
    tmPitchAndFamily  : BYTE;
    tmCharSet         : BYTE;
    tmOverhang        : INTEGER2;
    tmDigitizedAspectX : INTEGER2;
    tmDigitizedAspectY : INTEGER2;
  END;
  PTEXTMETRIC          = ADR OF TEXTMETRIC;
  NPTEXTMETRIC         = ADR OF TEXTMETRIC;
  LPTEXTMETRIC         = ADS OF TEXTMETRIC;

(* GDI logical objects *)
(* Pel Array *)
  PELARRAY = RECORD
    paXCount           : INTEGER2;
    paYCount           : INTEGER2;
    paXExt             : INTEGER2;
    paYExt             : INTEGER2;
    paRGBs             : BYTE;
  END;
  PPELARRAY            = ADR OF PELARRAY;
  NPPELARRAY           = ADR OF PELARRAY;
  LPPELARRAY           = ADS OF PELARRAY;

(* Logical Brush *)
  LOGBRUSH = RECORD
    lbStyle            : WORD;
    lbColor            : DWORD;
    lbHatch            : INTEGER2;
  END;
  PLOGBRUSH            = ADR OF LOGBRUSH;
  NPLOGBRUSH           = ADR OF LOGBRUSH;
  LPLOGBRUSH           = ADS OF LOGBRUSH;

(* A PATTERN and a LOGBRUSH are the same thing *)
  PATTERN              = LOGBRUSH;
  PPATTERN             = ADR OF PATTERN;
  NPPATTERN            = ADR OF PATTERN;
  LPPATTERN            = ADS OF PATTERN;

(* Logical Pen *)
  LOGPEN = RECORD
    lopnStyle          : WORD;
    lopnWidth          : POINT;
    lopnColor          : DWORD;
  END;
  PLOGPEN              = ADR OF LOGPEN;
  NPLOGPEN             = ADR OF LOGPEN;
  LPLOGPEN             = ADS OF LOGPEN;

(* Logical Font *)


CONST
  LF_FACESIZE          = 32;


TYPE
  LOGFONT = RECORD
    lfHeight           : INTEGER2;
    lfWidth            : INTEGER2;
    lfEscapement       : INTEGER2;
    lfOrientation      : INTEGER2;
    lfWeight           : INTEGER2;
    lfItalic           : BYTE;
    lfUnderline        : BYTE;
    lfStrikeOut        : BYTE;
    lfCharSet          : BYTE;
    lfOutPrecision     : BYTE;
    lfClipPrecision    : BYTE;
    lfQuality          : BYTE;
    lfPitchAndFamily   : BYTE;
    lfFaceName         : ARRAY [0..LF_FACESIZE-1] OF BYTE;
  END;
  PLOGFONT             = ADR OF LOGFONT;
  NPLOGFONT            = ADR OF LOGFONT;
  LPLOGFONT            = ADS OF LOGFONT;


(* Logical font constants *)

CONST
  OUT_DEFAULT_PRECIS   = 0;
  OUT_STRING_PRECIS    = 1;
  OUT_CHARACTER_PRECIS = 2;
  OUT_STROKE_PRECIS    = 3;

  CLIP_DEFAULT_PRECIS  = 0;
  CLIP_CHARACTER_PRECIS = 1;
  CLIP_STROKE_PRECIS    = 2;

  DEFAULT_QUALITY       = 0;
  DRAFT_QUALITY         = 1;
  PROOF_QUALITY         = 2;

  DEFAULT_PITCH         = 0;
  FIXED_PITCH           = 1;
  VARIABLE_PITCH        = 2;

  ANSI_CHARSET          = 0;
  SHIFTJIS_CHARSET	= 128;		 (* Kanji CharSet *)
  OEM_CHARSET           = 255;

(* GDI font families. *)
  FF_DONTCARE           = 0     (* Don't care or don't know. *);
  FF_ROMAN              = 16    (* Variable stroke width, serifed. *);
                                (* Times Roman, Century Schoolbook, etc. *)
  FF_SWISS              = 32    (* Variable stroke width, sans-serifed. *);
                                (* Helvetica, Swiss, etc. *)
  FF_MODERN             = 48    (* Constant stroke width, serifed or sans-serifed. *);
                                (* Pica, Elite, Courier, etc. *)
  FF_SCRIPT             = 64    (* Cursive, etc. *);
  FF_DECORATIVE         = 80    (* Old English, etc. *);

(* Font weights lightest to darkest. *)
  FW_DONTCARE           = 0;
  FW_THIN               = 100;
  FW_EXTRALIGHT         = 200;
  FW_LIGHT              = 300;
  FW_NORMAL             = 400;
  FW_MEDIUM             = 500;
  FW_SEMIBOLD           = 600;
  FW_BOLD               = 700;
  FW_EXTRABOLD          = 800;
  FW_HEAVY              = 900;

  FW_ULTRALIGHT         = (FW_EXTRALIGHT);
  FW_REGULAR            = (FW_NORMAL);
  FW_DEMIBOLD           = (FW_SEMIBOLD);
  FW_ULTRABOLD          = (FW_EXTRABOLD);
  FW_BLACK              = (FW_HEAVY);


(* EnumFonts masks. *)
  RASTER_FONTTYPE       = #0001;
  DEVICE_FONTTYPE       = #0002;


(* GDI rgb values packed into a dword *)

{ $IFDECL RGB $THEN BEGIN }
  FUNCTION RGB (
    r,g,b              : BYTE
  )                    : DWORD;
{ $END }

{ $IFDECL GetRValue $THEN BEGIN }
  FUNCTION GetRValue (
    d_                 : DWORD
  )                    : BYTE;
{ $END }

{ $IFDECL GetGValue $THEN BEGIN }
  FUNCTION GetGValue (
    d_                 : DWORD
  )                    : BYTE;
{ $END }

{ $IFDECL GetBValue $THEN BEGIN }
  FUNCTION GetBValue (
    d_                 : DWORD
  )                    : BYTE;
{ $END }

(* GDI Background Modes *)

CONST
  TRANSPARENT           = 1;
  OPAQUE                = 2;

(* GDI map modes *)
  MM_TEXT               = 1;
  MM_LOMETRIC           = 2;
  MM_HIMETRIC           = 3;
  MM_LOENGLISH          = 4;
  MM_HIENGLISH          = 5;
  MM_TWIPS              = 6;
  MM_ISOTROPIC          = 7;
  MM_ANISOTROPIC        = 8;

(* GDI coordinate modes *)

  ABSOLUTE              = 1;
  RELATIVE              = 2;

(* Stock Logical Objects *)
  WHITE_BRUSH           = 0;
  LTGRAY_BRUSH          = 1;
  GRAY_BRUSH            = 2;
  DKGRAY_BRUSH          = 3;
  BLACK_BRUSH           = 4;
  NULL_BRUSH            = 5;
  HOLLOW_BRUSH          = (NULL_BRUSH);
  WHITE_PEN             = 6;
  BLACK_PEN             = 7;
  NULL_PEN              = 8;
  OEM_FIXED_FONT        = 10;
  ANSI_FIXED_FONT       = 11;
  ANSI_VAR_FONT         = 12;
  SYSTEM_FONT           = 13;
  DEVICEDEFAULT_FONT    = 14;

(* GDI Brush Style definitions. *)

  BS_SOLID              = 0;
  BS_NULL               = 1;
  BS_HOLLOW             = (BS_NULL);
  BS_HATCHED            = 2;
  BS_PATTERN            = 3;
  BS_INDEXED		= 4;


(* GDI Hatch Style definitions. *)

  HS_HORIZONTAL         = 0       (* ----- *);
  HS_VERTICAL           = 1       (* ||||| *);
  HS_FDIAGONAL          = 2       (* ///// *);
  HS_BDIAGONAL          = 3       (* \\\\\ *);
  HS_CROSS              = 4       (* +++++ *);
  HS_DIAGCROSS          = 5       (* xxxxx *);


(* GDI Pen Style definitions *)
  PS_SOLID              = 0       (* solid pen *);
  PS_DASH               = 1       (* -------  *);
  PS_DOT                = 2       (* .......  *);
  PS_DASHDOT            = 3       (* _._._._  *);
  PS_DASHDOTDOT         = 4       (* _.._.._  *);
  PS_NULL               = 5       (*          *);

(* Device Parameters for GetDeviceCaps() *)

  DRIVERVERSION         = 0     (*  Device driver version                 *);
  TECHNOLOGY            = 2     (*  Device classification                 *);
  HORZSIZE              = 4     (*  Horizontal size in millimeters        *);
  VERTSIZE              = 6     (*  Vertical   size in millimeters        *);
  HORZRES               = 8     (*  Horizontal width in pixels            *);
  VERTRES               = 10    (*  Vertical   width in pixels            *);
  BITSPIXEL             = 12    (*  Number of bits per pixel              *);
  PLANES                = 14    (*  Number of planes                      *);
  NUMBRUSHES            = 16    (*  Number of brushes the device has      *);
  NUMPENS               = 18    (*  Number of pens the device has         *);
  NUMMARKERS            = 20    (*  Number of markers the device has      *);
  NUMFONTS              = 22    (*  Number of fonts the device has        *);
  NUMCOLORS             = 24;
  PDEVICESIZE           = 26    (*  Size required for device descriptor   *);
  CURVECAPS             = 28    (*  Curves    capabilities                *);
  LINECAPS              = 30    (*  Line      capabilities                *);
  POLYGONALCAPS         = 32    (*  Polygonal capabilities                *);
  TEXTCAPS              = 34    (*  Text      capabilities                *);
  CLIPCAPS              = 36    (*  Clipping  capabilities                *);
  RASTERCAPS            = 38    (*  Bitblt    capabilities                *);
  ASPECTX               = 40    (*  Length of the X leg                   *);
  ASPECTY               = 42    (*  Length of the Y leg                   *);
  ASPECTXY              = 44    (*  Length of the hypotenuse              *);

  LOGPIXELSX            = 88    (*  Logical pixels/inch in X              *);
  LOGPIXELSY            = 90    (*  Logical pixels/inch in Y              *);


(* Device capability masks *)
(*              Device Technologies                                *)

  DT_PLOTTER            = 0       (* Vector plotter          *);
  DT_RASDISPLAY         = 1       (* Raster display          *);
  DT_RASPRINTER         = 2       (* Raster printer          *);
  DT_RASCAMERA          = 3       (* Raster camera           *);
  DT_CHARSTREAM         = 4       (* Character-stream, PLP   *);
  DT_METAFILE           = 5       (* Metafile, VDM           *);
  DT_DISPFILE           = 6       (* Display-file            *);

(*              Curve Capabilities                                 *)

  CC_NONE               = 0   (* Curves not supported    *);
  CC_CIRCLES            = 1   (* Can do circles          *);
  CC_PIE                = 2   (* Can do pie wedges       *);
  CC_CHORD              = 4   (* Can do chord arcs       *);
  CC_ELLIPSES           = 8   (* Can do ellipese         *);
  CC_WIDE               = 16  (* Can do wide lines       *);
  CC_STYLED             = 32  (* Can do styled lines     *);
  CC_WIDESTYLED         = 64  (* Can do wide styled lines*);
  CC_INTERIORS          = 128 (* Can do interiors        *);

(*           Line Capabilities                                 *)

  LC_NONE               = 0   (* Lines not supported     *);
  LC_POLYLINE           = 2   (* Can do polylines        *);
  LC_MARKER             = 4   (* Can do markers          *);
  LC_POLYMARKER         = 8   (* Can do polymarkers      *);
  LC_WIDE               = 16  (* Can do wide lines       *);
  LC_STYLED             = 32   (* Can do styled lines     *);
  LC_WIDESTYLED         = 64   (* Can do wide styled lines*);
  LC_INTERIORS          = 128  (* Can do interiors        *);

(*           Polygonal Capabilities                            *)

  PC_NONE               = 0   (* Polygonals not supported*);
  PC_POLYGON            = 1   (* Can do polygons         *);
  PC_RECTANGLE          = 2   (* Can do rectangles       *);
  PC_TRAPEZOID          = 4   (* Can do trapezoids       *);
  PC_SCANLINE           = 8   (* Can do scanlines        *);
  PC_WIDE               = 16  (* Can do wide borders     *);
  PC_STYLED             = 32   (* Can do styled borders   *);
  PC_WIDESTYLED         = 64   (* Can do wide styled borders*);
  PC_INTERIORS          = 128  (* Can do interiors        *);

(*           Polygonal Capabilities                            *)

  CP_NONE               = 0   (* no clipping of Output   *);
  CP_RECTANGLE          = 1   (* Output clipped to Rects *);

(*           Text Capabilities                                          *)

  TC_OP_CHARACTER       = #0001      (* Can do OutputPrecision   CHARACTER      *);
  TC_OP_STROKE          = #0002      (* Can do OutputPrecision   STROKE         *);
  TC_CP_STROKE          = #0004      (* Can do ClipPrecision     STROKE         *);
  TC_CR_90              = #0008      (* Can do CharRotAbility    90             *);
  TC_CR_ANY             = #0010      (* Can do CharRotAbility    ANY            *);
  TC_SF_X_YINDEP        = #0020      (* Can do ScaleFreedom      X_YINDEPENDENT *);
  TC_SA_DOUBLE          = #0040      (* Can do ScaleAbility      DOUBLE         *);
  TC_SA_INTEGER         = #0080      (* Can do ScaleAbility      INTEGER        *);
  TC_SA_CONTIN          = #0100      (* Can do ScaleAbility      CONTINUOUS     *);
  TC_EA_DOUBLE          = #0200      (* Can do EmboldenAbility   DOUBLE         *);
  TC_IA_ABLE            = #0400      (* Can do ItalisizeAbility  ABLE           *);
  TC_UA_ABLE            = #0800      (* Can do UnderlineAbility  ABLE           *);
  TC_SO_ABLE            = #1000      (* Can do StrikeOutAbility  ABLE           *);
  TC_RA_ABLE            = #2000      (* Can do RasterFontAble    ABLE           *);
  TC_VA_ABLE            = #4000      (* Can do VectorFontAble    ABLE           *);
  TC_RESERVED           = #8000      (* Reserved.                               *);
(*           Raster Capabilities                                        *)

  RC_BITBLT             = 1     (* Can do standard non-stretching, non-inverting BLT. *);
  RC_BANDING            = 2     (* Device requires banding support                    *);
  RC_SCALING            = 4     (* Device requires scaling support *);
  RC_BITMAP64		= 8	(* Device can support >64K bitmap  *);

(* PeekMessage options *)

  PM_REMOVE	       = TRUE_;
  PM_NOREMOVE	       = FALSE_;
  PM_NOYIELD	       = #02;


{ $IFDECL GetMessage $THEN BEGIN }
  FUNCTION  GetMessage (
    l_                 : LPMSG;
    h_                 : HWND;
    w_,x_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL PeekMessage $THEN BEGIN }
  FUNCTION  PeekMessage (
    l_                 : LPMSG;
    h_                 : HWND;
    w_,x_              : WORD;
    b_                 : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL TranslateMessage $THEN BEGIN }
  FUNCTION  TranslateMessage (
    l_                 : LPMSG
  )                    : BOOL;
{ $END }

{ $IFDECL DispatchMessage $THEN BEGIN }
  FUNCTION  DispatchMessage (
    l_                 : LPMSG
  )                    : LONG;
{ $END }


{ $IFDECL SwapMouseButton $THEN BEGIN }
  FUNCTION  SwapMouseButton (
    b_                 : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL GetMessagePos $THEN BEGIN }
  FUNCTION  GetMessagePos                    : DWORD;
{ $END }

{ $IFDECL GetMessageTime $THEN BEGIN }
  FUNCTION  GetMessageTime                    : long;
{ $END }


{ $IFDECL GetSysModalWindow $THEN BEGIN }
  FUNCTION  GetSysModalWindow                    : HWND;
{ $END }

{ $IFDECL SetSysModalWindow $THEN BEGIN }
  FUNCTION  SetSysModalWindow (
    h_                 : HWND
  )                    : HWND;
{ $END }


{ $IFDECL SendMessage $THEN BEGIN }
  FUNCTION  SendMessage (
    h_                 : HWND;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : long;
{ $END }

{ $IFDECL PostMessage $THEN BEGIN }
  FUNCTION  PostMessage (
    h_                 : HWND;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : BOOL;
{ $END }

{ $IFDECL PostAppMessage $THEN BEGIN }
  FUNCTION  PostAppMessage (
    h_                 : HANDLE;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : BOOL;
{ $END }

{ $IFDECL ReplyMessage $THEN BEGIN }
  PROCEDURE ReplyMessage (
    l_                 : long
  );
{ $END }

{ $IFDECL WaitMessage $THEN BEGIN }
  PROCEDURE WaitMessage;
{ $END }

{ $IFDECL DefWindowProc $THEN BEGIN }
  FUNCTION  DefWindowProc (
    h_                 : HWND;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : long;
{ $END }

{ $IFDECL PostQuitMessage $THEN BEGIN }
  PROCEDURE PostQuitMessage (
    i_                 : int
  );
{ $END }

{ $IFDECL CallWindowProc $THEN BEGIN }
  FUNCTION  CallWindowProc (
    f_                 : FARPROC;
    h_                 : HWND;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : long;
{ $END }

{ $IFDECL InSendMessage $THEN BEGIN }
  FUNCTION  InSendMessage                    : BOOL;
{ $END }


{ $IFDECL GetDoubleClickTime $THEN BEGIN }
  FUNCTION  GetDoubleClickTime                    : WORD;
{ $END }

{ $IFDECL SetDoubleClickTime $THEN BEGIN }
  FUNCTION  SetDoubleClickTime (
     w_ 	       : WORD
  );
{ $END }

{ $IFDECL RegisterClass $THEN BEGIN }
  FUNCTION  RegisterClass (
    l_                 : LPWNDCLASS
  )                    : BOOL;
{ $END }

{ $IFDECL SetMessageQueue $THEN BEGIN }
  FUNCTION  SetMessageQueue (
    i_		       : int
  )                    : BOOL;
{ $END }

{ $IFDECL CreateWindow $THEN BEGIN }
  FUNCTION  CreateWindow (
    l_,m_              : LPSTR;
    d_                 : DWORD;
    i_,j_,k_,n_        : int;
    h_                 : HWND;
    o_                 : HMENU;
    p_                 : HANDLE;
    q_                 : LPSTR
  )                    : HWND;
{ $END }

CONST
  CW_USEDEFAULT        = RETYPE( int, #8000);	{ used on both x and cx }

{ $IFDECL IsWindow $THEN BEGIN }
  FUNCTION  IsWindow (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL DestroyWindow $THEN BEGIN }
  FUNCTION  DestroyWindow (
    h_                 : HWND
  )                    : BOOL;
{ $END }


{ $IFDECL ShowWindow $THEN BEGIN }
  FUNCTION  ShowWindow (
    h_                 : HWND;
    i_                 : int
  )                    : BOOL;
{ $END }

{ $IFDECL FlashWindow $THEN BEGIN }
  FUNCTION  FlashWindow (
    h_                 : HWND;
    b_                 : BOOL
  )                    : BOOL;
{ $END }


{ $IFDECL OpenIcon $THEN BEGIN }
  FUNCTION  OpenIcon (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL CloseWindow $THEN BEGIN }
  FUNCTION  CloseWindow (
    h_                 : HWND
  )                    : int;
{ $END }

{ $IFDECL MoveWindow $THEN BEGIN }
  PROCEDURE MoveWindow (
    h_                 : HWND;
    i_,j_,k_,l_        : int;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL IsWindowVisible $THEN BEGIN }
  FUNCTION  IsWindowVisible (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL IsIconic $THEN BEGIN }
  FUNCTION  IsIconic (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL AnyPopup $THEN BEGIN }
  FUNCTION  AnyPopup                    : BOOL;
{ $END }

{ $IFDECL BringWindowToTop $THEN BEGIN }
  PROCEDURE BringWindowToTop (
    h_                 : HWND
  );
{ $END }

{ $IFDECL IsZoomed $THEN BEGIN }
  FUNCTION  IsZoomed (
    h_                 : HWND
  )                    : BOOL;
{ $END }

(* SetWindowPos flags *)

CONST
  SWP_NOSIZE	   = #01;
  SWP_NOMOVE	   = #02;
  SWP_NOZORDER	   = #04;
  SWP_NOREDRAW	   = #08;
  SWP_NOACTIVATE   = #10;
  SWP_DRAWFRAME    = #20;
  SWP_SHOWWINDOW   = #40;
  SWP_HIDEWINDOW   = #80;
  SWP_NOCOPYBITS   = #0100;
  SWP_NOREPOSITION = #200;


(* DrawFrame and associated defines *)
  DF_SHIFT0	      = #0000;
  DF_SHIFT1	      = #0001;
  DF_SHIFT2	      = #0002;
  DF_SHIFT3	      = #0003;
  DF_PATCOPY	      = #0000;
  DF_PATINVERT	      = #0004;

  DF_SCROLLBAR	      = 0;
  DF_BACKGROUND       = 8;
  DF_ACTIVECAPTION    = 16;
  DF_INACTIVECAPTION  = 24;
  DF_MENU	      = 32;
  DF_WINDOW	      = 40;
  DF_WINDOWFRAME      = 48;
  DF_MENUTEXT	      = 56;
  DF_WINDOWTEXT       = 64;
  DF_CAPTIONTEXT      = 72;
  DF_ACTIVEBORDER     = 80;
  DF_INACTIVEBORDER   = 88;
  DF_APPWORKSPACE     = 96;
  DF_GRAY	      = 104;

(* DrawText format flags *)


  DT_LEFT               = #00;
  DT_CENTER             = #01;
  DT_RIGHT              = #02;
  DT_TOP                = #00;
  DT_VCENTER            = #04;
  DT_BOTTOM             = #08;
  DT_WORDBREAK          = #10;
  DT_SINGLELINE         = #20;
  DT_EXPANDTABS         = #40;
  DT_TABSTOP            = #80;
  DT_NOCLIP             = #100;
  DT_EXTERNALLEADING    = #200;
  DT_CALCRECT		= #400;
  DT_NOPREFIX		= #800;
  DT_INTERNAL		= #1000;


{ $IFDECL DrawText $THEN BEGIN }
  PROCEDURE DrawText (
    h_                 : HDC;
    l_                 : LPSTR;
    i_                 : int;
    m_                 : LPRECT;
    w_                 : WORD
  );
{ $END }

{ $IFDECL DrawIcon $THEN BEGIN }
  FUNCTION  DrawIcon (
    h_                 : HDC;
    i_,j_              : int;
    k_                 : HICON
  )                    : BOOL;
{ $END }


{ $IFDECL CreateDialog $THEN BEGIN }
  FUNCTION  CreateDialog (
    h_                 : HANDLE;
    l_                 : LPSTR;
    i_                 : HWND;
    f_                 : FARPROC
  )                    : HWND;
{ $END }

{ $IFDECL CreateDialogIndirect $THEN BEGIN }
  FUNCTION  CreateDialogIndirect (
    h_                 : HANDLE;
    l_                 : LPSTR;
    i_                 : HWND;
    f_                 : FARPROC
  )                    : HWND;
{ $END }

{ $IFDECL DialogBox $THEN BEGIN }
  FUNCTION  DialogBox (
    h_                 : HANDLE;
    l_                 : LPSTR;
    i_                 : HWND;
    f_                 : FARPROC
  )                    : int;
{ $END }

{ $IFDECL DialogBoxIndirect $THEN BEGIN }
  FUNCTION  DialogBoxIndirect (
    h_                 : HANDLE;
    h_		       : HANDLE;
    i_                 : HWND;
    f_                 : FARPROC
  )                    : int;
{ $END }

{ $IFDECL EndDialog $THEN BEGIN }
  PROCEDURE EndDialog (
    h_                 : HWND;
    i_                 : int
  );
{ $END }

{ $IFDECL GetDlgItem $THEN BEGIN }
  FUNCTION  GetDlgItem (
    h_                 : HWND;
    i_                 : int
  )                    : HWND;
{ $END }

{ $IFDECL SetDlgItemInt $THEN BEGIN }
  PROCEDURE SetDlgItemInt (
    h_                 : HWND;
    i_                 : int;
    w_                 : WORD;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL GetDlgItemInt $THEN BEGIN }
  FUNCTION  GetDlgItemInt (
    h_                 : HWND;
    i_                 : int;
    b_                 : LPBOOL;
    c_                 : BOOL
  )                    : WORD;
{ $END }

{ $IFDECL SetDlgItemText $THEN BEGIN }
  PROCEDURE SetDlgItemText (
    h_                 : HWND;
    i_                 : int;
    l_                 : LPSTR
  );
{ $END }

{ $IFDECL GetDlgItemText $THEN BEGIN }
  FUNCTION  GetDlgItemText (
    h_                 : HWND;
    i_                 : int;
    l_                 : LPSTR;
    j_                 : int
  )                    : int;
{ $END }

{ $IFDECL CheckDlgButton $THEN BEGIN }
  PROCEDURE CheckDlgButton (
    h_                 : HWND;
    i_                 : int;
    w_                 : WORD
  );
{ $END }

{ $IFDECL CheckRadioButton $THEN BEGIN }
  PROCEDURE CheckRadioButton (
    h_                 : HWND;
    i_,j_,k_           : int
  );
{ $END }

{ $IFDECL IsDlgButtonChecked $THEN BEGIN }
  FUNCTION  IsDlgButtonChecked (
    h_                 : HWND;
    i_                 : int
  )                    : WORD;
{ $END }

{ $IFDECL SendDlgItemMessage $THEN BEGIN }
  FUNCTION  SendDlgItemMessage (
    h_                 : HWND;
    i_                 : int;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : long;
{ $END }


{ $IFDECL CallMsgFilter $THEN BEGIN }
  FUNCTION  CallMsgFilter (
    l_                 : LPMSG;
    i_                 : int
  )                    : BOOL;
{ $END }

(* Clipboard manager routines *)

{ $IFDECL OpenClipboard $THEN BEGIN }
  FUNCTION  OpenClipboard (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL CloseClipboard $THEN BEGIN }
  FUNCTION  CloseClipboard                    : BOOL;
{ $END }

{ $IFDECL GetClipboardOwner $THEN BEGIN }
  FUNCTION  GetClipboardOwner                    : HWND;
{ $END }

{ $IFDECL SetClipboardViewer $THEN BEGIN }
  FUNCTION  SetClipboardViewer (
    h_                 : HWND
  )                    : HWND;
{ $END }

{ $IFDECL GetClipboardViewer $THEN BEGIN }
  FUNCTION  GetClipboardViewer                    : HWND;
{ $END }

{ $IFDECL ChangeClipboardChain $THEN BEGIN }
  FUNCTION  ChangeClipboardChain (
    h_,i_              : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL SetClipboardData $THEN BEGIN }
  FUNCTION  SetClipboardData (
    w_                 : WORD;
    h_                 : HANDLE
  )                    : HANDLE;
{ $END }

{ $IFDECL GetClipboardData $THEN BEGIN }
  FUNCTION  GetClipboardData (
    w_                 : WORD
  )                    : HANDLE;
{ $END }

{ $IFDECL RegisterClipboardFormat $THEN BEGIN }
  FUNCTION  RegisterClipboardFormat (
    l_                 : LPSTR
  )                    : WORD;
{ $END }

{ $IFDECL CountClipboardFormats $THEN BEGIN }
  FUNCTION  CountClipboardFormats                    : int;
{ $END }

{ $IFDECL EnumClipboardFormats $THEN BEGIN }
  FUNCTION  EnumClipboardFormats (
    w_                 : WORD
  )                    : WORD;
{ $END }

{ $IFDECL GetClipboardFormatName $THEN BEGIN }
  FUNCTION  GetClipboardFormatName (
    w_                 : WORD;
    l_                 : LPSTR;
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL EmptyClipboard $THEN BEGIN }
  FUNCTION  EmptyClipboard                    : BOOL;
{ $END }

{ $IFDECL IsClipboardFormatAvailable $THEN BEGIN }
  FUNCTION  IsClipboardFormatAvailable (
    w_                 : WORD
  )                    : BOOL;
{ $END }


{ $IFDECL SetFocus $THEN BEGIN }
  FUNCTION  SetFocus (
    h_                 : HWND
  )                    : HWND;
{ $END }

{ $IFDECL GetFocus $THEN BEGIN }
  FUNCTION  GetFocus                    : HWND;
{ $END }

{ $IFDECL GetActiveWindow $THEN BEGIN }
  FUNCTION  GetActiveWindow                    : HWND;
{ $END }


{ $IFDECL GetKeyState $THEN BEGIN }
  FUNCTION  GetKeyState (
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL GetAsyncKeyState $THEN BEGIN }
  FUNCTION  GetAsyncKeyState (
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL GetKeyboardState $THEN BEGIN }
  PROCEDURE GetKeyboardState (
    b_		       : ADS OF BYTE
  );
{ $END }

{ $IFDECL SetKeyboardState $THEN BEGIN }
  PROCEDURE SetKeyboardState (
    b_		       : ADS OF BYTE
  );
{ $END }

{ $IFDECL EnableHardwareInput $THEN BEGIN }
  FUNCTION  EnableHardwareInput (
    b_		       : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL GetInputState $THEN BEGIN }
  FUNCTION  GetInputState (
  )                    : BOOL;
{ $END }

{ $IFDECL GetCapture $THEN BEGIN }
  FUNCTION  GetCapture;
{ $END }

{ $IFDECL SetCapture $THEN BEGIN }
  FUNCTION  SetCapture (
    h_                 : HWND
  )                    : HWND;
{ $END }

{ $IFDECL ReleaseCapture $THEN BEGIN }
  PROCEDURE ReleaseCapture;
{ $END }

(* Windows Functions *)

{ $IFDECL SetTimer $THEN BEGIN }
  FUNCTION  SetTimer (
    h_                 : HWND;
    s_                 : short;
    w_                 : WORD;
    f_                 : FARPROC
  )		       : WORD;
{ $END }

{ $IFDECL KillTimer $THEN BEGIN }
  FUNCTION  KillTimer (
    h_                 : HWND;
    s_                 : short
  )                    : BOOL;
{ $END }


{ $IFDECL EnableWindow $THEN BEGIN }
  FUNCTION  EnableWindow (
    h_                 : HWND;
    b_                 : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL IsWindowEnabled $THEN BEGIN }
  FUNCTION  IsWindowEnabled (
    h_                 : HWND
  )                    : BOOL;
{ $END }


{ $IFDECL LoadAccelerators $THEN BEGIN }
  FUNCTION  LoadAccelerators (
    h_                 : HANDLE;
    l_                 : LPSTR
  )                    : HANDLE;
{ $END }


{ $IFDECL TranslateAccelerator $THEN BEGIN }
  FUNCTION  TranslateAccelerator (
    h_                 : HWND;
    i_                 : HANDLE;
    l_                 : LPMSG
  )                    : int;
{ $END }


(* GetSystemMetrics codes *)

CONST
  SM_CXSCREEN           = 0;
  SM_CYSCREEN           = 1;
  SM_CXVSCROLL          = 2;
  SM_CYHSCROLL          = 3;
  SM_CYCAPTION          = 4;
  SM_CXBORDER           = 5;
  SM_CYBORDER           = 6;
  SM_CXDLGFRAME         = 7;
  SM_CYDLGFRAME         = 8;
  SM_CYVTHUMB           = 9;
  SM_CXHTHUMB           = 10;
  SM_CXICON             = 11;
  SM_CYICON             = 12;
  SM_CXCURSOR           = 13;
  SM_CYCURSOR           = 14;
  SM_CYMENU             = 15;
  SM_CXFULLSCREEN       = 16;
  SM_CYFULLSCREEN       = 17;
  SM_CYKANJIWINDOW      = 18;
  SM_MOUSEPRESENT       = 19;
  SM_CYVSCROLL          = 20;
  SM_CXHSCROLL          = 21;
  SM_DEBUG              = 22;
  SM_SWAPBUTTON         = 23;
  SM_RESERVED1		= 24;
  SM_RESERVED2		= 25;
  SM_RESERVED3		= 26;
  SM_RESERVED4		= 27;
  SM_CXMIN		= 28;
  SM_CYMIN		= 29;
  SM_CXSIZE		= 30;
  SM_CYSIZE		= 31;
  SM_CXFRAME		= 32;
  SM_CYFRAME		= 33;
  SM_CXMINTRACK 	= 34;
  SM_CYMINTRACK 	= 35;
  SM_CMETRICS		= 36;


{ $IFDECL GetSystemMetrics $THEN BEGIN }
  FUNCTION  GetSystemMetrics (
    i_                 : int
  )                    : int;
{ $END }


{ $IFDECL HiliteMenuItem $THEN BEGIN }
  FUNCTION  HiliteMenuItem (
    h_                 : HWND;
    i_                 : HMENU;
    w_,x_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL GetMenuString $THEN BEGIN }
  FUNCTION  GetMenuString (
    h_                 : HMENU;
    w_                 : WORD;
    l_                 : LPSTR;
    i_                 : int;
    x_                 : WORD
  )                    : int;
{ $END }

{ $IFDECL GetMenuState $THEN BEGIN }
  FUNCTION  GetMenuState (
    h_                 : HMENU;
    w_                 : WORD;
    w_		       : WORD
  )		       : WORD;
{ $END }

{ $IFDECL GetMenuItemID $THEN BEGIN }
  FUNCTION  GetMenuItemID (
    h_                 : HMENU;
    i_		       : int
  )		       : WORD;
{ $END }

{ $IFDECL GetMenuItemCount $THEN BEGIN }
  FUNCTION  GetMenuItemCount (
    h_		       : HMENU
  )		       : WORD;
{ $END }

{ $IFDECL DrawMenuBar $THEN BEGIN }
  PROCEDURE DrawMenuBar (
    h_                 : HWND
  );
{ $END }

{ $IFDECL GetSystemMenu $THEN BEGIN }
  FUNCTION  GetSystemMenu (
    h_                 : HWND;
    b_                 : BOOL
  )                    : HMENU;
{ $END }

{ $IFDECL CreateMenu $THEN BEGIN }
  FUNCTION  CreateMenu                    : HMENU;
{ $END }

{ $IFDECL DestroyMenu $THEN BEGIN }
  FUNCTION  DestroyMenu (
    h_                 : HMENU
  )                    : BOOL;
{ $END }

{ $IFDECL ChangeMenu $THEN BEGIN }
  FUNCTION  ChangeMenu (
    h_                 : HMENU;
    w_                 : WORD;
    l_                 : LPSTR;
    x_,y_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL CheckMenuItem $THEN BEGIN }
  FUNCTION  CheckMenuItem (
    h_                 : HMENU;
    w_,x_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL EnableMenuItem $THEN BEGIN }
  FUNCTION  EnableMenuItem (
    h_                 : HMENU;
    w_,x_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL GetSubMenu $THEN BEGIN }
  FUNCTION  GetSubMenu (
    h_                 : HMENU;
    i_                 : int
  )                    : HMENU;
{ $END }

{ $IFDECL EndMenu $THEN BEGIN }
  PROCEDURE EndMenu;
{ $END }


{ $IFDECL GrayString $THEN BEGIN }
  FUNCTION  GrayString (
    h_                 : HDC;
    i_                 : HBRUSH;
    f_                 : FARPROC;
    d_                 : DWORD;
    j_,k_,l_,m_,n_     : int
  )                    : BOOL;
{ $END }

{ $IFDECL UpdateWindow $THEN BEGIN }
  PROCEDURE UpdateWindow (
    h_                 : HWND
  );
{ $END }

{ $IFDECL SetActiveWindow $THEN BEGIN }
  FUNCTION  SetActiveWindow (
    h_                 : HWND
  )                    : HWND;
{ $END }


{ $IFDECL GetWindowDC $THEN BEGIN }
  FUNCTION  GetWindowDC (
    h_                 : HWND
  )                    : HDC;
{ $END }

{ $IFDECL GetDC $THEN BEGIN }
  FUNCTION  GetDC (
    h_                 : HWND
  )                    : HDC;
{ $END }

{ $IFDECL ReleaseDC $THEN BEGIN }
  FUNCTION  ReleaseDC (
    h_                 : HWND;
    i_                 : HDC
  )                    : int;
{ $END }


{ $IFDECL BeginPaint $THEN BEGIN }
  FUNCTION  BeginPaint (
    h_                 : HWND;
    l_                 : LPPAINTSTRUCT
  )                    : HDC;
{ $END }


{ $IFDECL EndPaint $THEN BEGIN }
  PROCEDURE EndPaint (
    h_                 : HWND;
    l_                 : LPPAINTSTRUCT
  );
{ $END }

{ $IFDECL GetUpdateRect $THEN BEGIN }
  FUNCTION  GetUpdateRect (
    h_                 : HWND;
    l_                 : LPRECT;
    b_                 : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL GetUpdateRgn $THEN BEGIN }
  FUNCTION  GetUpdateRgn (
    h_                 : HWND;
    r_		       : HRGN;
    b_                 : BOOL
  )		       : int;
{ $END }

{ $IFDECL GetUpdateRgn $THEN BEGIN }
  FUNCTION  GetUpdateRgn (
    d_		       : HDC;
    h_		       : HWND
  )		       : short;
{ $END }

{ $IFDECL InvalidateRect $THEN BEGIN }
  PROCEDURE InvalidateRect (
    h_                 : HWND;
    l_                 : LPRECT;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL ValidateRect $THEN BEGIN }
  PROCEDURE ValidateRect (
    h_                 : HWND;
    l_                 : LPRECT
  );
{ $END }


{ $IFDECL InvalidateRgn $THEN BEGIN }
  PROCEDURE InvalidateRgn (
    h_                 : HWND;
    i_                 : HRGN;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL ValidateRgn $THEN BEGIN }
  PROCEDURE ValidateRgn (
    h_                 : HWND;
    i_                 : HRGN
  );
{ $END }


{ $IFDECL ScrollWindow $THEN BEGIN }
  PROCEDURE ScrollWindow (
    h_                 : HWND;
    i_,j_              : int;
    l_,m_              : LPRECT
  );
{ $END }

{ $IFDECL ScrollDC $THEN BEGIN }
  FUNCTION ScrollDC (
    h_		       : HDC;
    i_,j_              : int;
    l_,m_	       : LPRECT;
    r_		       : HRGN;
    p_		       : LPRECT
  )		       : BOOL;
{ $END }

{ $IFDECL SetScrollPos $THEN BEGIN }
  FUNCTION  SetScrollPos (
    h_                 : HWND;
    i_,j_              : int;
    b_                 : BOOL
  )                    : int;
{ $END }

{ $IFDECL GetScrollPos $THEN BEGIN }
  FUNCTION  GetScrollPos (
    h_                 : HWND;
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL SetScrollRange $THEN BEGIN }
  PROCEDURE SetScrollRange (
    h_                 : HWND;
    i_,j_,k_           : int;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL GetScrollRange $THEN BEGIN }
  PROCEDURE GetScrollRange (
    h_                 : HWND;
    i_                 : int;
    l_,m_              : LPINT
  );
{ $END }

{ $IFDECL ShowScrollBar $THEN BEGIN }
  PROCEDURE ShowScrollBar (
    h_                 : HWND;
    w_		       : WORD;
    b_		       : BOOL
  );
{ $END }

{ $IFDECL SetProp $THEN BEGIN }
  FUNCTION  SetProp (
    h_                 : HWND;
    l_                 : LPSTR;
    i_                 : HANDLE
  )                    : BOOL;
{ $END }

{ $IFDECL GetProp $THEN BEGIN }
  FUNCTION  GetProp (
    h_                 : HWND;
    l_                 : LPSTR
  )                    : HANDLE;
{ $END }

{ $IFDECL RemoveProp $THEN BEGIN }
  FUNCTION  RemoveProp (
    h_                 : HWND;
    l_                 : LPSTR
  )                    : HANDLE;
{ $END }

{ $IFDECL EnumProps $THEN BEGIN }
  FUNCTION  EnumProps (
    h_                 : HWND;
    f_                 : FARPROC
  )                    : int;
{ $END }

{ $IFDECL SetWindowText $THEN BEGIN }
  PROCEDURE SetWindowText (
    h_                 : HWND;
    l_                 : LPSTR
  );
{ $END }

{ $IFDECL GetWindowText $THEN BEGIN }
  FUNCTION  GetWindowText (
    h_                 : HWND;
    l_                 : LPSTR;
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL GetWindowTextLength $THEN BEGIN }
  FUNCTION  GetWindowTextLength (
    h_                 : HWND
  )                    : int;
{ $END }

{ $IFDECL SetMenu $THEN BEGIN }
  FUNCTION  SetMenu (
    h_                 : HWND;
    i_                 : HMENU
  )                    : BOOL;
{ $END }

{ $IFDECL GetMenu $THEN BEGIN }
  FUNCTION  GetMenu (
    h_                 : HWND
  )                    : HMENU;
{ $END }


{ $IFDECL GetClientRect $THEN BEGIN }
  PROCEDURE GetClientRect (
    h_                 : HWND;
    l_                 : LPRECT
  );
{ $END }

{ $IFDECL GetWindowRect $THEN BEGIN }
  PROCEDURE GetWindowRect (
    h_                 : HWND;
    l_                 : LPRECT
  );
{ $END }

{ $IFDECL AdjustWindowRect $THEN BEGIN }
  PROCEDURE AdjustWindowRect (
    l_		       : LPRECT
    l2_ 	       : long;
    b_		       : BOOL
  );
{ $END }

(* MessageBox type_flags *)

CONST
  MB_OK                 = #0000;
  MB_OKCANCEL           = #0001;
  MB_ABORTRETRYIGNORE   = #0002;
  MB_YESNOCANCEL        = #0003;
  MB_YESNO              = #0004;
  MB_RETRYCANCEL        = #0005;

  MB_ICONHAND           = #0010;
  MB_ICONQUESTION       = #0020;
  MB_ICONEXCLAMATION    = #0030;
  MB_ICONASTERISK       = #0040;

  MB_DEFBUTTON1         = #0000;
  MB_DEFBUTTON2         = #0100;
  MB_DEFBUTTON3         = #0200;

  MB_APPLMODAL          = #0000;
  MB_SYSTEMMODAL        = #1000;
  MB_NOFOCUS            = #8000;
  MB_MISCMASK           = #c000;
  MB_TYPEMASK           = #000f;
  MB_ICONMASK           = #00f0;
  MB_DEFMASK            = #0f00;
  MB_MODEMASK           = #3000;


{ $IFDECL MessageBox $THEN BEGIN }
  FUNCTION  MessageBox (
    h_                 : HWND;
    l_,m_              : LPSTR;
    w_                 : WORD
  )                    : int;
{ $END }

{ $IFDECL MessageBeep $THEN BEGIN }
  FUNCTION  MessageBeep (
    w_                 : WORD
  )                    : BOOL;
{ $END }


{ $IFDECL ShowCursor $THEN BEGIN }
  FUNCTION  ShowCursor (
    b_                 : BOOL
  )                    : int;
{ $END }


{ $IFDECL SetCursor $THEN BEGIN }
  FUNCTION  SetCursor (
    h_                 : HCURSOR
  )                    : HCURSOR;
{ $END }


{ $IFDECL SetCursorPos $THEN BEGIN }
  PROCEDURE SetCursorPos (
    i_,j_              : int
  );
{ $END }


{ $IFDECL GetCursorPos $THEN BEGIN }
  PROCEDURE GetCursorPos (
    l_                 : LPPOINT
  );
{ $END }


{ $IFDECL ClipCursor $THEN BEGIN }
  PROCEDURE ClipCursor (
    l_                 : LPRECT
  );
{ $END }


{ $IFDECL CreateCaret $THEN BEGIN }
  PROCEDURE CreateCaret (
    h_                 : HWND;
    i_                 : HBITMAP;
    j_,k_              : int
  );
{ $END }



{ $IFDECL GetCaretBlinkTime $THEN BEGIN }
  FUNCTION  GetCaretBlinkTime                    : WORD;
{ $END }

{ $IFDECL SetCaretBlinkTime $THEN BEGIN }
  PROCEDURE SetCaretBlinkTime (
    w_                 : WORD
  );
{ $END }

{ $IFDECL DestroyCaret $THEN BEGIN }
  PROCEDURE DestroyCaret;
{ $END }

{ $IFDECL HideCaret $THEN BEGIN }
  PROCEDURE HideCaret (
    h_                 : HWND
  );
{ $END }

{ $IFDECL ShowCaret $THEN BEGIN }
  PROCEDURE ShowCaret (
    h_                 : HWND
  );
{ $END }

{ $IFDECL SetCaretPos $THEN BEGIN }
  PROCEDURE SetCaretPos (
    i_,j_              : int
  );
{ $END }

{ $IFDECL GetCaretPos $THEN BEGIN }
  PROCEDURE GetCaretPos (
    l_			 : LPPOINT
  );
{ $END }

{ $IFDECL ClientToScreen $THEN BEGIN }
  PROCEDURE ClientToScreen (
    h_                 : HWND;
    l_                 : LPPOINT
  );
{ $END }

{ $IFDECL ScreenToClient $THEN BEGIN }
  PROCEDURE ScreenToClient (
    h_                 : HWND;
    l_                 : LPPOINT
  );
{ $END }

{ $IFDECL WindowFromPoint $THEN BEGIN }
  FUNCTION  WindowFromPoint (
    p_                 : POINT
  )                    : HWND;
{ $END }

{ $IFDECL ChildWindowFromPoint $THEN BEGIN }
  FUNCTION  ChildWindowFromPoint (
    h_                 : HWND;
    p_                 : POINT
  )                    : HWND;
{ $END }

(* color type_indices           *)
(* for the WM_CTLCOLOR message *)

CONST
  CTLCOLOR_MSGBOX       = 0;
  CTLCOLOR_EDIT         = 1;
  CTLCOLOR_LISTBOX      = 2;
  CTLCOLOR_BTN          = 3;
  CTLCOLOR_DLG          = 4;
  CTLCOLOR_SCROLLBAR    = 5;
  CTLCOLOR_STATIC       = 6;
  CTLCOLOR_MAX          = 8     (* three bits max *);

  COLOR_SCROLLBAR       = 0;
  COLOR_BACKGROUND      = 1;
  COLOR_ACTIVECAPTION   = 2;
  COLOR_INACTIVECAPTION = 3;
  COLOR_MENU            = 4;
  COLOR_WINDOW          = 5;
  COLOR_WINDOWFRAME     = 6;
  COLOR_MENUTEXT        = 7;
  COLOR_WINDOWTEXT      = 8;
  COLOR_CAPTIONTEXT     = 9;
  COLOR_ACTIVEBORDER	= 10;
  COLOR_INACTIVEBORDER	= 11;
  COLOR_APPWORKSPACE	= 12;


{ $IFDECL GetSysColor $THEN BEGIN }
  FUNCTION  GetSysColor (
    i_                 : int
  )                    : DWORD;
{ $END }

{ $IFDECL SetSysColors $THEN BEGIN }
  PROCEDURE SetSysColors (
    i_                 : int;
    l_                 : LPINT;
    m_                 : LPlong
  );
{ $END }

  CP_GETBEEP	    = 1;
  CP_SETBEEP	    = 2;
  CP_GETMOUSE	    = 3;
  CP_SETMOUSE	    = 4;
  CP_GETBORDER	    = 5;
  CP_SETBORDER	    = 6;
  CP_TIMEOUTS	    = 7;
  CP_KANJIMENU	    = 8;

{ $IFDECL ControlPanelInfo $THEN BEGIN }
  PROCEDURE ControlPanelInfo (
    w_,x_	       : WORD;
    l_		       : LONG
  );
{ $END }

{ $IFDECL CreateDC $THEN BEGIN }
  FUNCTION  CreateDC (
    l_,m_,n_,o_        : LPSTR
  )                    : HDC;
{ $END }

{ $IFDECL CreateIC $THEN BEGIN }
  FUNCTION  CreateIC (
    l_,m_,n_,o_        : LPSTR
  )                    : HDC;
{ $END }

{ $IFDECL CreateCompatibleDC $THEN BEGIN }
  FUNCTION  CreateCompatibleDC (
    h_                 : HDC
  )                    : HDC;
{ $END }

{ $IFDECL DeleteDC $THEN BEGIN }
  FUNCTION  DeleteDC (
    h_                 : HDC
  )                    : BOOL;
{ $END }

{ $IFDECL SaveDC $THEN BEGIN }
  FUNCTION  SaveDC (
    h_                 : HDC
  )                    : short;
{ $END }

{ $IFDECL RestoreDC $THEN BEGIN }
  FUNCTION  RestoreDC (
    h_                 : HDC;
    s_                 : short
  )                    : BOOL;
{ $END }

{ $IFDECL MoveTo $THEN BEGIN }
  FUNCTION  MoveTo (
    h_                 : HDC;
    s_,t_              : short
  )                    : DWORD;
{ $END }

{ $IFDECL GetCurrentPosition $THEN BEGIN }
  FUNCTION  GetCurrentPosition (
    h_                 : HDC
  )                    : DWORD;
{ $END }

{ $IFDECL LineTo $THEN BEGIN }
  FUNCTION  LineTo (
    h_                 : HDC;
    s_,t_              : short
  )                    : BOOL;
{ $END }

{ $IFDECL GetDCOrg $THEN BEGIN }
  FUNCTION  GetDCOrg (
    h_		       : HDC
  )		       : DWORD;
{ $END }

{ $IFDECL ExtTextOut $THEN BEGIN }
  FUNCTION  ExtTextOut (
    h_                 : HDC;
    s_,t_	       : short;
    w_		       : WORD;
    l_		       : LPRECT;
    p_		       : LPSTR;
    i_		       : WORD;
    n_		       : LPINT
  )                    : BOOL;
{ $END }

{ $IFDECL FastWindowFrame $THEN BEGIN }
  FUNCTION  FastWindowFrame (
    h_                 : HDC;
    l_		       : LPRECT;
    w_,x_	       : WORD;
    i_		       : DWORD
  )                    : BOOL;
{ $END }

{ $IFDECL Polyline $THEN BEGIN }
  FUNCTION  Polyline (
    h_                 : HDC;
    l_                 : LPPOINT;
    s_                 : short
  )                    : BOOL;
{ $END }

{ $IFDECL Polygon $THEN BEGIN }
  FUNCTION  Polygon (
    h_                 : HDC;
    l_                 : LPPOINT;
    s_                 : short
  )                    : BOOL;
{ $END }


{ $IFDECL Rectangle $THEN BEGIN }
  FUNCTION  Rectangle (
    h_                 : HDC;
    s_,t_,u_,v_        : short
  )                    : BOOL;
{ $END }

{ $IFDECL RoundRect $THEN BEGIN }
  FUNCTION  RoundRect (
    h_                 : HDC;
    s_,t_,u_,v_,w_,x_  : short
  )                    : BOOL;
{ $END }

{ $IFDECL Ellipse $THEN BEGIN }
  FUNCTION  Ellipse (
    h_                 : HDC;
    s_,t_,u_,v_        : short
  )                    : BOOL;
{ $END }

{ $IFDECL Arc $THEN BEGIN }
  FUNCTION  Arc (
    h_                 : HDC;
    s_,t_,u_,v_,w_,x_,y_,z_ : short
  )                         : BOOL;
{ $END }

{ $IFDECL Chord $THEN BEGIN }
  FUNCTION  Chord (
    h_                 : HDC;
    s_,t_,u_,v_,w_,x_,y_,z_ : short
  )                         : BOOL;
{ $END }

{ $IFDECL Pie $THEN BEGIN }
  FUNCTION  Pie (
    h_                      : HDC;
    s_,t_,u_,v_,w_,x_,y_,z_ : short
  )                         : BOOL;
{ $END }

{ $IFDECL PatBlt $THEN BEGIN }
  FUNCTION  PatBlt (
    h_                      : HDC;
    s_,t_,u_,v_             : short;
    d_                      : DWORD
  )                         : BOOL;
{ $END }

{ $IFDECL BitBlt $THEN BEGIN }
  FUNCTION  BitBlt (
    h_                      : HDC;
    s_,t_,u_,v_             : short;
    i_                      : HDC;
    w_,x_                   : short;
    d_                      : DWORD
  )                         : BOOL;
{ $END }

{ $IFDECL StretchBlt $THEN BEGIN }
  FUNCTION  StretchBlt (
    h_                      : HDC;
    s_,t_,u_,v_             : short;
    i_                      : HDC;
    w_,x_,y_,z_             : short;
    d_                      : DWORD
  )                         : BOOL;
{ $END }

{ $IFDECL TextOut $THEN BEGIN }
  FUNCTION  TextOut (
    h_                      : HDC;
    s_,t_                   : short;
    l_                      : LPSTR;
    u_                      : short
  )                         : BOOL;
{ $END }

{ $IFDECL GetCharWidth $THEN BEGIN }
  FUNCTION  GetCharWidth (
    h_                      : HDC;
    w_,x_		    : WORD;
    l_			    : LPINT
  )			    : BOOL;
{ $END }

{ $IFDECL SetPixel $THEN BEGIN }
  FUNCTION  SetPixel (
    h_                      : HDC;
    s_,t_                   : short;
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL GetPixel $THEN BEGIN }
  FUNCTION  GetPixel (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL FloodFill $THEN BEGIN }
  FUNCTION  FloodFill (
    h_                      : HDC;
    s_,t_                   : short;
    d_                      : DWORD
  )                         : BOOL;
{ $END }


{ $IFDECL LineDDA $THEN BEGIN }
  PROCEDURE LineDDA (
    s_,t_,u_,v_             : short;
    f_                      : FARPROC;
    l_                      : LPSTR
  );
{ $END }


{ $IFDECL FillRect $THEN BEGIN }
  FUNCTION  FillRect (
    h_                      : HDC;
    l_                      : LPRECT;
    i_                      : HBRUSH
  )                         : int;
{ $END }

{ $IFDECL FrameRect $THEN BEGIN }
  FUNCTION  FrameRect (
    h_                      : HDC;
    l_                      : LPRECT;
    i_                      : HBRUSH
  )                         : int;
{ $END }

{ $IFDECL InvertRect $THEN BEGIN }
  FUNCTION  InvertRect (
    h_                      : HDC;
    l_                      : LPRECT
  )                         : int;
{ $END }



{ $IFDECL FillRgn $THEN BEGIN }
  FUNCTION  FillRgn (
    h_                      : HDC;
    i_                      : HRGN;
    j_                      : HBRUSH
  )                         : BOOL;
{ $END }

{ $IFDECL FrameRgn $THEN BEGIN }
  FUNCTION  FrameRgn (
    h_                      : HDC;
    i_                      : HRGN;
    j_                      : HBRUSH;
    s_,t_                   : short
  )                         : BOOL;
{ $END }

{ $IFDECL InvertRgn $THEN BEGIN }
  FUNCTION  InvertRgn (
    h_                      : HDC;
    i_                      : HRGN
  )                         : BOOL;
{ $END }

{ $IFDECL PaintRgn $THEN BEGIN }
  FUNCTION  PaintRgn (
    h_                      : HDC;
    i_                      : HRGN
  )                         : BOOL;
{ $END }

{ $IFDECL PtInRegion $THEN BEGIN }
  FUNCTION  PtInRegion (
    h_                      : HRGN;
    s_,t_                   : short
  )                         : BOOL;
{ $END }


{ $IFDECL GetStockObject $THEN BEGIN }
  FUNCTION  GetStockObject (
    s_                      : short
  )                         : HANDLE;
{ $END }


{ $IFDECL CreatePen $THEN BEGIN }
  FUNCTION  CreatePen (
    s_,t_                   : short;
    d_                      : DWORD
  )                         : HPEN;
{ $END }

{ $IFDECL CreatePenIndirect $THEN BEGIN }
  FUNCTION  CreatePenIndirect (
    l_                      : LPLOGPEN
  )                         : HPEN;
{ $END }


{ $IFDECL CreateSolidBrush $THEN BEGIN }
  FUNCTION  CreateSolidBrush (
    d_                      : DWORD
  )                         : HBRUSH;
{ $END }

{ $IFDECL CreateHatchBrush $THEN BEGIN }
  FUNCTION  CreateHatchBrush (
    s_                      : short;
    d_                      : DWORD
  )                         : HBRUSH;
{ $END }

{ $IFDECL SetBrushOrg $THEN BEGIN }
  FUNCTION  SetBrushOrg (
    h_                      : HDC;
    i_,j_                   : int
  )                         : DWORD;
{ $END }

{ $IFDECL GetBrushOrg $THEN BEGIN }
  FUNCTION  GetBrushOrg (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL UnrealizeObject $THEN BEGIN }
  FUNCTION  UnrealizeObject (
    h_                      : HBRUSH
  )                         : BOOL;
{ $END }


{ $IFDECL CreatePatternBrush $THEN BEGIN }
  FUNCTION  CreatePatternBrush (
    h_                      : HBITMAP
  )                         : HBRUSH;
{ $END }

{ $IFDECL CreateBrushIndirect $THEN BEGIN }
  FUNCTION  CreateBrushIndirect (
    l_                      : LPLOGBRUSH
  )                         : HBRUSH;
{ $END }



{ $IFDECL CreateBitmap $THEN BEGIN }
  FUNCTION  CreateBitmap (
    s_,t_                   : short;
    b_,c_                   : BYTE;
    l_                      : LPSTR
  )                         : HBITMAP;
{ $END }

{ $IFDECL CreateBitmapIndirect $THEN BEGIN }
  FUNCTION  CreateBitmapIndirect (
    b_                      : LPBITMAP
  )                         : HBITMAP;
{ $END }

{ $IFDECL CreateCompatibleBitmap $THEN BEGIN }
  FUNCTION  CreateCompatibleBitmap (
    h_                      : HDC;
    s_,t_                   : short
  )                         : HBITMAP;
{ $END }

{ $IFDECL CreateDiscardableBitmap $THEN BEGIN }
  FUNCTION  CreateDiscardableBitmap (
    h_                      : HDC;
    s_,t_                   : short
  )                         : HBITMAP;
{ $END }

{ $IFDECL SetBitmapBits $THEN BEGIN }
  FUNCTION  SetBitmapBits (
    h_                      : HBITMAP;
    d_                      : DWORD;
    l_                      : LPSTR
  )			    : long;
{ $END }

{ $IFDECL GetBitmapBits $THEN BEGIN }
  FUNCTION  GetBitmapBits (
    h_                      : HBITMAP;
    l_                      : long;
    m_                      : LPSTR
  )                         : long;
{ $END }

{ $IFDECL SetBitmapDimension $THEN BEGIN }
  FUNCTION  SetBitmapDimension (
    h_                      : HBITMAP;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetBitmapDimension $THEN BEGIN }
  FUNCTION  GetBitmapDimension (
    h_                      : HBITMAP
  )                         : DWORD;
{ $END }


{ $IFDECL CreateFont $THEN BEGIN }
  FUNCTION  CreateFont (
    s_,t_,u_,v_,w_          : short;
    b_,c_,d_,e_,f_,g_,h_,i_ : BYTE;
    l_                      : LPSTR
  )                         : HFONT;
{ $END }

{ $IFDECL CreateFontIndirect $THEN BEGIN }
  FUNCTION  CreateFontIndirect (
    l_                      : LPLOGFONT
  )                         : HFONT;
{ $END }


{ $IFDECL CreateRectRgn $THEN BEGIN }
  FUNCTION  CreateRectRgn (
    s_,t_,u_,v_             : short
  )                         : HRGN;
{ $END }

{ $IFDECL SetRectRgn $THEN BEGIN }
  PROCEDURE  SetRectRgn     (
    h_			    : HRGN;
    s_,t_,u_,v_ 	    : short;
  );
{ $END }


{ $IFDECL CreateRectRgnIndirect $THEN BEGIN }
  FUNCTION  CreateRectRgnIndirect (
    l_                      : LPRECT
  )                         : HRGN;
{ $END }

{ $IFDECL CreateEllipticRgnIndirect $THEN BEGIN }
  FUNCTION  CreateEllipticRgnIndirect (
    l_                      : LPRECT
  )                         : HRGN;
{ $END }


{ $IFDECL CreateEllipticRgn $THEN BEGIN }
  FUNCTION  CreateEllipticRgn (
    s_,t_,u_,v_             : short
  )                         : HRGN;
{ $END }

{ $IFDECL CreatePolygonRgn $THEN BEGIN }
  FUNCTION  CreatePolygonRgn (
    l_                      : LPPOINT;
    s_,t_                   : short
  )                         : HRGN;
{ $END }


{ $IFDECL DeleteObject $THEN BEGIN }
  FUNCTION  DeleteObject (
    h_                      : HANDLE
  )                         : BOOL;
{ $END }

{ $IFDECL SelectObject $THEN BEGIN }
  FUNCTION  SelectObject (
    h_                      : HDC;
    i_                      : HANDLE
  )                         : HANDLE;
{ $END }


{ $IFDECL SelectClipRgn $THEN BEGIN }
  FUNCTION  SelectClipRgn (
    h_                      : HDC;
    i_                      : HRGN
  )                         : short;
{ $END }


{ $IFDECL GetObject $THEN BEGIN }
  FUNCTION  GetObject (
    h_                      : HANDLE;
    s_                      : short;
    l_                      : LPSTR
  )                         : short;
{ $END }


{ $IFDECL SetRelAbs $THEN BEGIN }
  FUNCTION  SetRelAbs (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetRelAbs $THEN BEGIN }
  FUNCTION  GetRelAbs (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetBkColor $THEN BEGIN }
  FUNCTION  SetBkColor (
    h_                      : HDC;
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL GetBkColor $THEN BEGIN }
  FUNCTION  GetBkColor (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetBkMode $THEN BEGIN }
  FUNCTION  SetBkMode (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetBkMode $THEN BEGIN }
  FUNCTION  GetBkMode (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetTextColor $THEN BEGIN }
  FUNCTION  SetTextColor (
    h_                      : HDC;
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL GetTextColor $THEN BEGIN }
  FUNCTION  GetTextColor (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetTextAlign $THEN BEGIN }
  FUNCTION  SetTextAlign (
    h_			    : HDC;
    w_			    : WORD
  )			    : WORD;
{ $END }

{ $IFDECL GetTextAlign $THEN BEGIN }
  FUNCTION  GetTextAlign (
    h_                      : HDC
  )			    : WORD;
{ $END }

{ $IFDECL SetMapperFlags $THEN BEGIN }
  FUNCTION  SetMapperFlags (
    h_			    : HDC;
    w_			    : WORD
  )			    : DWORD;
{ $END }

{ $IFDECL GetAspectRatioFilter $THEN BEGIN }
  FUNCTION  GetAspectRatioFilter (
    h_			    : HDC
  )			    : DWORD;
{ $END }

{ $IFDECL GetNearestColor $THEN BEGIN }
  FUNCTION  GetNearestColor (
    h_                      : HDC;
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL SetROP2 $THEN BEGIN }
  FUNCTION  SetROP2 (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetROP2 $THEN BEGIN }
  FUNCTION  GetROP2 (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetStretchBltMode $THEN BEGIN }
  FUNCTION  SetStretchBltMode (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetStretchBltMode $THEN BEGIN }
  FUNCTION  GetStretchBltMode (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetPolyFillMode $THEN BEGIN }
  FUNCTION  SetPolyFillMode (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetPolyFillMode $THEN BEGIN }
  FUNCTION  GetPolyFillMode (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetMapMode $THEN BEGIN }
  FUNCTION  SetMapMode (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetMapMode $THEN BEGIN }
  FUNCTION  GetMapMode (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetWindowOrg $THEN BEGIN }
  FUNCTION  SetWindowOrg (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetWindowOrg $THEN BEGIN }
  FUNCTION  GetWindowOrg (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetWindowExt $THEN BEGIN }
  FUNCTION  SetWindowExt (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetWindowExt $THEN BEGIN }
  FUNCTION  GetWindowExt (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetViewportOrg $THEN BEGIN }
  FUNCTION  SetViewportOrg (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetViewportOrg $THEN BEGIN }
  FUNCTION  GetViewportOrg (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetViewportExt $THEN BEGIN }
  FUNCTION  SetViewportExt (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetViewportExt $THEN BEGIN }
  FUNCTION  GetViewportExt (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL OffsetViewportOrg $THEN BEGIN }
  FUNCTION  OffsetViewportOrg (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL ScaleViewportExt $THEN BEGIN }
  FUNCTION  ScaleViewportExt (
    h_                      : HDC;
    s_,t_,r_,q_ 	    : short
  )                         : DWORD;
{ $END }

{ $IFDECL OffsetWindowOrg $THEN BEGIN }
  FUNCTION  OffsetWindowOrg (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL ScaleWindowExt $THEN BEGIN }
  FUNCTION  ScaleWindowExt (
    h_                      : HDC;
    s_,t_,r_,q_ 	    : short
  )                         : DWORD;
{ $END }


{ $IFDECL GetClipBox $THEN BEGIN }
  FUNCTION  GetClipBox (
    h_                      : HDC;
    l_                      : LPRECT
  )                         : short;
{ $END }


{ $IFDECL IntersectClipRect $THEN BEGIN }
  FUNCTION  IntersectClipRect (
    h_                      : HDC;
    s_,t_,u_,v_             : short
  )                         : short;
{ $END }

{ $IFDECL OffsetClipRgn $THEN BEGIN }
  FUNCTION  OffsetClipRgn (
    h_                      : HDC;
    s_,t_                   : short
  )                         : short;
{ $END }

{ $IFDECL ExcludeClipRect $THEN BEGIN }
  FUNCTION  ExcludeClipRect (
    h_                      : HDC;
    s_,t_,u_,v_             : short
  )                         : short;
{ $END }

{ $IFDECL PtVisible $THEN BEGIN }
  FUNCTION  PtVisible (
    h_                      : HDC;
    s_,t_                   : short
  )                         : BOOL;
{ $END }


{ $IFDECL SetRect $THEN BEGIN }
  FUNCTION  SetRect (
    l_                      : LPRECT;
    i_,j_,k_,m_             : int
  )                         : int;
{ $END }

{ $IFDECL SetRectEmpty $THEN BEGIN }
  FUNCTION  SetRectEmpty (
    l_                      : LPRECT
  )                         : int;
{ $END }

{ $IFDECL CopyRect $THEN BEGIN }
  FUNCTION  CopyRect (
    l_,m_                   : LPRECT
  )                         : int;
{ $END }

{ $IFDECL InflateRect $THEN BEGIN }
  FUNCTION  InflateRect (
    l_                      : LPRECT;
    i_,j_                   : int
  )                         : int;
{ $END }

{ $IFDECL IntersectRect $THEN BEGIN }
  FUNCTION  IntersectRect (
    l_,m_,n_                : LPRECT
  )                         : int;
{ $END }

{ $IFDECL UnionRect $THEN BEGIN }
  FUNCTION  UnionRect (
    l_,m_,n_                : LPRECT
  )                         : int;
{ $END }

{ $IFDECL OffsetRect $THEN BEGIN }
  FUNCTION  OffsetRect (
    l_                      : LPRECT;
    i_,j_                   : int
  )                         : int;
{ $END }

{ $IFDECL IsRectEmpty $THEN BEGIN }
  FUNCTION  IsRectEmpty (
    l_                      : LPRECT
  )                         : BOOL;
{ $END }

{ $IFDECL EqualRect $THEN BEGIN }
  FUNCTION  EqualRect (
    l_,k_		    : LPRECT
  )                         : BOOL;
{ $END }

{ $IFDECL PtInRect $THEN BEGIN }
  FUNCTION  PtInRect (
    l_                      : LPRECT;
    p_                      : POINT
  )                         : BOOL;
{ $END }


{ $IFDECL RectVisible $THEN BEGIN }
  FUNCTION  RectVisible (
    h_                      : HDC;
    l_                      : LPRECT
  )                         : BOOL;
{ $END }


{ $IFDECL CombineRgn $THEN BEGIN }
  FUNCTION  CombineRgn (
    h_,i_,j_                : HRGN;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL EqualRgn $THEN BEGIN }
  FUNCTION  EqualRgn (
    h_,i_                   : HRGN
  )                         : BOOL;
{ $END }

{ $IFDECL OffsetRgn $THEN BEGIN }
  FUNCTION  OffsetRgn (
    h_                      : HRGN;
    s_,t_                   : short
  )                         : short;
{ $END }


{ $IFDECL SetTextJustification $THEN BEGIN }
  FUNCTION  SetTextJustification (
    h_                      : HDC;
    s_,t_                   : short
  )                         : short;
{ $END }

{ $IFDECL GetTextExtent $THEN BEGIN }
  FUNCTION  GetTextExtent (
    h_                      : HDC;
    l_                      : LPSTR;
    s_                      : short
  )                         : DWORD;
{ $END }

{ $IFDECL SetTextCharacterExtra $THEN BEGIN }
  FUNCTION  SetTextCharacterExtra (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetTextCharacterExtra $THEN BEGIN }
  FUNCTION  GetTextCharacterExtra (
    h_                      : HDC
  )                         : short;
{ $END }


{ $IFDECL GetMetaFile $THEN BEGIN }
  FUNCTION  GetMetaFile (
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL DeleteMetaFile $THEN BEGIN }
  FUNCTION  DeleteMetaFile (
    h_                      : HANDLE
  )                         : BOOL;
{ $END }

{ $IFDECL CopyMetaFile $THEN BEGIN }
  FUNCTION  CopyMetaFile (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL PlayMetaFileRecord $THEN BEGIN }
  PROCEDURE  PlayMetaFileRecord (
    h_                      : HDC;
    i_			    : LPHANDLETABLE;
    j_			    : LPMETARECORD;
    w_			    : WORD;
  );
{ $END }

{ $IFDECL EnumMetaFile $THEN BEGIN }
  FUNCTION  EnumMetaFile (
    h_                      : HDC;
    i_			    : LOCALHANDLE;
    f_			    : FARPROC;
    a_			    ; ADS OF BYTE
  )                         : BOOL;
{ $END }


{ $IFDECL PlayMetaFile $THEN BEGIN }
  FUNCTION  PlayMetaFile (
    h_                      : HDC;
    i_                      : HANDLE
  )                         : BOOL;
{ $END }

{ $IFDECL Escape $THEN BEGIN }
  FUNCTION  Escape (
    h_                      : HDC;
    s_,t_                   : short;
    l_,m_                   : LPSTR
  )                         : short;
{ $END }

{ $IFDECL EnumFonts $THEN BEGIN }
  FUNCTION  EnumFonts (
    h_                      : HDC;
    l_                      : LPSTR;
    f_                      : FARPROC;
    m_                      : LPSTR
  )                         : short;
{ $END }

{ $IFDECL EnumObjects $THEN BEGIN }
  FUNCTION  EnumObjects (
    h_                      : HDC;
    s_                      : short;
    f_                      : FARPROC;
    l_                      : LPSTR
  )                         : short;
{ $END }

{ $IFDECL GetTextFace $THEN BEGIN }
  FUNCTION  GetTextFace (
    h_                      : HDC;
    s_                      : short;
    l_                      : LPSTR
  )                         : short;
{ $END }

{ $IFDECL GetTextMetrics $THEN BEGIN }
  FUNCTION  GetTextMetrics (
    h_                      : HDC;
    l_                      : LPTEXTMETRIC
  )                         : BOOL;
{ $END }

{ $IFDECL GetDeviceCaps $THEN BEGIN }
  FUNCTION  GetDeviceCaps (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }


{ $IFDECL DeviceModes $THEN BEGIN }
  FUNCTION  DeviceModes (
    h_                      : HWND;
    i_                      : HANDLE;
    l_,m_                   : LPSTR
  )                         : LPSTR;
{ $END }

{ $IFDECL SetEnvironment $THEN BEGIN }
  FUNCTION  SetEnvironment (
    l_,m_                   : LPSTR;
    w_                      : WORD
  )                         : short;
{ $END }

{ $IFDECL GetEnvironment $THEN BEGIN }
  FUNCTION  GetEnvironment (
    l_,m_                   : LPSTR;
    w_                      : WORD
  )                         : short;
{ $END }


{ $IFDECL DPtoLP $THEN BEGIN }
  FUNCTION  DPtoLP (
    h_                      : HDC;
    l_                      : LPPOINT;
    s_                      : short
  )                         : BOOL;
{ $END }

{ $IFDECL LPtoDP $THEN BEGIN }
  FUNCTION  LPtoDP (
    h_                      : HDC;
    l_                      : LPPOINT;
    s_                      : short
  )                         : BOOL;
{ $END }

(* Interface to the dynamic loader/linker *)


{ $IFDECL GetVersion $THEN BEGIN }
  FUNCTION  GetVersion                         : WORD;
{ $END }

{ $IFDECL GetNumTasks $THEN BEGIN }
  FUNCTION  GetNumTasks 		       : WORD;
{ $END }

{ $IFDECL GetCodeHandle $THEN BEGIN }
  FUNCTION  GetCodeHandle (
    f_                      : FARPROC
  )                         : HANDLE;
{ $END }

{ $IFDECL GetModuleHandle $THEN BEGIN }
  FUNCTION  GetModuleHandle (
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL GetModuleUsage $THEN BEGIN }
  FUNCTION  GetModuleUsage (
    h_                      : HANDLE
  )                         : int;
{ $END }

{ $IFDECL GetModuleFileName $THEN BEGIN }
  FUNCTION  GetModuleFileName (
    h_                      : HANDLE;
    l_                      : LPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetInstanceData $THEN BEGIN }
  FUNCTION  GetInstanceData (
    h_                      : HANDLE;
    n_                      : NPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetProcAddress $THEN BEGIN }
  FUNCTION  GetProcAddress (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : FARPROC;
{ $END }

{ $IFDECL MakeProcInstance $THEN BEGIN }
  FUNCTION  MakeProcInstance (
    f_                      : FARPROC;
    h_                      : HANDLE
  )                         : FARPROC;
{ $END }

{ $IFDECL FreeProcInstance $THEN BEGIN }
  PROCEDURE FreeProcInstance (
    f_                      : FARPROC
  );
{ $END }

{ $IFDECL LoadLibrary $THEN BEGIN }
  FUNCTION  LoadLibrary (
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL FreeLibrary $THEN BEGIN }
  FUNCTION  FreeLibrary (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }


{ $IFDECL AnsiToOem $THEN BEGIN }
  FUNCTION  AnsiToOem (
    l_,m_                   : LPSTR
  )                         : BOOL;
{ $END }

{ $IFDECL OemToAnsi $THEN BEGIN }
  FUNCTION  OemToAnsi (
    l_,m_                   : LPSTR
  )                         : BOOL;
{ $END }

{ $IFDECL AnsiUpper $THEN BEGIN }
  FUNCTION  AnsiUpper (
    l_                      : LPSTR
  )                         : BYTE;
{ $END }

{ $IFDECL AnsiLower $THEN BEGIN }
  FUNCTION  AnsiLower (
    l_                      : LPSTR
  )                         : BYTE;
{ $END }

{ $IFDECL AnsiNext $THEN BEGIN }
  FUNCTION  AnsiNext (
    l_                      : LPSTR
  )                         : LPSTR;
{ $END }

{ $IFDECL AnsiPrev $THEN BEGIN }
  FUNCTION  AnsiPrev (
    l_,m_                   : LPSTR
  )                         : LPSTR;
{ $END }



TYPE
  OFSTRUCT = RECORD
    cBytes                  : BYTE; (* length of structure *)
    fFixedDisk              : BYTE; (* non-zero if file located on non- *)
                                    (* removeable media *)
    nErrCode                : WORD; (* DOS error code if OpenFile fails *)
    reserved                : ARRAY [0..3] OF BYTE;
    szPathName		    : ARRAY [0..127] OF BYTE;
  END;
  POFSTRUCT                 = ADR OF OFSTRUCT;
  NPOFSTRUCT                = ADR OF OFSTRUCT;
  LPOFSTRUCT                = ADS OF OFSTRUCT;


{ $IFDECL GetTempDrive $THEN BEGIN }
  FUNCTION  GetTempDrive (
    b_                      : BYTE
  )                         : BYTE;
{ $END }


{ $IFDECL GetTempFileName $THEN BEGIN }
  FUNCTION  GetTempFileName (
    b_                      : BYTE;
    l_                      : LPSTR;
    w_                      : WORD;
    m_                      : LPSTR
  )                         : int;
{ $END }

{ $IFDECL OpenFile $THEN BEGIN }
  FUNCTION  OpenFile (
    l_                      : LPSTR;
    m_                      : LPOFSTRUCT;
    w_                      : WORD
  )                         : int;
{ $END }

(* Flags for GetTempFileName *)

CONST
  TF_FORCEDRIVE         = #80;   (* Forces use of current dir of passed *)
                                 (* drive *)

(* Flags for OpenFile *)

CONST
  OF_REOPEN             = #8000;
  OF_EXIST              = #4000;
  OF_PROMPT             = #2000;
  OF_CREATE             = #1000;
  OF_CANCEL             = #0800;
  OF_VERIFY             = #0400;
  OF_DELETE             = #0200;
  OF_PARSE              = #0100;

  OF_READ               = 0;
  OF_WRITE              = 1;
  OF_READWRITE          = 2;

(* Interface to global memory manager *)
  GMEM_FIXED            = #0000;
  GMEM_MOVEABLE         = #0002;
  GMEM_NOCOMPACT        = #0010;
  GMEM_NODISCARD        = #0020;
  GMEM_ZEROINIT         = #0040;
  GMEM_MODIFY           = #0080;
  GMEM_DISCARDABLE      = #0F00;
  GHND                  = (GMEM_MOVEABLE OR GMEM_ZEROINIT);
  GPTR                  = (GMEM_FIXED    OR GMEM_ZEROINIT);
  GMEM_SHARE		= #2000;
  GMEM_DDESHARE 	= #2000;
  GMEM_LOWER		= #1000;
  GMEM_NOTIFY		= #4000;
  GMEM_NOT_BANKED	= #1000;


{ $IFDECL GlobalAlloc $THEN BEGIN }
  FUNCTION  GlobalAlloc (
    w_                      : WORD;
    d_                      : DWORD
  )                         : HANDLE;
{ $END }

{ $IFDECL GlobalCompact $THEN BEGIN }
  FUNCTION  GlobalCompact (
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL GlobalDiscard $THEN BEGIN }
  FUNCTION  GlobalDiscard (
    h_                      : HANDLE;
  )                         : HANDLE;
{ $END }

{ $IFDECL GlobalFree $THEN BEGIN }
  FUNCTION  GlobalFree (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL GlobalHandle $THEN BEGIN }
  FUNCTION  GlobalHandle (
    w_                      : WORD
  )                         : DWORD;
{ $END }

{ $IFDECL GlobalLock $THEN BEGIN }
  FUNCTION  GlobalLock (
    h_                      : HANDLE
  )                         : LPSTR;
{ $END }

{ $IFDECL GlobalReAlloc $THEN BEGIN }
  FUNCTION  GlobalReAlloc (
    h_                      : HANDLE;
    d_                      : DWORD;
    w_                      : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL GlobalSize $THEN BEGIN }
  FUNCTION  GlobalSize (
    h_                      : HANDLE
  )                         : DWORD;
{ $END }

{ $IFDECL GlobalFlags $THEN BEGIN }
  FUNCTION  GlobalFlags (
    h_                      : HANDLE
  )                         : WORD;
{ $END }

{ $IFDECL GlobalWire $THEN BEGIN }
  FUNCTION  GlobalWire (
    h_                      : HANDLE
  )			    : LPSTR;
{ $END }

{ $IFDECL GlobalUnWire $THEN BEGIN }
  FUNCTION  GlobalUnWire (
    h_                      : HANDLE
  )			    : BOOL;
{ $END }

{ $IFDECL GlobalUnlock $THEN BEGIN }
  FUNCTION  GlobalUnlock (
    h_                      : HANDLE
  )			    : BOOL;
{ $END }

{ $IFDECL UnlockResource $THEN BEGIN }
  FUNCTION  UnlockResource ( h_ : HANDLE)  : BOOL;
    BEGIN
      UnlockResource := GlobalUnlock(h_)
    END;
{ $END }

{ $IFDECL GlobalLRUNewest $THEN BEGIN }
  FUNCTION  GlobalLRUNewest (
    h_                      : HANDLE
  )			    : HANDLE;
{ $END }

{ $IFDECL GlobalLRUOldest $THEN BEGIN }
  FUNCTION  GlobalLRUOldest (
    h_                      : HANDLE
  )			    : HANDLE;
{ $END }

{ $IFDECL GlobalNotify $THEN BEGIN }
  PROCEDURE  GlobalNotify (
    l_			    : LPSTR
  );
{ $END }

(* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) *)

CONST
  GMEM_DISCARDED        = #4000;
  GMEM_SWAPPED          = #8000;
  GMEM_LOCKCOUNT        = #00FF;

{ $IFDECL LockData $THEN BEGIN }
  FUNCTION  LockData (
    i_                      : int
  )                         : HANDLE;
{ $END }

{ $IFDECL UnlockData $THEN BEGIN }
  FUNCTION  UnlockData (
    i_                      : int
  )                         : HANDLE;
{ $END }


{ $IFDECL LockSegment $THEN BEGIN }
  FUNCTION  LockSegment (
    w_                      : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL UnlockSegment $THEN BEGIN }
  FUNCTION  UnlockSegment (
    w_                      : WORD
  )                         : HANDLE;
{ $END }

(* Interface to local memory manager *)


CONST
  LMEM_FIXED            = #0000;
  LMEM_MOVEABLE         = #0002;
  LMEM_NOCOMPACT        = #0010;
  LMEM_NODISCARD        = #0020;
  LMEM_ZEROINIT         = #0040;
  LMEM_MODIFY           = #0080;
  LMEM_DISCARDABLE      = #0F00;
  LHND                  = (LMEM_MOVEABLE OR LMEM_ZEROINIT);
  LPTR                  = (LMEM_FIXED    OR LMEM_ZEROINIT);
  NONZEROLHND           = (LMEM_MOVEABLE);
  NONZEROLPTR           = (LMEM_FIXED);

  LNOTIFY_OUTOFMEM      = 0;
  LNOTIFY_MOVE          = 1;
  LNOTIFY_DISCARD       = 2;


{ $IFDECL LocalAlloc $THEN BEGIN }
  FUNCTION  LocalAlloc (
    w_,x_                   : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalCompact $THEN BEGIN }
  FUNCTION  LocalCompact (
    w_                      : WORD
  )                         : WORD;
{ $END }

{ $IFDECL LocalDiscard $THEN BEGIN }
  FUNCTION  LocalDiscard (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalFree $THEN BEGIN }
  FUNCTION  LocalFree (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalHandle $THEN BEGIN }
  FUNCTION  LocalHandle (
    w_                      : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalFreeze $THEN BEGIN }
  PROCEDURE LocalFreeze (
    i_                      : int
  );
{ $END }

{ $IFDECL LocalHandleDelta $THEN BEGIN }
  FUNCTION  LocalHandleDelta (
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL LocalInit $THEN BEGIN }
  FUNCTION  LocalInit (
    w_			    : WORD;
    p_,q_		    : PSTR
  )                         : BOOL;
{ $END }

{ $IFDECL LocalLock $THEN BEGIN }
  FUNCTION  LocalLock (
    h_                      : HANDLE
  )                         : PSTR;
{ $END }

{ $IFDECL LocalMelt $THEN BEGIN }
  PROCEDURE LocalMelt (
    i_                      : int
  );
{ $END }

{ $IFDECL LocalNotify $THEN BEGIN }
  FUNCTION  LocalNotify (
    f_                      : FARPROC
  )                         : FARPROC;
{ $END }

{ $IFDECL LocalReAlloc $THEN BEGIN }
  FUNCTION  LocalReAlloc (
    h_                      : HANDLE;
    w_,x_                   : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalSize $THEN BEGIN }
  FUNCTION  LocalSize (
    h_                      : HANDLE
  )                         : WORD;
{ $END }

{ $IFDECL LocalUnlock $THEN BEGIN }
  FUNCTION  LocalUnlock (
    h_                      : HANDLE
  )                         : BOOL;
{ $END }

{ $IFDECL LocalFlags $THEN BEGIN }
  FUNCTION  LocalFlags (
    h_                      : HANDLE
  )                         : WORD;
{ $END }

{ $IFDECL LocalShrink $THEN BEGIN }
  FUNCTION  LocalShrink (
    h_			    : HANDLE;
    w_			    : WORD
  )                         : WORD;
{ $END }

(* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) *)

CONST
  LMEM_DISCARDED        = #4000;
  LMEM_LOCKCOUNT        = #00FF;

(* SetSwapAreaSize really returns 2 words -
    lo word is Size actually set (or current size if you passed in 0)
    hi word is Max size you can get
*)

{ $IFDECL SetSwapAreaSize $THEN BEGIN }
  FUNCTION  SetSwapAreaSize (
    w_			    : WORD
  )			    : LONG;
{ $END }

{ $IFDECL ValidateFreeSpaces $THEN BEGIN }
  FUNCTION  ValidateFreeSpaces	 : LPSTR;
{ $END }

{ $IFDECL LimitEmsPages $THEN BEGIN }
  PROCEDURE  LimitEmsPages (
    w_			    : DWORD
  );
{ $END }

{ $IFDECL SetErrorMode $THEN BEGIN }
  FUNCTION  SetErrorMode (
    w_			    : WORD
  )			    : BOOL;
{ $END }


(* Interface to the resource manager *)


{ $IFDECL FindResource $THEN BEGIN }
  FUNCTION  FindResource (
    h_                      : HANDLE;
    l_,m_                   : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL LoadResource $THEN BEGIN }
  FUNCTION  LoadResource (
    h_,i_                   : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL FreeResource $THEN BEGIN }
  FUNCTION  FreeResource (
    h_                      : HANDLE
  )                         : BOOL;
{ $END }


{ $IFDECL LockResource $THEN BEGIN }
  FUNCTION  LockResource (
    h_                      : HANDLE
  )                         : LPSTR;
{ $END }


{ $IFDECL SetResourceHandler $THEN BEGIN }
  FUNCTION  SetResourceHandler (
    h_                      : HANDLE;
    l_                      : LPSTR;
    f_                      : FARPROC
  )                         : FARPROC;
{ $END }

{ $IFDECL AllocResource $THEN BEGIN }
  FUNCTION  AllocResource (
    h_,i_                   : HANDLE;
    d_                      : DWORD
  )                         : HANDLE;
{ $END }

{ $IFDECL SizeofResource $THEN BEGIN }
  FUNCTION  SizeofResource (
    h_,i_                   : HANDLE
  )                         : WORD;
{ $END }

{ $IFDECL AccessResource $THEN BEGIN }
  FUNCTION  AccessResource (
    h_,i_                   : HANDLE
  )                         : int;
{ $END }

{ $IFDECL MAKEINTRESOURCE $THEN BEGIN }
  FUNCTION  MAKEINTRESOURCE (
    i_                      : int
  )                         : LPSTR;
{ $END }

(* Predefined resource types *)
CONST
  RT_CURSOR             = RETYPE( LPSTR, BYLONG(0, 1) );
  RT_BITMAP             = RETYPE( LPSTR, BYLONG(0, 2) );
  RT_ICON               = RETYPE( LPSTR, BYLONG(0, 3) );
  RT_MENU               = RETYPE( LPSTR, BYLONG(0, 4) );
  RT_DIALOG             = RETYPE( LPSTR, BYLONG(0, 5) );
  RT_STRING             = RETYPE( LPSTR, BYLONG(0, 6) );
  RT_FONTDIR            = RETYPE( LPSTR, BYLONG(0, 7) );
  RT_FONT               = RETYPE( LPSTR, BYLONG(0, 8) );
  RT_ACCELERATOR        = RETYPE( LPSTR, BYLONG(0, 9) );
  RT_RCDATA		= RETYPE( LPSTR, BYLONG(0, 10) );

(* Interface to the task scheduler *)


{ $IFDECL Yield $THEN BEGIN }
  FUNCTION  Yield                         : BOOL;
{ $END }

{ $IFDECL GetCurrentTask $THEN BEGIN }
  FUNCTION  GetCurrentTask                         : HANDLE;
{ $END }

{ $IFDECL SetPriority $THEN BEGIN }
  FUNCTION  SetPriority (
    h_                      : HANDLE;
    i_                      : int
  )                         : int;
{ $END }

(* Interface to the atom manager *)


TYPE
  ATOM                      = WORD;


{ $IFDECL InitAtomTable $THEN BEGIN }
  FUNCTION  InitAtomTable (
    i_                      : int
  )                         : BOOL;
{ $END }


{ $IFDECL AddAtom $THEN BEGIN }
  FUNCTION  AddAtom (
    l_                      : LPSTR
  )                         : ATOM;
{ $END }

{ $IFDECL DeleteAtom $THEN BEGIN }
  FUNCTION  DeleteAtom (
    a_                      : ATOM
  )                         : ATOM;
{ $END }

{ $IFDECL FindAtom $THEN BEGIN }
  FUNCTION  FindAtom (
    l_                      : LPSTR
  )                         : ATOM;
{ $END }

{ $IFDECL GetAtomName $THEN BEGIN }
  FUNCTION  GetAtomName (
    a_                      : ATOM;
    l_                      : LPSTR;
    i_                      : int
  )                         : WORD;
{ $END }

{ $IFDECL GlobalAddAtom $THEN BEGIN }
  FUNCTION  GlobalAddAtom (
    l_			    : LPSTR
  )			    : ATOM;
{ $END }

{ $IFDECL GlobalDeleteAtom $THEN BEGIN }
  FUNCTION  GlobalDeleteAtom (
    a_                      : ATOM
  )			    : ATOM;
{ $END }

{ $IFDECL GlobalFindAtom $THEN BEGIN }
  FUNCTION  GlobalFindAtom (
    l_			    : LPSTR
  )			    : ATOM;
{ $END }

{ $IFDECL GlobalGetAtomName $THEN BEGIN }
  FUNCTION  GlobalGetAtomName (
    a_                      : ATOM;
    l_                      : LPSTR;
    i_                      : int
  )                         : WORD;
{ $END }

{ $IFDECL GetAtomHandle $THEN BEGIN }
  FUNCTION  GetAtomHandle (
    a_                      : ATOM
  )                         : HANDLE;
{ $END }

{ $IFDECL MAKEINTATOM $THEN BEGIN }
  FUNCTION  MAKEINTATOM (
    i_                      : int
  )                         : LPSTR;
{ $END }

(* Interface to the user profile *)

{ $IFDECL GetProfileInt $THEN BEGIN }
  FUNCTION  GetProfileInt (
    l_,m_                   : LPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetProfileString $THEN BEGIN }
  FUNCTION  GetProfileString (
    l_,m_,n_,o_             : LPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL WriteProfileString $THEN BEGIN }
  FUNCTION  WriteProfileString (
    l_,m_,n_                : LPSTR
  )                         : BOOL;
{ $END }

(* Interface to FatalExit procedure *)


{ $IFDECL FatalExit $THEN BEGIN }
  PROCEDURE FatalExit (
    i_                      : int
  );
{ $END }

(* Interface to Catch and Throw procedures *)


TYPE
  CATCHBUF                  = ARRAY [0..8] OF int;
  LPCATCHBUF                = ADS OF int;

{ $IFDECL Catch $THEN BEGIN }
  FUNCTION  Catch (
    l_                      : LPCATCHBUF
  )                         : int;
{ $END }

{ $IFDECL Throw $THEN BEGIN }
  PROCEDURE Throw (
    l_                      : LPCATCHBUF;
    i_                      : int
  );
{ $END }


{ $IFDECL CreateMetaFile $THEN BEGIN }
  FUNCTION  CreateMetaFile (
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL CloseMetaFile $THEN BEGIN }
  FUNCTION  CloseMetaFile (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL GetMetaFileBits $THEN BEGIN }
  FUNCTION  GetMetaFileBits (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL SetMetaFileBits $THEN BEGIN }
  FUNCTION  SetMetaFileBits (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }


{ $IFDECL GetCurrentTime $THEN BEGIN }
  FUNCTION  GetCurrentTime  : DWORD;
{ $END }

{ $IFDECL GetTickCount $THEN BEGIN }
  FUNCTION  GetTickCount    : DWORD;
{ $END }

{ $IFDECL GetTimerResolution $THEN BEGIN }
  FUNCTION  GetTimerResolution	  : DWORD;
{ $END }

{ $IFDECL IsChild $THEN BEGIN }
  FUNCTION  IsChild (
    h_,i_                   : HWND
  )                         : BOOL;
{ $END }


{ $IFDECL GetWindowWord $THEN BEGIN }
  FUNCTION  GetWindowWord (
    h_                      : HWND;
    i_                      : int
  )                         : WORD;
{ $END }

{ $IFDECL SetWindowWord $THEN BEGIN }
  FUNCTION  SetWindowWord (
    h_                      : HWND;
    i_                      : int;
    w_                      : WORD
  )                         : WORD;
{ $END }

{ $IFDECL GetWindowLong $THEN BEGIN }
  FUNCTION  GetWindowLong (
    h_                      : HWND;
    i_                      : int
  )                         : LONG;
{ $END }

{ $IFDECL SetWindowLong $THEN BEGIN }
  FUNCTION  SetWindowLong (
    h_                      : HWND;
    i_                      : int;
    l_                      : LONG
  )                         : LONG;
{ $END }

{ $IFDECL GetClassWord $THEN BEGIN }
  FUNCTION  GetClassWord (
    h_                      : HWND;
    i_                      : int
  )                         : WORD;
{ $END }

{ $IFDECL SetClassWord $THEN BEGIN }
  FUNCTION  SetClassWord (
    h_                      : HWND;
    i_                      : int;
    w_                      : WORD
  )                         : WORD;
{ $END }

{ $IFDECL GetClassLong $THEN BEGIN }
  FUNCTION  GetClassLong (
    h_                      : HWND;
    i_                      : int
  )                         : LONG;
{ $END }

{ $IFDECL SetClassLong $THEN BEGIN }
  FUNCTION  SetClassLong (
    h_                      : HWND;
    i_                      : int;
    l_                      : LONG
  )                         : LONG;
{ $END }


{ $IFDECL GetParent $THEN BEGIN }
  FUNCTION  GetParent (
    h_                      : HWND
  )                         : HWND;
{ $END }

{ $IFDECL SetParent $THEN BEGIN }
  FUNCTION  SetParent (
    h_,w_		    : HWND
  )                         : HWND;
{ $END }

{ $IFDECL EnumChildWindows $THEN BEGIN }
  FUNCTION  EnumChildWindows (
    h_                      : HWND;
    f_                      : FARPROC;
    l_                      : LONG
  )                         : BOOL;
{ $END }

{ $IFDECL FindWindow $THEN BEGIN }
  FUNCTION  FindWindow (
    l_,m_                   : LPSTR
  )                         : HWND;
{ $END }

{ $IFDECL EnumWindows $THEN BEGIN }
  FUNCTION  EnumWindows (
    f_                      : FARPROC;
    l_                      : LONG
  )                         : BOOL;
{ $END }

{ $IFDECL EnumTaskWindows $THEN BEGIN }
  FUNCTION  EnumTaskWindows (
    h_			    : HANDLE;
    f_                      : FARPROC;
    l_                      : LONG
  )                         : BOOL;
{ $END }

{ $IFDECL GetClassName $THEN BEGIN }
  FUNCTION  GetClassName (
    h_                      : HWND;
    l_                      : LPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetTopWindow $THEN BEGIN }
  FUNCTION  GetTopWindow (
    h_			    : HWND
  )			    : HWND;
{ $END }

{ $IFDECL GetNextWindow $THEN BEGIN }
  FUNCTION  GetNextWindow (
    h_			    : HWND;
    W_			    : WORD
  )			    : HWND;
{ $END }

{ $IFDECL GetWindowTask $THEN BEGIN }
  FUNCTION  GetWindowTask (
    h_			    : HWND
  )			    : HANDLE;
{ $END }

(* GetWindow() and constants *)
{ $IFDECL GetWindow $THEN BEGIN }
  FUNCTION  GetWindow (
    h_			    : HWND;
    w_			    : WORD
  )			    : HWND;
{ $END }


{ $IFDECL SetWindowsHook $THEN BEGIN }
  FUNCTION  SetWindowsHook (
    i_                      : int;
    f_                      : FARPROC
  )                         : FARPROC;
{ $END }

{ $IFDECL UnhookWindowsHook $THEN BEGIN }
  FUNCTION  UnhookWindowsHook (
    i_                      : int;
    f_                      : FARPROC
  )			    : BOOL;
{ $END }

{ $IFDECL DefHookProc $THEN BEGIN }
  FUNCTION  DefHookProc (
    i_			    : int;
    w_			    : WORD;
    d_			    : DWORD;
    f_			    : ADS OF FARPROC
  )			    : DWORD;
{ $END }

(* Key conversion window *)

{ $IFDECL CreateConvertWindow $THEN BEGIN }
  FUNCTION  CreateConvertWindow (
    l_                      : LPSTR;
    h_                      : HANDLE;
    m_                      : LPSTR
  )                         : HWND;
{ $END }

{ $IFDECL ShowConvertWindow $THEN BEGIN }
  PROCEDURE ShowConvertWindow (
    h_                      : HWND;
    b_                      : BOOL
  );
{ $END }

{ $IFDECL SetConvertWindowHeight $THEN BEGIN }
  PROCEDURE SetConvertWindowHeight (
    i_                      : int
  );
{ $END }

{ $IFDECL IsTwoByteCharPrefix $THEN BEGIN }
  FUNCTION  IsTwoByteCharPrefix (
    i_                      : INTEGER1
  )                         : BOOL;
{ $END }

CONST
  GW_HWNDFIRST		    = 0;
  GW_HWNDLAST		    = 1;
  GW_HWNDNEXT		    = 2;
  GW_HWNDPREV		    = 3;
  GW_OWNER		    = 4;
  GW_CHILD		    = 5;

(* Menu flags for Add/Check/EnableMenuItem *)

  MF_CHANGE             = #0080;
  MF_INSERT             = #0000;
  MF_APPEND             = #0100;
  MF_DELETE             = #0200;
  MF_BYPOSITION         = #0400;
  MF_SEPARATOR          = #0800;
  MF_REMOVE		= #1000;
  MF_BYCOMMAND          = #0000;
  MF_GRAYED             = #0001;
  MF_DISABLED           = #0002;
  MF_ENABLED            = #0000;
  MF_CHECKED            = #0008;
  MF_UNCHECKED          = #0000;
  MF_BITMAP             = #0004;
  MF_STRING             = #0000;
  MF_POPUP              = #0010;
  MF_MENUBARBREAK       = #0020;
  MF_MENUBREAK          = #0040;
  MF_HILITE             = #0080;
  MF_UNHILITE           = #0000;
  MF_HELP		= #4000;
  MF_SYSMENU		= #2000;
  MF_MOUSESELECT	= #8000;


(* System Menu Command Values *)
  SC_SIZE               = #f000;
  SC_MOVE               = #f010;
  SC_MINIMIZE		= #f020;
  SC_MAXIMIZE		= #f030;
  SC_NEXTWINDOW         = #f040;
  SC_PREVWINDOW         = #f050;
  SC_CLOSE              = #f060;
  SC_VSCROLL            = #f070;
  SC_HSCROLL            = #f080;
  SC_MOUSEMENU          = #f090;
  SC_KEYMENU            = #f100;
  SC_ARRANGE		= #F110;
  SC_RESTORE		= #F120;
  SC_ICON		= SC_MINIMIZE;
  SC_ZOOM		= SC_MAXIMIZE;

(* Resource loading routines *)


{ $IFDECL LoadBitmap $THEN BEGIN }
  FUNCTION  LoadBitmap (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HBITMAP;
{ $END }


{ $IFDECL LoadCursor $THEN BEGIN }
  FUNCTION  LoadCursor (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HCURSOR;
{ $END }

(* Standard cursor IDs *)
CONST
  IDC_ARROW             = RETYPE( LPSTR, BYLONG(0,32512) );
  IDC_IBEAM             = RETYPE( LPSTR, BYLONG(0,32513) );
  IDC_WAIT              = RETYPE( LPSTR, BYLONG(0,32514) );
  IDC_CROSS             = RETYPE( LPSTR, BYLONG(0,32515) );
  IDC_UPARROW           = RETYPE( LPSTR, BYLONG(0,32516) );
  IDC_SIZE              = RETYPE( LPSTR, BYLONG(0,32640) );
  IDC_ICON              = RETYPE( LPSTR, BYLONG(0,32641) );
  IDC_SIZENWSE		= RETYPE( LPSTR, BYLONG(0,32642) );
  IDC_SIZENESW		= RETYPE( LPSTR, BYLONG(0,32643) );
  IDC_SIZEWE		= RETYPE( LPSTR, BYLONG(0,32644) );
  IDC_SIZENS		= RETYPE( LPSTR, BYLONG(0,32645) );



{ $IFDECL LoadIcon $THEN BEGIN }
  FUNCTION  LoadIcon (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HICON;
{ $END }

(* Standard icon IDs *)
CONST
  IDI_APPLICATION       = RETYPE( LPSTR, BYLONG(0,32512) );
  IDI_HAND              = RETYPE( LPSTR, BYLONG(0,32513) );
  IDI_QUESTION          = RETYPE( LPSTR, BYLONG(0,32514) );
  IDI_EXCLAMATION       = RETYPE( LPSTR, BYLONG(0,32515) );
  IDI_ASTERISK          = RETYPE( LPSTR, BYLONG(0,32516) );



{ $IFDECL LoadMenu $THEN BEGIN }
  FUNCTION  LoadMenu (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HMENU;
{ $END }

{ $IFDECL LoadMenuIndirect $THEN BEGIN }
  FUNCTION  LoadMenuIndirect (
    l_                      : LPSTR
  )                         : HMENU;
{ $END }

{ $IFDECL LoadString $THEN BEGIN }
  FUNCTION  LoadString (
    h_                      : HANDLE;
    w_                      : WORD;
    l_                      : LPSTR;
    i_                      : int
  )                         : int;
{ $END }


{ $IFDECL AddFontResource $THEN BEGIN }
  FUNCTION  AddFontResource (
    l_                      : LPSTR
  )                         : short;
{ $END }

{ $IFDECL RemoveFontResource $THEN BEGIN }
  FUNCTION  RemoveFontResource (
    l_                      : LPSTR
  )                         : BOOL;
{ $END }


CONST
  CP_HWND               = 0;
  CP_OPEN               = 1;
  CP_DIRECT		= 2;

(* VK from the keyboard driver *)
  VK_KANA		= #15;
  VK_ROMAJI		= #16;
  VK_ZENKAKU		= #17;
  VK_HIRAGANA		= #18;
  VK_KANJI		= #19;

(* VK to send to Applications *)
  VK_CONVERT		 = #1C;
  VK_NONCONVERT 	 = #1D;
  VK_ACCEPT		 = #1E;
  VK_MODECHANGE 	 = #1F;


(* Conversion function numbers *)
  KNJ_START		 = #01;
  KNJ_END		 = #02;
  KNJ_QUERY		 = #03;

  KNJ_LEARN_MODE	 = #10;
  KNJ_GETMODE		 = #11;
  KNJ_SETMODE		 = #12;

  KNJ_CODECONVERT	 = #20;
  KNJ_CONVERT		 = #21;
  KNJ_NEXT		 = #22;
  KNJ_PREVIOUS		 = #23;
  KNJ_ACCEPT		 = #24;

  KNJ_LEARN		 = #30;
  KNJ_REGISTER		 = #31;
  KNJ_REMOVE		 = #32;
  KNJ_CHANGE_UDIC	 = #33;

(* note: DEFAULT	= 0
	 JIS1		= 1
	 JIS2		= 2
	 SJIS2		= 3
	 JIS1KATAKANA	= 4
	 SJIS2HIRAGANA	= 5
	 SJIS2KATAKANA	= 6
	 OEM		= F
*)

  KNJ_JIS1toJIS1KATAKANA	 = #14;
  KNJ_JIS1toSJIS2		 = #13;
  KNJ_JIS1toSJIS2HIRAGANA	 = #15;
  KNJ_JIS1toSJIS2KATAKANA	 = #16;
  KNJ_JIS1toDEFAULT		 = #10;
  KNJ_JIS1toSJIS2OEM		 = #1F;
  KNJ_JIS2toSJIS2		 = #23;
  KNJ_SJIS2toJIS2		 = #32;

(* see KNJ_GETMODE for definition *)
  KNJ_MD_ALPHA			 = #01;
  KNJ_MD_HIRAGANA		 = #02;
  KNJ_MD_HALF			 = #04;
  KNJ_MD_JIS			 = #08;
  KNJ_MD_SPECIAL		 = #10;

(* conversion modes, low word of lParam when VK_CONVERT is sent to the app *)
  KNJ_CVT_NEXT			 = #01;
  KNJ_CVT_PREV			 = #02;
  KNJ_CVT_KATAKANA		 = #03;
  KNJ_CVT_HIRAGANA		 = #04;
  KNJ_CVT_JIS1			 = #05;
  KNJ_CVT_SJIS2 		 = #06;
  KNJ_CVT_DEFAULT		 = #07;
  KNJ_CVT_TYPED 		 = #08;

(* WM_YOMICHAR			  = #0108;
   WM_CONVERTREQUEST		  = #010A;
   WM_CONVERTRESULT		  = #010B;   Previously defined constants.
*)


TYPE
  KANJISTRUCT = RECORD
    fnc 		    : short;
    wParam		    : short;
    lpSource		    : LPSTR;
    lpdest		    : LPSTR;
    wCount		    : short;
    lpReserved1 	    : LPSTR;
    lpReserved2 	    : LPSTR;
  END;

  LPKANJISTRUCT             = ADS OF KANJISTRUCT;


{ $IFDECL MoveConvertWindow $THEN BEGIN }
  PROCEDURE MoveConvertWindow (
    s_,t_                   : short
  );
{ $END }

{ $IFDECL ConvertRequest $THEN BEGIN }
  FUNCTION ConvertRequest (
    h_                      : HWND;
    l_                      : LPKANJISTRUCT
  )			    : short;
{ $END }

{ $IFDECL SetConvertParams $THEN BEGIN }
  FUNCTION  SetConvertParams (
    s_,t_                   : short
  )                         : BOOL;
{ $END }

{ $IFDECL SetConvertHook $THEN BEGIN }
  PROCEDURE SetConvertHook (
    b_                      : BOOL
  );
{ $END }

(* Conventional dialog box and message box command IDs *)

CONST
  IDOK                  = 1;
  IDCANCEL              = 2;
  IDABORT               = 3;
  IDRETRY               = 4;
  IDIGNORE              = 5;
  IDYES                 = 6;
  IDNO                  = 7;


(* Control manager structures & definitions *)
(* Edit control class stuff *)

(* styles *)
  ES_LEFT               = BYLONG(0,0);
  ES_CENTER             = BYLONG(0,1);
  ES_RIGHT              = BYLONG(0,2);
  ES_MULTILINE          = BYLONG(0,4);
  ES_AUTOVSCROLL        = BYLONG(0,64);
  ES_AUTOHSCROLL        = BYLONG(0,128);
  ES_NOHIDESEL          = BYLONG(0,256);

(* notification codes *)
  EN_SETFOCUS_          = #0100;
  EN_KILLFOCUS_         = #0200;
  EN_CHANGE             = #0300;
  EN_UPDATE		= #0400;
  EN_ERRSPACE           = #0500;
  EN_HSCROLL            = #0601;
  EN_VSCROLL            = #0602;

(* control messages: *)
  EM_GETSEL             = WM_USER+0;
  EM_SETSEL             = WM_USER+1;
  EM_GETRECT            = WM_USER+2;
  EM_SETRECT            = WM_USER+3;
  EM_SETRECTNP          = WM_USER+4;
  EM_SCROLL             = WM_USER+5;
  EM_LINESCROLL         = WM_USER+6;
  EM_GETMODIFY          = WM_USER+8;
  EM_SETMODIFY          = WM_USER+9;
  EM_GETLINECOUNT       = WM_USER+10;
  EM_LINEINDEX          = WM_USER+11;
  EM_SETHANDLE          = WM_USER+12;
  EM_GETHANDLE          = WM_USER+13;
  EM_GETTHUMB           = WM_USER+14;
  EM_LINELENGTH         = WM_USER+17;
  EM_REPLACESEL         = WM_USER+18;
  EM_SETFONT            = WM_USER+19;
  EM_GETLINE            = WM_USER+20;
  EM_LIMITTEXT          = WM_USER+21;
  EM_CANUNDO            = WM_USER+22;
  EM_UNDO               = WM_USER+23;
  EM_FMTLINES           = WM_USER+24;
  EM_LINEFROMCHAR	= WM_USER+25;
  EM_SETWORDBREAK	= WM_USER+26;

(* button control styles *)
  BS_PUSHBUTTON         = BYLONG(0,0);
  BS_DEFPUSHBUTTON      = BYLONG(0,1);
  BS_CHECKBOX           = BYLONG(0,2);
  BS_AUTOCHECKBOX       = BYLONG(0,3);
  BS_RADIOBUTTON        = BYLONG(0,4);
  BS_3STATE             = BYLONG(0,5);
  BS_AUTO3STATE         = BYLONG(0,6);
  BS_GROUPBOX           = BYLONG(0,7);
  BS_USERBUTTON         = BYLONG(0,8);
  BS_AUTORADIOBUTTON	= BYLONG(0,9);
  BS_PUSHBOX		= BYLONG(0,10);
  BS_LEFTTEXT		= BYLONG(0,20);

(* user button notification codes *)
  BN_CLICKED            = 0;
  BN_PAINT              = 1;
  BN_HILITE             = 2;
  BN_UNHILITE           = 3;
  BN_DISABLE            = 4;
  BN_DOUBLECLICKED	= 5;

(* control messages *)
  BM_GETCHECK           = WM_USER+0;
  BM_SETCHECK           = WM_USER+1;
  BM_GETSTATE           = WM_USER+2;
  BM_SETSTATE           = WM_USER+3;
  BM_SETSTYLE		= WM_USER+4;

(* Static control constants *)

  SS_LEFT               = BYLONG(0,0);
  SS_CENTER             = BYLONG(0,1);
  SS_RIGHT              = BYLONG(0,2);
  SS_ICON               = BYLONG(0,3);
  SS_BLACKRECT          = BYLONG(0,4);
  SS_GRAYRECT           = BYLONG(0,5);
  SS_WHITERECT          = BYLONG(0,6);
  SS_BLACKFRAME         = BYLONG(0,7);
  SS_GRAYFRAME          = BYLONG(0,8);
  SS_WHITEFRAME         = BYLONG(0,9);
  SS_USERITEM           = BYLONG(0,10);
  SS_SIMPLE		= BYLONG(0,11);
  SS_NOPREFIX		= BYLONG(0,128);
		      (* 0x80 - don't do "&" character translation *)

(* Dialog manager routines *)


{ $IFDECL IsDialogMessage $THEN BEGIN }
  FUNCTION  IsDialogMessage (
    h_                      : HWND;
    l_                      : LPMSG
  )                         : BOOL;
{ $END }


{ $IFDECL MapDialogRect $THEN BEGIN }
  PROCEDURE MapDialogRect (
    h_                      : HWND;
    l_                      : LPRECT
  );
{ $END }


{ $IFDECL DlgDirList $THEN BEGIN }
  FUNCTION  DlgDirList (
    h_                      : HWND;
    l_                      : LPSTR;
    i_,j_                   : int;
    w_                      : WORD
  )                         : int;
{ $END }

{ $IFDECL DlgDirSelect $THEN BEGIN }
  FUNCTION  DlgDirSelect (
    h_                      : HWND;
    l_                      : LPSTR;
    i_                      : int
  )                         : BOOL;
{ $END }

(* Dialog style bits *)

CONST
  DS_ABSALIGN           = #000000001;
  DS_SYSMODAL           = #000000002;
  DS_LOCALEDIT		= #000000020; (* Edit items get Local storage. *)

  DM_GETDEFID		= WM_USER+0;
  DM_SETDEFID		= WM_USER+1;
  DC_HASDEFID		= #534B;

(*  Dialog codes (returned by WM_GETDLGCODE message) *)

  DLGC_WANTARROWS	= #0001; (* control wants arrow keys *)
  DLGC_WANTTAB		= #0002; (* control wants tab keys *)
  DLGC_WANTALLKEYS	= #0004; (* control wants all keys *)
  DLGC_HASSETSEL	= #0008; (* understands EM_SETSEL message *)
  DLGC_WANTMESSAGE	= #0004;    (* pass message to control *)
  DLGC_DEFPUSHBUTTON	= #0010;    (* Default pushbutton     *)
  DLGC_UNDEFPUSHBUTTON	= #0020;    (* Non-default pushbutton *)
  DLGC_RADIOBUTTON	= #0040;    (* radio button	      *)
  DLGC_WANTCHARS	= #0080;    (* Want WM_CHAR messages  *)
  DLGC_STATIC		= #0100;   (* Static item: don't include *)
  DLGC_BUTTON		= #2000;  (* Button item: can be checked *)

  LB_CTLCODE            = BYLONG(0,0);

(* Listbox control return values *)
  LB_OKAY               = 0;
  LB_ERR                = -1;
  LB_ERRSPACE           = -2;

(* listbox notification codes *)
  LBN_ERRSPACE          = -2;
  LBN_SELCHANGE         = 1;
  LBN_DBLCLK            = 2;

(* listbox messages *)
  LB_ADDSTRING          = 1+WM_USER;
  LB_INSERTSTRING       = 2+WM_USER;
  LB_DELETESTRING       = 3+WM_USER;
  LB_REPLACESTRING      = 4+WM_USER;
  LB_RESETCONTENT       = 5+WM_USER;
  LB_SETSEL             = 6+WM_USER;
  LB_SETCURSEL          = 7+WM_USER;
  LB_GETSEL             = 8+WM_USER;
  LB_GETCURSEL          = 9+WM_USER;
  LB_GETTEXT            = 10+WM_USER;
  LB_GETTEXTLEN         = 11+WM_USER;
  LB_GETCOUNT           = 12+WM_USER;
  LB_SELECTSTRING       = 13+WM_USER;
  LB_DIR                = 14+WM_USER;
  LB_GETTOPINDEX	= 15+WM_USER;
  LB_MSGMAX		= 16+WM_USER;

(* listbox style bits *)
  LBS_NOTIFY            = #00000001;
  LBS_SORT              = #00000002;
  LBS_NOREDRAW          = #00000004;
  LBS_MULTIPLESEL       = #00000008;
  LBS_STANDARD          = #00A00003; (*LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER *)


(* scroll bar styles *)
  SBS_HORZ              = #00000000;
  SBS_VERT              = #00000001;
  SBS_TOPALIGN          = #00000002;
  SBS_LEFTALIGN         = #00000002;
  SBS_BOTTOMALIGN       = #00000004;
  SBS_RIGHTALIGN        = #00000004;
  SBS_SIZEBOXTOPLEFTALIGN = #00000002;
  SBS_SIZEBOXBOTTOMRIGHTALIGN = #00000004;
  SBS_SIZEBOX                 = #00000008;


{ $IFDECL OpenSound $THEN BEGIN }
  FUNCTION  OpenSound                         : int;
{ $END }

{ $IFDECL CloseSound $THEN BEGIN }
  FUNCTION  CloseSound                         : int;
{ $END }

{ $IFDECL SetVoiceQueueSize $THEN BEGIN }
  FUNCTION  SetVoiceQueueSize (
    i_,j_                   : int
  )                         : int;
{ $END }

{ $IFDECL SetVoiceNote $THEN BEGIN }
  FUNCTION  SetVoiceNote (
    i_,j_,k_,l_             : int
  )                         : int;
{ $END }

{ $IFDECL SetVoiceAccent $THEN BEGIN }
  FUNCTION  SetVoiceAccent (
    i_,j_,k_,l_,m_          : int
  )                         : int;
{ $END }

{ $IFDECL SetVoiceEnvelope $THEN BEGIN }
  FUNCTION  SetVoiceEnvelope (
    i_,j_,k_                : int
  )                         : int;
{ $END }

{ $IFDECL SetSoundNoise $THEN BEGIN }
  FUNCTION  SetSoundNoise (
    i_,j_                   : int
  )                         : int;
{ $END }

{ $IFDECL SetVoiceSound $THEN BEGIN }
  FUNCTION  SetVoiceSound (
    i_,j_,k_                : int
  )                         : int;
{ $END }

{ $IFDECL StartSound $THEN BEGIN }
  FUNCTION  StartSound                         : int;
{ $END }

{ $IFDECL StopSound $THEN BEGIN }
  FUNCTION  StopSound                         : int;
{ $END }

{ $IFDECL WaitSoundState $THEN BEGIN }
  FUNCTION  WaitSoundState (
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL SyncAllVoices $THEN BEGIN }
  FUNCTION  SyncAllVoices                         : int;
{ $END }

{ $IFDECL CountVoiceNotes $THEN BEGIN }
  FUNCTION  CountVoiceNotes (
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetThresholdEvent $THEN BEGIN }
  FUNCTION  GetThresholdEvent                         : LPINT;
{ $END }

{ $IFDECL GetThresholdStatus $THEN BEGIN }
  FUNCTION  GetThresholdStatus                         : int;
{ $END }

{ $IFDECL SetVoiceThreshold $THEN BEGIN }
  FUNCTION  SetVoiceThreshold (
    i_,j_                   : int
  )                         : int;
{ $END }

(* constants used to specify return condition for WaitSoundState *)


CONST
  QUEUEEMPTY                  = 0;
  THRESHOLD                   = 1;
  ALLTHRESHOLD                = 2;

(* constants used to specify accent mode *)

  S_NORMAL                    = 0;
  S_LEGATO                    = 1;
  S_STACCATO                  = 2;

(* constants used to specify source in SetSoundNoise *)
  S_PERIOD512                 = 0   (* freq = N/512 high pitch, less coarse hiss *);
  S_PERIOD1024                = 1   (* freq = N/1024 *);
  S_PERIOD2048                = 2   (* freq = N/2048 low pitch, more coarse hiss *);
  S_PERIODVOICE               = 3   (* source is frequency from voice channel (3) *);

  S_WHITE512                  = 4   (* freq = N/512 high pitch, less coarse hiss *);
  S_WHITE1024                 = 5   (* freq = N/1024 *);
  S_WHITE2048                 = 6   (* freq = N/2048 low pitch, more coarse hiss *);
  S_WHITEVOICE                = 7   (* source is frequency from voice channel (3) *);

  S_SERDVNA                   = -1      (* device not available *);
  S_SEROFM                    = -2      (* out of memory *);
  S_SERMACT                   = -3      (* music active *);
  S_SERQFUL                   = -4      (* queue full *);
  S_SERBDNT                   = -5      (* invalid note *);
  S_SERDLN                    = -6      (* invalid note length *);
  S_SERDCC                    = -7      (* invalid note count *);
  S_SERDTP                    = -8      (* invalid tempo *);
  S_SERDVL                    = -9      (* invalid volume *);
  S_SERDMD                    = -10     (* invalid mode *);
  S_SERDSH                    = -11     (* invalid shape *);
  S_SERDPT                    = -12     (* invalid pitch *);
  S_SERDFQ                    = -13     (* invalid frequency *);
  S_SERDDR                    = -14     (* invalid duration *);
  S_SERDSR                    = -15     (* invalid source *);
  S_SERDST                    = -16     (* invalid state *);



(*************************************************************************
**
** dcb field definitions.
**
*************************************************************************)

  NOPARITY                    = 0;
  ODDPARITY                   = 1;
  EVENPARITY                  = 2;
  MARKPARITY                  = 3;
  SPACEPARITY                 = 4;

  ONESTOPBIT                  = 0;
  ONE5STOPBITS                = 1;
  TWOSTOPBITS                 = 2;

  IGNORE                      = 0               (* Ignore signal                *);
  INFINITE                    = #ffff          (* Infinite timeout             *);



(*************************************************************************
**
** Comm Device Driver Error Bits.
**
*************************************************************************)

  CE_RXOVER                   = #0001          (* Receive Queue overflow       *);
  CE_OVERRUN                  = #0002          (* Receive Overrun Error        *);
  CE_RXPARITY                 = #0004          (* Receive Parity Error         *);
  CE_FRAME                    = #0008          (* Receive Framing error        *);
  CE_BREAK                    = #0010          (* Break Detected               *);
  CE_CTSTO                    = #0020          (* CTS Timeout                  *);
  CE_DSRTO                    = #0040          (* DSR Timeout                  *);
  CE_RLSDTO                   = #0080          (* RLSD Timeout                 *);
  CE_TXFULL                   = #0100          (* TX QUEUE IS FULL             *);
  CE_PTO                      = #0200          (* LPTx Timeout                 *);
  CE_IOE                      = #0400          (* LPTx I/O Error               *);
  CE_DNS                      = #0800          (* LPTx Device not selected     *);
  CE_OOP                      = #1000          (* LPTx Out-Of-Paper            *);
  CE_MODE                     = #8000          (* Requested mode unsupported   *);


(*************************************************************************
**
** Initialization Error Codes
**
*************************************************************************)

  IE_BADID                    = -1              (* Invalid or unsupported id    *);
  IE_OPEN                     = -2              (* Device Already Open          *);
  IE_NOPEN                    = -3              (* Device Not Open              *);
  IE_MEMORY                   = -4              (* Unable to allocate queues    *);
  IE_DEFAULT                  = -5              (* Error in default parameters  *);
  IE_HARDWARE                 = -10             (* Hardware Not Present         *);
  IE_BYTESIZE                 = -11             (* Illegal Byte Size            *);
  IE_BAUDRATE                 = -12             (* Unsupported BaudRate         *);


(*************************************************************************
**
** Event Definitions
**
*************************************************************************)

  EV_RXCHAR                   = #0001          (* Any Character received       *);
  EV_RXFLAG                   = #0002          (* Received certain INTEGER1acter   *);
  EV_TXEMPTY                  = #0004          (* Transmitt Queue Empty        *);
  EV_CTS                      = #0008          (* CTS changed state            *);
  EV_DSR                      = #0010          (* DSR changed state            *);
  EV_RLSD                     = #0020          (* RLSD changed state           *);
  EV_BREAK                    = #0040          (* BREAK received               *);
  EV_ERR                      = #0080          (* Line status error occurred   *);
  EV_RING                     = #0100          (* Ring signal detected         *);
  EV_PERR                     = #0200          (* Printer error occured        *);


(*************************************************************************
**
** Escape Functions
**
*************************************************************************)

  SETXOFF                     = 1               (* Simulate XOFF received       *);
  SETXON                      = 2               (* Simulate XON received        *);
  SETRTS                      = 3               (* Set RTS high                 *);
  CLRRTS                      = 4               (* Set RTS low                  *);
  SETDTR                      = 5               (* Set DTR high                 *);
  CLRDTR                      = 6               (* Set DTR low                  *);
  RESETDEV                    = 7               (* Reset device if possible     *);


(*************************************************************************
**
** Device Descriptor Block Definition
**
*************************************************************************)

  LPTx                        = #80             (* Set if ID is for LPT device  *);

  (* Bitfield locators for 'bitField1' in DCB record type *)
  fBinary                     = 1;
  fRtsDisable                 = 2;
  fParity                     = 4;
  fOutxCtsFlow                = 8;
  fOutxDsrFlow                = 16;
  fDtrDisable                 = 128;

  (* Bitfield locators for 'bitField2' in DCB record type *)
  fOutX                       = 1;
  fInX                        = 2;
  fPeChar                     = 4;
  fNull                       = 8;
  fChEvt                      = 16;
  fDtrflow                    = 32;
  fRtsflow                    = 64;

TYPE
  DCB = RECORD
    Id                      : BYTE; (* Internal Device ID           *)
    BaudRate                : WORD; (* Baudrate at which runing     *)
    ByteSize                : BYTE; (* Number of bits/byte, 4-8     *)
    Parity                  : BYTE; (* 0-4=None,Odd,Even,Mark,Space *)
    StopBits                : BYTE; (* 0,1,2 = 1, 1.5, 2            *)
    RlsTimeout              : WORD; (* Timeout for RLSD to be set   *)
    CtsTimeout              : WORD; (* Timeout for CTS to be set    *)
    DsrTimeout              : WORD; (* Timeout for DSR to be set    *)

    bitField1               : BYTE;
        (* Packed bits.  Access with constants defined above.
         * BYTE fBinary: 1;         - Binary Mode (skip EOF check)
         * BYTE fRtsDisable:1;      - Don't assert RTS at init time
         * BYTE fParity: 1;         - Enable parity checking
         * BYTE fOutxCtsFlow:1;     - CTS handshaking on output
         * BYTE fOutxDsrFlow:1;     - DSR handshaking on output
         * BYTE fDummy: 2;          - Reserved
         * BYTE fDtrDisable:1;      - Don't assert DTR at init time
         *)
    bitField2               : BYTE;
        (* Packed bits.  Access with constants defined above.
         * BYTE fOutX: 1;           - Enable output X-ON/X-OFF
         * BYTE fInX: 1;            - Enable input X-ON/X-OFF
         * BYTE fPeChar: 1;         - Enable Parity Err Replacement
         * BYTE fNull: 1;           - Enable Null stripping
         * BYTE fChEvt: 1;          - Enable Rx INTEGER1acter event.
         * BYTE fDtrflow: 1;        - DTR handshake on input
         * BYTE fRtsflow: 1;        - RTS handshake on input
         * BYTE fDummy2: 1; }
         *)
    XonChar                 : INTEGER1; (* Tx and Rx X-ON INTEGER1acter     *)
    XoffChar                : INTEGER1; (* Tx and Rx X-OFF INTEGER1acter    *)
    XonLim                  : WORD; (* Transmit X-ON threshold      *)
    XoffLim                 : WORD; (* Transmit X-OFF threshold     *)
    PeChar                  : INTEGER1; (* Parity error replacement INTEGER1*)
    EofChar                 : INTEGER1; (* End of Input INTEGER1acter       *)
    EvtChar                 : INTEGER1; (* Recieved Event INTEGER1acter     *)
    TxDelay                 : WORD; (* Amount of time between INTEGER1s *)
  END;
  LPDCB = ADS OF DCB;


(*************************************************************************
**
** Status record returned by GetCommError
**
*************************************************************************)

CONST
  fCtsHold      = 1;
  fDsrHold      = 2;
  fRlsdHold     = 4;
  fXoffHold     = 8;
  fXoffSent     = 16;
  fEof          = 32;
  fTxim         = 64;

TYPE
  COMSTAT = RECORD
    bitField                : BYTE;
        (* Packed bits.  Access with constants defined above.
         * BYTE fCtsHold: 1;        - Transmit is on CTS hold
         * BYTE fDsrHold: 1;        - Transmit is on DSR hold
         * BYTE fRlsdHold: 1;       - Transmit is on RLSD hold
         * BYTE fXoffHold: 1;       - Received handshake
         * BYTE fXoffSent: 1;       - Issued handshake
         * BYTE fEof: 1;            - End of file INTEGER1acter found
         * BYTE fTxim: 1;           - Character being transmitted
         *)
    cbInQue                 : WORD; (* count of characters in Rx Que*)
    cbOutQue                : WORD; (* count of characters in Tx Que*)
  END;
  LPCOMSTAT = ADS OF COMSTAT;

{ $IFDECL OpenComm $THEN BEGIN }
  FUNCTION  OpenComm (
    l_               : LPSTR;
    w_,x_            : WORD
  )                  : short;
{ $END }

{ $IFDECL SetCommState $THEN BEGIN }
  FUNCTION  SetCommState (
    d_               : LPDCB
  )                  : short;
{ $END }

{ $IFDECL GetCommState $THEN BEGIN }
  FUNCTION  GetCommState (
    s_               : short;
    d_               : LPDCB
  )                  : short;
{ $END }

{ $IFDECL ReadComm $THEN BEGIN }
  FUNCTION  ReadComm (
    s_               : short;
    l_               : LPSTR;
    i_               : int
  )                  : short;
{ $END }

{ $IFDECL UngetCommChar $THEN BEGIN }
  FUNCTION  UngetCommChar (
    s_               : short;
    i_               : INTEGER1
  )                  : short;
{ $END }

{ $IFDECL WriteComm $THEN BEGIN }
  FUNCTION  WriteComm (
    s_               : short;
    l_               : LPSTR;
    i_               : int
  )                  : short;
{ $END }

{ $IFDECL CloseComm $THEN BEGIN }
  FUNCTION  CloseComm (
    s_               : short
  )                  : short;
{ $END }

{ $IFDECL GetCommError $THEN BEGIN }
  FUNCTION  GetCommError (
    s_               : short;
    c_               : LPCOMSTAT
  )                  : short;
{ $END }

{ $IFDECL BuildCommDCB $THEN BEGIN }
  FUNCTION  BuildCommDCB (
    l_               : LPSTR;
    d_               : LPDCB
  )                  : short;
{ $END }

{ $IFDECL TransmitCommChar $THEN BEGIN }
  FUNCTION  TransmitCommChar (
    s_               : short;
    i_               : INTEGER1
  )                  : short;
{ $END }

{ $IFDECL SetCommEventMask $THEN BEGIN }
  FUNCTION  SetCommEventMask (
    s_               : short;
    w_               : WORD
  )                  : LPWORD;
{ $END }

{ $IFDECL GetCommEventMask $THEN BEGIN }
  FUNCTION  GetCommEventMask (
    s_               : short;
    i_               : int
  )                  : WORD;
{ $END }

{ $IFDECL SetCommBreak $THEN BEGIN }
  FUNCTION  SetCommBreak (
    s_               : short
  )                  : short;
{ $END }

{ $IFDECL ClearCommBreak $THEN BEGIN }
  FUNCTION  ClearCommBreak (
    s_               : short
  )                  : short;
{ $END }

{ $IFDECL FlushComm $THEN BEGIN }
  FUNCTION  FlushComm (
    s_               : short;
    i_               : int
  )                  : short;
{ $END }

{ $IFDECL EscapeCommFunction $THEN BEGIN }
  FUNCTION  EscapeCommFunction (
    s_               : short;
    i_               : int
  )                  : short;
{ $END }
END;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\print.h ===
/*****************************************************************************\
*                                                                             *
* print.h -     Printing helper functions, types, and definitions             *
*                                                                             *
*               Copyright (c) 1985-1992. Microsoft Corp.  All rights reserved.*
*                                                                             *
*******************************************************************************
*
*  PRINTDRIVER       - For inclusion with a printer driver
*  NOPQ              - Prevent inclusion of priority queue APIs
*
\*****************************************************************************/

#ifndef _INC_PRINT
#define _INC_PRINT

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef PRINTDRIVER

#define NORASTEROPS
#define NOTEXTMETRICS
#define NOGDICAPMASKS
#define NOGDIOBJ
#define NOBITMAP
#define NOSOUND
#define NOTEXTMETRIC
#define NOCOMM
#define NOKANJI

#include <windows.h>

#undef NORASTEROPS
#undef NOTEXTMETRICS
#undef NOGDICAPMASKS
#undef NOGDICAPMASKS
#undef NOGDIOBJ
#undef NOBITMAP
#undef NOSOUND
#undef NOTEXTMETRIC
#undef NOCOMM
#undef NOKANJI

#define NOPTRC	/* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#define PQERROR (-1)

#ifndef NOPQ

DECLARE_HANDLE(HPQ);

HPQ     WINAPI CreatePQ(int);
int     WINAPI MinPQ(HPQ);
int     WINAPI ExtractPQ(HPQ);
int     WINAPI InsertPQ(HPQ, int, int);
int     WINAPI SizePQ(HPQ, int);
void    WINAPI DeletePQ(HPQ);
#endif  /* !NOPQ */

/* Spool routines for use by printer drivers */

DECLARE_HANDLE(HPJOB);

HPJOB   WINAPI OpenJob(LPSTR, LPSTR, HPJOB);
int     WINAPI StartSpoolPage(HPJOB);
int     WINAPI EndSpoolPage(HPJOB);
int     WINAPI WriteSpool(HPJOB, LPSTR, int);
int     WINAPI CloseJob(HPJOB);
int     WINAPI DeleteJob(HPJOB, int);
int     WINAPI WriteDialog(HPJOB, LPSTR, int);
int     WINAPI DeleteSpoolPage(HPJOB);

#endif /* !PRINTDRIVER */

typedef struct tagBANDINFOSTRUCT
{
    BOOL    fGraphics;
    BOOL    fText;
    RECT    rcGraphics;
} BANDINFOSTRUCT, FAR* LPBI;

#define USA_COUNTRYCODE 1

/*
 *  Printer driver initialization using ExtDeviceMode()
 *  and DeviceCapabilities().
 *  This replaces Drivinit.h
 */

/* size of a device name string */
#define CCHDEVICENAME 32
#define CCHPAPERNAME  64

/* current version of specification */
#define DM_SPECVERSION 0x30A

/* field selection bits */
#define DM_ORIENTATION	    0x0000001L
#define DM_PAPERSIZE	    0x0000002L
#define DM_PAPERLENGTH	    0x0000004L
#define DM_PAPERWIDTH	    0x0000008L
#define DM_SCALE	    0x0000010L
#define DM_COPIES	    0x0000100L
#define DM_DEFAULTSOURCE    0x0000200L
#define DM_PRINTQUALITY     0x0000400L
#define DM_COLOR	    0x0000800L
#define DM_DUPLEX	    0x0001000L
#define DM_YRESOLUTION	    0x0002000L
#define DM_TTOPTION	    0x0004000L

/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2

/* paper selections */
/*  Warning: The PostScript driver mistakingly uses DMPAPER_ values between
 *  50 and 56.  Don't use this range when defining new paper sizes.
 */
#define DMPAPER_FIRST	    DMPAPER_LETTER
#define DMPAPER_LETTER      1           /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL 2           /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID     3           /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER      4           /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL       5           /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT   6           /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE   7		/* Executive 7 1/4 x 10 1/2 in	      */
#define DMPAPER_A3          8           /* A3 297 x 420 mm                    */
#define DMPAPER_A4          9           /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL     10          /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5          11          /* A5 148 x 210 mm                    */
#define DMPAPER_B4          12          /* B4 250 x 354                       */
#define DMPAPER_B5          13          /* B5 182 x 257 mm                    */
#define DMPAPER_FOLIO       14          /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO      15          /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14       16          /* 10x14 in                           */
#define DMPAPER_11X17       17          /* 11x17 in                           */
#define DMPAPER_NOTE        18          /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9       19          /* Envelope #9 3 7/8 x 8 7/8          */
#define DMPAPER_ENV_10      20          /* Envelope #10 4 1/8 x 9 1/2         */
#define DMPAPER_ENV_11      21          /* Envelope #11 4 1/2 x 10 3/8        */
#define DMPAPER_ENV_12      22          /* Envelope #12 4 \276 x 11           */
#define DMPAPER_ENV_14      23          /* Envelope #14 5 x 11 1/2            */
#define DMPAPER_CSHEET      24          /* C size sheet                       */
#define DMPAPER_DSHEET      25          /* D size sheet                       */
#define DMPAPER_ESHEET      26          /* E size sheet                       */
#define DMPAPER_ENV_DL      27          /* Envelope DL 110 x 220mm            */
#define DMPAPER_ENV_C5      28          /* Envelope C5 162 x 229 mm           */
#define DMPAPER_ENV_C3      29          /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4      30          /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6      31          /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65     32          /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4      33          /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5      34          /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6      35          /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY   36          /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH 37          /* Envelope Monarch 3.875 x 7.5 in    */
#define DMPAPER_ENV_PERSONAL 38         /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US  39          /* US Std Fanfold 14 7/8 x 11 in      */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */

#define DMPAPER_LAST	    DMPAPER_FANFOLD_LGL_GERMAN

#define DMPAPER_USER	    256

/* bin selections */
#define DMBIN_FIRST	    DMBIN_UPPER
#define DMBIN_UPPER	    1
#define DMBIN_ONLYONE	    1
#define DMBIN_LOWER	    2
#define DMBIN_MIDDLE	    3
#define DMBIN_MANUAL	    4
#define DMBIN_ENVELOPE	    5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO	    7
#define DMBIN_TRACTOR	    8
#define DMBIN_SMALLFMT	    9
#define DMBIN_LARGEFMT	    10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_LAST	    DMBIN_CASSETTE

#define DMBIN_USER	    256     /* device specific bins start here */

/* print qualities */
#define DMRES_DRAFT	    (-1)
#define DMRES_LOW	    (-2)
#define DMRES_MEDIUM	    (-3)
#define DMRES_HIGH	    (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR	    2

/* duplex enable */
#define DMDUP_SIMPLEX	 1
#define DMDUP_VERTICAL	 2
#define DMDUP_HORIZONTAL 3

/* TrueType options */
#define DMTT_BITMAP     1       /* print TT fonts as graphics */
#define DMTT_DOWNLOAD   2       /* download TT fonts as soft fonts */
#define DMTT_SUBDEV     3       /* substitute device fonts for TT fonts */

typedef struct tagDEVMODE
{
    char  dmDeviceName[CCHDEVICENAME];
    UINT  dmSpecVersion;
    UINT  dmDriverVersion;
    UINT  dmSize;
    UINT  dmDriverExtra;
    DWORD dmFields;
    int   dmOrientation;
    int   dmPaperSize;
    int   dmPaperLength;
    int   dmPaperWidth;
    int   dmScale;
    int   dmCopies;
    int   dmDefaultSource;
    int   dmPrintQuality;
    int   dmColor;
    int   dmDuplex;
    int   dmYResolution;
    int   dmTTOption;
} DEVMODE;

typedef DEVMODE* PDEVMODE, NEAR* NPDEVMODE, FAR* LPDEVMODE;

/* mode selections for the device mode function */
#define DM_UPDATE	    1
#define DM_COPY 	    2
#define DM_PROMPT	    4
#define DM_MODIFY	    8

#define DM_IN_BUFFER	    DM_MODIFY
#define DM_IN_PROMPT	    DM_PROMPT
#define DM_OUT_BUFFER	    DM_COPY
#define DM_OUT_DEFAULT	    DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS	    1
#define DC_PAPERS	    2
#define DC_PAPERSIZE	    3
#define DC_MINEXTENT	    4
#define DC_MAXEXTENT	    5
#define DC_BINS 	    6
#define DC_DUPLEX	    7
#define DC_SIZE 	    8
#define DC_EXTRA	    9
#define DC_VERSION	    10
#define DC_DRIVER	    11
#define DC_BINNAMES	    12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE	    15
#define DC_PAPERNAMES	    16
#define DC_ORIENTATION	    17
#define DC_COPIES	    18

/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP	    0x0000001L
#define DCTT_DOWNLOAD	    0x0000002L
#define DCTT_SUBDEV	    0x0000004L

/* export ordinal definitions */
#define PROC_EXTDEVICEMODE	MAKEINTRESOURCE(90)
#define PROC_DEVICECAPABILITIES MAKEINTRESOURCE(91)
#define PROC_OLDDEVICEMODE	MAKEINTRESOURCE(13)

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions
 */
typedef UINT   (CALLBACK* LPFNDEVMODE)(HWND, HMODULE, DEVMODE FAR*,
                          LPSTR, LPSTR, DEVMODE FAR*, LPSTR, UINT);

typedef DWORD  (CALLBACK* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, DEVMODE FAR*);

HDC     WINAPI ResetDC(HDC, const DEVMODE FAR*);

/* this structure is used by the GETSETSCREENPARAMS escape */
typedef struct tagSCREENPARAMS
{
   int angle;
   int frequency;
} SCREENPARAMS;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_PRINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none, 
    olerender_draw, 
    olerender_format 
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);
    
    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);
    
/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\rom.inc ===
; ROM Windows specific include file

;
;   INT 2F subfunction
;	if ROM installed, returns 0 in AX and RM segment of ROMTOC in
;	BX.  Hooked by WIN.COM to pass ROMTOC to other components
;
ROMINSTALLCHECK     equ 160Ch

; ROM Table of Contents structure

ROMTOC	STRUC
ROMSignature	db	55h, 0AAh	; IBM standard ROM signature
ROMLength	db	?		; IBM length (/512)
ROMEntryPoint	db	5 dup (?)	; jmp near + retf + pad
szID		db	10 dup (?)	; ID string "ROMWINTOC\0"
DOSX_CSIP	dd	?		; DOSX initial CS:IP   (seg:off)
KRNL_CSIP	dd	?		; Kernel initial CS:IP (sel:off)
lmaROMLDT	dd	?		; lma of ROM prototype LDT
cROMsels	dw	?		; # descriptors used in ROM proto LDT
FirstROMsel	dw	?		; first LDT selector in ROM proto LDT
offSysDir	dw	?		; offset to system directory string
lmaHigh		dd	?		; lma of high ROM
lenHigh		dd	?		; length in bytes of High ROM
cModules	dw	?		; # modules defined in ROM TOC
cFiles		dw	?		; # files defined in ROM TOC
ModEntries	db	?		; start of module entries

; module entries follow at this point...
; file entries start at ModEntries + cModules*(SIZE MODENT)

ROMTOC	ENDS


; Module entry format in ROM TOC

File_Name_Len	=	13
Module_Name_Len =	9

MODENT	STRUC
ModNameStr	db	Module_Name_Len dup (?) ; Module name (null padded)
FileNameStr	db	File_Name_Len	dup (?) ; File name (null padded)
lmaExeHdr	dd	?			; lma of module EXE header
MODENT	ENDS

FILENT STRUC
fname		db	File_Name_Len dup(?)	; file name
lma		dd	?			; lma of start of file
fsize		dd	?
FILENT ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If included with Windows 3.0 windows.h: define 3.1-compatible types */

#ifndef _INC_WINDOWS

#define HDROP   HANDLE
#define WINAPI  FAR PASCAL
#define LPCSTR  LPSTR
#define UINT    WORD

#else

DECLARE_HANDLE(HDROP);

#endif

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ			1	    /* string type */

#define HKEY_CLASSES_ROOT	0x80000000

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;
                                                                /* ;Internal */
typedef struct _dropfilestruct {				/* ;Internal */
    WORD pFiles;                        /* offset of file list*//* ;Internal */
    POINT pt;                           /* drop point         *//* ;Internal */
    BOOL fNC;                           /* is it on NC area   *//* ;Internal */
} DROPFILESTRUCT, FAR* LPDROPFILESTRUCT;                        /* ;Internal */

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
				 
int   WINAPI ShellAbout(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);                   /* ;Internal */
HICON WINAPI ExtractAssociatedIcon(HANDLE hInst, LPSTR lpIconPath, WORD FAR* lpiIcon);                /* ;Internal */
HICON WINAPI InternalExtractIcon(HANDLE hInst, LPCSTR lpszExeFileName, WORD nIconIndex, WORD nIcons); /* ;Internal */
DWORD WINAPI DoEnvironmentSubst(LPSTR szString, WORD cbString);                                       /* ;Internal */
BOOL  WINAPI RegisterShellHook(HWND, BOOL);                                                           /* ;Internal */

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\spl_wnt.h ===
/*****************************************************************/ 
/**		  Microsoft Windows for Workgroups		**/
/**	      Copyright (C) Microsoft Corp., 1991-1992		**/
/*****************************************************************/ 

#ifndef _spl_wnt_h_
#define _spl_wnt_h_

/*
 *	Print Manager Administration APIs
 *	for later inclusion into WINNET.H once they settle down
 *
 *	JONN 4/19/91	Trimmed out unnecessary stuff
 *	JONN 5/3/91	Added type WNETERR
 */


/*
    Codes for WNetPrintMgrSelNotify's "type" variable, indicating
    what's selected:  a queue, a job, or nothing.
*/

#define WNPMSEL_NOTHING	0
#define WNPMSEL_QUEUE	1
#define WNPMSEL_JOB	2

#define PRIORITY        10		/* menu uses 10, 11, 12, 13 */
#define ABOUT	       24
#define EXIT            25
#define PRINT_LOG       28
#define NETWORK         29
#define HELP_NDEX       30
#define HELP_MOUSE      31
#define HELP_KEYBOARD   32
#define HELP_HELP       33
#define HELP_COMMANDS   34
#define HELP_PROCEDURES 35

#define SHOW_TIME   51
#define SHOW_SIZE   52
#define SHOW_DETAIL 53
#define UPDATE      54
#define SHOW_LOCAL  55
#define SHOW_NET    56
#define SHOW_QUEUE  57
#define SHOW_OTHER  58

#define ALERT_ALWAYS	100
#define ALERT_FLASH	101
#define ALERT_IGNORE	102

#define PRT_SETUP       8001   // These have to match the stuff in control
#define NETWK_CONNECTIONS 8021  // panel

#define PM_REFRESH	WM_USER + 100  // BUGBUG: Need to define proper manifest
#define PM_SELQUEUE	WM_USER + 101
#define PM_QUERYSEL	WM_USER + 102

typedef struct _wnpmsel {	/* structure returned by PM_QUERYSEL */
    WORD wJobID;
    char szQueueName [260];	/* in the form "LPT1\0HP LaserJet III\0" */
} WNPMSEL, far *LPWNPMSEL;

#define IDM_PROPERTIES		202
#define IDM_CHANGE_MENUS    	212

/*
 *	added JONN 2/26/91
 *	Print Manager Extensions
 */

typedef struct _queuestruct2
{
    WORD pq2Name;		/* offset to queue name */
				/* in the form "LPT1\0HP LaserJet III\0" */
    WORD pq2Comment;		/* offset to queue comment */
    WORD pq2Driver;		/* offset to driver name */
    WORD pq2Status;		/* status flags */
    WORD pq2Jobcount;		/* number of jobs in this queue */    
    WORD pq2Flags;		/* miscellaneous flags */

} QUEUESTRUCT2, FAR *LPQS2;

#define QNAME(buf,qs)	((LPSTR)(buf) + (qs).pq2Name)
#define QCOMMENT(buf,qs) ((LPSTR)(buf) + (qs).pq2Comment)
#define QDRIVER(buf,qs)	((LPSTR)(buf) + (qs).pq2Driver)

#define QF_REDIRECTED	0x0001
#define QF_SHARED	0x0002

typedef struct _jobstruct2 {
	WORD	pj2Id;		// job ID
	WORD	pj2Username;	// name of owner (offset to string)
//	WORD	pj2Parms;
	WORD	pj2Position;	// 0-based position in queue
	WORD	pj2Status;	// status flags (WNPRJ_XXXXX)
	DWORD	pj2Submitted;
	DWORD	pj2Size;	// size of job in bytes
        DWORD	pj2SubmitSize;	// bytes submitted so far
//	WORD	pj2Copies;
	WORD	pj2Comment;	// comment/app name (offset to string)
	WORD	pj2Document;	// document name (offset to string)
	WORD	pj2StatusText;	// verbose status (offset to string)
	WORD	pj2PrinterName;	// name of port job is printing on (offs to str)
} JOBSTRUCT2;

typedef JOBSTRUCT2 far * LPJOBSTRUCT2;

#define JOBNAME(buf,job)	((LPSTR)(buf) + (job).pj2Username)
#define JOBCOMMENT(buf,job)	((LPSTR)(buf) + (job).pj2Comment)
#define JOBDOCUMENT(buf,job)	((LPSTR)(buf) + (job).pj2Document)
#define JOBSTATUS(buf,job)	((LPSTR)(buf) + (job).pj2StatusText)
#define JOBPRINTER(buf,job)	((LPSTR)(buf) + (job).pj2PrinterName)

/*
 * Type WNETERR distinguishes WN_ error codes from other WORD
 * values.  Added JONN 5/3/91
 */
typedef WORD WNETERR;

// new Print Manager Extensions APIs
/* All queue names are in the form "LPT1\0HP LaserJet III\0" */
#ifdef C700
extern void far pascal __loadds WNetPrintMgrSelNotify (BYTE, LPQS2, LPQS2,
	LPJOBSTRUCT2, LPJOBSTRUCT2, LPWORD, LPSTR, WORD);
extern WNETERR far pascal __loadds WNetPrintMgrPrinterEnum (LPSTR lpszQueueName,
	LPSTR lpBuffer, LPWORD pcbBuffer, LPWORD cAvail, WORD usLevel);
extern WNETERR far pascal __loadds WNetPrintMgrChangeMenus(HWND, HANDLE FAR *, BOOL FAR *);
extern WNETERR far pascal __loadds WNetPrintMgrCommand (HWND, WORD);
extern void far pascal __loadds WNetPrintMgrExiting (void);
extern BOOL far pascal __loadds WNetPrintMgrExtHelp (DWORD);
extern WORD far pascal __loadds WNetPrintMgrMoveJob (HWND, LPSTR, WORD, int);
#else
extern void API WNetPrintMgrSelNotify (BYTE, LPQS2, LPQS2,
	                               LPJOBSTRUCT2, LPJOBSTRUCT2, 
                                       LPWORD, LPSTR, WORD);
extern WNETERR API WNetPrintMgrPrinterEnum (LPSTR lpszQueueName,
	                                    LPSTR lpBuffer, LPWORD pcbBuffer, 
                                            LPWORD cAvail, WORD usLevel);
extern WNETERR API WNetPrintMgrChangeMenus(HWND, HANDLE FAR *, BOOL FAR *);
extern WNETERR API WNetPrintMgrCommand (HWND, WORD);
extern void API WNetPrintMgrExiting (void);
extern BOOL API WNetPrintMgrExtHelp (DWORD);
extern WORD API WNetPrintMgrMoveJob (HWND, LPSTR, WORD, int);
#endif


#define WINBALL
#ifdef WINBALL
#define WNNC_PRINTMGRNOTIFY	0x000C
#ifdef C700
extern void far pascal __loadds WNetPrintMgrStatusChange (LPSTR lpszQueueName,
	LPSTR lpszPortName, WORD wQueueStatus, WORD cJobsLeft, HANDLE hJCB,
	BOOL fDeleted);
#else
extern void API WNetPrintMgrStatusChange (LPSTR lpszQueueName,
	                                  LPSTR lpszPortName, 
                                          WORD wQueueStatus, 
                                          WORD cJobsLeft, 
                                          HANDLE hJCB,
	                                  BOOL fDeleted);
#endif

#define PM_QUERYQDATA		WM_USER + 104

typedef struct _PMQUEUE {
    WORD dchPortName;		/* offset to port name string */
    WORD dchPrinterName;	/* offset to printer name string */
    WORD dchRemoteName;		/* offset to remote name string */
    WORD cJobs;			/* count of jobs */
    WORD fwStatus;		/* queue status */
} PMQUEUE, FAR *LPPMQUEUE;

#define PMQPORTNAME(buf,queue)		((LPSTR)(buf) + (queue).dchPortName)
#define PMQPRINTERNAME(buf,queue)	((LPSTR)(buf) + (queue).dchPrinterName)
#define PMQREMOTENAME(buf,queue)	((LPSTR)(buf) + (queue).dchRemoteName)

typedef struct _PMJOB {
    DWORD dwTime;		/* date/time job was spooled */
    DWORD cbJob;		/* job size in bytes */
    DWORD cbSubmitted;		/* bytes submitted so far */
    WORD dchJobName;		/* offset to job name (doc name) string */
    HANDLE hJCB;		/* hJCB to refer to the job */
} PMJOB, FAR *LPPMJOB;

#define PMJOBNAME(buf,job)	((LPSTR)(buf) + (job).dchJobName)


#endif

// new values for WNetGetCaps()
#define WNNC_PRINTMGREXT		0x000B
// returns extensions version number, re: GetVersion(),
//   or 0 if not supported

// QUEUESTRUCT2.pq2Status and .pq2Jobcount for WNetPrintMgrPrinterEnum[2]
#define WNQ_UNKNOWN -1

#define WNPRS_CANPAUSE	0x0001
#define WNPRS_CANRESUME	0x0002
#define WNPRS_CANDELETE	0x0004
#define WNPRS_CANMOVE	0x0008
#define WNPRS_CANDISCONNECT	0x0010
#define WNPRS_CANSTOPSHARE	0x0020
#define WNPRS_ISPAUSED		0x0040
#define WNPRS_ISRESUMED		0x0080

// help contexts, were previously in sphelp.h
#define IDH_HELPFIRST		5000
#define IDH_SYSMENU	(IDH_HELPFIRST + 2000)
#define IDH_MBFIRST	(IDH_HELPFIRST + 2001)
#define IDH_MBLAST	(IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST	(IDH_HELPFIRST + 3000)


#define IDH_PRIORITY	(IDH_HELPFIRST + PRIORITY )
#define IDH_PRIORITY1 	(IDH_HELPFIRST + PRIORITY + 1)
#define IDH_PRIORITY2 	(IDH_HELPFIRST + PRIORITY + 2)
#define IDH_ABOUT	(IDH_HELPFIRST + ABOUT	)
#define IDH_EXIT 	(IDH_HELPFIRST + EXIT)
#define IDH_NETWORK 	(IDH_HELPFIRST + NETWORK)
#define IDH_HELP_NDEX 	(IDH_HELPFIRST + HELP_NDEX)
#define IDH_HELP_MOUSE 	(IDH_HELPFIRST + HELP_MOUSE)
#define IDH_HELP_KEYBOARD 	(IDH_HELPFIRST + HELP_KEYBOARD)
#define IDH_HELP_HELP 	(IDH_HELPFIRST + HELP_HELP)
#define IDH_HELP_COMMANDS 	(IDH_HELPFIRST + HELP_COMMANDS)
#define IDH_HELP_PROCEDURES 	(IDH_HELPFIRST + HELP_PROCEDURES)
#define IDH_SHOW_TIME 	(IDH_HELPFIRST + SHOW_TIME)
#define IDH_SHOW_SIZE 	(IDH_HELPFIRST + SHOW_SIZE)
#define IDH_UPDATE 	(IDH_HELPFIRST + UPDATE)
#define IDH_SHOW_QUEUE 	(IDH_HELPFIRST + SHOW_QUEUE)
#define IDH_SHOW_OTHER 	(IDH_HELPFIRST + SHOW_OTHER)
#define IDH_ALERT_ALWAYS 	(IDH_HELPFIRST + ALERT_ALWAYS)
#define IDH_ALERT_FLASH 	(IDH_HELPFIRST + ALERT_FLASH)
#define IDH_ALERT_IGNORE 	(IDH_HELPFIRST + ALERT_IGNORE)


// was in spoolids.h

#define IDS_A_BASE	4096

/* also used as button IDs */
#define ID_ABORT	4
#define ID_PAUSE	2
#define ID_RESUME	3
#define ID_EXPLAIN	5

#endif /* _spl_wnt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_start(ap,v) ap = (va_list)&v + sizeof(v)
#define va_arg(ap,t) ((t _FAR_ *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\spool.h ===
#ifndef WINAPI
#ifdef BUILDDLL                                 /* ;Internal */
#define WINAPI              _loadds far pascal  /* ;Internal */
#define CALLBACK	    _loadds far pascal	/* ;Internal */
#else						/* ;Internal */
#define WINAPI              far pascal
#define CALLBACK	    far pascal
#endif                                          /* ;Internal */
#endif

#define LWORD(x)        ((int)((x)&0xFFFF))


/* spooler error code */
#define SP_ERROR            (-1)    /* general error - mostly used when spooler isn't loaded */
#define SP_APPABORT         (-2)    /* app aborted the job through the driver */
#define SP_USERABORT        (-3)    /* user aborted the job through spooler's front end */
#define SP_OUTOFDISK        (-4)    /* simply no disk to spool */
#define SP_OUTOFMEMORY      (-5)
#define SP_RETRY            (-6)    /* retry sending to the port again  */
#define SP_NOTREPORTED      0x4000  /* set if GDI did not report error */

/* subfunctions of the Spooler support function, GetSpoolJob()
 *  CP_* are used by the control panel for modifying the printer setup/
 */
#define SP_PRINTERNAME      20
#define SP_REGISTER         21
#define SP_CONNECTEDPORTCNT 25
#define SP_QUERYDISKUSAGE   26
#define SP_DISKFREED        27
#define SP_INIT             28
#define SP_LISTEDPORTCNT    29
#define CP_ISPORTFREE	    30
#define CP_REINIT	    31
#define SP_TXTIMEOUT	    32
#define SP_DNSTIMEOUT	    33
#define CP_CHECKSPOOLER     34
#define CP_SET_TT_ONLY      35
#define CP_SETSPOOLER       36
#define CP_SETDOSPRINT      37


#define SP_DISK_BUFFER      (20000) /* wait for about 20 K of disk space to free
                                       free up before attempting to write to disk */

/* messages posted or sent to the spooler window
 */
#define SP_NEWJOB           0x1001
#define SP_DELETEJOB        0x1002
#define SP_DISKNEEDED       0x1003
#define SP_QUERYDISKAVAIL   0x1004
#define SP_ISPORTFREE       0x1005
#define SP_CHANGEPORT       0x1006

/* in /windows/oem/printer.h */


/* job status flag bits in the type field of the JCB structure
 */
#define JB_ENDDOC           0x0001
#define JB_INVALIDDOC       0x0002
#define JB_DIRECT_SPOOL     0x8000  /* go directly to the printer without the spooler */
#define JB_FILE_PORT        0x4000  /* were given a file for a port name */
#define JB_VALID_SPOOL      0x2000  /* everything is cool, continue to spool normally */
#define JB_NOTIFIED_SPOOLER 0x1000  /* already notified the spooler of this job */
#define JB_WAITFORDISK      0x0800  /* out of disk condition has been detected previously */
#define JB_DEL_FILE         0x0400  /* no deletion of file after spool          */
#define JB_FILE_SPOOL	    0x0200  /* spooling a file		*/
#define JB_NET_SPOOL	    0x0100  /* sending directly to network */

/* allow 2 dialog box messages initially and increment 8 at a time */
#define SP_DLGINC       8
#define SP_DLGINIT      8

#define NAME_LEN        32
#define BUF_SIZE        128
#define MAX_PROFILE     80
#define JCBBUF_LEN      256

#define lower(c)        ((c > 'A' && c < 'Z') ? (c - 'A' + 'a') : c)

#define IDS_LENGTH	    60

/* comm driver stuff */
#define COMM_INQUE          0x010                       /* wm091385 */
#define COMM_OUTQUE         0x030                       /* wm091385 */
#define COMM_OUTQUEPMODE    0x400                       /* New size for pmode */

#define COMM_ERR_BIT        0x8000
#define TXTIMEOUT           45000               /* milliseconds */
#define DNSTIMEOUT          15000               /* milliseconds */

#define BAUDRATE            0
#define PARITY              1
#define BYTESIZE            2
#define STOPBITS            3
#define REPEAT              4


typedef struct {
    int     type;           /* type of dialog. This will tell whether it is */
                            /* call back function or pure dialog etc        */
    int     size;           /* size of special function data                */
    int     adr;
}DIALOGMARK;

#define SP_TEXT         0   /* text type                                */
#define SP_NOTTEXT      1   /* not text type                            */
#define SP_DIALOG       2   /* dialog type data                         */
#define SP_CALLBACK     3   /* call back type function                  */

#define MAXPORTLIST 20  	/* max # ports listed in win.ini [ports] */
#define MAXPORT     MAXPORTLIST
#define MAXSPOOL    100		/* max # jobs spooled per port */
#define MAXMAP      18
#define PORTINDENT   2
#define JOBINDENT    3
#define MAXPAGE     7     /* allow 7 pages at first */
#define INC_PAGE    8     /* increase by 8 pages at a time */

typedef struct {
    int   pnum;
    int   printeratom;
    long txtimeout;
    long dnstimeout;
}JCBQ;

typedef struct jcb {
    unsigned        type;
    int             pagecnt;
    int             maxpage;
    int             portnum;
    HDC             hDC;
    int             chBuf;
    long	    timeSpooled;
    char            buffer[JCBBUF_LEN];
    unsigned long   size;
    unsigned long   iLastPage;
    WORD	    psp;		// the PSP of the app that started printing
    char            jobName[NAME_LEN];
    int             page[MAXPAGE];
}JCB;

typedef struct page {
    int      filenum;
    unsigned maxdlg;                    /* max number of dialog */
    unsigned dlgptr;                    /* number of dialogs */
    long     spoolsize;
    OFSTRUCT fileBuf;
    DIALOGMARK  dialog[SP_DLGINIT];
}PAGE;

#define SP_COMM_PORT    0
#define SP_FILE_PORT	1
#define SP_REMOTE_QUEUE 2
#define SP_QUERYVALIDJOB    30


typedef struct
{
        int   type;
        int   fn;
        long  retry;            /* system timer on first error  */
}   PORT;


/* exported routines */
BOOL  WINAPI QueryJob(HANDLE, int);
BOOL  WINAPI QueryAbort(HANDLE, int);

int   WINAPI WriteDialog(HANDLE hJCB, LPSTR str, int n);
int   WINAPI WriteSpool(HANDLE hJCB, LPSTR str, int n);

LONG  WINAPI GetSpoolJob(int, long);
char  WINAPI GetSpoolTempDrive(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

/* definition of the return type for the onexit() function */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1

#ifndef _ONEXIT_T_DEFINED
typedef int (_FAR_ _cdecl _LOADDS_ * _cdecl onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */

/* external variable declarations */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
extern unsigned _far * _cdecl _far __doserrno(void);
#define errno	    (*_errno())
#define _doserrno   (*__doserrno())
#else
extern int _near _cdecl volatile errno; 	/* XENIX style error number */
extern int _near _cdecl _doserrno;		/* MS-DOS system error value */
#endif
extern char * _near _cdecl sys_errlist[];	/* perror error message table */
extern int _near _cdecl sys_nerr;		/* # of entries in sys_errlist table */

#ifdef _DLL
extern char ** _FAR_ _cdecl environ;		/* pointer to environment table */
extern int _FAR_ _cdecl _fmode; 		/* default file translation mode */
extern int _FAR_ _cdecl _fileinfo;		/* open file info mode (for spawn) */
#else
extern char ** _near _cdecl environ;		/* pointer to environment table */
extern int _near _cdecl _fmode; 		/* default file translation mode */
extern int _near _cdecl _fileinfo;		/* open file info mode (for spawn) */
#endif

extern unsigned int _near _cdecl _psp;		/* Program Segment Prefix */

/* OS major/minor version numbers */

#ifndef _WINDLL
extern unsigned char _near _cdecl _osmajor;
extern unsigned char _near _cdecl _osminor;
#endif

#define DOS_MODE	0	/* Real Address Mode */
#define OS2_MODE	1	/* Protected Address Mode */

extern unsigned char _near _cdecl _osmode;


/* function prototypes */

#ifdef	_MT
double _FAR_ _pascal atof(const char _FAR_ *);
double _FAR_ _pascal strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _pascal ldiv(long, long);
#else	/* not _MT */
double _FAR_ _cdecl atof(const char _FAR_ *);
double _FAR_ _cdecl strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _cdecl ldiv(long, long);
#endif

void _FAR_ _cdecl abort(void);
int _FAR_ _cdecl abs(int);
int _FAR_ _cdecl atexit(void (_cdecl _FAR_ _LOADDS_ *)(void));
int _FAR_ _cdecl atoi(const char _FAR_ *);
long _FAR_ _cdecl atol(const char _FAR_ *);
long double _FAR_ _cdecl _atold(const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl bsearch(const void _FAR_ *, const void _FAR_ *,
	size_t, size_t, int (_FAR_ _cdecl *)(const void _FAR_ *,
	const void _FAR_ *));
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
div_t _FAR_ _cdecl div(int, int);
char _FAR_ * _FAR_ _cdecl ecvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
char _FAR_ * _FAR_ _cdecl fcvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl free(void _FAR_ *);
char _FAR_ * _FAR_ _cdecl _fullpath(char _FAR_ *, const char _FAR_ *,
	size_t);
#ifndef _WINDLL
char _FAR_ * _FAR_ _cdecl gcvt(double, int, char _FAR_ *);
#endif
char _FAR_ * _FAR_ _cdecl getenv(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl itoa(int, char _FAR_ *, int);
long _FAR_ _cdecl labs(long);
unsigned long _FAR_ _cdecl _lrotl(unsigned long, int);
unsigned long _FAR_ _cdecl _lrotr(unsigned long, int);
char _FAR_ * _FAR_ _cdecl ltoa(long, char _FAR_ *, int);
void _FAR_ _cdecl _makepath(char _FAR_ *, const char _FAR_ *,
	const char _FAR_ *, const char _FAR_ *, const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
onexit_t _FAR_ _cdecl onexit(onexit_t);
#ifndef _WINDOWS
void _FAR_ _cdecl perror(const char _FAR_ *);
#endif
int _FAR_ _cdecl putenv(const char _FAR_ *);
void _FAR_ _cdecl qsort(void _FAR_ *, size_t, size_t, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
unsigned int _FAR_ _cdecl _rotl(unsigned int, int);
unsigned int _FAR_ _cdecl _rotr(unsigned int, int);
int _FAR_ _cdecl rand(void);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
void _FAR_ _cdecl _searchenv(const char _FAR_ *, const char _FAR_ *,
	char _FAR_ *);
void _FAR_ _cdecl _splitpath(const char _FAR_ *, char _FAR_ *,
	char _FAR_ *, char _FAR_ *, char _FAR_ *);
void _FAR_ _cdecl srand(unsigned int);
long _FAR_ _cdecl strtol(const char _FAR_ *, char _FAR_ * _FAR_ *,
	int);
long double _FAR_ _cdecl _strtold(const char _FAR_ *,
	char _FAR_ * _FAR_ *);
unsigned long _FAR_ _cdecl strtoul(const char _FAR_ *,
	char _FAR_ * _FAR_ *, int);
void _FAR_ _cdecl swab(char _FAR_ *, char _FAR_ *, int);
#ifndef _WINDOWS
int _FAR_ _cdecl system(const char _FAR_ *);
#endif
char _FAR_ * _FAR_ _cdecl ultoa(unsigned long, char _FAR_ *, int);

#ifndef tolower 	/* tolower has been undefined - use function */
int _FAR_ _cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
int _FAR_ _cdecl toupper(int);
#endif	/* toupper */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\strtable.h ===
/****************************************************************************/
/*                                      */
/*  STRTABLE.H -                                */
/*                                      */
/*  StringTable Defines                         */
/*                                      */
/****************************************************************************/

/* STRINGTABLE Defines */
#define STR_WINDOWS     0
#define STR_COLORS      1
#define STR_DESKPATTERN     2
#define STR_FONTS       3
#define STR_BLINK       4
#define STR_SWAPBUTTONS     5
#define STR_DBLCLKSPEED     6
#define STR_TYPEAHEAD       7
#define STR_GRID        8
#define STR_BEEP        9
#define STR_MOUSETHRESH1        10
#define STR_MOUSETHRESH2        11
#define STR_MOUSESPEED      12
#define STR_KEYSPEED        13
#define STR_BORDER      14
#define STR_QSIZE       15

#define STR_CLASSSTART      16
#define STR_BUTTONCLASS     16
#define STR_EDITCLASS       17
#define STR_STATICCLASS     18
#define STR_LISTBOXCLASS    19
#define STR_SCROLLBARCLASS  20
#define STR_COMBOBOXCLASS   21
#define STR_MDICLASS        22
#define STR_COMBOLISTBOXCLASS   23

#define STR_COLORSTART      32
#define STR_SCROLLBAR       32
#define STR_BACKGROUND      33
#define STR_ACTIVETITLE     34
#define STR_INACTIVETITLE   35
#define STR_MENU        36
#define STR_WINDOW      37
#define STR_WINDOWFRAME     38
#define STR_MENUTEXT        39
#define STR_WINDOWTEXT      40
#define STR_TITLETEXT       41
#define STR_ACTIVEBORDER    42
#define STR_INACTIVEBORDER  43
#define STR_APPWORKSPACE    44
#define STR_HIGHLIGHT       45
#define STR_HIGHLIGHTTEXT   46
#define STR_BTNFACE             47
#define STR_BTNSHADOW           48
#define STR_GRAYTEXT            49
#define STR_BTNTEXT             50
#define STR_INACTIVECAPTIONTEXT 51

#define STR_FILEPORT            60
#define STR_CANTOPEN            61
#define STR_OVERWRITE           62
#define STR_MOREWINDOWS     63

#define STR_ICONHORZSPACING     64
#define STR_ICONVERTSPACING     65
#define STR_ICONTITLEWRAP       66

#define STR_DTBITMAP        67
#define STR_DTSTYLE     68
#define STR_DTORIGINX       69
#define STR_DTORIGINY       70

#define STR_NETDRIVER       71
#define STR_BOOT        72
#define STR_LANGDRIVER      73
#define STR_SYSTEMINI       74
#define STR_SYSERR              75
#define STR_DIVBYZERO           76
#define STR_UNTITLED            77
#define STR_ERROR               78
#define STR_TASKMAN             79

#define STR_DESKTOP     80
#define STR_PATTERNS        81
#define STR_NONE        82
#define STR_TILEWALL        83

#define STR_OK                  84
#define STR_CANCEL              85
#define STR_ABORT               86
#define STR_RETRY               87
#define STR_IGNORE              88
#define STR_YES                 89
#define STR_NO                  90
#define STR_ACCELERATORS    91
#define STR_AM                  92
#define STR_PM                  93
#define STR_MENUSHOWDELAY       94
#define STR_MENUHIDEDELAY       95
#define STR_MENUDROPALIGNMENT   96
#define STR_DOUBLECLICKWIDTH    97
#define STR_DOUBLECLICKHEIGHT   98
#define STR_SCREENSAVETIMEOUT   99
#define STR_SCREENSAVEACTIVE    100
#define STR_SCREENSAVEEXE       101
#define STR_DRIVERS             102
#define STR_NOMEMBITMAP         103
#define STR_BEEPYES     104
#define STR_BEEPNO      105
#define STR_KEYDELAY        106
#define STR_DRAGFULLWINDOWS     107
#define STR_ICONTITLEFACENAME   108
#define STR_ICONTITLESIZE       109
#define STR_ICONTITLESTYLE      110
#define STR_FASTALTTAB          111
#define STR_INRESTORENETCONNECT 112

#define STR_COMMMODULENAME      200
#define STR_COMMWRITESTRING     201
#define STR_COMMREADSTRING      202
#define STR_COMMENABLENOTIFICATION 203
#define STR_MOUSEMODULENAME     204


    /* 256 - 512 are strings for network errors
     */

#define STR_NETCONNMSG      256
#define STR_NETCONNTTL      257
#define STR_NETCRASHEDTITLE     258
#define STR_NETCRASHEDMSG       259
#define STR_NETERRORS       275

#define STR_SEARCH_TAG      513 // don't change, these are hard
#define STR_USER_NAME       514 // coded in SHELL.DLL
#define STR_ORG_NAME        515 // ugh!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the level 2 I/O ("standard I/O") routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

/* buffered I/O macros */

#define BUFSIZ	512
#ifdef _MT
#define _NFILE	40
#else
#define _NFILE	20
#endif
#define EOF	(-1)

#ifndef _FILE_DEFINED
struct _iobuf {
	char _FAR_ *_ptr;
	int   _cnt;
	char _FAR_ *_base;
	char  _flag;
	char  _file;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of P_tmpdir
 *	+ 1 (in case P_tmpdir does not end in "\\")
 *	+ 6 (for the temp number string)
 *	+ 1 (for the null terminator)
 */

#define  P_tmpdir "\\"
#define  L_tmpnam sizeof(P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 63
#define FOPEN_MAX 20
#define SYS_OPEN 20
#define TMP_MAX 32767


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
#ifdef _DLL
extern FILE _FAR_ _cdecl _iob[];
#else
extern FILE _near _cdecl _iob[];
#endif
#endif


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif


/* standard file pointers */

#ifndef _WINDOWS
#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#define stdaux (&_iob[3])
#define stdprn (&_iob[4])
#endif


#define _IOREAD 	0x01
#define _IOWRT		0x02

#define _IOFBF		0x0
#define _IOLBF		0x40
#define _IONBF		0x04

#define _IOMYBUF	0x08
#define _IOEOF		0x10
#define _IOERR		0x20
#define _IOSTRG 	0x40
#define _IORW		0x80


/* function prototypes */

#ifndef _STDIO_DEFINED
int _FAR_ _cdecl _filbuf(FILE _FAR_ *);
int _FAR_ _cdecl _flsbuf(int, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _fsopen(const char _FAR_ *,
	const char _FAR_ *, int);
void _FAR_ _cdecl clearerr(FILE _FAR_ *);
int _FAR_ _cdecl fclose(FILE _FAR_ *);
int _FAR_ _cdecl fcloseall(void);
FILE _FAR_ * _FAR_ _cdecl fdopen(int, const char _FAR_ *);
int _FAR_ _cdecl feof(FILE _FAR_ *);
int _FAR_ _cdecl ferror(FILE _FAR_ *);
int _FAR_ _cdecl fflush(FILE _FAR_ *);
int _FAR_ _cdecl fgetc(FILE _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl fgetchar(void);
#endif
int _FAR_ _cdecl fgetpos(FILE _FAR_ *, fpos_t _FAR_ *);
char _FAR_ * _FAR_ _cdecl fgets(char _FAR_ *, int, FILE _FAR_ *);
int _FAR_ _cdecl fileno(FILE _FAR_ *);
int _FAR_ _cdecl flushall(void);
FILE _FAR_ * _FAR_ _cdecl fopen(const char _FAR_ *,
	const char _FAR_ *);
#ifndef _WINDLL
int _FAR_ _cdecl fprintf(FILE _FAR_ *, const char _FAR_ *, ...);
#endif
int _FAR_ _cdecl fputc(int, FILE _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl fputchar(int);
#endif
int _FAR_ _cdecl fputs(const char _FAR_ *, FILE _FAR_ *);
size_t _FAR_ _cdecl fread(void _FAR_ *, size_t, size_t, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl freopen(const char _FAR_ *,
	const char _FAR_ *, FILE _FAR_ *);
#ifndef _WINDLL
int _FAR_ _cdecl fscanf(FILE _FAR_ *, const char _FAR_ *, ...);
#endif
int _FAR_ _cdecl fsetpos(FILE _FAR_ *, const fpos_t _FAR_ *);
int _FAR_ _cdecl fseek(FILE _FAR_ *, long, int);
long _FAR_ _cdecl ftell(FILE _FAR_ *);
size_t _FAR_ _cdecl fwrite(const void _FAR_ *, size_t, size_t,
	FILE _FAR_ *);
int _FAR_ _cdecl getc(FILE _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl getchar(void);
char _FAR_ * _FAR_ _cdecl gets(char _FAR_ *);
#endif
int _FAR_ _cdecl getw(FILE _FAR_ *);
#ifndef _WINDOWS
void _FAR_ _cdecl perror(const char _FAR_ *);
#endif
int _FAR_ _cdecl _pclose(FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _popen(const char _FAR_ *,
	const char _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl printf(const char _FAR_ *, ...);
#endif
int _FAR_ _cdecl putc(int, FILE _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl putchar(int);
int _FAR_ _cdecl puts(const char _FAR_ *);
#endif
int _FAR_ _cdecl putw(int, FILE _FAR_ *);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
void _FAR_ _cdecl rewind(FILE _FAR_ *);
int _FAR_ _cdecl rmtmp(void);
#ifndef _WINDOWS
int _FAR_ _cdecl scanf(const char _FAR_ *, ...);
#endif
void _FAR_ _cdecl setbuf(FILE _FAR_ *, char _FAR_ *);
int _FAR_ _cdecl setvbuf(FILE _FAR_ *, char _FAR_ *, int, size_t);
#ifndef _WINDLL
int _FAR_ _cdecl sprintf(char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl sscanf(const char _FAR_ *, const char _FAR_ *, ...);
#endif
char _FAR_ * _FAR_ _cdecl tempnam(char _FAR_ *, char _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl tmpfile(void);
char _FAR_ * _FAR_ _cdecl tmpnam(char _FAR_ *);
int _FAR_ _cdecl ungetc(int, FILE _FAR_ *);
int _FAR_ _cdecl unlink(const char _FAR_ *);
#ifndef _WINDLL
int _FAR_ _cdecl vfprintf(FILE _FAR_ *, const char _FAR_ *, va_list);
#endif
#ifndef _WINDOWS
int _FAR_ _cdecl vprintf(const char _FAR_ *, va_list);
#endif
#ifndef _WINDLL
int _FAR_ _cdecl vsprintf(char _FAR_ *, const char _FAR_ *, va_list);
#endif
#define _STDIO_DEFINED
#endif

/* macro definitions */

#define feof(_stream)	  ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define fileno(_stream)   ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)	  (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
	: _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
	? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#ifndef _WINDOWS
#define getchar()	  getc(stdin)
#define putchar(_c)	  putc((_c),stdout)
#endif

#ifdef _MT
#undef	getc
#undef	putc
#undef	getchar
#undef	putchar
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memmove(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char _FAR_ * _FAR_ _cdecl strcat(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strchr(const char _FAR_ *, int);
int _FAR_ _cdecl strcmp(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcmpi(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcoll(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl stricmp(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strcpy(char _FAR_ *, const char _FAR_ *);
size_t _FAR_ _cdecl strcspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strdup(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strerror(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strerror(int);
size_t _FAR_ _cdecl strlen(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strlwr(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strncat(char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strncmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strnicmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strncpy(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strnset(char _FAR_ *, int, size_t);
char _FAR_ * _FAR_ _cdecl strpbrk(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strrchr(const char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl strrev(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strset(char _FAR_ *, int);
size_t _FAR_ _cdecl strspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strstr(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strtok(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strupr(char _FAR_ *);
size_t _FAR_ _cdecl strxfrm (char _FAR_ *, const char _FAR_ *,
	size_t);

/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemmove(void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
char _far * _far _cdecl _fstrcat(char _far *, const char _far *);
char _far * _far _cdecl _fstrchr(const char _far *, int);
int _far _cdecl _fstrcmp(const char _far *, const char _far *);
int _far _cdecl _fstricmp(const char _far *, const char _far *);
char _far * _far _cdecl _fstrcpy(char _far *, const char _far *);
size_t _far _cdecl _fstrcspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrdup(const char _far *);
char _near * _far _cdecl _nstrdup(const char _far *);
size_t _far _cdecl _fstrlen(const char _far *);
char _far * _far _cdecl _fstrlwr(char _far *);
char _far * _far _cdecl _fstrncat(char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrncmp(const char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrnicmp(const char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrncpy(char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrnset(char _far *, int, size_t);
char _far * _far _cdecl _fstrpbrk(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrrchr(const char _far *, int);
char _far * _far _cdecl _fstrrev(char _far *);
char _far * _far _cdecl _fstrset(char _far *, int);
size_t _far _cdecl _fstrspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrstr(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrtok(char _far *, const char _far *);
char _far * _far _cdecl _fstrupr(char _far *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\style.h ===
/* Window styles */
#define WS_TILED        0x00000000L
#define WS_ICONICPOPUP  0xc0000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_MINIMIZE     0x20000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_MAXIMIZE     0x01000000L

#define WS_BORDER       0x00800000L
#define WS_CAPTION      0x00c00000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_SIZEBOX      0x00040000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

#define WS_ICONIC       WS_MINIMIZE

/* Class styles */
#define CS_VREDRAW      0x0001
#define CS_HREDRAW      0x0002
#define CS_KEYCVTWINDOW 0x0004
#define CS_DBLCLKS      0x0008
			/* 0x0010 reserved */
#define CS_OWNDC        0x0020
#define CS_CLASSDC      0x0040
#define CS_MENUPOPUP    0x0080
#define CS_NOKEYCVT     0x0100
#define CS_SAVEBITS     0x0800

/* Shorthand for the common cases */
#define WS_TILEDWINDOW   (WS_TILED | WS_CAPTION | WS_SYSMENU | WS_SIZEBOX)
#define WS_POPUPWINDOW   (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW   (WS_CHILD)

/* Edit control styles */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L

/* button control styles */
#define BS_PUSHBUTTON    0L
#define BS_DEFPUSHBUTTON 1L
#define BS_CHECKBOX      2L
#define BS_AUTOCHECKBOX  3L
#define BS_RADIOBUTTON   4L
#define BS_3STATE        5L
#define BS_AUTO3STATE    6L
#define BS_GROUPBOX      7L
#define BS_USERBUTTON    8L
#define BS_AUTORADIOBUTTON 9L
#define BS_PUSHBOX       10L
#define BS_OWNERDRAW	   0x0BL
#define BS_LEFTTEXT      0x20L

/* Dialog Styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT	    0x20L   /* Edit items get Local storage. */
#define DS_SETFONT	    0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME	    0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG	    0x100L  /* WM_ENTERIDLE message will not be sent */

/* listbox style bits */
#define LBS_NOTIFY        0x0001L
#define LBS_SORT          0x0002L
#define LBS_NOREDRAW      0x0004L
#define LBS_MULTIPLESEL   0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#define LBS_STANDARD      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

/* Combo Box styles */
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L

/* scroll bar styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

/* Conventional dialog box and message box command IDs */
#define IDOK         1
#define IDCANCEL     2
#define IDABORT      3
#define IDRETRY      4
#define IDIGNORE     5
#define IDYES        6
#define IDNO         7

/* Static control constants */
#define SS_LEFT       0L
#define SS_CENTER     1L
#define SS_RIGHT      2L
#define SS_ICON       3L
#define SS_BLACKRECT  4L
#define SS_GRAYRECT   5L
#define SS_WHITERECT  6L
#define SS_BLACKFRAME 7L
#define SS_GRAYFRAME  8L
#define SS_WHITEFRAME 9L
#define SS_USERITEM   10L

/* Virtual Keys, Standard Set */

#define VK_LBUTTON  0x01
#define VK_RBUTTON  0x02
#define VK_CANCEL   0x03
#define VK_MBUTTON  0x04    /* NOT contiguous with L & RBUTTON */
#define VK_BACK     0x08
#define VK_TAB      0x09
#define VK_CLEAR    0x0c
#define VK_RETURN   0x0d
#define VK_SHIFT    0x10
#define VK_CONTROL  0x11
#define VK_MENU     0x12
#define VK_PAUSE    0x13
#define VK_CAPITAL  0x14
#define VK_ESCAPE   0x1b
#define VK_SPACE    0x20

#define VK_PRIOR    0x21
#define VK_NEXT     0x22
#define VK_END      0x23
#define VK_HOME     0x24
#define VK_LEFT     0x25
#define VK_UP       0x26
#define VK_RIGHT    0x27
#define VK_DOWN     0x28

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#define VK_SELECT   0x29
#define VK_PRINT    0x2a
#define VK_EXECUTE  0x2b
#define VK_SNAPSHOT 0x2c
#define VK_INSERT   0x2d
#define VK_DELETE   0x2e
#define VK_HELP     0x2f

#define VK_NUMPAD0  0x60
#define VK_NUMPAD1  0x61
#define VK_NUMPAD2  0x62
#define VK_NUMPAD3  0x63
#define VK_NUMPAD4  0x64
#define VK_NUMPAD5  0x65
#define VK_NUMPAD6  0x66
#define VK_NUMPAD7  0x67
#define VK_NUMPAD8  0x68
#define VK_NUMPAD9  0x69
#define VK_MULTIPLY 0x6A
#define VK_ADD      0x6B
#define VK_SEPARATOR 0x6C
#define VK_SUBTRACT 0x6D
#define VK_DECIMAL  0x6E
#define VK_DIVIDE   0x6F

#define VK_F1       0x70
#define VK_F2       0x71
#define VK_F3       0x72
#define VK_F4       0x73
#define VK_F5       0x74
#define VK_F6       0x75
#define VK_F7       0x76
#define VK_F8       0x77
#define VK_F9       0x78
#define VK_F10      0x79
#define VK_F11      0x7a
#define VK_F12      0x7b
#define VK_F13      0x7c
#define VK_F14      0x7d
#define VK_F15      0x7e
#define VK_F16      0x7f
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\testing.h ===
/*---------------------------------------------------------*\
|							    |
|  TESTING.H						    |
|							    |
|  Testing's very own include file!                         |
\*---------------------------------------------------------*/



/* This has all of the defines for the wParam and lParam that go along with
 * the WM_TESTING message 
 */
/* wParam defines - Area
 */
#define   TEST_PRINTMAN 	 0x0001
#define   TEST_GDI		 0x0002


/* lParam defines - Details (in LOWORD) 
 */
#define   TEST_PRINTJOB_START	 0x0001 /* when bits start going to the port */
#define   TEST_PRINTJOB_END	 0x0002 /* when bits stop going to the port  */
#define   TEST_QUEUE_READY	 0x0003 /* when the queue is ready to accept a job */
#define   TEST_QUEUE_EMPTY	 0x0004 /* when the last job is done being sent    */

#define   TEST_START_DOC	 0x0001 /* print job is started 	     */
#define   TEST_END_DOC		 0x0002 /* print job is ended		     */


/* Defines for UserSeeUserDo and GDISeeGDIDo functions 
 */
LONG API UserSeeUserDo(WORD wMsg, WORD wParam, LONG lParam);
LONG API GDISeeGDIDo(WORD wMsg, WORD wParam, LONG lParam);

/* Defines for the various messages one can pass for the SeeDo functions. 
 */
#define SD_LOCALALLOC	0x0001	/* Alloc using flags wParam and lParam bytes.
				 * Returns handle to data.  
				 */
#define SD_LOCALFREE	0x0002  /* Free the memory allocated by handle wParam
				 */
#define SD_LOCALCOMPACT	0x0003  /* Return the number of free bytes available 
				 */
#define SD_GETUSERMENUHEAP 0x0004 /* Return the handle to the far menu heap
                                   * maintained by user. 
				   */
#define SD_GETCLASSHEADPTR 0x0005 /* Return the near pointer to the head of 
				   * the linked list of CLS structures.
				   * Interface: wParam = NULL; lParam = NULL;
				   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\userproc.h ===
/*
 *
 *  UserProc.H
 *
 *  Addition exports from USER.EXE
 */

/*  lParam of WM_DROPOBJECT and WM_QUERYDROPOBJECT points to one of these.
 */
typedef struct _dropstruct
  {
    HWND  hwndSource;
    HWND  hwndSink;
    WORD  wFmt;
    LPARAM dwData;
    POINT ptDrop;
    LPARAM dwControlData;
  } DROPSTRUCT;

#define DOF_EXECUTABLE	0x8001
#define DOF_DOCUMENT	0x8002
#define DOF_DIRECTORY	0x8003
#define DOF_MULTIPLE	0x8004

typedef DROPSTRUCT FAR * LPDROPSTRUCT;

WORD FAR PASCAL GetInternalWindowPos(HWND,LPRECT,LPPOINT);
BOOL FAR PASCAL SetInternalWindowPos(HWND,WORD,LPRECT,LPPOINT);

void FAR PASCAL CalcChildScroll(HWND,WORD);
void FAR PASCAL ScrollChildren(HWND,WORD,WORD,LONG);

LRESULT FAR PASCAL DragObject(HWND hwndParent, HWND hwndFrom, WORD wFmt,
    LPARAM dwData, HANDLE hCursor);
BOOL FAR PASCAL DragDetect(HWND hwnd, POINT pt);

void FAR PASCAL FillWindow(HWND hwndBrush, HWND hwndPaint, HDC hdc,
    HBRUSH hBrush);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the various declarations and definitions
*	for the time routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
	int tm_sec;	/* seconds after the minute - [0,59] */
	int tm_min;	/* minutes after the hour - [0,59] */
	int tm_hour;	/* hours since midnight - [0,23] */
	int tm_mday;	/* day of the month - [1,31] */
	int tm_mon;	/* months since January - [0,11] */
	int tm_year;	/* years since 1900 */
	int tm_wday;	/* days since Sunday - [0,6] */
	int tm_yday;	/* days since January 1 - [0,365] */
	int tm_isdst;	/* daylight savings time flag */
	};
#define _TM_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC	1000

/* clock ticks macro - archaic version */

#define CLK_TCK 	1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

#ifdef _DLL
extern int _FAR_ _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _FAR_ _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char _FAR_ * _FAR_ _cdecl tzname[2]; /* standard/daylight savings time zone names */
#else
extern int _near _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _near _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char * _near _cdecl tzname[2]; /* standard/daylight savings time zone names */
#endif


/* function prototypes */

#ifdef _MT
double _FAR_ _pascal difftime(time_t, time_t);
#else
double _FAR_ _cdecl difftime(time_t, time_t);
#endif

char _FAR_ * _FAR_ _cdecl asctime(const struct tm _FAR_ *);
char _FAR_ * _FAR_ _cdecl ctime(const time_t _FAR_ *);
#ifndef _WINDLL
clock_t _FAR_ _cdecl clock(void);
#endif
struct tm _FAR_ * _FAR_ _cdecl gmtime(const time_t _FAR_ *);
struct tm _FAR_ * _FAR_ _cdecl localtime(const time_t _FAR_ *);
time_t _FAR_ _cdecl mktime(struct tm _FAR_ *);
#ifndef _WINDLL
size_t _FAR_ _cdecl strftime(char _FAR_ *, size_t, const char _FAR_ *,
	const struct tm _FAR_ *);
#endif
char _FAR_ * _FAR_ _cdecl _strdate(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strtime(char _FAR_ *);
time_t _FAR_ _cdecl time(time_t _FAR_ *);
void _FAR_ _cdecl tzset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\w32sys.h ===
/*************************************************************************\
* w32sys.h
*
* Win32S i/f
*
* 11-18-91    AviN   Created
\*************************************************************************/

#ifndef APIENTRY
#define APIENTRY _far _pascal _loadds
#endif

HANDLE APIENTRY GetPEResourceTable(WORD hFile);
HANDLE APIENTRY LoadPEResource(HANDLE hFile, LPSTR lpResTable, LPSTR lpId, LPSTR lpType);
WORD   APIENTRY GetW32SysVersion(VOID);
BOOL   APIENTRY GetPEExeInfo(LPSTR lpFileName, LPSTR lpBuff, WORD cbBuff, WORD iInfo);
WORD   APIENTRY ExecPE(LPSTR  lpPath, LPSTR lpCmd, WORD nCmdShow);
BOOL   APIENTRY IsPEFormat(LPSTR lpFileName, WORD hFile);

/*
 * Constants for GetPEExeInfo iInfo parameter
 */
#define GPEI_MODNAME     1
#define GPEI_DESCRIPTION 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\wfwnet.h ===
/*
 *      Windows/Network Interface
 *      Copyright (C) Microsoft 1989-1992
 *
 *      Standard WINNET Driver Header File, spec version 3.10
 *                                               rev. 3.10.05 ;Internal
 */


#ifndef _INC_WFWNET
#define _INC_WFWNET	/* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */


#define CHAR	char		
#define SHORT	short		
#define LONG	long		

typedef WORD far * 	LPWORD;

typedef unsigned char UCHAR;	
typedef unsigned short USHORT;	
typedef unsigned long ULONG;

typedef unsigned short SHANDLE;
typedef void far      *LHANDLE;

typedef unsigned char far  *PSZ;
typedef unsigned char near *NPSZ;

typedef unsigned char far  *PCH;
typedef unsigned char near *NPCH;

typedef UCHAR  FAR *PUCHAR;
typedef USHORT FAR *PUSHORT;
typedef ULONG  FAR *PULONG;


#ifndef DRIVDATA
/* structure for Device Driver data */

typedef struct _DRIVDATA {	/* driv */
	LONG	cb;
	LONG	lVersion;
	CHAR	szDeviceName[32];
	CHAR	abGeneralData[1];
} DRIVDATA;
typedef DRIVDATA far *PDRIVDATA;
#endif

#ifndef API
#define API WINAPI
#endif

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WFWNET */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *									    *
 *	This file is only modified by the official builder to update the    *
 *	VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h> 
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION 		    "3.1"
#define VER_PRODUCTVERSION_STR      "3.10\0"
#define VER_PRODUCTVERSION          3,10,0,103

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\wife.h ===
/****************************************************************************\
*
* WIFE.H : East Asia Windows Intelligent Font Environment definitions
*
******************************************************************************
*
* History:
* 21-Oct-1991	bent
*		initial merge of East Asia 3.0 versions
*		Should be updated to resolve local inconsistencies.
*
* Copyright (c) 1990  Microsoft Corporation
*
* Brief instruction
* -----------------
*
*   This header file is a common single header for WIFE drivers.										    *
*   If you are a developer of FontDriver, please write coding as follow 									    *
*
*   #define WIFE_CREATE_FONTDRIVER														      *
*   #include <wife.h>																      *
*
*   If you are a developer of DeviceDriver which are display or printer
*   drivers, please write coding as follow.														      *
*
*   #define WIFE_CREATE_DEVICEDRIVER														      *
*   #include <wife.h>																      *
*
*   If you don't define both of symbols, only common defenitions are
*   available.
*
*   Aug.17,1990 Akira Kawamata [AkiraK] 									     *
*
\****************************************************************************/

/****** OS/2-like common data type definitions ******************************/

#ifndef WIFEH_NODATATYPES
typedef unsigned short int USHORT;
typedef short int          SHORT;
typedef unsigned long      ULONG;
typedef LONG FAR *         LPLONG;
typedef LONG NEAR *        NPLONG;
typedef ULONG FAR *        LPULONG;
typedef ULONG NEAR *       NPULONG;
typedef SHORT FAR *        LPSHORT;
typedef SHORT NEAR *       NPSHORT;
typedef USHORT FAR *       LPUSHORT;
typedef USHORT NEAR *      NPUSHORT;
typedef char               CHAR;
typedef unsigned char      UCHAR;

typedef VOID NEAR *        NPVOID;

/* FIXED Number */
typedef struct {
	USHORT Fraction;
	SHORT Integer;
} FIXED;
#endif //WIFEH_NODATATYPES

/****** Graphics handling support definitions *******************************/

#ifndef WIFEH_NOGRAPHSUPPORT
/* rotation angle by 90degree */
typedef enum {
	ANGLE000 = 0,
	ANGLE090 = 1,
	ANGLE180 = 2,
	ANGLE270 = 3
} QUOTER_ANGLE;
#define FixedToQuoterAngle(f) ((f.Integer/90)%4)
#define RotationToQuoterAngle(r) ((r/900)%4)

typedef DWORD PACKEDPOINT;
typedef DWORD PACKEDLOGICALPOINT;
typedef DWORD PACKEDPHYSICALPOINT;
typedef struct {
	short x,y;
} XYPOINT;
typedef union {
	PACKEDPOINT packed;
	XYPOINT point;
} UNIONPOINT, NEAR * NPUNIONPOINT, FAR * LPUNIONPOINT;

#define PartOfX(xy)	((SHORT)(xy))
#define PartOfY(xy)	((SHORT)(((DWORD)(xy) >> 16) & 0xFFFF))
#define MAKELONG_LO_HI MAKELONG
#define PackXY(x,y)	((DWORD)MAKELONG_LO_HI((WORD)x,(WORD)y))
#endif //WIFEH_NOGRAPHSUPPORT

/****** UBCS : Unified Byte Character Set, data types defenition  **********/

#ifndef WIFEH_NOUBCS
typedef	USHORT UBCHAR;
typedef	UBCHAR NEAR * NPUBCHAR;
typedef	UBCHAR FAR * LPUBCHAR;

#define UBEOS (0)		/* End Of String */
#define UBNEWLINE (0x0a0d)	/* New Line (CR/LF) */

#define IsSbcsUBChar(uc) ((uc & 0xff00) == 0x2000)
#define IsDbcsUBChar(uc) ((uc & 0xff00) != 0x2000)
#endif //WIFEH_NOUBCS

/****** Utility macros *****************************************************/

#ifndef WIFEH_NOUTILITYMACROS
/* return type of GlobalLock is LPSTR, but it's to be LPVOID */
#define AnyGlobalLock(h) ((LPVOID)GlobalLock(h))
#define AnyLocalLock(h) ((NPVOID)LocalLock(h))
#define TypedLocalLock(h,t) ((t NEAR *)LocalLock(h))
#define TypedGlobalLock(h,t) ((t FAR *)GlobalLock(h))

/* utility macro which is not included windows.h */
#define MAKEWORD(l,h) ((WORD)((BYTE)l+(((BYTE)h) << 8)))
#endif //WIFEH_NOUTILITYMACROS

/****** GDIDEFS.H support definitions **************************************/

#ifdef WIFE_ENABLE_GDIDEFS_SUPPORT
typedef FONTINFO FAR * LPFONTINFO;
typedef DRAWMODE FAR * LPDRAWMODE;
typedef TEXTXFORM FAR * LPTEXTXFORM;
#endif //WIFE_ENABLE_GDIDEFS_SUPPORT

/****** Character set definitions ******************************************/

#ifndef WIFEH_NOCHARSET
typedef enum {
	CHARSET_ANSI = 0,
	CHARSET_SYMBOL = 2,
	CHARSET_SHIFTJIS = 128,
	CHARSET_KOREA = 129,
	CHARSET_CHINESEBIG5 = 136,
	CHARSET_OEM = 255
} CHAR_SET;
#endif //WIFEH_NOCHARSET


/***************************************************************************/
/****** Control function support definitions  ******************************/

#ifndef WIFEH_NOCONTROL

/******************************************/
/*      FONT DRIVER MEDIA DESCRIPTER      */
/******************************************/
#ifndef WIFEWH_NOMEDIA
/* FDMEDIA enumration type */
typedef enum {
	FDMEDIA_ON_FILE = 1,
	FDMEDIA_ON_DRIVER = 2,
	FDMEDIA_ON_REMOVEABLE_HARDWARE = 4,
	FDMEDIA_ON_FIXED_HARDWARE = 8,
	FDMEDIA_UNDEFINED = 0x4000,
	FDMEDIA_ANY_MEDIA = 0x7fff
} FDMEDIA;
#endif


/******************************************/
/*    MINOR CHARACTER SETS DEFENITION     */
/******************************************/
#ifndef WIFEH_NOMINORCHARSET_IN_JAPAN

/* general default minor character set */
#define FD_MINOR_CHARSET_DEFAULT 1

/* Minor Character Set in Japan */
#define	FD_MINOR_CHARSET_NEW_JIS 1	/* new JIS */
#define	FD_MINOR_CHARSET_OLD_JIS 2	/* old JIS */
#define	FD_MINOR_CHARSET_IBM_JIS 4	/* IBM JIS */
#define	FD_MINOR_CHARSET_NEC_JIS 8	/* NEC JIS */

#endif

/******************************************/
/*        CODE AREA STRUCTURE             */
/******************************************/
#ifndef WIFEH_NOCODEAREA

typedef struct {
	UBCHAR CodeFrom;
	UBCHAR CodeTo;
} CODEAREA, NEAR * NPCODEAREA, FAR * LPCODEAREA;

#endif

/******************************************/
/*    SPECIAL ESCAPE FUNCTION ORDERS      */
/******************************************/

/* subfunction orders in WIFE */
#define FD_CONTROL_RESERVED		(0xa20)
#define FD_CONTROL_RESERVED_LIMIT	(FD_CONTROL_RESERVED+0x3f)

/* standard subfunctions */
#define FD_CONTROL_QUERY_ESC_SUPPORT	(FD_CONTROL_RESERVED+0)
#define FD_CONTROL_SUPPORT_CODES	(FD_CONTROL_RESERVED+1)
#define FD_CONTROL_NUMBER_OF_ATTRIBUTE	(FD_CONTROL_RESERVED+2)
#define FD_CONTROL_NAME_OF_ATTRIBUTE	(FD_CONTROL_RESERVED+3)
#define FD_CONTROL_SET_ATTRIBUTE	(FD_CONTROL_RESERVED+4)
#define FD_CONTROL_GET_ATTRIBUTE	(FD_CONTROL_RESERVED+5)
#define FD_CONTROL_SET_MINOR_CHARSET	(FD_CONTROL_RESERVED+6)
#define FD_CONTROL_GET_MINOR_CHARSET	(FD_CONTROL_RESERVED+7)
#define FD_CONTROL_GET_FONT_DRIVER_NAME	(FD_CONTROL_RESERVED+8)
#define FD_CONTROL_GET_FONT_PACK_NAME	(FD_CONTROL_RESERVED+9)
#define FD_CONTROL_GET_MEDIA		(FD_CONTROL_RESERVED+10)
#define FD_CONTROL_GET_DBCS_STRING_KERN	(FD_CONTROL_RESERVED+11)

/* EUDC related subfunctions */
#define FD_CONTROL_LEVEL2_EUDC_INFO	(FD_CONTROL_RESERVED+12)

/* private interface subfunctions */
#define FD_CONTROL_USER			(FD_CONTROL_RESERVED+0x10)
#define FD_CONTROL_USER_LIMIT		(FD_CONTROL_RESERVED+0x1f)

/* Chinese related functions */
#define FD_CONTROL_GET_USERFONT_TECH	(FD_CONTROL_RESERVED+0x20)
#define FD_CONTROL_SET_USERFONT 	(FD_CONTROL_RESERVED+0x21)
#define FD_CONTROL_SETUP_DIALOG 	(FD_CONTROL_RESERVED+0x22)
#define FD_CONTROL_SET_DEFAULT_CHAR	(FD_CONTROL_RESERVED+0x23)

#ifdef WIFE_ENABLE_EUDC_SUPPORT

typedef struct {
	ULONG	cb;		/* length of this structure */
	BOOL	bForceFixedPitch;	/* force fixed pitch */
	BOOL	bVerticalFont;	/* vertical font flag */
	FIXED	fxCharRot;	/* character rotation */
	FIXED	fxInlineDir;	/* inline rotation */
	USHORT	usLimitWidth;	/* maximum width of cachable */
	SHORT	sFixedASpace;	/* font width when bForceFixedPitch is TRUE */
	USHORT	usFixedBSpace;	/* font width when bForceFixedPitch is TRUE */
	SHORT	sFixedCSpace;	/* font width when bForceFixedPitch is TRUE */
} EUDC_CONTEXT, NEAR * NPEUDC_CONTEXT, FAR * LPEUDC_CONTEXT;

#endif

#endif


#ifndef WIFEH_NOFDCOMMONDEFENITION
typedef LONG HFF;
typedef LONG HFC;
typedef HANDLE HFD;
typedef HANDLE HFB;

#define FACESIZE 32
#define GLYPHNAMESIZE 16

#define WIFEERR_FACENAME_NOT_FOUND        23004L
#define WIFEERR_FD_ALREADY_INSTALLED      23005L
#define WIFEERR_INVALID_CONTEXTINFO       23006L
#define WIFEERR_NOT_A_FONT_FILE           23007L
#define WIFEERR_INVALID_FONT_SELECTION    23008L
#define WIFEERR_INVALID_FORMAT            23009L
#define WIFEERR_BUSY_HFC                  230010L
#define WIFEERR_INVALID_HFC               230011L
#define WIFEERR_INVALID_INDEX             230012L
#define WIFEERR_INVALID_QUERY_TYPE        230013L
#define WIFEERR_CONTEXT_NOT_SET           230014L

#define FD_QUERY_ABC_WIDTHS     2L
#define FD_QUERY_KERNINGPAIRS   3L

#define FD_QUERY_CHARIMAGE      1L
#define FD_QUERY_OUTLINE        2L
#define FD_QUERY_BITMAPMETRICS  4L

typedef UBCHAR GLYPH; /* gi */
typedef LPUBCHAR LPGLYPH; /* lpgi */

typedef struct _POINTFX { /* ptfx, npptfx, lpptfx */
	FIXED x;
	FIXED y;
} POINTFX, NEAR * NPPOINTFX, FAR * LPPOINTFX;

typedef struct _ABC_TRIPLETS { /* abc, npabc, lpabc */
	SHORT  sA;
	USHORT usB;
	SHORT  sC;
} ABC_TRIPLETS, NEAR * NPABC_TRIPLETS, FAR * LPABC_TRIPLETS;

typedef struct _SIZEL { /* sizl */
	ULONG cx; // Width.
	ULONG cy; // Height.
} SIZEL;

typedef struct _BITMAPMETRICS { /* bmm, npbmm, lpbmm */
	SIZEL     sizlExtent;
	POINTFX   pfxOrigin;    /* Return character origin. */
	POINTFX   pfxCharInc;   /* Return the device advance width */
} BITMAPMETRICS, NEAR * NPBITMAPMETRICS, FAR * LPBITMAPMETRICS;

typedef struct _MAT2 { /* mat */
	FIXED eM11;
	FIXED eM12;
	FIXED eM21;
	FIXED eM22;
} MAT2;

typedef struct _FD_KERNINGPAIRS  { /* krnpr, npkrnpr, lpkrnpr */
	GLYPH     giFirst;
	GLYPH     giSecond;
	LONG      eKerningAmount;
} FD_KERNINGPAIRS, NEAR * NPFD_KERNINGPAIRS, FAR * LPFD_KERNINGPAIRS;


typedef struct _CONTEXTINFO  { /* ci */
	ULONG     cb;        /* Length in bytes of this structure. */
	ULONG     fl;        /* Flags. */
	SIZEL     sizlPPM;    /* Device resolution in pels/meter. */
	POINTFX   pfxSpot;   /* Spot size in pels. */
	MAT2      matXform;  /* Notional to Device transform. */
} CONTEXTINFO, NEAR * NPCONTEXTINFO, FAR * LPCONTEXTINFO;


typedef struct _CHARATTR  { /* chattr */
	ULONG     cb;
	ULONG     iQuery;   /* Query type. */
	GLYPH     gi;       /* Glyph index in font. */
	LPBYTE    lpBuffer;  /* Bitmap buffer. */
	ULONG     cbLen;    /* Size of buffer in bytes. */
} CHARATTR, NEAR * NPCHARATTR, FAR * LPCHARATTR;


/* bit-constants for fsType in IFIMETRICS  */

#define IFIMETRICS_FIXED       0x0001   /* Fixed pitch */
#define IFIMETRICS_LICENSED    0x0002   /* dummy defenition */
#define IFIMETRICS_SPARSE      0x0004   /* Incomplete font */
#define IFIMETRICS_SCALEABLE   0x8000   /* scalable font */

/* bit-constant for fsDefn in IFIMETRICS   */

#define IFIMETRICS_OUTLINE     0x0001   /* dummy definition */
					/* 1 - Outline. 0 - Raster */

/* bit-constant for fsSelection in IFIMETRICS */

#define IFIMETRICS_ITALIC      0x8000  /*Italic */
#define IFIMETRICS_UNDERSCORE  0x4000  /*Underscored */
#define IFIMETRICS_OVERSTRUCK  0x2000  /*Overstruck */

/* bit-constant for fsSelection in IFIMETRICS valid for bitmap fonts */

#define IFIMETRICS_NEGATIVE    0x1000   /*Negative image */
#define IFIMETRICS_HOLLOW      0x0800   /*Outline (hollow) */


typedef struct _IFIMETRICS {   /* ifim */
                                                                    /* UNITS */
  UCHAR   szFamilyname[FACESIZE];   /*Font Family Name, e.g. Roman */
  UCHAR   szFacename[FACESIZE];     /*Face name, e.g. Tms Rmn Bold Italic */
  UCHAR   szGlyphlistName[GLYPHNAMESIZE]; /*e.g. PM316, Latin-2, Greek */
  USHORT  idRegistry;          /*Dummy                                     I */
  SHORT   sCapEmHeight;        /*Height of uppercase M                     N */
  SHORT   sXHeight;            /*Nominal height of lowercase               N */
  SHORT   sMaxAscender;        /*Maximum height above baseline of any char N */
  SHORT   sMaxDescender;       /*Maximum depth below baseline of any char  N */
  SHORT   sLowerCaseAscent;    /*Maximum height above baseline of any a-z  N */
  SHORT   sLowerCaseDescent;   /*Maximum depth below basiline of any a-z   N */
  SHORT   sInternalLeading;    /*White space within character              N */
  SHORT   sExternalLeading;    /*White space between lines                 N */
  SHORT   sAveCharWidth;       /*Weighted average character width          N */
  SHORT   sMaxCharInc;         /*Maximum character increment               N */
  SHORT   sEmInc;              /*Increment for Capitals (typically 'M')    N */
  SHORT   sMaxBaselineExt;     /*Height of character cell                  N */
  FIXED   fxCharSlope;         /*Slope angle, degrees, clockwise           D */
  FIXED   fxInlineDir;         /*Drawing direction, degrees clockwise      D */
  FIXED   fxCharRot;           /*Glyph rotation in cell, degrees clockwise D */
  USHORT  usWeightClass;       /*Character weight, 1-9 (1=ultra-light)     I */
  USHORT  usWidthClass;        /*Character width, 1-9 (1=ultra condensed)  I */
  SHORT   sEmSquareSize;       /*Em Square size, x-direction               N */
  GLYPH   giFirstChar;         /*Number of first glyph in font             I */
  GLYPH   giLastChar;          /*Number of last glyph in font              I */
  GLYPH   giDefaultChar;       /*Glyph used if requested glyph invalid     I */
  GLYPH   giBreakChar;         /*Space glyph                               I */
  ULONG   aulPanose [1];       /*Panose Number */
  USHORT  usNominalPointSize;  /*Point size for which font was designed    N */
  USHORT  usMinimumPointSize;  /*Minimum point size scaling for font	   N */
  USHORT  usMaximumPointSize;  /*Maximum point size scaling for font	   N */
  USHORT  fsType;              /*Type indicators  (see #defines)           B */
  USHORT  fsDefn;              /*Font definition data (see #defines)       B */
  USHORT  fsSelection;         /*Font selection flags (see #defines)       B */
  USHORT  fsCapabilities;      /*Font capabilities must be 0               B */
  SHORT   sSubscriptXSize;     /*Size in x-direction of subscript          N */
  SHORT   sSubscriptYSize;     /*Size in y-direction of subscript          N */
  SHORT   sSubscriptXOffset;   /*Offset in x-direction of subscript        N */
  SHORT   sSubscriptYOffset;   /*Offset in y-direction of subscript        N */
  SHORT   sSuperscriptXSize;   /*Size in x-direction of superscript        N */
  SHORT   sSuperscriptYSize;   /*Size in y-direction of superscript        N */
  SHORT   sSuperscriptXOffset; /*Offset in x-direction of superscript      N */
  SHORT   sSuperscriptYOffset; /*Offset in y-direction of superscript      N */
  SHORT   sUnderscoreSize;     /*Underscore size                           N */
  SHORT   sUnderscorePosition; /*Underscore position                       N */
  SHORT   sStrikeoutSize;      /*Strikeout size                            N */
  SHORT   sStrikeoutPosition;  /*Strikeout position                        N */
  SHORT   cKerningPairs;       /*Number of kerning pairs in pair table     I */
  ULONG   ulFontClass;         /*IBM font classification                   B */
} IFIMETRICS, NEAR * NPIFIMETRICS, FAR * LPIFIMETRICS;

#ifdef ENABLE_CONTROL_TAG

/* Tag structure for Fd(i)Control */
typedef struct {
	USHORT SubFunction;
	LPDEVICE lpDevice;
	LPFONTINFO lpFontStructure;
	LPTEXTXFORM lpXform;
	LPVOID lpInData;
} CONTROLTAG, FAR * LPCONTROLTAG;
#else
typedef struct {
	USHORT SubFunction;
	LPVOID lpDevice;
	LPVOID lpFontStructure;
	LPVOID lpXform;
	LPVOID lpInData;
} CONTROLTAG, FAR * LPCONTROLTAG;
#endif

#endif


/****************************************/
/* Attribute bits for FdOpenFontContext */
/****************************************/
#ifndef WIFEH_NOWIFEMAN_EUDCFONTCONTEXT
#define OFC_EUDC_CONTEXT (0x80000000L)
#endif


#ifdef WIFE_CREATE_FONTDRIVER

/***********************************************/
/* PROTO-TYPE FOR EACH FUNCTION in FONT DRIVER */
/***********************************************/

LONG FAR PASCAL FdClaimFontFile( LPSTR lpszFileName );

LONG FAR PASCAL FdConvertFontFile( 
	LPSTR lpszSrcFileName, 
	LPSTR lpszDestDirName, 
	LPSTR lpszResultPackName 
);
HFF FAR PASCAL FdLoadFontFile( LPSTR lpszPackName );

LONG FAR PASCAL FdUnloadFontFile( HFF hFF );

LONG FAR PASCAL FdQueryFaces( 
	HFF hFF,
	LPIFIMETRICS lpIfiMetrics,
	ULONG cMetricLen,
	ULONG cFontCount,
	ULONG cStart
);

HFC FAR PASCAL FdOpenFontContext( HFF hFF, ULONG ulFont ); 

LONG FAR PASCAL FdSetFontContext(
	HFC hFC,
	LPCONTEXTINFO lpContextInfo
);

LONG FAR PASCAL FdCloseFontContext( HFC hFC ); 

LONG FAR PASCAL FdQueryFaceAttr(
	HFC       hFC,
	ULONG     iQuery,
	LPVOID    lpBuffer,
	ULONG     cb,
	LPVOID    lpIndex,
	SHORT     Start
);

LONG FAR PASCAL FdQueryCharAttr(
	HFC        hFC,
	LPCHARATTR lpCharAttr,
	LPBITMAPMETRICS lpbmm
);

SHORT FAR PASCAL FdControl(
	HFC hFC,
	LPCONTROLTAG lpControlTag,
	LPVOID lpOutData
);


/******************************************/
/*       FAR PTR TO EACH FUNCTION         */
/******************************************/
typedef LONG (FAR PASCAL * LPFDCLF)( LPSTR lpszFileName );

typedef LONG (FAR PASCAL * LPFDCFF)(
	LPSTR lpszSrcFileName, 
	LPSTR lpszDestDirName, 
	LPSTR lpszResultPackName 
);

typedef HFF (FAR PASCAL * LPFDLFF)( LPSTR lpszPackName );

typedef LONG (FAR PASCAL * LPFDQF)(
	HFF hFF,
	LPIFIMETRICS lpIfiMetrics,
	ULONG cMetricLen,
	ULONG cFontCount,
	ULONG cStart
);

typedef LONG (FAR PASCAL * LPFDUFF)( HFF hFF );

typedef HFC (FAR PASCAL * LPFDOFC)( HFF hFF, ULONG ulFont ); 

typedef LONG (FAR PASCAL * LPFDSFC)(
	HFC hFC,
	LPCONTEXTINFO lpContextInfo
);

typedef LONG (FAR PASCAL * LPFDCFC)( HFC hFC ); 

typedef LONG (FAR PASCAL * LPFDQFA)(
	HFC       hFC,
	ULONG     iQuery,
	LPVOID    lpBuffer,
	ULONG     cb,
	LPVOID    lpIndex,
	SHORT     Start
);

typedef LONG (FAR PASCAL * LPFDQCA)(
	HFC        hFC,
	LPCHARATTR lpCharAttr,
	LPBITMAPMETRICS lpbmm
);

typedef SHORT (FAR PASCAL * LPFDCTL)(
	HFC hFC,
	LPCONTROLTAG lpControlTag,
	LPVOID lpOutData
);

typedef struct _FDHEADER { /* fdhdr */
        ULONG   cbLength;            /* Length of FDHEADER */
        UCHAR   strId[16];           /* String 'WIFE FONT DRIVER' */
        UCHAR   szTechnology[40];    /* Identifier of Font Driver technology */
        ULONG   ulVersion;           /* IFI version number (0x0100) */
        ULONG   ufDeviceCaps;        /* Capabilities of device */
        NPVOID	npfddisp;
        SHORT	dummy1;
} FDHEADER, NEAR * NPFDHEADER, FAR * LPFDHEADER;

#endif

#ifdef WIFE_CREATE_DEVICEDRIVER

/***********************************************/
/* PROTO-TYPE FOR EACH FUNCTION in WIFEMAN.DLL */
/***********************************************/

/***********************************************/
/*         Module Install Manager              */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_MIM

typedef BOOL (FAR PASCAL * LPCBMEAD)
		( LPSTR lpszFoundFileName, LPSTR lpszDescriptionName );
BOOL FAR PASCAL MimEnumAvailableDrivers
			( LPSTR lpszSeachFilePath, LPCBMEAD lpfCallBack );

typedef BOOL (FAR PASCAL * LPCBMEAP)
		( HFD hFD, LPSTR lpszPackName );
BOOL FAR PASCAL MimEnumAvailablePacks
	( HFD hFD, LPSTR lpszPackName, LPCBMEAP lpfCallBack );

HFD FAR PASCAL MimAddFontDriver( LPSTR lpszFileName );

HFF FAR PASCAL MimAddFontPack( HFD hFD, LPSTR lpszPackName );

BOOL FAR PASCAL MimRemoveFontDriver( HFD hFD );

BOOL FAR PASCAL MimRemoveFontPack( HFD hFD, HFF hFontPack );

HFD FAR PASCAL MimEnumFontDrivers( HFD hLastDriver );

HFF FAR PASCAL MimEnumFontPacks( HFD hFD, HFF hLastPack );

HFC FAR PASCAL MimOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont );

LONG FAR PASCAL MimCloseFontContext( HFD hFD, HFF hFF, HFC hFC );

typedef enum {
	MIMGETINFO_FD_DESCRIPTION = 0,
	MIMGETINFO_FF_DESCRIPTION = 1,
	MIMGETINFO_FD_FILENAME = 2,
	MIMGETINFO_FF_FILENAME = 3,
	MIMGETINFO_FD_USAGE = 4,
	MIMGETINFO_FF_USAGE = 5,
	MIMGETINFO_FD_INSTALL_COUNT = 6,
	MIMGETINFO_FF_INSTALL_COUNT = 7
} MIMGETINFO_ORDER;

SHORT FAR PASCAL MimGetInformations( 
	MIMGETINFO_ORDER order,
	HFD hFD,
	HFF hFF,
	LPVOID AnswerBuffer,
	USHORT SizeOfBuffer
);

#endif

/***********************************************/
/*         Font Driver Interface               */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_FDI

LONG FAR PASCAL  FdiClaimFontFile( HFD hFD, LPSTR lpszFileName );

LONG FAR PASCAL FdiConvertFontFile( 
	HFD hFD,
	LPSTR lpszSrcFileName, 
	LPSTR lpszDestDirName, 
	LPSTR lpszResultPackName 
);

HFF FAR PASCAL FdiLoadFontFile( HFD hFD, LPSTR lpszPackName );

LONG FAR PASCAL FdiUnloadFontFile( HFD hFD, HFF hFF );

LONG FAR PASCAL FdiQueryFaces( 
	HFD hFD, 
	HFF hFF,            // Font File handle 
	LPIFIMETRICS lpIfiMetrics,   // Buffer for the metrics 
	ULONG cMetricLen,    // Length of the metrics structure 
	ULONG cFontCount,    // # of fonts wanted. 
	ULONG cStart         // index of the font to start with 
);

HFC FAR PASCAL FdiOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont ); 

LONG FAR PASCAL FdiSetFontContext(
	HFD hFD, 
	HFC hFC,
	LPCONTEXTINFO lpContextInfo
);

LONG FAR PASCAL FdiCloseFontContext( HFD hFD, HFC hFC ); 

LONG FAR PASCAL FdiQueryFaceAttr(
	HFD hFD, 
	HFC       hFC,
	ULONG     iQuery,
	LPVOID    lpBuffer,
	ULONG     cb,
	LPVOID    lpIndex,
	SHORT     Start
);

LONG FAR PASCAL FdiQueryCharAttr(
	HFD hFD, 
	HFC        hFC,
	LPCHARATTR lpCharAttr,
	LPBITMAPMETRICS lpbmm
);

SHORT FAR PASCAL FdiControl(
	HFD hFD, 
	HFC hFC,
	LPCONTROLTAG lpControlTag,
	LPVOID lpOutData
);

#endif

/***********************************************/
/*         Font Cacheing Manager               */
/***********************************************/
#ifdef WIFE_ENABLE_FCM

#define FCM_WIFE_CHARACTER 1
#define FCM_CLIP_OUT 2
#define FCM_LEFT_CLIP 0x0100
#define FCM_RIGHT_CLIP 0x0200
#define FCM_TOP_CLIP 0x0400
#define FCM_BOTTOM_CLIP 0x0800

typedef struct {
	USHORT	SizeOfStruct;	/* size of structire */
	WORD	WifeFlag;	/* FCM processing flags */
	UBCHAR	ubCode;		/* character code */
	LPSTR	lpCacheBuffer; /* long ptr to cache bitmap */
	SHORT	nBitWidth;	/* x size of character image */
	SHORT	nBitHeight;	/* y size of character image */
	SHORT	nByteWidth;	/* byte width size in alloctaed buffer */
	USHORT	InternalIndex;	/* RESERVED FOR SYSTEM USE */
} FCM_CHARACTERISTIC, NEAR *NP_FCM_CHARACTERISTIC, FAR *LP_FCM_CHARACTERISTIC;

typedef struct {
	USHORT	SizeOfStruct;	/* size of structire */
	WORD	WifeFlag;	/* FCM processing flags */
	UBCHAR	ubCode;		/* character code */
	LPSTR	lpCacheBuffer; /* long ptr to cache bitmap */
	SHORT	nBitWidth;	/* x size of character image */
	SHORT	nBitHeight;	/* y size of character image */
	SHORT	nByteWidth;	/* byte width size in alloctaed buffer */
	USHORT	InternalIndex;	/* RESERVED FOR SYSTEM USE */

	SHORT	xPosOnDst;	/* x position on dst device */
	SHORT	yPosOnDst;	/* y position on dst device */

} FCM_EXTCHARACTERISTIC, 
	NEAR * NP_FCM_EXTCHARACTERISTIC, FAR * LP_FCM_EXTCHARACTERISTIC;


HFB FAR PASCAL FcmCreateCacheBuffer(
	HFD hFD,
	HFF hFF,
	ULONG ulFont,
	LPTEXTXFORM lpXform,
	USHORT usMinorCharSet,
	USHORT usAttribute
);

BOOL FAR PASCAL FcmDeleteCacheBuffer( HFB hFontBuffer );

SHORT FAR PASCAL FcmRequestImages( 
	HFB hFontBuffer,
	LP_FCM_CHARACTERISTIC AnswerBuffer,
	short length
);

BOOL FAR PASCAL FcmReleaseImages( 
	HFB hFontBuffer,
	LP_FCM_CHARACTERISTIC AnswerBuffer,
	short length
);

HFB FAR PASCAL FcmRequestDefaultFB( 
	LPFONTINFO lpFont, 
	LPTEXTXFORM lpTextXform 
);

BOOL FAR PASCAL FcmReleaseDefaultFB( HFB hFB );

#define FCMCALC_BIGFONT 1
#define FCMCALC_ROUGHCLIPINFO 2
#define FCMCALC_DETAILCLIPINFO 4

DWORD FAR PASCAL FcmCalculateTextExtent(
	HFB         hFB,
	LPSTR       lpString,
	short       count,
	LPFONTINFO  lpFont,
	LPDRAWMODE  lpDrawMode,
	LPTEXTXFORM lpXform,
	LPSHORT     lpCharWidths,
	USHORT      usMode
);

SHORT FAR PASCAL FcmCalculateOutputPositions(
	HFB             hFB,
	LP_FCM_EXTCHARACTERISTIC lpFcmCharacteristics,
	SHORT		nArrayLength,
	LPSHORT		lpx,
	LPSHORT		lpy,
	LPRECT		lpClipRect,
	LPSTR		FAR * lplpString,
	LPSHORT		lpcount,
	LPFONTINFO	lpFont,
	LPDRAWMODE	lpDrawMode,
	LPTEXTXFORM     lpXform,
	LPSHORT         FAR * lplpCharWidths,
	USHORT          usMode
);


SHORT FAR PASCAL FcmCleanUp( VOID );

HFB FAR PASCAL FcmEnumFontBuffers( HFB hLastBuffer );

HFC FAR PASCAL FcmGetFontContext( HFB hFB );

SHORT FAR PASCAL FcmCalcByteWidth( SHORT nBitWidth );

SHORT FAR PASCAL FcmForceCacheIn( HFB hFB, LPUBCHAR lpubStr );

BOOL FAR PASCAL FcmValidateFC( HFB hFB );

BOOL FAR PASCAL FcmUnvalidateFC( HFB hFB );

LONG FAR PASCAL FcmQueryFaceAttr(
	HFB         hFB,
	ULONG       iQuery,
	LPABC_TRIPLETS  lpBuffer,
	ULONG       cb,
	LPUBCHAR    lpIndex,
	UBCHAR      Start
);

#ifdef WIFE_ENABLE_FCM_CONTROL

SHORT FAR PASCAL FcmIsProcessableDeviceControl( 
	HFB hFB,
	SHORT nFunction,
	GAIJIINFO FAR * lpGI
);

SHORT FAR PASCAL FcmProcessDeviceControl( 
	HFB hFB,
	SHORT nFunction,
	GAIJIINFO FAR * lpGI,
	LPVOID lpOutData
);

#endif

USHORT FAR PASCAL FcmGetEUDCLeadByteRange( HFB hFB );

HFB FAR PASCAL FcmGetEUDCFB( HFB hFB );

USHORT FAR PASCAL FcmGetCharWidth(
	HFB         hFB,
	LPUSHORT    lpBuffer,
	USHORT      wFirstChar,
	USHORT      wLastChar,
	LPFONTINFO  lpFont,
	LPDRAWMODE  lpDrawMode,
	LPTEXTXFORM lpFontTrans,
	USHORT      usExpandPixels,
	USHORT      usMode
);

#endif

#endif

/***********************************************/
/*  WIFEMAN's Miscellaneous Service Functions  */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_MISC

BOOL FAR PASCAL MiscIsDBCSLeadByte( CHAR_SET CharSet, USHORT ch );

#define MiscIsMBCSCharSet(c) (MiscIsDBCSLeadByte(c,0xffff))

VOID FAR PASCAL MiscSetErroInfo( ULONG ErrorCode );

ULONG FAR PASCAL MiscGetErroInfo( VOID );

SHORT FAR PASCAL MiscWarningMessage( 
	HANDLE hInst, 
	USHORT idsMsg, 
	USHORT idsTitle, 
	USHORT mode 
);

SHORT FAR PASCAL MiscWarningMessageWithArgument( 
	HANDLE hInst, 
	USHORT idsMsg, 
	USHORT idsTitle, 
	LPSTR lpszArgument,
	USHORT mode
);

#ifdef ENABLE_MESSAGEBOX

/* MessageBox() Flags */
#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP	    MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000

#define MB_TYPEMASK	    0x000F
#define MB_ICONMASK	    0x00F0
#define MB_DEFMASK	    0x0F00
#define MB_MODEMASK	    0x3000
#define MB_MISCMASK	    0xC000

#endif /* ENABLE_MESSAGEBOX */

USHORT FAR PASCAL ubstrlen( LPUBCHAR cp );

LPUBCHAR FAR PASCAL ubstrcpy( LPUBCHAR dst, LPUBCHAR src );

LPUBCHAR FAR PASCAL ubstrncpy( LPUBCHAR dst, LPUBCHAR src, USHORT limit );

LPUBCHAR FAR PASCAL ubstrcat( LPUBCHAR dst, LPUBCHAR src );

LPUBCHAR FAR PASCAL ubstrncat( LPUBCHAR dst, LPUBCHAR src, USHORT limit );

SHORT FAR PASCAL ubstrcmp( LPUBCHAR str1, LPUBCHAR str2 );

USHORT FAR PASCAL AscizToUz( 
	LPUBCHAR dst, 
	LPSTR src, 
	USHORT limit,
	CHAR_SET CharSet
);

USHORT FAR PASCAL UzToAsciz(
	LPSTR dst, 
	LPUBCHAR src, 
	USHORT limit 
);

VOID FAR PASCAL MiscTrancateString( 
	LPSTR lpszStr, 
	SHORT length, 
	SHORT CharSet 
);

#define MiscTrancateByDefaultCharSet(s,l) MiscTrancateString(s,l,-1)

ULONG FAR PASCAL MiscGetVersion( VOID );

USHORT FAR PASCAL MiscGetEUDCLeadByteRange( CHAR_SET csCharSet );

BYTE FAR PASCAL MiscConvertFontFamily( LPSTR szFamilyName );

BYTE FAR PASCAL MiscConvertCharSet( LPSTR CharSetString );

#ifdef WIFE_ENABLE_FONT_STRUCT_CONVERT

/* follow two values are only for usLogicalMapFlag parameter */
/* in MiscIfiMetricsToLogFont function.  */
#define LOGMAP_IGNORE_DESCENT 1
#define LOGMAP_IGNORE_INTERNAL_LEADING 2
#define LOGMAP_NEGATIVE (0x8000)

VOID FAR PASCAL MiscIfiMetricsToLogFont( 
	LPLOGFONT lpLogFont, 
	LPIFIMETRICS lpIFIMetrics,
	USHORT usLogicalMapFlag
);

VOID FAR PASCAL MiscIfiMetricsToTextMetrics( 
	LPTEXTMETRIC lpTextMetrics, 
	LPIFIMETRICS lpIFIMetrics 
);

#endif

#ifdef WIFE_ENABLE_FONT_STRUCT_MAKE

VOID FAR PASCAL MiscMakeTextXform(
	LPTEXTXFORM lpTXF,
	LPIFIMETRICS lpIM,
	LPLOGFONT lpLF
);

#endif

#ifndef WIFEH_NO_HUGE_SUPPORT
LPVOID FAR PASCAL MiscAddHugePtr( LPVOID src, ULONG offset );
USHORT FAR PASCAL MiscGetSegmentIncrement( VOID );
#endif

#ifndef WIFEH_NO_CONTROL_RANGES
BOOL FAR PASCAL MiscIsWifeControl( SHORT function );
BOOL FAR PASCAL MiscIsGaijiControl( SHORT function );
#endif

#ifndef WIFEH_NO_STRETCHER
BOOL FAR PASCAL MiscStretchMonoFontImage(
	LPVOID	lpDestImage,
	USHORT	usSizeOfDestX,
	USHORT	usSizeOfDestY,
	LPVOID	lpSrcImage,
	USHORT	usSizeOfSrcX,
	USHORT	usSizeOfSrcY
);
#endif

#ifdef WIFE_ENABLE_QUICK_SEARCH_TABLE

typedef struct {
	HFD hFD;
	HFF hFF;
	ULONG ulFont;
	BOOL bScalable;
	LOGFONT LogFont;
}QUICK_SEARCH_TABLE, NEAR * NP_QUICK_SEARCH_TABLE, FAR * LP_QUICK_SEARCH_TABLE;

LP_QUICK_SEARCH_TABLE FAR PASCAL MiscValidateQuickSearchTable( 
	USHORT usLogicalMapFlag 
);

BOOL FAR PASCAL MiscUnvalidateQuickSearchTable( 
	USHORT usLogicalMapFlag 
);

typedef LP_QUICK_SEARCH_TABLE (FAR PASCAL * LPMISCVALIDATEQST)(
	USHORT usLogicalMapFlag 
);

typedef BOOL (FAR PASCAL * LPMISCUNVALIDATEQST)(
	USHORT usLogicalMapFlag 
);

#define NMISCVALIDATEQST (67)
#define NMISCUNVALIDATEQST (68)

#endif

#ifdef WIFE_ENABLE_NOTIFY_FUNCTIONS

typedef enum {
	WN_ADD_FONTDRIVER = 0,
	WN_ADD_FONTPACKAGE = 1,
	WN_REMOVE_FONTDRIVER = 2,
	WN_REMOVE_FONTPACKAGE = 3,
	WN_REGISTER_SYSTEM_EUDC_CHAR = 4,
	WN_CHANGE_SYSTEM_EUDC_FILE = 5
} WIFENOTIFY_ORDER;

typedef struct {
	HFD hTargetFontDriver;
} WNS_FONTDRIVER;

typedef struct {
	HFD hTargetFontDriver;
	HFF hTargetFontPackage;
} WNS_FONTPACKAGE;

typedef struct {
	HFD hTargetFontDriver;
	HFF hTargetFontPackage;
	UBCHAR ubRegistedCharCode;
} WNS_REGISTER_SYSTEM_EUDC_CHAR;

typedef struct {
	HFD hTargetFontDriver;
	HFF hTargetFontPackage;
	LPSTR lpszNewFileName;
} WNS_WN_CHANGE_SYSTEM_EUDC_FILE;

typedef BOOL (FAR PASCAL * LPNOTIFYCALLBACKFUNC)(
	WIFENOTIFY_ORDER NotifyOrder,
	LPVOID lpParamBlock
);

BOOL FAR PASCAL MiscRegisterNotifyFunction(
	LPNOTIFYCALLBACKFUNC lpfnCallBack
);

BOOL FAR PASCAL MiscUnregisterNotifyFunction(
	LPNOTIFYCALLBACKFUNC lpfnCallBack
);

#endif

#endif


/***********************************************/
/*    DIAGNOSTIC TEST&CHECKING FUNCTIONS       */
/***********************************************/
#ifdef ENABLE_DIAGNOSTIC_FUNCTION

/* test and return error code  */
SHORT FAR PASCAL DiagSelfCheck( VOID );

/* invoke self test and make error record file, display warning dialog */
SHORT FAR PASCAL DiagSelfCheckAndWarning( VOID );

#endif


/************************************************/
/* THESE ARE PRIVATE INTERFACE FOR TEST PROGRAM */
/************************************************/
#ifdef ENABLE_TEST_PROGRAM_INTERFACE

LPVOID FAR PASCAL DiagLocalLockAnything( LOCALHANDLE hAny );
LPVOID FAR PASCAL DiagLocalUnlockAnything( LOCALHANDLE hAny );
SHORT FAR PASCAL DiagGetConfirmString( LPSTR buffer, SHORT length );

#endif

/* end of wife.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\windefs.inc ===
;***************************************************************************
;                                                                          *
;   Copyright (C) 1983,1984 by Microsoft Inc.                              *
;                                                                          *
;***************************************************************************

;       Macros for disabling and restoring hardware interrupt enable flag
;
;       The LeaveCrit macro has been updated for the mask problem on
;       the 80286 processor.

include vint.inc


EnterCrit   MACRO
        pushf
        FCLI
ENDM

LeaveCrit   macro   reg 		;;this macro will restore the state of
ifnb	<reg>				;;the interrupt flag to what is was
	pop	reg&x			;;before EnterCrit.  All other flags
	test	reg&h, 2		;;are discarded.
	jz	@f
        FSTI
@@:
else
	push	bp
	mov	bp, sp
	test	byte ptr [bp+3], 2
	jz	@f
        FSTI
@@:
	pop	bp
	popf
endif
	endm


if 0
POPFF	equ	<LeaveCrit>

LeaveCrit   MACRO
        POPFF
ENDM
endif

POPFF	MACRO				;;this macro will restore ALL flags,
	local	a			;;EXCEPT the interrupt flag, to
	jmp	$+3			;;their previous state
a       label   near
        iret
        push    cs
        call    a
ENDM




;***************************************************************************
;                                                                          *
;   Inquire data structures for Timer, Keyboard, Mouse and Cursor modules  *
;                                                                          *
;***************************************************************************

TIMERINFO       STRUC
tiResolution    DD      0       ; #microseconds each timer tick
TIMERINFO       ENDS

KBINFO          STRUC
kbRanges        DB      4 dup (0)  ; Far East ranges for KANJI
kbStateSize     DW      0       ; #bytes of state info maintained by TOASCII
KBINFO          ENDS


MOUSEINFO       STRUC
msExists        DB      0       ; true => mouse exists
msRelative      DB      0       ; true => relative coordinate
msNumButtons    DW      0       ; number of buttons on the mouse
msRate          DW      0       ; maximum rate of mouse input events
msXThresh       DW      0       ; threshold before acceleration
msYThresh       DW      0       ;
msXRes          DW      0       ; x resolution
msYRes          DW      0       ; y resolution
MOUSEINFO       ENDS


CURSORINFO      STRUC
dpXRate         DW      0       ; horizontal mickey/pixel ratio
dpYRate         DW      0       ; vertical mickey/pixel ratio
CURSORINFO      ENDS


;***************************************************************************
;                                                                          *
; Cursor data structure passed to OEM routines.  Defines a graphics display*
; cursor in terms of a hotspot, an AND mask and an XOR mask.  The hot      *
; spot defines the pixel within the cursor that is the cursor is "pointing"*
; to.  So when displaying a cursor at location X,Y the pixel that          *
; is the hot spot should be painted at that X,Y coordinate.  The "shape"   *
; of the cursor is defined by two pixel masks.  The first mask is ANDed    *
; with the bits in the display bitmap and the second mask is XORed with    *
; the result to determine the bits that will be placed in the display      *
; bitmap.  The bits for the masks are in the byte array that begins        *
; at the csBits field, with the AND mask bits first, followed by the       *
; XOR mask bits.  The csWidthBytes field is the width of ONE mask, in      *
; bytes.  Currently, MS-WIN will only generate cursors whose width and     *
; height are both 16.                                                      *
;                                                                          *
;***************************************************************************

cursorShape     STRUC
csHotX          DW      0
csHotY          DW      0
csWidth         DW      0
csHeight        DW      0
csWidthBytes    DW      0
csColor         DW      0
    ; Beginning of an array of bytes that contain the bits for the AND and
    ; XOR masks.  The first csHeight * csWidthBytes bytes contain the bits
    ; for the AND mask and the next csHeight * csWidthBytes bytes contain
    ; the bits for the XOR mask.
;csBits          DB  2*2*16 DUP (?)
cursorShape     ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\win3deb.inc ===
; declare a simple interface to control debugging messages

BegData	macro
  _DATA	SEGMENT PARA PUBLIC 'DATA'
endm

EndData	macro
  _DATA ENDS
endm

DEB_ERROR	=  1
DEB_WARN	=  2
DEB_TRACE	=  4
DEB_FERROR	=  8	;; fatal error - terminate app
DEB_IERROR	= 10h
DEB_IWARN	= 20h
DEB_ITRACE	= 40h
DEB_IFERROR	= 80h ;; fatal error - terminate app
DEB_FERRORS	= DEB_FERROR or DEB_IFERROR
DEB_ERRORS	= DEB_ERROR OR DEB_IERROR OR DEB_FERRORS
DEB_WARNS	= DEB_WARN OR DEB_IWARN
DEB_TRACES	= DEB_TRACE OR DEB_ITRACE
DEB_NOCRLF	= 8000h	;; No CR/LF in string
DEB_BREAKLEVEL	= DEB_ERRORS or 0ff00h
DEB_INFOLEVEL	= DEB_BREAKLEVEL or DEB_WARNS

DECLARE_DEBUG	macro	comp

  ifdef Win3DebData
  else
    extrn _Win3InfoLevel:word, _Win3BreakLevel:word

;    BegData
      extrn	_&comp&InfoLevel:word, _&comp&BreakLevel:word
;    EndData

  endif
  ifdef Win3Deb
  else
    extrn	_&comp&DebugTest:far
  endif

  &comp&DebugOut	macro	flag, string, vals
    local sloc, cnt
    BegData
      sloc label byte
       db  string
       ife (flag) and DEB_NOCRLF
	 db 13, 10
       endif
       db  0
    EndData
    cnt = 0
    irp foo, <vals>
      push	foo
      cnt = cnt + 1
    endm
    push	offset sloc
    push	flag AND NOT DEB_NOCRLF
    call	_&comp&DebugTest
    add	sp, 4+(2*cnt)
  endm
endm

declare_areas macro name, comp, list
  deb_loc = 100h
  deb_areas equ <list>

  irp val, <list>
    DEB_&comp&&val = deb_loc
    deb_loc = deb_loc + deb_loc
    ifdef Win3Deb
      BegData
      STR_&comp&&val label byte
	 db  "&name &val: ", 0
      EndData
    endif
  endm
  ifdef Win3Deb
    BegData
      STR_&comp&Trace db "Trace: ", 0
      STR_&comp&Warn db "Warning: ", 0
      STR_&comp&Error db "Error: ", 0
      STR_&comp	db	"&name: ", 0
      STR_&comp&table	dw	dataoffset STR_&comp
      irp val, <list>
	dw dataoffset STR_&comp&&val
      endm
    EndData
  endif
endm

declare_infolevel macro comp
  local skip
  BegData
;    public _&comp&InfoLevel, _&comp&BreakLevel
;    _&comp&InfoLevel  dw  DEB_INFOLEVEL		;; component can override
;    _&comp&BreakLevel dw  DEB_BREAKLEVEL
  EndData

  _&comp&DebugTest proc far		;; Per-component - check right flags
  public _&comp&DebugTest
	push	bp
	mov	bp, sp
	push	ds
	push	ax
	mov	ax, _DATA
	cmp	ax, 1000h		;; DATA should be selector, not addr
	jnc	skip
	mov	ds, ax
	assume	ds:_DATA

	mov	ax, [bp+6]		;; See if component enabled
	and	ax, [_&comp&InfoLevel]
	cmp	ax, [bp+6]
	jnz	skip

	push	es			;; See if system enabled
	push	seg _Win3InfoLevel
	pop	es
	and	al, byte ptr es:[_Win3InfoLevel] ;; test low 8 bits for system-wide
	pop	es
	cmp	ax, [bp+6]
	jnz	skip

					;; Print it, so format message
	push	bx
	test	al, DEB_ERRORS
	mov	bx, dataoffset STR_&comp&Error
	jnz	@F
	test	al, DEB_WARNS
	mov	bx, dataoffset STR_&comp&Warn
	jnz	@F
	test	al, DEB_TRACES
	mov	bx, dataoffset STR_&comp&Trace
	jnz	@F
	jmp	short deb_no_msg_type

@@:
	push	bx
	call	KOutDSStr
deb_no_msg_type:
	mov	bx, dataoffset STR_&comp&Table
	or	ah, ah
	jz	deb_show_it
@@:
	add	bx, 2
	shr	ah, 1
	jnz	@B
deb_show_it:
	push	[bx]			;; push parameter
	call	KOutDSStr
	pop	bx			;; restore reg

	pop	ax
	push	[bp+8]
	call	KOutDSStr
	push	ax
	mov	ax, [bp+6]
	and	ax, [_&comp&BreakLevel]
	jz	skip

	push	es
	push	seg _Win3BreakLevel
	pop	es
	and	ax, es:_Win3BreakLevel
	pop	es
	jz	skip

	int	3
  skip:
	test    byte ptr [bp+6], DEB_FERRORS
	jz	@F
	push	0
	push	DGROUP
	push	word ptr [bp+8]
	cCall	FatalAppExit	;,<0,DGROUP,[bp+8]>
@@:
	pop	ax
	pop	ds
	pop	bp
	retf
  _&comp&DebugTest endp
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\winexp.h ===
#ifndef NOATOM
/* atom manager internals */
#define ATOMSTRUC struct atomstruct
typedef ATOMSTRUC *PATOM;
typedef ATOMSTRUC {
    PATOM chain;
    WORD  usage;             /* Atoms are usage counted. */
    BYTE  len;               /* length of ASCIZ name string */
    BYTE  name;              /* beginning of ASCIZ name string */
} ATOMENTRY;

typedef struct {
    int     numEntries;
    PATOM   pAtom[ 1 ];
} ATOMTABLE;
ATOMTABLE * PASCAL pAtomTable;
#endif

LPSTR	API lstrbscan(LPSTR, LPSTR);
LPSTR	API lstrbskip(LPSTR, LPSTR);

int	API OpenPathName(LPSTR, int);
int	API DeletePathName(LPSTR);
WORD	API _ldup(int);


/* scheduler things that the world knows not */
BOOL	API WaitEvent( HANDLE );
BOOL	API PostEvent( HANDLE );
BOOL	API KillTask( HANDLE );

/* print screen hooks */
BOOL	API SetPrtScHook(FARPROC);
FARPROC API GetPrtScHook(void);


/* scroll bar messages */
#define SBM_SETPOS      WM_USER+0
#define SBM_GETPOS      WM_USER+1
#define SBM_SETRANGE    WM_USER+2
#define SBM_GETRANGE    WM_USER+3
#define SBM_ENABLE_ARROWS WM_USER+4

/* module stuff */
HANDLE	API GetDSModule( WORD );
HANDLE	API GetDSInstance( WORD );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\windows.inc ===
;*************************************************************************
;
;       WINDOWS.INC - Windows assembly language structures & constants
;
;*************************************************************************
;
; Conditional Block includes:   (True states)
;     NOTEXT - don't include TextMetric struc & text drawing modes & stock objs.
;     NORASTOPS - don't include binary and ternary raster ops.
;     NOVK      - don't include virtual key definitions
;     NOMB      - don't include message box definitions
;     NOWM      - don't include window messages
;
;
FALSE   =       0
TRUE    =       1
NULL    =       0

;*******************************************************************
;
;       Rectangle
;
;*******************************************************************

RECT    struc
        rcLeft          dw      ?
        rcTop           dw      ?
        rcRight         dw      ?
        rcBottom        dw      ?
RECT    ends

;*******************************************************************
;
;  Window Class structure
;
;*******************************************************************

WNDCLASS struc
        clsStyle        dw      ?       ; class style
        clsLpfnWndProc  dd      ?
        clsCbClsExtra   dw      ?
        clsCbWndExtra   dw      ?
        clsHInstance    dw      ?       ; instance handle
        clsHIcon        dw      ?       ; class icon handle
        clsHCursor      dw      ?       ; class cursor handle
        clsHbrBackground dw     ?       ; class background brush
        clsLpszMenuName dd      ?       ; menu name
        clsLpszClassName dd     ?       ; far ptr to class name
WNDCLASS ends

IFNDEF NOTEXT
TEXTMETRIC struc
    tmHeight	    dw	    ?
    tmAscent	    dw	    ?
    tmDescent	    dw	    ?
    tmIntLeading    dw	    ?
    tmExtLeading    dw	    ?
    tmAveCharWidth  dw	    ?
    tmMaxCharWidth  dw	    ?
    tmWeight	    dw	    ?
    tmItalic	    db	    ?
    tmUnderlined    db	    ?
    tmStruckOut     db	    ?
    tmFirstChar     db	    ?
    tmLastChar	    db	    ?
    tmDefaultChar   db	    ?
    tmBreakChar     db	    ?
    tmPitch	    db	    ?
    tmCharSet	    db	    ?
    tmOverhang	    dw	    ?
    tmAspectX	    dw	    ?
    tmAspectY	    dw	    ?
TEXTMETRIC ends

LF_FACESIZE	EQU	32

LOGFONT struc
    lfHeight	      dw   ?
    lfWidth	      dw   ?
    lfEscapement      dw   ?
    lfOrientation     dw   ?
    lfWeight	      dw   ?
    lfItalic	      db   ?
    lfUnderline       db   ?
    lfStrikeOut       db   ?
    lfCharSet	      db   ?
    lfOutPrecision    db   ?
    lfClipPrecision   db   ?
    lfQuality	      db   ?
    lfPitchAndFamily  db   ?
    lfFaceName	      db   LF_FACESIZE dup(?)
LOGFONT ends

LOGBRUSH struc
    lbStyle         dw ?
    lbColor         dd ?
    lbHatch         dw ?
LOGBRUSH ends

;
;  Text Drawing modes
;
TRANSPARENT     = 1
OPAQUE          = 2
;
; Mapping Modes
;
MM_TEXT         =   1
MM_LOMETRIC     =   2
MM_HIMETRIC     =   3
MM_LOENGLISH    =   4
MM_HIENGLISH    =   5
MM_TWIPS        =   6
MM_ISOTROPIC    =   7
MM_ANISOTROPIC  =   8
;
; Coordinate Modes
;
ABSOLUTE        =   1
RELATIVE        =   2
;
;  Stock Logical Objects
;
WHITE_BRUSH         =  0
LTGRAY_BRUSH        =  1
GRAY_BRUSH          =  2
DKGRAY_BRUSH        =  3
BLACK_BRUSH         =  4
NULL_BRUSH          =  5
HOLLOW_BRUSH        =  5
WHITE_PEN           =  6
BLACK_PEN           =  7
NULL_PEN            =  8
DOT_MARKER          =  9
OEM_FIXED_FONT      = 10
ANSI_FIXED_FONT     = 11
ANSI_VAR_FONT       = 12
SYSTEM_FONT         = 13
DEVICE_DEFAULT_FONT = 14
DEFAULT_PALETTE     = 15
SYSTEM_FIXED_FONT   = 16
ENDIF
;
; Brush Styles
;
BS_SOLID        =   0
BS_NULL         =   1
BS_HOLLOW       =   BS_NULL
BS_HATCHED      =   2
BS_PATTERN      =   3
BS_INDEXED      =   4
BS_DIBPATTERN	=   5
;
; Hatch Styles
;
HS_HORIZONTAL   =   0       ; -----
HS_VERTICAL     =   1       ; |||||
HS_FDIAGONAL    =   2       ; \\\\\
HS_BDIAGONAL    =   3       ; /////
HS_CROSS        =   4       ; +++++
HS_DIAGCROSS    =   5       ; xxxxx
;
; Pen Styles
;
PS_SOLID        =   0
PS_DASH         =   1       ; -------
PS_DOT          =   2       ; .......
PS_DASHDOT      =   3       ; _._._._
PS_DASHDOTDOT   =   4       ; _.._.._
PS_NULL         =   5
PS_INSIDEFRAME  =   6
;
; Device Parameters for GetDeviceCaps()
;
DRIVERVERSION =0     ; Device driver version
TECHNOLOGY    =2     ; Device classification
HORZSIZE      =4     ; Horizontal size in millimeters
VERTSIZE      =6     ; Vertical size in millimeters
HORZRES       =8     ; Horizontal width in pixels
VERTRES       =10    ; Vertical width in pixels
BITSPIXEL     =12    ; Number of bits per pixel
PLANES        =14    ; Number of planes
NUMBRUSHES    =16    ; Number of brushes the device has
NUMPENS       =18    ; Number of pens the device has
NUMMARKERS    =20    ; Number of markers the device has
NUMFONTS      =22    ; Number of fonts the device has
NUMCOLORS     =24    ; Number of colors the device supports
PDEVICESIZE   =26    ; Size required for device descriptor
CURVECAPS     =28    ; Curve capabilities
LINECAPS      =30    ; Line capabilities
POLYGONALCAPS =32    ; Polygonal capabilities
TEXTCAPS      =34    ; Text capabilities
CLIPCAPS      =36    ; Clipping capabilities
RASTERCAPS    =38    ; Bitblt capabilities
ASPECTX       =40    ; Length of the X leg
ASPECTY       =42    ; Length of the Y leg
ASPECTXY      =44    ; Length of the hypotenuse

LOGPIXELSX    =88    ; Logical pixels/inch in X
LOGPIXELSY    =90    ; Logical pixels/inch in Y

SIZEPALETTE   =104   ; Number of entries in physical palette
NUMRESERVED   =106   ; Number of reserved entries in palette
COLORRES      =108   ; Actual color resolution
;
ifndef NOGDICAPMASKS
;
; Device Capability Masks:
;
; Device Technologies
DT_PLOTTER       =   0  ; /* Vector plotter                   */
DT_RASDISPLAY    =   1  ; /* Raster display                   */
DT_RASPRINTER    =   2  ; /* Raster printer                   */
DT_RASCAMERA     =   3  ; /* Raster camera                    */
DT_CHARSTREAM    =   4  ; /* Character-stream, PLP            */
DT_METAFILE      =   5  ; /* Metafile, VDM                    */
DT_DISPFILE      =   6  ; /* Display-file                     */
;
; Curve Capabilities
CC_NONE          =   0  ; /* Curves not supported             */
CC_CIRCLES       =   1  ; /* Can do circles                   */
CC_PIE           =   2  ; /* Can do pie wedges                */
CC_CHORD         =   4  ; /* Can do chord arcs                */
CC_ELLIPSES      =   8  ; /* Can do ellipese                  */
CC_WIDE          =   16 ; /* Can do wide lines                */
CC_STYLED        =   32 ; /* Can do styled lines              */
CC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
CC_INTERIORS     =   128; /* Can do interiors                 */
;
; Line Capabilities
LC_NONE          =   0  ; /* Lines not supported              */
LC_POLYLINE      =   2  ; /* Can do polylines                 */
LC_MARKER        =   4  ; /* Can do markers                   */
LC_POLYMARKER    =   8  ; /* Can do polymarkers               */
LC_WIDE          =   16 ; /* Can do wide lines                */
LC_STYLED        =   32 ; /* Can do styled lines              */
LC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
LC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities
PC_NONE          =   0  ; /* Polygonals not supported         */
PC_POLYGON       =   1  ; /* Can do polygons                  */
PC_RECTANGLE     =   2  ; /* Can do rectangles                */
PC_WINDPOLYGON   =   4  ; /* Can do winding polygons          */
PC_TRAPEZOID     =   4  ; /* Can do trapezoids                */
PC_SCANLINE      =   8  ; /* Can do scanlines                 */
PC_WIDE          =   16 ; /* Can do wide borders              */
PC_STYLED        =   32 ; /* Can do styled borders            */
PC_WIDESTYLED    =   64 ; /* Can do wide styled borders       */
PC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities */
CP_NONE          =   0  ; /* No clipping of output            */
CP_RECTANGLE     =   1  ; /* Output clipped to rects          */
;
; Text Capabilities
TC_OP_CHARACTER  =   0001h ; /* Can do OutputPrecision   CHARACTER      */
TC_OP_STROKE     =   0002h ; /* Can do OutputPrecision   STROKE         */
TC_CP_STROKE     =   0004h ; /* Can do ClipPrecision     STROKE         */
TC_CR_90         =   0008h ; /* Can do CharRotAbility    90             */
TC_CR_ANY        =   0010h ; /* Can do CharRotAbility    ANY            */
TC_SF_X_YINDEP   =   0020h ; /* Can do ScaleFreedom      X_YINDEPENDENT */
TC_SA_DOUBLE     =   0040h ; /* Can do ScaleAbility      DOUBLE         */
TC_SA_INTEGER    =   0080h ; /* Can do ScaleAbility      INTEGER        */
TC_SA_CONTIN     =   0100h ; /* Can do ScaleAbility      CONTINUOUS     */
TC_EA_DOUBLE     =   0200h ; /* Can do EmboldenAbility   DOUBLE         */
TC_IA_ABLE       =   0400h ; /* Can do ItalisizeAbility  ABLE           */
TC_UA_ABLE       =   0800h ; /* Can do UnderlineAbility  ABLE           */
TC_SO_ABLE       =   1000h ; /* Can do StrikeOutAbility  ABLE           */
TC_RA_ABLE       =   2000h ; /* Can do RasterFontAble    ABLE           */
TC_VA_ABLE       =   4000h ; /* Can do VectorFontAble    ABLE           */
TC_RESERVED      =   8000h
;
; Raster Capabilities
RC_BITBLT        =   1      ; /* Can do standard BLT.             */
RC_BANDING       =   2      ; /* Device requires banding support  */
RC_SCALING       =   4      ; /* Device requires scaling support  */
RC_BITMAP64      =   8      ; /* Device can support >64K bitmap   */
RC_GDI20_OUTPUT  =   0010h  ; /* has 2.0 output calls         */
RC_DI_BITMAP     =   0080h  ; /* supports DIB to memory       */
RC_PALETTE       =   0100h  ; /* supports a palette           */
RC_DIBTODEV      =   0200h  ; /* supports DIBitsToDevice      */
RC_BIGFONT       =   0400h  ; /* supports >64K fonts          */
RC_STRETCHBLT    =   0800h  ; /* supports StretchBlt          */
RC_FLOODFILL     =   1000h  ; /* supports FloodFill           */
RC_STRETCHDIB    =   2000h  ; /* supports StretchDIBits       */

endif       ;NOGDICAPMASKS

; palette entry flags
;
PC_RESERVED     = 1    ;/* palette index used for animation */
PC_EXPLICIT     = 2    ;/* palette index is explicit to device */
PC_NOCOLLAPSE	= 4    ;/* do not match color to system palette */

; DIB color table identifiers
;
DIB_RGB_COLORS  = 0    ;/* color table in RGBTriples */
DIB_PAL_COLORS  = 1    ;/* color table in palette indices */
;

;constants for Get/SetSystemPaletteUse()
;
SYSPAL_STATIC	= 1
SYSPAL_NOSTATIC	= 2

; constants for CreateDIBitmap
CBM_INIT        = 4    ;/* initialize bitmap */
;
; Bitmap format constants
BI_RGB          = 0
BI_RLE8         = 1
BI_RLE4         = 2
;
;
ANSI_CHARSET    = 0
SYMBOL_CHARSET	= 2
OEM_CHARSET     = 255
;
;  styles for CombineRgn
;
RGN_AND  = 1
RGN_OR   = 2
RGN_XOR  = 3
RGN_DIFF = 4
RGN_COPY = 5
;
;  Predefined cursor & icon IDs
;
IDC_ARROW       = 32512
IDC_IBEAM       = 32513
IDC_WAIT        = 32514
IDC_CROSS       = 32515
IDC_UPARROW     = 32516
IDC_SIZE        = 32640
IDC_ICON        = 32641
IDC_SIZENWSE    = 32642
IDC_SIZENESW    = 32643
IDC_SIZEWE      = 32644
IDC_SIZENS      = 32645

IDI_APPLICATION = 32512
IDI_HAND        = 32513
IDI_QUESTION    = 32514
IDI_EXCLAMATION = 32515
IDI_ASTERISK    = 32516

;
; OEM Resource Ordinal Numbers */
;
OBM_CLOSE         =  32754
OBM_UPARROW       =  32753
OBM_DNARROW       =  32752
OBM_RGARROW       =  32751
OBM_LFARROW       =  32750
OBM_REDUCE        =  32749
OBM_ZOOM          =  32748
OBM_RESTORE       =  32747
OBM_REDUCED       =  32746
OBM_ZOOMD         =  32745
OBM_RESTORED      =  32744
OBM_UPARROWD      =  32743
OBM_DNARROWD      =  32742
OBM_RGARROWD      =  32741
OBM_LFARROWD      =  32740
OBM_MNARROW       =  32739
OBM_COMBO         =  32738
OBM_UPARROWI	  =  32737
OBM_DNARROWI	  =  32736
OBM_RGARROWI	  =  32735
OBM_LFARROWI	  =  32734

OBM_OLD_CLOSE     =  32767
OBM_SIZE          =  32766
OBM_OLD_UPARROW   =  32765
OBM_OLD_DNARROW   =  32764
OBM_OLD_RGARROW   =  32763
OBM_OLD_LFARROW   =  32762
OBM_BTSIZE        =  32761
OBM_CHECK         =  32760
OBM_CHECKBOXES    =  32759
OBM_BTNCORNERS    =  32758
OBM_OLD_REDUCE    =  32757
OBM_OLD_ZOOM      =  32756
OBM_OLD_RESTORE   =  32755

OCR_NORMAL        =  32512
OCR_IBEAM         =  32513
OCR_WAIT          =  32514
OCR_CROSS         =  32515
OCR_UP            =  32516
OCR_SIZE          =  32640
OCR_ICON          =  32641
OCR_SIZENWSE      =  32642
OCR_SIZENESW      =  32643
OCR_SIZEWE        =  32644
OCR_SIZENS        =  32645
OCR_SIZEALL       =  32646
OCR_ICOCUR        =  32647

OIC_SAMPLE        =  32512
OIC_HAND          =  32513
OIC_QUES          =  32514
OIC_BANG          =  32515
OIC_NOTE          =  32516

;
;   Scroll bar constants
;
SB_HORZ = 0
SB_VERT = 1
SB_CTL  = 2
SB_BOTH = 3
;
;   Scroll Commands
;
SB_LINEUP        = 0
SB_LINEDOWN      = 1
SB_PAGEUP        = 2
SB_PAGEDOWN      = 3
SB_THUMBPOSITION = 4
SB_THUMBTRACK    = 5
SB_TOP           = 6
SB_BOTTOM        = 7
SB_ENDSCROLL     = 8
;
;  MessageBox type flags
;
IFNDEF                  NOMB
MB_OK                   = 0000H
MB_OKCANCEL             = 0001H
MB_ABORTRETRYIGNORE     = 0002H
MB_YESNOCANCEL          = 0003H
MB_YESNO                = 0004H
MB_RETRYCANCEL          = 0005H

MB_ICONHAND             = 0010H
MB_ICONQUESTION         = 0020H
MB_ICONEXCLAMATION      = 0030H
MB_ICONASTERISK         = 0040H

MB_DEFBUTTON1           = 0000H
MB_DEFBUTTON2           = 0100H
MB_DEFBUTTON3           = 0200H

MB_APPLMODAL            = 0000H
MB_SYSTEMMODAL          = 1000H
MB_TASKMODAL            = 2000H

MB_NOFOCUS              = 8000H

;
;  Conventional dialog box and message box command IDs
;
IDOK     =   1
IDCANCEL =   2
IDABORT  =   3
IDRETRY  =   4
IDIGNORE =   5
IDYES    =   6
IDNO     =   7
;
;  Flags for OpenFile
;
OF_READ 	    = 0000H
OF_WRITE	    = 0001H
OF_READWRITE	    = 0002H
OF_SHARE_COMPAT	    = 0000H
OF_SHARE_EXCLUSIVE  = 0010H
OF_SHARE_DENY_WRITE = 0020H
OF_SHARE_DENY_READ  = 0030H
OF_SHARE_DENY_NONE  = 0040H
OF_PARSE	    = 0100H
OF_DELETE	    = 0200H
OF_VERIFY	    = 0400H     ; Used with OF_REOPEN
OF_SEARCH	    = 0400H     ; Used without OF_REOPEN
OF_CANCEL           = 0800H
OF_CREATE           = 1000H
OF_PROMPT           = 2000H
OF_EXIST            = 4000H
OF_REOPEN           = 8000H

TF_FORCEDRIVE   = 80H

OPENSTRUC       STRUC
opLen   db      ?
opDisk  db      ?
opXtra  dw      ?
opDate  dw      ?
opTime  dw      ?
opFile  db      120 dup (?)
OPENSTRUC       ENDS
;
;  DrawText format flags
;
DT_LEFT         = 00H
DT_CENTER       = 01H
DT_RIGHT        = 02H
DT_TOP          = 00H
DT_VCENTER      = 04H
DT_BOTTOM       = 08H
DT_WORDBREAK    = 10H
DT_SINGLELINE   = 20H
DT_EXPANDTABS   = 40H
DT_TABSTOP      = 80H
DT_NOCLIP       =    0100H
DT_EXTERNALLEADING = 0200H
DT_CALCRECT     =    0400H
DT_NOPREFIX     =    0800H
DT_INTERNAL     =    1000H
ENDIF

;
; ExtFloodFill style flags
;
FLOODFILLBORDER  =  0
FLOODFILLSURFACE =  1

;
; Memory manager flags
;
LMEM_FIXED      =   0000h
LMEM_MOVEABLE   =   0002h
LMEM_NOCOMPACT  =   0010H
LMEM_NODISCARD  =   0020H
LMEM_ZEROINIT   =   0040h
LMEM_MODIFY     =   0080H
LMEM_DISCARDABLE=   0F00h
LHND    =    LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR    =    LMEM_FIXED+LMEM_ZEROINIT
; Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE)
LMEM_DISCARDED  =   4000H
LMEM_LOCKCOUNT  =   00FFH

NONZEROLHND     =    LMEM_MOVEABLE
NONZEROLPTR     =    LMEM_FIXED

LNOTIFY_OUTOFMEM  =  0			;Internal
LNOTIFY_MOVE      =  1			;Internal
LNOTIFY_DISCARD   =  2			;Internal


GMEM_FIXED      =   0000h
GMEM_MOVEABLE   =   0002h
GMEM_NOCOMPACT  =   0010h
GMEM_NODISCARD  =   0020h
GMEM_ZEROINIT   =   0040h
GMEM_MODIFY     =   0080h
GMEM_DISCARDABLE=   0100h
GMEM_NOT_BANKED =   1000h
GMEM_DDESHARE   =   2000h
GMEM_SHARE	=   2000h
GMEM_NOTIFY     =   4000h
GMEM_LOWER      =   GMEM_NOT_BANKED
GHND            =   GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR            =   GMEM_FIXED+GMEM_ZEROINIT

; Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE)
GMEM_DISCARDED  =    4000h
GMEM_LOCKCOUNT  =    00FFh

; Flags returned by GetWinFlags

WF_PMODE        =    0001h
WF_CPU286       =    0002h
WF_CPU386       =    0004h
WF_CPU486       =    0008h
WF_STANDARD	=    0010h
WF_WIN286	=    0010h
WF_ENHANCED	=    0020h
WF_WIN386	=    0020h
WF_CPU086	=    0040h
WF_CPU186	=    0080h
WF_LARGEFRAME   =    0100h
WF_SMALLFRAME   =    0200h
WF_80x87	=    0400h
WF_PAGING	=    0800h
WF_WLO          =    8000h

; WEP fSystemExit flag values
WEP_SYSTEM_EXIT	=	1
WEP_FREE_DLL	=	0

; GetAppCompatFlags flag values 	;Internal
GACF_IGNORENODISCARD	=	0001h	;Internal
GACF_FORCETEXTBAND	=	0002h	;Internal
GACF_ONELANDGRXBAND	=	0004h	;Internal
GACF_IGNORETOPMOST	=	0008h	;Internal
GACF_CALLTTDEVICE	=	0010h	;Internal
GACF_MULTIPLEBANDS	=	0020h	;Internal
GACF_ALWAYSSENDNCPAINT	=	0040h	;Internal
GACF_EDITSETTEXTMUNGE	=	0080h	;Internal
GACF_MOREEXTRAWNDWORDS	=	0100h	;Internal
GACF_TTIGNORERASTERDUPE =	0200h	;Internal
GACF_HACKWINFLAGS	=	0400h	;Internal
GACF_DELAYHWHNDSHAKECHK =	0800h	;Internal

;  Virtual Keys, Standard Set

IFNDEF          NOVK
VK_LBUTTON      = 01H
VK_RBUTTON      = 02H
VK_CANCEL       = 03H
VK_BACK         = 08H
VK_TAB          = 09H
VK_CLEAR        = 0cH
VK_RETURN       = 0dH
VK_SHIFT        = 10H
VK_CONTROL      = 11H
VK_MENU         = 12H
VK_PAUSE        = 13H
VK_CAPITAL      = 14H
VK_ESCAPE       = 1bH
VK_SPACE        = 20H

VK_PRIOR        = 21H
VK_NEXT         = 22H
VK_END          = 23H
VK_HOME         = 24H
VK_LEFT         = 25H
VK_UP           = 26H
VK_RIGHT        = 27H
VK_DOWN         = 28H

;  VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z'
;  VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0'

VK_PRINT        = 2aH
VK_EXECUTE      = 2bH
VK_SNAPSHOT	= 2ch	; Printscreen key..
VK_INSERT       = 2dH
VK_DELETE       = 2eH
VK_HELP         = 2fH

VK_NUMPAD0      = 60H
VK_NUMPAD1      = 61H
VK_NUMPAD2      = 62H
VK_NUMPAD3      = 63H
VK_NUMPAD4      = 64H
VK_NUMPAD5      = 65H
VK_NUMPAD6      = 66H
VK_NUMPAD7      = 67H
VK_NUMPAD8      = 68H
VK_NUMPAD9      = 69H
VK_MULTIPLY     = 6AH
VK_ADD          = 6BH
VK_SEPARATER    = 6CH
VK_SUBTRACT     = 6DH
VK_DECIMAL      = 6EH
VK_DIVIDE       = 6FH

VK_F1           = 70H
VK_F2           = 71H
VK_F3           = 72H
VK_F4           = 73H
VK_F5           = 74H
VK_F6           = 75H
VK_F7           = 76H
VK_F8           = 77H
VK_F9           = 78H
VK_F10          = 79H
VK_F11          = 7aH
VK_F12          = 7bH
VK_F13          = 7cH
VK_F14          = 7dH
VK_F15          = 7eH
VK_F16          = 7fH
VK_F17		= 80H
VK_F18		= 81H
VK_F19		= 82H
VK_F20		= 83H
VK_F21		= 84H
VK_F22		= 85H
VK_F23		= 86H
VK_F24		= 87H

VK_NUMLOCK      = 90H
VK_SCROLL       = 91H
ENDIF

IFNDEF NOWH

; SetWindowsHook() codes
WH_NULLNODE	   = (-100)		;Internal
WH_MSGFILTER       = (-1)
WH_JOURNALRECORD   = 0
WH_JOURNALPLAYBACK = 1
WH_KEYBOARD        = 2
WH_GETMESSAGE      = 3
WH_CALLWNDPROC     = 4
IFNDEF NOWIN31
WH_CBT             = 5
WH_SYSMSGFILTER    = 6
WH_MOUSE	   = 7
WH_HARDWARE	   = 8
WH_DEBUG	   = 9
ENDIF
;
; Hook Codes
HC_GETLPLPFN	   = (-3)
HC_LPLPFNNEXT      = (-2)
HC_LPFNNEXT        = (-1)
HC_ACTION          = 0
HC_GETNEXT         = 1
HC_SKIP            = 2
HC_NOREM           = 3
HC_NOREMOVE        = 3
HC_SYSMODALON      = 4
HC_SYSMODALOFF     = 5
;
; CBT Hook Codes
HCBT_MOVESIZE      = 0
HCBT_MINMAX        = 1
HCBT_QS            = 2
HCBT_CREATEWND	   = 3
HCBT_DESTROYWND	   = 4
HCBT_ACTIVATE	   = 5
HCBT_CLICKSKIPPED  = 6
HCBT_KEYSKIPPED    = 7
HCBT_SYSCOMMAND	   = 8
HCBT_SETFOCUS	   = 9

;
; WH_MSGFILTER Filter Proc Codes
MSGF_DIALOGBOX     = 0
MSGF_MESSAGEBOX    = 1        ;Internal
MSGF_MENU          = 2
MSGF_MOVE          = 3
MSGF_SIZE          = 4
MSGF_SCROLLBAR     = 5
MSGF_NEXTWINDOW    = 6
;
; Window Manager Hook Codes
WC_INIT            = 1
WC_SWP             = 2
WC_DEFWINDOWPROC   = 3
WC_MINMAX          = 4
WC_MOVE            = 5
WC_SIZE            = 6
WC_DRAWCAPTION     = 7
;

; Message Structure used in Journaling
EVENTMSG    struc
    message     dw ?
    paramL      dw ?
    paramH      dw ?
    time        dd ?
EVENTMSG    ends

ENDIF ;NOWH

; Window field offsets for GetWindowLong() and GetWindowWord()
GWL_WNDPROC       =  (-4)
GWW_HINSTANCE     =  (-6)
GWW_HWNDPARENT    =  (-8)
GWW_ID            =  (-12)
GWL_STYLE         =  (-16)
GWL_EXSTYLE       =  (-20)

; GetWindow() Constants
GW_HWNDFIRST	  =  0
GW_HWNDLAST	  =  1
GW_HWNDNEXT	  =  2
GW_HWNDPREV	  =  3
GW_OWNER	  =  4
GW_CHILD	  =  5

; Class field offsets for GetClassLong() and GetClassWord()
GCL_MENUNAME      =  (-8)
GCW_HBRBACKGROUND =  (-10)
GCW_HCURSOR       =  (-12)
GCW_HICON         =  (-14)
GCW_HMODULE       =  (-16)
GCW_CBWNDEXTRA    =  (-18)
GCW_CBCLSEXTRA    =  (-20)
GCL_WNDPROC       =  (-24)
GCW_STYLE         =  (-26)

; WinWhere() Area Codes
HTERROR           =  (-2)
HTTRANSPARENT     =  (-1)
HTNOWHERE         =  0
HTCLIENT          =  1
HTCAPTION         =  2
HTSYSMENU         =  3
HTGROWBOX         =  4
HTSIZE            =  HTGROWBOX
HTMENU            =  5
HTHSCROLL         =  6
HTVSCROLL         =  7
HTREDUCE          =  8
HTZOOM            =  9
HTLEFT            =  10
HTRIGHT           =  11
HTTOP             =  12
HTTOPLEFT         =  13
HTTOPRIGHT        =  14
HTBOTTOM          =  15
HTBOTTOMLEFT      =  16
HTBOTTOMRIGHT     =  17
HTSIZEFIRST       =  HTLEFT
HTSIZELAST        =  HTBOTTOMRIGHT



;*************************************************************************
;
;       Misc structures & constants
;
;*************************************************************************

IFNDEF  NOMST
POINT   struc
        ptX             dw      ?
        ptY             dw      ?
POINT   ends

LOGPEN struc
    lopnStyle       dw ?
    lopnWidth       db (SIZE POINT) DUP(?)
    lopnColor       dd ?
LOGPEN ends


BITMAP STRUC
        bmType         DW ?
        bmWidth        DW ?
        bmHeight       DW ?
        bmWidthBytes   DW ?
        bmPlanes       DB ?
        bmBitsPixel    DB ?
        bmBits         DD ?
BITMAP ENDS

RGBTRIPLE	struc
	rgbBlue		db ?
	rgbGreen	db ?
	rgbRed		db ?
RGBTRIPLE	ends

RGBQUAD         struc
        rgbqBlue        db ?
        rgbqGreen       db ?
        rgbqRed         db ?
        rgbqReserved    db ?
RGBQUAD         ends

; structures for defining DIBs
BITMAPCOREHEADER struc
        bcSize      dd ?
        bcWidth     dw ?
        bcHeight    dw ?
        bcPlanes    dw ?
        bcBitCount  dw ?
BITMAPCOREHEADER ends

BITMAPINFOHEADER struc
        biSize           dd ?
        biWidth          dd ?
        biHeight         dd ?
        biPlanes         dw ?
        biBitCount       dw ?

        biCompression    dd ?
        biSizeImage      dd ?
        biXPelsPerMeter  dd ?
        biYPelsPerMeter  dd ?
        biClrUsed        dd ?
        biClrImportant   dd ?
BITMAPINFOHEADER ends

BITMAPINFO  struc
    bmiHeader   db (SIZE BITMAPINFOHEADER) DUP (?)
    bmiColors   db ?            ; array of RGBQUADs
BITMAPINFO  ends

BITMAPCOREINFO  struc
    bmciHeader  db (SIZE BITMAPCOREHEADER) DUP (?)
    bmciColors  db ?            ; array of RGBTRIPLEs
BITMAPCOREINFO  ends

BITMAPFILEHEADER struc
    bfType          dw ?
    bfSize          dd ?
    bfReserved1     dw ?
    bfReserved2     dw ?
    bfOffBits       dd ?
BITMAPFILEHEADER ends


WNDSTRUC struc
        WSwndStyle        dd      ?
        WSwndID           dw      ?
        WSwndText         dw      ?
        WSwndParent       dw      ?
        WSwndInstance     dw      ?
        WSwndClassProc    dd      ?
WNDSTRUC ends
;
;  Message structure
;
MSGSTRUCT       struc
msHWND          dw      ?
msMESSAGE       dw      ?
msWPARAM        dw      ?
msLPARAM        dd      ?
msTIME          dd      ?
msPT            dd      ?
MSGSTRUCT       ends

NEWPARMS struc
        nprmHwnd        dw      ?
        nprmCmd         db      ?
NEWPARMS ends
ENDIF

PAINTSTRUCT STRUC
    PShdc         DW ?
    PSfErase      DW ?
    PSrcPaint     DB size RECT dup(?)
    PSfRestore    DW ?
    PSfIncUpdate  DW ?
    PSrgbReserved DB 16 dup(?)
PAINTSTRUCT ENDS


CREATESTRUCT struc
    cs_lpCreateParams  dd ?
    cs_hInstance       dw ?
    cs_hMenu           dw ?
    cs_hwndParent      dw ?
    cs_cy              dw ?
    cs_cx              dw ?
    cs_y               dw ?
    cs_x               dw ?
    cs_style           dd ?
    cs_lpszName        dd ?
    cs_lpszClass       dd ?
    cs_dwExStyle       dd ?
CREATESTRUCT  ends
;
;       PostError constants
;
WARNING     = 0           ; command codes
MINOR_ERROR = 1
FATAL_ERROR = 2

IGNORE      = 0           ; response codes
RETRY       = 1
ABORT       = 2
;
; GDI-related constants & commands
;
ERRORREGION     = 0
NULLREGION      = 1
SIMPLEREGION    = 2
COMPLEXREGION   = 3

IFNDEF NORASTOPS
;
; Binary raster ops
;
R2_BLACK        =  1
R2_NOTMERGEPEN  =  2
R2_MASKNOTPEN   =  3
R2_NOTCOPYPEN   =  4
R2_MASKPENNOT   =  5
R2_NOT          =  6
R2_XORPEN       =  7
R2_NOTMASKPEN   =  8
R2_MASKPEN      =  9
R2_NOTXORPEN    = 10
R2_NOP          = 11
R2_MERGENOTPEN  = 12
R2_COPYPEN      = 13
R2_MERGEPENNOT  = 14
R2_MERGEPEN     = 15
R2_WHITE        = 16
;
; Ternary raster ops
;
SRCCOPY_L     = 0020h   ;dest=source
SRCCOPY_H     = 00CCh
SRCPAINT_L    = 0086h   ;dest=source OR dest
SRCPAINT_H    = 00EEh
SRCAND_L      = 00C6h   ;dest=source AND   dest
SRCAND_H      = 0088h
SRCINVERT_L   = 0046h   ;dest= source XOR      dest
SRCINVERT_H   = 0066h
SRCERASE_L    = 0328h   ;dest= source AND (not dest )
SRCERASE_H    = 0044h
NOTSRCCOPY_L  = 0008h   ;dest= (not source)
NOTSRCCOPY_H  = 0033h
NOTSRCERASE_L = 00A6h   ;dest= (not source) AND (not dest)
NOTSRCERASE_H = 0011h
MERGECOPY_L   = 00CAh   ;dest= (source AND pattern)
MERGECOPY_H   = 00C0h
MERGEPAINT_L  = 0226h   ;dest= (source AND pattern) OR dest
MERGEPAINT_H  = 00BBh
PATCOPY_L     = 0021h   ;dest= pattern
PATCOPY_H     = 00F0h
PATPAINT_L    = 0A09h   ;DPSnoo
PATPAINT_H    = 00FBh
PATINVERT_L   = 0049h   ;dest= pattern XOR     dest
PATINVERT_H   = 005Ah
DSTINVERT_L   = 0009h   ;dest= (not dest)
DSTINVERT_H   = 0055h
BLACKNESS_L   = 0042h   ;dest= BLACK
BLACKNESS_H   = 0000h
WHITENESS_L   = 0062h   ;dest= WHITE
WHITENESS_H   = 00FFh
;
; StretchBlt modes
;
BLACKONWHITE    = 1
WHITEONBLACK    = 2
COLORONCOLOR    = 3
;
; New StretchBlt modes
;
STRETCH_ANDSCANS    = 1
STRETCH_ORSCANS     = 2
STRETCH_DELETESCANS = 3
;
; PolyFill modes
;
ALTERNATE       = 1
WINDING         = 2
ENDIF
;
; Text Alignment Options
;
TA_NOUPDATECP   =  0
TA_UPDATECP     =  1

TA_LEFT         =  0
TA_RIGHT        =  2
TA_CENTER       =  6

TA_TOP          =  0
TA_BOTTOM       =  8
TA_BASELINE     =  24

ETO_GRAYED      =  1
ETO_OPAQUE      =  2
ETO_CLIPPED     =  4

ASPECT_FILTERING = 1

ifndef NOMETAFILE

; Metafile Functions */
META_SETBKCOLOR            =  0201h
META_SETBKMODE             =  0102h
META_SETMAPMODE            =  0103h
META_SETROP2               =  0104h
META_SETRELABS             =  0105h
META_SETPOLYFILLMODE       =  0106h
META_SETSTRETCHBLTMODE     =  0107h
META_SETTEXTCHAREXTRA      =  0108h
META_SETTEXTCOLOR          =  0209h
META_SETTEXTJUSTIFICATION  =  020Ah
META_SETWINDOWORG          =  020Bh
META_SETWINDOWEXT          =  020Ch
META_SETVIEWPORTORG        =  020Dh
META_SETVIEWPORTEXT        =  020Eh
META_OFFSETWINDOWORG       =  020Fh
META_SCALEWINDOWEXT        =  0400h
META_OFFSETVIEWPORTORG     =  0211h
META_SCALEVIEWPORTEXT      =  0412h
META_LINETO                =  0213h
META_MOVETO                =  0214h
META_EXCLUDECLIPRECT       =  0415h
META_INTERSECTCLIPRECT     =  0416h
META_ARC                   =  0817h
META_ELLIPSE               =  0418h
META_FLOODFILL             =  0419h
META_PIE                   =  081Ah
META_RECTANGLE             =  041Bh
META_ROUNDRECT             =  061Ch
META_PATBLT                =  061Dh
META_SAVEDC                =  001Eh
META_SETPIXEL              =  041Fh
META_OFFSETCLIPRGN         =  0220h
META_TEXTOUT               =  0521h
META_BITBLT                =  0922h
META_STRETCHBLT            =  0B23h
META_POLYGON               =  0324h
META_POLYLINE              =  0325h
META_ESCAPE                =  0626h
META_RESTOREDC             =  0127h
META_FILLREGION            =  0228h
META_FRAMEREGION           =  0429h
META_INVERTREGION          =  012Ah
META_PAINTREGION           =  012Bh
META_SELECTCLIPREGION      =  012Ch
META_SELECTOBJECT          =  012Dh
META_SETTEXTALIGN          =  012Eh
META_DRAWTEXT              =  062Fh

META_CHORD		   =  0830h
META_SETMAPPERFLAGS	   =  0231h
META_EXTTEXTOUT		   =  0a32h
META_SETDIBTODEV	   =  0d33h
META_SELECTPALETTE	   =  0234h
META_REALIZEPALETTE	   =  0035h
META_ANIMATEPALETTE	   =  0436h
META_SETPALENTRIES	   =  0037h
META_POLYPOLYGON	   =  0538h
META_RESIZEPALETTE	   =  0139h

META_DIBBITBLT		   =  0940h
META_DIBSTRETCHBLT	   =  0b41h
META_DIBCREATEPATTERNBRUSH =  0142h
META_STRETCHDIB		   =  0f43h

META_DELETEOBJECT	   =  01f0h

META_CREATEPALETTE	   =  00f7h
META_CREATEBRUSH           =  00F8h
META_CREATEPATTERNBRUSH    =  01F9h
META_CREATEPENINDIRECT     =  02FAh
META_CREATEFONTINDIRECT    =  02FBh
META_CREATEBRUSHINDIRECT   =  02FCh
META_CREATEBITMAPINDIRECT  =  02FDh
META_CREATEBITMAP          =  06FEh
META_CREATEREGION          =  06FFh

; /* Clipboard Metafile Picture Structure */
HANDLETABLE struc
    ht_objectHandle  dw      ?
HANDLETABLE ends

METARECORD struc
    mr_rdSize	     dd      ?
    mr_rdFunction    dw      ?
    mr_rdParm	     dw      ?
METARECORD ends

METAFILEPICT struc
    mfp_mm	dw	?
    mfp_xExt	dw	?
    mfp_yExt	dw	?
    mfp_hMF	dw	?
METAFILEPICT ends

METAHEADER struc
  mtType	dw	?
  mtHeaderSize	dw	?
  mtVersion	dw	?
  mtSize	dd	?
  mtNoObjects	dw	?
  mtMaxRecord	dd	?
  mtNoParameters dw	?
METAHEADER ends

endif ; NOMETAFILE

; GDI Escapes
NEWFRAME                  =   1
ABORTDOC                  =   2
NEXTBAND                  =   3
SETCOLORTABLE             =   4
GETCOLORTABLE             =   5
FLUSHOUTPUT               =   6
DRAFTMODE                 =   7
QUERYESCSUPPORT           =   8
SETABORTPROC              =   9
STARTDOC                  =   10
;; This value conflicts with a std WIN386 MACRO definition
;;ENDDOC		    =	11
GETPHYSPAGESIZE           =   12
GETPRINTINGOFFSET         =   13
GETSCALINGFACTOR          =   14
MFCOMMENT                 =   15
GETPENWIDTH               =   16
SETCOPYCOUNT              =   17
SELECTPAPERSOURCE         =   18
DEVICEDATA                =   19
PASSTHROUGH               =   19
GETTECHNOLGY		  =   20
GETTECHNOLOGY		  =   20
SETENDCAP                 =   21
SETLINEJOIN               =   22
SETMITERLIMIT             =   23
BANDINFO                  =   24
DRAWPATTERNRECT           =   25
GETVECTORPENSIZE          =   26
GETVECTORBRUSHSIZE        =   27
ENABLEDUPLEX              =   28
ENABLEMANUALFEED	  =   29
GETSETPAPERBINS 	  =   29
GETSETPRINTORIENT	  =   30
ENUMPAPERBINS		  =   31

GETEXTENDEDTEXTMETRICS    =   256
GETEXTENTTABLE            =   257
GETPAIRKERNTABLE          =   258
GETTRACKKERNTABLE         =   259

EXTTEXTOUT                =   512

ENABLERELATIVEWIDTHS      =   768
ENABLEPAIRKERNING         =   769
SETKERNTRACK              =   770
SETALLJUSTVALUES	  =   771
SETCHARSET		  =   772

GETSETSCREENPARAMS        =   3072

STRETCHBLT                =   2048


; Spooler Error Codes
SP_NOTREPORTED            =   4000h
SP_ERROR                  =   (-1)
SP_APPABORT               =   (-2)
SP_USERABORT              =   (-3)
SP_OUTOFDISK              =   (-4)
SP_OUTOFMEMORY            =   (-5)

PR_JOBSTATUS              =   0000

; Object Definitions for EnumObjects()
OBJ_PEN                   =   1
OBJ_BRUSH                 =   2

;
; Menu flags for Change/Check/Enable MenuItem
;
MF_INSERT       =   0000h
MF_CHANGE       =   0080h
MF_APPEND       =   0100h
MF_DELETE       =   0200h
MF_REMOVE       =   1000h

MF_BYCOMMAND    =   0000h
MF_BYPOSITION   =   0400h

MF_SEPARATOR    =   0800h

MF_ENABLED      =   0000h
MF_GRAYED       =   0001h
MF_DISABLED     =   0002h

MF_UNCHECKED    =   0000h
MF_CHECKED      =   0008h
MF_USECHECKBITMAPS= 0200h

MF_STRING       =   0000h
MF_BITMAP       =   0004h
MF_OWNERDRAW    =   0100h

MF_POPUP        =   0010h
MF_MENUBARBREAK =   0020h
MF_MENUBREAK    =   0040h

MF_UNHILITE     =   0000h
MF_HILITE       =   0080h

MF_SYSMENU      =   2000h
MF_HELP         =   4000h
MF_MOUSESELECT  =   8000h


;
;  System Menu Command Values
;
SC_SIZE        = 0F000h
SC_MOVE        = 0F010h
SC_MINIMIZE    = 0F020h
SC_MAXIMIZE    = 0F030h
SC_NEXTWINDOW  = 0F040h
SC_PREVWINDOW  = 0F050h
SC_CLOSE       = 0F060h
SC_VSCROLL     = 0F070h
SC_HSCROLL     = 0F080h
SC_MOUSEMENU   = 0F090h
SC_KEYMENU     = 0F100h
SC_ARRANGE     = 0F110h
SC_RESTORE     = 0F120h
SC_TASKLIST    = 0F130h
SC_SCREENSAVE  = 0F140h
SC_HOTKEY      = 0F150h

SC_ICON        = SC_MINIMIZE
SC_ZOOM        = SC_MAXIMIZE

;
;  Window State Messages
;
IFNDEF  NOWM
WM_STATE            = 0000H

WM_NULL             = 0000h
WM_CREATE           = 0001h
WM_DESTROY          = 0002h
WM_MOVE             = 0003h
WM_SIZEWAIT         = 0004h	;Internal
WM_SIZE             = 0005h
WM_ACTIVATE         = 0006h
WM_SETFOCUS         = 0007h
WM_KILLFOCUS        = 0008h
WM_SETVISIBLE       = 0009h	;Internal
WM_ENABLE           = 000Ah
WM_SETREDRAW        = 000Bh
WM_SETTEXT          = 000Ch
WM_GETTEXT          = 000Dh
WM_GETTEXTLENGTH    = 000Eh
WM_PAINT            = 000Fh
WM_CLOSE            = 0010h
WM_QUERYENDSESSION  = 0011h
WM_QUIT             = 0012h
WM_QUERYOPEN        = 0013h
WM_ERASEBKGND       = 0014h
WM_SYSCOLORCHANGE   = 0015h
WM_ENDSESSION       = 0016h
WM_SYSTEMERROR      = 0017h
WM_SHOWWINDOW       = 0018h
WM_CTLCOLOR         = 0019h
WM_WININICHANGE     = 001Ah
WM_DEVMODECHANGE    = 001Bh
WM_ACTIVATEAPP      = 001Ch
WM_FONTCHANGE       = 001Dh
WM_TIMECHANGE       = 001Eh
WM_CANCELMODE       = 001Fh
WM_SETCURSOR        = 0020h
WM_MOUSEACTIVATE    = 0021h
WM_CHILDACTIVATE    = 0022h
WM_QUEUESYNC        = 0023h
WM_GETMINMAXINFO    = 0024h
WM_PAINTICON        = 0026h
WM_ICONERASEBKGND   = 0027h
WM_NEXTDLGCTL       = 0028h
WM_ALTTABACTIVE     = 0029h	;Internal
WM_SPOOLERSTATUS    = 002Ah
WM_DRAWITEM         = 002Bh
WM_MEASUREITEM      = 002Ch
WM_DELETEITEM       = 002Dh
WM_VKEYTOITEM       = 002Eh
WM_CHARTOITEM       = 002Fh
WM_SETFONT          = 0030h
WM_GETFONT          = 0031h
WM_SETHOTKEY        = 0032h     ;Internal
WM_GETHOTKEY        = 0033h     ;Internal
WM_FILESYSCHANGE    = 0034h	;Internal
WM_ISACTIVEICON     = 0035h	;Internal
WM_UNUSED0036       = 0036h	;Internal
WM_QUERYDRAGICON    = 0037h
WM_COMPAREITEM	    = 0039h
WM_TESTING	    = 0040h	;Internal
WM_COMPACTING       = 0041h
;                     0042h	;Internal
;                     0043h	;Internal
IFNDEF NOWIN31
WM_COMMNOTIFY       = 0044h
;                   = 0045h     ;Internal
WM_WINDOWPOSCHANGING= 0046h
WM_WINDOWPOSCHANGED = 0047h
WM_POWER            = 0048h
ENDIF


WM_NCCREATE         = 0081h
WM_NCDESTROY        = 0082h
WM_NCCALCSIZE       = 0083h
WM_NCHITTEST        = 0084h
WM_NCPAINT          = 0085h
WM_NCACTIVATE       = 0086h
WM_GETDLGCODE       = 0087h
WM_SYNCPAINT        = 0088h	;Internal
WM_SYNCTASK         = 0089h	;Internal
WM_NCMOUSEMOVE      = 00A0h
WM_NCLBUTTONDOWN    = 00A1h
WM_NCLBUTTONUP      = 00A2h
WM_NCLBUTTONDBLCLK  = 00A3h
WM_NCRBUTTONDOWN    = 00A4h
WM_NCRBUTTONUP      = 00A5h
WM_NCRBUTTONDBLCLK  = 00A6h
WM_NCMBUTTONDOWN    = 00A7h
WM_NCMBUTTONUP      = 00A8h
WM_NCMBUTTONDBLCLK  = 00A9h

WM_KEYFIRST         = 0100h
WM_KEYDOWN          = 0100h
WM_KEYUP            = 0101h
WM_CHAR             = 0102h
WM_DEADCHAR         = 0103h
WM_SYSKEYDOWN       = 0104h
WM_SYSKEYUP         = 0105h
WM_SYSCHAR          = 0106h
WM_SYSDEADCHAR      = 0107h
WM_YOMICHAR         = 0108h	;Internal
WM_KEYLAST          = 0108h

WM_CONVERTREQUEST   = 010Ah	;Internal
WM_CONVERTRESULT    = 010Bh	;Internal
WM_INITDIALOG       = 0110h
WM_COMMAND          = 0111h
WM_SYSCOMMAND       = 0112h
WM_TIMER            = 0113h
WM_HSCROLL          = 0114h
WM_VSCROLL          = 0115h
WM_INITMENU         = 0116h
WM_INITMENUPOPUP    = 0117h
WM_SYSTIMER         = 0118h	;Internal
WM_MENUSELECT       = 011Fh
WM_MENUCHAR         = 0120h
WM_ENTERIDLE        = 0121h

WM_LBTRACKPOINT     = 0131h	;Internal
			  
WM_MOUSEFIRST       = 0200h
WM_MOUSEMOVE        = 0200h
WM_LBUTTONDOWN      = 0201h
WM_LBUTTONUP        = 0202h
WM_LBUTTONDBLCLK    = 0203h
WM_RBUTTONDOWN      = 0204h
WM_RBUTTONUP        = 0205h
WM_RBUTTONDBLCLK    = 0206h
WM_MBUTTONDOWN      = 0207h
WM_MBUTTONUP        = 0208h
WM_MBUTTONDBLCLK    = 0209h
WM_MOUSELAST        = 0209h

WM_PARENTNOTIFY     = 0210h
WM_ENTERMENULOOP    = 0211h	;Internal
WM_EXITMENULOOP     = 0212h	;Internal
WM_NEXTMENU         = 0213h	;Internal
WM_MDICREATE        = 0220h
WM_MDIDESTROY       = 0221h
WM_MDIACTIVATE      = 0222h
WM_MDIRESTORE       = 0223h
WM_MDINEXT          = 0224h
WM_MDIMAXIMIZE      = 0225h
WM_MDITILE          = 0226h
WM_MDICASCADE       = 0227h
WM_MDIICONARRANGE   = 0228h
WM_MDIGETACTIVE     = 0229h
WM_DROPOBJECT       = 022Ah	;Internal
WM_QUERYDROPOBJECT  = 022Bh	;Internal
WM_BEGINDRAG        = 022Ch	;Internal
WM_DRAGLOOP         = 022Dh	;Internal
WM_DRAGSELECT       = 022Eh	;Internal
WM_DRAGMOVE         = 022Fh	;Internal
WM_MDISETMENU       = 0230h
WM_ENTERSIZEMOVE    = 0231h	;Internal
WM_EXITSIZEMOVE     = 0232h	;Internal
WM_DROPFILES	    = 0233h

WM_KANJIFIRST       = 0280h	;Internal
WM_KANJILAST        = 029Fh	;Internal

WM_CUT              = 0300h
WM_COPY             = 0301h
WM_PASTE            = 0302h
WM_CLEAR            = 0303h
WM_UNDO             = 0304h
WM_RENDERFORMAT     = 0305h
WM_RENDERALLFORMATS = 0306h
WM_DESTROYCLIPBOARD = 0307h
WM_DRAWCLIPBOARD    = 0308h
WM_PAINTCLIPBOARD   = 0309h
WM_VSCROLLCLIPBOARD = 030Ah
WM_SIZECLIPBOARD    = 030Bh
WM_ASKCBFORMATNAME  = 030Ch
WM_CHANGECBCHAIN    = 030Dh
WM_HSCROLLCLIPBOARD = 030Eh
WM_QUERYNEWPALETTE  = 030Fh
WM_PALETTEGONNACHANGE = 0310h	;Internal
WM_PALETTEISCHANGING = 0310h
WM_CHANGEPALETTE    = 0311h	;Internal
WM_PALETTECHANGED   = 0311h

IFNDEF NOWIN31
WM_PENWINFIRST      equ 0380h
WM_PENWINLAST       equ 038Fh

WM_INTERNAL_COALESCE_FIRST equ 0390h	 ;Internal

WM_COALESCE_FIRST  equ 0390h
WM_COALESCE_LAST   equ 039Fh

; The following message range reserved   ;Internal
; for multi-media                        ;Internal

WM_MM_RESERVED_FIRST  equ 03A0h          ;Internal
WM_MM_RESERVED_LAST   equ 03DFh          ;Internal

WM_INTERNAL_COALESCE_LAST equ (WM_MM_RESERVED_FIRST+16)	;Internal

ENDIF

WM_INTERNAL_DDE_FIRST equ 03E0h    ;Internal
WM_INTERNAL_DDE_LAST  equ 03EFh    ;Internal

; The following messages are reserved for CBT ;Internal
WM_CBT_RESERVED_FIRST equ 03F0h    ;Internal
WM_CBT_RESERVED_LAST  equ 03FFh    ;Internal

;  private window messages start here
WM_USER             = 0400H
ENDIF           ; NOWM

; WM_MOUSEACTIVATE Return Codes
MA_ACTIVATE       =  1
MA_ACTIVATEANDEAT =  2
MA_NOACTIVATE     =  3

; Size message commands
SIZENORMAL       = 0
SIZEICONIC       = 1
SIZEFULLSCREEN   = 2
SIZEZOOMSHOW     = 3
SIZEZOOMHIDE     = 4

; ShowWindow() Commands
SW_HIDE            = 0
SW_SHOWNORMAL      = 1
SW_NORMAL          = 1
SW_SHOWMINIMIZED   = 2
SW_SHOWMAXIMIZED   = 3
SW_MAXIMIZE        = 3
SW_SHOWNOACTIVATE  = 4
SW_SHOW            = 5
SW_MINIMIZE        = 6
SW_SHOWMINNOACTIVE = 7
SW_SHOWNA          = 8
SW_RESTORE         = 9

; Old ShowWindow() Commands
HIDE_WINDOW        = 0
SHOW_OPENWINDOW    = 1
SHOW_ICONWINDOW    = 2
SHOW_FULLSCREEN    = 3
SHOW_OPENNOACTIVATE= 4

;  identifiers for the WM_SHOWWINDOW message
SW_PARENTCLOSING =  1
SW_OTHERZOOM     =  2
SW_PARENTOPENING =  3
SW_OTHERUNZOOM   =  4
;
; Key state masks for mouse messages
;
MK_LBUTTON       = 0001h
MK_RBUTTON       = 0002h
MK_SHIFT         = 0004h
MK_CONTROL       = 0008h
MK_MBUTTON       = 0010h
;
; Class styles
;
CS_VREDRAW         = 0001h
CS_HREDRAW         = 0002h
CS_KEYCVTWINDOW    = 0004H
CS_DBLCLKS         = 0008h
; 		     0010h reserved
CS_OWNDC           = 0020h
CS_CLASSDC         = 0040h
CS_PARENTDC        = 0080h
CS_NOKEYCVT        = 0100h
CS_SAVEBITS        = 0800h
CS_NOCLOSE         = 0200h
CS_BYTEALIGNCLIENT = 1000h
CS_BYTEALIGNWINDOW = 2000h
CS_GLOBALCLASS     = 4000h    ; Global window class

;
; Special CreateWindow position value
;
CW_USEDEFAULT	EQU    8000h

;
; Windows styles (the high words)
;
WS_OVERLAPPED   = 00000h
WS_ICONICPOPUP  = 0C000h
WS_POPUP        = 08000h
WS_CHILD        = 04000h
WS_MINIMIZE     = 02000h
WS_VISIBLE      = 01000h
WS_DISABLED     = 00800h
WS_CLIPSIBLINGS = 00400h
WS_CLIPCHILDREN = 00200h
WS_MAXIMIZE     = 00100h
WS_CAPTION      = 000C0h     ; WS_BORDER | WS_DLGFRAME
WS_BORDER       = 00080h
WS_DLGFRAME     = 00040h
WS_VSCROLL      = 00020h
WS_HSCROLL      = 00010h
WS_SYSMENU      = 00008h
WS_THICKFRAME   = 00004h
WS_HREDRAW      = 00002h
WS_VREDRAW      = 00001h
WS_GROUP        = 00002h
WS_TABSTOP      = 00001h
WS_MINIMIZEBOX  = 00002h
WS_MAXIMIZEBOX  = 00001h

; Common Window Styles

WS_OVERLAPPEDWINDOW = WS_OVERLAPPED + WS_CAPTION + WS_SYSMENU + WS_THICKFRAME + WS_MINIMIZEBOX + WS_MAXIMIZEBOX
WS_POPUPWINDOW  = WS_POPUP + WS_BORDER + WS_SYSMENU
WS_CHILDWINDOW  = WS_CHILD
WS_TILEDWINDOW  = WS_OVERLAPPEDWINDOW

WS_TILED        = WS_OVERLAPPED
WS_ICONIC       = WS_MINIMIZE
WS_SIZEBOX      = WS_THICKFRAME

; Extended Window Styles (low words)
WS_EX_DLGMODALFRAME  = 0001
WS_EX_DRAGOBJECT     = 0002
WS_EX_NOPARENTNOTIFY = 0004
WS_EX_TOPMOST        = 0008

;
; predefined clipboard formats
;
CF_TEXT         =  1
CF_BITMAP       =  2
CF_METAFILEPICT =  3
CF_SYLK         =  4
CF_DIF          =  5
CF_TIFF         =  6
CF_OEMTEXT      =  7
CF_DIB          =  8
CF_PALETTE      =  9
CF_PENDATA      = 10
CF_RIFF         = 11
CF_WAVE         = 12

CF_OWNERDISPLAY = 80h       ; owner display
CF_DSPTEXT      = 81h       ; display text
CF_DSPBITMAP    = 82h       ; display bitmap
CF_DSPMETAFILEPICT  = 83h   ; display metafile
;
; Private clipboard format range
;
CF_PRIVATEFIRST       = 200h       ; Anything in this range doesn't
CF_PRIVATELAST        = 2ffh       ; get GlobalFree'd
CF_GDIOBJFIRST        = 300h       ; Anything in this range gets
CF_GDIOBJLAST         = 3ffh       ; DeleteObject'ed


MAKEINTRESOURCE MACRO a
        mov     ax,a
        xor     dx,dx
        ENDM
;
;  Predefined resource types
;
RT_CURSOR       = 1              ; must be passed through MAKEINTRESOURCE
RT_BITMAP       = 2
RT_ICON         = 3
RT_MENU         = 4
RT_DIALOG       = 5
RT_STRING       = 6
RT_FONTDIR      = 7
RT_FONT         = 8
RT_ACCELERATOR  = 9
RT_RCDATA       = 10

;** NOTE: if any new resource types are introduced above this point, then the
;** value of DIFFERENCE must be changed.
;** (RT_GROUP_CURSOR - RT_CURSOR) must always be equal to DIFFERENCE
;** (RT_GROUP_ICON - RT_ICON) must always be equal to DIFFERENCE

DIFFERENCE       =   11

RT_GROUP_CURSOR  =   RT_CURSOR + DIFFERENCE
RT_GROUP_ICON    =   RT_ICON + DIFFERENCE



IFNDEF NOMDI
MDICREATESTRUCT     struc
    szClass	    dd ?
    szTitle	    dd ?
    hOwner	    dw ?
    x		    dw ?
    y		    dw ?
    cxc 	    dw ?
    cyc 	    dw ?
    style	    dd ?
MDICREATESTRUCT ends

CLIENTCREATESTRUCT  struc
    hWindowMenu     dw ?
    idFirstChild    dw ?
CLIENTCREATESTRUCT ends
ENDIF

; NOMDI


PALETTEENTRY	    struc
    peRed	    db ?
    peGreen	    db ?
    peBlue	    db ?
    peFlags	    db ?
PALETTEENTRY	    ends

; Logical Palette
LOGPALETTE	    struc
    palVersion	    dw ?
    palNumEntries   dw ?
    palPalEntry     db ?  ; array of PALETTEENTRY
LOGPALETTE	    ends

; DRAWITEMSTRUCT for ownerdraw
DRAWITEMSTRUCT	    struc
    drCtlType	      dw ?
    drCtlID	      dw ?
    dritemID	      dw ?
    dritemAction      dw ?
    dritemState       dw ?
    drhwndItem	      dw ?
    drhDC	      dw ?
    drrcItem	      DB size RECT dup(?)
    dritemData	      dd ?
DRAWITEMSTRUCT ends

; DELETEITEMSTRUCT for ownerdraw
DELETEITEMSTRUCT    struc
    deCtlType	      dw ?
    deCtlID	      dw ?
    deitemID	      dw ?
    dehwndItem	      dw ?
    deitemData	      dd ?
DELETEITEMSTRUCT ends

; MEASUREITEMSTRUCT for ownerdraw
MEASUREITEMSTRUCT   struc
    meCtlType	      dw ?
    meCtlID	      dw ?
    meitemID	      dw ?
    meitemWidth       dw ?
    meitemHeight      dw ?
    meitemData	      dd ?
MEASUREITEMSTRUCT ends

; COMPAREITEMSTUCT for ownerdraw sorting
COMPAREITEMSTRUCT   struc
    coCtlType   dw ?
    coCtlID     dw ?
    cohwndItem  dw ?
    coitemID1   dw ?
    coitemData1 dd ?
    coitemID2   dw ?
    coitemData2 dd ?
COMPAREITEMSTRUCT   ends

; Owner draw control types
ODT_MENU      =  1
ODT_LISTBOX   =  2
ODT_COMBOBOX  =  3
ODT_BUTTON    =  4

; Owner draw actions
ODA_DRAWENTIRE = 1
ODA_SELECT     = 2
ODA_FOCUS      = 4

; Owner draw state
ODS_SELECTED   = 0001h
ODS_GRAYED     = 0002h
ODS_DISABLED   = 0004h
ODS_CHECKED    = 0008h
ODS_FOCUS      = 0010h

; PeekMessage() Options
PM_NOREMOVE    = 0000h
PM_REMOVE      = 0001h
PM_NOYIELD     = 0002h

; SetWindowPos Flags
SWP_NOSIZE       =  0001h
SWP_NOMOVE       =  0002h
SWP_NOZORDER     =  0004h
SWP_NOREDRAW     =  0008h
SWP_NOACTIVATE   =  0010h
SWP_DRAWFRAME    =  0020h
SWP_SHOWWINDOW   =  0040h
SWP_HIDEWINDOW   =  0080h
SWP_NOCOPYBITS   =  0100h
SWP_NOREPOSITION =  0200h


IFNDEF NOWINMESSAGES

; Listbox messages
LB_ADDSTRING	       = (WM_USER+1)
LB_INSERTSTRING        = (WM_USER+2)
LB_DELETESTRING        = (WM_USER+3)
LB_RESETCONTENT        = (WM_USER+5)
LB_SETSEL	       = (WM_USER+6)
LB_SETCURSEL	       = (WM_USER+7)
LB_GETSEL	       = (WM_USER+8)
LB_GETCURSEL	       = (WM_USER+9)
LB_GETTEXT	       = (WM_USER+10)
LB_GETTEXTLEN	       = (WM_USER+11)
LB_GETCOUNT	       = (WM_USER+12)
LB_SELECTSTRING        = (WM_USER+13)
LB_DIR		       = (WM_USER+14)
LB_GETTOPINDEX	       = (WM_USER+15)
LB_FINDSTRING	       = (WM_USER+16)
LB_GETSELCOUNT	       = (WM_USER+17)
LB_GETSELITEMS	       = (WM_USER+18)
LB_SETTABSTOPS	       = (WM_USER+19)
LB_GETHORIZONTALEXTENT = (WM_USER+20)
LB_SETHORIZONTALEXTENT = (WM_USER+21)
LB_ADDFILE	       = (WM_USER+23)	;Internal
LB_SETTOPINDEX	       = (WM_USER+24)
LB_GETITEMRECT	       = (WM_USER+25)
LB_GETITEMDATA	       = (WM_USER+26)
LB_SETITEMDATA	       = (WM_USER+27)
LB_SELITEMRANGE        = (WM_USER+28)
LB_SETANCHORINDEX      = (WM_USER+29)	;Internal
LB_GETANCHORINDEX      = (WM_USER+30)	;Internal
LB_SETCARETINDEX       = (WM_USER+31)
LB_GETCARETINDEX       = (WM_USER+32)
IFNDEF NOWIN31
LB_SETITEMHEIGHT       = (WM_USER+33)
LB_GETITEMHEIGHT       = (WM_USER+34)
LB_FINDSTRINGEXACT     = (WM_USER+35)
ENDIF
LBCB_CARETON           = (WM_USER+36)   ;Internal
LBCB_CARETOFF          = (WM_USER+37)   ;Internal
LB_MSGMAX	       = (WM_USER+38)   ;Internal

ENDIF
; NOWINMESSAGES

; Listbox Styles
LBS_NOTIFY            = 0001h
LBS_SORT              = 0002h
LBS_NOREDRAW          = 0004h
LBS_MULTIPLESEL       = 0008h
LBS_OWNERDRAWFIXED    = 0010h
LBS_OWNERDRAWVARIABLE = 0020h
LBS_HASSTRINGS        = 0040h
LBS_USETABSTOPS       = 0080h
LBS_NOINTEGRALHEIGHT  = 0100h
LBS_MULTICOLUMN       = 0200h
LBS_WANTKEYBOARDINPUT = 0400h
LBS_EXTENDEDSEL	      = 0800h
LBS_STANDARD          = LBS_NOTIFY + LBS_SORT + WS_VSCROLL + WS_BORDER
LBS_DISABLENOSCROLL   = 1000h

; Listbox Notification Codes
LBN_ERRSPACE      =  (-2)
LBN_SELCHANGE     =  1
LBN_DBLCLK        =  2
LBN_SELCANCEL     =  3
LBN_SETFOCUS      =  4
LBN_KILLFOCUS     =  5

IFNDEF NOWINMESSAGES

; Edit Control Messages
EM_GETSEL              = (WM_USER+0)
EM_SETSEL              = (WM_USER+1)
EM_GETRECT             = (WM_USER+2)
EM_SETRECT             = (WM_USER+3)
EM_SETRECTNP           = (WM_USER+4)
EM_SCROLL              = (WM_USER+5)
EM_LINESCROLL          = (WM_USER+6)
EM_GETMODIFY           = (WM_USER+8)
EM_SETMODIFY           = (WM_USER+9)
EM_GETLINECOUNT        = (WM_USER+10)
EM_LINEINDEX           = (WM_USER+11)
EM_SETHANDLE           = (WM_USER+12)
EM_GETHANDLE           = (WM_USER+13)
EM_GETTHUMB            = (WM_USER+14) ;Internal
EM_LINELENGTH          = (WM_USER+17)
EM_REPLACESEL          = (WM_USER+18)
EM_SETFONT             = (WM_USER+19)
EM_GETLINE             = (WM_USER+20)
EM_LIMITTEXT           = (WM_USER+21)
EM_CANUNDO             = (WM_USER+22)
EM_UNDO                = (WM_USER+23)
EM_FMTLINES            = (WM_USER+24)
EM_LINEFROMCHAR        = (WM_USER+25)
EM_SETWORDBREAK        = (WM_USER+26)
EM_SETTABSTOPS         = (WM_USER+27)
EM_SETPASSWORDCHAR     = (WM_USER+28)
EM_EMPTYUNDOBUFFER     = (WM_USER+29)
IFNDEF NOWIN31
EM_GETFIRSTVISIBLELINE = (WM_USER+30)
EM_SETREADONLY         = (WM_USER+31)
EM_SETWORDBREAKPROC    = (WM_USER+32)
EM_GETWORDBREAKPROC    = (WM_USER+33)
EM_GETPASSWORDCHAR     = (WM_USER+34)
ENDIF
EM_MSGMAX              = (WM_USER+35) ;Internal

ENDIF
; NOWINMESSAGES


; Edit Control Styles (low word)
ES_LEFT            = 0000h
ES_CENTER          = 0001h
ES_RIGHT           = 0002h
ES_MULTILINE       = 0004h
ES_UPPERCASE       = 0008h
ES_LOWERCASE       = 0010h
ES_PASSWORD        = 0020h
ES_AUTOVSCROLL     = 0040h
ES_AUTOHSCROLL     = 0080h
ES_NOHIDESEL       = 0100h
ES_OEMCONVERT      = 0400h
IFNDEF NOWIN31
ES_READONLY        = 0800h
ES_WANTRETURN      = 1000h
ENDIF


; Edit Control Notification Codes
EN_SETFOCUS        = 0100h
EN_KILLFOCUS       = 0200h
EN_CHANGE          = 0300h
EN_UPDATE          = 0400h
EN_ERRSPACE        = 0500h
EN_MAXTEXT         = 0501h
EN_HSCROLL         = 0601h
EN_VSCROLL         = 0602h

IFNDEF NOWINMESSAGES

; Button Control Messages
BM_GETCHECK	   = (WM_USER+0)
BM_SETCHECK	   = (WM_USER+1)
BM_GETSTATE	   = (WM_USER+2)
BM_SETSTATE	   = (WM_USER+3)
BM_SETSTYLE	   = (WM_USER+4)

ENDIF
; NOWINMESSAGES

; Button Control Styles (low word)
BS_PUSHBUTTON      = 00h
BS_DEFPUSHBUTTON   = 01h
BS_CHECKBOX        = 02h
BS_AUTOCHECKBOX    = 03h
BS_RADIOBUTTON     = 04h
BS_3STATE          = 05h
BS_AUTO3STATE      = 06h
BS_GROUPBOX        = 07h
BS_USERBUTTON      = 08h
BS_AUTORADIOBUTTON = 09h
BS_PUSHBOX         = 0Ah  		;Internal
BS_OWNERDRAW       = 0Bh
BS_LEFTTEXT        = 20h

; User Button Notification Codes
BN_CLICKED         = 0
BN_PAINT           = 1
BN_HILITE          = 2
BN_UNHILITE        = 3
BN_DISABLE         = 4
BN_DOUBLECLICKED   = 5

; Dialog Styles (low words)
DS_ABSALIGN        = 01h
DS_SYSMODAL        = 02h
DS_LOCALEDIT       = 20h  ;/* Edit items get Local storage. */
DS_SETFONT         = 40h  ;/* User specified font for Dlg controls */
DS_MODALFRAME      = 80h  ;/* Can be combined with WS_CAPTION  */
DS_NOIDLEMSG       = 100h ;/* WM_ENTERIDLE message will not be sent */

IFNDEF NOWINMESSAGES

; Dialog box messages
DM_GETDEFID	   = (WM_USER+0)
DM_SETDEFID	   = (WM_USER+1)

ENDIF   ;NOWINMESSAGES

; Dialog Codes
DLGC_WANTARROWS     = 0001h    ;  /* Control wants arrow keys         */
DLGC_WANTTAB        = 0002h    ;  /* Control wants tab keys           */
DLGC_WANTALLKEYS    = 0004h    ;  /* Control wants all keys           */
DLGC_WANTMESSAGE    = 0004h    ;  /* Pass message to control          */
DLGC_HASSETSEL      = 0008h    ;  /* Understands EM_SETSEL message    */
DLGC_DEFPUSHBUTTON  = 0010h    ;  /* Default pushbutton               */
DLGC_UNDEFPUSHBUTTON= 0020h    ;  /* Non-default pushbutton           */
DLGC_RADIOBUTTON    = 0040h    ;  /* Radio button                     */
DLGC_WANTCHARS      = 0080h    ;  /* Want WM_CHAR messages            */
DLGC_STATIC         = 0100h    ;  /* Static item: don't include       */
DLGC_BUTTON         = 2000h    ;  /* Button item: can be checked      */

; Combo Box return Values
CB_OKAY          =   0
CB_ERR           =   (-1)
CB_ERRSPACE      =   (-2)

; Combo Box Notification Codes
CBN_ERRSPACE     =   (-1)
CBN_SELCHANGE    =   1
CBN_DBLCLK       =   2
CBN_SETFOCUS     =   3
CBN_KILLFOCUS    =   4
CBN_EDITCHANGE   =   5
CBN_EDITUPDATE   =   6
CBN_DROPDOWN     =   7

; Combo Box styles (low words)
CBS_SIMPLE           = 0001h
CBS_DROPDOWN         = 0002h
CBS_DROPDOWNLIST     = 0003h
CBS_OWNERDRAWFIXED   = 0010h
CBS_OWNERDRAWVARIABLE= 0020h
CBS_AUTOHSCROLL      = 0040h
CBS_OEMCONVERT       = 0080h
CBS_SORT             = 0100h
CBS_HASSTRINGS       = 0200h
CBS_NOINTEGRALHEIGHT = 0400h

IFNDEF NOWINMESSAGES

; Combo Box messages
CB_GETEDITSEL	         = (WM_USER+0)
CB_LIMITTEXT	         = (WM_USER+1)
CB_SETEDITSEL	         = (WM_USER+2)
CB_ADDSTRING	         = (WM_USER+3)
CB_DELETESTRING          = (WM_USER+4)
CB_DIR		         = (WM_USER+5)
CB_GETCOUNT	         = (WM_USER+6)
CB_GETCURSEL	         = (WM_USER+7)
CB_GETLBTEXT	         = (WM_USER+8)
CB_GETLBTEXTLEN          = (WM_USER+9)
CB_INSERTSTRING          = (WM_USER+10)
CB_RESETCONTENT          = (WM_USER+11)
CB_FINDSTRING	         = (WM_USER+12)
CB_SELECTSTRING          = (WM_USER+13)
CB_SETCURSEL	         = (WM_USER+14)
CB_SHOWDROPDOWN          = (WM_USER+15)
CB_GETITEMDATA           = (WM_USER+16)
CB_SETITEMDATA           = (WM_USER+17)
IFNDEF NOWIN31
CB_GETDROPPEDCONTROLRECT = (WM_USER+18)
CB_SETITEMHEIGHT         = (WM_USER+19)
CB_GETITEMHEIGHT         = (WM_USER+20)
CB_SETEXTENDEDUI         = (WM_USER+21)
CB_GETEXTENDEDUI         = (WM_USER+22)
CB_GETDROPPEDSTATE       = (WM_USER+23)
CB_FINDSTRINGEXACT       = (WM_USER+24)
ENDIF
CB_MSGMAX	         = (WM_USER+25)		;Internal

ENDIF ; NOWINMESSAGES

; Static Control styles (low word)
SS_LEFT            = 00h
SS_CENTER          = 01h
SS_RIGHT           = 02h
SS_ICON            = 03h
SS_BLACKRECT       = 04h
SS_GRAYRECT        = 05h
SS_WHITERECT       = 06h
SS_BLACKFRAME      = 07h
SS_GRAYFRAME       = 08h
SS_WHITEFRAME      = 09h
SS_USERITEM        = 0Ah    ;Internal
SS_SIMPLE          = 0Bh
SS_LEFTNOWORDWRAP  = 0Ch
SS_NOPREFIX        = 80h    ; Don't do "&" character translation

IFNDEF NOWIN31
IFNDEF NOWINMESSAGES

;Static Control Messages
STM_SETICON        = (WM_USER+0)
STM_GETICON        = (WM_USER+1)
STM_MSGMAX         = (WM_USER+2)	;Internal
ENDIF
ENDIF

; Scroll Bar Styles (low word)
SBS_HORZ                    = 0000h
SBS_VERT                    = 0001h
SBS_TOPALIGN                = 0002h
SBS_LEFTALIGN               = 0002h
SBS_BOTTOMALIGN             = 0004h
SBS_RIGHTALIGN              = 0004h
SBS_SIZEBOXTOPLEFTALIGN     = 0002h
SBS_SIZEBOXBOTTOMRIGHTALIGN = 0004h
SBS_SIZEBOX                 = 0008h

IFNDEF NOSYSMETRICS

; GetSystemMetrics() codes
SM_CXSCREEN           =  0
SM_CYSCREEN           =  1
SM_CXVSCROLL          =  2
SM_CYHSCROLL          =  3
SM_CYCAPTION          =  4
SM_CXBORDER           =  5
SM_CYBORDER           =  6
SM_CXDLGFRAME         =  7
SM_CYDLGFRAME         =  8
SM_CYVTHUMB           =  9
SM_CXHTHUMB           =  10
SM_CXICON             =  11
SM_CYICON             =  12
SM_CXCURSOR           =  13
SM_CYCURSOR           =  14
SM_CYMENU             =  15
SM_CXFULLSCREEN       =  16
SM_CYFULLSCREEN       =  17
SM_CYKANJIWINDOW      =  18
SM_MOUSEPRESENT       =  19
SM_CYVSCROLL          =  20
SM_CXHSCROLL          =  21
SM_DEBUG              =  22
SM_SWAPBUTTON         =  23
SM_RESERVED1          =  24
SM_RESERVED2          =  25
SM_RESERVED3          =  26
SM_RESERVED4          =  27
SM_CXMIN              =  28
SM_CYMIN              =  29
SM_CXSIZE             =  30
SM_CYSIZE             =  31
SM_CXFRAME            =  32
SM_CYFRAME            =  33
SM_CXMINTRACK         =  34
SM_CYMINTRACK         =  35
IFNDEF NOWIN31
SM_CXDOUBLECLK        =  36
SM_CYDOUBLECLK        =  37
SM_CXICONSPACING      =  38
SM_CYICONSPACING      =  39
SM_MENUDROPALIGNMENT  =  40
SM_PENWINDOWS         =  41
SM_DBCSENABLED        =  42
ENDIF
SM_CMETRICSMAX        =  76

ENDIF   ;NOSYSMETRICS

IFNDEF  NOCOLOR

COLOR_SCROLLBAR           = 0
COLOR_BACKGROUND          = 1
COLOR_ACTIVECAPTION       = 2
COLOR_INACTIVECAPTION     = 3
COLOR_MENU                = 4
COLOR_WINDOW              = 5
COLOR_WINDOWFRAME         = 6
COLOR_MENUTEXT            = 7
COLOR_WINDOWTEXT          = 8
COLOR_CAPTIONTEXT         = 9
COLOR_ACTIVEBORDER        = 10
COLOR_INACTIVEBORDER      = 11
COLOR_APPWORKSPACE        = 12
COLOR_HIGHLIGHT           = 13
COLOR_HIGHLIGHTTEXT       = 14
COLOR_BTNFACE             = 15
COLOR_BTNSHADOW           = 16
COLOR_GRAYTEXT            = 17
COLOR_BTNTEXT             = 18
IFNDEF NOWIN31
COLOR_INACTIVECAPTIONTEXT = 19
COLOR_BTNHILIGHT          = 20
ENDIF
ENDIF   ;NOCOLOR

; Commands to pass WinHelp()
HELP_CONTEXT	=0001h	;/* Display topic in ulTopic */
HELP_QUIT	=0002h	;/* Terminate help */
HELP_INDEX	=0003h	;/* Display index */
HELP_HELPONHELP =0004h	;/* Display help on using help */
HELP_SETINDEX	=0005h	;/* Set the current Index for multi index help */
HELP_KEY	=0101h	;/* Display topic for keyword in offabData */

IFNDEF NOCOMM

NOPARITY        =   0
ODDPARITY       =   1
EVENPARITY      =   2
MARKPARITY      =   3
SPACEPARITY     =   4

ONESTOPBIT      =   0
ONE5STOPBITS    =   1
TWOSTOPBITS     =   2

IGNORE          =   0      ; /* Ignore signal    */
INFINITE        =   0FFFFh ; /* Infinite timeout */

; Error Flags
CE_RXOVER       =    0001h ; /* Receive Queue overflow       */
CE_OVERRUN      =    0002h ; /* Receive Overrun Error        */
CE_RXPARITY     =    0004h ; /* Receive Parity Error         */
CE_FRAME        =    0008h ; /* Receive Framing error        */
CE_BREAK        =    0010h ; /* Break Detected               */
CE_CTSTO        =    0020h ; /* CTS Timeout                  */
CE_DSRTO        =    0040h ; /* DSR Timeout                  */
CE_RLSDTO       =    0080h ; /* RLSD Timeout                 */
CE_TXFULL       =    0100h ; /* TX Queue is full             */
CE_PTO          =    0200h ; /* LPTx Timeout                 */
CE_IOE          =    0400h ; /* LPTx I/O Error               */
CE_DNS          =    0800h ; /* LPTx Device not selected     */
CE_OOP          =    1000h ; /* LPTx Out-Of-Paper            */
CE_MODE         =    8000h ; /* Requested mode unsupported   */

IE_BADID        =    (-1)  ;  /* Invalid or unsupported id    */
IE_OPEN         =    (-2)  ;  /* Device Already Open          */
IE_NOPEN        =    (-3)  ;  /* Device Not Open              */
IE_MEMORY       =    (-4)  ;  /* Unable to allocate queues    */
IE_DEFAULT      =    (-5)  ;  /* Error in default parameters  */
IE_HARDWARE     =    (-10) ;  /* Hardware Not Present         */
IE_BYTESIZE     =    (-11) ;  /* Illegal Byte Size            */
IE_BAUDRATE     =    (-12) ;  /* Unsupported BaudRate         */

; Events
EV_RXCHAR       =    0001h ; /* Any Character received       */
EV_RXFLAG       =    0002h ; /* Received certain character   */
EV_TXEMPTY      =    0004h ; /* Transmitt Queue Empty        */
EV_CTS          =    0008h ; /* CTS changed state            */
EV_DSR          =    0010h ; /* DSR changed state            */
EV_RLSD         =    0020h ; /* RLSD changed state           */
EV_BREAK        =    0040h ; /* BREAK received               */
EV_ERR          =    0080h ; /* Line status error occurred   */
EV_RING         =    0100h ; /* Ring signal detected         */
EV_PERR         =    0200h ; /* Printer error occured        */
EV_CTSS         =    0400h ; /* CTS state                    */
EV_DSRS         =    0800h ; /* DSR state                    */
EV_RLSDS        =    1000h ; /* RLSD state                   */
EV_RingTe       =    2000h ; /* Ring Trailing Edge Indicator */


; Escape Functions
SETXOFF         =    1     ;  /* Simulate XOFF received       */
SETXON          =    2     ;  /* Simulate XON received        */
SETRTS          =    3     ;  /* Set RTS high                 */
CLRRTS          =    4     ;  /* Set RTS low                  */
SETDTR          =    5     ;  /* Set DTR high                 */
CLRDTR          =    6     ;  /* Set DTR low                  */
RESETDEV        =    7     ;  /* Reset device if possible     */

LPTx            =    80h   ; /* Set if ID is for LPT device  */

IFNDEF NOWIN31
; new escape functions
GETMAXLPT   equ  8	   ; Max supported LPT id
GETMAXCOM   equ  9	   ; Max supported COM id
GETBASEIRQ  equ 10	   ; Get port base & irq for a port

; Comm Baud Rate indices
CBR_110     equ 0FF10h
CBR_300     equ 0FF11h
CBR_600     equ 0FF12h
CBR_1200    equ 0FF13h
CBR_2400    equ 0FF14h
CBR_4800    equ 0FF15h
CBR_9600    equ 0FF16h
CBR_14400   equ 0FF17h
CBR_19200   equ 0FF18h
;		0FF19h	(reserved)
;		0FF1Ah	(reserved)
CBR_38400   equ 0FF1Bh
;		0FF1Ch	(reserved)
;		0FF1Dh	(reserved)
;		0FF1Eh	(reserved)
CBR_56000   equ 0FF1Fh
;		0FF20h	(reserved)
;		0FF21h	(reserved)
;		0FF22h	(reserved)
CBR_128000  equ 0FF23h
;		0FF24h	(reserved)
;		0FF25h	(reserved)
;		0FF26h	(reserved)
CBR_256000  equ 0FF27h

; notifications passed in low word of lParam on WM_COMMNOTIFY messages
CN_RECEIVE  equ 1	    ; bytes are available in the input queue
CN_TRANSMIT equ 2	    ; fewer than wOutTrigger bytes still
			    ; remain in the output queue waiting
			    ; to be transmitted.
CN_EVENT    equ 4	    ; an enabled event has occurred

ENDIF


DCB     struc
    DCB_Id             db ?  ; /* Internal Device ID              */
    DCB_BaudRate       dw ?  ; /* Baudrate at which runing        */
    DCB_ByteSize       db ?  ; /* Number of bits/byte, 4-8        */
    DCB_Parity         db ?  ; /* 0-4=None,Odd,Even,Mark,Space    */
    DCB_StopBits       db ?  ; /* 0,1,2 = 1, 1.5, 2               */
    DCB_RlsTimeout     dw ?  ; /* Timeout for RLSD to be set      */
    DCB_CtsTimeout     dw ?  ; /* Timeout for CTS to be set       */
    DCB_DsrTimeout     dw ?  ; /* Timeout for DSR to be set       */

    DCB_BitMask1       db ?

    ;   BYTE fBinary: 1;     /* Binary Mode (skip EOF check     */
    ;   BYTE fRtsDisable:1;  /* Don't assert RTS at init time   */
    ;   BYTE fParity: 1;     /* Enable parity checking          */
    ;   BYTE fOutxCtsFlow:1; /* CTS handshaking on output       */
    ;   BYTE fOutxDsrFlow:1; /* DSR handshaking on output       */
    ;   BYTE fDummy: 2;      /* Reserved                        */
    ;   BYTE fDtrDisable:1;  /* Don't assert DTR at init time   */

    DCB_BitMask2       db ?

    ;   BYTE fOutX: 1;       /* Enable output X-ON/X-OFF        */
    ;   BYTE fInX: 1;        /* Enable input X-ON/X-OFF         */
    ;   BYTE fPeChar: 1;     /* Enable Parity Err Replacement   */
    ;   BYTE fNull: 1;       /* Enable Null stripping           */
    ;   BYTE fChEvt: 1;      /* Enable Rx character event.      */
    ;   BYTE fDtrflow: 1;    /* DTR handshake on input          */
    ;   BYTE fRtsflow: 1;    /* RTS handshake on input          */
    ;   BYTE fDummy2: 1;

    DCB_XonChar        db ? ; /* Tx and Rx X-ON character        */
    DCB_XoffChar       db ? ; /* Tx and Rx X-OFF character       */
    DCB_XonLim         dw ? ; /* Transmit X-ON threshold         */
    DCB_XoffLim        dw ? ; /* Transmit X-OFF threshold        */
    DCB_PeChar         db ? ; /* Parity error replacement char   */
    DCB_EofChar        db ? ; /* End of Input character          */
    DCB_EvtChar        db ? ; /* Recieved Event character        */
    DCB_TxDelay        dw ? ; /* Amount of time between chars    */
DCB     ends

COMSTAT     struc
    COMS_BitMask1   db ?

;    BYTE fCtsHold: 1;   /* Transmit is on CTS hold         */
;    BYTE fDsrHold: 1;   /* Transmit is on DSR hold         */
;    BYTE fRlsdHold: 1;  /* Transmit is on RLSD hold        */
;    BYTE fXoffHold: 1;  /* Received handshake              */
;    BYTE fXoffSent: 1;  /* Issued handshake                */
;    BYTE fEof: 1;       /* End of file character found     */
;    BYTE fTxim: 1;      /* Character being transmitted     */


    COMS_cbInQue    dw ?  ;   /* count of characters in Rx Queue */
    COMS_cbOutQue   dw ?  ;   /* count of characters in Tx Queue */
COMSTAT     ends

ENDIF       ;NOCOM

;
; Installable Driver Support
;
; Driver Messages
DRV_LOAD	    = 0001h
DRV_ENABLE	    = 0002h
DRV_OPEN	    = 0003h
DRV_CLOSE	    = 0004h
DRV_DISABLE	    = 0005h
DRV_FREE	    = 0006h
DRV_CONFIGURE	    = 0007h
DRV_QUERYCONFIGURE  = 0008h
DRV_INSTALL	    = 0009h
DRV_REMOVE	    = 000Ah
DRV_EXITSESSION	    = 000Bh
DRV_POWER	    = 000Fh
DRV_RESERVED	    = 0800h
DRV_USER	    = 4000h

;LPARAM of DRV_CONFIGURE message and return values
DRVCONFIGINFO struc
    DRVCNF_dwDCISize	      dw ?
    DRVCNF_lpszDCISectionName dd ?
    DRVCNF_lpszDCIAliasName   dd ?
DRVCONFIGINFO ends

DRVCNF_CANCEL	    = 0000h
DRVCNF_OK	    = 0001h
DRVCNF_RESTART	    = 0002h


IFNDEF  NOKERNEL
;
; Common Kernel errors
; 
ERR_GALLOC	= 01030h	; GlobalAlloc Failed
ERR_GREALLOC	= 01031h	; GlobalReAlloc Failed
ERR_GLOCK	= 01032h	; GlobalLock Failed
ERR_LALLOC	= 01033h	; LocalAlloc Failed
ERR_LREALLOC	= 01034h	; LocalReAlloc Failed
ERR_LLOCK	= 01035h	; LocalLock Failed
ERR_ALLOCRES	= 01036h	; AllocResource Failed
ERR_LOCKRES	= 01037h	; LockResource Failed
ERR_LOADMODULE  = 01038h	; LoadModule failed

;
; Common User Errors 
;
ERR_CREATEDLG	     =	01045h ; /* Create Dlg failure due to LoadMenu failure */
ERR_CREATEDLG2	     =	01046h ; /* Create Dlg failure due to CreateWindow Failure */
ERR_REGISTERCLASS    =	01047h ; /* RegisterClass failure due to Class already registered */
ERR_DCBUSY	     =	01048h ; /* DC Cache is full */
ERR_CREATEWND	     =	01049h ; /* Create Wnd failed due to class not found */
ERR_STRUCEXTRA	     =  01050h ; /* Unallocated Extra space is used */
ERR_LOADSTR	     =	01051h ; /* LoadString() failed */
ERR_LOADMENU	     =	01052h ; /* LoadMenu Failed     */
ERR_NESTEDBEGINPAINT =  01053h ; /* Nested BeginPaint() calls */
ERR_BADINDEX	     =  01054h ; /* Bad index to Get/Set Class/Window Word/Long */
ERR_CREATEMENU	     =	01055h ; /* Error creating menu */

;
; Common GDI Errors
;
ERR_CREATEDC	    = 01070h	; /* CreateDC/CreateIC etc., failure */
ERR_CREATEMETA      = 01071h	; /* CreateMetafile failure */
ERR_DELOBJSELECTED  = 01072h	; /* Bitmap being deleted is selected into DC */
ERR_SELBITMAP	    = 01073h	; /* Bitmap being selected is already selected elsewhere */

ENDIF	    ;NOKERNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\winnet.h ===
/*
 *      Windows/Network Interface
 *      Copyright (C) Microsoft 1989-1993
 *
 *      Standard WINNET Driver Header File, spec version 3.10
 */


#ifndef _INC_WINNET
#define _INC_WINNET  /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif   /* __cplusplus */

typedef WORD far * LPWORD;

#ifndef API
#define API WINAPI
#endif


/*
 *      SPOOLING - CONTROLLING JOBS
 */

#define WNJ_NULL_JOBID  0


WORD API WNetOpenJob(LPSTR,LPSTR,WORD,LPINT);
WORD API WNetCloseJob(WORD,LPINT,LPSTR);
WORD API WNetWriteJob(HANDLE,LPSTR,LPINT);
WORD API WNetAbortJob(WORD,LPSTR);
WORD API WNetHoldJob(LPSTR,WORD);
WORD API WNetReleaseJob(LPSTR,WORD);
WORD API WNetCancelJob(LPSTR,WORD);
WORD API WNetSetJobCopies(LPSTR,WORD,WORD);

/*
 *      SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct     {
	WORD    pqName;
	WORD    pqComment;
	WORD    pqStatus;
	WORD    pqJobcount;
	WORD    pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE    0x0
#define WNPRQ_PAUSE     0x1
#define WNPRQ_ERROR     0x2
#define WNPRQ_PENDING   0x3
#define WNPRQ_PROBLEM   0x4


typedef struct _jobstruct       {
	WORD    pjId;
	WORD    pjUsername;
	WORD    pjParms;
	WORD    pjPosition;
	WORD    pjStatus;
	DWORD   pjSubmitted;
	DWORD   pjSize;
	WORD    pjCopies;
	WORD    pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS           0x0007
#define WNPRJ_QS_QUEUED                0x0000
#define WNPRJ_QS_PAUSED                0x0001
#define WNPRJ_QS_SPOOLING              0x0002
#define WNPRJ_QS_PRINTING              0x0003
#define WNPRJ_DEVSTATUS         0x0FF8
#define WNPRJ_DS_COMPLETE              0x0008
#define WNPRJ_DS_INTERV                0x0010
#define WNPRJ_DS_ERROR                 0x0020
#define WNPRJ_DS_DESTOFFLINE           0x0040
#define WNPRJ_DS_DESTPAUSED            0x0080
#define WNPRJ_DS_NOTIFY                0x0100
#define WNPRJ_DS_DESTNOPAPER           0x0200
#define WNPRJ_DS_DESTFORMCHG           0x0400
#define WNPRJ_DS_DESTCRTCHG            0x0800
#define WNPRJ_DS_DESTPENCHG            0x1000

#define SP_QUEUECHANGED         0x0500


WORD API WNetWatchQueue(HWND,LPSTR,LPSTR,WORD);
WORD API WNetUnwatchQueue(LPSTR);
WORD API WNetLockQueueData(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
WORD API WNetUnlockQueueData(LPSTR);


/*
 *      CONNECTIONS
 */

UINT API WNetAddConnection(LPSTR,LPSTR,LPSTR);
UINT API WNetCancelConnection(LPSTR,BOOL);
UINT API WNetGetConnection(LPSTR,LPSTR, UINT FAR *);
UINT API WNetRestoreConnection(HWND,LPSTR);

/*
 *      CAPABILITIES
 */

#define WNNC_SPEC_VERSION               0x0001

#define WNNC_NET_TYPE                   0x0002
#define  WNNC_NET_NONE                          0x0000
#define  WNNC_NET_MSNet                         0x0100
#define  WNNC_NET_LanMan                        0x0200
#define  WNNC_NET_NetWare                       0x0300
#define  WNNC_NET_Vines                         0x0400
#define  WNNC_NET_10NET                         0x0500
#define  WNNC_NET_Locus                         0x0600
#define  WNNC_NET_Sun_PC_NFS                    0x0700
#define  WNNC_NET_LANstep                       0x0800
#define  WNNC_NET_9TILES                        0x0900
#define  WNNC_NET_LANtastic                     0x0A00
#define  WNNC_NET_AS400                         0x0B00
#define  WNNC_NET_FTP_NFS                       0x0C00
#define  WNNC_NET_PATHWORKS                     0x0D00
#define  WNNC_NET_MultiNet       0x8000
#define   WNNC_SUBNET_NONE          0x0000
#define   WNNC_SUBNET_MSNet            0x0001
#define   WNNC_SUBNET_LanMan           0x0002
#define   WNNC_SUBNET_WinWorkgroups       0x0004
#define   WNNC_SUBNET_NetWare          0x0008
#define   WNNC_SUBNET_Vines            0x0010
#define   WNNC_SUBNET_Other            0x0080

#define WNNC_DRIVER_VERSION             0x0003

#define WNNC_USER                       0x0004
#define  WNNC_USR_GetUser                       0x0001

#define WNNC_CONNECTION                 0x0006
#define  WNNC_CON_AddConnection                 0x0001
#define  WNNC_CON_CancelConnection              0x0002
#define  WNNC_CON_GetConnections                0x0004
#define  WNNC_CON_AutoConnect                   0x0008
#define  WNNC_CON_BrowseDialog                  0x0010
#define  WNNC_CON_RestoreConnection             0x0020

#define WNNC_PRINTING                   0x0007
#define  WNNC_PRT_OpenJob                       0x0002
#define  WNNC_PRT_CloseJob                      0x0004
#define  WNNC_PRT_HoldJob                       0x0010
#define  WNNC_PRT_ReleaseJob                    0x0020
#define  WNNC_PRT_CancelJob                     0x0040
#define  WNNC_PRT_SetJobCopies                  0x0080
#define  WNNC_PRT_WatchQueue                    0x0100
#define  WNNC_PRT_UnwatchQueue                  0x0200
#define  WNNC_PRT_LockQueueData                 0x0400
#define  WNNC_PRT_UnlockQueueData               0x0800
#define  WNNC_PRT_ChangeMsg                     0x1000
#define  WNNC_PRT_AbortJob                      0x2000
#define  WNNC_PRT_NoArbitraryLock               0x4000
#define  WNNC_PRT_WriteJob                      0x8000

#define WNNC_DIALOG                     0x0008
#define  WNNC_DLG_DeviceMode                    0x0001
#define  WNNC_DLG_BrowseDialog                  0x0002
#define  WNNC_DLG_ConnectDialog                 0x0004
#define  WNNC_DLG_DisconnectDialog              0x0008
#define  WNNC_DLG_ViewQueueDialog               0x0010
#define  WNNC_DLG_PropertyDialog                0x0020
#define  WNNC_DLG_ConnectionDialog              0x0040
#define  WNNC_DLG_PrinterConnectDialog    0x0080
#define  WNNC_DLG_SharesDialog         0x0100
#define  WNNC_DLG_ShareAsDialog        0x0200


#define WNNC_ADMIN                      0x0009
#define  WNNC_ADM_GetDirectoryType              0x0001
#define  WNNC_ADM_DirectoryNotify               0x0002
#define  WNNC_ADM_LongNames                     0x0004
#define  WNNC_ADM_SetDefaultDrive      0x0008

#define WNNC_ERROR                      0x000A
#define  WNNC_ERR_GetError                      0x0001
#define  WNNC_ERR_GetErrorText                  0x0002


WORD API WNetGetCaps(WORD);

/*
 *      OTHER
 */

WORD API WNetGetUser(LPSTR,LPINT);

/*
 *      BROWSE DIALOG
 */

#define WNBD_CONN_UNKNOWN       0x0
#define WNBD_CONN_DISKTREE      0x1
#define WNBD_CONN_PRINTQ        0x3
#define WNBD_MAX_LENGTH         0x80    // path length, includes the NULL

#define WNTYPE_DRIVE            1
#define WNTYPE_FILE             2
#define WNTYPE_PRINTER          3
#define WNTYPE_COMM             4

#define WNPS_FILE               0
#define WNPS_DIR                1
#define WNPS_MULT               2

WORD API WNetDeviceMode(HWND);
WORD API WNetBrowseDialog(HWND,WORD,LPSTR);
WORD API WNetConnectDialog(HWND,WORD);
WORD API WNetDisconnectDialog(HWND,WORD);
WORD API WNetConnectionDialog(HWND,WORD);
WORD API WNetViewQueueDialog(HWND,LPSTR);
WORD API WNetPropertyDialog(HWND hwndParent, WORD iButton, WORD nPropSel,
				 LPSTR lpszName, WORD nType);
WORD API WNetGetPropertyText(WORD iButton, WORD nPropSel, LPSTR lpszName,
				  LPSTR lpszButtonName, WORD cbButtonName, WORD nType);

/*
	 The following APIs are not exported from USER.EXE.  They must be
	 loaded from the active network driver like this:

	 HINSTANCE hinstNetDriver;
	 LPWNETSERVERBROWSEDIALOG lpDialogAPI;

	 hinstNetDriver = (HINSTANCE)WNetGetCaps(0xFFFF);
	 if (hinstNetDriver == NULL) {
	// no network driver loaded
	 }
	 else {
	lpDialogAPI = (LPWNETSERVERBROWSEDIALOG)GetProcAddress(hinstNetDriver,
					(LPSTR)ORD_WNETSERVERBROWSEDIALOG);

	if (lpDialogAPI == NULL) {
		 // currently installed network doesn't support this API
	}
	else {
		 (*lpDialogAPI)(hwndParent, lpszSectionName, lpszBuffer, cbBuffer, 0L);
	}
	 }
*/

typedef WORD (API *LPWNETSHAREASDIALOG)(HWND hwndParent, WORD iType,
						 LPSTR lpszPath);
typedef WORD (API *LPWNETSTOPSHAREDIALOG)(HWND hwndParent, WORD iType,
							LPSTR lpszPath);
typedef WORD (API *LPWNETSETDEFAULTDRIVE)(WORD idriveDefault);
typedef WORD (API *LPWNETGETSHARECOUNT)(WORD iType);
typedef WORD (API *LPWNETGETSHARENAME)(LPSTR lpszPath, LPSTR lpszBuf,
						WORD cbBuf);
typedef WORD (API *LPWNETSERVERBROWSEDIALOG)(HWND hwndParent,
						 LPSTR lpszSectionName,
						 LPSTR lpszBuffer,
						 WORD cbBuffer,
						 DWORD flFlags);
typedef WORD (API *LPWNETGETSHAREPATH)(LPSTR lpszName, LPSTR lpszBuf,
						WORD cbBuf);
typedef WORD (API *LPWNETGETLASTCONNECTION)(WORD iType, LPWORD lpwConnIndex);
typedef WORD (API *LPWNETEXITCONFIRM)(HWND hwndOwner, WORD iExitType);

typedef BOOL (API *LPI_AUTOLOGON)(HWND hwndOwner, LPSTR lpszReserved,
						BOOL fPrompt, BOOL FAR *lpfLoggedOn);
typedef BOOL (API *LPI_LOGOFF)(HWND hwndOwner, LPSTR lpszReserved);
typedef VOID (API *LPI_CHANGEPASSWORD)(HWND hwndOwner);
typedef VOID (API *LPI_CHANGECACHEPASSWORD)(HWND hwndOwner);
typedef WORD (API *LPI_CONNECTDIALOG)(HWND hwndParent, WORD iType);
typedef WORD (API *LPI_CONNECTIONDIALOG)(HWND hwndParent, WORD iType);


typedef struct tagPASSWORD_CACHE_ENTRY {
	 WORD cbEntry;
	 WORD cbResource;
	 WORD cbPassword;
	 BYTE iEntry;
	 BYTE nType;
	 BYTE abResource[1];    /* resource name, cbResource bytes long */
				/* password follows immediately after */
} PASSWORD_CACHE_ENTRY;

typedef PASSWORD_CACHE_ENTRY FAR *LPPASSWORD_CACHE_ENTRY;

typedef WORD (API *LPWNETCACHEPASSWORD)(LPSTR pbResource, WORD cbResource,
					LPSTR pbPassword, WORD cbPassword,
					BYTE nType);

typedef WORD (API *LPWNETGETCACHEDPASSWORD)(LPSTR pbResource, WORD cbResource,
						 LPSTR pbPassword, LPWORD pcbPassword,
						 BYTE nType);

typedef WORD (API *LPWNETREMOVECACHEDPASSWORD)(LPSTR pbResource,
							 WORD cbResource,
							 BYTE nType);

/*
	 Typedef for the callback routine passed to WNetEnumCachedPasswords.
	 It will be called once for each entry that matches the criteria
	 requested.  It should return TRUE if it wants the enumeration to
	 continue, FALSE to stop.
*/
typedef BOOL (API *CACHECALLBACK)( LPPASSWORD_CACHE_ENTRY pce );


typedef WORD (API *LPWNETENUMCACHEDPASSWORDS)(LPSTR pbPrefix, WORD cbPrefix,
							BYTE nType,
							CACHECALLBACK pfnCallback);

/*
 * Ordinals in the network driver for APIs not exported by USER.
 */
#define ORD_I_AUTOLOGON       530
#define ORD_I_CHANGEPASSWORD     531
#define ORD_I_LOGOFF       532
#define ORD_I_CONNECTIONDIALOG      533
#define ORD_I_CHANGECACHEPASSWORD   534
#define ORD_I_CONNECTDIALOG      535
#define ORD_WNETSHARESDIALOG     140
#define ORD_WNETSHAREASDIALOG    141
#define ORD_WNETSTOPSHAREDIALOG     142
#define ORD_WNETSETDEFAULTDRIVE     143
#define ORD_WNETGETSHARECOUNT    144
#define ORD_WNETGETSHARENAME     145

#define ORD_WNETSERVERBROWSEDIALOG  146

#define ORD_WNETGETSHAREPATH     147

#define ORD_WNETGETLASTCONNECTION   148

#define ORD_WNETEXITCONFIRM      149

#define ORD_WNETCACHEPASSWORD    150
#define ORD_WNETGETCACHEDPASSWORD   151
#define ORD_WNETREMOVECACHEDPASSWORD   152
#define ORD_WNETENUMCACHEDPASSWORDS 153

/*
 *   the following nType values are only for the purposes of enumerating
 *   entries from the cache.  note that PCE_ALL is reserved and should not
 *   be the nType value for any entry.
*/

#define PCE_DOMAIN   0x01  /* entry is for a domain */
#define PCE_SERVER   0x02  /* entry is for a server */
#define PCE_UNC      0x03  /* entry is for a server/share combo */

#define PCE_NOTMRU   0x80  /* bit set if entry is exempt from MRU aging */
#define PCE_ALL      0xff  /* retrieve all entries */


/*
 * Defines for iExitType on WNetExitConfirm
 */
#define EXIT_CONFIRM 0
#define EXIT_EXITING 1
#define EXIT_CANCELED   2

/*
 *      ADMIN
 */

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3

WORD API WNetGetDirectoryType(LPSTR,LPINT);
WORD API WNetDirectoryNotify(HWND,LPSTR,WORD);

/*
 *      ERRORS
 */

WORD API WNetGetError(LPINT);
WORD API WNetGetErrorText(WORD,LPSTR,LPINT);


/*
 *      STATUS CODES
 */

/* General */

#define WN_SUCCESS                      0x0000
#define WN_NOT_SUPPORTED                0x0001
#define WN_NET_ERROR                    0x0002
#define WN_MORE_DATA                    0x0003
#define WN_BAD_POINTER                  0x0004
#define WN_BAD_VALUE                    0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED                0x0007
#define WN_FUNCTION_BUSY                0x0008
#define WN_WINDOWS_ERROR                0x0009
#define WN_BAD_USER                     0x000A
#define WN_OUT_OF_MEMORY                0x000B
#define WN_CANCEL                       0x000C
#define WN_CONTINUE                     0x000D

/* Connection */

#define WN_NOT_CONNECTED                0x0030
#define WN_OPEN_FILES                   0x0031
#define WN_BAD_NETNAME                  0x0032
#define WN_BAD_LOCALNAME                0x0033
#define WN_ALREADY_CONNECTED            0x0034
#define WN_DEVICE_ERROR                 0x0035
#define WN_CONNECTION_CLOSED            0x0036

/* Printing */

#define WN_BAD_JOBID                    0x0040
#define WN_JOB_NOT_FOUND                0x0041
#define WN_JOB_NOT_HELD                 0x0042
#define WN_BAD_QUEUE                    0x0043
#define WN_BAD_FILE_HANDLE              0x0044
#define WN_CANT_SET_COPIES              0x0045
#define WN_ALREADY_LOCKED               0x0046

#define WN_NO_ERROR                     0x0050

/* stuff in user, not driver, for shell apps ;Internal */
WORD API WNetErrorText(WORD,LPSTR,WORD); /* ;Internal */

#ifdef LFN

/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2
  {
	 WORD fdateCreation;
	 WORD ftimeCreation;
	 WORD fdateLastAccess;
	 WORD ftimeLastAccess;
	 WORD fdateLastWrite;
	 WORD ftimeLastWrite;
	 DWORD cbFile;
	 DWORD cbFileAlloc;
	 WORD attr;
	 DWORD cbList;
	 BYTE cchName;
	 BYTE achName[1];
  } FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (API *PQUERYPROC)( void );

WORD API LFNFindFirst(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD API LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD API LFNFindClose(HANDLE);
WORD API LFNGetAttribute(LPSTR,LPINT);
WORD API LFNSetAttribute(LPSTR,WORD);
WORD API LFNCopy(LPSTR,LPSTR,PQUERYPROC);
WORD API LFNMove(LPSTR,LPSTR);
WORD API LFNDelete(LPSTR);
WORD API LFNMKDir(LPSTR);
WORD API LFNRMDir(LPSTR);
WORD API LFNGetVolumeLabel(WORD,LPSTR);
WORD API LFNSetVolumeLabel(WORD,LPSTR);
WORD API LFNParse(LPSTR,LPSTR,LPSTR);
WORD API LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI              0
#define FILE_83_CS              1
#define FILE_LONG               2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD         0
#define VOLUME_LONGNAMES        1

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC   0xFFFF

#endif

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif   /* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\inc\windowsx.h ===
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)		\
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)	    DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)	    ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)	    DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)	    ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)	    DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)	    DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)	    ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)	    GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)	\
		((WNDPROC)SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)	IsIconic(hwnd)
#define     IsMaximized(hwnd)	IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()	(GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()	(GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()	(GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
		((DLGPROC)SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)	 \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam));
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam));
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam);
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(h