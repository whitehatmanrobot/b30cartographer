f //CHECK_REGISTRY_USECOUNT
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            KeyNode =  (PCM_KEY_NODE)HvGetCell(Hive, Cell);
            if( KeyNode == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we successfully marked the cell as dirty
                //
                ASSERT( FALSE );
#ifdef CHECK_REGISTRY_USECOUNT
                CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            // release the cell right here as we are holding the reglock exclusive
            HvReleaseCell(Hive,Cell);

            KeyBody = (PCM_KEY_BODY)(*Object);

            //
            // A new key is created, invalid the subkey info of the parent KCB.
            //
            ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

            CmpCleanUpSubKeyInfo (KeyBody->KeyControlBlock->ParentKcb);

            //
            // Update max keyname and class name length fields
            //

            //some sanity asserts first
            ASSERT( KeyBody->KeyControlBlock->ParentKcb->KeyCell == Cell );
            ASSERT( KeyBody->KeyControlBlock->ParentKcb->KeyHive == Hive );
            ASSERT( KeyBody->KeyControlBlock->ParentKcb == ParentKcb );
            ASSERT( KeyBody->KeyControlBlock->ParentKcb->KcbMaxNameLen == KeyNode->MaxNameLen );

            //
            // update the LastWriteTime on both keynode and kcb;
            //
            KeQuerySystemTime(&TimeStamp);
            KeyNode->LastWriteTime = TimeStamp;
            KeyBody->KeyControlBlock->ParentKcb->KcbLastWriteTime = TimeStamp;

            if (KeyNode->MaxNameLen < Name->Length) {
                KeyNode->MaxNameLen = Name->Length;
                // update the kcb cache too
                KeyBody->KeyControlBlock->ParentKcb->KcbMaxNameLen = Name->Length;
            }

            if (KeyNode->MaxClassLen < Context->Class.Length) {
                KeyNode->MaxClassLen = Context->Class.Length;
            }


            if (Context->CreateOptions & REG_OPTION_CREATE_LINK) {
                pdata = HvGetCell(Hive, KeyCell);
                if( pdata == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    // this shouldn't happen as we just allocated the cell
                    // (i.e. it must be PINNED into memory at this point)
                    //
                    ASSERT( FALSE );
#ifdef CHECK_REGISTRY_USECOUNT
                    CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                // release the cell right here as we are holding the reglock exclusive
                HvReleaseCell(Hive,KeyCell);

                pdata->u.KeyNode.Flags |= KEY_SYM_LINK;
                KeyBody->KeyControlBlock->Flags = pdata->u.KeyNode.Flags;

            }
#ifdef CM_BREAK_ON_KEY_OPEN
			if( KeyBody->KeyControlBlock->ParentKcb->Flags & KEY_BREAK_ON_OPEN ) {
				DbgPrint("\n\n Current process is creating a subkey to a key tagged as BREAK ON OPEN\n");
				DbgPrint("\nPlease type the following in the debugger window: !reg kcb %p\n\n\n",KeyBody->KeyControlBlock);
				
				try {
					DbgBreakPoint();
				} except (EXCEPTION_EXECUTE_HANDLER) {

					//
					// no debugger enabled, just keep going
					//

				}
			}
#endif //CM_BREAK_ON_KEY_OPEN

		}
    }
#ifdef CHECK_REGISTRY_USECOUNT
    CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT
    return status;
}


NTSTATUS
CmpDoCreateChild(
    IN PHHIVE Hive,
    IN HCELL_INDEX ParentCell,
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PACCESS_STATE AccessState,
    IN PUNICODE_STRING Name,
    IN KPROCESSOR_MODE AccessMode,
    IN PCM_PARSE_CONTEXT Context,
    IN PCM_KEY_CONTROL_BLOCK ParentKcb,
    IN USHORT Flags,
    OUT PHCELL_INDEX KeyCell,
    OUT PVOID *Object
    )

/*++

Routine Description:

    Creates a new sub-key.  This is called by CmpDoCreate to create child
    sub-keys and CmpCreateLinkNode to create root sub-keys.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    ParentCell - supplies cell index of parent cell

    ParentDescriptor - Supplies security descriptor of parent key, for use
           in inheriting ACLs.

    AccessState - Running security access state information for operation.

    Name - Supplies pointer to a UNICODE string which is the name of the
           child to be created.

    AccessMode - Access mode of the original caller.

    Context - Supplies pointer to CM_PARSE_CONTEXT structure passed through
           the object manager.

    BaseName - Name of object create is relative to

    KeyName - Relative name (to BaseName)

    Flags - Supplies any flags to be set in the newly created node

    KeyCell - Receives the cell index of the newly created sub-key, if any.

    Object - Receives a pointer to the created key object, if any.

Return Value:

    STATUS_SUCCESS - sub-key successfully created.  New object is returned in
            Object, and the new cell's cell index is returned in KeyCell.

    !STATUS_SUCCESS - appropriate error message.

--*/

{
    ULONG clean=0;
    ULONG alloc=0;
    NTSTATUS Status = STATUS_SUCCESS;
    PCM_KEY_BODY KeyBody;
    HCELL_INDEX ClassCell=HCELL_NIL;
    PCM_KEY_NODE KeyNode;
    PCELL_DATA CellData;
    PCM_KEY_CONTROL_BLOCK kcb;
    PCM_KEY_CONTROL_BLOCK fkcb;
    LONG found;
    ULONG StorageType;
    PSECURITY_DESCRIPTOR NewDescriptor = NULL;
    LARGE_INTEGER systemtime;

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoCreateChild:\n"));
    try {
        //
        // Get allocation type
        //
        StorageType = Stable;
        if (Context->CreateOptions & REG_OPTION_VOLATILE) {
            StorageType = Volatile;
        }

        //
        // Allocate child cell
        //
        *KeyCell = HvAllocateCell(
                        Hive,
                        CmpHKeyNodeSize(Hive, Name),
                        StorageType,
                        HCELL_NIL
                        );
        if (*KeyCell == HCELL_NIL) {
			Status = STATUS_INSUFFICIENT_RESOURCES;
			leave;
        }
        alloc = 1;
        KeyNode = (PCM_KEY_NODE)HvGetCell(Hive, *KeyCell);
        if( KeyNode == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just allocated the cell
            // (i.e. it must be PINNED into memory at this point)
            //
            ASSERT( FALSE );
			Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive,*KeyCell);

        //
        // Allocate cell for class name
        //
        if (Context->Class.Length > 0) {
            ClassCell = HvAllocateCell(Hive, Context->Class.Length, StorageType,*KeyCell);
            if (ClassCell == HCELL_NIL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
				leave;
            }
        }
        alloc = 2;
        //
        // Allocate the object manager object
        //
        Status = ObCreateObject(AccessMode,
                                CmpKeyObjectType,
                                NULL,
                                AccessMode,
                                NULL,
                                sizeof(CM_KEY_BODY),
                                0,
                                0,
                                Object);

        if (NT_SUCCESS(Status)) {

            KeyBody = (PCM_KEY_BODY)(*Object);

            //
            // We have managed to allocate all of the objects we need to,
            // so initialize them
            //

            //
            // Mark the object as uninitialized (in case we get an error too soon)
            //
            KeyBody->Type = KEY_BODY_TYPE;
            KeyBody->KeyControlBlock = NULL;

            //
            // Fill in the class name
            //
            if (Context->Class.Length > 0) {

                CellData = HvGetCell(Hive, ClassCell);
                if( CellData == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    // this shouldn't happen as we just allocated the cell
                    // (i.e. it must be PINNED into memory at this point)
                    //
                    ASSERT( FALSE );
			        Status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }

                // release the cell right here as we are holding the reglock exclusive
                HvReleaseCell(Hive,ClassCell);

                try {

                    RtlCopyMemory(
                        &(CellData->u.KeyString[0]),
                        Context->Class.Buffer,
                        Context->Class.Length
                        );

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    ObDereferenceObject(*Object);
                    return GetExceptionCode();
                }
            }

            //
            // Fill in the new key itself
            //
            KeyNode->Signature = CM_KEY_NODE_SIGNATURE;
            KeyNode->Flags = Flags;

            KeQuerySystemTime(&systemtime);
            KeyNode->LastWriteTime = systemtime;

            KeyNode->Spare = 0;
            KeyNode->Parent = ParentCell;
            KeyNode->SubKeyCounts[Stable] = 0;
            KeyNode->SubKeyCounts[Volatile] = 0;
            KeyNode->SubKeyLists[Stable] = HCELL_NIL;
            KeyNode->SubKeyLists[Volatile] = HCELL_NIL;
            KeyNode->ValueList.Count = 0;
            KeyNode->ValueList.List = HCELL_NIL;
            KeyNode->Security = HCELL_NIL;
            KeyNode->Class = ClassCell;
            KeyNode->ClassLength = Context->Class.Length;

            KeyNode->MaxValueDataLen = 0;
            KeyNode->MaxNameLen = 0;
            KeyNode->MaxValueNameLen = 0;
            KeyNode->MaxClassLen = 0;

            KeyNode->NameLength = CmpCopyName(Hive,
                                              KeyNode->Name,
                                              Name);
            if (KeyNode->NameLength < Name->Length) {
                KeyNode->Flags |= KEY_COMP_NAME;
            }

            if (Context->CreateOptions & REG_OPTION_PREDEF_HANDLE) {
                KeyNode->ValueList.Count = (ULONG)((ULONG_PTR)Context->PredefinedHandle);
                KeyNode->Flags |= KEY_PREDEF_HANDLE;
            }

            //
            // Create kcb here so all data are filled in.
            //
            // Allocate a key control block
            //
            kcb = CmpCreateKeyControlBlock(Hive, *KeyCell, KeyNode, ParentKcb, FALSE, Name);
            if (kcb == NULL) {
                ObDereferenceObject(*Object);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            ASSERT(kcb->RefCount == 1);
            alloc = 3;

#if DBG
            if( kcb->ExtFlags & CM_KCB_KEY_NON_EXIST ) {
                //
                // we shouldn't fall into this
                //
                ObDereferenceObject(*Object);
                DbgBreakPoint();
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }
#endif //DBG
            //
            // Fill in CM specific fields in the object
            //
            KeyBody->Type = KEY_BODY_TYPE;
            KeyBody->KeyControlBlock = kcb;
            KeyBody->NotifyBlock = NULL;
            KeyBody->Process = PsGetCurrentProcess();
            ENLIST_KEYBODY_IN_KEYBODY_LIST(KeyBody);
            //
            // Assign a security descriptor to the object.  Note that since
            // registry keys are container objects, and ObAssignSecurity
            // assumes that the only container object in the world is
            // the ObpDirectoryObjectType, we have to call SeAssignSecurity
            // directly in order to get the right inheritance.
            //

            Status = SeAssignSecurity(ParentDescriptor,
                                      AccessState->SecurityDescriptor,
                                      &NewDescriptor,
                                      TRUE,             // container object
                                      &AccessState->SubjectSecurityContext,
                                      &CmpKeyObjectType->TypeInfo.GenericMapping,
                                      CmpKeyObjectType->TypeInfo.PoolType);
            if (NT_SUCCESS(Status)) {
                Status = CmpSecurityMethod(*Object,
                                           AssignSecurityDescriptor,
                                           NULL,
                                           NewDescriptor,
                                           NULL,
                                           NULL,
                                           CmpKeyObjectType->TypeInfo.PoolType,
                                           &CmpKeyObjectType->TypeInfo.GenericMapping);
            }

            //
            // Since the security descriptor now lives in the hive,
            // free the in-memory copy
            //
            SeDeassignSecurity( &NewDescriptor );

            if (!NT_SUCCESS(Status)) {

                //
                // Note that the dereference will clean up the kcb, so
                // make sure and decrement the allocation count here.
                //
                // Also mark the kcb as deleted so it does not get
                // inappropriately cached.
                //
                ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
                kcb->Delete = TRUE;
                CmpRemoveKeyControlBlock(kcb);
                ObDereferenceObject(*Object);
                alloc = 2;

            } else {
                CmpReportNotify(
                        kcb,
                        kcb->KeyHive,
                        kcb->KeyCell,
                        REG_NOTIFY_CHANGE_NAME
                        );
            }
        }

    } finally {

        if (!NT_SUCCESS(Status)) {

            //
            // Clean up allocations
            //
            switch (alloc) {
            case 3:
                //
                // Mark KCB as deleted so it does not get inadvertently added to
                // the delayed close list. That would have fairly disastrous effects
                // as the KCB points to storage we are about to free.
                //
                ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
                kcb->Delete = TRUE;
                CmpRemoveKeyControlBlock(kcb);
                CmpDereferenceKeyControlBlockWithLock(kcb);
                // DELIBERATE FALL

            case 2:
                if (Context->Class.Length > 0) {
                    HvFreeCell(Hive, ClassCell);
                }
                // DELIBERATE FALL

            case 1:
                HvFreeCell(Hive, *KeyCell);
                // DELIBERATE FALL
            }
#ifdef CM_CHECK_FOR_ORPHANED_KCBS
            DbgPrint("CmpDoCreateChild failed with status %lx for hive = %p , NodeName = %.*S\n",Status,Hive,Name->Length/2,Name->Buffer);
#endif //CM_CHECK_FOR_ORPHANED_KCBS
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmpbug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cmpbug.h

Abstract:

    Description of the registry bugchecks; only defines and comments.

Author:

    Dragos C. Sambotin (dragoss) 02-Nov-99

Environment:


Revision History:

--*/

#ifndef __CMPBUG_H__
#define __CMPBUG_H__

#if defined(_CM_LDR_)

//
// KeBugCheckEx() is not available to boot code.
//

#define CM_BUGCHECK( Code, Parm1, Parm2, Parm3, Parm4 ) ASSERT(FALSE)

#else

#define CM_BUGCHECK( Code, Parm1, Parm2, Parm3, Parm4 ) \
    KeBugCheckEx( (ULONG)Code, (ULONG_PTR)Parm1, (ULONG_PTR)Parm2, (ULONG_PTR)Parm3, (ULONG_PTR)Parm4 )

#endif


/*
CRITICAL_SERVICE_FAILED          (0x5A)
*/
/*
SET_ENV_VAR_FAILED               (0x5B)
*/

#define BAD_LAST_KNOWN_GOOD             1       //CmBootLastKnownGood


/*
CONFIG_LIST_FAILED               (0x73)
Indicates that one of the core system hives cannot be linked in the
registry tree. The hive is valid, it was loaded OK. Examine the 2nd 
bugcheck argument to see why the hive could not be linked in the 
registry tree.

PARAMETERS
        1 - 1
        2 - Indicates the NT status code that tripped us into thinking
			that we failed to load the hive.
        3 - Index of hive in hivelist 
        4 - Pointer to UNICODE_STRING containing filename of hive

DESCRIPTION
This can be either SAM, SECURITY, SOFTWARE or DEFAULT. One common reason 
for this to happen is if you are out of disk space on the system drive 
(in which case param 4 is 0xC000017D - STATUS_NO_LOG_SPACE) or an attempt 
to allocate pool has failed (in which case param 4 is 0xC000009A -
STATUS_INSUFFICIENT_RESOURCES). Other status codes must be individually
investigated. 
*/

#define BAD_CORE_HIVE                   1       // CmpInitializeHiveList

/*
BAD_SYSTEM_CONFIG_INFO           (0x74)
Can indicate that the SYSTEM hive loaded by the osloader/NTLDR
was corrupt.  This is unlikely, since the osloader will check
a hive to make sure it isn't corrupt after loading it.

It can also indicate that some critical registry keys and values
are not present.  (i.e. somebody used regedt32 to delete something
that they shouldn't have)  Booting from LastKnownGood may fix
the problem, but if someone is persistent enough in mucking with
the registry they will need to reinstall or use the Emergency
Repair Disk.

PARAMETERS
		1 - identifies the function
		2 - identifies the line inside the function
		3 - other info
		4 - usually the NT status code.
*/

#define BAD_SYSTEM_CONTROL_VALUES       1       // CmGetSystemControlValues

#define BAD_HIVE_LIST                   2       // CmpInitializeHiveList

#define BAD_SYSTEM_HIVE                 3       // CmpInitializeSystemHive



/*
CONFIG_INITIALIZATION_FAILED     (0x67)

PARAMETERS
    1 - indicates location in ntos\config\cmsysini that failed
    2 - location selector
	3 - NT status code 

DESCRIPTION
This means the registry couldn't allocate the pool needed to contain the
registry files.  This should never happen, since it is early enough in
system initialization that there is always plenty of paged pool available.
*/

#define INIT_SYSTEM1                    1       // CmInitSystem1

#define INIT_SYSTEM_DRIVER_LIST         2       // CmGetSystemDriverList

#define INIT_CACHE_TABLE                3       // CmpInitializeCache

#define INIT_DELAYED_CLOSE_TABLE        4       // CmpInitializeDelayedCloseTable


/*
CANNOT_WRITE_CONFIGURATION       (0x75)

This will result if the SYSTEM hive file cannot be converted to a 
mapped file. This usually happens if the system is out of pool and
we cannot reopen the hive. 

PARAMETERS
		1 - 1
		2 - Indicates the NT status code that tripped us into thinking
			that we failed to convert the hive.

DESCRIPTION
Normally you shouldn't see this as the conversion happens at early 
during system initialization, so enough pool should be available.
*/

#define CANNOT_CONVERT_SYSTEM_HIVE      1


/*
REGISTRY_ERROR                   (0x51)
PARAMETERS
        1 - value 1 (indicates where we bugchecked)
        2 - value 2 (indicates where we bugchecked)
        3 - depends on where it bugchecked, may be pointer to hive
        4 - depends on where it bugchecked, may be return code of
            HvCheckHive if the hive is corrupt.

DESCRIPTION
Something has gone horribly wrong with the registry.  If a kernel debugger
is available, get a stack trace.It can also indicate that the registry got 
an I/O error while trying to read one of its files, so it can be caused by 
hardware problems or filesystem corruption.

It may occur due to a failure in a refresh operation, which is used only
in by the security system, and then only when resource limits are encountered.
*/

#define BAD_CELL_MAP                    1           // VALIDATE_CELL_MAP

#define BAD_FREE_BINS_LIST              2           // HvpDelistBinFreeCells

#define FATAL_MAPPING_ERROR             3           // HvpFindNextDirtyBlock
                                                    // HvpDoWriteHive

#define BAD_SECURITY_CACHE              4           // CmpAssignSecurityToKcb
                                                    // CmpSetSecurityDescriptorInfo

#define BAD_SECURITY_METHOD             5           // CmpSecurityMethod

#define CHECK_LOCK_EXCEPTION            6           // CmpCheckLockExceptionFilter

#define REGISTRY_LOCK_CHECKPOINT        7           // END_LOCK_CHECKPOINT

#define BIG_CELL_ERROR                  8           // CmpValueToData

#define CMVIEW_ERROR                    9           // CmpAllocateCmView
                                                    // CmpFreeCmView
                                                    // CmpPinCmView

#define REFRESH_HIVE                    0xA         // HvRefreshHive


#define ALLOCATE_SECURITY_DESCRIPTOR    0xB         // CmpHiveRootSecurityDescriptor

#define BAD_NOTIFY_CONTEXT              0xC         // NtNotifyChangeMultipleKeys


#define QUOTA_ERROR                     0xD         // CmpReleaseGlobalQuota

#define INVALID_WRITE_OPERATION         0xE         // NtCreateKey

#define HANDLES_STILL_OPEN_AT_SHUTDOWN  0xF         // CmFreeAllMemory

#define COMPRESS_HIVE					0x10        // CmCompressKey

#define ALLOC_ERROR						0x11        // CmpFreeKeyControlBlock

#endif  // _CMPBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmquery.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmquery.c

Abstract:

    This module contains the object name query method for the registry.

Author:

    Bryan M. Willman (bryanwi) 8-Apr-1992

Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpQueryKeyName)
#endif

NTSTATUS
CmpQueryKeyName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    )
/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system wishes to discover the name of an object that
    belongs to the registry.

Arguments:

    Object - pointer to a Key, thus -> KEY_BODY.

    HasObjectName - indicates whether the object manager knows about a name
        for this object

    ObjectNameInfo - place where we report the name

    Length - maximum length they can deal with

    ReturnLength - supplies variable to receive actual length

Return Value:

    STATUS_SUCCESS

    STATUS_INFO_LENGTH_MISMATCH

--*/

{
    PUNICODE_STRING Name;
    PWCHAR t;
    PWCHAR s;
    ULONG l;
    NTSTATUS status;

    UNREFERENCED_PARAMETER(HasObjectName);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpQueryKeyName:\n"));

    CmpLockRegistry();

    if ( ((PCM_KEY_BODY)Object)->KeyControlBlock->Delete) {
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }
    Name = CmpConstructName(((PCM_KEY_BODY)Object)->KeyControlBlock);
    if (Name == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        CmpUnlockRegistry();
        return status;
    }

    if (Length <= sizeof(OBJECT_NAME_INFORMATION)) {
        *ReturnLength = Name->Length + sizeof(WCHAR) + sizeof(OBJECT_NAME_INFORMATION);
        ExFreePoolWithTag(Name, CM_NAME_TAG | PROTECTED_POOL);
        CmpUnlockRegistry();
        return STATUS_INFO_LENGTH_MISMATCH;  // they can't even handle null
    }

    t = (PWCHAR)(ObjectNameInfo + 1);
    s = Name->Buffer;
    l = Name->Length;
    l += sizeof(WCHAR);     // account for null


    *ReturnLength = l + sizeof(OBJECT_NAME_INFORMATION);
    if (l > Length - sizeof(OBJECT_NAME_INFORMATION)) {
        l = Length - sizeof(OBJECT_NAME_INFORMATION);
        status = STATUS_INFO_LENGTH_MISMATCH;
    } else {
        status = STATUS_SUCCESS;
    }
    l -= sizeof(WCHAR);

    //
    // The ObjectNameInfo buffer is a usermode buffer, so make sure we have an
    // exception handler in case a malicious app changes the protection out from
    // under us.
    //
    // Note the object manager is responsible for probing the buffer and ensuring
    // that a top-level exception handler returns the correct error code. We just
    // need to make sure we drop our lock.
    //
    try {
        RtlCopyMemory(t, s, l);
        t[l/sizeof(WCHAR)] = UNICODE_NULL;
        ObjectNameInfo->Name.Length = (USHORT)l;
        ObjectNameInfo->Name.MaximumLength = ObjectNameInfo->Name.Length;
        ObjectNameInfo->Name.Buffer = t;
    } finally {
        ExFreePoolWithTag(Name, CM_NAME_TAG | PROTECTED_POOL);
        CmpUnlockRegistry();
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmplock.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmplock.h

Abstract:

    Macros that hide the system calls used to do locking.  Allows
    cm and reg code to run in a variety of environments.

    Note that there is a single lock (in particular, a mutex) which
    protects the entire registry.

Author:

    Bryan M. Willman (bryanwi) 30-Oct-91

Environment:

Revision History:

--*/

//
// Macros for kernel mode environment
//

extern  KMUTEX  CmpRegistryMutex;
#if DBG
extern  LONG    CmpRegistryLockLocked;
#endif

//
// Test macro
//
#if DBG
#define ASSERT_CM_LOCK_OWNED() \
    if ( (CmpRegistryMutex.OwnerThread != KeGetCurrentThread())  ||   \
         (CmpRegistryMutex.Header.SignalState >= 1) )                 \
    {                                                                 \
        ASSERT(FALSE);                                                \
    }
#else
#define ASSERT_CM_LOCK_OWNED()
#endif

//
// This set of macros serializes all access to the registry via
// a single Mutex.
//

//
// CMP_LOCK_REGISTRY(
//      NTSTATUS        *pstatus,
//      PLARGE_INTEGER  timeout
//      );
//
//  Routine Description:
//
//      Acquires the CmpRegistryMutex, with specified timeout, and
//      returns status.
//
//  Arguments:
//
//      pstatus - pointer to variable to receive status from wait call
//
//      timeout - pointer to timeout value
//

#if DBG
#define CMP_LOCK_REGISTRY(status, timeout)                      \
{                                                               \
    status = KeWaitForSingleObject(                             \
                &CmpRegistryMutex,                              \
                Executive,                                      \
                KernelMode,                                     \
                FALSE,                                          \
                timeout                                         \
                );                                              \
    CmpRegistryLockLocked++;                                    \
}
#else
#define CMP_LOCK_REGISTRY(status, timeout)                      \
{                                                               \
    status = KeWaitForSingleObject(                             \
                &CmpRegistryMutex,                              \
                Executive,                                      \
                KernelMode,                                     \
                FALSE,                                          \
                timeout                                         \
                );                                              \
}
#endif

//
// CMP_UNLOCK_REGISTRY(
//      );
//
//  Routine Description:
//
//      Releases the CmpRegistryMutex.
//
//

#if DBG
#define CMP_UNLOCK_REGISTRY()                               \
{                                                           \
    ASSERT(CmpRegistryLockLocked > 0);                      \
    KeReleaseMutex(&CmpRegistryMutex, FALSE);               \
    CmpRegistryLockLocked--;                                \
}
#else
#define CMP_UNLOCK_REGISTRY()                               \
{                                                           \
    KeReleaseMutex(&CmpRegistryMutex, FALSE);               \
}
#endif


//
// Debugging asserts
//

#if DBG
#define ASSERT_REGISTRY_LOCKED()    ASSERT(CmpRegistryLockLocked > 0)
#else
#define ASSERT_REGISTRY_LOCKED()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmparse.c ===
/*++
Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmparse.c

Abstract:

    This module contains parse routines for the configuration manager, particularly
    the registry.

Author:

    Bryan M. Willman (bryanwi) 10-Sep-1991

Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const ULONG CmpCacheOnFlag = CM_CACHE_FAKE_KEY;

extern  PCMHIVE CmpMasterHive;
extern  BOOLEAN CmpNoMasterCreates;
extern  PCM_KEY_CONTROL_BLOCK CmpKeyControlBlockRoot;
extern  UNICODE_STRING CmSymbolicLinkValueName;

#define CM_HASH_STACK_SIZE  30

typedef struct _CM_HASH_ENTRY {
    ULONG ConvKey;
    UNICODE_STRING KeyName;
} CM_HASH_ENTRY, *PCM_HASH_ENTRY;

ULONG
CmpComputeHashValue(
    IN PCM_HASH_ENTRY  HashStack,
    IN OUT ULONG  *TotalSubkeys,
    IN ULONG BaseConvKey,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
CmpCacheLookup(
    IN PCM_HASH_ENTRY HashStack,
    IN ULONG TotalRemainingSubkeys,
    OUT ULONG *MatchRemainSubkeyLevel,
    IN OUT PCM_KEY_CONTROL_BLOCK *Kcb,
    OUT PUNICODE_STRING RemainingName,
    OUT PHHIVE *Hive,
    OUT HCELL_INDEX *Cell
    );

VOID
CmpCacheAdd(
    IN PCM_HASH_ENTRY LastHashEntry,
    IN ULONG Count
    );

PCM_KEY_CONTROL_BLOCK
CmpAddInfoAfterParseFailure(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    PCM_KEY_NODE    Node,
    PCM_KEY_CONTROL_BLOCK kcb,
    PUNICODE_STRING NodeName
    );

//
// Prototypes for procedures private to this file
//

BOOLEAN
CmpGetSymbolicLink(
    IN PHHIVE Hive,
    IN OUT PUNICODE_STRING ObjectName,
    IN OUT PCM_KEY_CONTROL_BLOCK SymbolicKcb,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
CmpDoOpen(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PCM_KEY_NODE Node,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN PCM_PARSE_CONTEXT Context,
    IN BOOLEAN  CompleteKeyCached,
    IN OUT PCM_KEY_CONTROL_BLOCK *CachedKcb,
    IN PUNICODE_STRING KeyName,
    OUT PVOID *Object
    );

NTSTATUS
CmpCreateLinkNode(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PACCESS_STATE AccessState,
    IN UNICODE_STRING Name,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN PCM_PARSE_CONTEXT Context,
    IN PCM_KEY_CONTROL_BLOCK ParentKcb,
    OUT PVOID *Object
    );

#ifdef CM_DYN_SYM_LINK
BOOLEAN
CmpCaptureProcessEnvironmentString(
                                   OUT  PWSTR   *ProcessEnvironment,
                                   OUT  PULONG  Length
                                   );
PWSTR
CmpExpandEnvVars(
               IN   PWSTR   StringToExpand,
               IN   ULONG   LengthToExpand,
               OUT  PULONG  ExpandedLength
               );
BOOLEAN
CmpGrowAndCopyString(
                     IN OUT PWSTR   *OldString,
                     IN OUT PULONG  OldStringSize,
                     IN     ULONG   GrowIncrements
                     );
BOOLEAN
CmpFindEnvVar(
              IN    PWSTR   ProcessEnv,
              IN    ULONG   ProcessEnvLength,
              IN    PWSTR   CurrentEnvVar,
              IN    ULONG   CurrentEnvLength,
              OUT   PWSTR   *CurrentEnvValue,
              OUT   PULONG  CurrentEnvValueLength
              );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpParseKey)
#pragma alloc_text(PAGE,CmpGetNextName)
#pragma alloc_text(PAGE,CmpDoOpen)
#pragma alloc_text(PAGE,CmpCreateLinkNode)
#pragma alloc_text(PAGE,CmpGetSymbolicLink)
#pragma alloc_text(PAGE,CmpComputeHashValue)
#pragma alloc_text(PAGE,CmpCacheLookup)
#pragma alloc_text(PAGE,CmpAddInfoAfterParseFailure)

#ifdef CM_DYN_SYM_LINK
#pragma alloc_text(PAGE,CmpCaptureProcessEnvironmentString)
#pragma alloc_text(PAGE,CmpExpandEnvVars)
#pragma alloc_text(PAGE,CmpGrowAndCopyString)
#pragma alloc_text(PAGE,CmpFindEnvVar)
#endif //CM_DYN_SYM_LINK

#endif

/*
VOID
CmpStepThroughExit(
    IN OUT PHHIVE       *Hive,
    IN OUT HCELL_INDEX  *Cell,
    IN OUT PCM_KEY_NODE *pNode
    )
*/
#define CmpStepThroughExit(h,c,n,ReleaseHive,ReleaseCell)           \
if ((n)->Flags & KEY_HIVE_EXIT) {                                   \
    if( ReleaseCell != HCELL_NIL ) {                                \
        ASSERT( ReleaseHive != NULL );                              \
        HvReleaseCell( ReleaseHive,ReleaseCell);                    \
    }                                                               \
    (h)=(n)->ChildHiveReference.KeyHive;                            \
    (c)=(n)->ChildHiveReference.KeyCell;                            \
    (n)=(PCM_KEY_NODE)HvGetCell((h),(c));                           \
    if( (n) == NULL ) {                                             \
        ReleaseHive = NULL;                                         \
        ReleaseCell = HCELL_NIL;                                    \
    } else {                                                        \
        ReleaseHive = (h);                                          \
        ReleaseCell = (c);                                          \
    }                                                               \
}

#define CmpReleasePreviousAndHookNew(NewHive,NewCell,ReleaseHive,ReleaseCell)   \
    if( ReleaseCell != HCELL_NIL ) {                                            \
        ASSERT( ReleaseHive != NULL );                                          \
        HvReleaseCell( ReleaseHive,ReleaseCell);                                \
    }                                                                           \
    ReleaseHive = (NewHive);                                                    \
    ReleaseCell = (NewCell)                                                    

#define CMP_PARSE_GOTO_NONE     0
#define CMP_PARSE_GOTO_CREATE   1
#define CMP_PARSE_GOTO_RETURN   2
#define CMP_PARSE_GOTO_RETURN2  3

#ifdef CMP_STATS
extern BOOLEAN CmpNtFakeCreateStarted; 
extern ULONG CmpNtFakeCreate;
#endif


NTSTATUS
CmpParseKey(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )
/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and
    a Key or KeyRoot is encountered in the path.  In practice this means
    that this routine is called for all objects whose names are of the
    form \REGISTRY\...

    This routine will create a Key object, which is effectively an open
    instance to a registry key node, and return its address
    (for the success case.)

Arguments:

    ParseObject - Pointer to a KeyRoot or Key, thus -> KEY_BODY.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    CompleteName - Supplies complete name of the object.

    RemainingName - Remaining name of the object.

    Context - if create or hive root open, points to a CM_PARSE_CONTEXT
              structure,
              if open, is NULL.

    SecurityQos - Optional security quality of service indicator.

    Object - The address of a variable to receive the created key object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created key object.

        b)  STATUS_REPARSE - This indicates that a symbolic link key was
            found, and the path should be reparsed.

        c)  Error - This indicates that the file was not found or created and
            no file object was created.

--*/
{
    NTSTATUS                status;
    BOOLEAN                 rc;
    PHHIVE                  Hive;
    PCM_KEY_NODE            Node = NULL;
    HCELL_INDEX             Cell;
    HCELL_INDEX             ParentCell;
    HCELL_INDEX             NextCell;
    PHCELL_INDEX            Index;
    PCM_PARSE_CONTEXT       lcontext;
    UNICODE_STRING          Current;
    UNICODE_STRING          NextName;   // Component last returned by CmpGetNextName,
                                        // will always be behind Current.
    
    BOOLEAN                 Last;       // TRUE if component NextName points to
                                        // is the last one in the path.

    ULONG           TotalRemainingSubkeys;
    ULONG           MatchRemainSubkeyLevel;
    ULONG           TotalSubkeys=0;
    PCM_KEY_CONTROL_BLOCK   kcb;
    PCM_KEY_HASH            PCmpCacheEntry=NULL;
    PCM_KEY_CONTROL_BLOCK   ParentKcb;
    UNICODE_STRING          TmpNodeName;
    ULONG                   namelength;
    ULONG                   GoToValue = CMP_PARSE_GOTO_NONE;
    BOOLEAN                 CompleteKeyCached = FALSE;
    USHORT                  i,j;
    WCHAR                   *p1;
    BOOLEAN                 ExclusiveLock = FALSE;

    PHHIVE                  HiveToRelease = NULL;
    HCELL_INDEX             CellToRelease = HCELL_NIL;

    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CompleteName = '%wZ'\n\t", CompleteName));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"RemainingName = '%wZ'\n", RemainingName));

    //
    // Strip off any trailing path separators
    //
    while ((RemainingName->Length > 0) &&
           (RemainingName->Buffer[(RemainingName->Length/sizeof(WCHAR)) - 1] == OBJ_NAME_PATH_SEPARATOR)) {
        RemainingName->Length -= sizeof(WCHAR);
    }

    Current = *RemainingName;
    if (ObjectType != CmpKeyObjectType) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    lcontext = (PCM_PARSE_CONTEXT)Context;

    //
    // PreCreate callback
    //
    if ( CmAreCallbacksRegistered() ) {
        if( ARGUMENT_PRESENT(lcontext) ) {
            //
            // NtCreateKey
            //
            REG_PRE_CREATE_KEY_INFORMATION  PreCreateInfo;
       
            PreCreateInfo.CompleteName = CompleteName;

            status = CmpCallCallBacks(RegNtPreCreateKey,&PreCreateInfo);
        } else {
            //
            // NtOpenKey
            //
            REG_PRE_OPEN_KEY_INFORMATION  PreOpenInfo;
       
            PreOpenInfo.CompleteName = CompleteName;

            status = CmpCallCallBacks(RegNtPreOpenKey,&PreOpenInfo);
        }

        if( !NT_SUCCESS(status) ) {
            return status;
        }
    }
    
    BEGIN_LOCK_CHECKPOINT;
    //
    // we now lock it shared as 85% of the create calls are in fact opens
    // the lock will be aquired exclusively in CmpDoCreate/CmpCreateLinkNode
    //
    // We only lock the registry here, in the parse routine to reduce contention 
    // on the registry lock (NO reason to wait on OB)
    //

    CmpLockRegistry();
    //CmpLockRegistryExclusive();

    //
    // Check to make sure the passed in root key is not marked for deletion.
    //
    if (((PCM_KEY_BODY)ParseObject)->KeyControlBlock->Delete == TRUE) {
        CmpUnlockRegistry();
        return(STATUS_KEY_DELETED);
    }

    //
    // Fetch the starting Hive.Cell.  Because of the way the parse
    // paths work, this will always be defined.  (ObOpenObjectByName
    // had to bounce off of a KeyObject or KeyRootObject to get here)
    //
    kcb = ((PCM_KEY_BODY)ParseObject)->KeyControlBlock;
    Hive = kcb->KeyHive;
    Cell = kcb->KeyCell;

    //
    // give back the stack after we don't need it anymore.
    //
    {
        CM_HASH_ENTRY   HashStack[CM_HASH_STACK_SIZE];
        //
        // Compute the hash values of each subkeys
        //
        TotalRemainingSubkeys = CmpComputeHashValue(HashStack,
                                                    &TotalSubkeys,
                                                    kcb->ConvKey,
                                                    &Current);
        PERFINFO_REG_PARSE(kcb, RemainingName);

        // Look up from the cache.  kcb will be changed if we find a partial or exact match
        // PCmpCacheEntry, the entry found, will be moved to the front of
        // the Cache.

        BEGIN_KCB_LOCK_GUARD;                             

        CmpLockKCBTreeExclusive();

        status = CmpCacheLookup(HashStack,
                                TotalRemainingSubkeys,
                                &MatchRemainSubkeyLevel,
                                &kcb,
                                &Current,
                                &Hive,
                                &Cell);
        //
        // The RefCount of kcb was increased in the CmpCacheLookup process,
        // It is to protect it from being kicked out of cache.
        // Make sure we dereference it after we are done.
        //

        CmpUnlockKCBTree();
        END_KCB_LOCK_GUARD;                             
    }

    //
    // First make sure it is OK to proceed.
    //
    if (!NT_SUCCESS (status)) {
        goto JustReturn;
    }

    ParentKcb = kcb;

    if(TotalRemainingSubkeys == 0) {
        //
        // We REALLY don't want to mess with the cache code bellow
        // in this case (this could only happen if we called with 
        // the lpSubkey = NULL )
        //
        CompleteKeyCached = TRUE;
        goto Found;
    }


    //
    // First check if there are further information in the cached kcb.
    // 
    // The additional information can be
    // 1. This cached key is a fake key (CM_KCB_KEY_NON_EXIST), then either let it be created
    //    or return STATUS_OBJECT_NAME_NOT_FOUND.
    // 2. The cached key is not the destination and it has no subkey (CM_KCB_NO_SUBKEY).
    // 3. The cached key is not the destination and it has 
    //    the first four characters of its subkeys.  If the flag is CM_KCB_SUBKEY_ONE, there is only one subkey
    //    and the four char is embedded in the KCB.  If the flag is CM_KCB_SUBKEY_INFO, then there is
    //    an allocation for these info. 
    //
    // We do need to lock KCB tree to protect the KCB being modified.  Currently there is not lock contention problem
    // on KCBs, We can change KCB lock to a read-write lock if this becomes a problem.
    // 

    //
    // we did it; we changed the lock to a read-write resource
    //
    BEGIN_KCB_LOCK_GUARD;                             
    CmpLockKCBTree();

    if( FALSE ) {
        //
        // if we are here, we are in the position where we need to modify the KCB; therefore we need to aquire 
        // the lock exclusive; after aquiring we test if the kcb is still valid (was not deleted in the meanwhile)
        //

NeedExclusiveLock:

        CmpUnlockKCBTree();
        CmpLockKCBTreeExclusive();
        ExclusiveLock = TRUE;
    }
    
    if( kcb->Delete ) {
        //
        // kcb has been deleted while playing with the lock
        //
        status = STATUS_OBJECT_NAME_NOT_FOUND;
        CmpUnlockKCBTree();
        goto JustReturn;

    }

    if (kcb->ExtFlags & CM_KCB_CACHE_MASK) {
        if (MatchRemainSubkeyLevel == TotalRemainingSubkeys) {
            //
            // We have found a cache for the complete path,
            //
            if (kcb->ExtFlags & CM_KCB_KEY_NON_EXIST) {
                //
                // This key does not exist.
                //
                if (ARGUMENT_PRESENT(lcontext)) {
                    ULONG LevelToSkip = TotalRemainingSubkeys-1;
                    ULONG i=0;
                    
                    //
                    // we need to change the kcb; get the lock exclusive (if noty already held) and try again
                    //
                    if( ExclusiveLock == FALSE ) {
                        goto NeedExclusiveLock;
                    }

                    //
                    // The non-existing key is the destination key and lcontext is present.
                    // delete this fake kcb and let the real one be created.
                    //
                    // Temporarily increase the RefCount of the ParentKcb so it's 
                    // not removed while removing the fake and creating the real KCB.
                    //
                    
                    ParentKcb = kcb->ParentKcb;
                    
                    if (CmpReferenceKeyControlBlock(ParentKcb)) {
                    
                        kcb->Delete = TRUE;
                        CmpRemoveKeyControlBlock(kcb);
                        CmpDereferenceKeyControlBlockWithLock(kcb);

                        //
                        // Update Hive, Cell and Node
                        //
                        Hive = ParentKcb->KeyHive;
                        Cell = ParentKcb->KeyCell;
                        Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
                        if( Node == NULL ) {
                            //
                            // we couldn't map the bin contianing this cell
                            //
                            CmpUnlockKCBTree();
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            goto FreeAndReturn;
                        }
                    
                        CmpReleasePreviousAndHookNew(Hive,Cell,HiveToRelease,CellToRelease);

                        //
                        // Now get the child name to be created.
                        //
   
                        NextName = *RemainingName;
                        if ((NextName.Buffer == NULL) || (NextName.Length == 0)) {
                            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Something wrong in finding the child name\n"));
                            DbgBreakPoint();
                        }
                        //
                        // Skip over leading path separators
                        //
                        while (*(NextName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {
                            NextName.Buffer++;
                            NextName.Length -= sizeof(WCHAR);
                            NextName.MaximumLength -= sizeof(WCHAR);
                        }
   
                        while (i < LevelToSkip) {
                            if (*(NextName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {
                                i++;
                                while (*(NextName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {
                                    NextName.Buffer++;
                                    NextName.Length -= sizeof(WCHAR);
                                    NextName.MaximumLength -= sizeof(WCHAR);
                                }
                            } else {
                                NextName.Buffer++;
                                NextName.Length -= sizeof(WCHAR);
                                NextName.MaximumLength -= sizeof(WCHAR);
                            }
                        } 
                        GoToValue = CMP_PARSE_GOTO_CREATE;
                    } else {
                        //
                        // We have maxed the RefCount of ParentKcb; treate it as key cannot be created.
                        // The ParentKcb will not be dereferenced at the end.
                        //
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        GoToValue = CMP_PARSE_GOTO_RETURN2;
                    }
                } else {
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    GoToValue = CMP_PARSE_GOTO_RETURN;
                }
            }
        } else if (kcb->ExtFlags & CM_KCB_KEY_NON_EXIST) {
            //
            // one subkey (not destination) in the path does not exist. no point to continue.
            //
            status = STATUS_OBJECT_NAME_NOT_FOUND;
            GoToValue = CMP_PARSE_GOTO_RETURN;
        } else if (kcb->ExtFlags & CM_KCB_NO_SUBKEY) {
            //
            // one parent in the path has no subkey. see if it is a create.
            //
            if (((TotalRemainingSubkeys - MatchRemainSubkeyLevel) == 1) && (ARGUMENT_PRESENT(lcontext))) {
                //
                // Now we are going to create this subkey. 
                // The kcb cache will be updated in CmpDoCreate routine.
                //
            } else {
                status = STATUS_OBJECT_NAME_NOT_FOUND;
                GoToValue = CMP_PARSE_GOTO_RETURN;
            }
        } else {
            //
            // We have a partial match.  Current is the remaining name to be parsed.
            // The Key has either one or a few subkeys and has index hint. check if it is the candidate.
            //
           
            BOOLEAN NoMatch = TRUE;
            ULONG   NextHashKey;
            PULONG  TempHashKey;
            ULONG   HintCounts;
            ULONG   CmpCount;
            //
            // When NoMatch is TRUE, we know for sure there is no subkey that can match.
            // When NoMatch is FALSE, it can we either we found a match or
            // there is not enough information.  Either case, we need to continue
            // the parse.
            //

            TmpNodeName = Current;

            rc = CmpGetNextName(&TmpNodeName, &NextName, &Last);
        
            NextHashKey = CmpComputeHashKey(&NextName);

            if (kcb->ExtFlags & CM_KCB_SUBKEY_ONE) {
                HintCounts = 1;
                TempHashKey = &(kcb->HashKey);
            } else {
                //
                // More than one child, the hint info in not inside the kcb but pointed by kcb.
                //
                HintCounts = kcb->IndexHint->Count;
                TempHashKey = &(kcb->IndexHint->HashKey[0]);
            }

            for (CmpCount=0; CmpCount<HintCounts; CmpCount++) {
                if( TempHashKey[CmpCount] == 0) {
                    //
                    // No hint available; assume the subkey exist and go on with the parse
                    //
                    //DbgPrint("KCB cache hit [0]\n");
                    NoMatch = FALSE;
                    break;
                } 
                
                if( NextHashKey == TempHashKey[CmpCount] ) {
                    //
                    // There is a match.
                    //
                    //DbgPrint("KCB cache hit [1]\n");
                    NoMatch = FALSE;
                    break;
                }
            }

            if (NoMatch) {
                if (((TotalRemainingSubkeys - MatchRemainSubkeyLevel) == 1) && (ARGUMENT_PRESENT(lcontext))) {
                    //
                    // No we are going to create this subkey. 
                    // The kcb cache will be updated in CmpDoCreate.
                    //
                } else {
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    GoToValue = CMP_PARSE_GOTO_RETURN;
                }
            }
        }
    }

    CmpUnlockKCBTree();
    END_KCB_LOCK_GUARD;                             


    if (GoToValue == CMP_PARSE_GOTO_CREATE) {
        goto CreateChild;
    } else if (GoToValue == CMP_PARSE_GOTO_RETURN) {
        goto FreeAndReturn;
    } else if (GoToValue == CMP_PARSE_GOTO_RETURN2) {
        goto JustReturn;
    }

    if (MatchRemainSubkeyLevel) {
        // Found something, update the information to start the search
        // from the new BaseName

        if (MatchRemainSubkeyLevel == TotalSubkeys) {
            // The complete key has been found in the cache,
            // go directly to the CmpDoOpen.
            
            //
            // Found the whole thing cached.
            // 
            //
            CompleteKeyCached = TRUE;
            goto Found;
        }
        ASSERT( (Cell == kcb->KeyCell) && (Hive == kcb->KeyHive) );
    }  

    //
    //  Check if we hit a symbolic link case
    //
    if (kcb->Flags & KEY_SYM_LINK) {
        //
        // The given key was a symbolic link.  Find the name of
        // its link, and return STATUS_REPARSE to the Object Manager.
        //
        rc = CmpGetNextName(&Current, &NextName, &Last);
        Current.Buffer = NextName.Buffer;
        Current.Length += NextName.Length;
        Current.MaximumLength += NextName.MaximumLength;
        if (CmpGetSymbolicLink(Hive,
                               CompleteName,
                               kcb,
                               &Current)) {

            status = STATUS_REPARSE;
        } else {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey: couldn't find symbolic link name\n"));
            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        goto FreeAndReturn;
    }

    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
    if( Node == NULL ) {
        //
        // we couldn't map the bin contianing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FreeAndReturn;
    }
    CmpReleasePreviousAndHookNew(Hive,Cell,HiveToRelease,CellToRelease);

    //
    // Parse the path.
    //

    status = STATUS_SUCCESS;
    while (TRUE) {

        //
        // Parse out next component of name
        //
        rc = CmpGetNextName(&Current, &NextName, &Last);
        if ((NextName.Length > 0) && (rc == TRUE)) {

            //
            // As we iterate through, we will create a kcb for each subkey parsed.
            // 
            // Always use the information in kcb to avoid
            // touching registry data.
            //
#ifdef CMP_KCB_CACHE_VALIDATION
            {
                PCM_KEY_NODE            TempNode;
                TempNode = (PCM_KEY_NODE)HvGetCell(kcb->KeyHive,kcb->KeyCell);
                if( TempNode == NULL ) {
                    //
                    // we couldn't map the bin contianing this cell
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
                ASSERT( TempNode->Flags == kcb->Flags );
                HvReleaseCell(kcb->KeyHive,kcb->KeyCell);
            }
#endif
            if (!(kcb->Flags & KEY_SYM_LINK)) {
                //
                // Got a legal name component, see if we can find a sub key
                // that actually has such a name.
                //
                NextCell = CmpFindSubKeyByName(Hive,
                                               Node,
                                               &NextName);

                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey:\n\t"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"NextName = '%wZ'\n\t", &NextName));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"NextCell = %08lx  Last = %01lx\n", NextCell, Last));

                if (NextCell != HCELL_NIL) {
                    Cell = NextCell;
                    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
                    if( Node == NULL ) {
                        //
                        // we couldn't map the bin contianing this cell
                        //
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    
                    CmpReleasePreviousAndHookNew(Hive,Cell,HiveToRelease,CellToRelease);

                    if (Last == TRUE) {

Found:
                        //
                        // We will open the key regardless of whether the
                        // call was open or create, so step through exit
                        // portholes here.
                        //

                        if (CompleteKeyCached == TRUE) {
                            //
                            // If the key found is already cached, 
                            // do not need to StepThroughExit
                            // (no kcb is created using exit node).
                            // This prevents us from touching the key node just for the Flags.
                            //
                        } else {
                            CmpStepThroughExit(Hive, Cell, Node,HiveToRelease,CellToRelease);
                            if( Node == NULL ) {
                                //
                                // we couldn't map view for this cell
                                //
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                break;
                            }
                        }
                        //
                        // We have found the entire path, so we want to open
                        // it (for both Open and Create calls).
                        // Hive,Cell -> the key we are supposed to open.
                        //

#ifdef CMP_STATS
                        if(CmpNtFakeCreateStarted == TRUE) {
                            CmpNtFakeCreate++;
                        }
#endif

                        status = CmpDoOpen(Hive,
                                           Cell,
                                           Node,
                                           AccessState,
                                           AccessMode,
                                           Attributes,
                                           lcontext,
                                           CompleteKeyCached,
                                           &kcb,
                                           &NextName,
                                           Object);

                        if (status == STATUS_REPARSE) {
                            //
                            // The given key was a symbolic link.  Find the name of
                            // its link, and return STATUS_REPARSE to the Object Manager.
                            //

                            if (!CmpGetSymbolicLink(Hive,
                                                    CompleteName,
                                                    kcb,
                                                    NULL)) {
                                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey: couldn't find symbolic link name\n"));
                                status = STATUS_OBJECT_NAME_NOT_FOUND;
                            }
                        }

                        break;
                    }
                    // else
                    //   Not at end, so we'll simply iterate and consume
                    //   the next component.
                    //
                    //
                    // Step through exit portholes here.
                    // This ensures that no KCB is created using
                    // the Exit node.
                    //

                    CmpStepThroughExit(Hive, Cell, Node,HiveToRelease,CellToRelease);
                    if( Node == NULL ) {
                        //
                        // we couldn't map view for this cell
                        //
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    //
                    // Create a kcb for each subkey parsed.
                    //

                    kcb = CmpCreateKeyControlBlock(Hive,
                                                   Cell,
                                                   Node,
                                                   ParentKcb,
                                                   FALSE,
                                                   &NextName);
            
                    if (kcb  == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto FreeAndReturn;
                        //
                        // Currently, the kcb has one extra reference conut to be decremented.
                        // Remember it so we can dereference it properly.
                        //
                    }
                    //
                    // Now we have created a kcb for the next level,
                    // the kcb in the previous level is no longer needed.
                    // Dereference the parent kcb.
                    //
                    CmpDereferenceKeyControlBlock(ParentKcb);

                    ParentKcb = kcb;


                } else {
                    //
                    // We did not find a key matching the name, but no
                    // unexpected error occured
                    //

                    if ((Last == TRUE) && (ARGUMENT_PRESENT(lcontext))) {

CreateChild:
                        //
                        // Only unfound component is last one, and operation
                        // is a create, so perform the create.
                        //

                        //
                        // There are two possibilities here.  The normal one
                        // is that we are simply creating a new node.
                        //
                        // The abnormal one is that we are creating a root
                        // node that is linked to the main hive.  In this
                        // case, we must create the link.  Once the link is
                        // created, we can check to see if the root node
                        // exists, then either create it or open it as
                        // necessary.
                        //
                        // CmpCreateLinkNode creates the link, and calls
                        // back to CmpDoCreate or CmpDoOpen to create or open
                        // the root node as appropriate.
                        //

                        //
                        // either one of this will drop the reglock and reaquire it 
                        // exclusive; we need not to hurt ourselves, so release
                        // all cells here
                        //
                        CmpReleasePreviousAndHookNew(NULL,HCELL_NIL,HiveToRelease,CellToRelease);

                        if (lcontext->CreateLink) {
                            status = CmpCreateLinkNode(Hive,
                                                       Cell,
                                                       AccessState,
                                                       NextName,
                                                       AccessMode,
                                                       Attributes,
                                                       lcontext,
                                                       ParentKcb,
                                                       Object);

                        } else {

                            if ( (Hive == &(CmpMasterHive->Hive)) &&
                                 (CmpNoMasterCreates == TRUE) ) {
                                //
                                // attempting to create a cell in the master
                                // hive, and not a link, so blow out of here,
                                // since it wouldn't work anyway.
                                //
                                status = STATUS_INVALID_PARAMETER;
                                break;
                            }

                            status = CmpDoCreate(Hive,
                                                 Cell,
                                                 AccessState,
                                                 &NextName,
                                                 AccessMode,
                                                 lcontext,
                                                 ParentKcb,
                                                 Object);
                        }

                        if( status == STATUS_REPARSE ) {
                            //
                            // somebody else created the key in between; 
                            // let the Object Manager work for us !!!
                            // now we have the lock exclusive, so nothing can happen in between 
                            // next iterarion will find the key very quick
                            //
                            break;
                        }
                        lcontext->Disposition = REG_CREATED_NEW_KEY;
                        break;

                    } else {

                        //
                        // Did not find a key to match the component, and
                        // are not at the end of the path.  Thus, open must
                        // fail because the whole path dosn't exist, create must
                        // fail because more than 1 component doesn't exist.
                        //
                        //
                        // We have a lookup failure here, so having additional information
                        // about this kcb may help us not to go through all the code just to fail again.
                        // 
                        ParentKcb = CmpAddInfoAfterParseFailure(Hive,
                                                                Cell,
                                                                Node,
                                                                kcb,
                                                                &NextName
                                                                );
                        
                        if( ParentKcb == NULL ) {
                            //
                            // resource problem
                            //
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        } else {
                            status = STATUS_OBJECT_NAME_NOT_FOUND;
                        }
                        break;
                    }

                }

            } else {
                //
                // The given key was a symbolic link.  Find the name of
                // its link, and return STATUS_REPARSE to the Object Manager.
                //
                Current.Buffer = NextName.Buffer;
                Current.Length += NextName.Length;
                Current.MaximumLength += NextName.MaximumLength;
                if (CmpGetSymbolicLink(Hive,
                                       CompleteName,
                                       kcb,
                                       &Current)) {

                    status = STATUS_REPARSE;
                    break;

                } else {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey: couldn't find symbolic link name\n"));
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    break;
                }
            }

        } else if (rc == TRUE && Last == TRUE) {
            //
            // We will open the \Registry root.
            // Or some strange remaining name that
            // messes up the lookup.
            //
            CmpStepThroughExit(Hive, Cell, Node,HiveToRelease,CellToRelease);
            if( Node == NULL ) {
                //
                // we couldn't map view for this cell
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            //
            // We have found the entire path, so we want to open
            // it (for both Open and Create calls).
            // Hive,Cell -> the key we are supposed to open.
            //
            status = CmpDoOpen(Hive,
                               Cell,
                               Node,
                               AccessState,
                               AccessMode,
                               Attributes,
                               lcontext,
                               TRUE,
                               &kcb,
                               &NextName,
                               Object);
            break;

        } else {

            //
            // bogus path -> fail
            //
            status = STATUS_INVALID_PARAMETER;
            break;
        }

    } // while

FreeAndReturn:
    //
    // Now we have to free the last kcb that still has one extra reference count to
    // protect it from being freed.
    //

    if( ParentKcb != NULL ) {
        CmpDereferenceKeyControlBlock(ParentKcb);
    }
JustReturn:
    CmpReleasePreviousAndHookNew(NULL,HCELL_NIL,HiveToRelease,CellToRelease);

    CmpUnlockRegistry();
    END_LOCK_CHECKPOINT;

    //
    // PostCreate callback
    //
    if ( CmAreCallbacksRegistered() ) {
        if( ARGUMENT_PRESENT(lcontext) ) {
            //
            // NtCreateKey
            //
            REG_POST_CREATE_KEY_INFORMATION  PostCreateInfo;
       
            PostCreateInfo.CompleteName = CompleteName;
            PostCreateInfo.Object = Object;
            PostCreateInfo.Status = status;

            CmpCallCallBacks(RegNtPostCreateKey,&PostCreateInfo);
        } else {
            //
            // NtOpenKey
            //
            REG_POST_OPEN_KEY_INFORMATION  PostOpenInfo;
       
            PostOpenInfo.CompleteName = CompleteName;
            PostOpenInfo.Object = Object;
            PostOpenInfo.Status = status;

            CmpCallCallBacks(RegNtPostOpenKey,&PostOpenInfo);
        }
    }

    return status;
}


BOOLEAN
CmpGetNextName(
    IN OUT PUNICODE_STRING  RemainingName,
    OUT    PUNICODE_STRING  NextName,
    OUT    PBOOLEAN  Last
    )
/*++

Routine Description:

    This routine parses off the next component of a registry path, returning
    all of the interesting state about it, including whether it's legal.

Arguments:

    Current - supplies pointer to variable which points to path to parse.
              on input - parsing starts from here
              on output - updated to reflect starting position for next call.

    NextName - supplies pointer to a unicode_string, which will be set up
               to point into the parse string.

    Last - supplies a pointer to a boolean - set to TRUE if this is the
           last component of the name being parse, FALSE otherwise.

Return Value:

    TRUE if all is well.

    FALSE if illegal name (too long component, bad character, etc.)
        (if false, all out parameter values are bogus.)

--*/
{
    BOOLEAN rc = TRUE;

    //
    // Deal with NULL paths, and pointers to NULL paths
    //
    if ((RemainingName->Buffer == NULL) || (RemainingName->Length == 0)) {
        *Last = TRUE;
        NextName->Buffer = NULL;
        NextName->Length = 0;
        return TRUE;
    }

    if (*(RemainingName->Buffer) == UNICODE_NULL) {
        *Last = TRUE;
        NextName->Buffer = NULL;
        NextName->Length = 0;
        return TRUE;
    }

    //
    // Skip over leading path separators
    //
    if (*(RemainingName->Buffer) == OBJ_NAME_PATH_SEPARATOR) {
        RemainingName->Buffer++;
        RemainingName->Length -= sizeof(WCHAR);
        RemainingName->MaximumLength -= sizeof(WCHAR);
    }

    //
    // Remember where the component starts, and scan to the end
    //
    NextName->Buffer = RemainingName->Buffer;
    while (TRUE) {
        if (RemainingName->Length == 0) {
            break;
        }
        if (*RemainingName->Buffer == OBJ_NAME_PATH_SEPARATOR) {
            break;
        }

        //
        // NOT at end
        // NOT another path sep
        //

        RemainingName->Buffer++;
        RemainingName->Length -= sizeof(WCHAR);
        RemainingName->MaximumLength -= sizeof(WCHAR);
    }

    //
    // Compute component length, return error if it's illegal
    //
    NextName->Length = (USHORT)
        ((PUCHAR)RemainingName->Buffer - (PUCHAR)(NextName->Buffer));
    if (NextName->Length > REG_MAX_KEY_NAME_LENGTH)
    {
        rc = FALSE;
    }
    NextName->MaximumLength = NextName->Length;

	//
    // Set last, return success
    //
    *Last = (RemainingName->Length == 0);
    return rc;
}


NTSTATUS
CmpDoOpen(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PCM_KEY_NODE Node,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN PCM_PARSE_CONTEXT Context,
    IN BOOLEAN  CompleteKeyCached,
    IN OUT PCM_KEY_CONTROL_BLOCK  *CachedKcb,
    IN PUNICODE_STRING KeyName,
    OUT PVOID *Object
    )
/*++

Routine Description:

    Open a registry key, create a keycontrol block.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to delete

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    Context - if create or hive root open, points to a CM_PARSE_CONTEXT
              structure,
              if open, is NULL.

    CompleteKeyCached - BOOLEAN to indicate it the completekey is cached.

    CachedKcb - If the completekey is cached, this is the kcb for the destination.
                If not, this is the parent kcb.

    KeyName - Relative name (to BaseName)

    Object - The address of a variable to receive the created key object, if
             any.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PCM_KEY_BODY pbody;
    PCM_KEY_CONTROL_BLOCK kcb;
    KPROCESSOR_MODE   mode;
    BOOLEAN BackupRestore;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoOpen:\n"));

    if (ARGUMENT_PRESENT(Context)) {

        //
        // It's a create of some sort
        //
        if (Context->CreateLink) {
            //
            // The node already exists as a regular key, so it cannot be
            // turned into a link node.
            //
            return STATUS_ACCESS_DENIED;

        } else if (Context->CreateOptions & REG_OPTION_CREATE_LINK) {
            //
            // Attempt to create a symbolic link has hit an existing key
            // so return an error
            //
            return STATUS_OBJECT_NAME_COLLISION;

        } else {
            //
            // Operation is an open, so set Disposition
            //
            Context->Disposition = REG_OPENED_EXISTING_KEY;
        }
    }

    //
    // Check for symbolic link and caller does not want to open a link
    //
    if (CompleteKeyCached) {
        //
        // The complete key is cached.
        //
        BEGIN_KCB_LOCK_GUARD;                             
        CmpLockKCBTreeExclusive();
        if ((*CachedKcb)->Flags & KEY_SYM_LINK && !(Attributes & OBJ_OPENLINK)) {
            //
            // If the key is a symbolic link, check if the link has been resolved.
            // If the link is resolved, change the kcb to the real KCB.
            // Otherwise, return for reparse.
            //
            if ((*CachedKcb)->ExtFlags & CM_KCB_SYM_LINK_FOUND) {
                kcb = (*CachedKcb)->ValueCache.RealKcb;

                if (kcb->Delete == TRUE) {
                    //
                    // The real key it pointes to had been deleted.
                    // We have no way of knowing if the key has been recreated.
                    // Just clean up the cache and do a reparse.
                    //
                    CmpCleanUpKcbValueCache(*CachedKcb);
                    CmpUnlockKCBTree();
                    return(STATUS_REPARSE);
                }

                if (!CmpReferenceKeyControlBlock(kcb)) {
                    CmpUnlockKCBTree();
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                CmpUnlockKCBTree();
                return(STATUS_REPARSE);
            }
        } else {
            //
            // Not a symbolic link, increase the reference Count of Kcb.
            //
            kcb = *CachedKcb;
            if (!CmpReferenceKeyControlBlock(kcb)) {
                CmpUnlockKCBTree();
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        CmpUnlockKCBTree();
        END_KCB_LOCK_GUARD;                             
   } else {
            //
            // The key is not in cache, the CachedKcb is the parentkcb of this
            // key to be opened.
            //

        if (Node->Flags & KEY_SYM_LINK && !(Attributes & OBJ_OPENLINK)) {
            //
            // Create a KCB for this symbolic key and put it in delay close.
            //
            kcb = CmpCreateKeyControlBlock(Hive, Cell, Node, *CachedKcb, FALSE, KeyName);
            if (kcb  == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            CmpDereferenceKeyControlBlock(kcb);
            *CachedKcb = kcb;
            return(STATUS_REPARSE);
        }
    
        //
        // If key control block does not exist, and cannot be created, fail,
        // else just increment the ref count (done for us by CreateKeyControlBlock)
        //
        kcb = CmpCreateKeyControlBlock(Hive, Cell, Node, *CachedKcb, FALSE, KeyName);
        if (kcb  == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        ASSERT(kcb->Delete == FALSE);
    
        *CachedKcb = kcb;
    }

#if DBG
   if( kcb->ExtFlags & CM_KCB_KEY_NON_EXIST ) {
        //
        // we shouldn't fall into this
        //
        DbgBreakPoint();
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
#endif //DBG
    //
    // Allocate the object.
    //
    status = ObCreateObject(AccessMode,
                            CmpKeyObjectType,
                            NULL,
                            AccessMode,
                            NULL,
                            sizeof(CM_KEY_BODY),
                            0,
                            0,
                            Object);

    if (NT_SUCCESS(status)) {

        pbody = (PCM_KEY_BODY)(*Object);

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"CmpDoOpen: object allocated at:%p\n", pbody));

        //
        // Check for predefined handle
        //

        pbody = (PCM_KEY_BODY)(*Object);

        if (kcb->Flags & KEY_PREDEF_HANDLE) {
            pbody->Type = kcb->ValueCache.Count;
            pbody->KeyControlBlock = kcb;
            return(STATUS_PREDEFINED_HANDLE);
        } else {
            //
            // Fill in CM specific fields in the object
            //
            pbody->Type = KEY_BODY_TYPE;
            pbody->KeyControlBlock = kcb;
            pbody->NotifyBlock = NULL;
            pbody->Process = PsGetCurrentProcess();
            ENLIST_KEYBODY_IN_KEYBODY_LIST(pbody);
        }

#ifdef CM_BREAK_ON_KEY_OPEN
		if( kcb->Flags & KEY_BREAK_ON_OPEN ) {
			DbgPrint("\n\n Current process is opening a key tagged as BREAK ON OPEN\n");
			DbgPrint("\nPlease type the following in the debugger window: !reg kcb %p\n\n\n",kcb);
			
			try {
				DbgBreakPoint();
			} except (EXCEPTION_EXECUTE_HANDLER) {

				//
				// no debugger enabled, just keep going
				//

			}
		}
#endif //CM_BREAK_ON_KEY_OPEN

    } else {

        //
        // Failed to create object, so undo key control block work
        //
        CmpDereferenceKeyControlBlock(kcb);
        return status;
    }

    //
    // Check to make sure the caller can access the key.
    //
    BackupRestore = FALSE;
    if (ARGUMENT_PRESENT(Context)) {
        if (Context->CreateOptions & REG_OPTION_BACKUP_RESTORE) {
            BackupRestore = TRUE;
        }
    }

    status = STATUS_SUCCESS;

    if (BackupRestore == TRUE) {

        //
        // this is an open to support a backup or restore
        // operation, do the special case work
        //
        AccessState->RemainingDesiredAccess = 0;
        AccessState->PreviouslyGrantedAccess = 0;

        mode = KeGetPreviousMode();

        if (SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
            AccessState->PreviouslyGrantedAccess |=
                KEY_READ | ACCESS_SYSTEM_SECURITY;
        }

        if (SeSinglePrivilegeCheck(SeRestorePrivilege, mode)) {
            AccessState->PreviouslyGrantedAccess |=
                KEY_WRITE | ACCESS_SYSTEM_SECURITY | WRITE_DAC | WRITE_OWNER;
        }

        if (AccessState->PreviouslyGrantedAccess == 0) {
            //
            // relevent privileges not asserted/possessed, so
            // deref (which will cause CmpDeleteKeyObject to clean up)
            // and return an error.
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoOpen for backup restore: access denied\n"));
#ifdef CM_CHECK_FOR_ORPHANED_KCBS
            //DbgPrint("CmpDoOpen for backup restore: access denied , hive = %p\n",Hive);
#endif //CM_CHECK_FOR_ORPHANED_KCBS
            ObDereferenceObject(*Object);
            return STATUS_ACCESS_DENIED;
        }

    } else {

        if (!ObCheckObjectAccess(*Object,
                                  AccessState,
                                  TRUE,         // Type mutex already locked
                                  AccessMode,
                                  &status))
        {
            //
            // Access denied, so deref object, will cause CmpDeleteKeyObject
            // to be called, it will clean up.
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoOpen: access denied\n"));
#ifdef CM_CHECK_FOR_ORPHANED_KCBS
            //DbgPrint("CmpDoOpen: access denied , hive = %p\n",Hive);
#endif //CM_CHECK_FOR_ORPHANED_KCBS
            ObDereferenceObject(*Object);
        }
    }

    return status;
}

#ifdef CM_CHECK_FOR_ORPHANED_KCBS
ULONG   CmpCheckOrphanedKcbFix = 0;
#endif //CM_CHECK_FOR_ORPHANED_KCBS

NTSTATUS
CmpCreateLinkNode(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PACCESS_STATE AccessState,
    IN UNICODE_STRING Name,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN PCM_PARSE_CONTEXT Context,
    IN PCM_KEY_CONTROL_BLOCK ParentKcb,
    OUT PVOID *Object
    )
/*++

Routine Description:

    Perform the creation of a link node.  Allocate all components,
    and attach to parent key.  Calls CmpDoCreate or CmpDoOpen to
    create or open the root node of the hive as appropriate.

    Note that you can only create link nodes in the master hive.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to create child under

    Name - supplies pointer to a UNICODE string which is the name of
            the child to be created.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    Context - pointer to CM_PARSE_CONTEXT structure passed through
                the object manager

    BaseName - Name of object create is relative to

    KeyName - Relative name (to BaseName)

    Object - The address of a variable to receive the created key object, if
             any.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                Status;
    PCELL_DATA              Parent;
    PCELL_DATA              Link;
    PCELL_DATA              CellData;
    HCELL_INDEX             LinkCell;
    HCELL_INDEX             KeyCell;
    HCELL_INDEX             ChildCell;
    PCM_KEY_CONTROL_BLOCK   kcb = ParentKcb;  
    PCM_KEY_BODY            KeyBody;
    LARGE_INTEGER           systemtime;
    PCM_KEY_NODE            TempNode;
    LARGE_INTEGER           TimeStamp;

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpCreateLinkNode:\n"));

    if (Hive != &CmpMasterHive->Hive) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpCreateLinkNode: attempt to create link node in\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"    non-master hive %p\n", Hive));
        return(STATUS_ACCESS_DENIED);
    }

#if DBG
    //
    // debug only code
    //
    *Object = NULL;
#endif
    //
    // this is a create, so we need exclusive access on the registry
    // first get the time stamp to see if somebody messed with this key
    // this might be more easier if we decide to cache the LastWriteTime
    // in the KCB ; now it IS !!!
    //
    if( CmIsKcbReadOnly(ParentKcb) ) {
        //
        // key is protected
        //
        return STATUS_ACCESS_DENIED;
    } 

    TimeStamp = ParentKcb->KcbLastWriteTime;

    CmpUnlockRegistry();
    CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
    CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

    //
    // make sure nothing changed in between:
    //  1. ParentKcb is still valid
    //  2. Child was not already added by somebody else 
    //
    if( ParentKcb->Delete ) {
        //
        // key was deleted in between
        //
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if( TimeStamp.QuadPart != ParentKcb->KcbLastWriteTime.QuadPart ) {
        //
        // key was changed in between; possibly this key was already created ==> reparse
        //
        return STATUS_REPARSE;
    }

    //
    // Allocate link node
    //
    // Link nodes are always in the master hive, so their storage type is
    // mostly irrelevent.
    //
    LinkCell = HvAllocateCell(Hive,  CmpHKeyNodeSize(Hive, &Name), Stable,HCELL_NIL);
    if (LinkCell == HCELL_NIL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeyCell = Context->ChildHive.KeyCell;

    if (KeyCell != HCELL_NIL) {

        //
        // This hive already exists, so we just need to open the root node.
        //
        ChildCell=KeyCell;

        //
        // The root cell in the hive does not has the Name buffer 
        // space reseverd.  This is why we need to pass in the Name for creating KCB
        // instead of using the name in the keynode.
        //
        CellData = HvGetCell(Context->ChildHive.KeyHive, ChildCell);
        if( CellData == NULL ) {
            //
            // we couldn't map the bin contianing this cell
            //
            HvFreeCell(Hive, LinkCell);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Context->ChildHive.KeyHive, ChildCell);

        CellData->u.KeyNode.Parent = LinkCell;
        CellData->u.KeyNode.Flags |= KEY_HIVE_ENTRY | KEY_NO_DELETE;

        TempNode = (PCM_KEY_NODE)HvGetCell(Context->ChildHive.KeyHive,KeyCell);
        if( TempNode == NULL ) {
            //
            // we couldn't map the bin contianing this cell
            //
            HvFreeCell(Hive, LinkCell);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Context->ChildHive.KeyHive,KeyCell);

        Status = CmpDoOpen( Context->ChildHive.KeyHive,
                            KeyCell,
                            TempNode,
                            AccessState,
                            AccessMode,
                            Attributes,
                            NULL,
                            FALSE,
                            &kcb,
                            &Name,
                            Object );
    } else {

        //
        // This is a newly created hive, so we must allocate and initialize
        // the root node.
        //

        Status = CmpDoCreateChild( Context->ChildHive.KeyHive,
                                   Cell,
                                   NULL,
                                   AccessState,
                                   &Name,
                                   AccessMode,
                                   Context,
                                   ParentKcb,
                                   KEY_HIVE_ENTRY | KEY_NO_DELETE,
                                   &ChildCell,
                                   Object );

        if (NT_SUCCESS(Status)) {

            //
            // Initialize hive root cell pointer.
            //

            Context->ChildHive.KeyHive->BaseBlock->RootCell = ChildCell;
        }

    }
    if (NT_SUCCESS(Status)) {

#ifdef CM_CHECK_FOR_ORPHANED_KCBS
        if(CmpCheckOrphanedKcbFix) {
            DbgPrint("CmpCreateLinkNode: Force return with STATUS_NO_LOG_SPACE\n");
            Status = STATUS_NO_LOG_SPACE;
            goto Cleanup;
        }
#endif //CM_CHECK_FOR_ORPHANED_KCBS
        //
        // Initialize parent and flags.  Note that we do this whether the
        // root has been created or opened, because we are not guaranteed
        // that the link node is always the same cell in the master hive.
        //
        if (!HvMarkCellDirty(Context->ChildHive.KeyHive, ChildCell)) {
            Status = STATUS_NO_LOG_SPACE;
            goto Cleanup;
        }
        CellData = HvGetCell(Context->ChildHive.KeyHive, ChildCell);
        if( CellData == NULL ) {
            //
            // we couldn't map the bin contianing this cell
            //
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Context->ChildHive.KeyHive, ChildCell);

        CellData->u.KeyNode.Parent = LinkCell;
        CellData->u.KeyNode.Flags |= KEY_HIVE_ENTRY | KEY_NO_DELETE;

        //
        // Initialize special link node flags and data
        //
        Link = HvGetCell(Hive, LinkCell);
        if( Link == NULL ) {
            //
            // we couldn't map the bin contianing this cell
            // this shouldn't happen as we just allocated this cell
            // (i.e. it should be PINNED in memory at this point)
            //
            ASSERT( FALSE );
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive,LinkCell);

        Link->u.KeyNode.Signature = CM_LINK_NODE_SIGNATURE;
        Link->u.KeyNode.Flags = KEY_HIVE_EXIT | KEY_NO_DELETE;
        Link->u.KeyNode.Parent = Cell;
        Link->u.KeyNode.NameLength = CmpCopyName(Hive, Link->u.KeyNode.Name, &Name);
        if (Link->u.KeyNode.NameLength < Name.Length) {
            Link->u.KeyNode.Flags |= KEY_COMP_NAME;
        }

        KeQuerySystemTime(&systemtime);
        Link->u.KeyNode.LastWriteTime = systemtime;

        //
        // Zero out unused fields.
        //
        Link->u.KeyNode.SubKeyCounts[Stable] = 0;
        Link->u.KeyNode.SubKeyCounts[Volatile] = 0;
        Link->u.KeyNode.SubKeyLists[Stable] = HCELL_NIL;
        Link->u.KeyNode.SubKeyLists[Volatile] = HCELL_NIL;
        Link->u.KeyNode.ValueList.Count = 0;
        Link->u.KeyNode.ValueList.List = HCELL_NIL;
        Link->u.KeyNode.ClassLength = 0;


        //
        // Fill in the link node's pointer to the root node
        //
        Link->u.KeyNode.ChildHiveReference.KeyHive = Context->ChildHive.KeyHive;
        Link->u.KeyNode.ChildHiveReference.KeyCell = ChildCell;

        //
        // get the parent first, we don't need to do unneccessary cleanup
        //
        Parent = HvGetCell(Hive, Cell);
        if( Parent == NULL ) {
            //
            // we couldn't map the bin contianing this cell
            //
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive,Cell);

        //
        // Fill in the parent cell's child list
        //
        if (! CmpAddSubKey(Hive, Cell, LinkCell)) {
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // If the parent has the subkey info or hint cached, free it.
        //
        ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
        KeyBody = (PCM_KEY_BODY)(*Object);
        CmpCleanUpSubKeyInfo (KeyBody->KeyControlBlock->ParentKcb);

        //
        // Update max keyname and class name length fields
        //

        //
        // It seems to me that the original code is wrong.
        // Isn't the definition of MaxNameLen just the length of the subkey?
        //
        
        // some sanity asserts
        ASSERT( KeyBody->KeyControlBlock->ParentKcb->KeyCell == Cell );
        ASSERT( KeyBody->KeyControlBlock->ParentKcb->KeyHive == Hive );
        ASSERT( KeyBody->KeyControlBlock->ParentKcb->KcbMaxNameLen == Parent->u.KeyNode.MaxNameLen );
        
        //
        // update the LastWriteTime on both keynode and kcb;
        //
        KeQuerySystemTime(&systemtime);
        Parent->u.KeyNode.LastWriteTime = systemtime;
        KeyBody->KeyControlBlock->ParentKcb->KcbLastWriteTime = systemtime;

        if (Parent->u.KeyNode.MaxNameLen < Name.Length) {
            Parent->u.KeyNode.MaxNameLen = Name.Length;
            KeyBody->KeyControlBlock->ParentKcb->KcbMaxNameLen = Name.Length;
        }

        if (Parent->u.KeyNode.MaxClassLen < Context->Class.Length) {
            Parent->u.KeyNode.MaxClassLen = Context->Class.Length;
        }
Cleanup:
        if( !NT_SUCCESS(Status) ) {
            ASSERT( (*Object) != NULL );
            //
            // mark the kcb as "no-delay-close" so it gets kicked out of cache when 
            // refcount goes down to 0
            //
            KeyBody = (PCM_KEY_BODY)(*Object);
            ASSERT( KeyBody->KeyControlBlock );
            ASSERT_KCB( KeyBody->KeyControlBlock );
            KeyBody->KeyControlBlock->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;
            
            ObDereferenceObject(*Object);
        }

    } else {
        HvFreeCell(Hive, LinkCell);
    }

    return(Status);
}

BOOLEAN
CmpGetSymbolicLink(
    IN PHHIVE Hive,
    IN OUT PUNICODE_STRING ObjectName,
    IN OUT PCM_KEY_CONTROL_BLOCK SymbolicKcb,
    IN PUNICODE_STRING RemainingName OPTIONAL
    )

/*++

Routine Description:

    This routine extracts the symbolic link name from a key, if it is
    marked as a symbolic link.

Arguments:

    Hive - Supplies the hive of the key.

    ObjectName - Supplies the current ObjectName.
                 Returns the new ObjectName.  If the new name is longer
                 than the maximum length of the current ObjectName, the
                 old buffer will be freed and a new buffer allocated.

    RemainingName - Supplies the remaining path.  If present, this will be
                concatenated with the symbolic link to form the new objectname.

Return Value:

    TRUE - symbolic link succesfully found

    FALSE - Key is not a symbolic link, or an error occurred

--*/

{
    NTSTATUS                Status;
    HCELL_INDEX             LinkCell = HCELL_NIL;
    PHCELL_INDEX            Index;
    PCM_KEY_VALUE           LinkValue = NULL;
    PWSTR                   LinkName;
    BOOLEAN                 LinkNameAllocated = FALSE;
    PWSTR                   NewBuffer;
    ULONG                   Length;
    ULONG                   ValueLength;
    extern ULONG            CmpHashTableSize; 
    extern PCM_KEY_HASH     *CmpCacheTable;
    PUNICODE_STRING         ConstructedName;
    ULONG                   ConvKey=0;
    PCM_KEY_HASH            KeyHash;
    PCM_KEY_CONTROL_BLOCK   RealKcb;
    BOOLEAN                 KcbFound = FALSE;
    ULONG                   Cnt;
    WCHAR                   *Cp;
    WCHAR                   *Cp2;
    ULONG                   TotalLevels;
    BOOLEAN                 FreeConstructedName = FALSE;
    BOOLEAN                 Result = TRUE;
    HCELL_INDEX             CellToRelease = HCELL_NIL;
#ifdef CM_DYN_SYM_LINK
    BOOLEAN                 DynamicLink = FALSE;
    PWSTR                   ExpandedLinkName = NULL;
#endif //CM_DYN_SYM_LINK
    
    BEGIN_KCB_LOCK_GUARD;                             
    CmpLockKCBTree();
    if (SymbolicKcb->ExtFlags & CM_KCB_SYM_LINK_FOUND) {
        //
        // First see of the real kcb for this symbolic name has been found
        // 
        ConstructedName = CmpConstructName(SymbolicKcb->ValueCache.RealKcb);
        if (ConstructedName) {
            FreeConstructedName = TRUE;
            LinkName = ConstructedName->Buffer;
            ValueLength = ConstructedName->Length;
            Length = (USHORT)ValueLength + sizeof(WCHAR);
        }
    } 
    CmpUnlockKCBTree();
    END_KCB_LOCK_GUARD;                             

    if (FreeConstructedName == FALSE) {
        PCM_KEY_NODE Node;
        //
        // Find the SymbolicLinkValue value.  This is the name of the symbolic link.
        //
        Node = (PCM_KEY_NODE)HvGetCell(SymbolicKcb->KeyHive,SymbolicKcb->KeyCell);
        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            Result = FALSE;
            goto Exit;
        }

        LinkCell = CmpFindValueByName(Hive,
                                      Node,
                                      &CmSymbolicLinkValueName);
        // release the node here as we don't need it anymore
        HvReleaseCell(SymbolicKcb->KeyHive,SymbolicKcb->KeyCell);
        if (LinkCell == HCELL_NIL) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpGetSymbolicLink: couldn't open symbolic link\n"));
            Result = FALSE;
            goto Exit;
        }
    
        LinkValue = (PCM_KEY_VALUE)HvGetCell(Hive, LinkCell);
        if( LinkValue == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            Result = FALSE;
            goto Exit;
        }
    
#ifdef CM_DYN_SYM_LINK
        if( LinkValue->Type == REG_DYN_LINK ) {
            //
            // we have found a dynamic link
            //
            DynamicLink = TRUE;
        } else 
#endif //CM_DYN_SYM_LINK
            if (LinkValue->Type != REG_LINK) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpGetSymbolicLink: link value is wrong type: %08lx", LinkValue->Type));
            Result = FALSE;
            goto Exit;
        }
    

        if( CmpGetValueData(Hive,LinkValue,&ValueLength,&LinkName,&LinkNameAllocated,&CellToRelease) == FALSE ) {
            //
            // insufficient resources; return NULL
            //
            ASSERT( LinkNameAllocated == FALSE );
            ASSERT( LinkName == NULL );
            Result = FALSE;
            goto Exit;
        }
    
#ifdef CM_DYN_SYM_LINK
        if( DynamicLink == TRUE ) {
            ULONG           DestLength;
            ExpandedLinkName = CmpExpandEnvVars(LinkName,ValueLength,&DestLength);
            
            if( ExpandedLinkName == NULL ) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Dynamic link not resolved !\n"));
                Result = FALSE;
                goto Exit;
            } 
            
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Dynamic link resolved to: (%.*S)\n",DestLength/sizeof(WCHAR),ExpandedLinkName));
            //
            // if we are here, we successfully resolved the link
            //
            LinkName = ExpandedLinkName;
            ValueLength = DestLength;
                        
        }
#endif //CM_DYN_SYM_LINK

        Length = (USHORT)ValueLength + sizeof(WCHAR);

#ifdef CM_DYN_SYM_LINK
        if( DynamicLink == FALSE ) {
#endif //CM_DYN_SYM_LINK
            //
            // Now see if we have this kcb cached.
            //
            Cp = LinkName;
            //
            // first char SHOULD be OBJ_NAME_PATH_SEPARATOR, otherwise we could get into real trouble!!!
            //
            if( *Cp != OBJ_NAME_PATH_SEPARATOR ) {
                Result = FALSE;
                goto Exit;
            }

            TotalLevels = 0;
            for (Cnt=0; Cnt<ValueLength; Cnt += sizeof(WCHAR)) {
                if (*Cp != OBJ_NAME_PATH_SEPARATOR) {
                    ConvKey = 37 * ConvKey + (ULONG) RtlUpcaseUnicodeChar(*Cp);
                } else {
                    TotalLevels++;
                }
                ++Cp;
            }

        
            BEGIN_KCB_LOCK_GUARD;    
            CmpLockKCBTreeExclusive();

            KeyHash = GET_HASH_ENTRY(CmpCacheTable, ConvKey); 

            while (KeyHash) {
                RealKcb =  CONTAINING_RECORD(KeyHash, CM_KEY_CONTROL_BLOCK, KeyHash);
                if ((ConvKey == KeyHash->ConvKey) && (TotalLevels == RealKcb->TotalLevels) && (!(RealKcb->ExtFlags & CM_KCB_KEY_NON_EXIST)) ) {
                    ConstructedName = CmpConstructName(RealKcb);
                    if (ConstructedName) {
                        FreeConstructedName = TRUE;
                        if (ConstructedName->Length == ValueLength) {
                            KcbFound = TRUE;
                            Cp = LinkName;
                            Cp2 = ConstructedName->Buffer;
                            for (Cnt=0; Cnt<ConstructedName->Length; Cnt += sizeof(WCHAR)) {
                                if (RtlUpcaseUnicodeChar(*Cp) != RtlUpcaseUnicodeChar(*Cp2)) {
                                    KcbFound = FALSE;
                                    break;
                                }
                                ++Cp;
                                ++Cp2;
                            }
                            if (KcbFound) {
                                //
                                // Now the RealKcb is also pointed to by its symbolic link Kcb,
                                // Increase the reference count.
                                // Need to dereference the realkcb when the symbolic kcb is removed.
                                // Do this in CmpCleanUpKcbCacheWithLock();
                                //
                                if (CmpReferenceKeyControlBlock(RealKcb)) {
                                    //
                                    // This symbolic kcb may have value lookup for the path
                                    // Cleanup the value cache.
                                    //
                                    CmpCleanUpKcbValueCache(SymbolicKcb);
    
                                    SymbolicKcb->ExtFlags |= CM_KCB_SYM_LINK_FOUND;
                                    SymbolicKcb->ValueCache.RealKcb = RealKcb;
                                } else {
                                    //
                                    // We have maxed out the ref count on the real kcb.
                                    // do not cache the symbolic link.
                                    //
                                }
                                break;
                            }
                        }
                    } else {
                        break;
                    }
                }
                if (FreeConstructedName) {
                    ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
                    FreeConstructedName = FALSE;
                }
                KeyHash = KeyHash->NextHash;
            }
            CmpUnlockKCBTree();
            END_KCB_LOCK_GUARD;    
#ifdef CM_DYN_SYM_LINK
        }
#endif //CM_DYN_SYM_LINK
    }
    
    if (ARGUMENT_PRESENT(RemainingName)) {
        Length += RemainingName->Length + sizeof(WCHAR);
    }

    //
    // Overflow test: If Length overflows the USHRT_MAX value
    //                cleanup and return FALSE  
    //
    if( Length>0xFFFF ) {
        Result = FALSE;
        goto Exit;
    }

	if (Length > ObjectName->MaximumLength) {
        UNICODE_STRING NewObjectName;

        //
        // The new name is too long to fit in the existing ObjectName buffer,
        // so allocate a new buffer.
        //
        NewBuffer = ExAllocatePool(PagedPool, Length);
        if (NewBuffer == NULL) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpGetSymbolicLink: couldn't allocate new name buffer\n"));
            Result = FALSE;
            goto Exit;
        }

        NewObjectName.Buffer = NewBuffer;
        NewObjectName.MaximumLength = (USHORT)Length;
        NewObjectName.Length = (USHORT)ValueLength;
        RtlCopyMemory(NewBuffer, LinkName, ValueLength);
#if DBG
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpGetSymbolicLink: LinkName is %wZ\n", ObjectName));
        if (ARGUMENT_PRESENT(RemainingName)) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"               RemainingName is %wZ\n", RemainingName));
        } else {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"               RemainingName is NULL\n"));
        }
#endif
        if (ARGUMENT_PRESENT(RemainingName)) {
            NewBuffer[ ValueLength / sizeof(WCHAR) ] = OBJ_NAME_PATH_SEPARATOR;
            NewObjectName.Length += sizeof(WCHAR);
            Status = RtlAppendUnicodeStringToString(&NewObjectName, RemainingName);
            ASSERT(NT_SUCCESS(Status));
        }

        ExFreePool(ObjectName->Buffer);
        *ObjectName = NewObjectName;
    } else {
        //
        // The new name will fit within the maximum length of the existing
        // ObjectName, so do the expansion in-place. Note that the remaining
        // name must be moved into its new position first since the symbolic
        // link may or may not overlap it.
        //
        ObjectName->Length = (USHORT)ValueLength;
        if (ARGUMENT_PRESENT(RemainingName)) {
            RtlMoveMemory(&ObjectName->Buffer[(ValueLength / sizeof(WCHAR)) + 1],
                          RemainingName->Buffer,
                          RemainingName->Length);
            ObjectName->Buffer[ValueLength / sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
            ObjectName->Length += RemainingName->Length + sizeof(WCHAR);
        }
        RtlCopyMemory(ObjectName->Buffer, LinkName, ValueLength);
    }
    ObjectName->Buffer[ObjectName->Length / sizeof(WCHAR)] = UNICODE_NULL;

Exit:
    if( LinkNameAllocated ) {
        ExFreePool(LinkName);
    }
    if (FreeConstructedName) {
        ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
    }
#ifdef CM_DYN_SYM_LINK
    if( ExpandedLinkName ) {
        ExFreePool(ExpandedLinkName);
    }
#endif //CM_DYN_SYM_LINK
    if( LinkValue != NULL ) {
        ASSERT( LinkCell != HCELL_NIL );
        HvReleaseCell(Hive,LinkCell);
    }
    if( CellToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive,CellToRelease);
    }
    return Result;
}


ULONG
CmpComputeHashValue(
    IN PCM_HASH_ENTRY HashStack,
    IN OUT ULONG  *TotalSubkeys,
    IN ULONG BaseConvKey,
    IN PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine parses the complete path of a request registry key and calculate
    the hash value at each level.

Arguments:

    HashStack - Array for filling the hash value of each level.

    TotalSubkeys - a pointer to fill the total number of subkeys

    BaseConvKey - Supplies the convkey for the base key.

    RemainingName - supplies pointer to a unicode_string for RemainingName.

Return Value:

    Number of Levels in RemainingName

--*/

{
    ULONG  TotalRemainingSubkeys=0;
    ULONG  TotalKeys=0;
    ULONG  ConvKey=BaseConvKey;
    USHORT  Cnt;
    WCHAR *Cp;
    WCHAR *Begin;
    USHORT Length;

    if (RemainingName->Length) {
        Cp = RemainingName->Buffer;
        Cnt = RemainingName->Length;

        //Skip the leading OBJ_NAME_PATH_SEPARATOR

        while (*Cp == OBJ_NAME_PATH_SEPARATOR) {
            Cp++;
            Cnt -= sizeof(WCHAR);
        }
        Begin = Cp;
        Length = 0;

        HashStack[TotalRemainingSubkeys].KeyName.Buffer = Cp;

        while (Cnt) {
            if (*Cp == OBJ_NAME_PATH_SEPARATOR) {
                if (TotalRemainingSubkeys < CM_HASH_STACK_SIZE) {
                    HashStack[TotalRemainingSubkeys].ConvKey = ConvKey;
                    //
                    // Due to the changes in KCB structure, we now only have the subkey name
                    // in the kcb (not the full path).  Change the name in the stack to store
                    // the parse element (each subkey) only.
                    //
                    HashStack[TotalRemainingSubkeys].KeyName.Length = Length;
                    Length = 0;
                    TotalRemainingSubkeys++;
                }

                TotalKeys++;

                //
                // Now skip over leading path separators
                // Just in case someone has a RemainingName '..A\\\\B..'
                //
                //
                // We are stripping all OBJ_NAME_PATH_SEPARATOR (The origainl code keep the first one).
                // so the KeyName.Buffer is set properly.
                //
                while(*Cp == OBJ_NAME_PATH_SEPARATOR) {
                    Cp++;
                    Cnt -= sizeof(WCHAR);
                }
                if (TotalRemainingSubkeys < CM_HASH_STACK_SIZE) {
                    HashStack[TotalRemainingSubkeys].KeyName.Buffer = Cp;
                }

            } else {
                ConvKey = 37 * ConvKey + (ULONG) RtlUpcaseUnicodeChar(*Cp);
                //
                // We are stripping all OBJ_NAME_PATH_SEPARATOR in the above code,
                // we should only move to the next char in the else case.
                //
                Cp++;
                Cnt -= sizeof(WCHAR);
                Length += sizeof(WCHAR);
            
            }


        }

        //
        // Since we have stripped off all trailing path separators in CmpParseKey routine,
        // the last char will not be OBJ_NAME_PATH_SEPARATOR.
        //
        if (TotalRemainingSubkeys < CM_HASH_STACK_SIZE) {
            HashStack[TotalRemainingSubkeys].ConvKey = ConvKey;
            HashStack[TotalRemainingSubkeys].KeyName.Length = Length;
            TotalRemainingSubkeys++;
        }
        TotalKeys++;

        (*TotalSubkeys) = TotalKeys;
    }

    return(TotalRemainingSubkeys);
}
NTSTATUS
CmpCacheLookup(
    IN PCM_HASH_ENTRY HashStack,
    IN ULONG TotalRemainingSubkeys,
    OUT ULONG *MatchRemainSubkeyLevel,
    IN OUT PCM_KEY_CONTROL_BLOCK *Kcb,
    OUT PUNICODE_STRING RemainingName,
    OUT PHHIVE *Hive,
    OUT HCELL_INDEX *Cell
    )
/*++

Routine Description:

    This routine Search the cache to find the matching path in the Cache.

Arguments:

    HashStack - Array that has the hash value of each level.

    TotalRemainingSubkeys - Total Subkey counts from base.

    MatchRemainSubkeyLevel - Number of Levels in RemaingName 
                             that matches. (0 if not found)

    kcb - Pointer to the kcb of the basename.
          Will be changed to the kcb for the new basename.

    RemainingName - Returns remaining name

    Hive - Returns the hive of the cache entry found (if any)

    Cell - Returns the cell of the cache entry found (if any)

Return Value:

    Status

--*/

{
    LONG i;
    LONG j;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG CurrentLevel;
    PCM_KEY_HASH Current;
    PCM_KEY_CONTROL_BLOCK BaseKcb;
    PCM_KEY_CONTROL_BLOCK CurrentKcb;
    PCM_KEY_CONTROL_BLOCK ParentKcb;
    BOOLEAN Found = FALSE;

    BaseKcb = *Kcb;
    CurrentLevel = TotalRemainingSubkeys + BaseKcb->TotalLevels + 1;

    for(i = TotalRemainingSubkeys-1; i>=0; i--) {
        //
        // Try to find the longest path in the cache.
        //
        // First, find the kcb that match the hash value.
        //

        CurrentLevel--; 

        Current = GET_HASH_ENTRY(CmpCacheTable, HashStack[i].ConvKey);

        while (Current) {
            ASSERT_KEY_HASH(Current);

            //
            // Check against both the ConvKey and total levels;
            //
            CurrentKcb = (CONTAINING_RECORD(Current, CM_KEY_CONTROL_BLOCK, KeyHash));

            if (CurrentKcb->TotalLevels == CurrentLevel) {
                //
                // The total subkey levels match.
                // Iterate through the kcb path and compare each subkey.
                //
                Found = TRUE;
                ParentKcb = CurrentKcb;
                for (j=i; j>=0; j--) {
                    if (HashStack[j].ConvKey == ParentKcb->ConvKey) {
                        //
                        // Convkey matches, compare the string
                        //
                        LONG Result;
                        UNICODE_STRING  TmpNodeName;

                        if (ParentKcb->NameBlock->Compressed) {
                               Result = CmpCompareCompressedName(&(HashStack[j].KeyName),
                                                                 ParentKcb->NameBlock->Name, 
                                                                 ParentKcb->NameBlock->NameLength,
                                                                 CMP_DEST_UP // name block is always UPPERCASE!!!
                                                                 ); 
                        } else {
                               TmpNodeName.Buffer = ParentKcb->NameBlock->Name;
                               TmpNodeName.Length = ParentKcb->NameBlock->NameLength;
                               TmpNodeName.MaximumLength = ParentKcb->NameBlock->NameLength;

                               //
                               // use the cmp compare variant as we know the destination is already uppercased.
                               //
                               Result = CmpCompareUnicodeString(&(HashStack[j].KeyName),
                                                                &TmpNodeName, 
                                                                CMP_DEST_UP);
                        }

                        if (Result) {
                            Found = FALSE;
                            break;
                        } 
                        ParentKcb = ParentKcb->ParentKcb;
                    } else {
                        Found = FALSE;
                        break;
                    }
                }
                if (Found) {
                    //
                    // All remaining key matches.  Now compare the BaseKcb.
                    //
                    if (BaseKcb == ParentKcb) {
                        if (CurrentKcb->ParentKcb->Delete) {
                            //
                            // The parentkcb is marked deleted.  
                            // So this must be a fake key created when the parent still existed.
                            // Otherwise it cannot be in the cache
                            //
                            ASSERT (CurrentKcb->ExtFlags & CM_KCB_KEY_NON_EXIST);

                            //
                            // It is possible that the parent key was deleted but now recreated.
                            // In that case this fake key is not longer valid for the ParentKcb is bad.
                            // We must now remove this fake key out of cache so, if this is a
                            // create operation, we do get hit this kcb in CmpCreateKeyControlBlock. 
                            //
                            if (CurrentKcb->RefCount == 0) {
                                //
                                // No one is holding this fake kcb, just delete it.
                                //
                                CmpRemoveFromDelayedClose(CurrentKcb);
                                CmpCleanUpKcbCacheWithLock(CurrentKcb);
                            } else {
                                //
                                // Someone is still holding this fake kcb, 
                                // Mark it as delete and remove it out of cache.
                                //
                                CurrentKcb->Delete = TRUE;
                                CmpRemoveKeyControlBlock(CurrentKcb);
                            }
                            Found = FALSE;
                            break;
                        } else if(CurrentKcb->Delete) {
                            //
                            // the key has been deleted, but still kept in the cache for 
                            // this kcb does not belong here
                            //
                            CmpRemoveKeyControlBlock(CurrentKcb);
                            return STATUS_OBJECT_NAME_NOT_FOUND;
                        }

                        
                        //
                        // We have a match, update the RemainingName.
                        //

                        //
                        // Skip the leading OBJ_NAME_PATH_SEPARATOR
                        //
                        while ((RemainingName->Length > 0) &&
                               (RemainingName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
                            RemainingName->Buffer++;
                            RemainingName->Length -= sizeof(WCHAR);
                        }

                        //
                        // Skip all subkeys plus OBJ_NAME_PATH_SEPARATOR
                        //
                        for(j=0; j<=i; j++) {
                            RemainingName->Buffer += HashStack[j].KeyName.Length/sizeof(WCHAR) + 1;
                            RemainingName->Length -= HashStack[j].KeyName.Length + sizeof(WCHAR);
                        }

                        //
                        // Update the KCB, Hive and Cell.
                        //
                        *Kcb = CurrentKcb;
                        *Hive = CurrentKcb->KeyHive;
                        *Cell = CurrentKcb->KeyCell;
                        break;
                    } else {
                        Found = FALSE;
                    }
                }
            }
            Current = Current->NextHash;
        }

        if (Found) {
            break;
        }
    }
    if((*Kcb)->Delete) {
        //
        // the key has been deleted, but still kept in the cache for 
        // this kcb does not belong here
        //
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Now the kcb will be used in the parse routine.
    // Increase its reference count.
    // Make sure we remember to dereference it at the parse routine.
    //
    if (!CmpReferenceKeyControlBlock(*Kcb)) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    *MatchRemainSubkeyLevel = i+1;
    return status;
}


PCM_KEY_CONTROL_BLOCK
CmpAddInfoAfterParseFailure(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    PCM_KEY_NODE    Node,
    PCM_KEY_CONTROL_BLOCK kcb,
    PUNICODE_STRING NodeName
    )
/*++

Routine Description:

    This routine builds up further information in the cache when parse
    fails.  The additional information can be
    1. The key is has no subkey (CM_KCB_NO_SUBKEY).
    2. The key has a few subkeys, then build the index hint in the cache.
    3. If lookup failed even we have index hint cached, then create a fake key so
       we do not fail again.   This is very usful for lookup failure under keys like
       \registry\machine\software\classes\clsid, which have 1500+ subkeys and lots of
       them have the smae first four chars.
       
       NOTE. Currently we are not seeing too many fake keys being created.
       We need to monitor this periodly and work out a way to work around if
       we do create too many fake keys. 
       One solution is to use hash value for index hint (We can do it in the cache only
       if we need to be backward comparible).
    
Arguments:

    Hive - Supplies Hive that holds the key we are creating a KCB for.

    Cell - Supplies Cell that contains the key we are creating a KCB for.

    Node - Supplies pointer to key node.

    KeyName - The KeyName.

Return Value:

    The KCB that CmpParse need to dereference at the end.

    If resources problem, it returns NULL, and the caller is responsible for cleanup
--*/
{

    ULONG                   TotalSubKeyCounts;
    BOOLEAN                 CreateFakeKcb = FALSE;
    BOOLEAN                 HintCached;
    PCM_KEY_CONTROL_BLOCK   ParentKcb;
    USHORT                  i,j,k;
    HCELL_INDEX             CellToRelease;
    ULONG                   HashKey;

    if (!UseFastIndex(Hive)) {
        //
        // Older version of hive, do not bother to cache hint.
        //
        return (kcb);
    }

    TotalSubKeyCounts = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];

    if (TotalSubKeyCounts == 0) {
        BEGIN_KCB_LOCK_GUARD;    
        CmpLockKCBTreeExclusive();
        kcb->ExtFlags |= CM_KCB_NO_SUBKEY;
        // clean up the invalid flag (if any)
        kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
        CmpUnlockKCBTree();
        END_KCB_LOCK_GUARD;    
    } else if (TotalSubKeyCounts == 1) {
        BEGIN_KCB_LOCK_GUARD;    
        CmpLockKCBTreeExclusive();
        if (!(kcb->ExtFlags & CM_KCB_SUBKEY_ONE)) {
            //
            // Build the subkey hint to avoid unnecessary lookups in the index leaf
            //
            PCM_KEY_INDEX   Index;
            HCELL_INDEX     SubKeyCell;
            PCM_KEY_NODE    SubKeyNode;
            UNICODE_STRING  TmpStr;

            if (Node->SubKeyCounts[Stable] == 1) {
                CellToRelease = Node->SubKeyLists[Stable];
                Index = (PCM_KEY_INDEX)HvGetCell(Hive, CellToRelease);
            } else {
                CellToRelease = Node->SubKeyLists[Volatile];
                Index = (PCM_KEY_INDEX)HvGetCell(Hive, CellToRelease);
            } 
            
            if( Index == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // return NULL; The caller must handle this gracefully!
                //
                CmpUnlockKCBTree();
                return NULL;
            }

            if( Index->Signature == CM_KEY_INDEX_ROOT ) {
                //
                // don't cache root indexes; they are too big
                //
                HvReleaseCell(Hive,CellToRelease);
                CmpUnlockKCBTree();
                return NULL;
            }

            HashKey = 0;
            if ( Index->Signature == CM_KEY_HASH_LEAF ) {
                PCM_KEY_FAST_INDEX FastIndex;
                FastIndex = (PCM_KEY_FAST_INDEX)Index;
                //
                // we already have the hash key handy; preserve it for the kcb hint
                //
                HashKey = FastIndex->List[0].HashKey;
            } else if(Index->Signature == CM_KEY_FAST_LEAF) {
                PCM_KEY_FAST_INDEX FastIndex;
                FastIndex = (PCM_KEY_FAST_INDEX)Index;
                SubKeyCell = FastIndex->List[0].Cell;

            } else {
                SubKeyCell = Index->List[0];
            }
            
            //DbgPrint("CmpAddInfoAfterParseFailure [0]\n");
            if( HashKey != 0 ) {
                kcb->HashKey = HashKey;
                kcb->ExtFlags |= CM_KCB_SUBKEY_ONE;
                // clean up the invalid flag (if any)
                kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
            } else {
                SubKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,SubKeyCell);
                if( SubKeyNode != NULL ) {
                    if (SubKeyNode->Flags & KEY_COMP_NAME) {
                        kcb->HashKey = CmpComputeHashKeyForCompressedName(SubKeyNode->Name,SubKeyNode->NameLength);
                    } else {
                        TmpStr.Buffer = SubKeyNode->Name;
                        TmpStr.Length = SubKeyNode->NameLength;
                        kcb->HashKey = CmpComputeHashKey(&TmpStr);
                    }
                
                    
                    HvReleaseCell(Hive,SubKeyCell);
                    kcb->ExtFlags |= CM_KCB_SUBKEY_ONE;
                    // clean up the invalid flag (if any)
                    kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
                } else {
                    //
                    // we couldn't map the bin containing this cell
                    // return NULL; The caller must handle this gracefully!
                    //
                    HvReleaseCell(Hive,CellToRelease);
                    CmpUnlockKCBTree();
                    return NULL;
                }
            }
            HvReleaseCell(Hive,CellToRelease);
        } else {
            //
            // The name hint does not prevent from this look up
            // Create the fake Kcb.
            //
            CreateFakeKcb = TRUE;
        }
        CmpUnlockKCBTree();
        END_KCB_LOCK_GUARD;    
    } else if (TotalSubKeyCounts < CM_MAX_CACHE_HINT_SIZE) {
        BEGIN_KCB_LOCK_GUARD;    
        CmpLockKCBTreeExclusive();
        if (!(kcb->ExtFlags & CM_KCB_SUBKEY_HINT)) {
            //
            // Build the index leaf info in the parent KCB
            // How to sync the cache with the registry data is a problem to be resolved.
            //
            ULONG               Size;
            PCM_KEY_INDEX       Index;
            PCM_KEY_FAST_INDEX  FastIndex;
            HCELL_INDEX         SubKeyCell;
            PCM_KEY_NODE        SubKeyNode;
            ULONG               HintCrt;
            UNICODE_STRING      TmpStr;

            Size = sizeof(ULONG) * (Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile] + 1);

            kcb->IndexHint = ExAllocatePoolWithTag(PagedPool,
                                                   Size,
                                                   CM_CACHE_INDEX_TAG | PROTECTED_POOL);

            HintCached = TRUE;
            if (kcb->IndexHint) {
                kcb->IndexHint->Count = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile]; 

                HintCrt = 0;

                //DbgPrint("CmpAddInfoAfterParseFailure [1]\n");

                for (i = 0; i < Hive->StorageTypeCount; i++) {
                    if(Node->SubKeyCounts[i]) {
                        CellToRelease = Node->SubKeyLists[i];
                        Index = (PCM_KEY_INDEX)HvGetCell(Hive, CellToRelease);
                        if( Index == NULL ) {
                            //
                            // we couldn't map the bin containing this cell
                            // return NULL; The caller must handle this gracefully!
                            //
                            CmpUnlockKCBTree();
                            return NULL;
                        }
                        if( Index->Signature == CM_KEY_INDEX_ROOT ) {
                            HvReleaseCell(Hive,CellToRelease);
                            HintCached = FALSE;
                            break;
                        } else {
                          
                            for (j=0; j<Node->SubKeyCounts[i]; j++) {
                                HashKey = 0;

                                if ( Index->Signature == CM_KEY_HASH_LEAF ) {
                                    FastIndex = (PCM_KEY_FAST_INDEX)Index;
                                    //
                                    // preserve the hash key for the kcb hint
                                    //
                                    HashKey = FastIndex->List[j].HashKey;
                                } else if( Index->Signature == CM_KEY_FAST_LEAF ) {
                                    FastIndex = (PCM_KEY_FAST_INDEX)Index;
                                    SubKeyCell = FastIndex->List[j].Cell;
                                } else {
                                    SubKeyCell = Index->List[j];
                                }
                            
                                if( HashKey != 0 ) {
                                    kcb->IndexHint->HashKey[HintCrt] = HashKey;
                                } else {
                                    SubKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,SubKeyCell);
                                    if( SubKeyNode == NULL ) {
                                        //
                                        // couldn't map view; bad luck; don't cache hint for this kcb
                                        //
                                        HintCached = FALSE;
                                        break;
                                    }

                                    if (SubKeyNode->Flags & KEY_COMP_NAME) {
                                        kcb->IndexHint->HashKey[HintCrt] = CmpComputeHashKeyForCompressedName(SubKeyNode->Name,SubKeyNode->NameLength);
                                    } else {
                                        TmpStr.Buffer = SubKeyNode->Name;
                                        TmpStr.Length = SubKeyNode->NameLength;
                                        kcb->IndexHint->HashKey[HintCrt] = CmpComputeHashKey(&TmpStr);
                                    }

                                    HvReleaseCell(Hive,SubKeyCell);
                                }
                                //
                                // advance to the new hint
                                //
                                HintCrt++;
                            
                            }
                        }

                        HvReleaseCell(Hive,CellToRelease);
                    }
                }

                if (HintCached) {
                    kcb->ExtFlags |= CM_KCB_SUBKEY_HINT;
                    // clean up the invalid flag (if any)
                    kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
                } else {
                    //
                    // Do not have a FAST_LEAF, free the allocation.
                    //
                    ExFreePoolWithTag(kcb->IndexHint, CM_CACHE_INDEX_TAG | PROTECTED_POOL);
                }
            }
        } else {
            //
            // The name hint does not prevent from this look up
            // Create the fake Kcb.
            //
            CreateFakeKcb = TRUE;
        }
        CmpUnlockKCBTree();
        END_KCB_LOCK_GUARD;    
    } else {
        CreateFakeKcb = TRUE;
    }

    ParentKcb = kcb;

    if (CreateFakeKcb && (CmpCacheOnFlag & CM_CACHE_FAKE_KEY)) {
        //
        // It has more than a few children but not the one we are interested.
        // Create a kcb for this non-existing key so we do not try to find it
        // again. Use the cell and node from the parent.
        //
        // Before we create a new one. Dereference the current kcb.
        //
        // CmpCacheOnFlag is for us to turn it on/off easily.
        //

        kcb = CmpCreateKeyControlBlock(Hive,
                                       Cell,
                                       Node,
                                       ParentKcb,
                                       TRUE,
                                       NodeName);

        if (kcb) {
            CmpDereferenceKeyControlBlock(ParentKcb);
            ParentKcb = kcb;
        }
    }

    return (ParentKcb);
}


#ifdef CM_DYN_SYM_LINK
//
// this code is commented out of the current builds;
// there is a potential security breach in the way RtlAcquirePebLock() 
// works by calling a user mode routine (stored in the PEB) to lock the PEB
// We need to find a way to work around that before enabling this code
//
//
// Commenting the body of this function, to make sure code will not go in without 
// fixing the above problem
//
BOOLEAN
CmpCaptureProcessEnvironmentString(
                                   OUT  PWSTR   *ProcessEnvironment,
                                   OUT  PULONG  Length
                                   )
/*++

Routine Description:

    Captures the process environment; It first Probe the env, then captures its
    address. Parse the whole env to the end and count it's length. 
    Then allocate a buffer for it and copy.
    All of these are done in try/except to protect for bogus user-mode data.
    We need to lock the teb while working on it.
    
Arguments:

    ProcessEnvironment - to receive the captured stuff

    Length - length of the above - in bytes

Return Value:

    TRUE or FALSE
    when TRUE, the caller is responsible of freeing ProcessEnvironment 
--*/
{
/*
    BOOLEAN Result = TRUE;
    PPEB    Peb;
    PWSTR   LocalEnv;
    PWSTR   p;

    PAGED_CODE();

    *ProcessEnvironment = NULL;
    *Length = 0;

    try {
        //
        // grab the peb lock and the peb
        //
        RtlAcquirePebLock();
        Peb = PsGetCurrentProcess()->Peb;

        //
        // probe the env from peb
        //
        LocalEnv = (PWSTR)ProbeAndReadPointer((PVOID *)(&(Peb->ProcessParameters->Environment)));

        //
        // parse the env to find its length
        //
        //
        // The environment variable block consists of zero or more null
        // terminated UNICODE strings.  Each string is of the form:
        //
        //      name=value
        //
        // where the null termination is after the value.
        //
        p = LocalEnv;
        if (p != NULL) while (*p) {
            while (*p) {
                p++;
                *Length += sizeof(WCHAR);
            }

            //
            // Skip over the terminating null character for this name=value
            // pair in preparation for the next iteration of the loop.
            //

            p++;
            *Length += sizeof(WCHAR);
        }
        //
        // adjust the length to accomodate the last two UNICODE_NULL
        //
        *Length += 2*sizeof(WCHAR);

        //
        // allocate a buffer for the captured env and copy
        //
        *ProcessEnvironment = (PWSTR)ExAllocatePoolWithTag(PagedPool,*Length,CM_FIND_LEAK_TAG41);
        if( *ProcessEnvironment != NULL ) {
            RtlCopyMemory(*ProcessEnvironment,LocalEnv, *Length);
        } else {
            *Length = 0;
        }

        //
        // release the peb lock
        //
        RtlReleasePebLock();
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpCaptureProcessEnvironmentString: code:%08lx\n", GetExceptionCode()));
        Result = FALSE;
        if( *ProcessEnvironment != NULL) {
            ExFreePool(*ProcessEnvironment);
            *ProcessEnvironment = NULL;
        }
        *Length = 0;
        //
        // release the peb lock
        //
        RtlReleasePebLock();
    }    

    return Result;
*/
}

#define GROW_INCREMENT  64*sizeof(WCHAR)  // grow 64 wide-chars at a time

PWSTR
CmpExpandEnvVars(
               IN   PWSTR   StringToExpand,
               IN   ULONG   LengthToExpand,
               OUT  PULONG  ExpandedLength
               )
/*++

Routine Description:

    Replaces all env vars from StringToExpand with their values, from the process
    environment. Allocates a new buffer for the result and returns it.
    
Arguments:

    StringToExpand - to receive the captured stuff

    LengthToExpand - length of the above - in bytes

    ExpandedLength - the actual length of the expanded string

Return Value:

    NULL - the string could not be expanded (or not all the env inside it could be resolved)

    valid buffer - the expanded string, it is the caller's responsibility to free it.
    
--*/
{
    PWSTR   ProcessEnv;
    ULONG   ProcessEnvLength;
    PWSTR   ExpandedString;
    ULONG   ExpandedStringSize;
    PWSTR   CurrentEnvVar;
    ULONG   CurrentEnvLength;
    PWSTR   CurrentEnvValue;
    ULONG   CurrentEnvValueLength;

    PAGED_CODE();

    *ExpandedLength = 0;
    if( !CmpCaptureProcessEnvironmentString(&ProcessEnv,&ProcessEnvLength) ) {
        //
        // could not secure the process env
        //
        ASSERT( (ProcessEnv == NULL) && (ProcessEnvLength == 0) );
        return NULL;
    }

    //
    // allocate a buffer twice as the unexpanded buffer; we shall grow it if it's not big enough 
    //
    ExpandedStringSize = LengthToExpand * 2;
    ExpandedString = (PWSTR)ExAllocatePoolWithTag(PagedPool,ExpandedStringSize,CM_FIND_LEAK_TAG42);
    if( ExpandedString == NULL ) {
        goto JustReturn;
    }

    //
    // convert to number of WCHARs
    //
    LengthToExpand /= sizeof(WCHAR);

    //
    // iterate through the string to be expanded and copy everything that's not and env var
    // expand the env vars and replace them with their value
    //
    while( LengthToExpand ) {
        
        //
        // find a % sign
        //
        while( LengthToExpand && (*StringToExpand != L'%') ) {
            if( *ExpandedLength == ExpandedStringSize ) {
                //
                // we need to grow the expanded string
                //
                if( !CmpGrowAndCopyString(&ExpandedString,&ExpandedStringSize,GROW_INCREMENT) ) {
                    goto ErrorExit;
                }
            }
            ExpandedString[(*ExpandedLength) / sizeof(WCHAR)] = *StringToExpand;
            (*ExpandedLength) += sizeof(WCHAR);
            LengthToExpand--;
            StringToExpand++;
        }

        if( LengthToExpand == 0 ) {
            if( *StringToExpand != L'%') {
                //
                // we have exited the loop because of the end of the string
                //
                goto JustReturn;
            } else {
                //
                // we have found a mismatched %
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpExpandEnvVars : mismatched % sign\n"));
                goto ErrorExit;
            }
        }

        ASSERT( *StringToExpand == L'%' );
        //
        // skip it; then mark the beggining of an env var
        //
        StringToExpand++;
        LengthToExpand--;
        CurrentEnvVar = StringToExpand;
        CurrentEnvLength = 0;

        //
        // find a % match sign
        //
        while( LengthToExpand && (*StringToExpand != L'%') ) {
            LengthToExpand--;
            StringToExpand++;

            CurrentEnvLength += sizeof(WCHAR);
        }

        if( LengthToExpand == 0 ) {
            if( (*StringToExpand == L'%') && (CurrentEnvLength != 0) ) {
                //
                // end of string and no empty env var; we'll return (exit the surrounding
                // while loop) after expanding this string
                //
            } else {
                //
                // we didn't find a matching % sign, or we are in the %% case
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpExpandEnvVars : mismatched % sign\n"));
                goto ErrorExit;
            }
        } else {
            //
            // skip this % sign
            //
            StringToExpand++;
            LengthToExpand--;
        }
        //
        // find the value for this env var
        //
        if( !CmpFindEnvVar(ProcessEnv,ProcessEnvLength,CurrentEnvVar,CurrentEnvLength,&CurrentEnvValue,&CurrentEnvValueLength) ) {
            //
            // could not resolve this env var
            //
            ASSERT( CurrentEnvValue == NULL );
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpExpandEnvVars : could not resolve (%.*S)\n",CurrentEnvLength/sizeof(WCHAR),CurrentEnvVar));
            goto ErrorExit;
        }
        
        ASSERT( (CurrentEnvValueLength % sizeof(WCHAR)) == 0 );
        //
        // found it; strcat it at the end of the expanded string
        //
        if( (*ExpandedLength + CurrentEnvValueLength) >= ExpandedStringSize ) {
            //
            // we first need to grow the buffer
            //
            if( !CmpGrowAndCopyString(&ExpandedString,&ExpandedStringSize,CurrentEnvValueLength) ) {
                goto ErrorExit;
            }
        }
        
        ASSERT( (*ExpandedLength + CurrentEnvValueLength) < ExpandedStringSize );
        RtlCopyMemory(((PUCHAR)ExpandedString) + (*ExpandedLength),CurrentEnvValue,CurrentEnvValueLength);
        *ExpandedLength += CurrentEnvValueLength;
    }

    goto JustReturn;

ErrorExit:
    if( ExpandedString != NULL ) {
        ExFreePool(ExpandedString);
        ExpandedString = NULL;
    }

JustReturn:
    ExFreePool(ProcessEnv);
    return ExpandedString;
}

BOOLEAN
CmpGrowAndCopyString(
                     IN OUT PWSTR   *OldString,
                     IN OUT PULONG  OldStringSize,
                     IN     ULONG   GrowIncrements
                     )  
{
    PWSTR   NewString;

    PAGED_CODE();

    ASSERT( (*OldStringSize % sizeof(WCHAR)) == 0 );
    ASSERT( (GrowIncrements % sizeof(WCHAR)) == 0 );

    NewString = (PWSTR)ExAllocatePoolWithTag(PagedPool,*OldStringSize + GrowIncrements,CM_FIND_LEAK_TAG42);
    if( NewString == NULL ) {
        return FALSE;
    }
    RtlCopyMemory(NewString,*OldString,*OldStringSize);
    ExFreePool(*OldString);
    *OldString = NewString;
    *OldStringSize = *OldStringSize + GrowIncrements;
    return TRUE;
}

BOOLEAN
CmpFindEnvVar(
              IN    PWSTR   ProcessEnv,
              IN    ULONG   ProcessEnvLength,
              IN    PWSTR   CurrentEnvVar,
              IN    ULONG   CurrentEnvLength,
              OUT   PWSTR   *CurrentEnvValue,
              OUT   PULONG  CurrentEnvValueLength
              )  
/*++

Routine Description:

    finds a specified envvar in the env string;
    if found returns a pointer to it in the env string, along 
    with its size
    
Arguments:

    ProcessEnvironment - to receive the captured stuff

    Length - length of the above - in bytes

Return Value:

    TRUE or FALSE
    when TRUE, the caller is responsible of freeing ProcessEnvironment 
--*/
{
    PWSTR           p;
    UNICODE_STRING  CurrentName;
    UNICODE_STRING  CurrentValue;
    UNICODE_STRING  SearchedName;

    PAGED_CODE();

    *CurrentEnvValue = NULL;

    if( ProcessEnv == NULL ) {
        return FALSE;
    }

    p = ProcessEnv;
    SearchedName.Buffer = CurrentEnvVar;
    SearchedName.Length = (USHORT)CurrentEnvLength;
    SearchedName.MaximumLength = (USHORT)CurrentEnvLength;
    //
    // The environment variable block consists of zero or more null
    // terminated UNICODE strings.  Each string is of the form:
    //
    //      name=value
    //
    // where the null termination is after the value.
    //

    while (ProcessEnvLength) {
        //
        // Determine the size of the name and value portions of
        // the current string of the environment variable block.
        //
        CurrentName.Buffer = p;
        CurrentName.Length = 0;
        CurrentName.MaximumLength = 0;
        while (*p) {
            //
            // If we see an equal sign, then compute the size of
            // the name portion and scan for the end of the value.
            //

            if (*p == L'=' && p != CurrentName.Buffer) {
                CurrentName.Length = (USHORT)(p - CurrentName.Buffer)*sizeof(WCHAR);
                CurrentName.MaximumLength = (USHORT)(CurrentName.Length+sizeof(WCHAR));
                CurrentValue.Buffer = ++p;
                ProcessEnvLength -= sizeof(WCHAR);

                while(*p) {
                    p++;
                    ProcessEnvLength -= sizeof(WCHAR);
                }
                CurrentValue.Length = (USHORT)(p - CurrentValue.Buffer)*sizeof(WCHAR);
                CurrentValue.MaximumLength = (USHORT)(CurrentValue.Length+sizeof(WCHAR));

                //
                // At this point we have the length of both the name
                // and value portions, so exit the loop so we can
                // do the compare.
                //
                break;
            }
            else {
                ProcessEnvLength -= sizeof(WCHAR);
                p++;
            }
        }

        //
        // Skip over the terminating null character for this name=value
        // pair in preparation for the next iteration of the loop.
        //

        p++;
        ProcessEnvLength -= sizeof(WCHAR);

        //
        // Compare the current name with the one requested, ignore
        // case.
        //

        if (RtlEqualUnicodeString( &SearchedName, &CurrentName, TRUE )) {
            //
            // Names are equal.  Always return the length of the
            // value string, excluding the terminating null.  
            //
            *CurrentEnvValue = CurrentValue.Buffer;
            *CurrentEnvValueLength = CurrentValue.Length;
            return TRUE;

        }
    }
    return FALSE;
}

#endif //CM_DYN_SYM_LINK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmsavres.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmsavres.c

Abstract:

    This file contains code for SaveKey and RestoreKey.

Author:

    Bryan M. Willman (bryanwi) 15-Jan-92

Revision History:

--*/

#include    "cmp.h"

//
// defines how big the buffer we use for doing a savekey by copying the
// hive file should be.
//
#define CM_SAVEKEYBUFSIZE 0x10000

extern PCMHIVE CmpMasterHive;

extern  BOOLEAN CmpProfileLoaded;

extern PUCHAR  CmpStashBuffer;
extern ULONG   CmpGlobalQuotaAllowed;
extern ULONG   CmpGlobalQuotaWarning;
extern ULONG   CmpGlobalQuotaUsed;
extern BOOLEAN HvShutdownComplete;     // Set to true after shutdown
                                        // to disable any further I/O

PCMHIVE
CmpCreateTemporaryHive(
    IN HANDLE FileHandle
    );

VOID
CmpDestroyTemporaryHive(
    PCMHIVE CmHive
    );

NTSTATUS
CmpLoadHiveVolatile(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN HANDLE FileHandle
    );

NTSTATUS
CmpRefreshHive(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock
    );

NTSTATUS
CmpSaveKeyByFileCopy(
    PCMHIVE Hive,
    HANDLE  FileHandle
    );

ULONG
CmpRefreshWorkerRoutine(
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    );

BOOLEAN
CmpMergeKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    );

VOID 
CmpShiftSecurityCells(PHHIVE        Hive);

VOID
CmpShiftValueList(PHHIVE      Hive,
            HCELL_INDEX ValueList,
            ULONG       Count
            );

VOID
CmpShiftKey(PHHIVE      Hive,
            PCMHIVE     OldHive,
            HCELL_INDEX Cell,
            HCELL_INDEX ParentCell
            );

VOID 
CmpShiftIndex(PHHIVE        Hive,
              PCM_KEY_INDEX Index
              );

BOOLEAN
CmpShiftAllCells2(  PHHIVE      Hive,
                    PCMHIVE     OldHive,
                    HCELL_INDEX Cell,
                    HCELL_INDEX ParentCell
                    );

BOOLEAN
CmpShiftAllCells(PHHIVE     NewHive,
                 PCMHIVE    OldHive
                 );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmRestoreKey)
#pragma alloc_text(PAGE,CmpLoadHiveVolatile)
#pragma alloc_text(PAGE,CmpRefreshHive)
#pragma alloc_text(PAGE,CmSaveKey)
#pragma alloc_text(PAGE,CmDumpKey)
#pragma alloc_text(PAGE,CmSaveMergedKeys)
#pragma alloc_text(PAGE,CmpCreateTemporaryHive)
#pragma alloc_text(PAGE,CmpDestroyTemporaryHive)
#pragma alloc_text(PAGE,CmpRefreshWorkerRoutine)
#pragma alloc_text(PAGE,CmpSaveKeyByFileCopy)
#pragma alloc_text(PAGE,CmpOverwriteHive)
#pragma alloc_text(PAGE,CmpShiftHiveFreeBins)
#pragma alloc_text(PAGE,CmpSwitchStorageAndRebuildMappings)
#pragma alloc_text(PAGE,CmpShiftSecurityCells)
#pragma alloc_text(PAGE,CmpShiftValueList)
#pragma alloc_text(PAGE,CmpShiftKey)
#pragma alloc_text(PAGE,CmpShiftIndex)
#pragma alloc_text(PAGE,CmpShiftAllCells2)
#pragma alloc_text(PAGE,CmpShiftAllCells)
#endif



NTSTATUS
CmRestoreKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN HANDLE  FileHandle,
    IN ULONG Flags
    )
/*++

Routine Description:

    This copies the data from an on-disk hive into the registry.  The file
    is not loaded into the registry, and the system will NOT be using
    the source file after the call returns.

    If the flag REG_WHOLE_HIVE_VOLATILE is not set, the given key is replaced
    by the root of the hive file.  The root's name is changed to the name
    of the given key.

    If the flag REG_WHOLE_HIVE_VOLATILE is set, a volatile hive is created,
    the hive file is copied into it, and the resulting hive is linked to
    the master hive.  The given key must be in the master hive.  (Usually
    will be \Registry\User)

    If the flag REG_REFRESH_HIVE is set (must be only flag) then the
    the Hive will be restored to its state as of the last flush.
    (The hive must be marked NOLAZY_FLUSH, and the caller must have
     TCB privilege, and the handle must point to the root of the hive.
     If the refresh fails, the hive will be corrupt, and the system
     will bugcheck.)

    If the flag REG_FORCE_RESTORE is set, the restore operation is done even
    if there areopen handles underneath the key we are restoring to.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node at root of tree to restore into

    FileHandle - handle of the file to read from.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS    status;
    PCELL_DATA  ptar;
    PCELL_DATA  psrc;
    PCMHIVE     TmpCmHive;
    HCELL_INDEX newroot;
    HCELL_INDEX newcell;
    HCELL_INDEX parent;
    HCELL_INDEX list;
    ULONG       count;
    ULONG       i;
    ULONG       j;
    LONG        size;
    PHHIVE      Hive;
    HCELL_INDEX Cell;
    HSTORAGE_TYPE Type;
    ULONG       NumberLeaves;
    PHCELL_INDEX LeafArray;
    PCM_KEY_INDEX Leaf;
    PCM_KEY_FAST_INDEX FastLeaf;
    PRELEASE_CELL_ROUTINE   SourceReleaseCellRoutine;
    PRELEASE_CELL_ROUTINE   TargetReleaseCellRoutine;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmRestoreKey:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tKCB=%p\n",KeyControlBlock));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tFileHandle=%08lx\n",FileHandle));

    if (Flags & REG_REFRESH_HIVE) {
        if ((Flags & ~REG_REFRESH_HIVE) != 0) {
            //
            // Refresh must be alone
            //
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // If they want to do WHOLE_HIVE_VOLATILE, it's a completely different API.
    //
    if (Flags & REG_WHOLE_HIVE_VOLATILE) {
        return(CmpLoadHiveVolatile(KeyControlBlock, FileHandle));
    }

    //
    // If they want to do REFRESH_HIVE, that's a completely different api too.
    //
    if (Flags & REG_REFRESH_HIVE) {
        CmpLockRegistryExclusive();
        status = CmpRefreshHive(KeyControlBlock);
        CmpUnlockRegistry();
        return status;
    }

    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;

    //
    // Disallow attempts to "restore" the master hive
    //
    if (Hive == &CmpMasterHive->Hive) {
        return STATUS_ACCESS_DENIED;
    }

    CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
    CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

    //
    // Make sure this key has not been deleted
    //
    if (KeyControlBlock->Delete) {
        CmpUnlockRegistry();
        return(STATUS_CANNOT_DELETE);
    }

#ifdef NT_UNLOAD_KEY_EX
    if( IsHiveFrozen(((PCMHIVE)Hive)) ) {
        //
        // deny attempts to clobber with a frozen hive
        //
        CmpUnlockRegistry();
        return STATUS_TOO_LATE;
    }
#endif //NT_UNLOAD_KEY_EX

    DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));

    //
    // Check for any open handles underneath the key we are restoring to.
    //
    if (CmpSearchForOpenSubKeys(KeyControlBlock,(Flags&REG_FORCE_RESTORE)?SearchAndDeref:SearchIfExist) != 0) {

        //
        // Cannot restore over a subtree with open handles in it, or the open handles to subkeys 
        // successfully marked as closed.
        //

        CmpUnlockRegistry();
        return(STATUS_CANNOT_DELETE);
    }

    //
    // Make sure this is the only handle open for this key
    //
    if (KeyControlBlock->RefCount != 1 && !(Flags&REG_FORCE_RESTORE)) {
        CmpUnlockRegistry();
        return(STATUS_CANNOT_DELETE);
    }

    ptar = HvGetCell(Hive, Cell);
    if( ptar == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        CmpUnlockRegistry();
		return STATUS_INSUFFICIENT_RESOURCES;
    }
    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    //
    // The subtree the caller wants does not exactly match a
    // subtree.  Make a temporary hive, load the file into it,
    // tree copy the temporary to the active, and free the temporary.
    //

    //
    // Create the temporary hive
    //
    status = CmpInitializeHive(&TmpCmHive,
                           HINIT_FILE,
                           0,
                           HFILE_TYPE_PRIMARY,
                           NULL,
                           FileHandle,
                           NULL,
                           NULL,
                           NULL,
                           CM_CHECK_REGISTRY_CHECK_CLEAN
                           );

    if (!NT_SUCCESS(status)) {
        goto ErrorExit1;
    }                         

    //
    // Create a new target root, under which we will copy the new tree
    //
    if (ptar->u.KeyNode.Flags & KEY_HIVE_ENTRY) {
        parent = HCELL_NIL;                         // root of hive, so parent is NIL
    } else {
        parent = ptar->u.KeyNode.Parent;
    }

    SourceReleaseCellRoutine = TmpCmHive->Hive.ReleaseCellRoutine;
    TargetReleaseCellRoutine = Hive->ReleaseCellRoutine;
    TmpCmHive->Hive.ReleaseCellRoutine = NULL;
    Hive->ReleaseCellRoutine = NULL;

    newroot = CmpCopyKeyPartial(&(TmpCmHive->Hive),
                                TmpCmHive->Hive.BaseBlock->RootCell,
                                Hive,
                                parent,
                                TRUE);
    TmpCmHive->Hive.ReleaseCellRoutine = SourceReleaseCellRoutine;
    Hive->ReleaseCellRoutine = TargetReleaseCellRoutine;

    if (newroot == HCELL_NIL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    //
    // newroot has all the correct stuff, except that it has the
    // source root's name, when it needs to have the target root's.
    // So edit its name.
    //
    psrc = HvGetCell(Hive, Cell);
    if( psrc == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    ptar = HvGetCell(Hive, newroot);
    if( ptar == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }
    size = FIELD_OFFSET(CM_KEY_NODE, Name) + psrc->u.KeyNode.NameLength;

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,newroot);

    //
    // make sure that new root has correct amount of space
    // to hold name from old root
    //
    newcell = HvReallocateCell(Hive, newroot, size);
    if (newcell == HCELL_NIL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }
    newroot = newcell;
    ptar = HvGetCell(Hive, newroot);
    if( ptar == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen, as we just allocated this cell
        // (i.e. it should be PINNED in memory at this point)
        //
        ASSERT( FALSE );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }
    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,newroot);

    status = STATUS_SUCCESS;

    RtlCopyMemory((PVOID)&(ptar->u.KeyNode.Name[0]),
                  (PVOID)&(psrc->u.KeyNode.Name[0]),
                  psrc->u.KeyNode.NameLength);

    ptar->u.KeyNode.NameLength = psrc->u.KeyNode.NameLength;
    if (psrc->u.KeyNode.Flags & KEY_COMP_NAME) {
        ptar->u.KeyNode.Flags |= KEY_COMP_NAME;
    } else {
        ptar->u.KeyNode.Flags &= ~KEY_COMP_NAME;
    }

    //
    // newroot is now ready to have subtree copied under it, do tree copy
    //
    if (CmpCopyTree(&(TmpCmHive->Hive),
                    TmpCmHive->Hive.BaseBlock->RootCell,
                    Hive,
                    newroot) == FALSE)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    //
    // The new root and the tree under it now look the way we want.
    //

    //
    // Swap the new tree in for the old one.
    //
    ptar = HvGetCell(Hive, Cell);
    if( ptar == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    parent = ptar->u.KeyNode.Parent;

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    if (ptar->u.KeyNode.Flags & KEY_HIVE_ENTRY) {

        //
        // root is actually the root of the hive.  parent doesn't
        // refer to it via a child list, but rather with an inter hive
        // pointer.  also, must update base block
        //
        ptar = HvGetCell( (&(CmpMasterHive->Hive)), parent);
        if( ptar == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell((&(CmpMasterHive->Hive)), parent);

        ptar->u.KeyNode.ChildHiveReference.KeyCell = newroot;
        ptar = HvGetCell(Hive, newroot);
        if( ptar == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen, as we just allocated this cell
            // (i.e. it should be PINNED in memory at this point)
            //
            ASSERT( FALSE );
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive, newroot);

        ptar->u.KeyNode.Parent = parent;
        Hive->BaseBlock->RootCell = newroot;


    } else {

        //
        //  Notice that new root is *always* name of existing target,
        //      therefore, even in b-tree, old and new cell can share
        //      the same reference slot in the parent.  So simply edit
        //      the new cell_index on the top of the old.
        //
        ptar = HvGetCell(Hive, parent);
        if( ptar == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive, parent);

        Type = HvGetCellType(Cell);
        list = ptar->u.KeyNode.SubKeyLists[Type];
        count = ptar->u.KeyNode.SubKeyCounts[Type];

        ptar = HvGetCell(Hive, list);
        if( ptar == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive, list);
        if (ptar->u.KeyIndex.Signature == CM_KEY_INDEX_ROOT) {
            NumberLeaves = ptar->u.KeyIndex.Count;
            LeafArray = &ptar->u.KeyIndex.List[0];
        } else {
            NumberLeaves = 1;
            LeafArray = &list;
        }

        //
        // Look in each leaf for the HCELL_INDEX we need to replace
        //
        for (i = 0; i < NumberLeaves; i++) {
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafArray[i]);
            if( Leaf == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit2;
            }
            // release the cell right here as we are holding the reglock exclusive
            HvReleaseCell(Hive, LeafArray[i]);
            if( !HvMarkCellDirty(Hive, LeafArray[i]) ) {
                status = STATUS_NO_LOG_SPACE;
                goto ErrorExit2;
            }
            if ( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                 (Leaf->Signature == CM_KEY_HASH_LEAF) ) {
                FastLeaf = (PCM_KEY_FAST_INDEX)Leaf;
                for (j=0; j < FastLeaf->Count; j++) {
                    if (FastLeaf->List[j].Cell == Cell) {
                        FastLeaf->List[j].Cell = newroot;
                        goto FoundCell;
                    }
                }
            } else {
                for (j=0; j < Leaf->Count; j++) {
                    if (Leaf->List[j] == Cell) {

                        Leaf->List[j] = newroot;
                        goto FoundCell;
                    }
                }
            }
        }
        ASSERT(FALSE);      //  implies we didn't find it
                        //  we should never get here
    }

FoundCell:


    //
    // Fix up the key control block to point to the new root
    //
    KeyControlBlock->KeyCell = newroot;

    //
    // Kcb has changed, update the cache information.
    // Registry locked exclusively, no need for KCB lock.
    //
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    CmpCleanUpKcbValueCache(KeyControlBlock);

    {
        PCM_KEY_NODE    Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);

        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }

        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);

        CmpSetUpKcbValueCache(KeyControlBlock,Node->ValueList.Count,Node->ValueList.List);
        KeyControlBlock->Flags = Node->Flags;

        CmpAssignSecurityToKcb(KeyControlBlock,Node->Security);
        
        //
        // we need to update the other kcb cache members too!!!
        //
        CmpCleanUpSubKeyInfo (KeyControlBlock);
        KeyControlBlock->KcbLastWriteTime = Node->LastWriteTime;  
        KeyControlBlock->KcbMaxNameLen = (USHORT)Node->MaxNameLen;
        KeyControlBlock->KcbMaxValueNameLen = (USHORT)Node->MaxValueNameLen;
        KeyControlBlock->KcbMaxValueDataLen = Node->MaxValueDataLen;
    
    }

    KeyControlBlock->ExtFlags = 0;

    // mark the cached info as not valid
    KeyControlBlock->ExtFlags |= CM_KCB_INVALID_CACHED_INFO;

    //
    // Delete the old subtree and it's root cell
    //
    CmpDeleteTree(Hive, Cell);
    CmpFreeKeyByCell(Hive, Cell, FALSE);

    //
    // Report the notify event
    //
    CmpReportNotify(KeyControlBlock,
                    KeyControlBlock->KeyHive,
                    KeyControlBlock->KeyCell,
                    REG_NOTIFY_CHANGE_NAME);
    

    //
    // Free the temporary hive
    //
    CmpDestroyTemporaryHive(TmpCmHive);

    //
    // We've given user chance to log on, so turn on quota
    //
    if (CmpProfileLoaded == FALSE) {
        CmpProfileLoaded = TRUE;
        CmpSetGlobalQuotaAllowed();
    }

    DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));
    CmpUnlockRegistry();
    return status;


    //
    // Error exits
    //
ErrorExit2:
    CmpDestroyTemporaryHive(TmpCmHive);
ErrorExit1:
    DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));
    CmpUnlockRegistry();

    return status;
}


NTSTATUS
CmpLoadHiveVolatile(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN HANDLE FileHandle
    )

/*++

Routine Description:

    Creates a VOLATILE hive and loads it underneath the given Hive and Cell.
    The data for the volatile hive is copied out of the given file.  The
    file is *NOT* in use by the registry when this returns.

Arguments:

    Hive - Supplies the hive that the new hive is to be created under.
           Currently this must be the Master Hive.

    Cell - Supplies the HCELL_INDEX of the new hive's parent.  (Usually
           will by \Registry\User)

    FileHandle - Supplies a handle to the hive file that will be copied
           into the volatile hive.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS status;
    PHHIVE Hive;
    PCELL_DATA RootData;
    PCMHIVE NewHive;
    PCMHIVE TempHive;
    HCELL_INDEX Cell;
    HCELL_INDEX Root;
    NTSTATUS Status;
    UNICODE_STRING RootName;
    UNICODE_STRING NewName;
    USHORT NewNameLength;
    PUNICODE_STRING ConstructedName;
    PRELEASE_CELL_ROUTINE   SourceReleaseCellRoutine;
    PRELEASE_CELL_ROUTINE   TargetReleaseCellRoutine;

    PAGED_CODE();
    CmpLockRegistryExclusive();

    if (KeyControlBlock->Delete) {
        CmpUnlockRegistry();
        return(STATUS_KEY_DELETED);
    }
    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;

#ifdef NT_UNLOAD_KEY_EX
    if( IsHiveFrozen(((PCMHIVE)Hive)) ) {
        //
        // deny attempts to clobber with a frozen hive
        //
        CmpUnlockRegistry();
        return STATUS_TOO_LATE;
    }
#endif //NT_UNLOAD_KEY_EX
    //
    // New hives can be created only under the master hive.
    //

    if (Hive != &CmpMasterHive->Hive) {
        CmpUnlockRegistry();
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Create a temporary hive and load the file into it
    //
    status = CmpInitializeHive(&TempHive,
                           HINIT_FILE,
                           0,
                           HFILE_TYPE_PRIMARY,
                           NULL,
                           FileHandle,
                           NULL,
                           NULL,
                           NULL,
                           CM_CHECK_REGISTRY_CHECK_CLEAN); 
    if (!NT_SUCCESS(status)) {
        CmpUnlockRegistry();
        return(status);
    }                           

    //
    // Create the volatile hive.
    //
    status = CmpInitializeHive(&NewHive,
                           HINIT_CREATE,
                           HIVE_VOLATILE,
                           0,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           0);
    if (!NT_SUCCESS(status)) {
        CmpDestroyTemporaryHive(TempHive);
        CmpUnlockRegistry();
        return(status);
    }                           

    //
    // Create the target root
    //
    SourceReleaseCellRoutine = TempHive->Hive.ReleaseCellRoutine;
    TargetReleaseCellRoutine = NewHive->Hive.ReleaseCellRoutine;
    TempHive->Hive.ReleaseCellRoutine = NULL;
    NewHive->Hive.ReleaseCellRoutine = NULL;

    Root = CmpCopyKeyPartial(&TempHive->Hive,
                             TempHive->Hive.BaseBlock->RootCell,
                             &NewHive->Hive,
                             HCELL_NIL,
                             FALSE);

    TempHive->Hive.ReleaseCellRoutine = SourceReleaseCellRoutine;
    NewHive->Hive.ReleaseCellRoutine = TargetReleaseCellRoutine;

    if (Root == HCELL_NIL) {
        CmpDestroyTemporaryHive(TempHive);
        CmpDestroyTemporaryHive(NewHive);
        CmpUnlockRegistry();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    NewHive->Hive.BaseBlock->RootCell = Root;

    //
    // Copy the temporary hive into the volatile hive
    //
    if (!CmpCopyTree(&TempHive->Hive,
                    TempHive->Hive.BaseBlock->RootCell,
                    &NewHive->Hive,
                    Root))
    {
        CmpDestroyTemporaryHive(TempHive);
        CmpDestroyTemporaryHive(NewHive);
        CmpUnlockRegistry();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // The volatile hive now has all the right stuff in all the right places,
    // we just need to link it into the master hive.
    //
    RootData = HvGetCell(&NewHive->Hive,Root);
    if( RootData == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen, as we just allocated this cell
        // (i.e. it should be PINNED in memory at this point)
        //
        ASSERT( FALSE );
        CmpDestroyTemporaryHive(TempHive);
        CmpDestroyTemporaryHive(NewHive);
        CmpUnlockRegistry();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(&NewHive->Hive,Root);

    ConstructedName = CmpConstructName(KeyControlBlock);
    
    NewNameLength = ConstructedName->Length +
                CmpHKeyNameLen(&RootData->u.KeyNode) +
                sizeof(WCHAR);
    NewName.Buffer = ExAllocatePool(PagedPool, NewNameLength);
    if (NewName.Buffer == NULL) {
        CmpDestroyTemporaryHive(TempHive);
        CmpDestroyTemporaryHive(NewHive);
        CmpUnlockRegistry();
        ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    NewName.Length = NewName.MaximumLength = NewNameLength;
    RtlCopyUnicodeString(&NewName, ConstructedName);
    ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
    RtlAppendUnicodeToString(&NewName, L"\\");

    if (RootData->u.KeyNode.Flags & KEY_COMP_NAME) {
        CmpCopyCompressedName(NewName.Buffer + (NewName.Length / sizeof(WCHAR)),
                              NewName.MaximumLength - NewName.Length,
                              RootData->u.KeyNode.Name,
                              CmpHKeyNameLen(&RootData->u.KeyNode));
        NewName.Length += CmpHKeyNameLen(&RootData->u.KeyNode);
    } else {
        RootName.Buffer = RootData->u.KeyNode.Name;
        RootName.Length = RootName.MaximumLength = RootData->u.KeyNode.NameLength;

        RtlAppendUnicodeStringToString(&NewName,&RootName);
    }

    Status = CmpLinkHiveToMaster(&NewName,
                                 NULL,
                                 NewHive,
                                 FALSE,
                                 NULL);
    if (NT_SUCCESS(Status)) {
        // call the worker to add the hive to the list
        CmpAddToHiveFileList(NewHive);
    } else {
        CmpDestroyTemporaryHive(NewHive);
    }
    CmpDestroyTemporaryHive(TempHive);

    ExFreePool(NewName.Buffer);

    if (NT_SUCCESS(Status)) {
        //
        // We've given user chance to log on, so turn on quota
        //
        if (CmpProfileLoaded == FALSE) {
            CmpProfileLoaded = TRUE;
            CmpSetGlobalQuotaAllowed();
        }
    }

    CmpUnlockRegistry();
    return(Status);
}



ULONG
CmpRefreshWorkerRoutine(
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    )
/*++

Routine Description:

    Helper used by CmpRefreshHive when calling
    CmpSearchKeyControlBlockTree.

    If a match is found, the KCB is deleted and restart is returned.
    Else, continue is returned.

Arguments:

    Current - the kcb to examine

    Context1 - the hive to match against

    Context2 - nothing

Return Value:

    if no match, return continue.

    if match, return restart.

--*/
{
    PAGED_CODE();
    if (Current->KeyHive == (PHHIVE)Context1) {

        //
        // match.  set deleted flag.  continue search.
        //
        Current->Delete = TRUE;
        Current->KeyHive = NULL;
        Current->KeyCell = 0;
        return(KCB_WORKER_DELETE);
    }
    return KCB_WORKER_CONTINUE;
}


NTSTATUS
CmpRefreshHive(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock
    )
/*++

Routine Description:

    Backs out all changes to a hives since it was last flushed.
    Used as a transaction abort by the security system.

    Caller must have SeTcbPrivilege.

    The target hive must have HIVE_NOLAZYFLUSH set.

    KeyControlBlock must refer to the root of the hive (HIVE_ENTRY must
    be set in the key.)

    Any kcbs that point into this hive (and thus any handles open
    against it) will be force to DELETED state.  (If we do any work.)

    All notifies pending against the hive will be flushed.

    When we're done, only the tombstone kcbs, handles, and attached
    notify blocks will be left.

    WARNNOTE:   Once reads have begun, if the operation fails, the hive
                will be corrupt, so we will bugcheck.

Arguments:

    KeyControlBlock - provides a reference to the root of the hive
                      we wish to refresh.

Return Value:

    NTSTATUS

--*/
{
    PHHIVE              Hive;
    PLIST_ENTRY         ptr;
    PCM_NOTIFY_BLOCK    node;
#ifdef CMP_KCB_CACHE_VALIDATION
    PCELL_DATA          pcell;
    HCELL_INDEX         Cell;
#endif //CMP_KCB_CACHE_VALIDATION

    PAGED_CODE();
    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeTcbPrivilege, KeGetPreviousMode())) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    if (KeyControlBlock->Delete) {
        return(STATUS_KEY_DELETED);
    }
    CmpLockRegistryExclusive();
    Hive = KeyControlBlock->KeyHive;
#ifdef CMP_KCB_CACHE_VALIDATION
    Cell = KeyControlBlock->KeyCell;
#endif //CMP_KCB_CACHE_VALIDATION

#ifdef NT_UNLOAD_KEY_EX
    if( IsHiveFrozen(((PCMHIVE)Hive)) ) {
        //
        // deny attempts to clobber with a frozen hive
        //
        CmpUnlockRegistry();
        return STATUS_TOO_LATE;
    }
#endif //NT_UNLOAD_KEY_EX

    //
    // check to see if hive is of proper type
    //
    if ( ! (Hive->HiveFlags & HIVE_NOLAZYFLUSH)) {
        CmpUnlockRegistry();
        return STATUS_INVALID_PARAMETER;
    }

    //
    // punt if any volatile storage has been allocated
    //
    if (Hive->Storage[Volatile].Length != 0) {
        CmpUnlockRegistry();
        return STATUS_UNSUCCESSFUL;
    }

#ifdef CMP_KCB_CACHE_VALIDATION
    //
    // check to see if call was applied to the root of the hive
    //
    pcell = HvGetCell(Hive, Cell);
    if( pcell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        CmpUnlockRegistry();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    ASSERT( pcell->u.KeyNode.Flags == KeyControlBlock->Flags );
#endif //CMP_KCB_CACHE_VALIDATION

    if ( ! (KeyControlBlock->Flags & KEY_HIVE_ENTRY)) {
        CmpUnlockRegistry();
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Flush all NotifyBlocks attached to this hive
    //
    while (TRUE) {

        //
        // flush below will edit list, so restart at beginning each time
        //
        ptr = &(((PCMHIVE)Hive)->NotifyList);
        if (ptr->Flink == NULL) {
            break;
        }

        ptr = ptr->Flink;
        node = CONTAINING_RECORD(ptr, CM_NOTIFY_BLOCK, HiveList);
        ASSERT((node->KeyBody)->NotifyBlock == node);
        CmpFlushNotify(node->KeyBody);
    }

    //
    // Force all kcbs that refer to this hive to the deleted state.
    //
    CmpSearchKeyControlBlockTree(
        CmpRefreshWorkerRoutine,
        (PVOID)Hive,
        NULL
        );

    //
    // Call the worker to do the refresh
    //
    HvRefreshHive(Hive);

    CmpUnlockRegistry();
    //
    // we're back (rather than bugchecked) so it worked
    //
    return STATUS_SUCCESS;
}

NTSTATUS
CmDumpKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN HANDLE                   FileHandle
    )
/*++

Routine Description:
    
    Dumps the key into the specified File - no tree copy.
    It is supposed to work fast, Works only when KeyControlBlock is 
    the root of the hive

Arguments:

    KeyControlBlock - pointer to the KCB that describes the key

    FileHandle - handle of the file to dump to.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS                status;
    PHHIVE                  Hive;
    HCELL_INDEX             Cell;
    PCMHIVE                 CmHive;

    PAGED_CODE();

    //
    // Disallow attempts to "save" the master hive
    //
    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;
    if (Hive == &CmpMasterHive->Hive) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Make sure the cell passed in is the root cell of the hive.
    //
    if (Cell != Hive->BaseBlock->RootCell) {
        return STATUS_INVALID_PARAMETER;
    }

    CmpLockRegistry();

    //
    // Punt if post shutdown
    //
    if (HvShutdownComplete) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmDumpKey: Attempt to write hive AFTER SHUTDOWN\n"));
        CmpUnlockRegistry();
        return STATUS_REGISTRY_IO_FAILED;
    }

    if (KeyControlBlock->Delete) {
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    //
    // protect against lazy flusher
    //
    CmLockHive (CmHive);
    // sanity
    ASSERT( CmHive->FileHandles[HFILE_TYPE_EXTERNAL] == NULL );
    CmHive->FileHandles[HFILE_TYPE_EXTERNAL] = FileHandle;
    status = HvWriteHive(Hive,FALSE,FALSE,FALSE);
    CmHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;
    CmUnlockHive (CmHive);

    CmpUnlockRegistry();
    return status;
}

NTSTATUS
CmSaveKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN HANDLE                   FileHandle,
    IN ULONG                    HiveVersion
    )
/*++

Routine Description:

Arguments:

    KeyControlBlock - pointer to the KCB that describes the key

    FileHandle - handle of the file to dump to.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS                status;
    PCMHIVE                 TmpCmHive;
    PCMHIVE                 CmHive;
    HCELL_INDEX             newroot;
    PHHIVE                  Hive;
    HCELL_INDEX             Cell;
    ULONG                   OldQuotaAllowed;
    ULONG                   OldQuotaWarning;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmSaveKey:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tKCB=%p",KeyControlBlock));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tFileHandle=%08lx\n",FileHandle));

    //
    // Disallow attempts to "save" the master hive
    //
    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;

    if (Hive == &CmpMasterHive->Hive) {
        return STATUS_ACCESS_DENIED;
    }

    CmpLockRegistry();

    if (KeyControlBlock->Delete) {
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    DCmCheckRegistry(CmHive);
    if ( (Hive->HiveFlags & HIVE_NOLAZYFLUSH) &&
         (Hive->DirtyCount != 0) &&
         (CmHive->FileHandles[HFILE_TYPE_PRIMARY] != NULL)
         )
    {
        //
        // we really need the lock exclusive in this case as we can't afford somebody else 
        // to alter the file
        //
        CmpUnlockRegistry();
        CmpLockRegistryExclusive();
        if (KeyControlBlock->Delete) {
            CmpUnlockRegistry();
            return STATUS_KEY_DELETED;
        }

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        //
        // It's a NOLAZY hive, and there's some dirty data, so writing
        // out a snapshot of what's in memory will not give the caller
        // consistent user data.  Therefore, copy the on disk image
        // instead of the memory image
        //

        //
        // Note that this will generate weird results if the key
        // being saved is not the root of the hive, since the
        // resulting file will always be a copy of the entire hive, not
        // just the subtree they asked for.
        //
        status = CmpSaveKeyByFileCopy((PCMHIVE)Hive, FileHandle);

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        CmpUnlockRegistry();
        return status;
    }

    //
    // Always try to copy the hive and write it out.  This has the
    // effect of compressing out unused free storage.
    // If there isn't space, and the savekey is of the root of the
    // hive, then just write it out directly.  (i.e. don't fail on
    // a whole hive restore just because we're out of memory.)
    //
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tSave of partial hive\n"));

    //
    // The subtree the caller wants does not exactly match a
    // subtree.  Make a temporary hive, tree copy the source
    // to temp, write out the temporary, free the temporary.
    //

    //
    // temporarily disable registry quota as we will be giving this memory back immediately!
    //
    OldQuotaAllowed = CmpGlobalQuotaAllowed;
    OldQuotaWarning = CmpGlobalQuotaWarning;
    CmpGlobalQuotaAllowed = CM_WRAP_LIMIT;
    CmpGlobalQuotaWarning = CM_WRAP_LIMIT;

    //
    // Create the temporary hive
    //

    TmpCmHive = CmpCreateTemporaryHive(FileHandle);
    if (TmpCmHive == NULL) {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // Create a root cell, mark it as such
    //

    //
    // overwrite the hive's minor version in order to implement NtSaveKeyEx
    //
    TmpCmHive->Hive.BaseBlock->Minor = HiveVersion;
    TmpCmHive->Hive.Version = HiveVersion;
    
    newroot = CmpCopyKeyPartial(
                Hive,
                Cell,
                &(TmpCmHive->Hive),
                HCELL_NIL,          // will force KEY_HIVE_ENTRY set
                TRUE);

    if (newroot == HCELL_NIL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    TmpCmHive->Hive.BaseBlock->RootCell = newroot;

    //
    // Do a tree copy
    //
    if (CmpCopyTree(Hive, Cell, &(TmpCmHive->Hive), newroot) == FALSE) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // Write the file
    //
    CmLockHive (TmpCmHive);
    ASSERT( TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] == NULL );
    TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] = FileHandle;
    status = HvWriteHive(&(TmpCmHive->Hive),FALSE,FALSE,FALSE);
    TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;
    CmUnlockHive (TmpCmHive);
    //
    // Error exits
    //
ErrorInsufficientResources:

    //
    // Free the temporary hive
    //
    if (TmpCmHive != NULL) {
        CmpDestroyTemporaryHive(TmpCmHive);
    }

    //
    // Set global quota back to what it was.
    //
    CmpGlobalQuotaAllowed = OldQuotaAllowed;
    CmpGlobalQuotaWarning = OldQuotaWarning;
    DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));

    CmpUnlockRegistry();
    return status;
}

NTSTATUS
CmSaveMergedKeys(
    IN PCM_KEY_CONTROL_BLOCK    HighPrecedenceKcb,
    IN PCM_KEY_CONTROL_BLOCK    LowPrecedenceKcb,
    IN HANDLE   FileHandle
    )
/*++

Routine Description:

Arguments:

    HighPrecedenceKcb - pointer to the KCB that describes the High precedence key 
                        (the one that wins in a duplicate key case)

    LowPrecedenceKcb - pointer to the KCB that describes the Low precedence key 
                        (the one that gets overwritten in a duplicate key case)

    FileHandle - handle of the file to dump to.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS    status;
    PCMHIVE     TmpCmHive;
    HCELL_INDEX newroot;
    PHHIVE HighHive;
    PHHIVE LowHive;
    HCELL_INDEX HighCell;
    HCELL_INDEX LowCell;
    ULONG OldQuotaAllowed;
    ULONG OldQuotaWarning;
    PCM_KEY_NODE HighNode,LowNode;
    PRELEASE_CELL_ROUTINE   SourceReleaseCellRoutine;
    PRELEASE_CELL_ROUTINE   TargetReleaseCellRoutine;
#if DBG
    ULONG OldQuotaUsed;
#endif

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmSaveMergedKeys:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tHighKCB=%p",HighPrecedenceKcb));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tLowKCB=%p",LowPrecedenceKcb));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tFileHandle=%08lx\n",FileHandle));

    //
    // Disallow attempts to "merge" keys located in the same hive
    // A brutal way to avoid recursivity
    //
    HighHive = HighPrecedenceKcb->KeyHive;
    HighCell = HighPrecedenceKcb->KeyCell;
    LowHive = LowPrecedenceKcb->KeyHive;
    LowCell = LowPrecedenceKcb->KeyCell;

    if (LowHive  == HighHive ) {
        return STATUS_INVALID_PARAMETER;
    }

    CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
    CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

    if (HighPrecedenceKcb->Delete || LowPrecedenceKcb->Delete) {
        //
        // Unlock the registry and fail if one of the keys are marked as deleted
        //
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }

    DCmCheckRegistry(CONTAINING_RECORD(HighHive, CMHIVE, Hive));
    DCmCheckRegistry(CONTAINING_RECORD(LowHive, CMHIVE, Hive));


    if( ((HighHive->HiveFlags & HIVE_NOLAZYFLUSH) && (HighHive->DirtyCount != 0)) ||
        ((LowHive->HiveFlags & HIVE_NOLAZYFLUSH) && (LowHive->DirtyCount != 0)) ) {
        //
        // Reject the call when one of the hives is a NOLAZY hive and there's
        // some dirty data. Another alternative will be to save only one of the 
        // trees (if a valid one exists) or an entire hive (see CmSaveKey)
        //
        status =  STATUS_INVALID_PARAMETER;

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        CmpUnlockRegistry();
        return status;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tCopy of partial HighHive\n"));

    //
    // Make a temporary hive, tree copy the key subtree from
    // HighHive hive to temp, tree-merge with the key subtree from
    // LowHive hive, write out the temporary, free the temporary.
    // Always write the HighHive subtree first, so its afterwise
    // only add new keys/values
    // 

    //
    // temporarily disable registry quota as we will be giving this memory back immediately!
    //
    OldQuotaAllowed = CmpGlobalQuotaAllowed;
    OldQuotaWarning = CmpGlobalQuotaWarning;
    CmpGlobalQuotaAllowed = CM_WRAP_LIMIT;
    CmpGlobalQuotaWarning = CM_WRAP_LIMIT;

#if DBG
    OldQuotaUsed = CmpGlobalQuotaUsed;
#endif

    //
    // Create the temporary hive
    //

    TmpCmHive = CmpCreateTemporaryHive(FileHandle);
    if (TmpCmHive == NULL) {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // Create a root cell, mark it as such
    //

    //
    // since the registry is locked exclusively here, we don't need to lock/release cells 
    // while copying the trees; So, we just set the release routines to NULL and restore after
    // the copy is complete; this saves some pain
    //
    SourceReleaseCellRoutine = HighHive->ReleaseCellRoutine;
    TargetReleaseCellRoutine = TmpCmHive->Hive.ReleaseCellRoutine;
    HighHive->ReleaseCellRoutine = NULL;
    TmpCmHive->Hive.ReleaseCellRoutine = NULL;

    newroot = CmpCopyKeyPartial(
                HighHive,
                HighCell,
                &(TmpCmHive->Hive),
                HCELL_NIL,          // will force KEY_HIVE_ENTRY set
                TRUE);

    HighHive->ReleaseCellRoutine = SourceReleaseCellRoutine;
    TmpCmHive->Hive.ReleaseCellRoutine = TargetReleaseCellRoutine;

    if (newroot == HCELL_NIL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    TmpCmHive->Hive.BaseBlock->RootCell = newroot;

    //
    // Do a tree copy. Copy the HighCell tree from HighHive first.
    //
    if (CmpCopyTree(HighHive, HighCell, &(TmpCmHive->Hive), newroot) == FALSE) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // Merge the values in the root node of the merged subtrees
    //
    LowNode = (PCM_KEY_NODE)HvGetCell(LowHive, LowCell);                                         
    if( LowNode == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(LowHive, LowCell);

    HighNode = (PCM_KEY_NODE)HvGetCell(&(TmpCmHive->Hive),newroot);
    if( HighNode == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(&(TmpCmHive->Hive),newroot);

    //
    // since the registry is locked exclusively here, we don't need to lock/release cells 
    // while copying the trees; So, we just set the release routines to NULL and restore after
    // the copy is complete; this saves some pain
    //
    SourceReleaseCellRoutine = LowHive->ReleaseCellRoutine;
    TargetReleaseCellRoutine = TmpCmHive->Hive.ReleaseCellRoutine;
    LowHive->ReleaseCellRoutine = NULL;
    TmpCmHive->Hive.ReleaseCellRoutine = NULL;

    if (CmpMergeKeyValues(LowHive, LowCell, LowNode, &(TmpCmHive->Hive), newroot, HighNode) == FALSE ){
        LowHive->ReleaseCellRoutine = SourceReleaseCellRoutine;
        TmpCmHive->Hive.ReleaseCellRoutine = TargetReleaseCellRoutine;
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tMerge partial LowHive over the HighHive\n"));

    //
    // Merge the two trees. A Merge operation is a sync that obeys
    // the following aditional rules:
    //      1. keys the exist in the taget tree and does not exist
    //      in the source tree remain as they are (don't get deleted)
    //      2. keys the doesn't exist both in the target tree are added
    //      "as they are" from the source tree (always the target tree
    //      has a higher precedence)
    // 
    if (CmpMergeTrees(LowHive, LowCell, &(TmpCmHive->Hive), newroot) == FALSE) {
        LowHive->ReleaseCellRoutine = SourceReleaseCellRoutine;
        TmpCmHive->Hive.ReleaseCellRoutine = TargetReleaseCellRoutine;
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    LowHive->ReleaseCellRoutine = SourceReleaseCellRoutine;
    TmpCmHive->Hive.ReleaseCellRoutine = TargetReleaseCellRoutine;
    
    //
    // Write the file
    //
    TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] = FileHandle;
    status = HvWriteHive(&(TmpCmHive->Hive),FALSE,FALSE,FALSE);
    TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;

    //
    // Error exits
    //
ErrorInsufficientResources:
    //
    // Free the temporary hive
    //
    if (TmpCmHive != NULL) {
        CmpDestroyTemporaryHive(TmpCmHive);
    }

#if DBG
    //
    // Sanity check: when this assert fires, we have leaks in the merge routine.
    //
    ASSERT( OldQuotaUsed == CmpGlobalQuotaUsed );
#endif
    //
    // Set global quota back to what it was.
    //
    CmpGlobalQuotaAllowed = OldQuotaAllowed;
    CmpGlobalQuotaWarning = OldQuotaWarning;
    DCmCheckRegistry(CONTAINING_RECORD(HighHive, CMHIVE, Hive));
    DCmCheckRegistry(CONTAINING_RECORD(LowHive, CMHIVE, Hive));

#ifdef CHECK_REGISTRY_USECOUNT
    CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

    CmpUnlockRegistry();
    return status;
}


NTSTATUS
CmpSaveKeyByFileCopy(
    PCMHIVE  CmHive,
    HANDLE  FileHandle
    )
/*++

Routine Description:

    Do special case of SaveKey by copying the hive file

Arguments:

    CmHive - supplies a pointer to an HHive

    FileHandle - open handle to target file

Return Value:

    NTSTATUS - Result code from call, among the following:

--*/
{
    PHBASE_BLOCK    BaseBlock;
    NTSTATUS        status;
    ULONG           Offset;
    ULONG           Length;
    ULONG           Position;
    PUCHAR          CopyBuffer;
    ULONG           BufferLength;
    ULONG           BytesToCopy;
    CMP_OFFSET_ARRAY offsetElement;

    PAGED_CODE();

    //
    // Attempt to allocate large buffer for copying stuff around.  If
    // we can't get one, just use the stash buffer.
    //
    BufferLength = CM_SAVEKEYBUFSIZE;
    try {
        CopyBuffer = ExAllocatePoolWithQuota(PagedPoolCacheAligned,
                                             BufferLength);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        CopyBuffer = NULL;
    }
    CmpLockRegistryExclusive();
#ifdef CHECK_REGISTRY_USECOUNT
    CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT
    if (CopyBuffer == NULL) {
        LOCK_STASH_BUFFER();
        CopyBuffer = CmpStashBuffer;
        BufferLength = HBLOCK_SIZE;
    }
    //
    // Read the base block, step the sequence number, and write it out
    //
    status = STATUS_REGISTRY_IO_FAILED;

    CmHive->FileHandles[HFILE_TYPE_EXTERNAL] = FileHandle;

    Offset = 0;

    if( !CmpFileRead((PHHIVE)CmHive,HFILE_TYPE_PRIMARY,&Offset,CopyBuffer,HBLOCK_SIZE) ) {
        goto ErrorExit;
    }

    BaseBlock = (PHBASE_BLOCK)CopyBuffer;
    Length = BaseBlock->Length;

    BaseBlock->Sequence1++;

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = CopyBuffer;
    offsetElement.DataLength = HBLOCK_SIZE;
    if ( ! CmpFileWrite((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL, &offsetElement,
                        1, &Offset))
    {
        goto ErrorExit;
    }

    //
    // Flush the external, so header will show corrupt until we're done
    //
    if (CmpFileFlush((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        status = STATUS_SUCCESS;
    }

    //
    // For span of data, read from master and write to external
    //
    for (Position = 0; Position < Length; Position += BytesToCopy) {

        Offset = Position + HBLOCK_SIZE;
        BytesToCopy = Length-Position;
        if (BytesToCopy > BufferLength) {
            BytesToCopy = BufferLength;
        }

        if( !CmpFileRead((PHHIVE)CmHive,HFILE_TYPE_PRIMARY,&Offset,CopyBuffer,BytesToCopy) ) {
            goto ErrorExit;
        }

        Offset = Position + HBLOCK_SIZE;
        offsetElement.FileOffset = Offset;
        offsetElement.DataBuffer = CopyBuffer;
        offsetElement.DataLength = BytesToCopy;
        if ( ! CmpFileWrite((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL, &offsetElement,
                            1, &Offset))
        {
            goto ErrorExit;
        }
    }

    //
    // Flush the external, so data is there before we update the header
    //
    if (CmpFileFlush((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        status = STATUS_SUCCESS;
    }

    //
    // Reread the base block, sync the seq #, rewrite it.
    // (Brute force, but means no memory alloc - always works)
    //
    Offset = 0;
    if( !CmpFileRead((PHHIVE)CmHive,HFILE_TYPE_PRIMARY,&Offset,CopyBuffer,HBLOCK_SIZE) ) {
        goto ErrorExit;
    }
    BaseBlock->Sequence1++;     // it got trampled when we reread it
    BaseBlock->Sequence2++;

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = CopyBuffer;
    offsetElement.DataLength = HBLOCK_SIZE;
    if ( ! CmpFileWrite((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL, &offsetElement,
                        1, &Offset))
    {
        goto ErrorExit;
    }

    //
    // Flush the external, and we are done
    //
    if (CmpFileFlush((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        status = STATUS_SUCCESS;
    }

ErrorExit:
    if (CopyBuffer != CmpStashBuffer) {
        ExFreePool(CopyBuffer);
    } else {
        UNLOCK_STASH_BUFFER();
    }
    CmHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;
    CmpUnlockRegistry();
    return status;
}


PCMHIVE
CmpCreateTemporaryHive(
    IN HANDLE FileHandle
    )
/*++

Routine Description:

    Allocates and inits a temporary hive.

Arguments:

    FileHandle - Supplies the handle of the file to back the hive.

Return Value:

    Pointer to CmHive.

    If NULL the operation failed.

--*/
{
    PCMHIVE TempHive;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // NOTE: Hive will get put on CmpHiveListHead list.
    //       Make sure CmpDestroyTemporaryHive gets called to remove it.
    //

    Status = CmpInitializeHive(&TempHive,
                          HINIT_CREATE,
                          HIVE_VOLATILE,
                          0,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          0);
    if (NT_SUCCESS(Status)) {
        return(TempHive);
    } else {
        return(NULL);
    }

}


VOID
CmpDestroyTemporaryHive(
    PCMHIVE CmHive
    )
/*++

Routine Description:

    Frees all the pieces of a hive.

Arguments:

    CmHive - CM level hive structure to free

Return Value:

    None.

--*/
{
    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpDestroyTemporaryHive:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tCmHive=%p\n", CmHive));

    if (CmHive == NULL) {
        return;
    }

    //
    // NOTE: Hive is on CmpHiveListHead list.
    //       Remove it.
    //
    CmpDestroyHiveViewList(CmHive);
    CmpDestroySecurityCache(CmHive);
    CmpDropFileObjectForHive(CmHive);

    LOCK_HIVE_LIST();
    CmpRemoveEntryList(&CmHive->HiveList);
    UNLOCK_HIVE_LIST();

    HvFreeHive(&(CmHive->Hive));
    ASSERT( CmHive->HiveLock );
    ExFreePool(CmHive->HiveLock);
    ASSERT( CmHive->ViewLock );
    ExFreePool(CmHive->ViewLock);
    CmpFree(CmHive, sizeof(CMHIVE));

    return;
}

NTSTATUS
CmpOverwriteHive(
					PCMHIVE			CmHive,
					PCMHIVE			NewHive,
					HCELL_INDEX		LinkCell
					)
{
	HCELL_INDEX             RootCell;
	BOOLEAN					Result;
	PCM_KEY_NODE			RootNode;
    PULONG					Vector;
	ULONG					Length;

    PAGED_CODE();

	// get rid of the views.
	CmpDestroyHiveViewList (CmHive);

    RootCell = NewHive->Hive.BaseBlock->RootCell;

	RootNode = (PCM_KEY_NODE)HvGetCell(&(NewHive->Hive),RootCell);
	if( RootNode == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
	}
	if( !HvMarkCellDirty(&(NewHive->Hive),RootCell) ) {
		HvReleaseCell(&(NewHive->Hive),RootCell);
        return STATUS_NO_LOG_SPACE;
	}
	RootNode->Parent = LinkCell;
	RootNode->Flags |= KEY_HIVE_ENTRY | KEY_NO_DELETE;
	HvReleaseCell(&(NewHive->Hive),RootCell);
	//
	// dump data over to the log and primary
	//
	ASSERT( NewHive->Hive.DirtyVector.Buffer == NULL );
	ASSERT( NewHive->Hive.DirtyAlloc == 0 );
	Length = NewHive->Hive.Storage[Stable].Length;
	Vector = (PULONG)((NewHive->Hive.Allocate)(ROUND_UP(Length /HSECTOR_SIZE/8,sizeof(ULONG)),TRUE,CM_FIND_LEAK_TAG22));
	if (Vector == NULL) {
		return STATUS_NO_MEMORY;
	}
	RtlZeroMemory(Vector, Length / HSECTOR_SIZE / 8);
    RtlInitializeBitMap(&(NewHive->Hive.DirtyVector), Vector, Length / HSECTOR_SIZE);
	NewHive->Hive.DirtyAlloc = ROUND_UP(Length /HSECTOR_SIZE/8,sizeof(ULONG));
    RtlSetAllBits(&(NewHive->Hive.DirtyVector));
    NewHive->Hive.DirtyCount = NewHive->Hive.DirtyVector.SizeOfBitMap;
    NewHive->Hive.Log = TRUE;

	NewHive->FileHandles[HFILE_TYPE_LOG] = CmHive->FileHandles[HFILE_TYPE_LOG];
	
	Result = HvpGrowLog2(&(NewHive->Hive), Length);
	if( Result) {
		Result = HvpWriteLog(&(NewHive->Hive));
	}

	NewHive->FileHandles[HFILE_TYPE_LOG] = NULL;
	
	NewHive->Hive.Free(Vector,NewHive->Hive.DirtyAlloc);
	NewHive->Hive.DirtyAlloc = 0;
	NewHive->Hive.DirtyCount = 0;
	RtlZeroMemory(&(NewHive->Hive.DirtyVector),sizeof(RTL_BITMAP));
    NewHive->Hive.Log = FALSE;

	if( !Result ) {
        return STATUS_REGISTRY_IO_FAILED;
	}
	NewHive->FileHandles[HFILE_TYPE_EXTERNAL] = CmHive->FileHandles[HFILE_TYPE_PRIMARY];
	//
	// all data in the new hive is marked as dirty !!!
	// even if this fails; we are going to keep the hive in memory, so no problem, we have the log !
	//
	NewHive->FileObject = CmHive->FileObject;
    NewHive->Hive.BaseBlock->Type = HFILE_TYPE_PRIMARY;
	HvWriteHive(&(NewHive->Hive),Length <= CmHive->Hive.Storage[Stable].Length,CmHive->FileObject != NULL,TRUE);
	NewHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;
	NewHive->FileObject = NULL;

    RtlClearAllBits(&(NewHive->Hive.DirtyVector));
    NewHive->Hive.DirtyCount = 0;
	return STATUS_SUCCESS;
}


VOID
CmpSwitchStorageAndRebuildMappings(PCMHIVE	OldCmHive,
								   PCMHIVE	NewCmHive
								   ) 
/*++

Routine Description:

    Switches relevant storage between the hives. Then, rebuilds 
	the kcb mapping according with the mapping stored inside OldHive

Arguments:

    OldHive - Hive to be updated; the one that is currently linked in 
	the registry tree

	NewHive - the compressed hive; it'll be freed after this operation.

Return Value:

    None.

--*/
{

	HHIVE							TmpHive;
	RTL_BITMAP						Bitmap;
    ULONG							i;
	LONG							j;
    PCM_KCB_REMAP_BLOCK				RemapBlock;
	PLIST_ENTRY						AnchorAddr;
	BOOLEAN							OldSmallDir;
	BOOLEAN							NewSmallDir;
    PFREE_HBIN                      FreeBin;
    PCM_KNODE_REMAP_BLOCK           KnodeRemapBlock;

	PAGED_CODE();

	//
	// The baseblock
	//
    OldCmHive->Hive.BaseBlock->Sequence1 = NewCmHive->Hive.BaseBlock->Sequence1;
    OldCmHive->Hive.BaseBlock->Sequence2 = NewCmHive->Hive.BaseBlock->Sequence2;
    OldCmHive->Hive.BaseBlock->RootCell = NewCmHive->Hive.BaseBlock->RootCell;
    
	//
	// rest of the hive 
	//
	ASSERT( (NewCmHive->Hive.DirtyVector.Buffer == NULL) && 
			(NewCmHive->Hive.DirtyCount == 0) &&
			(NewCmHive->Hive.DirtyAlloc == 0) &&
			(OldCmHive->Hive.Storage[Stable].Length >= NewCmHive->Hive.Storage[Stable].Length) );

	OldCmHive->Hive.LogSize = NewCmHive->Hive.LogSize;
	NewCmHive->Hive.LogSize = 0;


	//
	// switch hive stable storage; preserving the volatile info
	//
	OldSmallDir = (OldCmHive->Hive.Storage[Stable].Map == (PHMAP_DIRECTORY)&(OldCmHive->Hive.Storage[Stable].SmallDir));
	NewSmallDir = (NewCmHive->Hive.Storage[Stable].Map == (PHMAP_DIRECTORY)&(NewCmHive->Hive.Storage[Stable].SmallDir));
	RtlCopyMemory(&(TmpHive.Storage[Stable]),&(OldCmHive->Hive.Storage[Stable]),sizeof(TmpHive.Storage[Stable]) - sizeof(LIST_ENTRY) );
	RtlCopyMemory(&(OldCmHive->Hive.Storage[Stable]),&(NewCmHive->Hive.Storage[Stable]),sizeof(TmpHive.Storage[Stable]) - sizeof(LIST_ENTRY) );
	RtlCopyMemory(&(NewCmHive->Hive.Storage[Stable]),&(TmpHive.Storage[Stable]),sizeof(TmpHive.Storage[Stable])  - sizeof(LIST_ENTRY) );
	if( OldSmallDir ) {
        NewCmHive->Hive.Storage[Stable].Map = (PHMAP_DIRECTORY)&(NewCmHive->Hive.Storage[Stable].SmallDir);
	}
	if( NewSmallDir ) {
        OldCmHive->Hive.Storage[Stable].Map = (PHMAP_DIRECTORY)&(OldCmHive->Hive.Storage[Stable].SmallDir);
	}
    //
    // For FreeBins we have to take special precaution and move them manually from one list to another
    //
    // new hive should not have free bins.
    ASSERT( IsListEmpty(&(NewCmHive->Hive.Storage[Stable].FreeBins)) );
    while( !IsListEmpty(&(OldCmHive->Hive.Storage[Stable].FreeBins)) ) {
        FreeBin = (PFREE_HBIN)RemoveHeadList(&(OldCmHive->Hive.Storage[Stable].FreeBins));
        FreeBin = CONTAINING_RECORD(FreeBin,
                                    FREE_HBIN,
                                    ListEntry);

        InsertTailList(
            &(NewCmHive->Hive.Storage[Stable].FreeBins),
            &(FreeBin->ListEntry)
            );
    }
    ASSERT( IsListEmpty(&(OldCmHive->Hive.Storage[Stable].FreeBins)) );

	ASSERT( IsListEmpty(&(OldCmHive->LRUViewListHead)) && (OldCmHive->MappedViews == 0) && (OldCmHive->UseCount == 0) );
	ASSERT( IsListEmpty(&(NewCmHive->LRUViewListHead)) && (NewCmHive->MappedViews == 0) && (OldCmHive->UseCount == 0) );

	ASSERT( IsListEmpty(&(OldCmHive->PinViewListHead)) && (OldCmHive->PinnedViews == 0) );
	ASSERT( IsListEmpty(&(NewCmHive->PinViewListHead)) && (NewCmHive->PinnedViews == 0) );
	
	//
	// now the security cache; we preserve the security cache; only that we go through it and 
    // shift cells accordingly
	//
    for( i=0;i<OldCmHive->SecurityCount;i++) {
		if( HvGetCellType(OldCmHive->SecurityCache[i].Cell) == (ULONG)Stable ) {
            ASSERT( OldCmHive->SecurityCache[i].Cell == OldCmHive->CellRemapArray[i].OldCell );
            ASSERT( OldCmHive->SecurityCache[i].Cell ==  OldCmHive->SecurityCache[i].CachedSecurity->Cell);
            OldCmHive->SecurityCache[i].Cell = OldCmHive->CellRemapArray[i].NewCell;
            OldCmHive->SecurityCache[i].CachedSecurity->Cell = OldCmHive->CellRemapArray[i].NewCell;
		} 
    }

	//
	// now restore mappings for kcbs KeyCells 
	//
	AnchorAddr = &(OldCmHive->KcbConvertListHead);
	RemapBlock = (PCM_KCB_REMAP_BLOCK)(OldCmHive->KcbConvertListHead.Flink);

	while ( RemapBlock != (PCM_KCB_REMAP_BLOCK)AnchorAddr ) {
		RemapBlock = CONTAINING_RECORD(
						RemapBlock,
						CM_KCB_REMAP_BLOCK,
						RemapList
						);
		ASSERT( RemapBlock->OldCellIndex != HCELL_NIL );

		if( (HvGetCellType(RemapBlock->KeyControlBlock->KeyCell) == (ULONG)Stable) &&  // we are preserving volatile storage
			(!(RemapBlock->KeyControlBlock->ExtFlags & CM_KCB_KEY_NON_EXIST)) // don't mess with fake kcbs
			) {
			ASSERT( RemapBlock->NewCellIndex != HCELL_NIL );
			RemapBlock->KeyControlBlock->KeyCell = RemapBlock->NewCellIndex;
		}
		//
		// invalidate the cache
		//
        if( (!(RemapBlock->KeyControlBlock->Flags & KEY_PREDEF_HANDLE) ) && // don't mess with predefined handles
			(!(RemapBlock->KeyControlBlock->ExtFlags & (CM_KCB_KEY_NON_EXIST|CM_KCB_SYM_LINK_FOUND))) && // don't mess with fake kcbs or symlinks
			(HvGetCellType(RemapBlock->KeyControlBlock->KeyCell) == (ULONG)Stable) // we are preserving volatile storage
			) {
			CmpCleanUpKcbValueCache(RemapBlock->KeyControlBlock);
			CmpSetUpKcbValueCache(RemapBlock->KeyControlBlock,RemapBlock->ValueCount,RemapBlock->ValueList);
		}
        //
        // skip to the next element
        //
        RemapBlock = (PCM_KCB_REMAP_BLOCK)(RemapBlock->RemapList.Flink);
	}

	//
	// now restore mappings for volatile Knodes
	//
	AnchorAddr = &(OldCmHive->KnodeConvertListHead);
	KnodeRemapBlock = (PCM_KNODE_REMAP_BLOCK)(OldCmHive->KnodeConvertListHead.Flink);

	while ( KnodeRemapBlock != (PCM_KNODE_REMAP_BLOCK)AnchorAddr ) {
		KnodeRemapBlock = CONTAINING_RECORD(
						KnodeRemapBlock,
						CM_KNODE_REMAP_BLOCK,
						RemapList
						);
	    KnodeRemapBlock->KeyNode->Parent = KnodeRemapBlock->NewParent;
       
        //
        // skip to the next element
        //
        KnodeRemapBlock = (PCM_KNODE_REMAP_BLOCK)(KnodeRemapBlock->RemapList.Flink);
	}


}

NTSTATUS
CmpShiftHiveFreeBins(
					  PCMHIVE			CmHive,
					  PCMHIVE			*NewHive
					  )
/*++

Routine Description:

Arguments:

	CmHive - the hive to compress

    NewHive - hive with the free bins shifted to the end.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS                status;
    HCELL_INDEX             newroot;
    PHHIVE                  Hive;
	HCELL_INDEX             RootCell;
    ULONG                   NewLength;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
	ASSERT( !IsListEmpty(&(CmHive->Hive.Storage[Stable].FreeBins)) );

	*NewHive = NULL;
    //
    // Disallow attempts to "save" a hive which cannot be saved.
    //
    Hive = &(CmHive->Hive);
    RootCell = Hive->BaseBlock->RootCell;


    if ( (Hive == &CmpMasterHive->Hive) ||
		 ( (Hive->HiveFlags & HIVE_NOLAZYFLUSH) && (Hive->DirtyCount != 0) ) ||
         (CmHive->FileHandles[HFILE_TYPE_PRIMARY] == NULL) 
       ) {
        return STATUS_ACCESS_DENIED;
    }


	if(Hive->DirtyCount != 0) {
		//
		// need to flush the hive as we will replace it with the compressed one.
		//
		if( !HvSyncHive(Hive) ) {
	        return STATUS_ACCESS_DENIED;
		}
	}

    //
    // The subtree the caller wants does not exactly match a
    // subtree.  Make a temporary hive, tree copy the source
    // to temp, write out the temporary, free the temporary.
    //

    //
    // Create the temporary hive
    //

    (*NewHive) = CmpCreateTemporaryHive(NULL);
    if (*NewHive == NULL) {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // Create a root cell, mark it as such
    //

    //
    // preserve the hive version and signal to copy tree to build mappings and preserve volatile.
    //
    (*NewHive)->Hive.BaseBlock->Minor = Hive->BaseBlock->Minor;
    (*NewHive)->Hive.Version = Hive->Version;
    (*NewHive)->Hive.BaseBlock->RootCell = CmHive->Hive.BaseBlock->RootCell;
    

    //
    // this will create a clone hive (in paged pool) and will compute the shift index for each bin
    //
    status = HvCloneHive(&(CmHive->Hive),&((*NewHive)->Hive),&NewLength);
    if( !NT_SUCCESS(status) ) {
        goto ErrorInsufficientResources;
    }

    //
    // iterate through the hive and shift each cell; this will take care of the mappings too.
    //
    if( !CmpShiftAllCells(&((*NewHive)->Hive),CmHive) ) {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    (*NewHive)->Hive.BaseBlock->RootCell = HvShiftCell(&((*NewHive)->Hive),(*NewHive)->Hive.BaseBlock->RootCell);

    //
    // moves free bins at the end and updates the maps.
    //
    status = HvShrinkHive(&((*NewHive)->Hive),NewLength);
    if( !NT_SUCCESS(status) ) {
        goto ErrorInsufficientResources;
    }
    
    return STATUS_SUCCESS;
    //
    // Error exits
    //
ErrorInsufficientResources:

    //
    // Free the temporary hive
    //
    if ((*NewHive) != NULL) {
        CmpDestroyTemporaryHive((*NewHive));
        (*NewHive) = NULL;
    }


    return status;
}

BOOLEAN
CmpShiftAllCells(PHHIVE     NewHive,
                 PCMHIVE    OldHive
                 )
/*++

Routine Description:

    Parsess the logical structure of the registry tree and remaps all
    cells inside, according to the Spare filed in each bin. Updates 
    kcb and security mapping also.

Arguments:

	NewHive - hive to remap
    
    OldHive - the old hive - will use volatile from it (temporary)

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    
    PRELEASE_CELL_ROUTINE   ReleaseCellRoutine;
    BOOLEAN                 Result = TRUE;
    ULONG                   i;

    PAGED_CODE();

    ReleaseCellRoutine = NewHive->ReleaseCellRoutine;
    NewHive->ReleaseCellRoutine = NULL;

    //
    // setup volatile to the newhive; just temporary, so we can access it
    //
    ASSERT( NewHive->Storage[Volatile].Length == 0 );
    ASSERT( NewHive->Storage[Volatile].Map == NULL );
    ASSERT( NewHive->Storage[Volatile].SmallDir == NULL );
    NewHive->Storage[Volatile].Length = OldHive->Hive.Storage[Volatile].Length;
    NewHive->Storage[Volatile].Map = OldHive->Hive.Storage[Volatile].Map;
    NewHive->Storage[Volatile].SmallDir = OldHive->Hive.Storage[Volatile].SmallDir;

    CmpShiftSecurityCells(NewHive);
    //
    // update the security mapping array
    //
    for( i=0;i<OldHive->SecurityCount;i++) {
		if( HvGetCellType(OldHive->SecurityCache[i].Cell) == (ULONG)Stable ) {
			OldHive->CellRemapArray[i].NewCell = HvShiftCell(NewHive,OldHive->CellRemapArray[i].OldCell);
		} 
    }
    
    Result =  CmpShiftAllCells2(NewHive,OldHive,NewHive->BaseBlock->RootCell, HCELL_NIL);
    
    NewHive->Storage[Volatile].Length = 0;
    NewHive->Storage[Volatile].Map = NULL;
    NewHive->Storage[Volatile].SmallDir = NULL;

    NewHive->ReleaseCellRoutine = ReleaseCellRoutine;
    return Result;
}

BOOLEAN
CmpShiftAllCells2(  PHHIVE      Hive,
                    PCMHIVE     OldHive,
                    HCELL_INDEX Cell,
                    HCELL_INDEX ParentCell
                    )
/*++

Routine Description:

    In this routine, HvGetCell cannot fail because the hive is in paged pool!

Arguments:

	CmHive - hive to remap

Return Value:

        TRUE/FALSE
--*/
{   
    PCMP_CHECK_REGISTRY_STACK_ENTRY     CheckStack;
    LONG                                StackIndex;
    PCM_KEY_NODE                        Node;
    HCELL_INDEX                         SubKey;
    BOOLEAN                             Result = TRUE;
    PCM_KEY_INDEX                       Index;
    ULONG                               i;


    ASSERT( Hive->ReleaseCellRoutine == NULL );

    //
    // Initialize the stack to simulate recursion here
    //

    CheckStack = ExAllocatePool(PagedPool,sizeof(CMP_CHECK_REGISTRY_STACK_ENTRY)*CMP_MAX_REGISTRY_DEPTH);
    if (CheckStack == NULL) {
        return FALSE;
    }
    CheckStack[0].Cell = Cell;
    CheckStack[0].ParentCell = ParentCell;
    CheckStack[0].ChildIndex = 0;
    CheckStack[0].CellChecked = FALSE;
    StackIndex = 0;


    while(StackIndex >=0) {
        //
        // first check the current cell
        //
        if( CheckStack[StackIndex].CellChecked == FALSE ) {
            CheckStack[StackIndex].CellChecked = TRUE;

            CmpShiftKey(Hive,OldHive,CheckStack[StackIndex].Cell,CheckStack[StackIndex].ParentCell);
        }

        Node = (PCM_KEY_NODE)HvGetCell(Hive, CheckStack[StackIndex].Cell);
        ASSERT( Node != NULL );

        if( CheckStack[StackIndex].ChildIndex < Node->SubKeyCounts[Stable] ) {
            //
            // we still have childs to check; add another entry for them and advance the 
            // StackIndex
            //
            SubKey = CmpFindSubKeyByNumber(Hive,
                                           Node,
                                           CheckStack[StackIndex].ChildIndex);
            ASSERT( SubKey != HCELL_NIL ); 
            //
            // next iteration will check the next child
            //
            CheckStack[StackIndex].ChildIndex++;

            StackIndex++;
            if( StackIndex == CMP_MAX_REGISTRY_DEPTH ) {
                //
                // we've run out of stack; registry tree has too many levels
                //
                Result = FALSE;
                // bail out
                break;
            }
            CheckStack[StackIndex].Cell = SubKey;
            CheckStack[StackIndex].ParentCell = CheckStack[StackIndex-1].Cell;
            CheckStack[StackIndex].ChildIndex = 0;
            CheckStack[StackIndex].CellChecked = FALSE;

        } else {
            //
            // add all volatile nodes to the volatile list
            //
	        PCM_KNODE_REMAP_BLOCK		knodeRemapBlock;

            for(i = 0; i<Node->SubKeyCounts[Volatile];i++) {
                SubKey = CmpFindSubKeyByNumber(Hive,
                                               Node,
                                               Node->SubKeyCounts[Stable] + i);
                ASSERT( SubKey != HCELL_NIL ); 

                knodeRemapBlock = (PCM_KNODE_REMAP_BLOCK)ExAllocatePool(PagedPool, sizeof(CM_KNODE_REMAP_BLOCK));
		        if( knodeRemapBlock == NULL ) {
			        Result = FALSE;
                    break;
		        }
                ASSERT( HvGetCellType(SubKey) == (ULONG)Volatile );
                knodeRemapBlock->KeyNode = (PCM_KEY_NODE)HvGetCell(Hive,SubKey);;
	            knodeRemapBlock->NewParent = HvShiftCell(Hive,CheckStack[StackIndex].Cell);

                InsertTailList(&(OldHive->KnodeConvertListHead),&(knodeRemapBlock->RemapList));
            }

            //
            // we have checked all childs for this node; time to take care of the index.
            // 
            if( Node->SubKeyLists[Stable] != HCELL_NIL ) {
                Index = (PCM_KEY_INDEX)HvGetCell(Hive, Node->SubKeyLists[Stable]);
                CmpShiftIndex(Hive,Index);
                Node->SubKeyLists[Stable] = HvShiftCell(Hive,Node->SubKeyLists[Stable]);
            }
            //
            // ; go back
            //
            StackIndex--;

        }

    }

    ExFreePool(CheckStack);
    return Result;

}

VOID 
CmpShiftIndex(PHHIVE        Hive,
              PCM_KEY_INDEX Index
              )
{
    ULONG               i,j;
    HCELL_INDEX         LeafCell;
    PCM_KEY_INDEX       Leaf;
    PCM_KEY_FAST_INDEX  FastIndex;

    if (Index->Signature == CM_KEY_INDEX_ROOT) {

        //
        // step through root, update the leafs
        //
        for (i = 0; i < Index->Count; i++) {
            LeafCell = Index->List[i];
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
            ASSERT( Leaf != NULL ); 

            for(j=0;j<Leaf->Count;j++) {
                if( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                    (Leaf->Signature == CM_KEY_HASH_LEAF) ) {
                    FastIndex = (PCM_KEY_FAST_INDEX)Leaf;
                    FastIndex->List[j].Cell = HvShiftCell(Hive,FastIndex->List[j].Cell);
                } else {
                    Leaf->List[j] = HvShiftCell(Hive,Leaf->List[j]);
                }
            }
        }
    }

    //
    // now update the root
    //
    for (i = 0; i < Index->Count; i++) {
        if( (Index->Signature == CM_KEY_FAST_LEAF) ||
            (Index->Signature == CM_KEY_HASH_LEAF) ) {
            FastIndex = (PCM_KEY_FAST_INDEX)Index;
            FastIndex->List[i].Cell = HvShiftCell(Hive,FastIndex->List[i].Cell);
        } else {
            Index->List[i] = HvShiftCell(Hive,Index->List[i]);
        }
    }
}

VOID
CmpShiftKey(PHHIVE      Hive,
            PCMHIVE     OldHive,
            HCELL_INDEX Cell,
            HCELL_INDEX ParentCell
            )
{
    PCM_KEY_NODE            Node;
	PCM_KCB_REMAP_BLOCK		RemapBlock;
    PLIST_ENTRY             AnchorAddr;

    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
    ASSERT( Node != NULL );
    
    //
    // key node related cells
    //
    if( ParentCell != HCELL_NIL ) {
        ASSERT( ParentCell == Node->Parent );
        Node->Parent = HvShiftCell(Hive,Node->Parent);
    }
    ASSERT( Node->Security != HCELL_NIL );
    Node->Security = HvShiftCell(Hive,Node->Security);
    if( Node->Class != HCELL_NIL ) {
        Node->Class = HvShiftCell(Hive,Node->Class);
    }
    
    //
    // now the valuelist
    //
    if( Node->ValueList.Count > 0 ) {
        CmpShiftValueList(Hive,Node->ValueList.List,Node->ValueList.Count);
        Node->ValueList.List = HvShiftCell(Hive,Node->ValueList.List);
    }

    //
	// walk the KcbConvertListHead and store the mappings
	//
	AnchorAddr = &(OldHive->KcbConvertListHead);
	RemapBlock = (PCM_KCB_REMAP_BLOCK)(OldHive->KcbConvertListHead.Flink);

	while ( RemapBlock != (PCM_KCB_REMAP_BLOCK)AnchorAddr ) {
		RemapBlock = CONTAINING_RECORD(
						RemapBlock,
						CM_KCB_REMAP_BLOCK,
						RemapList
						);
		ASSERT( RemapBlock->OldCellIndex != HCELL_NIL );
		if( RemapBlock->OldCellIndex == Cell ) {
			//
			// found it !
			//
			// can only be set once 
			ASSERT( RemapBlock->NewCellIndex == HCELL_NIL );
			RemapBlock->NewCellIndex = HvShiftCell(Hive,Cell);;
		    RemapBlock->ValueCount = Node->ValueList.Count;
		    RemapBlock->ValueList = Node->ValueList.List;
			break;
		}
        //
        // skip to the next element
        //
        RemapBlock = (PCM_KCB_REMAP_BLOCK)(RemapBlock->RemapList.Flink);
	}

}

VOID
CmpShiftValueList(PHHIVE      Hive,
            HCELL_INDEX ValueList,
            ULONG       Count
            )
{
    PCELL_DATA      List,pcell;
    ULONG           i,j;
    HCELL_INDEX     Cell;
    ULONG           DataLength;
    HCELL_INDEX     Data;
    PCM_BIG_DATA    BigData;
    PHCELL_INDEX    Plist;

    List = HvGetCell(Hive,ValueList);
    ASSERT( List != NULL );

    for (i = 0; i < Count; i++) {
        Cell = List->u.KeyList[i];
        pcell = HvGetCell(Hive, Cell);
        ASSERT( pcell != NULL );
        DataLength = pcell->u.KeyValue.DataLength;
        if (DataLength < CM_KEY_VALUE_SPECIAL_SIZE) {
            //
            // regular value.
            //
            if( CmpIsHKeyValueBig(Hive,DataLength) == TRUE ) {
                BigData = (PCM_BIG_DATA)HvGetCell(Hive, pcell->u.KeyValue.Data);
                ASSERT( BigData != NULL );
                
                if( BigData->Count ) {
                    Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
                    ASSERT( Plist != NULL );
                    for(j=0;j<BigData->Count;j++) {
                        Plist[j] = HvShiftCell(Hive,Plist[j]);
                    }
                    BigData->List = HvShiftCell(Hive,BigData->List);
                }
            }
            
            if( pcell->u.KeyValue.Data != HCELL_NIL ) {
                pcell->u.KeyValue.Data = HvShiftCell(Hive,pcell->u.KeyValue.Data);
            }
        }
        List->u.KeyList[i] = HvShiftCell(Hive,List->u.KeyList[i]);

    }

}

VOID 
CmpShiftSecurityCells(PHHIVE        Hive)
{

    PCM_KEY_NODE        RootNode;
    PCM_KEY_SECURITY    SecurityCell;
    HCELL_INDEX         ListAnchor;
    HCELL_INDEX         NextCell;
    
    ASSERT( Hive->ReleaseCellRoutine == NULL );
    RootNode = (PCM_KEY_NODE) HvGetCell(Hive, Hive->BaseBlock->RootCell);
    ASSERT( RootNode != NULL );

    ListAnchor = NextCell = RootNode->Security;
    
    do {
        SecurityCell = (PCM_KEY_SECURITY) HvGetCell(Hive, NextCell);
        ASSERT( SecurityCell != NULL );

        NextCell = SecurityCell->Flink;
        SecurityCell->Flink = HvShiftCell(Hive,SecurityCell->Flink);
        SecurityCell->Blink = HvShiftCell(Hive,SecurityCell->Blink);
    } while ( NextCell != ListAnchor );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmse.c

Abstract:

    This module implements security routines for the configuration manager.

Author:

    John Vert (jvert) 20-Jan-1992

Revision History:

    Richard Ward (richardw) 14-Apr-1992  Changed ACE_HEADER

--*/
#include "cmp.h"


//
// Function prototypes private to this module
//

//
// Dragos: modified to use the security cache
//
BOOLEAN
CmpFindMatchingDescriptorCell(
    IN PCMHIVE CmHive,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Type,
    OUT PHCELL_INDEX MatchingCell,
    OUT OPTIONAL PCM_KEY_SECURITY_CACHE *CachedSecurityPointer
    );

////////////////
NTSTATUS
CmpSetSecurityDescriptorInfo(
    IN PCM_KEY_CONTROL_BLOCK kcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
CmpQuerySecurityDescriptorInfo(
    IN PCM_KEY_CONTROL_BLOCK kcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );

PCM_KEY_SECURITY
CmpGetKeySecurity(
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Key,
    OUT PHCELL_INDEX SecurityCell OPTIONAL
    );

NTSTATUS
CmpGetObjectSecurity(
    IN HCELL_INDEX Cell,
    IN PHHIVE Hive,
    OUT PCM_KEY_SECURITY *Security,
    OUT PHCELL_INDEX SecurityCell OPTIONAL
    );

BOOLEAN
CmpInsertSecurityCellList(
    IN PHHIVE Hive,
    IN HCELL_INDEX NodeCell,
    IN HCELL_INDEX SecurityCell
    );

VOID
CmpRemoveSecurityCellList(
    IN PHHIVE Hive,
    IN HCELL_INDEX SecurityCell
    );

ULONG
CmpSecurityExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    );

//
// This macro takes a PSECURITY_DESCRIPTOR and returns the size of the
// hive cell required to contain the entire security descriptor.
//

#define SECURITY_CELL_LENGTH(pDescriptor) \
    FIELD_OFFSET(CM_KEY_SECURITY,Descriptor) + \
    RtlLengthSecurityDescriptor(pDescriptor)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpSecurityMethod )
#pragma alloc_text(PAGE,CmpSetSecurityDescriptorInfo)
#pragma alloc_text(PAGE,CmpAssignSecurityDescriptor)
#pragma alloc_text(PAGE,CmpQuerySecurityDescriptorInfo)
#pragma alloc_text(PAGE,CmpCheckCreateAccess)
#pragma alloc_text(PAGE,CmpCheckNotifyAccess)
#pragma alloc_text(PAGE,CmpGetObjectSecurity)
#pragma alloc_text(PAGE,CmpGetKeySecurity)
#pragma alloc_text(PAGE,CmpHiveRootSecurityDescriptor)
#pragma alloc_text(PAGE,CmpFreeSecurityDescriptor)
#pragma alloc_text(PAGE,CmpInsertSecurityCellList)
#pragma alloc_text(PAGE,CmpRemoveSecurityCellList)
#pragma alloc_text(PAGE,CmpSecurityExceptionFilter)
#endif

ULONG
CmpSecurityExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )

/*++

Routine Description:

    Debug code to find registry security exceptions that are being swallowed

Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/

{
#ifndef _CM_LDR_
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CM: Registry security exception %lx, ExceptionPointers = %p\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers);
#endif //_CM_LDR_
    
    //
    // This is a request from the base test team; no dbg should be hit on the free builds 
    // at the client; after RC2 is shipped we should enable this on free builds too.
    //
#if DBG
    try {
        DbgBreakPoint();
    } except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // no debugger enabled, just keep going
        //

    }
#endif

    return(EXCEPTION_EXECUTE_HANDLER);
}

NTSTATUS
CmpSecurityMethod (
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This is the security method for registry objects.  It is responsible for
    retrieving, setting, and deleting the security descriptor of a registry
    object.  It is not used to assign the original security descriptor to an
    object (use SeAssignSecurity for that purpose).


    IT IS ASSUMED THAT THE OBJECT MANAGER HAS ALREADY DONE THE ACCESS
    VALIDATIONS NECESSARY TO ALLOW THE REQUESTED OPERATIONS TO BE PERFORMED.

Arguments:

    Object - Supplies a pointer to the object being used.

    OperationCode - Indicates if the operation is for setting, querying, or
        deleting the object's security descriptor.

    SecurityInformation - Indicates which security information is being
        queried or set.  This argument is ignored for the delete operation.

    SecurityDescriptor - The meaning of this parameter depends on the
        OperationCode:

        QuerySecurityDescriptor - For the query operation this supplies the
            buffer to copy the descriptor into.  The security descriptor is
            assumed to have been probed up to the size passed in in Length.
            Since it still points into user space, it must always be
            accessed in a try clause in case it should suddenly disappear.

        SetSecurityDescriptor - For a set operation this supplies the
            security descriptor to copy into the object.  The security
            descriptor must be captured before this routine is called.

        DeleteSecurityDescriptor - It is ignored when deleting a security
            descriptor.

        AssignSecurityDescriptor - For assign operations this is the
            security descriptor that will be assigned to the object.
            It is assumed to be in kernel space, and is therefore not
            probed or captured.

    CapturedLength - For the query operation this specifies the length, in
        bytes, of the security descriptor buffer, and upon return contains
        the number of bytes needed to store the descriptor.  If the length
        needed is greater than the length supplied the operation will fail.
        It is ignored in the set and delete operation.

        This parameter is assumed to be captured and probed as appropriate.

    ObjectsSecurityDescriptor - For the Set operation this supplies the address
        of a pointer to the object's current security descriptor.  This routine
        will either modify the security descriptor in place or deallocate/
        allocate a new security descriptor and use this variable to indicate
        its new location.  For the query operation it simply supplies
        the security descriptor being queried.

    PoolType - For the set operation this specifies the pool type to use if
        a new security descriptor needs to be allocated.  It is ignored
        in the query and delete operation.

    GenericMapping - Passed only for the set operation, this argument provides
        the mapping of generic to specific/standard access types for the object
        being accessed.  This mapping structure is expected to be safe to
        access (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the operation is successful and an
        appropriate error status otherwise.

--*/

{
    PCM_KEY_CONTROL_BLOCK   kcb;
    NTSTATUS                Status;
    CM_KEY_REFERENCE        Key;
    PCM_KEY_NODE            TempNode;

    //
    //  Make sure the common parts of our input are proper
    //

    PAGED_CODE();
    ASSERT_KEY_OBJECT(Object);

    ASSERT( (OperationCode == SetSecurityDescriptor) ||
            (OperationCode == QuerySecurityDescriptor) ||
            (OperationCode == AssignSecurityDescriptor) ||
            (OperationCode == DeleteSecurityDescriptor) );

    //
    // Lock hive for shared or exclusive, depending on what we need
    // to do.
    //
    if (OperationCode == QuerySecurityDescriptor) {
        CmpLockRegistry();
    } else {
        CmpLockRegistryExclusive();
#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT
    }

    if (((PCM_KEY_BODY)Object)->KeyControlBlock->Delete) {
        //
        // Key has been deleted, performing security operations on
        // it is Not Allowed.
        //
        CmpUnlockRegistry();
        return(STATUS_KEY_DELETED);
    }

    kcb = ((PCM_KEY_BODY)Object)->KeyControlBlock;

    try {

        //
        //  This routine simply cases off of the operation code to decide
        //  which support routine to call
        //

        switch (OperationCode) {

        case SetSecurityDescriptor:

            //
            //  check the rest of our input and call the set security
            //  method
            //
            ASSERT( (PoolType == PagedPool) || (PoolType == NonPagedPool) );

            Status = CmpSetSecurityDescriptorInfo( kcb,
                                                   SecurityInformation,
                                                   SecurityDescriptor,
                                                   ObjectsSecurityDescriptor,
                                                   PoolType,
                                                   GenericMapping );

            //
            // this is the one and only path on which a user could change
            // a security descriptor, therefore, report such changes for
            // notification here.
            //
            if (NT_SUCCESS(Status)) {
                CmpReportNotify(kcb,
                                kcb->KeyHive,
                                kcb->KeyCell,
                                REG_NOTIFY_CHANGE_ATTRIBUTES | REG_NOTIFY_CHANGE_SECURITY);
    
            }

            break;

        case QuerySecurityDescriptor:

            //
            //  check the rest of our input and call the default query security
            //  method
            //
            ASSERT( CapturedLength != NULL );
            Status = CmpQuerySecurityDescriptorInfo( kcb,
                                                     SecurityInformation,
                                                     SecurityDescriptor,
                                                     CapturedLength,
                                                     ObjectsSecurityDescriptor );
            break;

        case DeleteSecurityDescriptor:

            //
            // Nobody should ever call the delete method.  When the key is
            // freed, the security descriptor associated with it is
            // explicitly freed (CmpFreeSecurityDescriptor)
            //
            ASSERT(FALSE);

            break;

        case AssignSecurityDescriptor:

            //
            // Set the SecurityDescriptor field in the object's header to
            // NULL.  This indicates that our security method needs to be
            // called for any security descriptor operations.
            //

            Status = ObAssignObjectSecurityDescriptor(Object, NULL, PagedPool);

            ASSERT( NT_SUCCESS( Status ));

            TempNode = (PCM_KEY_NODE)HvGetCell(kcb->KeyHive, kcb->KeyCell);
            if( TempNode == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;
                // step thru exit
                break;
            }
            
            ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
            // release the cell right here as we are holding the reglock exclusive
            HvReleaseCell(kcb->KeyHive, kcb->KeyCell);
            //
            // Assign the actual descriptor.
            //
            Status = CmpAssignSecurityDescriptor( kcb->KeyHive,
                                                  kcb->KeyCell,
                                                  TempNode,
                                                  SecurityDescriptor );
            //
            // Security has been changed, update the cache.
            //
            ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
            CmpAssignSecurityToKcb(kcb,TempNode->Security);

            break;

        default:

            //
            //  Bugcheck on any other operation code,  We won't get here if
            //  the earlier asserts are still checked.
            //
            CM_BUGCHECK( REGISTRY_ERROR,BAD_SECURITY_METHOD,1,kcb,OperationCode);

        }

    } except (CmpSecurityExceptionFilter(GetExceptionInformation())) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpSecurityMethod: code:%08lx\n", GetExceptionCode()));
        Status = GetExceptionCode();
    }

    CmpUnlockRegistry();
    return(Status);

}

NTSTATUS
CmpSetSecurityDescriptorInfo(
    IN PCM_KEY_CONTROL_BLOCK Key,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This routine will set a node's security descriptor.  The input
    security descriptor must be previously captured.

Arguments:

    Key - Supplies a pointer to the KEY_CONTROL_BLOCK for the node whose
        security descriptor will be set.

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the SecurityDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure

    PoolType - Specifies the type of pool to allocate for the objects
        security descriptor.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        value otherwise

--*/

{
    NTSTATUS                Status;
    HCELL_INDEX             SecurityCell;
    HCELL_INDEX             MatchSecurityCell;
    HCELL_INDEX             NewCell;
    HCELL_INDEX             OldCell;
    PCM_KEY_SECURITY        Security;
    PCM_KEY_SECURITY        NewSecurity;
    PCM_KEY_SECURITY        FlinkSecurity;
    PCM_KEY_SECURITY        BlinkSecurity;
    PCM_KEY_NODE            Node;
    ULONG                   DescriptorLength;
    PSECURITY_DESCRIPTOR    DescriptorCopy;
    PSECURITY_DESCRIPTOR    OldDescriptorCopy;
    ULONG                   Type;
    LARGE_INTEGER           SystemTime;
    PHHIVE                  Hive;
    PCM_KEY_SECURITY_CACHE  CachedSecurity;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpSetSecurityDescriptorInfo:\n"));

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    Node = (PCM_KEY_NODE)HvGetCell(Key->KeyHive, Key->KeyCell);
    if( Node == NULL ) {
        //
        // we couldn't map the bin containing this cell;
        // this shouldn't happen as we are about to modify the cell
        // (i.e. it should be dirty/pinned by this time)
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Key->KeyHive, Key->KeyCell);

    //
    // Map in the hive cell for the security descriptor before we make
    // the call to SeSetSecurityDescriptorInfo.  This prevents us from
    // changing its security descriptor and then being unable to bring
    // the hive cell into memory for updating.
    //
    Security = CmpGetKeySecurity(Key->KeyHive,
                                 Node,
                                 &SecurityCell);
    if( Security == NULL ) {
        //
        // couldn't map view inside
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // SeSetSecurityDescriptorInfo takes a pointer to the original
    // descriptor. This pointer is not freed, but a new pointer will
    // be returned.
    //
    DescriptorCopy = &Security->Descriptor;
    Status = SeSetSecurityDescriptorInfo( NULL,
                                          SecurityInformation,
                                          ModificationDescriptor,
                                          &DescriptorCopy,
                                          PoolType,
                                          GenericMapping );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Set Security operation succeeded, so we update the security
    // descriptor in the hive.
    //
    DescriptorLength = RtlLengthSecurityDescriptor(DescriptorCopy);
    Type = HvGetCellType(Key->KeyCell);
    Hive = Key->KeyHive;

    if (! (HvMarkCellDirty(Hive, Key->KeyCell) &&
           HvMarkCellDirty(Hive, SecurityCell)))
    {
        ExFreePool(DescriptorCopy);
        return STATUS_NO_LOG_SPACE;
    }

    //
    // Try to find an existing security descriptor that we can share.
    //
    if (CmpFindMatchingDescriptorCell((PCMHIVE)Hive, DescriptorCopy, Type, &MatchSecurityCell,&CachedSecurity)) {
        //
        // A match was found.
        //
        if( MatchSecurityCell == SecurityCell ) {
            //
            // Whoops !!!; what we want to set is already here ! bail out
            // (office instalation does this !!!!)
            //
            ExFreePool(DescriptorCopy);

            //
            // Update the LastWriteTime of the key. Do we need to do that? ==> Ask John.
            //
#pragma message ("Dragos ==> John - Do we need to update the time even though nothing changed?")

            KeQuerySystemTime(&SystemTime);
            Node->LastWriteTime = SystemTime;
            // update the time in kcb too, to keep the cache in sync
            Key->KcbLastWriteTime = SystemTime;

            return STATUS_SUCCESS;
        } else {
            if (!HvMarkCellDirty(Hive, MatchSecurityCell)) {
                ExFreePool(DescriptorCopy);
                return(STATUS_NO_LOG_SPACE);
            }
            if (Security->ReferenceCount == 1) {
                //
                // No more references to the old security cell, so we can free it now.
                //
                if (! (HvMarkCellDirty(Hive, Security->Flink) &&
                       HvMarkCellDirty(Hive, Security->Blink))) {
                    ExFreePool(DescriptorCopy);
                    return(STATUS_NO_LOG_SPACE);
                }
                CmpRemoveSecurityCellList(Hive, SecurityCell);
                HvFreeCell(Hive, SecurityCell);
            } else {

                //
                // Just decrement the count on the old security cell
                //
                Security->ReferenceCount -= 1;
            }

            //
            // Set the node to point at the matching security cell.
            //
            Security = (PCM_KEY_SECURITY)HvGetCell(Hive, MatchSecurityCell);
            if( Security == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this should not happen as we just marked the cell dirty
                //
                ASSERT( FALSE );
                ExFreePool(DescriptorCopy);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            // release the cell right here as we are holding the reglock exclusive
            HvReleaseCell(Hive, MatchSecurityCell);

            Security->ReferenceCount += 1;
            Node->Security = MatchSecurityCell;
        }
    } else {

        //
        // No match was found, we need to create a new cell.
        //
        if (Security->ReferenceCount > 1) {

            //
            // We can't change the existing security cell, since it is shared
            // by multiple keys.  Allocate a new cell and decrement the existing
            // one's reference count.
            //
            NewCell = HvAllocateCell(Key->KeyHive,
                                     SECURITY_CELL_LENGTH(DescriptorCopy),
                                     Type,
                                     HCELL_NIL);
            if (NewCell == HCELL_NIL) {
                ExFreePool(DescriptorCopy);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }

            if (! HvMarkCellDirty(Key->KeyHive, Security->Flink)) {
                ExFreePool(DescriptorCopy);
                return STATUS_NO_LOG_SPACE;
            }

            Security->ReferenceCount -= 1;

            //
            // Map in the new cell and insert it into the linked list.
            //
            NewSecurity = (PCM_KEY_SECURITY) HvGetCell(Key->KeyHive, NewCell);
            if( NewSecurity == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                ExFreePool(DescriptorCopy);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            // release the cell right here as we are holding the reglock exclusive
            HvReleaseCell(Key->KeyHive, NewCell);

            NewSecurity->Blink = SecurityCell;
            NewSecurity->Flink = Security->Flink;
            FlinkSecurity = (PCM_KEY_SECURITY) HvGetCell(Key->KeyHive, Security->Flink);
            if( FlinkSecurity == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                ExFreePool(DescriptorCopy);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            // release the cell right here as we are holding the reglock exclusive
            HvReleaseCell(Key->KeyHive, Security->Flink);

            Security->Flink = FlinkSecurity->Blink = NewCell;

            //
            // initialize new cell
            //
            NewSecurity->Signature = CM_KEY_SECURITY_SIGNATURE;
            NewSecurity->ReferenceCount = 1;
            NewSecurity->DescriptorLength = DescriptorLength;
            Security=NewSecurity;

            //
            // copy the descriptor
            //
            RtlCopyMemory( &(Security->Descriptor),
                           DescriptorCopy,
                           DescriptorLength );

            //
            // Add the new created security cell to the cache
            //
            if( !NT_SUCCESS(CmpAddSecurityCellToCache( (PCMHIVE)Key->KeyHive,NewCell,FALSE)) ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated (marked dirty) the cell
                //
                ASSERT( FALSE );
                ExFreePool(DescriptorCopy);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Update the pointer in the node cell.
            //
            Node->Security = NewCell;

        } else {
            //
            // when this is FALSE, the new cell is ADDED to cache;
            // Otherwise (the cell index and size did not change), 
            // the new sd is copied over the one in cache
            //
            BOOLEAN UpdateCache;

            if (DescriptorLength != Security->DescriptorLength) {

                //
                // The security descriptor's size has changed, and it is not shared
                // by any other cells, so reallocate the cell.
                //
                if (! (HvMarkCellDirty(Key->KeyHive, Security->Flink) &&
                       HvMarkCellDirty(Key->KeyHive, Security->Blink))) {
                    ExFreePool(DescriptorCopy);
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }

                DCmCheckRegistry((PCMHIVE)(Key->KeyHive));
                OldCell = SecurityCell;
                SecurityCell = HvReallocateCell( Key->KeyHive,
                                                 SecurityCell,
                                                 SECURITY_CELL_LENGTH(DescriptorCopy) );
                if (SecurityCell == HCELL_NIL) {
                    ExFreePool(DescriptorCopy);
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }

                //
                // remove the old cell from security cache and signal that the new one should be added
                //
                CmpRemoveFromSecurityCache ((PCMHIVE)Key->KeyHive,OldCell);
                UpdateCache = FALSE;

                //
                // Update the Node's security data.
                //
                Node->Security = SecurityCell;

                //
                // Update Security to point to where the new security object is
                //
                Security = (PCM_KEY_SECURITY) HvGetCell(Key->KeyHive, SecurityCell);
                if( Security == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    // this shouldn't happen as we just allocated this cell
                    // (i.e. it should be pinned into memory at this point)
                    //
                    ASSERT( FALSE );
                    ExFreePool(DescriptorCopy);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                // release the cell right here as we are holding the reglock exclusive
                HvReleaseCell(Key->KeyHive, SecurityCell);

                ASSERT_SECURITY(Security);

                //
                // Update other list references to the node
                //
                if (Security->Flink == OldCell) {
                    Security->Flink = SecurityCell; // point to new self
                } else {
                    FlinkSecurity = (PCM_KEY_SECURITY) HvGetCell(
                                                            Key->KeyHive,
                                                            Security->Flink
                                                            );
                    if( FlinkSecurity == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        ExFreePool(DescriptorCopy);
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    // release the cell right here as we are holding the reglock exclusive
                    HvReleaseCell(Key->KeyHive, Security->Flink);

                    FlinkSecurity->Blink = SecurityCell;
                }

                if (Security->Blink == OldCell) {
                    Security->Blink = SecurityCell; // point to new self
                } else {
                    BlinkSecurity = (PCM_KEY_SECURITY) HvGetCell(
                                                            Key->KeyHive,
                                                            Security->Blink
                                                            );
                    if( BlinkSecurity == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        ExFreePool(DescriptorCopy);
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    // release the cell right here as we are holding the reglock exclusive
                    HvReleaseCell(Key->KeyHive,Security->Blink);

                    BlinkSecurity->Flink = SecurityCell;
                }

                //
                // Finally, update the length field in the cell
                //
                Security->DescriptorLength = DescriptorLength;
                DCmCheckRegistry((PCMHIVE)(Key->KeyHive));

            } else {

                //
                // Size hasn't changed, and it's not shared by any other cells, so
                // we can just write the new bits over the old bits.
                //

                //
                // new bits should be copied over the cached security 
                // descriptor too, to keep cache consistency
                //
                //
                // get the cached security structure for this security cell
                //
                ULONG Index;

                if( CmpFindSecurityCellCacheIndex ((PCMHIVE)Hive,SecurityCell,&Index) == FALSE ) {
                    //
                    // this cannot happen !!!
                    //
                    CM_BUGCHECK( REGISTRY_ERROR,BAD_SECURITY_CACHE,2,Key,SecurityCell);
                } 
                CachedSecurity = ((PCMHIVE)Hive)->SecurityCache[Index].CachedSecurity;

                UpdateCache = TRUE;
            }

            RtlCopyMemory( &(Security->Descriptor),
                           DescriptorCopy,
                           DescriptorLength );

            if( UpdateCache == TRUE ) {
                //
                // we just need to copy the descriptor over the existing one
                // (keep the security cache in sync !!!)
                //
                RtlCopyMemory( &(CachedSecurity->Descriptor),
                                DescriptorCopy,
                                DescriptorLength );
                //
                // recalculate the conv key and insert the sd in the proper place in the hash
                //
                CmpRemoveEntryList(&(CachedSecurity->List));
                CachedSecurity->ConvKey = CmpSecConvKey(DescriptorLength,(PULONG)(DescriptorCopy));
                InsertTailList( &(((PCMHIVE)Hive)->SecurityHash[CachedSecurity->ConvKey % CmpSecHashTableSize]),
                                &(CachedSecurity->List)
                              );

            
            } else {
                //
                // add new cell to the security cache
                //
                if( !NT_SUCCESS(CmpAddSecurityCellToCache( (PCMHIVE)Hive,SecurityCell,FALSE)) ) {
                    //
                    // we couldn't map the bin containing this cell
                    // this shouldn't happen as we just allocated (marked dirty) the cell
                    //
                    ASSERT( FALSE );
                    ExFreePool(DescriptorCopy);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }    
    }


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"\tObject's SD has been changed\n"));
    //CmpDumpSecurityDescriptor(DescriptorCopy, "NEW DESCRIPTOR\n");

    ExFreePool(DescriptorCopy);

    //
    // Update the LastWriteTime of the key.
    //
    KeQuerySystemTime(&SystemTime);
    Node->LastWriteTime = SystemTime;

    // update the time in kcb too, to keep the cache in sync
    Key->KcbLastWriteTime = SystemTime;

    //
    // Security has changed, update the cache.
    //
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    CmpAssignSecurityToKcb(Key,Node->Security);

    return(STATUS_SUCCESS);
}

NTSTATUS
CmpAssignSecurityDescriptor(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PCM_KEY_NODE Node,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine assigns the given security descriptor to the specified
    node in the configuration tree.

Arguments:

    Hive - Supplies a pointer to the Hive for the node whose security
           descriptor will be assigned.

    Cell - Supplies the HCELL_INDEX of the node whose security descriptor
           will be assigned.

    Node - Supplies a pointer to the node whose security descriptor will
           be assigned.

    SecurityDescriptor - Supplies a pointer to the security descriptor to
           be assigned to the node.

    PoolType - Supplies the type of pool the SecurityDescriptor was a
           allocated from.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error value
        otherwise

--*/

{
    HCELL_INDEX SecurityCell;
    PCM_KEY_SECURITY Security;
    ULONG DescriptorLength;
    ULONG Type;

    PAGED_CODE();
    //
    // Map the node that we need to assign the security descriptor to.
    //
    if (! HvMarkCellDirty(Hive, Cell)) {
        return STATUS_NO_LOG_SPACE;
    }
    ASSERT_NODE(Node);

    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

#if DBG
    {
        UNICODE_STRING Name;

        Name.MaximumLength = Name.Length = Node->NameLength;
        Name.Buffer = Node->Name;
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpAssignSecurityDescriptor: '%wZ' (H %p C %lx)\n",&Name,Hive,Cell ));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"\tSecurityCell = %lx\n",Node->Security));
    }
#endif

    ASSERT(Node->Security==HCELL_NIL);

    //
    // This is a CreateKey, so the registry node has just been created and
    // the security descriptor we have been passed needs to be associated
    // with the new registry node and inserted into the hive.
    //
    //CmpDumpSecurityDescriptor(SecurityDescriptor, "ASSIGN DESCRIPTOR\n");

    //
    // Try to find an existing security descriptor that matches this one.
    // If successful, then we don't need to allocate a new cell, we can
    // just point to the existing one and increment its reference count.
    //
    Type = HvGetCellType(Cell);
    if (!CmpFindMatchingDescriptorCell( (PCMHIVE)Hive,
                                        SecurityDescriptor,
                                        Type,
                                        &SecurityCell,
                                        NULL)) {
        //
        // No matching descriptor found, allocate and initialize a new one.
        //
        SecurityCell = HvAllocateCell(Hive,
                                      SECURITY_CELL_LENGTH(SecurityDescriptor),
                                      Type,
                                      HCELL_NIL);
        if (SecurityCell == HCELL_NIL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Map the security cell
        //
        Security = (PCM_KEY_SECURITY) HvGetCell(Hive, SecurityCell);
        if( Security == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just allocated this cell
            // (i.e. it should be PINNED into memory at this point)
            //
            ASSERT( FALSE );
            HvFreeCell(Hive, SecurityCell);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive, SecurityCell);

        //
        // Initialize the security cell
        //
        DescriptorLength = RtlLengthSecurityDescriptor(SecurityDescriptor);

        Security->Signature = CM_KEY_SECURITY_SIGNATURE;
        Security->ReferenceCount = 1;
        Security->DescriptorLength = DescriptorLength;
        RtlCopyMemory( &(Security->Descriptor),
                       SecurityDescriptor,
                       DescriptorLength );

        //
        // Insert the new security descriptor into the list of security
        // cells; takes care of cache too
        //
        if (!CmpInsertSecurityCellList(Hive,Cell,SecurityCell))
        {
            HvFreeCell(Hive, SecurityCell);
            return STATUS_NO_LOG_SPACE;
        }

    } else {

        //
        // Found identical descriptor already existing.  Map it in and
        // increment its reference count.
        //
        if (! HvMarkCellDirty(Hive, SecurityCell)) {
            return STATUS_NO_LOG_SPACE;
        }
        Security = (PCM_KEY_SECURITY) HvGetCell(Hive, SecurityCell);
        if( Security == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just marked the cell dirty
            // (dirty means PIN !)
            //
            ASSERT( FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive, SecurityCell);

        Security->ReferenceCount += 1;
    }

    //
    // Initialize the reference in the node cell
    //
    Node->Security = SecurityCell;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"\tSecurityCell = %lx\n",Node->Security));

    return(STATUS_SUCCESS);
}


NTSTATUS
CmpQuerySecurityDescriptorInfo(
    IN PCM_KEY_CONTROL_BLOCK kcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    )

/*++

Routine Description:

    This routine will extract the desired information from the
    passed security descriptor and return the information in
    the passed buffer as a security descriptor in absolute format.

Arguments:

    Key - Supplies a pointer to the CM_KEY_REFERENCE for the node whose
        security descriptor will be deleted.

    SecurityInformation - Specifies what information is being queried.

    SecurityDescriptor - Supplies the buffer to output the requested
        information into.

        This buffer has been probed only to the size indicated by
        the Length parameter.  Since it still points into user space,
        it must always be accessed in a try clause.

    Length - Supplies the address of a variable containing the length of
        the security descriptor buffer.  Upon return this variable will
        contain the length needed to store the requested information.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor.  The passed security descriptor
        must be in self-relative format.


Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error value
        otherwise

Note:
    
      In the new implementation this function looks just in the security cache

--*/

{
    NTSTATUS                Status;
    PSECURITY_DESCRIPTOR    CellSecurityDescriptor;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpQuerySecurityDescriptorInfo:\n"));



    CellSecurityDescriptor = &(kcb->CachedSecurity->Descriptor);

    Status = SeQuerySecurityDescriptorInfo( SecurityInformation,
                                            SecurityDescriptor,
                                            Length,
                                            &CellSecurityDescriptor );

    return Status;
}


BOOLEAN
CmpCheckCreateAccess(
    IN PUNICODE_STRING RelativeName,
    IN PSECURITY_DESCRIPTOR Descriptor,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE PreviousMode,
    IN ACCESS_MASK AdditionalAccess,
    OUT PNTSTATUS AccessStatus
    )

/*++

Routine Description:

    This routine checks to see if we are allowed to create a sub-key in the
    given key, and performs auditing as appropriate.

Arguments:

    RelativeName - Supplies the relative name of the key being created.

    Descriptor - Supplies the security descriptor of the key in which
        the sub-key is to be created.

    CreateAccess - The access mask corresponding to create access for
        this directory type.

    AccessState - Checks for traverse access will typically be incidental
        to some other access attempt.  Information on the current state of
        that access attempt is required so that the constituent access
        attempts may be associated with each other in the audit log.

    PreviousMode - The previous processor mode.

    AdditionalAccess - access rights in addition to KEY_CREATE_SUB_KEY
            that are required.  (e.g. KEY_CREATE_LINK)

    AccessStatus - Pointer to a variable to return the status code of the
        access attempt.  In the case of failure this status code must be
        propagated back to the user.

Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise.  AccessStatus
    contains the status code to be passed back to the caller.  It is not
    correct to simply pass back STATUS_ACCESS_DENIED, since this will have
    to change with the advent of mandatory access control.

--*/

{
    BOOLEAN AccessAllowed;
    ACCESS_MASK GrantedAccess = 0;
    BOOLEAN AuditPerformed = FALSE;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpCheckCreateAccess:\n"));

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    AccessAllowed = SeAccessCheck(
                        Descriptor,
                        &AccessState->SubjectSecurityContext,
                        TRUE,                              // Token is read locked
                        (KEY_CREATE_SUB_KEY | AdditionalAccess),
                        0,
                        NULL,
                        &CmpKeyObjectType->TypeInfo.GenericMapping,
                        PreviousMode,
                        &GrantedAccess,
                        AccessStatus
                        );

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"Create access %s\n",AccessAllowed ? "granted" : "denied"));
/*
#if DBG
    if (!AccessAllowed) {
        CmpDumpSecurityDescriptor(Descriptor, "DENYING DESCRIPTOR");
    }
#endif
*/
    return(AccessAllowed);
}


BOOLEAN
CmpCheckNotifyAccess(
    IN PCM_NOTIFY_BLOCK NotifyBlock,
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Node
    )
/*++

Routine Description:

    Check whether the subject process/thread/user specified by the
    security data in the NotifyBlock has required access to the
    key specified by Hive.Cell.

Arguments:

    NotifyBlock - pointer to structure that describes the notify
                  operation, including the identity of the subject
                  that opened the notify.

    Hive - Supplies pointer to hive containing Node.

    Node - Supplies pointer to key of interest.

Return Value:

    TRUE if RequiredAccess is in fact possessed by the subject,
    else FALSE.

Note:

    In the new implementation get the sd from the security cache.

--*/
{
    PCM_KEY_SECURITY        Security;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    BOOLEAN                 AccessAllowed;
    NTSTATUS                Status;
    ACCESS_MASK             GrantedAccess = 0;
    ULONG                   Index;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpCheckAccessForNotify:\n"));

    if( CmpFindSecurityCellCacheIndex ((PCMHIVE)Hive,Node->Security,&Index) == FALSE ) {
        return FALSE;
    }


    SeLockSubjectContext( &NotifyBlock->SubjectContext );

    SecurityDescriptor = &(((PCMHIVE)Hive)->SecurityCache[Index].CachedSecurity->Descriptor);


    AccessAllowed = SeAccessCheck( SecurityDescriptor,
                                   &NotifyBlock->SubjectContext,
                                   TRUE,
                                   KEY_NOTIFY,
                                   0,
                                   NULL,
                                   &CmpKeyObjectType->TypeInfo.GenericMapping,
                                   UserMode,
                                   &GrantedAccess,
                                   &Status );

    SeUnlockSubjectContext( &NotifyBlock->SubjectContext );

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"Notify access %s\n",AccessAllowed ? "granted" : "denied"));
/*
#if DBG
    if (!AccessAllowed) {
        CmpDumpSecurityDescriptor(SecurityDescriptor, "DENYING DESCRIPTOR");
    }
#endif
*/
    return AccessAllowed;
}


NTSTATUS
CmpGetObjectSecurity(
    IN HCELL_INDEX Cell,
    IN PHHIVE Hive,
    OUT PCM_KEY_SECURITY *Security,
    OUT PHCELL_INDEX SecurityCell OPTIONAL
    )

/*++

Routine Description:

    This routine maps in the security cell of a registry object.

Arguments:

    Cell - Supplies the cell index of the object.

    Hive - Supplies the hive the object's cell is in.

    Security - Returns a pointer to the security cell of the object.

    SecurityCell - Returns the index of the security cell

Return Value:

    NTSTATUS.

--*/

{
    HCELL_INDEX CellIndex;
    PCM_KEY_NODE Node;

    PAGED_CODE();
    //
    // Map the node we need to get the security descriptor for
    //
    Node = (PCM_KEY_NODE) HvGetCell(Hive, Cell);

    if( Node == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    {
        UNICODE_STRING Name;

        Name.MaximumLength = Name.Length = Node->NameLength;
        Name.Buffer = Node->Name;
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpGetObjectSecurity for: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"%wZ\n", &Name));
    }
#endif

    *Security = CmpGetKeySecurity(Hive,Node,SecurityCell);

    HvReleaseCell(Hive, Cell);

    if( *Security == NULL ) {
        //
        // couldn't map view inside
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}

PCM_KEY_SECURITY
CmpGetKeySecurity(
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Key,
    OUT PHCELL_INDEX SecurityCell OPTIONAL
    )

/*++

Routine Description:

    This routine returns the security of a registry key.

Arguments:

    Hive - Supplies the hive the object's cell is in.

    Key - Supplies a pointer to the key node.

    SecurityCell - Returns the index of the security cell

Return Value:

    Returns a pointer to the security cell of the object
    
    NULL, if resources problem
--*/

{
    HCELL_INDEX CellIndex;
    PCM_KEY_SECURITY Security;

    PAGED_CODE();

    ASSERT(Key->Signature == CM_KEY_NODE_SIGNATURE);
    ASSERT_NODE(Key);

#if DBG
    {
        UNICODE_STRING Name;

        Name.MaximumLength = Name.Length = Key->NameLength;
        Name.Buffer = Key->Name;
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpGetObjectSecurity for: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"%wZ\n", &Name));
    }
#endif

    CellIndex = Key->Security;

    //
    // Map in the security descriptor cell
    //
    Security = (PCM_KEY_SECURITY) HvGetCell(Hive, CellIndex);
    if( Security == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return NULL;
    }
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    HvReleaseCell(Hive, CellIndex);
    ASSERT_SECURITY(Security);

    if (ARGUMENT_PRESENT(SecurityCell)) {
        *SecurityCell = CellIndex;
    }

    return(Security);
}

PSECURITY_DESCRIPTOR
CmpHiveRootSecurityDescriptor(
    VOID
    )
/*++

Routine Description:

    This routine allocates and initializes the default security descriptor
    for a system-created registry key.

    The caller is responsible for freeing the allocated security descriptor
    when he is done with it.

Arguments:

    None

Return Value:

    Pointer to an initialized security descriptor if successful.

    Bugcheck otherwise.

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SecurityDescriptor=NULL;
    PACL Acl=NULL;
    PACL AclCopy;
    PSID WorldSid=NULL;
    PSID RestrictedSid=NULL;
    PSID SystemSid=NULL;
    PSID AdminSid=NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG AceLength;
    ULONG AclLength;
    PACE_HEADER AceHeader;

    PAGED_CODE();

    //
    // Allocate and initialize the SIDs we will need.
    //
    WorldSid  = ExAllocatePool(PagedPool, RtlLengthRequiredSid(1));
    RestrictedSid  = ExAllocatePool(PagedPool, RtlLengthRequiredSid(1));
    SystemSid = ExAllocatePool(PagedPool, RtlLengthRequiredSid(1));
    AdminSid  = ExAllocatePool(PagedPool, RtlLengthRequiredSid(2));
    if ((WorldSid  == NULL) ||
        (RestrictedSid == NULL) ||
        (SystemSid == NULL) ||
        (AdminSid  == NULL)) {

        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 1, 0, 0);
    }

    if ((!NT_SUCCESS(RtlInitializeSid(WorldSid, &WorldAuthority, 1))) ||
        (!NT_SUCCESS(RtlInitializeSid(RestrictedSid, &NtAuthority, 1))) ||
        (!NT_SUCCESS(RtlInitializeSid(SystemSid, &NtAuthority, 1))) ||
        (!NT_SUCCESS(RtlInitializeSid(AdminSid, &NtAuthority, 2)))) {
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 2, 0, 0);
    }

    *(RtlSubAuthoritySid(WorldSid, 0)) = SECURITY_WORLD_RID;

    *(RtlSubAuthoritySid(RestrictedSid, 0)) = SECURITY_RESTRICTED_CODE_RID;

    *(RtlSubAuthoritySid(SystemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;

    *(RtlSubAuthoritySid(AdminSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid(AdminSid, 1)) = DOMAIN_ALIAS_RID_ADMINS;

    ASSERT(RtlValidSid(WorldSid));
    ASSERT(RtlValidSid(RestrictedSid));
    ASSERT(RtlValidSid(SystemSid));
    ASSERT(RtlValidSid(AdminSid));

    //
    // Compute the size of the ACE list
    //

    AceLength = (SeLengthSid(WorldSid)  -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE))
              + (SeLengthSid(RestrictedSid)  -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE))
              + (SeLengthSid(SystemSid) -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE))
              + (SeLengthSid(AdminSid)  -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE));

    //
    // Allocate and initialize the ACL
    //

    AclLength = AceLength + sizeof(ACL);
    Acl = ExAllocatePool(PagedPool, AclLength);
    if (Acl == NULL) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: couldn't allocate ACL\n"));

        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 3, 0, 0);
    }

    Status = RtlCreateAcl(Acl, AclLength, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: couldn't initialize ACL\n"));
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 4, Status, 0);
    }

    //
    // Now add the ACEs to the ACL
    //
    Status = RtlAddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    KEY_ALL_ACCESS,
                                    SystemSid);
    if (NT_SUCCESS(Status)) {
        Status = RtlAddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        KEY_ALL_ACCESS,
                                        AdminSid);
    }
    if (NT_SUCCESS(Status)) {
        Status = RtlAddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        KEY_READ,
                                        WorldSid);
    }
    if (NT_SUCCESS(Status)) {
        Status = RtlAddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        KEY_READ,
                                        RestrictedSid);
    }
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: RtlAddAce failed status %08lx\n", Status));

        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 5, Status, 0);
    }

    //
    // Make the ACEs inheritable
    //
    Status = RtlGetAce(Acl,0,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;

    Status = RtlGetAce(Acl,1,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;

    Status = RtlGetAce(Acl,2,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;

    Status = RtlGetAce(Acl,3,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;
    //
    // We are finally ready to allocate and initialize the security descriptor
    // Allocate enough space to hold both the security descriptor and the
    // ACL.  This allows us to free the whole thing at once when we are
    // done with it.
    //

    SecurityDescriptor = ExAllocatePool(
                            PagedPool,
                            sizeof(SECURITY_DESCRIPTOR) + AclLength
                            );

    if (SecurityDescriptor == NULL) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: Couldn't allocate Sec. Desc.\n"));
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 6, 0, 0);
    }

    AclCopy = (PACL)((PISECURITY_DESCRIPTOR)SecurityDescriptor+1);
    RtlCopyMemory(AclCopy, Acl, AclLength);

    Status = RtlCreateSecurityDescriptor( SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION );
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: CreateSecDesc failed %08lx\n",Status));
        ExFreePool(SecurityDescriptor);
        SecurityDescriptor=NULL;
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 7, Status, 0);
    }

    Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                           TRUE,
                                           AclCopy,
                                           FALSE );
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: SetDacl failed %08lx\n",Status));
        ExFreePool(SecurityDescriptor);
        SecurityDescriptor=NULL;
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 8, Status, 0);
    }

    //
    // free any allocations we made
    //
    if (WorldSid!=NULL) {
        ExFreePool(WorldSid);
    }
    if (RestrictedSid!=NULL) {
        ExFreePool(RestrictedSid);
    }
    if (SystemSid!=NULL) {
        ExFreePool(SystemSid);
    }
    if (AdminSid!=NULL) {
        ExFreePool(AdminSid);
    }
    if (Acl!=NULL) {
        ExFreePool(Acl);
    }

    return(SecurityDescriptor);
}

VOID
CmpFreeSecurityDescriptor(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )

/*++

Routine Description:

    Frees the security descriptor associated with a particular node.  This
    can only happen when the node is actually being deleted from the
    registry.

    NOTE:   Caller is expected to have already marked relevent cells dirty.

Arguments:

    Hive - Supplies thepointer to hive control structure for hive of interest

    Cell - Supplies index for cell to free storage for (the target)

Return Value:

    None.

--*/

{
    PCELL_DATA Node;
    PCELL_DATA Security;
    HCELL_INDEX SecurityCell;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpFreeSecurityDescriptor for cell %ld\n",Cell));

    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);
    //
    // Map in the cell whose security descriptor is being freed
    //
    Node = HvGetCell(Hive, Cell);
    if( Node == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // Sorry, we cannot free the descriptor
        return;
    }

    ASSERT_NODE(&(Node->u.KeyNode));

    //
    // Map in the cell containing the security descriptor.
    //
    SecurityCell = Node->u.KeyNode.Security;
    Security = HvGetCell(Hive, SecurityCell);
    if( Security == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // Sorry, we cannot free the descriptor
        HvReleaseCell(Hive, Cell);
        return;
    }

    ASSERT_SECURITY(&(Security->u.KeySecurity));


    if (Security->u.KeySecurity.ReferenceCount == 1) {

        //
        // This is the only cell that references this security descriptor,
        // so it is ok to free it now.
        //
        CmpRemoveSecurityCellList(Hive, SecurityCell);
        HvFreeCell(Hive, SecurityCell);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpFreeSecurityDescriptor: freeing security cell\n"));
    } else {

        //
        // More than one node references this security descriptor, so
        // just decrement the reference count.
        //
        Security->u.KeySecurity.ReferenceCount -= 1;
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpFreeSecurityDescriptor: decrementing reference count\n"));
    }

    //
    // Zero out the pointer to the security descriptdr in the main cell
    //
    Node->u.KeyNode.Security = HCELL_NIL;
    // release the cells
    HvReleaseCell(Hive, Cell);
    HvReleaseCell(Hive, SecurityCell);
}

BOOLEAN
CmpInsertSecurityCellList(
    IN PHHIVE Hive,
    IN HCELL_INDEX NodeCell,
    IN HCELL_INDEX SecurityCell
    )
/*++

Routine Description:

    Inserts a newly-created security cell into the per-hive linked list of
    security cells.

    NOTE:   Assumes that NodeCell and SecurityCell have already been
            marked dirty.

Arguments:

    Hive - Supplies a pointer to the hive control structure.

    NodeCell - Supplies the cell index of the node that owns the security cell

    SecurityCell - Supplies the cell index of the security cell.

Return Value:

    TRUE - it worked

    FALSE - some failure - generally STATUS_NO_LOG_SPACE

--*/

{
    PCM_KEY_SECURITY    FlinkCell;
    PCM_KEY_SECURITY    BlinkCell;
    PCM_KEY_SECURITY    Cell;
    PCM_KEY_NODE        Node;
    PCM_KEY_NODE        ParentNode;

    PAGED_CODE();
    //
    // If the new cell's storage type is Volatile, simply make it the
    //  anchor of it's own list.  (Volatile security entries will disappear
    //  at reboot, restore, etc, so we don't need the list to hunt them
    //  down at those times.)
    //
    // Else, the storage type is Stable.
    //   Map in the node that owns the new security cell.  If it is a root
    //   cell, then we are creating the hive for the first time, so this is
    //   the only security cell in the list.  If it is not a root cell, then
    //   we simply find its parent's security cell and stick the new security
    //   cell into the list immediately after it.
    //
    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    Cell = (PCM_KEY_SECURITY) HvGetCell(Hive, SecurityCell);
    if( Cell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // 
        return FALSE;
    }

    // release the cell as we hold the reglock exclusive
    HvReleaseCell(Hive, SecurityCell);

    ASSERT_SECURITY(Cell);

    if (HvGetCellType(SecurityCell) == Volatile) {

        Cell->Flink = Cell->Blink = SecurityCell;

    } else {

        Node = (PCM_KEY_NODE) HvGetCell(Hive, NodeCell);
        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // 
            return FALSE;
        }

        // release the cell as we hold the reglock exclusive
        HvReleaseCell(Hive, NodeCell);

        ASSERT_NODE(Node);

        if (Node->Flags & KEY_HIVE_ENTRY) {
            //
            // This must be the hive creation, so this cell becomes the anchor
            // for the list.
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpInsertSecurityCellList: hive creation\n"));
            Cell->Flink = Cell->Blink = SecurityCell;

        } else {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpInsertSecurityCellList: insert at parent\n"));
            //
            // Map in the node's parent's security cell, so we can hook into
            // the list there.
            //
            ParentNode = (PCM_KEY_NODE) HvGetCell(Hive, Node->Parent);
            if( ParentNode == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // 
                return FALSE;
            }
            // release the cell as we hold the reglock exclusive
            HvReleaseCell(Hive, Node->Parent);

            ASSERT_NODE(ParentNode);
            BlinkCell = (PCM_KEY_SECURITY) HvGetCell(
                                            Hive,
                                            ParentNode->Security
                                            );
            if( BlinkCell == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // 
                return FALSE;
            }
            // release the cell as we hold the reglock exclusive
            HvReleaseCell(Hive, ParentNode->Security);

            ASSERT_SECURITY(BlinkCell);

            //
            // Map in the Flink of the parent's security cell.
            //
            FlinkCell = (PCM_KEY_SECURITY) HvGetCell(
                                            Hive,
                                            BlinkCell->Flink
                                            );
            if( FlinkCell == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // 
                return FALSE;
            }
            // release the cell as we hold the reglock exclusive
            HvReleaseCell(Hive, BlinkCell->Flink);

            ASSERT_SECURITY(FlinkCell);

            if (! (HvMarkCellDirty(Hive, ParentNode->Security) &&
                   HvMarkCellDirty(Hive, BlinkCell->Flink)))
            {
                return FALSE;
            }

            //
            // Insert the new security cell in between the Flink and Blink cells
            //
            Cell->Flink = BlinkCell->Flink;
            Cell->Blink = FlinkCell->Blink;
            BlinkCell->Flink = SecurityCell;
            FlinkCell->Blink = SecurityCell;
        }
    }

    //
    // add the new security cell to the hive's security cache
    //
    if( !NT_SUCCESS( CmpAddSecurityCellToCache ( (PCMHIVE)Hive,SecurityCell,FALSE) ) ) {
        return FALSE;
    }

    return TRUE;
}


VOID
CmpRemoveSecurityCellList(
    IN PHHIVE Hive,
    IN HCELL_INDEX SecurityCell
    )
/*++

Routine Description:

    Removes a security cell from the per-hive linked list of security cells.
    (This means the cell is going to be deleted!)

    NOTE:   Caller is expected to have already marked relevent cells dirty

Arguments:

    Hive - Supplies a pointer to the hive control structure

    SecurityCell - Supplies the cell index of the security cell to be
           removed

Return Value:

    None.

--*/

{
    PCM_KEY_SECURITY FlinkCell;
    PCM_KEY_SECURITY BlinkCell;
    PCM_KEY_SECURITY Cell;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpRemoveSecurityCellList: index %ld\n",SecurityCell));

    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    Cell = (PCM_KEY_SECURITY) HvGetCell(Hive, SecurityCell);
    if( Cell == NULL ) {
        //
        // we couldn't map the bin containing one of these cells
        // 
        return;
    }

    FlinkCell = (PCM_KEY_SECURITY) HvGetCell(Hive, Cell->Flink);
    if( FlinkCell == NULL ) {
        //
        // we couldn't map the bin containing one of these cells
        // 
        HvReleaseCell(Hive, SecurityCell);
        return;
    }

    BlinkCell = (PCM_KEY_SECURITY) HvGetCell(Hive, Cell->Blink);
    if( BlinkCell == NULL ) {
        //
        // we couldn't map the bin containing one of these cells
        // 
        HvReleaseCell(Hive, SecurityCell);
        HvReleaseCell(Hive, Cell->Flink);
        return;
    }

    ASSERT(FlinkCell->Blink == SecurityCell);
    ASSERT(BlinkCell->Flink == SecurityCell);

    FlinkCell->Blink = Cell->Blink;
    BlinkCell->Flink = Cell->Flink;

    //
    // finally, remove the security cell from cache, as it'll be freed
    //
    CmpRemoveFromSecurityCache ( (PCMHIVE)Hive,SecurityCell);

    //
    // release used cells
    //
    HvReleaseCell(Hive, Cell->Blink);
    HvReleaseCell(Hive, Cell->Flink);
    HvReleaseCell(Hive, SecurityCell);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmsubs3.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmsubs3.c

Abstract:

    This module contains locking support routines for the configuration manager.

Author:

    Bryan M. Willman (bryanwi) 30-Mar-1992

Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpLockRegistry)
#pragma alloc_text(PAGE,CmpLockRegistryExclusive)
#pragma alloc_text(PAGE,CmpLockKCBTree)
#pragma alloc_text(PAGE,CmpLockKCBTreeExclusive)
#pragma alloc_text(PAGE,CmpUnlockRegistry)
#pragma alloc_text(PAGE,CmpUnlockKCBTree)

#if DBG
#pragma alloc_text(PAGE,CmpTestRegistryLock)
#pragma alloc_text(PAGE,CmpTestRegistryLockExclusive)
#pragma alloc_text(PAGE,CmpTestKCBLock)
#pragma alloc_text(PAGE,CmpTestKCBLockExclusive)
#endif

#endif


//
// Global registry lock
//

ERESOURCE   CmpRegistryLock;
ERESOURCE   CmpKcbLock;
ULONG       CmpFlushStarveWriters = 0;
BOOLEAN     CmpFlushOnLockRelease = FALSE;
LONG        CmRegistryLogSizeLimit = -1;


#if DBG
PVOID       CmpRegistryLockCaller;
PVOID       CmpRegistryLockCallerCaller;
PVOID       CmpKCBLockCaller;
PVOID       CmpKCBLockCallerCaller;
#endif //DBG

extern BOOLEAN CmpSpecialBootCondition;

VOID
CmpLockRegistry(
    VOID
    )
/*++

Routine Description:

    Lock the registry for shared (read-only) access

Arguments:

    None.

Return Value:

    None, the registry lock will be held for shared access upon return.

--*/
{
#if DBG
    PVOID       Caller;
    PVOID       CallerCaller;
#endif

    KeEnterCriticalRegion();

    if( CmpFlushStarveWriters ) {
        //
        // a flush is in progress; starve potential writers
        //
        ExAcquireSharedStarveExclusive(&CmpRegistryLock, TRUE);
    } else {
        //
        // regular shared mode
        //
        ExAcquireResourceSharedLite(&CmpRegistryLock, TRUE);
    }

#if DBG
    RtlGetCallersAddress(&Caller, &CallerCaller);
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_LOCKING,"CmpLockRegistry: c, cc: %p  %p\n", Caller, CallerCaller));
#endif

}

VOID
CmpLockRegistryExclusive(
    VOID
    )
/*++

Routine Description:

    Lock the registry for exclusive (write) access.

Arguments:

    None.

Return Value:

    TRUE - Lock was acquired exclusively

    FALSE - Lock is owned by another thread.

--*/
{
    KeEnterCriticalRegion();
    
    ExAcquireResourceExclusiveLite(&CmpRegistryLock,TRUE);

    ASSERT( CmpFlushStarveWriters == 0 );

#if DBG
    RtlGetCallersAddress(&CmpRegistryLockCaller, &CmpRegistryLockCallerCaller);
#endif //DBG
}

VOID
CmpUnlockRegistry(
    )
/*++

Routine Description:

    Unlock the registry.

--*/
{
    ASSERT_CM_LOCK_OWNED();

    //
    // test if bit set to force flush; and we own the reglock exclusive and ownercount is 1
    //
    if( CmpFlushOnLockRelease && ExIsResourceAcquiredExclusiveLite(&CmpRegistryLock) && (CmpRegistryLock.OwnerThreads[0].OwnerCount == 1) ) {
        //
        // we need to flush now
        //
        ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
        CmpDoFlushAll(TRUE);
        CmpFlushOnLockRelease = FALSE;
    }
    
    ExReleaseResourceLite(&CmpRegistryLock);
    KeLeaveCriticalRegion();
}


#if DBG

BOOLEAN
CmpTestRegistryLock(VOID)
{
    BOOLEAN rc;

    rc = TRUE;
    if (ExIsResourceAcquiredShared(&CmpRegistryLock) == 0) {
        rc = FALSE;
    }
    return rc;
}

BOOLEAN
CmpTestRegistryLockExclusive(VOID)
{
    if (ExIsResourceAcquiredExclusiveLite(&CmpRegistryLock) == 0) {
        return(FALSE);
    }
    return(TRUE);
}

#endif


VOID
CmpLockKCBTree(
    VOID
    )
/*++

Routine Description:

    Lock the KCB tree for shared (read-only) access

Arguments:

    None.

Return Value:

    None, the kcb lock will be held for shared access upon return.

--*/
{
#if DBG
    PVOID       Caller;
    PVOID       CallerCaller;
#endif

    //
    // we don't need to enter critical section here as we are already there 
    // (i.e. kcb lock can be aquired only while holding the registry lock)
    //
    ExAcquireResourceSharedLite(&CmpKcbLock, TRUE);

#if DBG
    RtlGetCallersAddress(&Caller, &CallerCaller);
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_LOCKING,"CmpLockKCBTree: c, cc: %p  %p\n", Caller, CallerCaller));
#endif

}

VOID
CmpLockKCBTreeExclusive(
    VOID
    )
/*++

Routine Description:

    Lock the KCB tree for exclusive (write) access.

Arguments:

    None.

Return Value:

    None, the kcb lock will be held for exclusive access upon return.

--*/
{
    //
    // we don't need to enter critical section here as we are already there 
    // (i.e. kcb lock can be aquired only while holding the registry lock)
    //
    ExAcquireResourceExclusiveLite(&CmpKcbLock,TRUE);
#if DBG
    RtlGetCallersAddress(&CmpKCBLockCaller, &CmpKCBLockCallerCaller);
#endif //DBG
}

VOID
CmpUnlockKCBTree(
    )
/*++

Routine Description:

    Unlock the KCB_TREE.

--*/
{
    ASSERT_KCB_LOCK_OWNED();
    ExReleaseResourceLite(&CmpKcbLock);
}


#if DBG

BOOLEAN
CmpTestKCBLock(VOID)
{
    BOOLEAN rc;

    rc = TRUE;
    if (ExIsResourceAcquiredShared(&CmpKcbLock) == 0) {
        rc = FALSE;
    }
    return rc;
}

BOOLEAN
CmpTestKCBLockExclusive(VOID)
{
    if (ExIsResourceAcquiredExclusiveLite(&CmpKcbLock) == 0) {
        return(FALSE);
    }
    return(TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmsubs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmsubs.c

Abstract:

    This module various support routines for the configuration manager.

    The routines in this module are not independent enough to be linked
    into any other program.  The routines in cmsubs2.c are.

Author:

    Bryan M. Willman (bryanwi) 12-Sep-1991

Revision History:

--*/

#include    "cmp.h"

FAST_MUTEX CmpPostLock;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

extern ULONG CmpDelayedCloseSize; 
extern BOOLEAN CmpHoldLazyFlush;


PCM_KEY_HASH *CmpCacheTable = NULL;
ULONG CmpHashTableSize = 2048;
PCM_NAME_HASH *CmpNameCacheTable = NULL;

#ifdef CMP_STATS
extern struct {
    ULONG       CmpMaxKcbNo;
    ULONG       CmpKcbNo;
    ULONG       CmpStatNo;
    ULONG       CmpNtCreateKeyNo;
    ULONG       CmpNtDeleteKeyNo;
    ULONG       CmpNtDeleteValueKeyNo;
    ULONG       CmpNtEnumerateKeyNo;
    ULONG       CmpNtEnumerateValueKeyNo;
    ULONG       CmpNtFlushKeyNo;
    ULONG       CmpNtNotifyChangeMultipleKeysNo;
    ULONG       CmpNtOpenKeyNo;
    ULONG       CmpNtQueryKeyNo;
    ULONG       CmpNtQueryValueKeyNo;
    ULONG       CmpNtQueryMultipleValueKeyNo;
    ULONG       CmpNtRestoreKeyNo;
    ULONG       CmpNtSaveKeyNo;
    ULONG       CmpNtSaveMergedKeysNo;
    ULONG       CmpNtSetValueKeyNo;
    ULONG       CmpNtLoadKeyNo;
    ULONG       CmpNtUnloadKeyNo;
    ULONG       CmpNtSetInformationKeyNo;
    ULONG       CmpNtReplaceKeyNo;
    ULONG       CmpNtQueryOpenSubKeysNo;
} CmpStatsDebug;
#endif

VOID
CmpRemoveKeyHash(
    IN PCM_KEY_HASH KeyHash
    );

PCM_KEY_CONTROL_BLOCK
CmpInsertKeyHash(
    IN PCM_KEY_HASH KeyHash,
    IN BOOLEAN      FakeKey
    );

//
// private prototype for recursive worker
//


VOID
CmpDereferenceNameControlBlockWithLock(
    PCM_NAME_CONTROL_BLOCK   Ncb
    );

VOID
CmpDumpKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK   kcb,
    IN PULONG                  Count
    );

#ifdef NT_RENAME_KEY
ULONG
CmpComputeKcbConvKey(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );

BOOLEAN
CmpRehashKcbSubtree(
                    PCM_KEY_CONTROL_BLOCK   Start,
                    PCM_KEY_CONTROL_BLOCK   End
                    );
#endif //NT_RENAME_KEY

VOID
CmpRebuildKcbCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpCleanUpKCBCacheTable)
#pragma alloc_text(PAGE,CmpSearchForOpenSubKeys)
#pragma alloc_text(PAGE,CmpReferenceKeyControlBlock)
#pragma alloc_text(PAGE,CmpGetNameControlBlock)
#pragma alloc_text(PAGE,CmpDereferenceNameControlBlockWithLock)
#pragma alloc_text(PAGE,CmpCleanUpSubKeyInfo)
#pragma alloc_text(PAGE,CmpCleanUpKcbValueCache)
#pragma alloc_text(PAGE,CmpCleanUpKcbCacheWithLock)
#pragma alloc_text(PAGE,CmpConstructName)
#pragma alloc_text(PAGE,CmpCreateKeyControlBlock)
#pragma alloc_text(PAGE,CmpSearchKeyControlBlockTree)
#pragma alloc_text(PAGE,CmpDereferenceKeyControlBlock)
#pragma alloc_text(PAGE,CmpDereferenceKeyControlBlockWithLock)
#pragma alloc_text(PAGE,CmpRemoveKeyControlBlock)
#pragma alloc_text(PAGE,CmpFreeKeyBody)
#pragma alloc_text(PAGE,CmpInsertKeyHash)
#pragma alloc_text(PAGE,CmpRemoveKeyHash)
#pragma alloc_text(PAGE,CmpInitializeCache)
#pragma alloc_text(PAGE,CmpDumpKeyBodyList)
#pragma alloc_text(PAGE,CmpFlushNotifiesOnKeyBodyList)
#pragma alloc_text(PAGE,CmpRebuildKcbCache)

#ifdef NT_RENAME_KEY
#pragma alloc_text(PAGE,CmpComputeKcbConvKey)
#pragma alloc_text(PAGE,CmpRehashKcbSubtree)
#endif //NT_RENAME_KEY

#ifdef CM_CHECK_FOR_ORPHANED_KCBS
#pragma alloc_text(PAGE,CmpCheckForOrphanedKcbs)
#endif //CM_CHECK_FOR_ORPHANED_KCBS

#endif

VOID
CmpDumpKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK   kcb,
    IN PULONG                  Count
    )
{
        
    PCM_KEY_BODY    KeyBody;
    PUNICODE_STRING Name;

    if( IsListEmpty(&(kcb->KeyBodyListHead)) == TRUE ) {
        //
        // Nobody has this subkey open, but for sure some subkey must be 
        // open. nicely return.
        //
        return;
    }


    Name = CmpConstructName(kcb);
    if( !Name ){
        // oops, we're low on resources
        return;
    }
    
    //
    // now iterate through the list of KEY_BODYs referencing this kcb
    //
    KeyBody = (PCM_KEY_BODY)kcb->KeyBodyListHead.Flink;
    while( KeyBody != (PCM_KEY_BODY)(&(kcb->KeyBodyListHead)) ) {
        KeyBody = CONTAINING_RECORD(KeyBody,
                                    CM_KEY_BODY,
                                    KeyBodyList);
        //
        // sanity check: this should be a KEY_BODY
        //
        ASSERT_KEY_OBJECT(KeyBody);
        
        //
        // dump it's name and owning process
        //
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Process %p (KCB = %p) :: Key %wZ \n",KeyBody->Process,kcb,Name);
#ifdef CM_LEAK_STACK_TRACES
        if( KeyBody->Callers != 0 ) {
            ULONG i;
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Callers Stack Trace : \n");
            for( i=0;i<KeyBody->Callers;i++) {
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\t CallerAddress[%lu] = %p \n",i,KeyBody->CallerAddress[i]);
            }
        }
#endif  //CM_LEAK_STACK_TRACES

#endif //_CM_LDR_
        
        // count it
        (*Count)++;
        
        KeyBody = (PCM_KEY_BODY)KeyBody->KeyBodyList.Flink;
    }

    ExFreePoolWithTag(Name, CM_NAME_TAG | PROTECTED_POOL);

}

VOID
CmpFlushNotifiesOnKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK   kcb
    )
{
    PCM_KEY_BODY    KeyBody;
    
    if( IsListEmpty(&(kcb->KeyBodyListHead)) == FALSE ) {
        //
        // now iterate through the list of KEY_BODYs referencing this kcb
        //
        KeyBody = (PCM_KEY_BODY)kcb->KeyBodyListHead.Flink;
        while( KeyBody != (PCM_KEY_BODY)(&(kcb->KeyBodyListHead)) ) {
            KeyBody = CONTAINING_RECORD(KeyBody,
                                        CM_KEY_BODY,
                                        KeyBodyList);
            //
            // sanity check: this should be a KEY_BODY
            //
            ASSERT_KEY_OBJECT(KeyBody);

            //
            // flush any notifies that might be set on it
            //
            CmpFlushNotify(KeyBody);

            KeyBody = (PCM_KEY_BODY)KeyBody->KeyBodyList.Flink;
        }
    }
}

VOID CmpCleanUpKCBCacheTable()
/*++
Routine Description:

	Kicks out of cache all kcbs with RefCount == 0

Arguments:


Return Value:

--*/
{
    ULONG					i;
    PCM_KEY_HASH			*Current;
    PCM_KEY_CONTROL_BLOCK	kcb;

	PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    for (i=0; i<CmpHashTableSize; i++) {
        Current = &CmpCacheTable[i];
        while (*Current) {
            kcb = CONTAINING_RECORD(*Current, CM_KEY_CONTROL_BLOCK, KeyHash);
            if (kcb->RefCount == 0) {
                //
                // This kcb is in DelayClose case, remove it.
                //
                CmpRemoveFromDelayedClose(kcb);
                CmpCleanUpKcbCacheWithLock(kcb);

                //
                // The HashTable is changed, start over in this index again.
                //
                Current = &CmpCacheTable[i];
                continue;
            }
            Current = &kcb->NextHash;
        }
    }

}

PERFINFO_REG_DUMP_CACHE()

ULONG
CmpSearchForOpenSubKeys(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock,
    SUBKEY_SEARCH_TYPE      SearchType
    )
/*++
Routine Description:

    This routine searches the KCB tree for any open handles to keys that
    are subkeys of the given key.

    It is used by CmRestoreKey to verify that the tree being restored to
    has no open handles.

Arguments:

    KeyControlBlock - Supplies the key control block for the key for which
        open subkeys are to be found.

    SearchType - the type of the search
        SearchIfExist - exits at the first open subkey found ==> returns 1 if any subkey is open
        
        SearchAndDeref - Forces the keys underneath the Key referenced KeyControlBlock to 
                be marked as not referenced (see the REG_FORCE_RESTORE flag in CmRestoreKey) 
                returns 1 if at least one deref was made
        
        SearchAndCount - Counts all open subkeys - returns the number of them

Return Value:

    TRUE  - open handles to subkeys of the given key exist

    FALSE - open handles to subkeys of the given key do not exist.
--*/
{
    ULONG i;
    PCM_KEY_HASH *Current;
    PCM_KEY_CONTROL_BLOCK kcb;
    PCM_KEY_CONTROL_BLOCK Realkcb;
    PCM_KEY_CONTROL_BLOCK Parent;
    ULONG    LevelDiff, l;
    ULONG   Count = 0;
    
    //
    // Registry lock should be held exclusively, so no need to KCB lock
    //
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();


    //
    // First, clean up all subkeys in the cache
    //
	CmpCleanUpKCBCacheTable();

    if (KeyControlBlock->RefCount == 1) {
        //
        // There is only one open handle, so there must be no open subkeys.
        //
        Count = 0;
    } else {
        //
        // Now search for an open subkey handle.
        //
        Count = 0;

        //
        // dump the root first if we were asked to do so.
        //
        if(SearchType == SearchAndCount) {
            CmpDumpKeyBodyList(KeyControlBlock,&Count);
        }

        for (i=0; i<CmpHashTableSize; i++) {

StartDeref:

            Current = &CmpCacheTable[i];
            while (*Current) {
                kcb = CONTAINING_RECORD(*Current, CM_KEY_CONTROL_BLOCK, KeyHash);
                if (kcb->TotalLevels > KeyControlBlock->TotalLevels) {
                    LevelDiff = kcb->TotalLevels - KeyControlBlock->TotalLevels;
                
                    Parent = kcb;
                    for (l=0; l<LevelDiff; l++) {
                        Parent = Parent->ParentKcb;
                    }
    
                    if (Parent == KeyControlBlock) {
                        //
                        // Found a match;
                        //
                        if( SearchType == SearchIfExist ) {
                            Count = 1;
                            break;
						} else if(SearchType == SearchAndTagNoDelayClose) {
							kcb->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;
                        } else if(SearchType == SearchAndDeref) {
                            //
                            // Mark the key as deleted, remove it from cache, but don't add it
                            // to the Delay Close table (we want the key to be visible only to
                            // the one(s) that have open handles on it.
                            //

                            ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

                            //
                            // don't mess with read only kcbs; this prevents a potential hack when 
                            // trying to FORCE_RESTORE over WPA keys.
                            //
                            if( !CmIsKcbReadOnly(kcb) ) {
                                //
                                // flush any pending notifies as the kcb won't be around any longer
                                //
                                CmpFlushNotifiesOnKeyBodyList(kcb);
                            
                                CmpCleanUpSubKeyInfo(kcb->ParentKcb);
                                kcb->Delete = TRUE;
                                CmpRemoveKeyControlBlock(kcb);
                                kcb->KeyCell = HCELL_NIL;
                                //
                                // Restart the search 
                                // 
                                goto StartDeref;
                            }
                        } else if(SearchType == SearchAndCount) {
                            //
                            // here do the dumping and count incrementing stuff
                            //
                            CmpDumpKeyBodyList(kcb,&Count);

#ifdef NT_RENAME_KEY
                        } else if( SearchType == SearchAndRehash ) {
                            //
                            // every kcb which has the one passed as a parameter
                            // as an ancestor needs to be moved to the right location 
                            // in the kcb hash table.
                            //
                            ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

                            if( CmpRehashKcbSubtree(KeyControlBlock,kcb) == TRUE ) {
                                //
                                // at least one kcb has been moved, we need to reiterate this bucket
                                //
                                goto StartDeref;
                            }
#endif //NT_RENAME_KEY
                        }
                    }   

                }
                Current = &kcb->NextHash;
            }
        }
    }
    
                           
    return Count;
}


#ifdef NT_RENAME_KEY
ULONG
CmpComputeKcbConvKey(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++
Routine Description:

    Computes the convkey for this kcb based on the NCB and its parent ConvKey

Arguments:

    KeyControlBlock - Supplies the key control block for the key for which
        the ConvKey is to be calculated

Return Value:

    The new ConvKey

Notes:

    This is to be used by the rename key api, which needs to rehash kcbs

--*/
{
    ULONG   ConvKey = 0;
    ULONG   Cnt;
    WCHAR   Cp;
    PUCHAR  u;
    PWCHAR  w;

    PAGED_CODE();

    if( KeyControlBlock->ParentKcb != NULL ) {
        ConvKey = KeyControlBlock->ParentKcb->ConvKey;
    }

    //
    // Manually compute the hash to use.
    //
    ASSERT(KeyControlBlock->NameBlock->NameLength > 0);

    u = (PUCHAR)(&(KeyControlBlock->NameBlock->Name[0]));
    w = (PWCHAR)u;
    for( Cnt = 0; Cnt < KeyControlBlock->NameBlock->NameLength;) {
        if( KeyControlBlock->NameBlock->Compressed ) {
            Cp = (WCHAR)(*u);
            u++;
            Cnt += sizeof(UCHAR);
        } else {
            Cp = *w;
            w++;
            Cnt += sizeof(WCHAR);
        }
        ASSERT( Cp != OBJ_NAME_PATH_SEPARATOR );
        
        ConvKey = 37 * ConvKey + (ULONG)RtlUpcaseUnicodeChar(Cp);
    }

    return ConvKey;
}

BOOLEAN
CmpRehashKcbSubtree(
                    PCM_KEY_CONTROL_BLOCK   Start,
                    PCM_KEY_CONTROL_BLOCK   End
                    )
/*++
Routine Description:

    Walks the path between End and Start and rehashed all kcbs that need
    rehashing;

    Assumptions: It is apriori taken that Start is an ancestor of End;

    Works in two steps:
    1. walks the path backwards from End to Start, reverting the back-link
    (we use the ParentKcb member in the kcb structure for that). I.e. we build a 
    forward path from Start to End
    2.Walks the forward path built at 1, rehashes kcbs whos need rehashing and restores
    the parent relationship.
    
Arguments:

    KeyControlBlock - where we start

    kcb - where we stop

Return Value:

    TRUE if at least one kcb has been rehashed

--*/
{
    PCM_KEY_CONTROL_BLOCK   Parent;
    PCM_KEY_CONTROL_BLOCK   Current;
    PCM_KEY_CONTROL_BLOCK   TmpKcb;
    ULONG                   ConvKey;
    BOOLEAN                 Result;

    PAGED_CODE();

#if DBG
    //
    // make sure Start is an ancestor of End;
    //
    {
        ULONG LevelDiff = End->TotalLevels - Start->TotalLevels;

        ASSERT( (LONG)LevelDiff >= 0 );

        TmpKcb = End;
        for(;LevelDiff; LevelDiff--) {
            TmpKcb = TmpKcb->ParentKcb;
        }

        ASSERT( TmpKcb == Start );
    }
    
#endif
    //
    // Step 1: walk the path backwards (using the parentkcb link) and
    // revert it, until we reach Start. It is assumed that Start is an 
    // ancestor of End (the caller must not call this function otherwise !!!)
    //
    Current = NULL;
    Parent = End;
    while( Current != Start ) {
        //
        // revert the link
        //
        TmpKcb = Parent->ParentKcb;
        Parent->ParentKcb = Current;
        Current = Parent;
        Parent = TmpKcb;
        
        ASSERT( Current->TotalLevels >= Start->TotalLevels );
    }

    ASSERT( Current == Start );

    //
    // Step 2: Walk the forward path built at 1 and rehash the kcbs that need 
    // caching; At the same time, restore the links (parent relationships)
    //
    Result = FALSE;
    while( Current != NULL ) {
        //
        // see if we need to rehash this kcb;
        //
        //
        // restore the parent relationship; need to do this first so
        // CmpComputeKcbConvKey works OK
        //
        TmpKcb = Current->ParentKcb;
        Current->ParentKcb = Parent;

        ConvKey = CmpComputeKcbConvKey(Current);
        if( ConvKey != Current->ConvKey ) {
            //
            // rehash the kcb by removing it from hash, and then inserting it
            // again with th new ConvKey
            //
            CmpRemoveKeyHash(&(Current->KeyHash));
            Current->ConvKey = ConvKey;
            CmpInsertKeyHash(&(Current->KeyHash),FALSE);
            Result = TRUE;
        }

        //
        // advance forward
        //
        Parent = Current;
        Current = TmpKcb;
    }

    ASSERT( Parent == End );

    return Result;
}

#endif //NT_RENAME_KEY


BOOLEAN
CmpReferenceKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
{
    if (KeyControlBlock->RefCount == 0) {
        CmpRemoveFromDelayedClose(KeyControlBlock);
    }

    if ((USHORT)(KeyControlBlock->RefCount + 1) == 0) {
        //
        // We have maxed out the ref count on this key. Probably
        // some bogus app has opened the same key 64K times without
        // ever closing it. Just fail the call
        //
        return (FALSE);
    } else {
        ++(KeyControlBlock->RefCount);
        return (TRUE);
    }
}


PCM_NAME_CONTROL_BLOCK
CmpGetNameControlBlock(
    PUNICODE_STRING NodeName
    )
{
    PCM_NAME_CONTROL_BLOCK   Ncb;
    ULONG  Cnt;
    WCHAR *Cp;
    WCHAR *Cp2;
    ULONG Index;
    ULONG i;
    ULONG      Size;
    PCM_NAME_HASH CurrentName;
    ULONG rc;
    BOOLEAN NameFound = FALSE;
    USHORT NameSize;
    BOOLEAN NameCompressed;
    ULONG NameConvKey=0;
    LONG Result;

    //
    // Calculate the ConvKey for this NodeName;
    //

    Cp = NodeName->Buffer;
    for (Cnt=0; Cnt<NodeName->Length; Cnt += sizeof(WCHAR)) {
        if (*Cp != OBJ_NAME_PATH_SEPARATOR) {
            NameConvKey = 37 * NameConvKey + (ULONG) RtlUpcaseUnicodeChar(*Cp);
        }
        ++Cp;
    }

    //
    // Find the Name Size;
    // 
    NameCompressed = TRUE;
    NameSize = NodeName->Length / sizeof(WCHAR);
    for (i=0;i<NodeName->Length/sizeof(WCHAR);i++) {
        if ((USHORT)NodeName->Buffer[i] > (UCHAR)-1) {
            NameSize = NodeName->Length;
            NameCompressed = FALSE;
        }
    }

    Index = GET_HASH_INDEX(NameConvKey);
    CurrentName = CmpNameCacheTable[Index];

    while (CurrentName) {
        Ncb =  CONTAINING_RECORD(CurrentName, CM_NAME_CONTROL_BLOCK, NameHash);

        if ((NameConvKey == CurrentName->ConvKey) &&
            (NameSize == Ncb->NameLength)) {
            //
            // Hash value matches, compare the names.
            //
            NameFound = TRUE;
            if (Ncb->Compressed) {
                // we already know the name is uppercase
                if (CmpCompareCompressedName(NodeName, Ncb->Name, NameSize, CMP_DEST_UP)) {
                    NameFound = FALSE;
                }
            } else {
                Cp = (WCHAR *) NodeName->Buffer;
                Cp2 = (WCHAR *) Ncb->Name;
                for (i=0 ;i<Ncb->NameLength; i+= sizeof(WCHAR)) {
                    //
                    // Cp2 is always uppercase; see bellow
                    //
                    if (RtlUpcaseUnicodeChar(*Cp) != (*Cp2) ) {
                        NameFound = FALSE;
                        break;
                    }
                    ++Cp;
                    ++Cp2;
                }
            }
            if (NameFound) {
                //
                // Found it, increase the refcount.
                //
                if ((USHORT) (Ncb->RefCount + 1) == 0) {
                    //
                    // We have maxed out the ref count.
                    // fail the call.
                    //
                    Ncb = NULL;
                } else {
                    ++Ncb->RefCount;
                }
                break;
            }
        }
        CurrentName = CurrentName->NextHash;
    }
    
    if (NameFound == FALSE) {
        //
        // Now need to create one Name block for this string.
        //
        Size = FIELD_OFFSET(CM_NAME_CONTROL_BLOCK, Name) + NameSize;
 
        Ncb = ExAllocatePoolWithTag(PagedPool,
                                    Size,
                                    CM_NAME_TAG | PROTECTED_POOL);
 
        if (Ncb == NULL) {
            return(NULL);
        }
        RtlZeroMemory(Ncb, Size);
 
        //
        // Update all the info for this newly created Name block.
        // Starting with whistler, the name is always upercase in kcb name block
        //
        if (NameCompressed) {
            Ncb->Compressed = TRUE;
            for (i=0;i<NameSize;i++) {
                ((PUCHAR)Ncb->Name)[i] = (UCHAR)RtlUpcaseUnicodeChar(NodeName->Buffer[i]);
            }
        } else {
            Ncb->Compressed = FALSE;
            for (i=0;i<NameSize/sizeof(WCHAR);i++) {
                Ncb->Name[i] = RtlUpcaseUnicodeChar(NodeName->Buffer[i]);
            }
        }

        Ncb->ConvKey = NameConvKey;
        Ncb->RefCount = 1;
        Ncb->NameLength = NameSize;
        
        CurrentName = &(Ncb->NameHash);
        //
        // Insert into Name Hash table.
        //
        CurrentName->NextHash = CmpNameCacheTable[Index];
        CmpNameCacheTable[Index] = CurrentName;
    }

    return(Ncb);
}


VOID
CmpDereferenceNameControlBlockWithLock(
    PCM_NAME_CONTROL_BLOCK   Ncb
    )
{
    PCM_NAME_HASH *Prev;
    PCM_NAME_HASH Current;

    if (--Ncb->RefCount == 0) {

        //
        // Remove it from the the Hash Table
        //
        Prev = &(GET_HASH_ENTRY(CmpNameCacheTable, Ncb->ConvKey));
        
        while (TRUE) {
            Current = *Prev;
            ASSERT(Current != NULL);
            if (Current == &(Ncb->NameHash)) {
                *Prev = Current->NextHash;
                break;
            }
            Prev = &Current->NextHash;
        }

        //
        // Free storage
        //
        ExFreePoolWithTag(Ncb, CM_NAME_TAG | PROTECTED_POOL);
    }
    return;
}

VOID
CmpRebuildKcbCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++
Routine Description:

    rebuilds all the kcb cache values from knode; this routine is intended to be called
    after a tree sync/copy

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    PCM_KEY_NODE    Node;

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    ASSERT( !(KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND) ); 

    Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);
    if( Node == NULL ) {
        //
        // this shouldn't happen as we should have the knode arround
        //
        ASSERT( FALSE );
        return;
    }
    HvReleaseCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);

    // subkey info;
    CmpCleanUpSubKeyInfo(KeyControlBlock);

    // value cache
    CmpCleanUpKcbValueCache(KeyControlBlock);
    CmpSetUpKcbValueCache(KeyControlBlock,Node->ValueList.Count,Node->ValueList.List);

    // the rest of the cache
    KeyControlBlock->KcbLastWriteTime = Node->LastWriteTime;
    KeyControlBlock->KcbMaxNameLen = (USHORT)Node->MaxNameLen;
    KeyControlBlock->KcbMaxValueNameLen = (USHORT)Node->MaxValueNameLen;
    KeyControlBlock->KcbMaxValueDataLen = Node->MaxValueDataLen;
}

VOID
CmpCleanUpSubKeyInfo(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++
Routine Description:

    Clean up the subkey information cache due to create or delete keys.
    Registry is locked exclusively and no need to lock the KCB.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    PCM_KEY_NODE    Node;

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    if (KeyControlBlock->ExtFlags & (CM_KCB_NO_SUBKEY | CM_KCB_SUBKEY_ONE | CM_KCB_SUBKEY_HINT)) {
        if (KeyControlBlock->ExtFlags & (CM_KCB_SUBKEY_HINT)) {
            ExFreePoolWithTag(KeyControlBlock->IndexHint, CM_CACHE_INDEX_TAG | PROTECTED_POOL);
        }
        KeyControlBlock->ExtFlags &= ~((CM_KCB_NO_SUBKEY | CM_KCB_SUBKEY_ONE | CM_KCB_SUBKEY_HINT));
    }
   
    //
    // Update the cached SubKeyCount in stored the kcb
    //
	if( KeyControlBlock->KeyCell == HCELL_NIL ) {
		//
		// prior call of ZwRestoreKey(REG_FORCE_RESTORE) invalidated this kcb
		//
		ASSERT( KeyControlBlock->Delete );
		Node = NULL;
	} else {
	    Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);
	}
    if( Node == NULL ) {
        //
        // insufficient resources; mark subkeycount as invalid
        //
        KeyControlBlock->ExtFlags |= CM_KCB_INVALID_CACHED_INFO;
    } else {
        KeyControlBlock->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
        KeyControlBlock->SubKeyCount = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];
        HvReleaseCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);
    }
    
}


VOID
CmpCleanUpKcbValueCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++

Routine Description:

    Clean up cached value/data that are associated to this key.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    ULONG i;
    PULONG_PTR CachedList;
    PCELL_DATA pcell;
    ULONG      realsize;
    BOOLEAN    small;

    if (CMP_IS_CELL_CACHED(KeyControlBlock->ValueCache.ValueList)) {
        CachedList = (PULONG_PTR) CMP_GET_CACHED_CELLDATA(KeyControlBlock->ValueCache.ValueList);
        for (i = 0; i < KeyControlBlock->ValueCache.Count; i++) {
            if (CMP_IS_CELL_CACHED(CachedList[i])) {

                // Trying to catch the BAD guy who writes over our pool.
                CmpMakeSpecialPoolReadWrite( CMP_GET_CACHED_ADDRESS(CachedList[i]) );

                ExFreePool((PVOID) CMP_GET_CACHED_ADDRESS(CachedList[i]));
               
            }
        }

        // Trying to catch the BAD guy who writes over our pool.
        CmpMakeSpecialPoolReadWrite( CMP_GET_CACHED_ADDRESS(KeyControlBlock->ValueCache.ValueList) );

        ExFreePool((PVOID) CMP_GET_CACHED_ADDRESS(KeyControlBlock->ValueCache.ValueList));

        // Mark the ValueList as NULL 
        KeyControlBlock->ValueCache.ValueList = HCELL_NIL;

    } else if (KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND) {
        //
        // This is a symbolic link key with symbolic name resolved.
        // Dereference to its real kcb and clear the bit.
        //
        if ((KeyControlBlock->ValueCache.RealKcb->RefCount == 1) && !(KeyControlBlock->ValueCache.RealKcb->Delete)) {
            KeyControlBlock->ValueCache.RealKcb->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;
        }
        CmpDereferenceKeyControlBlockWithLock(KeyControlBlock->ValueCache.RealKcb);
        KeyControlBlock->ExtFlags &= ~CM_KCB_SYM_LINK_FOUND;
    }
}


VOID
CmpCleanUpKcbCacheWithLock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++

Routine Description:

    Clean up all cached allocations that are associated to this key.
    If the parent is still open just because of this one, Remove the parent as well.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    PCM_KEY_CONTROL_BLOCK   Kcb;
    PCM_KEY_CONTROL_BLOCK   ParentKcb;

    Kcb = KeyControlBlock;

    ASSERT(KeyControlBlock->RefCount == 0);

    while (Kcb && Kcb->RefCount == 0) {
        //
        // First, free allocations for Value/data.
        //
    
        CmpCleanUpKcbValueCache(Kcb);
    
        //
        // Free the kcb and dereference parentkcb and nameblock.
        //
    
        CmpDereferenceNameControlBlockWithLock(Kcb->NameBlock);
    
        if (Kcb->ExtFlags & CM_KCB_SUBKEY_HINT) {
            //
            // Now free the HintIndex allocation
            //
            ExFreePoolWithTag(Kcb->IndexHint, CM_CACHE_INDEX_TAG | PROTECTED_POOL);
        }

        //
        // Save the ParentKcb before we free the Kcb
        //
        ParentKcb = Kcb->ParentKcb;
        
        //
        // We cannot call CmpDereferenceKeyControlBlockWithLock so we can avoid recurrsion.
        //
        
        if (!Kcb->Delete) {
            CmpRemoveKeyControlBlock(Kcb);
        }
        SET_KCB_SIGNATURE(Kcb, '4FmC');

#ifdef CMP_STATS
        CmpStatsDebug.CmpKcbNo--;
        ASSERT( CmpStatsDebug.CmpKcbNo >= 0 );
#endif

        CmpFreeKeyControlBlock( Kcb );

        Kcb = ParentKcb;
        if (Kcb) {
            Kcb->RefCount--;
        }
    }
}


PUNICODE_STRING
CmpConstructName(
    PCM_KEY_CONTROL_BLOCK kcb
)
/*++

Routine Description:

    Construct the name given a kcb.

Arguments:

    kcb - Kcb for the key

Return Value:

    Pointer to the unicode string constructed.  
    Caller is responsible to free this storage space.

--*/
{
    PUNICODE_STRING         FullName;
    PCM_KEY_CONTROL_BLOCK   TmpKcb;
    PCM_KEY_NODE            KeyNode;
    USHORT                  Length;
    USHORT                  size;
    USHORT                  i;
    USHORT                  BeginPosition;
    WCHAR                   *w1, *w2;
    UCHAR                   *u2;

    //
    // Calculate the total string length.
    //
    Length = 0;
    TmpKcb = kcb;
    while (TmpKcb) {
        if (TmpKcb->NameBlock->Compressed) {
            Length += TmpKcb->NameBlock->NameLength * sizeof(WCHAR);
        } else {
            Length += TmpKcb->NameBlock->NameLength; 
        }
        //
        // Add the space for OBJ_NAME_PATH_SEPARATOR;
        //
        Length += sizeof(WCHAR);

        TmpKcb = TmpKcb->ParentKcb;
    }

    //
    // Allocate the pool for the unicode string
    //
    size = sizeof(UNICODE_STRING) + Length;

    FullName = (PUNICODE_STRING) ExAllocatePoolWithTag(PagedPool,
                                                       size,
                                                       CM_NAME_TAG | PROTECTED_POOL);

    if (FullName) {
        FullName->Buffer = (USHORT *) ((ULONG_PTR) FullName + sizeof(UNICODE_STRING));
        FullName->Length = Length;
        FullName->MaximumLength = Length;

        //
        // Now fill the name into the buffer.
        //
        TmpKcb = kcb;
        BeginPosition = Length;

        while (TmpKcb) {
            if( (TmpKcb->KeyHive == NULL) || (TmpKcb->KeyCell == HCELL_NIL) || (TmpKcb->ExtFlags & CM_KCB_KEY_NON_EXIST) ) {
                ExFreePoolWithTag(FullName, CM_NAME_TAG | PROTECTED_POOL);
                FullName = NULL;
                break;
            }
            
            KeyNode = (PCM_KEY_NODE)HvGetCell(TmpKcb->KeyHive,TmpKcb->KeyCell);
            if( KeyNode == NULL ) {
                //
                // could not allocate view
                //
                ExFreePoolWithTag(FullName, CM_NAME_TAG | PROTECTED_POOL);
                FullName = NULL;
                break;
            }
            //
            // sanity
            //
#if DBG
            if( ! (TmpKcb->Flags & (KEY_HIVE_ENTRY | KEY_HIVE_EXIT)) ) {
                ASSERT( KeyNode->NameLength == TmpKcb->NameBlock->NameLength );
                ASSERT( ((KeyNode->Flags&KEY_COMP_NAME) && (TmpKcb->NameBlock->Compressed)) ||
                        ((!(KeyNode->Flags&KEY_COMP_NAME)) && (!(TmpKcb->NameBlock->Compressed))) );
            }
#endif //DBG
            //
            // Calculate the begin position of each subkey. Then fill in the char.
            //
            //
            if (TmpKcb->NameBlock->Compressed) {
                BeginPosition -= (TmpKcb->NameBlock->NameLength + 1) * sizeof(WCHAR);
                w1 = &(FullName->Buffer[BeginPosition/sizeof(WCHAR)]);
                *w1 = OBJ_NAME_PATH_SEPARATOR;
                w1++;

                if( ! (TmpKcb->Flags & (KEY_HIVE_ENTRY | KEY_HIVE_EXIT)) ) {
                    //
                    // Get the name from the knode; to preserve case
                    //
                    u2 = (UCHAR *) &(KeyNode->Name[0]);
                } else { 
                    //
                    // get it from the kcb, as in the keynode we don't hold the right name (see PROTO.HIV nodes)
                    //
                    u2 = (UCHAR *) &(TmpKcb->NameBlock->Name[0]);
                }

                for (i=0; i<TmpKcb->NameBlock->NameLength; i++) {
                    *w1 = (WCHAR)(*u2);
                    w1++;
                    u2++;
                }
            } else {
                BeginPosition -= (TmpKcb->NameBlock->NameLength + sizeof(WCHAR));
                w1 = &(FullName->Buffer[BeginPosition/sizeof(WCHAR)]);
                *w1 = OBJ_NAME_PATH_SEPARATOR;
                w1++;

                if( ! (TmpKcb->Flags & (KEY_HIVE_ENTRY | KEY_HIVE_EXIT)) ) {
                    //
                    // Get the name from the knode; to preserve case
                    //
                    w2 = KeyNode->Name;
                } else {
                    //
                    // get it from the kcb, as in the keynode we don't hold the right name (see PROTO.HIV nodes)
                    //
                    w2 = TmpKcb->NameBlock->Name;
                }
                for (i=0; i<TmpKcb->NameBlock->NameLength; i=i+sizeof(WCHAR)) {
                    *w1 = *w2;
                    w1++;
                    w2++;
                }
            }

            HvReleaseCell(TmpKcb->KeyHive,TmpKcb->KeyCell);

            TmpKcb = TmpKcb->ParentKcb;
        }
    }
    return (FullName);
}

PCM_KEY_CONTROL_BLOCK
CmpCreateKeyControlBlock(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    PCM_KEY_NODE    Node,
    PCM_KEY_CONTROL_BLOCK ParentKcb,
    BOOLEAN         FakeKey,
    PUNICODE_STRING KeyName
    )
/*++

Routine Description:

    Allocate and initialize a key control block, insert it into
    the kcb tree.

    Full path will be BaseName + '\' + KeyName, unless BaseName
    NULL, in which case the full path is simply KeyName.

    RefCount of returned KCB WILL have been incremented to reflect
    callers ref.

Arguments:

    Hive - Supplies Hive that holds the key we are creating a KCB for.

    Cell - Supplies Cell that contains the key we are creating a KCB for.

    Node - Supplies pointer to key node.

    ParentKcb - Parent kcb of the kcb to be created

    FakeKey - Whether the kcb to be create is a fake one or not

    KeyName - the subkey name to of the KCB to be created.
 
    NOTE:  We need the parameter instead of just using the name in the KEY_NODE 
           because there is no name in the root cell of a hive.

Return Value:

    NULL - failure (insufficient memory)
    else a pointer to the new kcb.

--*/
{
    PCM_KEY_CONTROL_BLOCK   kcb;
    PCM_KEY_CONTROL_BLOCK   kcbmatch=NULL;
    ULONG                   namelength;
    PUNICODE_STRING         fullname;
    ULONG                   Size;
    ULONG                   i;
    UNICODE_STRING          NodeName;
    ULONG                   ConvKey = 0;
    ULONG                   Cnt;
    WCHAR                   *Cp;

    //
    // ParentKCb has the base hash value.
    //
    if (ParentKcb) {
        ConvKey = ParentKcb->ConvKey;
    }

    NodeName = *KeyName;

    while ((NodeName.Length > 0) && (NodeName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
        //
        // This must be the \REGISTRY.
        // Strip off the leading OBJ_NAME_PATH_SEPARATOR
        //
        NodeName.Buffer++;
        NodeName.Length -= sizeof(WCHAR);
    }

    //
    // Manually compute the hash to use.
    //
    ASSERT(NodeName.Length > 0);

    if (NodeName.Length) {
        Cp = NodeName.Buffer;
        for (Cnt=0; Cnt<NodeName.Length; Cnt += sizeof(WCHAR)) {
            //
            // UNICODE_NULL is a valid char !!!
            //
            if (*Cp != OBJ_NAME_PATH_SEPARATOR) {
                //(*Cp != UNICODE_NULL)) {
                ConvKey = 37 * ConvKey + (ULONG)RtlUpcaseUnicodeChar(*Cp);
            }
            ++Cp;
        }
    }

    //
    // Create a new kcb, which we will free if one already exists
    // for this key.
    // Now it is a fixed size structure.
    //
    kcb = CmpAllocateKeyControlBlock( );

    if (kcb == NULL) {
        return(NULL);
    } else {
        SET_KCB_SIGNATURE(kcb, KCB_SIGNATURE);
        INIT_KCB_KEYBODY_LIST(kcb);
        kcb->Delete = FALSE;
        kcb->RefCount = 1;
        kcb->KeyHive = Hive;
        kcb->KeyCell = Cell;
        kcb->ConvKey = ConvKey;

#ifdef CMP_STATS
        // colect stats
        CmpStatsDebug.CmpKcbNo++;
        if( CmpStatsDebug.CmpKcbNo > CmpStatsDebug.CmpMaxKcbNo ) {
            CmpStatsDebug.CmpMaxKcbNo = CmpStatsDebug.CmpKcbNo;
        }
#endif
    }

    ASSERT_KCB(kcb);
    //
    // Find location to insert kcb in kcb tree.
    //


    BEGIN_KCB_LOCK_GUARD;    
    CmpLockKCBTreeExclusive();

    //
    // Add the KCB to the hash table
    //
    kcbmatch = CmpInsertKeyHash(&kcb->KeyHash, FakeKey);
    if (kcbmatch != NULL) {
        //
        // A match was found.
        //
        ASSERT(!kcbmatch->Delete);
        SET_KCB_SIGNATURE(kcb, '1FmC');

#ifdef CMP_STATS
        CmpStatsDebug.CmpKcbNo--;
        ASSERT( CmpStatsDebug.CmpKcbNo >= 0 );
#endif

        CmpFreeKeyControlBlock(kcb);
        ASSERT_KCB(kcbmatch);
        kcb = kcbmatch;
        if (kcb->RefCount == 0) {
            //
            // This kcb is on the delayed close list. Remove it from that
            // list.
            //
            CmpRemoveFromDelayedClose(kcb);
        }
        if ((USHORT)(kcb->RefCount + 1) == 0) {
            //
            // We have maxed out the ref count on this key. Probably
            // some bogus app has opened the same key 64K times without
            // ever closing it. Just fail the open, they've got enough
            // handles already.
            //
            ASSERT(kcb->RefCount + 1 != 0);
            kcb = NULL;
        } else {
            ++kcb->RefCount;
        }

        //
        // update the keycell and hive, in case this is a fake kcb
        //
        if( (kcb->ExtFlags & CM_KCB_KEY_NON_EXIST) && (!FakeKey) ) {
            kcb->ExtFlags = CM_KCB_INVALID_CACHED_INFO;
            kcb->KeyHive = Hive;
            kcb->KeyCell = Cell;
        }

        //
        // Update the cached information stored in the kcb, since we have the key_node handy
        //
        if (!(kcb->ExtFlags & (CM_KCB_NO_SUBKEY | CM_KCB_SUBKEY_ONE | CM_KCB_SUBKEY_HINT)) ) {
            // SubKeyCount
            kcb->SubKeyCount = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];
            // clean up the invalid flag (if any)
            kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;

        }

        kcb->KcbLastWriteTime = Node->LastWriteTime;
        kcb->KcbMaxNameLen = (USHORT)Node->MaxNameLen;
        kcb->KcbMaxValueNameLen = (USHORT)Node->MaxValueNameLen;
        kcb->KcbMaxValueDataLen = Node->MaxValueDataLen;

    } else {
        //
        // No kcb created previously, fill in all the data.
        //

        //
        // Now try to reference the parentkcb
        //
        
        if (ParentKcb) {
            if ( ((ParentKcb->TotalLevels + 1) < CMP_MAX_REGISTRY_DEPTH) && (CmpReferenceKeyControlBlock(ParentKcb)) ) {
                kcb->ParentKcb = ParentKcb;
                kcb->TotalLevels = ParentKcb->TotalLevels + 1;
            } else {
                //
                // We have maxed out the ref count on the parent.
                // Since it has been cached in the cachetable,
                // remove it first before we free the allocation.
                //
                CmpRemoveKeyControlBlock(kcb);
                SET_KCB_SIGNATURE(kcb, '2FmC');

#ifdef CMP_STATS
        CmpStatsDebug.CmpKcbNo--;
        ASSERT( CmpStatsDebug.CmpKcbNo >= 0 );
#endif

                CmpFreeKeyControlBlock(kcb);
                kcb = NULL;
            }
        } else {
            //
            // It is the \REGISTRY node.
            //
            kcb->ParentKcb = NULL;
            kcb->TotalLevels = 1;
        }

        if (kcb) {
            //
            // Cache the security cells in the kcb
            //
            CmpAssignSecurityToKcb(kcb,Node->Security);

            //
            // Now try to find the Name Control block that has the name for this node.
            //
            kcb->NameBlock = CmpGetNameControlBlock (&NodeName);

            if (kcb->NameBlock) {
                //
                // Now fill in all the data needed for the cache.
                //
                kcb->ValueCache.Count = Node->ValueList.Count;                    
                kcb->ValueCache.ValueList = (ULONG_PTR)(Node->ValueList.List);
        
                kcb->Flags = Node->Flags;
                kcb->ExtFlags = 0;
                kcb->DelayedCloseIndex = CmpDelayedCloseSize;
        
                if (FakeKey) {
                    //
                    // The KCb to be created is a fake one; 
                    //
                    kcb->ExtFlags |= CM_KCB_KEY_NON_EXIST;
                }

                CmpTraceKcbCreate(kcb);
                PERFINFO_REG_KCB_CREATE(kcb);

                //
                // Update the cached information stored in the kcb, since we have the key_node handy
                //
                
                // SubKeyCount
                kcb->SubKeyCount = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];
                
                kcb->KcbLastWriteTime = Node->LastWriteTime;
                kcb->KcbMaxNameLen = (USHORT)Node->MaxNameLen;
                kcb->KcbMaxValueNameLen = (USHORT)Node->MaxValueNameLen;
                kcb->KcbMaxValueDataLen = Node->MaxValueDataLen;

            } else {
                //
                // We have maxed out the ref count on the Name.
                //
                
                //
                // First dereference the parent KCB.
                //
                CmpDereferenceKeyControlBlockWithLock(ParentKcb);

                CmpRemoveKeyControlBlock(kcb);
                SET_KCB_SIGNATURE(kcb, '3FmC');

#ifdef CMP_STATS
                CmpStatsDebug.CmpKcbNo--;
                ASSERT( CmpStatsDebug.CmpKcbNo >= 0 );
#endif

                CmpFreeKeyControlBlock(kcb);
                kcb = NULL;
            }
        }
    }

#ifdef NT_UNLOAD_KEY_EX
	if( kcb && IsHiveFrozen(Hive) && (!(kcb->Flags & KEY_SYM_LINK)) ) {
		//
		// kcbs created inside a frozen hive should not be added to delayclose table.
		//
		kcb->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;

	}
#endif //NT_UNLOAD_KEY_EX

    CmpUnlockKCBTree();
    END_KCB_LOCK_GUARD;    
    return kcb;
}


BOOLEAN
CmpSearchKeyControlBlockTree(
    PKCB_WORKER_ROUTINE WorkerRoutine,
    PVOID               Context1,
    PVOID               Context2
    )
/*++

Routine Description:

    Traverse the kcb tree.  We will visit all nodes unless WorkerRoutine
    tells us to stop part way through.

    For each node, call WorkerRoutine(..., Context1, Contex2).  If it returns
    KCB_WORKER_DONE, we are done, simply return.  If it returns
    KCB_WORKER_CONTINUE, just continue the search. If it returns KCB_WORKER_DELETE,
    the specified KCB is marked as deleted.
	If it returns KCB_WORKER_ERROR we bail out and signal the error to the caller.

    This routine has the side-effect of removing all delayed-close KCBs.

Arguments:

    WorkerRoutine - applied to nodes witch Match.

    Context1 - data we pass through

    Context2 - data we pass through


Return Value:

    NONE.

--*/
{
    PCM_KEY_CONTROL_BLOCK   Current;
    PCM_KEY_CONTROL_BLOCK   Next;
    PCM_KEY_HASH *Prev;
    ULONG                   WorkerResult;
    ULONG                   i;

    //
    // Walk the hash table
    //
    for (i=0; i<CmpHashTableSize; i++) {
        Prev = &CmpCacheTable[i];
        while (*Prev) {
            Current = CONTAINING_RECORD(*Prev,
                                        CM_KEY_CONTROL_BLOCK,
                                        KeyHash);
            ASSERT_KCB(Current);
            ASSERT(!Current->Delete);
            if (Current->RefCount == 0) {
                //
                // This kcb is in DelayClose case, remove it.
                //
                CmpRemoveFromDelayedClose(Current);
                CmpCleanUpKcbCacheWithLock(Current);

                //
                // The HashTable is changed, start over in this index again.
                //
                Prev = &CmpCacheTable[i];
                continue;
            }

            WorkerResult = (WorkerRoutine)(Current, Context1, Context2);
            if (WorkerResult == KCB_WORKER_DONE) {
                return TRUE;
            } else if (WorkerResult == KCB_WORKER_ERROR) {
				return FALSE;
            } else if (WorkerResult == KCB_WORKER_DELETE) {
                ASSERT(Current->Delete);
                *Prev = Current->NextHash;
                continue;
            } else {
                ASSERT(WorkerResult == KCB_WORKER_CONTINUE);
                Prev = &Current->NextHash;
            }
        }
    }

	return TRUE;
}


VOID
CmpDereferenceKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++

Routine Description:

    Decrements the reference count on a key control block, and frees it if it
    becomes zero.

    It is expected that no notify control blocks remain if the reference count
    becomes zero.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    BEGIN_KCB_LOCK_GUARD;    
    CmpLockKCBTreeExclusive();
    CmpDereferenceKeyControlBlockWithLock(KeyControlBlock) ;
    CmpUnlockKCBTree();
    END_KCB_LOCK_GUARD;    
    return;
}


VOID
CmpDereferenceKeyControlBlockWithLock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
{
    ULONG_PTR FreeIndex;
    PCM_KEY_CONTROL_BLOCK KcbToFree;



    ASSERT_KCB(KeyControlBlock);

    if (--KeyControlBlock->RefCount == 0) {
        //
        // Remove kcb from the tree
        //
        // delay close disabled during boot; up to the point CCS is saved.
        // for symbolic links, we still need to keep the symbolic link kcb around.
        //
        if((CmpHoldLazyFlush && (!(KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND)) && (!(KeyControlBlock->Flags & KEY_SYM_LINK))) || 
            (KeyControlBlock->ExtFlags & CM_KCB_NO_DELAY_CLOSE) ) {
            //
            // Free storage directly so we can clean up junk quickly.
            //
            //
            // Need to free all cached Index List, Index Leaf, Value, etc.
            //
            CmpCleanUpKcbCacheWithLock(KeyControlBlock);
        } else if (!KeyControlBlock->Delete) {

            //
            // Put this kcb on our delayed close list.
            //
            CmpAddToDelayedClose(KeyControlBlock);

        } else {
            //
            // Free storage directly as there is no point in putting this on
            // our delayed close list.
            //
            //
            // Need to free all cached Index List, Index Leaf, Value, etc.
            //
            CmpCleanUpKcbCacheWithLock(KeyControlBlock);
        }
    }

    return;
}


VOID
CmpRemoveKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++

Routine Description:

    Remove a key control block from the KCB tree.

    It is expected that no notify control blocks remain.

    The kcb will NOT be freed, call DereferenceKeyControlBlock for that.

    This call assumes the KCB tree is already locked or registry is locked exclusively.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    ASSERT_KCB(KeyControlBlock);

    //
    // Remove the KCB from the hash table
    //
    CmpRemoveKeyHash(&KeyControlBlock->KeyHash);

    return;
}


BOOLEAN
CmpFreeKeyBody(
    PHHIVE Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Free storage for the key entry Hive.Cell refers to, including
    its class and security data.  Will NOT free child list or value list.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of key to free

Return Value:

    TRUE - success

    FALSE - error; couldn't map cell
--*/
{
    PCELL_DATA key;

    //
    // map in the cell
    //
    key = HvGetCell(Hive, Cell);
    if( key == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // Sorry, we cannot free the keybody
        // this shouldn't happen as the cell must've been
        // marked dirty (i.e. pinned in memory) by now
        //
        ASSERT( FALSE );
        return FALSE;
    }

    if (!(key->u.KeyNode.Flags & KEY_HIVE_EXIT)) {
        if (key->u.KeyNode.Security != HCELL_NIL) {
            HvFreeCell(Hive, key->u.KeyNode.Security);
        }

        if (key->u.KeyNode.ClassLength > 0) {
            HvFreeCell(Hive, key->u.KeyNode.Class);
        }
    }

    HvReleaseCell(Hive,Cell);

    //
    // unmap the cell itself and free it
    //
    HvFreeCell(Hive, Cell);

    return TRUE;
}



PCM_KEY_CONTROL_BLOCK
CmpInsertKeyHash(
    IN PCM_KEY_HASH KeyHash,
    IN BOOLEAN      FakeKey
    )
/*++

Routine Description:

    Adds a key hash structure to the hash table. The hash table
    will be checked to see if a duplicate entry already exists. If
    a duplicate is found, its kcb will be returned. If a duplicate is not
    found, NULL will be returned.

Arguments:

    KeyHash - Supplies the key hash structure to be added.

Return Value:

    NULL - if the supplied key has was added
    PCM_KEY_HASH - The duplicate hash entry, if one was found

--*/

{
    HASH_VALUE Hash;
    ULONG Index;
    PCM_KEY_HASH Current;

    ASSERT_KEY_HASH(KeyHash);
    Index = GET_HASH_INDEX(KeyHash->ConvKey);

    //
    // If this is a fake key, we will use the cell and hive from its 
    // parent for uniqeness.  To deal with the case when the fake
    // has the same ConvKey as its parent (in which case we cannot distingish 
    // between the two), we set the lowest bit of the fake key's cell.
    //
    // It's possible (unlikely) that we cannot distingish two fake keys 
    // (when their Convkey's are the same) under the same key.  It is not breaking
    // anything, we just cannot find the other one in cache lookup.
    //
    //
    if (FakeKey) {
        KeyHash->KeyCell++;
    }

    //
    // First look for duplicates.
    //
    Current = CmpCacheTable[Index];
    while (Current) {
        ASSERT_KEY_HASH(Current);
        //
        // We must check ConvKey since we can create a fake kcb
        // for keys that does not exist.
        // We will use the Hive and Cell from the parent.
        //

        if ((KeyHash->ConvKey == Current->ConvKey) &&
            (KeyHash->KeyCell == Current->KeyCell) &&
            (KeyHash->KeyHive == Current->KeyHive)) {
            //
            // Found a match
            //
            return(CONTAINING_RECORD(Current,
                                     CM_KEY_CONTROL_BLOCK,
                                     KeyHash));
        }
        Current = Current->NextHash;
    }

#if DBG
    // 
    // Make sure this key is not somehow cached in the wrong spot.
    //
    {
        ULONG DbgIndex;
        PCM_KEY_CONTROL_BLOCK kcb;
        
        for (DbgIndex = 0; DbgIndex < CmpHashTableSize; DbgIndex++) {
            Current = CmpCacheTable[DbgIndex];
            while (Current) {
                kcb = CONTAINING_RECORD(Current,
                                        CM_KEY_CONTROL_BLOCK,
                                        KeyHash);
                
                ASSERT_KEY_HASH(Current);
                ASSERT((KeyHash->KeyHive != Current->KeyHive) ||
                       FakeKey ||
                       (kcb->ExtFlags & CM_KCB_KEY_NON_EXIST) ||
                       (KeyHash->KeyCell != Current->KeyCell));
                Current = Current->NextHash;
            }
        }
    }
    
#endif

    //
    // No duplicate was found, add this entry at the head of the list
    //
    KeyHash->NextHash = CmpCacheTable[Index];
    CmpCacheTable[Index] = KeyHash;
    return(NULL);
}


VOID
CmpRemoveKeyHash(
    IN PCM_KEY_HASH KeyHash
    )
/*++

Routine Description:

    Removes a key hash structure from the hash table.

Arguments:

    KeyHash - Supplies the key hash structure to be deleted.

Return Value:

    None

--*/

{
    ULONG Index;
    PCM_KEY_HASH *Prev;
    PCM_KEY_HASH Current;

    ASSERT_KEY_HASH(KeyHash);

    Index = GET_HASH_INDEX(KeyHash->ConvKey);

    //
    // Find this entry.
    //
    Prev = &CmpCacheTable[Index];
    while (TRUE) {
        Current = *Prev;
        ASSERT(Current != NULL);
        ASSERT_KEY_HASH(Current);
        if (Current == KeyHash) {
            *Prev = Current->NextHash;
#if DBG
            if (*Prev) {
                ASSERT_KEY_HASH(*Prev);
            }
#endif
            break;
        }
        Prev = &Current->NextHash;
    }
}


VOID
CmpInitializeCache()
{
    ULONG TotalCmCacheSize;
    ULONG i;

    TotalCmCacheSize = CmpHashTableSize * sizeof(PCM_KEY_HASH);

    CmpCacheTable = ExAllocatePoolWithTag(PagedPool,
                                          TotalCmCacheSize,
                                          'aCMC');
    if (CmpCacheTable == NULL) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_CACHE_TABLE,1,0,0);
        return;
    }
    RtlZeroMemory(CmpCacheTable, TotalCmCacheSize);

    TotalCmCacheSize = CmpHashTableSize * sizeof(PCM_NAME_HASH);
    CmpNameCacheTable = ExAllocatePoolWithTag(PagedPool,
                                              TotalCmCacheSize,
                                              'aCMC');
    if (CmpNameCacheTable == NULL) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_CACHE_TABLE,1,0,0);
        return;
    }
    RtlZeroMemory(CmpNameCacheTable, TotalCmCacheSize);

    CmpInitializeDelayedCloseTable();
}


#ifdef CM_CHECK_FOR_ORPHANED_KCBS
VOID
CmpCheckForOrphanedKcbs(
    PHHIVE          Hive
    )
/*++

Routine Description:

    Parses the entire kcb cache in search of kcbs that still reffer to the specified hive
    breakpoint when a match is found.

Arguments:

    Hive - Supplies Hive.


Return Value:

    none

--*/
{
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock;
    PCM_KEY_HASH            Current;
    ULONG                   i;

    //
    // Walk the hash table
    //
    for (i=0; i<CmpHashTableSize; i++) {
        Current = CmpCacheTable[i];
        while (Current) {
            KeyControlBlock = CONTAINING_RECORD(Current, CM_KEY_CONTROL_BLOCK, KeyHash);
            ASSERT_KCB(KeyControlBlock);

            if( KeyControlBlock->KeyHive == Hive ) {
                //
                // found it ! Break to investigate !!!
                //
                DbgPrint("\n Orphaned KCB (%p) found for hive (%p)\n\n",KeyControlBlock,Hive);
                DbgBreakPoint();
            }
            Current = Current->NextHash;
        }
    }

}
#endif //CM_CHECK_FOR_ORPHANED_KCBS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmtrecpy.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmtrecpy.c

Abstract:

    This file contains code for CmpCopyTree, misc copy utility routines.

Author:

    Bryan M. Willman (bryanwi) 15-Jan-92

Revision History:

   Elliot Shmukler (t-ellios) 24-Aug-1998
   
      Added support for synchronizing two trees.

--*/

#include    "cmp.h"

//
// Set this to true to enable tree sync debug outputs
//

#define DEBUG_TREE_SYNC FALSE
                          
//
// stack used for directing nesting of tree copy.  gets us off
// the kernel stack and thus allows for VERY deep nesting
//

#define CMP_INITIAL_STACK_SIZE  1024        // ENTRIES

typedef struct {
    HCELL_INDEX SourceCell;
    HCELL_INDEX TargetCell;
    ULONG       i;
} CMP_COPY_STACK_ENTRY, *PCMP_COPY_STACK_ENTRY;

BOOLEAN
CmpCopySyncTree2(
    PCMP_COPY_STACK_ENTRY   CmpCopyStack,
    ULONG                   CmpCopyStackSize,
    ULONG                   CmpCopyStackTop,
    PHHIVE                  CmpSourceHive,
    PHHIVE                  CmpTargetHive,
    BOOLEAN                 CopyVolatile,
    CMP_COPY_TYPE           CopyType
    );

BOOLEAN
CmpFreeKeyValues(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    PCM_KEY_NODE Node
    );

BOOLEAN
CmpSyncKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    );

BOOLEAN
CmpMergeKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    );


BOOLEAN
CmpSyncSubKeysAfterDelete(
                          PHHIVE SourceHive,
                          PCM_KEY_NODE SourceCell,
                          PHHIVE TargetHive,
                          PCM_KEY_NODE TargetCell, 
                          WCHAR *NameBuffer);

BOOLEAN
CmpMarkKeyValuesDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    PCM_KEY_NODE Node
    );

BOOLEAN
CmpMarkKeyParentDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpCopySyncTree)
#pragma alloc_text(PAGE,CmpCopySyncTree2)
#pragma alloc_text(PAGE,CmpCopyKeyPartial)
#pragma alloc_text(PAGE,CmpCopyValue)
#pragma alloc_text(PAGE,CmpCopyCell)
#pragma alloc_text(PAGE,CmpFreeKeyValues)
#pragma alloc_text(PAGE,CmpSyncKeyValues)
#pragma alloc_text(PAGE,CmpMergeKeyValues)
#pragma alloc_text(PAGE,CmpInitializeKeyNameString)
#pragma alloc_text(PAGE,CmpInitializeValueNameString)
#pragma alloc_text(PAGE,CmpSyncSubKeysAfterDelete)
#pragma alloc_text(PAGE,CmpMarkKeyValuesDirty)
#pragma alloc_text(PAGE,CmpMarkKeyParentDirty)
#endif

//
// Routine to actually call to do a tree copy (or sync)
//

BOOLEAN
CmpCopySyncTree(
    PHHIVE          SourceHive,
    HCELL_INDEX     SourceCell,
    PHHIVE          TargetHive,
    HCELL_INDEX     TargetCell,
    BOOLEAN         CopyVolatile,
    CMP_COPY_TYPE   CopyType
    )
/*++

Routine Description:

    This routine can perform two distinct (yet similar) tasks:
    a tree copy or a tree synchronization (sync). Which task
    is performed is determined by the TreeSync parameter.
    
    For both operations:
    --------------------
    
    The source root key and target root key must exist in advance.
    These root nodes and their value entries will NOT be copied/synced.                
    
    NOTE:   Volatile keys are only copied/synced if the CopyVolatile
            parameter is set to true.

    
    For a tree copy:
    ----------------
    
    A tree is copied from source to destination. The subkeys
    of the source root key and the full trees under those
    subkeys will be copied to a new tree at target root key.
                           
    NOTE:   If this call fails part way through, it will NOT undo
            any successfully completed key copies, thus a partial
            tree copy CAN occur.
            
    For a tree sync:
    ----------------
    
    The target tree is synchronized with the source tree. It is 
    assumed that for a certain period of the time the target tree
    has remained unmodified while modifications may have been made
    to the source tree. During a sync, any such modifications
    to the source tree are made to the target tree. Thus, at the
    end of a successful sync, the target tree is identical to the
    source tree.
    
    Since only things that have changed in the source tree 
    are modified in the target tree, a sync operation is far
    more efficient than the delete/copy operations necessary
    to accomplish the same results.
    
    NOTE: It is assumed that no open handles are held
          on any target tree keys. Registry in-memory data
          structures may be corrupted if this is not true.
        
Arguments:

    SourceHive - pointer to hive control structure for source

    SourceCell - index of cell at root of tree to copy/sync

    TargetHive - pointer to hive control structure for target

    TargetCell - pointer to cell at root of target tree
    
    CopyVolatile - indicates whether volatile keys should be
                   copied/synced.
                   
    CopyType - indicates the type of the copy operation:
                Copy  - A copy is requested
                Sync  - A sync is requested
                Merge - A merge is requested i.e.:
                    1. the target nodes that are not present on the source tree are not
                    deleted.
                    2. the target nodes that are present in the source tree gets overrided
                    no matter what the LastWriteTime value is.
Return Value:

    BOOLEAN - Result code from call, among the following:
        TRUE - it worked
        FALSE - the tree copy/sync was not completed (though more than 0
                keys may have been copied/synced)

--*/
{
    BOOLEAN result;
    PCMP_COPY_STACK_ENTRY   CmpCopyStack;
    PRELEASE_CELL_ROUTINE   TargetReleaseCellRoutine;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyTree:\n"));

    CmpCopyStack = ExAllocatePool(
                        PagedPool,
                        sizeof(CMP_COPY_STACK_ENTRY)*CMP_INITIAL_STACK_SIZE
                        );
    if (CmpCopyStack == NULL) {
        return FALSE;
    }
    CmpCopyStack[0].SourceCell = SourceCell;
    CmpCopyStack[0].TargetCell = TargetCell;

    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // since the registry is locked exclusively here, we don't need to lock/release cells 
    // while copying the trees; So, we just set the release routines to NULL and restore after
    // the copy is complete; this saves some pain
    //
    TargetReleaseCellRoutine = TargetHive->ReleaseCellRoutine;
    TargetHive->ReleaseCellRoutine = NULL;

    result = CmpCopySyncTree2(
                CmpCopyStack,
                CMP_INITIAL_STACK_SIZE,
                0,
                SourceHive,
                TargetHive,
                CopyVolatile,
                CopyType
                );

    TargetHive->ReleaseCellRoutine = TargetReleaseCellRoutine;

    ExFreePool(CmpCopyStack);
    return result;
}


//
// Helper
//

BOOLEAN
CmpCopySyncTree2(
    PCMP_COPY_STACK_ENTRY   CmpCopyStack,
    ULONG                   CmpCopyStackSize,
    ULONG                   CmpCopyStackTop,
    PHHIVE                  CmpSourceHive,
    PHHIVE                  CmpTargetHive,
    BOOLEAN                 CopyVolatile,
    CMP_COPY_TYPE           CopyType
    )
/*++

Routine Description:

   This is a helper routine for CmpCopySyncTree. It accomplishes
   the functionality described by that routine in a "virtually"
   recursive manner which frees this routine from the limitations
   of the Kernel stack.
   
   This routine should not be called directly. Use CmpCopySyncTree!.
      
Arguments:

    (All of these are "virtual globals")

    CmpCopyStack - "global" pointer to stack for frames

    CmpCopyStackSize - alloced size of stack

    CmpCopyStackTop - current top

    CmpSourceHive, CmpTargetHive - source and target hives
    
    CopyVolatile, CopyType - same as CmpCopySyncTree.


Return Value:

    BOOLEAN - Result code from call, among the following:
        TRUE - it worked
        FALSE - the tree copy/sync was not completed (though more than 0
                keys may have been copied/synced)

--*/
{
    PCMP_COPY_STACK_ENTRY   Frame;
    HCELL_INDEX             SourceChild;
    HCELL_INDEX             NewSubKey;

    BOOLEAN                 Ret = FALSE, SyncNeedsTreeCopy = FALSE;
    UNICODE_STRING          KeyName;
    PCM_KEY_NODE            SourceChildCell, TargetChildCell;       
    PCM_KEY_NODE            SourceCell, TargetCell, TempNode;
    ULONG                   SyncTreeCopyStackStart;
    WCHAR                   *NameBuffer = NULL;
    
    // A merge is a particular case of a sync !!!
    BOOLEAN                 TreeSync = (CopyType == Sync || CopyType == Merge)?TRUE:FALSE;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyTree2:\n"));

    if (TreeSync) {

       //
       // The sync operation involves some work with key names, 
       // so we must allocate a buffer used for key name decompression.
       //

       NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_NAME_LENGTH);
       if(!NameBuffer) return FALSE;

    } 

    //
    // outer loop, apply to entire tree, emulate recursion here
    // jump to here is a virtual call
    //
    Outer: while (TRUE) {

        Frame = &(CmpCopyStack[CmpCopyStackTop]);

        Frame->i = 0;
                        
    //
    // inner loop, applies to one key
    // jump to here is a virtual return
    //
        Inner: while (TRUE) {

            SourceCell = (PCM_KEY_NODE)HvGetCell(CmpSourceHive, Frame->SourceCell);
            if( SourceCell == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                goto CopyEnd;
            }

            SourceChild = CmpFindSubKeyByNumber(CmpSourceHive,
                                                SourceCell,
                                                Frame->i);
            (Frame->i)++;

            if ((SourceChild == HCELL_NIL) || (!CopyVolatile &&
                                               (HvGetCellType(SourceChild) == Volatile))) {

                //
                // we've stepped through all the children (or we are only
                // interested in stable children and have just stepped through
                // the stable children and into the volatile ones)
                //                
                
                if(TreeSync && (CopyType != Merge))
                { 
                   //
                   // If we are here during a sync, that means most of sync operations
                   // applied to the current SourceCell have been completed.
                   // That is, we have:
                   //   1) Synchronized SourceCell's values with its counterpart in the
                   //      target tree.
                   //   2) Synchronized any new SourceCell subkeys (subkeys present
                   //      in SourceCell but not its counterpart) by creating
                   //      and copying them to the proper place in the target tree.
                   //
                   // What this means is that SourceCell's counterpart in the target tree
                   // (TargetCell) now has at least as many subkeys as SourceCell.
                   //
                   // This implies that if TargetCell now has more subkeys that SourceCell
                   // than some subkeys of TargetCell are not present in the source tree
                   // (probably because those keys were deleted from the source tree 
                   //  during the period between the previous sync and now).
                   //
                   // If such keys exist, then they must be delete them from TargetCell
                   // in order to complete the sync. We do this below.
                   //

                   TargetCell = (PCM_KEY_NODE)HvGetCell(CmpTargetHive, Frame->TargetCell);
                    if( TargetCell == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        HvReleaseCell(CmpSourceHive, Frame->SourceCell);
                        goto CopyEnd;
                    }

                   //
                   // Does TargetCell have more subkeys than SourceCell?
                   //

                   if((TargetCell->SubKeyCounts[Stable] + 
                       TargetCell->SubKeyCounts[Volatile]) >

                      (SourceCell->SubKeyCounts[Stable] + 

                       // We only count the volatile keys if we are actually
                       // syncing them. Note, however, that we always use
                       // the volatile counts in TargetCell since we may
                       // be syncing to a volatile tree where all keys are volatile.
                       
                       (CopyVolatile ? SourceCell->SubKeyCounts[Volatile] : 0)))  
                           
                   {
#if DEBUG_TREE_SYNC
                      CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CONFIG: SubKey Deletion from Source Cell #%lu.\n", 
                               Frame->SourceCell));
#endif

                      //
                      // Delete what should be deleted from TargetCell
                      //

                      CmpSyncSubKeysAfterDelete(CmpSourceHive,
                                                SourceCell, 
                                                CmpTargetHive,
                                                TargetCell,
                                                NameBuffer);
                   }                                      
                   //
                   // release target cell as we don't need it anymore
                   //
                   HvReleaseCell(CmpTargetHive, Frame->TargetCell);
                }
                //
                // release the source cell
                //
                HvReleaseCell(CmpSourceHive, Frame->SourceCell);
                break;
            } else {
                //
                // release the source cell
                //
                HvReleaseCell(CmpSourceHive, Frame->SourceCell);
            }
                                                
            if (TreeSync) {

               //
               // For a sync, we want to check if the current child (subkey)
               // of SourceCell is also a child of TargetCell - i.e. if
               // the subkey in question has a counterpart in the target tree.
               //
               // There is no guarantee that the counterpart's index number
               // will be the same so we must perform this check using
               // the subkey name.
               //

               //
               // Get the name of the current child
               //
                     
               SourceChildCell = (PCM_KEY_NODE)HvGetCell(CmpSourceHive,                                                               
                                                         SourceChild);                                         
                     
                if( SourceChildCell == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    //
                    goto CopyEnd;
                }
               CmpInitializeKeyNameString(SourceChildCell,
                                          &KeyName, 
                                          NameBuffer);                     

               //
               // Try to find the current child's counterpart in
               // in the target tree using the child's name.
               //
                     
                TempNode = (PCM_KEY_NODE)HvGetCell(CmpTargetHive,Frame->TargetCell);
                if( TempNode == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    //
                    HvReleaseCell(CmpSourceHive,SourceChild);                                         
                    goto CopyEnd;
                }

               NewSubKey = CmpFindSubKeyByName(CmpTargetHive,
                                               TempNode,
                                               &KeyName);
                                   
               // release the temporary node
               HvReleaseCell(CmpTargetHive,Frame->TargetCell);
                     
               if (NewSubKey != HCELL_NIL) {

                  //
                  // Found it, the current child (subkey) has a counterpart
                  // in the target tree. Thus, we just need to check if 
                  // the counterpart's values are out of date and should
                  // be updated.
                  //

                  TargetChildCell = (PCM_KEY_NODE)HvGetCell(CmpTargetHive,
                                                            NewSubKey);
                    if( TargetChildCell == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        HvReleaseCell(CmpSourceHive,SourceChild);                                         
                        goto CopyEnd;
                    }
                        
                  //
                  // Check if the current subkey has been modified
                  // more recently than its target tree counterpart.
                  // When we are doing a tree merge, always override the target.
                  //
                        
                  if ( (CopyType == Merge) ||
                      ((TargetChildCell->LastWriteTime.QuadPart) < 
                      (SourceChildCell->LastWriteTime.QuadPart))) {

                     //
                     // The counterpart is out of date. Its values
                     // must be synchronized with the current subkey.
                     //
#if DEBUG_TREE_SYNC
                     CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CONFIG: Target Refresh.\n"));
                     CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CONFIG: Source Cell %lu = %.*S\n", 
                              SourceChild,
                              KeyName.Length / sizeof(WCHAR),
                              KeyName.Buffer));
#endif

                     //
                     // Sync up the key's values, sd, & class                     
                     //

                     if(CopyType == Merge) {
                         if(!CmpMergeKeyValues(CmpSourceHive, SourceChild, SourceChildCell,
                                              CmpTargetHive, NewSubKey, TargetChildCell)) {
                            HvReleaseCell(CmpSourceHive,SourceChild);                                         
                            HvReleaseCell(CmpTargetHive,NewSubKey);
                            goto CopyEnd;                              
                         }
                     } else {
                         if(!CmpSyncKeyValues(CmpSourceHive, SourceChild, SourceChildCell,
                                              CmpTargetHive, NewSubKey, TargetChildCell)) {
                            HvReleaseCell(CmpSourceHive,SourceChild);                                         
                            HvReleaseCell(CmpTargetHive,NewSubKey);
                            goto CopyEnd;                              
                        }
                     }

                     //
                     // Sync the timestamps so that we don't do this again.
                     //

                     TargetChildCell->LastWriteTime.QuadPart =
                        SourceChildCell->LastWriteTime.QuadPart;
                        
                  }
                           
                  //
                  // If we are here, then the current subkey's target
                  // tree counterpart has been synchronized (or did not need
                  // to be). Transfer control to the code that will apply
                  // this function "recursively" to the current subkey in order
                  // to continue the sync.
                  //

                  HvReleaseCell(CmpSourceHive,SourceChild);                                         
                  HvReleaseCell(CmpTargetHive,NewSubKey);
                  goto NewKeyCreated;
                     
               }   

               //
               // If we are here, it means that the current child (subkey)
               // does not have a counterpart in the target tree. This means
               // we have encountered a new subkey in the source tree and must
               // create it in the target tree. 
               //
               // The standard copy code below will create this subkey. However,
               // we must also make sure that the tree under this subkey is properly
               // copied from source to target. The most efficient way of doing
               // this is to temporarily forget that we are in a sync operation
               // and merely perform a copy until the desired result is achieved.
               // 

#if DEBUG_TREE_SYNC
               CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CONFIG: New SubKey.\n"));
               CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CONFIG: Source Cell %lu = %.*S\n", 
                        SourceChild,
                        KeyName.Length / sizeof(WCHAR),
                        KeyName.Buffer));
#endif

               //
               // Indicate that we will just copy and not sync for a while
               //
                                             
               SyncNeedsTreeCopy = TRUE;                                          
               //
               // release this cell as we don't need it anymore
               //
               HvReleaseCell(CmpSourceHive,SourceChild);                                         
            }

            NewSubKey = CmpCopyKeyPartial(
                                          CmpSourceHive,
                                          SourceChild,
                                          CmpTargetHive,
                                          Frame->TargetCell,
                                          TRUE
                                          );

                
            if (NewSubKey == HCELL_NIL) {
               
               goto CopyEnd;
            }
                
            if ( !  CmpAddSubKey(
                                 CmpTargetHive,
                                 Frame->TargetCell,
                                 NewSubKey
                                 )
                 ) {

               goto CopyEnd;
            }

            //
            // Check if the sync operation determined that this
            // subtree should be copied
            //
                
            if(TreeSync && SyncNeedsTreeCopy) {

               //
               // We have just created a new key in the target tree
               // with the above code. However, since this is a sync,
               // the parent of that new key has not been created by our
               // code and thus may not have been modified at all before
               // the creation of the new key. But this parent now 
               // has a new child, and must therefore be marked as dirty.
               //
                   
               if (! CmpMarkKeyParentDirty(CmpTargetHive, NewSubKey)) {

                  goto CopyEnd;
               }
                   
               //
               // Record the stack level where we start the copy 
               // (and temporarily abandon the sync)
               // so that we can return to the sync operation when this
               // stack level is reached again (i.e. when the tree
               // under the current subkey is fully copied)
               //

               SyncTreeCopyStackStart = CmpCopyStackTop;

               //
               // Pretend that this is not a sync in order
               // to simply start copying
               //

               TreeSync = FALSE;
            }

NewKeyCreated:
                    
                    //
                    // We succeeded in copying/syncing the subkey, apply
                    // ourselves to it
                    //
                    CmpCopyStackTop++;

                    if (CmpCopyStackTop >= CmpCopyStackSize) {

                        //
                        // if we're here, it means that the tree
                        // we're trying to copy is more than 1024
                        // COMPONENTS deep (from 2048 to 256k bytes)
                        // we could grow the stack, but this is pretty
                        // severe, so return FALSE and fail the copy
                        //
                        
                        goto CopyEnd;
                    }

                    CmpCopyStack[CmpCopyStackTop].SourceCell =
                            SourceChild;

                    CmpCopyStack[CmpCopyStackTop].TargetCell =
                            NewSubKey;

                    goto Outer;

                    
        } // Inner: while

        if (CmpCopyStackTop == 0) {            
            Ret = TRUE;
            goto CopyEnd;
        }

        CmpCopyStackTop--;
        Frame = &(CmpCopyStack[CmpCopyStackTop]);

        //
        // We have just completed working at a certain stack level.
        // This is a good time to check if we need to resume a temporarily
        // suspended sync operation.
        //

        if(SyncNeedsTreeCopy && (CmpCopyStackTop == SyncTreeCopyStackStart))
        {
           //
           // We've been copying a tree for a sync. But now, that tree is fully
           // copied. So, let's resume the sync once again.
           //

           TreeSync = TRUE;               
           SyncNeedsTreeCopy = FALSE;
        }


        goto Inner;

    } // Outer: while

CopyEnd:

   if (NameBuffer) ExFreePool(NameBuffer);
   return Ret;
}


HCELL_INDEX
CmpCopyKeyPartial(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PHHIVE  TargetHive,
    HCELL_INDEX Parent,
    BOOLEAN CopyValues
    )
/*++

Routine Description:

    Copy a key body and all of its values, but NOT its subkeylist or
    subkey entries.  SubKeyList.Count will be set to 0.

Arguments:

    SourceHive - pointer to hive control structure for source

    SourceKeyCell - value entry being copied

    TargetHive - pointer to hive control structure for target

    Parent - parent value to set into newly created key body

    CopyValues - if FALSE value entries will not be copied, if TRUE, they will

Return Value:

    HCELL_INDEX - Cell of body of new key entry, or HCELL_NIL
        if some error.

--*/
{
    NTSTATUS                status;
    HCELL_INDEX             newkey = HCELL_NIL;
    HCELL_INDEX             newclass = HCELL_NIL;
    HCELL_INDEX             newsecurity = HCELL_NIL;
    HCELL_INDEX             newlist = HCELL_NIL;
    HCELL_INDEX             newvalue;
    BOOLEAN                 success = FALSE;
    ULONG                   i,Index;
    PCELL_DATA              psrckey = NULL;
    PCM_KEY_NODE            ptarkey = NULL;
    PCELL_DATA              psrclist = NULL;
    PCELL_DATA              ptarlist;
    HCELL_INDEX             security;
    HCELL_INDEX             class;
    ULONG                   classlength;
    ULONG                   count;
    ULONG                   Type;
    PCM_KEY_VALUE           pvalue;
#if DBG
    WCHAR                   *NameBuffer = NULL;
    UNICODE_STRING          ValueName;
    HCELL_INDEX             child;
#endif
    PSECURITY_DESCRIPTOR    SrcSecurityDescriptor;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyKeyPartial:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tSHive=%p SCell=%08lx\n",SourceHive,SourceKeyCell));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tTHive=%p\n",TargetHive));

#if DBG    
	NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_VALUE_NAME_LENGTH);
    if(!NameBuffer) {
        return HCELL_NIL;
    }
#endif //DBG
    //
    // get description of source
    //
    if (Parent == HCELL_NIL) {
        //
        // This is a root node we are creating, so don't make it volatile.
        //
        Type = Stable;
    } else {
        Type = HvGetCellType(Parent);
    }
    psrckey = HvGetCell(SourceHive, SourceKeyCell);
    if( psrckey == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        goto DoFinally;
    }
    security = psrckey->u.KeyNode.Security;
    class = psrckey->u.KeyNode.Class;
    classlength = psrckey->u.KeyNode.ClassLength;

    //
    // Allocate and copy the body
    //
    newkey = CmpCopyCell(SourceHive, SourceKeyCell, TargetHive, Type);
    if (newkey == HCELL_NIL) {
        goto DoFinally;
    }
    //
    // this cell was just allocated so it should be pinned; it's OK to release it here
    // as the view is not going anywhere
    //
    ASSERT_CELL_DIRTY(TargetHive, newkey);
    //
    // Allocate and copy class
    //
    if (classlength > 0) {
        newclass = CmpCopyCell(SourceHive, class, TargetHive, Type);
        if (newclass == HCELL_NIL) {
            goto DoFinally;
        }
    }

    //
    // Fill in the target body
    //
    ptarkey = (PCM_KEY_NODE)HvGetCell(TargetHive, newkey);
    if( ptarkey == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        goto DoFinally;
    }

    ptarkey->Class = newclass;
    ptarkey->Security = HCELL_NIL;
    ptarkey->SubKeyLists[Stable] = HCELL_NIL;
    ptarkey->SubKeyCounts[Stable] = 0;
	ptarkey->SubKeyCounts[Volatile] = 0;
	ptarkey->SubKeyLists[Volatile] = HCELL_NIL;
    ptarkey->Parent = Parent;
    
    ptarkey->Flags = (psrckey->u.KeyNode.Flags & KEY_COMP_NAME);
    if (Parent == HCELL_NIL) {
        ptarkey->Flags |= KEY_HIVE_ENTRY + KEY_NO_DELETE;
    }

    //
    // Allocate and copy security
    //
    // Use the hash Luke !!!
    //
    if( CmpFindSecurityCellCacheIndex ((PCMHIVE)SourceHive,security,&Index) == FALSE ) {
        goto DoFinally;
    }

    SrcSecurityDescriptor = &(((PCMHIVE)SourceHive)->SecurityCache[Index].CachedSecurity->Descriptor);

    status = CmpAssignSecurityDescriptor(TargetHive,
                                         newkey,
                                         ptarkey,
                                         SrcSecurityDescriptor);
    if (!NT_SUCCESS(status)) {
        goto DoFinally;
    }

    //
    // Set up the value list
    //
    count = psrckey->u.KeyNode.ValueList.Count;

    //
    // initialize an Empty ValueList
    //
    ptarkey->ValueList.List = HCELL_NIL;
    ptarkey->ValueList.Count = 0;

    if ((count == 0) || (CopyValues == FALSE)) {
        success = TRUE;
    } else {

        psrclist = HvGetCell(SourceHive, psrckey->u.KeyNode.ValueList.List);
        if( psrclist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            goto DoFinally;
        }


        //
        // Copy the values
        //
        for (i = 0; i < count; i++) {

            newvalue = CmpCopyValue(
                            SourceHive,
                            psrclist->u.KeyList[i],
                            TargetHive,
                            Type
                            );

            if (newvalue == HCELL_NIL) {
                //
                // for cleanup purposes
                //
                newlist = ptarkey->ValueList.List;
                goto DoFinally;
            }

            pvalue = (PCM_KEY_VALUE)HvGetCell(TargetHive, newvalue);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated the cell
                // (i.e. the bin containing it should be PINNED into memory by now )
                //
                ASSERT( FALSE );
                //
                // for cleanup purposes
                //
                newlist = ptarkey->ValueList.List;
                goto DoFinally;
            }
            //
            // this cell was just allocated so it should be pinned; it's OK to release it here
            // as the view is not going anywhere
            //
            ASSERT_CELL_DIRTY(TargetHive, newvalue);
            HvReleaseCell(TargetHive, newvalue);

#if DBG
            //
            // get the name
            //
            CmpInitializeValueNameString(pvalue,&ValueName,NameBuffer);


            //
            // find out the index where we should insert this 
            // this is a special treatment for the case when we copy form and old hive (not sorted)
            // into a new format one (sorted)
            //
            if( CmpFindNameInList(TargetHive,&(ptarkey->ValueList),&ValueName,&Index,&child) == FALSE ) {
                //
                // we couldn't map a view inside the above call
                //
                //
                // for cleanup purposes
                //
                newlist = ptarkey->ValueList.List;
                goto DoFinally;
            }

            //
            // the value is not present in the list; we're about to add it!
            //
            ASSERT( child == HCELL_NIL );
            
            //
            // sanity validation : insert at the end
            //
            ASSERT( Index == i );

#endif //DBG

            if( !NT_SUCCESS( CmpAddValueToList(TargetHive,newvalue,i,Type,&(ptarkey->ValueList)) ) ) {
                //
                // for cleanup purposes
                //
                newlist = ptarkey->ValueList.List;
                if( newlist != HCELL_NIL ) {
                    ASSERT( i > 0 );
                    //
                    // free already copied values
                    //
                    ptarlist = HvGetCell(TargetHive, newlist);
                    if( ptarlist == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        // this shouldn't fail as we just allocated this cell
                        // (i.e. the bin should be PINNED into memory at this point)
                        //
                        ASSERT( FALSE );
                        goto DoFinally;
                    }
                    //
                    // this cell was just allocated so it should be pinned; it's OK to release it here
                    // as the view is not going anywhere
                    //
                    ASSERT_CELL_DIRTY(TargetHive, newlist);
                    HvReleaseCell(TargetHive, newlist);

                    for (; i > 0; i--) {
                        HvFreeCell(
                            TargetHive,
                            ptarlist->u.KeyList[i - 1]
                            );
                    }
                } else {
                    ASSERT( i == 0 );
                }

                goto DoFinally;
            }
            
        }
        success = TRUE;
    }

DoFinally:
    
#if DBG
    ASSERT( NameBuffer != NULL );
    ExFreePool(NameBuffer);
#endif //DBG
    
    if( psrclist != NULL ) {
        ASSERT(psrckey!= NULL ); 
        HvReleaseCell(SourceHive, psrckey->u.KeyNode.ValueList.List);
    }

    if( psrckey != NULL ) {
        HvReleaseCell(SourceHive, SourceKeyCell);
    }

    if( ptarkey != NULL ) {
		ASSERT( newkey != HCELL_NIL );
        HvReleaseCell(TargetHive, newkey);
    }
    
    if (success == FALSE) {
        if (newlist != HCELL_NIL) {
            HvFreeCell(TargetHive, newlist);
        }

        if (newsecurity != HCELL_NIL) {
            HvFreeCell(TargetHive, newsecurity);
        }

        if (newclass != HCELL_NIL) {
            HvFreeCell(TargetHive, newclass);
        }

        if (newkey != HCELL_NIL) {
            HvFreeCell(TargetHive, newkey);
        }

        return HCELL_NIL;

    } else {

        return newkey;
    }
}


HCELL_INDEX
CmpCopyValue(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceValueCell,
    PHHIVE  TargetHive,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Copy a value entry.  Copies the body of a value entry and the
    data.  Returns cell of new value entry.

Arguments:

    SourceHive - pointer to hive control structure for source

    SourceValueCell - value entry being copied

    TargetHive - pointer to hive control structure for target

    Type - storage type to allocate for target (stable or volatile)

Return Value:

    HCELL_INDEX - Cell of body of new value entry, or HCELL_NIL
        if some error.

--*/
{
    HCELL_INDEX newvalue;
    HCELL_INDEX newdata;
    PCELL_DATA  pvalue;
    ULONG       datalength;
    HCELL_INDEX olddata;
    ULONG       tempdata;
    BOOLEAN     small;
    HCELL_INDEX CellToRelease = HCELL_NIL;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyValue:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tSHive=%p SCell=%08lx\n",SourceHive,SourceValueCell));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tTargetHive=%p\n",TargetHive));

    ASSERT( TargetHive->ReleaseCellRoutine == NULL );

    //
    // get source data
    //
    pvalue = HvGetCell(SourceHive, SourceValueCell);
    if( pvalue == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return HCELL_NIL;
    }
    small = CmpIsHKeyValueSmall(datalength, pvalue->u.KeyValue.DataLength);
    olddata = pvalue->u.KeyValue.Data;

    //
    // Copy body
    //
    newvalue = CmpCopyCell(SourceHive, SourceValueCell, TargetHive, Type);
    if (newvalue == HCELL_NIL) {
        HvReleaseCell(SourceHive, SourceValueCell);
        return HCELL_NIL;
    }

    //
    // Copy data (if any)
    //
    if (datalength > 0) {

        if (datalength > CM_KEY_VALUE_SMALL) {

            if( (CmpIsHKeyValueBig(SourceHive,datalength) == TRUE) ||
                (CmpIsHKeyValueBig(TargetHive,datalength) == TRUE)
                ) {
                PCELL_DATA  Buffer;
                BOOLEAN     BufferAllocated;
                HCELL_INDEX CellToRelease2 = HCELL_NIL;
                //
                // get the data from source, regardless of the size
                //
                if( CmpGetValueData(SourceHive,&(pvalue->u.KeyValue),&datalength,&Buffer,&BufferAllocated,&CellToRelease2) == FALSE ) {
                    //
                    // insufficient resources; return NULL
                    //
                    ASSERT( BufferAllocated == FALSE );
                    ASSERT( Buffer == NULL );
                    HvFreeCell(TargetHive, newvalue);
                    HvReleaseCell(SourceHive, SourceValueCell);
                    return HCELL_NIL;
                }
                //
                // we ignore celltorelease because we have specifically set the releae routine to NULL
                //

                //
                // allocate a new value data in the target hive (regardless of the size)
                // and copy the data onto it.
                //
                if( !NT_SUCCESS(CmpSetValueDataNew(TargetHive,Buffer,datalength,Type,newvalue,&newdata)) ) {
                    //
                    // We have bombed out loading user data, clean up and exit.
                    //
                    if( BufferAllocated == TRUE ) {
                        ExFreePool( Buffer );
                    }
                    HvFreeCell(TargetHive, newvalue);
                    HvReleaseCell(SourceHive, SourceValueCell);
                    if( CellToRelease2 != HCELL_NIL ) {
                        HvReleaseCell(SourceHive, CellToRelease2);
                    }
                    return HCELL_NIL;
                }

                //
                // free the source buffer
                //
                if( BufferAllocated == TRUE ) {
                    ExFreePool( Buffer );
                }
                if( CellToRelease2 != HCELL_NIL ) {
                    HvReleaseCell(SourceHive, CellToRelease2);
                }

            } else {
                //
                // there's data, normal size, or none of the hives support 
                // bigdata cells, so do standard copy
                //
                newdata = CmpCopyCell(SourceHive, olddata, TargetHive, Type);
            }

            if (newdata == HCELL_NIL) {
                HvFreeCell(TargetHive, newvalue);
                HvReleaseCell(SourceHive, SourceValueCell);
                return HCELL_NIL;
            }

            pvalue = HvGetCell(TargetHive, newvalue);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated the cell
                // (i.e. it should be PINNED into memory at this point)
                //
                ASSERT( FALSE );
                HvFreeCell(TargetHive, newvalue);
                HvReleaseCell(SourceHive, SourceValueCell);
                CmpFreeValueData(TargetHive,newdata,datalength);
                return HCELL_NIL;
            }

            pvalue->u.KeyValue.Data = newdata;
            pvalue->u.KeyValue.DataLength = datalength;

        } else {

            //
            // the data is small, but may be stored in either large or
            // small format for historical reasons
            //
            if (small) {

                //
                // data is already small, so just do a body to body copy
                //
                tempdata = pvalue->u.KeyValue.Data;

            } else {

                //
                // data is stored externally in old cell, will be internal in new
                //
                CellToRelease = pvalue->u.KeyValue.Data;
                pvalue = HvGetCell(SourceHive, pvalue->u.KeyValue.Data);
                if( pvalue == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    //
                    HvFreeCell(TargetHive, newvalue);
                    HvReleaseCell(SourceHive, SourceValueCell);
                    return HCELL_NIL;
                }
                tempdata = *((PULONG)pvalue);
            }
            pvalue = HvGetCell(TargetHive, newvalue);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated the cell
                // (i.e. it should be PINNED into memory at this point)
                //
                ASSERT( FALSE );
                HvFreeCell(TargetHive, newvalue);
                HvReleaseCell(SourceHive, SourceValueCell);
                if( CellToRelease != HCELL_NIL ) {
                    HvReleaseCell(SourceHive, CellToRelease);
                }
                return HCELL_NIL;
            }
            pvalue->u.KeyValue.Data = tempdata;
            pvalue->u.KeyValue.DataLength =
                datalength + CM_KEY_VALUE_SPECIAL_SIZE;

            if( CellToRelease != HCELL_NIL ) {
                HvReleaseCell(SourceHive, CellToRelease);
            }
        }
    }

    HvReleaseCell(SourceHive, SourceValueCell);
    return newvalue;
}

HCELL_INDEX
CmpCopyCell(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceCell,
    PHHIVE  TargetHive,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Copy SourceHive.SourceCell to TargetHive.TargetCell.

Arguments:

    SourceHive - pointer to hive control structure for source

    SourceCell - index of cell to copy from

    TargetHive - pointer to hive control structure for target

    Type - storage type (stable or volatile) of new cell

Return Value:

    HCELL_INDEX of new cell, or HCELL_NIL if failure.

--*/
{
    PVOID   psource;
    PVOID   ptarget;
    ULONG   size;
    HCELL_INDEX newcell;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tSourceHive=%p SourceCell=%08lx\n",SourceHive,SourceCell));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tTargetHive=%p\n",TargetHive));

    psource = HvGetCell(SourceHive, SourceCell);
    if( psource == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return HCELL_NIL;
    }

    size = HvGetCellSize(SourceHive, psource);

    newcell = HvAllocateCell(TargetHive, size, Type,HCELL_NIL);
    if (newcell == HCELL_NIL) {
        HvReleaseCell(SourceHive, SourceCell);
        return HCELL_NIL;
    }

    ptarget = HvGetCell(TargetHive, newcell);
    if( ptarget == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen as we just allocated the cell
        // (i.e. it should be PINNED into memory at this point)
        //
        ASSERT( FALSE );
        HvFreeCell(TargetHive, newcell);
        HvReleaseCell(SourceHive, SourceCell);
        return HCELL_NIL;
    }

   
    RtlCopyMemory(ptarget, psource, size);

    HvReleaseCell(SourceHive, SourceCell);
    HvReleaseCell(TargetHive, newcell);

    return newcell;
}

BOOLEAN
CmpFreeKeyValues(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    PCM_KEY_NODE Node
    )
/*++

Routine Description:

   Free the cells associated with the value entries, the security descriptor,
   and the class of a particular key.   

Arguments:

   Hive        - The hive of the key in question
   Cell        - The cell of the key in question
   Node        - The key body of the key in question

Return Value:

   TRUE if successful, FALSE otherwise.

--*/
{    
    PCELL_DATA  plist;
    ULONG       i;

    ASSERT( Hive->ReleaseCellRoutine == NULL );
    //
    // Mark all the value-related cells dirty 
    //

    if (! CmpMarkKeyValuesDirty(Hive, Cell, Node)) {
        return FALSE;
    }
    
    //
    // Link nodes don't have things that we need to free
    //

    if (!(Node->Flags & KEY_HIVE_EXIT)) {

        //
        // First, free the value entries
        //
        if (Node->ValueList.Count > 0) {

            // Get value list
            plist = HvGetCell(Hive, Node->ValueList.List);
            if( plist == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just marked the cell dirty
                // (i.e. it should be PINNED into memory at this point)
                //
                ASSERT( FALSE );
                return FALSE;
            }

            // Free each value
            for (i = 0; i < Node->ValueList.Count; i++) {
                if( CmpFreeValue(Hive, plist->u.KeyList[i]) == FALSE ) {
                    //
                    // we couldn't map view inside call above
                    // this shouldn't happen as we just marked the values dirty
                    // (i.e. they should be PINNED into memory at this point)
                    //
                    ASSERT( FALSE );
                    return FALSE;
                }
            }

            // Free the value list
            HvFreeCell(Hive, Node->ValueList.List);
        }

        //
        // Make this key value-less
        //

        Node->ValueList.List = HCELL_NIL;
        Node->ValueList.Count = 0;

        //
        // Free the security descriptor
        //
        // we need to postpone that until we are sure we got the new one
        //CmpFreeSecurityDescriptor(Hive, Cell);

        //
        // Free the Class information
        //

        if (Node->ClassLength > 0) {
            HvFreeCell(Hive, Node->Class);
            Node->Class = HCELL_NIL;
            Node->ClassLength = 0;
        }
        
    }

    return TRUE;
}

BOOLEAN
CmpMergeKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    )
/*++

Routine Description:
    Merges the values from the two key-nodes provided.
    Rules for the merge:
    1. The target values are not touched!
    2. Only values from the source that are not present in the 
    target are taken into account by this routine. They are added
    to the target node value list "as they are".

Arguments:

   SourceHive     - Hive of the source key
   SourceKeyCell  - The source key's cell
   SourceKeyNode  - The source key's body
   
   TargetHive     - Hive of the target key
   TargetKeyCell  - The target key's cell
   TargetKeyNode  - The target key's body

Return Value:

   TRUE of successful, FALSE otherwise.

--*/
{
    NTSTATUS        status;    
    BOOLEAN         success = FALSE;    
    PCELL_DATA      psrclist;
    HCELL_INDEX     newvalue, newlist = HCELL_NIL,child;    
    ULONG           i, count, Type, ChildIndex;
    PCM_KEY_VALUE   poldvalue;
    WCHAR           *NameBuffer = NULL;
    UNICODE_STRING  ValueName;

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT( SourceHive->ReleaseCellRoutine == NULL );
    ASSERT( TargetHive->ReleaseCellRoutine == NULL );

    if(TargetKeyNode->MaxValueNameLen < SourceKeyNode->MaxValueNameLen) {
        TargetKeyNode->MaxValueNameLen = SourceKeyNode->MaxValueNameLen;
    }

    if(TargetKeyNode->MaxValueDataLen < SourceKeyNode->MaxValueDataLen) {
        TargetKeyNode->MaxValueDataLen = SourceKeyNode->MaxValueDataLen;
    }

    if(TargetKeyNode->ValueList.Count == 0) {
        //
        // No Values in Target, do a sync
        //
        return CmpSyncKeyValues(SourceHive, SourceKeyCell, SourceKeyNode, TargetHive, TargetKeyCell, TargetKeyNode);
    }
    //
    // Set up the value list
    //
    count = SourceKeyNode->ValueList.Count;

    if (count == 0) {

        // No values in source, no update to the list needed.
        success = TRUE;
    } else {        

        NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_VALUE_NAME_LENGTH);
        if(!NameBuffer) return FALSE;

        //
        // The type of the new cells will be the same as that
        // of the target cell.
        //

        Type = HvGetCellType(TargetKeyCell);    

        //
        // Reallocate the value list for target to fit the new size
        // Worst case: all values from the source node will be added 
        // to the target node
        //

        psrclist = HvGetCell(SourceHive, SourceKeyNode->ValueList.List);
        if( psrclist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            newlist = HCELL_NIL;
            goto EndValueMerge;
        }

        //
        // Copy the values
        //
        for (i = 0; i < count; i++) {

            poldvalue = (PCM_KEY_VALUE)HvGetCell(SourceHive, psrclist->u.KeyList[i]);
            if( poldvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;

                goto EndValueMerge;
            }
            
            //
            // get the name
            //
            CmpInitializeValueNameString(poldvalue,&ValueName,NameBuffer);


            //
            // check if this particular values doesn't exist in the target node already
            //
            if( CmpFindNameInList(TargetHive,&(TargetKeyNode->ValueList),&ValueName,&ChildIndex,&child) == FALSE ) {
                //
                // we couldn't map a view inside the above call
                //
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;

                goto EndValueMerge;
            }

            if( child == HCELL_NIL ) {
                //
                // sanity validation : insert at the end
                //
                ASSERT( ChildIndex == TargetKeyNode->ValueList.Count );

                //
                // No, it doesn't, so add it
                //
                newvalue = CmpCopyValue(
                                SourceHive,
                                psrclist->u.KeyList[i],
                                TargetHive,
                                Type
                                );

                if (newvalue == HCELL_NIL) {
                    //
                    // for cleanup purposes
                    //
                    newlist = TargetKeyNode->ValueList.List;
                    goto EndValueMerge;
                }

                if( !NT_SUCCESS( CmpAddValueToList(TargetHive,newvalue,ChildIndex,Type,&(TargetKeyNode->ValueList)) ) ) {
                    //
                    // for cleanup purposes
                    //
                    newlist = TargetKeyNode->ValueList.List;
                    goto EndValueMerge;
                }
            }
        }

        success = TRUE;
    }

EndValueMerge:
    if (NameBuffer) ExFreePool(NameBuffer);

    if (success == FALSE) {

        // Clean-up on failure
        // Revert to the original size
        
        //
        // unfortunatelly we cannot do that anymore as we have sorted the list
        //
    }

    return success;
}
    
BOOLEAN
CmpSyncKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    )
/*++

Routine Description:

    Synchronizes the value entries, security descriptor, and class of a 
    target key with that of a source key - ensuring that the keys are 
    identical with respect to the synchronized information.

Arguments:

   SourceHive     - Hive of the source key
   SourceKeyCell  - The source key's cell
   SourceKeyNode  - The source key's body
   
   TargetHive     - Hive of the target key
   TargetKeyCell  - The target key's cell
   TargetKeyNode  - The target key's body

Return Value:

   TRUE of successful, FALSE otherwise.

--*/
{
    NTSTATUS                status;    
    BOOLEAN                 success = FALSE;    
    PCELL_DATA              psrclist = NULL, ptarlist, psrcsecurity;
    HCELL_INDEX             newvalue, newlist = HCELL_NIL, newclass = HCELL_NIL;    
    ULONG                   i, count, Type, Index;
    PCM_KEY_VALUE           pvalue;
#if DBG
    WCHAR                   *NameBuffer = NULL;
    UNICODE_STRING          ValueName;
	HCELL_INDEX				child;
#endif //DBG

    PSECURITY_DESCRIPTOR    SrcSecurityDescriptor;
    HCELL_INDEX             OldSecurity,NewSecurity;    
    
    //
    // nobody is operating on the target hive
    //
    ASSERT( TargetHive->ReleaseCellRoutine == NULL );

    //
    // First, free the target key's values, sd, and class info.
    //

    if(!CmpFreeKeyValues(TargetHive, TargetKeyCell, TargetKeyNode))
       return FALSE;

#if DBG
    NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_VALUE_NAME_LENGTH);
    if(!NameBuffer) {
        return FALSE;
    }
#endif //DBG    
    //
    // Now, copy the values, class, & sd from the source cell
    //

    //
    // The type of the new cells will be the same as that
    // of the target cell.
    //

    Type = HvGetCellType(TargetKeyCell);    
    
    //
    // Allocate and copy class
    //
    if ((SourceKeyNode->ClassLength > 0) && (SourceKeyNode->Class != HCELL_NIL)) {
        newclass = CmpCopyCell(SourceHive, SourceKeyNode->Class, TargetHive, Type);
        if (newclass == HCELL_NIL) {
            goto EndValueSync;
        }
        
        // only if class is valid. Otherwise remains 0 (set by CmpFreeKeyValues)
        TargetKeyNode->ClassLength = SourceKeyNode->ClassLength;
    }

    //
    // Associate the new class with the target key
    // and prepare and security descriptor assignment.
    //

    TargetKeyNode->Class = newclass;

    //
    // Allocate and assign security
    //
    //
    // Use the hash Luke !!!
    //
    if( CmpFindSecurityCellCacheIndex ((PCMHIVE)SourceHive,SourceKeyNode->Security,&Index) == FALSE ) {
        goto EndValueSync;
    }


    SrcSecurityDescriptor = &(((PCMHIVE)SourceHive)->SecurityCache[Index].CachedSecurity->Descriptor);


    //
    // store it for later in case of error recovery
    //
    OldSecurity = TargetKeyNode->Security;
    TargetKeyNode->Security = HCELL_NIL;

    status = CmpAssignSecurityDescriptor(TargetHive,
                                         TargetKeyCell,
                                         TargetKeyNode,
                                         SrcSecurityDescriptor);
    if (!NT_SUCCESS(status)) {
        TargetKeyNode->Security = OldSecurity;
        goto EndValueSync;
    }

    NewSecurity = TargetKeyNode->Security;
    TargetKeyNode->Security = OldSecurity;
    if ((TargetKeyNode->Flags & KEY_HIVE_ENTRY) && ( NewSecurity != OldSecurity) ) {
        //
        // we need to play it safe here so we don't blow away the security list for entire hive.
        //
        PCM_KEY_SECURITY    NewSec;
        PCM_KEY_SECURITY    OldSec;
        PCM_KEY_SECURITY    LastSec;
        HCELL_INDEX         LastSecCell;

        NewSec = (PCM_KEY_SECURITY)HvGetCell(TargetHive,NewSecurity);
        if( NewSec == NULL ) {
            //
            // could not map view
            //
            goto EndValueSync;
        }

        OldSec = (PCM_KEY_SECURITY)HvGetCell(TargetHive,OldSecurity);
        if( OldSec == NULL ) {
            //
            // could not map view
            //
            HvReleaseCell(TargetHive,NewSecurity);
            goto EndValueSync;
        }

        LastSecCell = OldSec->Blink;
        LastSec = (PCM_KEY_SECURITY)HvGetCell(TargetHive,LastSecCell);
        if( LastSec == NULL ) {
            //
            // could not map view
            //
            HvReleaseCell(TargetHive,OldSecurity);
            HvReleaseCell(TargetHive,NewSecurity);
            goto EndValueSync;
        }

        if( !HvMarkCellDirty(TargetHive,OldSecurity) ||
            !HvMarkCellDirty(TargetHive,LastSecCell) ) {
            //
            // no log space
            //
            HvReleaseCell(TargetHive,LastSecCell);
            HvReleaseCell(TargetHive,OldSecurity);
            HvReleaseCell(TargetHive,NewSecurity);
            goto EndValueSync;
        }
        
        //
        // link old list to new security
        //
        NewSec->Flink = OldSecurity;
        NewSec->Blink = LastSecCell;
        OldSec->Blink = NewSecurity;
        LastSec->Flink = NewSecurity;

        HvReleaseCell(TargetHive,LastSecCell);
        HvReleaseCell(TargetHive,OldSecurity);
        HvReleaseCell(TargetHive,NewSecurity);

    }
    //
    // we need to play it safe here, to make sure we never end up having a key
    // with a NIL security cell
    //
    CmpFreeSecurityDescriptor(TargetHive, TargetKeyCell);
    TargetKeyNode->Security = NewSecurity;
    
    //
    // Set up the value list
    //
    count = SourceKeyNode->ValueList.Count;

    //
    // target ValueList is an emptylist; we shall add values to it.
    //
    TargetKeyNode->ValueList.List = HCELL_NIL;
    TargetKeyNode->ValueList.Count = 0;

	//
	// after sync we'll have the values from source
	//
	TargetKeyNode->MaxValueNameLen = SourceKeyNode->MaxValueNameLen;
	TargetKeyNode->MaxValueDataLen = SourceKeyNode->MaxValueDataLen;

    if (count == 0) {

        // No values in source, no list needed.

        success = TRUE;
    } else {        

        //
        // Do not allocate space for ValueList; CmpAddValueToList will do it
        //

        psrclist = HvGetCell(SourceHive, SourceKeyNode->ValueList.List);
        if( psrclist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            goto EndValueSync;
        }


        //
        // Copy the values
        //
        for (i = 0; i < count; i++) {

            newvalue = CmpCopyValue(
                            SourceHive,
                            psrclist->u.KeyList[i],
                            TargetHive,
                            Type
                            );

            if (newvalue == HCELL_NIL) {
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;
                goto EndValueSync;
            }

            pvalue = (PCM_KEY_VALUE)HvGetCell(TargetHive, newvalue);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated the cell
                // (i.e. the bin containing it should be PINNED into memory by now )
                //
                ASSERT( FALSE );
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;
                goto EndValueSync;
            }

#if DBG            
            //
            // get the name
            //
            CmpInitializeValueNameString(pvalue,&ValueName,NameBuffer);


            //
            // find out the index where we should insert this 
            // this is a special treatment for the case when we copy form and old hive (not sorted)
            // into a new format one (sorted)
            //
            if( CmpFindNameInList(TargetHive,&(TargetKeyNode->ValueList),&ValueName,&Index,&child) == FALSE ) {
                //
                // we couldn't map a view inside the above call
                //
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;
                goto EndValueSync;
            }

            //
            // the value is not present in the list; we're about to add it!
            //
            ASSERT( child == HCELL_NIL );
            
            //
            // sanity validation : insert at the end
            //
            ASSERT( Index == i );
#endif //DBG            

            if( !NT_SUCCESS( CmpAddValueToList(TargetHive,newvalue,i,Type,&(TargetKeyNode->ValueList)) ) ) {
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;

                if( newlist != HCELL_NIL ) {
                    //
                    // Delete all the copied values on an error.
                    //
                    ptarlist = HvGetCell(TargetHive, newlist);
                    if( ptarlist == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        // this shouldn't fail as we just allocated this cell
                        // (i.e. the bin should be PINNED into memory at this point)
                        //
                        ASSERT( FALSE );
                        goto EndValueSync;
                    }
                    for (; i > 0; i--) {
                        HvFreeCell(
                            TargetHive,
                            ptarlist->u.KeyList[i - 1]
                            );
                    }
                }
                goto EndValueSync;
            }

        }

        success = TRUE;
    }

EndValueSync:

#if DBG
    ASSERT( NameBuffer != NULL );
    ExFreePool(NameBuffer);
#endif //DBG

    if( psrclist != NULL ) {
        HvReleaseCell(SourceHive, SourceKeyNode->ValueList.List);
    }

    if (success == FALSE) {

        // Clean-up on failure

        if (newlist != HCELL_NIL) {
            HvFreeCell(TargetHive, newlist);
        }

        if (newclass != HCELL_NIL) {
            HvFreeCell(TargetHive, newclass);
        }

    }

    return success;
}

VOID 
CmpInitializeKeyNameString(PCM_KEY_NODE Cell, 
                           PUNICODE_STRING KeyName,
                           WCHAR *NameBuffer
                           )
/*++

Routine Description:

   Initializes a UNICODE_STRING with the name of a given key.
   
   N.B. The initialized string's buffer is not meant
         to be modified.   

Arguments:

   Cell       - The body of the key in question
   KeyName    - The UNICODE_STRING to initialize
   NameBuffer - A buffer REG_MAX_KEY_NAME_LENGTH bytes in size 
                that will possibly be used as the UNICODE_STRING's 
                buffer.

Return Value:

   NONE.

--*/
{                        
   // is the name stored in compressed form?

   if(Cell->Flags & KEY_COMP_NAME) {

      // Name is compressed. 

      // Get the uncompressed length.
                        
      KeyName->Length = CmpCompressedNameSize(Cell->Name,
                                              Cell->NameLength);
                        
      // Decompress the name into a buffer.

      CmpCopyCompressedName(NameBuffer, 
                            REG_MAX_KEY_NAME_LENGTH,
                            Cell->Name,                                            
                            Cell->NameLength);

      //
      // Use the decompression buffer as the string buffer
      //
                        
      KeyName->Buffer = NameBuffer;      
      KeyName->MaximumLength = REG_MAX_KEY_NAME_LENGTH;

   } else {

      //
      // Name is not compressed. Just use the name string 
      // from the key buffer as the string buffer.
      //
                        
      KeyName->Length = Cell->NameLength;                        
      KeyName->Buffer = Cell->Name;
      KeyName->MaximumLength = (USHORT)Cell->MaxNameLen;
                     
   }                                             
}

VOID 
CmpInitializeValueNameString(PCM_KEY_VALUE Cell, 
                             PUNICODE_STRING ValueName,
                             WCHAR *NameBuffer
                             )
/*
Routine Description:

   Initializes a UNICODE_STRING with the name of a given value key.
   
   N.B. The initialized string's buffer is not meant
         to be modified.   

Arguments:

   Cell       - The value key in question
   ValueName    - The UNICODE_STRING to initialize
   NameBuffer - A buffer REG_MAX_KEY_NAME_LENGTH bytes in size 
                that will possibly be used as the UNICODE_STRING's 
                buffer.

Return Value:

   NONE.
*/

{                        
   // is the name stored in compressed form?

   if(Cell->Flags & VALUE_COMP_NAME) {

      // Name is compressed. 

      // Get the uncompressed length.
                        
      ValueName->Length = CmpCompressedNameSize(Cell->Name,
                                              Cell->NameLength);
                        
      // Decompress the name into a buffer.

      CmpCopyCompressedName(NameBuffer, 
                            REG_MAX_KEY_VALUE_NAME_LENGTH,
                            Cell->Name,                                            
                            Cell->NameLength);

      //
      // Use the decompression buffer as the string buffer
      //
                        
      ValueName->Buffer = NameBuffer;      
      ValueName->MaximumLength = REG_MAX_KEY_VALUE_NAME_LENGTH;

   } else {

      //
      // Name is not compressed. Just use the name string 
      // from the ValueName buffer as the string buffer.
      //
                        
      ValueName->Length = Cell->NameLength;                        
      ValueName->Buffer = Cell->Name;
      ValueName->MaximumLength = ValueName->Length;
                     
   }                                             
}

BOOLEAN
CmpSyncSubKeysAfterDelete(PHHIVE SourceHive,
                          PCM_KEY_NODE SourceCell,
                          PHHIVE TargetHive,
                          PCM_KEY_NODE TargetCell,
                          WCHAR *NameBuffer)
/*++

Routine Description:

   This routine makes sure that any subkeys present in the target key
   but not present in the source key are deleted from the target key
   along with any trees under those subkeys.
   
   This routine is useful for synchronizing key deletion changes
   in a source cell with a target cell. It is used in this way
   from CmpCopySyncTree.
   
   NOTE: It is assumed that no open handles are held for the keys
         being deleted. If this is not so, registry in-memory
         data structures may become corrupted.
   
Arguments:

   SourceHive  - The hive of the source key
   SourceCell  - The body of the source key
   TargetHive  - The hive of the target key
   TargetCell  - The body of the target key
   NameBuffer  - A buffer REG_MAX_KEY_NAME_LENGTH bytes in size

Return Value:

   TRUE if successful, FALSE otherwise.

--*/
{
   HCELL_INDEX TargetSubKey, SourceSubKey;
   ULONG i = 0;   
   PCM_KEY_NODE SubKeyCell;
   UNICODE_STRING SubKeyName;

   //
   // Run through all of the target cell's subkeys
   //

   while((TargetSubKey = CmpFindSubKeyByNumber(
                                               TargetHive,
                                               TargetCell,
                                               i)) != HCELL_NIL)
   {
      
      //
      // Check if the current subkey has a counterpart
      // subkey of the source cell.
      // (Note that we use similar techniques as in the code
      //  of CmpCopySyncTree2)
      //

      SubKeyCell = (PCM_KEY_NODE)HvGetCell(TargetHive, TargetSubKey);
        if( SubKeyCell == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            return FALSE;
        }

      CmpInitializeKeyNameString(SubKeyCell,
                                 &SubKeyName,
                                 NameBuffer);

      SourceSubKey = CmpFindSubKeyByName(SourceHive, 
                                         SourceCell,
                                         &SubKeyName);

      if(SourceSubKey == HCELL_NIL)
      { 
         //
         // The current subkey has no counterpart, 
         // it must therefore be deleted from the target cell.
         //

#if DEBUG_TREE_SYNC
         CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CONFIG: SubKey Deletion of %.*S\n",                         
               SubKeyName.Length / sizeof(WCHAR),
               SubKeyName.Buffer));         
#endif
         
         if(SubKeyCell->SubKeyCounts[Stable] + SubKeyCell->SubKeyCounts[Volatile])
         {
            // The subkey we are deleting has subkeys - use delete tree to get rid of them            

            CmpDeleteTree(TargetHive, TargetSubKey);

#if DEBUG_TREE_SYNC
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CONFIG: Delete TREE performed.\n"));
#endif
         }
      
         //
         // release this cell as we don't need it anymore
         //
         HvReleaseCell(TargetHive, TargetSubKey);
         
         // The subkey we are deleting is now a leaf (or has always been one), 
         // just delete it.

         if(!NT_SUCCESS(CmpFreeKeyByCell(TargetHive, TargetSubKey, TRUE)))
         {
            return FALSE;
         }
         
         //
         // We have deleted a subkey, so *i* does not need to get incremented
         // here because it now refers to the next subkey.
         //         
      }
      else
      {
         //
         // Counterpart found. No deletion necessary. Move on to the next subkey
         //

         i++;

         //
         // release this cell as we don't need it anymore
         //
         HvReleaseCell(TargetHive, TargetSubKey);

      }
   }
         
   return TRUE;
}


BOOLEAN
CmpMarkKeyValuesDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    PCM_KEY_NODE Node
    )
/*++

Routine Description:

   
   Marks the cells associated with a key's value entries, security descriptor,
   and class information as dirty.
                        
Arguments:

   Hive     - The hive of the key in question
   Cell     - The cell of the key in question
   Node     - The body of the key in question


Return Value:

   TRUE if successful, FALSE otherwise.
   
   A failure probably indicates that no log space was available.

--*/
{    
    PCELL_DATA  plist, security, pvalue;
    ULONG       i, realsize;    

    ASSERT( Hive->ReleaseCellRoutine == NULL );

    if (Node->Flags & KEY_HIVE_EXIT) {

        //
        // If this is a link node, we are done.  Link nodes never have
        // classes, values, subkeys, or security descriptors.  Since
        // they always reside in the master hive, they're always volatile.
        //
        return(TRUE);
    }

    //
    // mark cell itself
    //
    if (! HvMarkCellDirty(Hive, Cell)) {
        return FALSE;
    }

    //
    // Mark the class
    //
    if (Node->Class != HCELL_NIL) {
        if (! HvMarkCellDirty(Hive, Node->Class)) {
            return FALSE;
        }
    }

    //
    // Mark security
    //
    if (Node->Security != HCELL_NIL) {
        if (! HvMarkCellDirty(Hive, Node->Security)) {
            return FALSE;
        }

        security = HvGetCell(Hive, Node->Security);
        if( security == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just marked the cell dirty
            // (dirty == PINNED in memory).
            //
            ASSERT( FALSE );
            return FALSE;
        }
        if (! (HvMarkCellDirty(Hive, security->u.KeySecurity.Flink) &&
               HvMarkCellDirty(Hive, security->u.KeySecurity.Blink)))
        {
            return FALSE;
        }
    }

    //
    // Mark the value entries and their data
    //
    if (Node->ValueList.Count > 0) {

        // Value list
        if (! HvMarkCellDirty(Hive, Node->ValueList.List)) {
            return FALSE;
        }
        plist = HvGetCell(Hive, Node->ValueList.List);
        if( plist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just marked the cell dirty
            // (dirty == PINNED in memory).
            //
            ASSERT( FALSE );
            return FALSE;
        }

        for (i = 0; i < Node->ValueList.Count; i++) {
            if (! HvMarkCellDirty(Hive, plist->u.KeyList[i])) {
                return FALSE;
            }

            pvalue = HvGetCell(Hive, plist->u.KeyList[i]);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just marked the cell dirty
                // (dirty == PINNED in memory).
                //
                ASSERT( FALSE );
                return FALSE;
            }
            
            if( !CmpMarkValueDataDirty(Hive,&(pvalue->u.KeyValue)) ) {
                return FALSE;
            }
            
        }
    }

    return TRUE;
}

BOOLEAN
CmpMarkKeyParentDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

   Marks the parent of a given key and the parent's subkey list as dirty.
   
Arguments:

   Hive     - The hive of the key in question.
   Cell     - The cell of the key in question.


Return Value:

   TRUE if successful, FALSE otherwise.
   
   A failure probably indicates that no log space was available.

--*/
{

    PCELL_DATA ptarget;

    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // Map in the target
    //
    ptarget = HvGetCell(Hive, Cell);    
    if( ptarget == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }


    if (ptarget->u.KeyNode.Flags & KEY_HIVE_ENTRY) {

        //
        // if this is an entry node, we are done.  our parent will
        // be in the master hive (and thus volatile)
        //
        return TRUE;
    }

    //
    // Mark the parent's Subkey list
    //
    if (! CmpMarkIndexDirty(Hive, ptarget->u.KeyNode.Parent, Cell)) {
        return FALSE;
    }

    //
    // Mark the parent
    //
    if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.Parent)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmsysini.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmsysini.c

Abstract:

    This module contains init support for the configuration manager,
    particularly the registry.

Author:

    Bryan M. Willman (bryanwi) 26-Aug-1991

Revision History:

    Elliot Shmukler (t-ellios) 24-Aug-1998

         Added CmpSaveBootControlSet & CmpDeleteCloneTree in order to
         perform some of the LKG work that has been moved into the kernel.
         Modified system initialization to permit operation and LKG control
         set saves without a CurrentControlSet clone.

--*/

#include    "cmp.h"
#include    "arc.h"
#pragma hdrstop
#include    "arccodes.h"

typedef struct _VERSION_DATA_KEY
{
    PWCHAR InitialKeyPath;

    PWCHAR AdditionalKeyPath;

} VERSION_DATA_KEY, *PVERSION_DATA_KEY;

VERSION_DATA_KEY VersionDataKeys[] =
{
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft", NULL },
#if defined(_WIN64)
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node", L"Microsoft" },
#endif
    { NULL, NULL }
} ;

//
// paths
//

#define INIT_REGISTRY_MASTERPATH   L"\\REGISTRY\\"

extern  PKPROCESS   CmpSystemProcess;
extern  ERESOURCE   CmpRegistryLock;
extern  ERESOURCE   CmpKcbLock;
extern  FAST_MUTEX  CmpPostLock;
extern  FAST_MUTEX  CmpWriteLock;

extern  BOOLEAN     CmFirstTime;
extern  BOOLEAN HvShutdownComplete;

//
// List of MACHINE hives to load.
//
extern  HIVE_LIST_ENTRY CmpMachineHiveList[];
extern  UCHAR           SystemHiveFullPathBuffer[];
extern  UNICODE_STRING  SystemHiveFullPathName;

#define SYSTEM_PATH L"\\registry\\machine\\system"

//
// special keys for backwards compatibility with 1.0
//
#define HKEY_PERFORMANCE_TEXT       (( HANDLE ) (ULONG_PTR)((LONG)0x80000050) )
#define HKEY_PERFORMANCE_NLSTEXT    (( HANDLE ) (ULONG_PTR)((LONG)0x80000060) )

extern UNICODE_STRING  CmpSystemFileName;
extern UNICODE_STRING  CmSymbolicLinkValueName;
extern UNICODE_STRING  CmpLoadOptions;         // sys options from FW or boot.ini
extern PWCHAR CmpProcessorControl;
extern PWCHAR CmpControlSessionManager;

//
//
// Object type definition support.
//
// Key objects (CmpKeyObjectType) represent open instances of keys in the
// registry.  They do not have object names, rather, their names are
// defined by the registry backing store.
//

//
// Master Hive
//
//  The KEY_NODEs for \REGISTRY, \REGISTRY\MACHINE, and \REGISTRY\USER
//  are stored in a small memory only hive called the Master Hive.
//  All other hives have link nodes in this hive which point to them.
//
extern   PCMHIVE CmpMasterHive;
extern   BOOLEAN CmpNoMasterCreates;    // Init False, Set TRUE after we're done to
                                        // prevent random creates in the
                                        // master hive, which is not backed
                                        // by a file.

extern   LIST_ENTRY  CmpHiveListHead;   // List of CMHIVEs


//
// Addresses of object type descriptors:
//

extern   POBJECT_TYPE CmpKeyObjectType;

//
// Define attributes that Key objects are not allowed to have.
//

#define CMP_KEY_INVALID_ATTRIBUTES  (OBJ_EXCLUSIVE  |\
                                     OBJ_PERMANENT)


//
// Global control values
//

//
// Write-Control:
//  CmpNoWrite is initially true.  When set this way write and flush
//  do nothing, simply returning success.  When cleared to FALSE, I/O
//  is enabled.  This change is made after the I/O system is started
//  AND autocheck (chkdsk) has done its thing.
//

extern BOOLEAN CmpNoWrite;

//
// Buffer used for quick-stash transfers in CmSetValueKey
//
extern PUCHAR  CmpStashBuffer;
extern ULONG   CmpStashBufferSize;


//
// set to true if disk full when trying to save the changes made between system hive loading and registry initalization
//
extern BOOLEAN CmpCannotWriteConfiguration;
//
// Global "constants"
//

extern   const UNICODE_STRING nullclass;
extern BOOLEAN CmpTrackHiveClose;

//
// Private prototypes
//
VOID
CmpCreatePredefined(
    IN HANDLE Root,
    IN PWSTR KeyName,
    IN HANDLE PredefinedHandle
    );

VOID
CmpCreatePerfKeys(
    VOID
    );

BOOLEAN
CmpLinkKeyToHive(
    PWSTR   KeyPath,
    PWSTR   HivePath
    );

NTSTATUS
CmpCreateControlSet(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
CmpCloneControlSet(
    VOID
    );

NTSTATUS
CmpCreateObjectTypes(
    VOID
    );

BOOLEAN
CmpCreateRegistryRoot(
    VOID
    );

BOOLEAN
CmpCreateRootNode(
    IN PHHIVE   Hive,
    IN PWSTR    Name,
    OUT PHCELL_INDEX RootCellIndex
    );

VOID
CmpFreeDriverList(
    IN PHHIVE Hive,
    IN PLIST_ENTRY DriverList
    );

VOID
CmpInitializeHiveList(
    VOID
    );

BOOLEAN
CmpInitializeSystemHive(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
CmpInterlockedFunction (
    PWCHAR RegistryValueKey,
    VOID (*InterlockedFunction)(VOID)
    );

VOID
CmpConfigureProcessors (
    VOID
    );

#if i386
VOID
KeOptimizeProcessorControlState (
    VOID
    );
#endif

NTSTATUS
CmpAddDockingInfo (
    IN HANDLE Key,
    IN PROFILE_PARAMETER_BLOCK * ProfileBlock
    );

NTSTATUS
CmpAddAliasEntry (
    IN HANDLE IDConfigDB,
    IN PROFILE_PARAMETER_BLOCK * ProfileBlock,
    IN ULONG  ProfileNumber
    );

NTSTATUS CmpDeleteCloneTree(VOID);

VOID
CmpDiskFullWarning(
    VOID
    );

VOID
CmpLoadHiveThread(
    IN PVOID StartContext
    );

NTSTATUS
CmpSetupPrivateWrite(
    PCMHIVE             CmHive
    );

NTSTATUS
CmpSetSystemValues(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
CmpSetNetworkValue(
    IN PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    );

VOID
CmpInitCallback(VOID);

VOID
CmpMarkCurrentValueDirty(
                         IN PHHIVE SystemHive,
                         IN HCELL_INDEX RootCell
                         );

#ifdef ALLOC_PRAGMA
NTSTATUS
CmpHwprofileDefaultSelect (
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse,
    IN  PVOID Context
    );
#pragma alloc_text(INIT,CmInitSystem1)
#pragma alloc_text(INIT,CmIsLastKnownGoodBoot)
#pragma alloc_text(INIT,CmpHwprofileDefaultSelect)
#pragma alloc_text(INIT,CmpCreateControlSet)
#pragma alloc_text(INIT,CmpCloneControlSet)
#pragma alloc_text(INIT,CmpCreateObjectTypes)
#pragma alloc_text(INIT,CmpCreateRegistryRoot)
#pragma alloc_text(INIT,CmpCreateRootNode)
#pragma alloc_text(INIT,CmpInitializeSystemHive)
#pragma alloc_text(INIT,CmGetSystemDriverList)
#pragma alloc_text(INIT,CmpFreeDriverList)
#pragma alloc_text(INIT,CmpSetSystemValues)
#pragma alloc_text(INIT,CmpSetNetworkValue)
#pragma alloc_text(PAGE,CmpInitializeHiveList)
#pragma alloc_text(PAGE,CmpLinkHiveToMaster)
#pragma alloc_text(PAGE,CmpSetVersionData)
#pragma alloc_text(PAGE,CmBootLastKnownGood)
#pragma alloc_text(PAGE,CmpSaveBootControlSet)
#pragma alloc_text(PAGE,CmpInitHiveFromFile)
#pragma alloc_text(PAGE,CmpLinkKeyToHive)
#pragma alloc_text(PAGE,CmpCreatePredefined)
#pragma alloc_text(PAGE,CmpCreatePerfKeys)
#pragma alloc_text(PAGE,CmpInterlockedFunction)
#pragma alloc_text(PAGE,CmpConfigureProcessors)
#pragma alloc_text(INIT,CmpAddDockingInfo)
#pragma alloc_text(INIT,CmpAddAliasEntry)
#pragma alloc_text(PAGE,CmpDeleteCloneTree)
#pragma alloc_text(PAGE,CmpSetupPrivateWrite)
#pragma alloc_text(PAGE,CmpLoadHiveThread)
#pragma alloc_text(PAGE,CmpMarkCurrentValueDirty)
#endif



BOOLEAN
CmInitSystem1(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function is called as part of phase1 init, after the object
    manager has been inited, but before IoInit.  It's purpose is to
    set up basic registry object operations, and transform data
    captured during boot into registry format (whether it was read
    from the SYSTEM hive file by the osloader or computed by recognizers.)
    After this call, Nt*Key calls work, but only part of the name
    space is available and any changes written must be held in
    memory.

    CmpMachineHiveList entries marked CM_PHASE_1 are available
    after return from this call, but writes must be held in memory.

    This function will:

        1.  Create the regisrty worker/lazy-write thread
        2.  Create the registry key object type
        4.  Create the master hive
        5.  Create the \REGISTRY node
        6.  Create a KEY object that refers to \REGISTRY
        7.  Create \REGISTRY\MACHINE node
        8.  Create the SYSTEM hive, fill in with data from loader
        9.  Create the HARDWARE hive, fill in with data from loader
       10.  Create:
                \REGISTRY\MACHINE\SYSTEM
                \REGISTRY\MACHINE\HARDWARE
                Both of which will be link nodes in the master hive.

    NOTE:   We do NOT free allocated pool in failure case.  This is because
            our caller is going to bugcheck anyway, and having the memory
            object to look at is useful.

Arguments:

    LoaderBlock - supplies the LoaderBlock passed in from the OSLoader.
        By looking through the memory descriptor list we can find the
        SYSTEM hive which the OSLoader has placed in memory for us.

Return Value:

    TRUE if all operations were successful, false if any failed.

    Bugchecks when something went wrong (CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,.....)

--*/
{
    HANDLE  key1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS    status;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PCMHIVE HardwareHive;
    PCMHIVE CloneHive;

    //
    // Set the mini NT flag if we are booting into Mini NT
    // environment
    //
    if (InitIsWinPEMode) {
        CmpMiniNTBoot = InitIsWinPEMode;

        //
        // On Remote boot client share the system hives
        //
        // NOTE : We can't assume exclusive access to WinPE
        // remote boot clients. We don't flush anything to
        // system hives in WinPE. All the system hives are
        // loaded in memory in scratch mode
        //
        CmpShareSystemHives = TRUE;
    }

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmInitSystem1\n"));

    //
    // Initialize Names of all registry paths.
    // This simply initializes unicode strings so we don't have to bother
    // with it later. This can not fail.
    //
    CmpInitializeRegistryNames();

    //
    // Compute registry global quota
    //
    CmpComputeGlobalQuotaAllowed();

    //
    // Initialize the hive list head
    //
    InitializeListHead(&CmpHiveListHead);
    ExInitializeFastMutex(&CmpHiveListHeadLock);

    //
    // Initialize the global registry resource
    //
    ExInitializeResourceLite(&CmpRegistryLock);

    //
    // Initialize the KCB tree mutex
    //
    ExInitializeResourceLite(&CmpKcbLock);

    //
    // Initialize the PostList mutex
    //
    ExInitializeFastMutex(&CmpPostLock);

    //
    // Initialize the Stash Buffer mutex
    //
    ExInitializeFastMutex(&CmpStashBufferLock);

    //
    // Initialize the Write mutex
    //
    ExInitializeFastMutex(&CmpWriteLock);

    //
    // Initialize the cache
    //
    CmpInitializeCache ();

    //
    // Initialize private allocator
    //
    CmpInitCmPrivateAlloc();

    //
    // Initialize callback module
    //
    CmpInitCallback();

    //
    // Save the current process to allow us to attach to it later.
    //
    CmpSystemProcess = &PsGetCurrentProcess()->Pcb;

    CmpLockRegistryExclusive();

    //
    // Create the Key object type.
    //
    status = CmpCreateObjectTypes();
    if (!NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: CmpCreateObjectTypes failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,1,status,0); // could not registrate with object manager
        return FALSE;
    }


    //
    // Create the master hive and initialize it.
    //
    status = CmpInitializeHive(&CmpMasterHive,
                HINIT_CREATE,
                HIVE_VOLATILE,
                HFILE_TYPE_PRIMARY,     // i.e. no logging, no alterate
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                0);
    if (!NT_SUCCESS(status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmInitSystem1: CmpInitializeHive(master) failed\n"));

        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,2,status,0); // could not initialize master hive

        return (FALSE);
    }

    //
    // try to allocate a stash buffer.  if we can't get 1 page this
    // early on, we're in deep trouble, so punt.
    //
    CmpStashBuffer = ExAllocatePoolWithTag(PagedPool, PAGE_SIZE,CM_STASHBUFFER_TAG);
    if (CmpStashBuffer == NULL) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,3,0,0); // odds against this are huge
        return FALSE;
    }
    CmpStashBufferSize = PAGE_SIZE;

    //
    // Create the \REGISTRY node
    //
    if (!CmpCreateRegistryRoot()) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: CmpCreateRegistryRoot failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,4,0,0); // could not create root of the registry
        return FALSE;
    }

    //
    // --- 6. Create \REGISTRY\MACHINE and \REGISTRY\USER nodes ---
    //

    //
    // Get default security descriptor for the nodes we will create.
    //
    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryMachineName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        SecurityDescriptor
        );

    if (!NT_SUCCESS(status = NtCreateKey(
                        &key1,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes,
                        0,
                        (PUNICODE_STRING)&nullclass,
                        0,
                        NULL
        )))
    {
        ExFreePool(SecurityDescriptor);
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: NtCreateKey(MACHINE) failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,5,status,0); // could not create HKLM
        return FALSE;
    }

    NtClose(key1);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryUserName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        SecurityDescriptor
        );

    if (!NT_SUCCESS(status = NtCreateKey(
                        &key1,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes,
                        0,
                        (PUNICODE_STRING)&nullclass,
                        0,
                        NULL
        )))
    {
        ExFreePool(SecurityDescriptor);
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: NtCreateKey(USER) failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,6,status,0); // could not create HKUSER
        return FALSE;
    }

    NtClose(key1);


    //
    // --- 7. Create the SYSTEM hive, fill in with data from loader ---
    //
    if (!CmpInitializeSystemHive(LoaderBlock)) {
        ExFreePool(SecurityDescriptor);

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitSystem1: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Hive allocation failure for SYSTEM\n"));

        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,7,0,0); // could not create SystemHive
        return(FALSE);
    }

    //
    // Create the symbolic link \Registry\Machine\System\CurrentControlSet
    //
    status = CmpCreateControlSet(LoaderBlock);
    if (!NT_SUCCESS(status)) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,8,status,0); // could not create CurrentControlSet
        return(FALSE);
    }

    //
    // Handle the copying of the CurrentControlSet to a Clone volatile
    // hive (but only if we really want to have a clone)
    //

#if CLONE_CONTROL_SET

    //
    // Create the Clone temporary hive, link it into the master hive,
    // and make a symbolic link to it.
    //
    status = CmpInitializeHive(&CloneHive,
                HINIT_CREATE,
                HIVE_VOLATILE,
                HFILE_TYPE_PRIMARY,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                0);
    if (!NT_SUCCESS(status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitSystem1: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Could not initialize CLONE hive\n"));

        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,9,status,0); // could not initialize clone hive
        return(FALSE);
    }

    status = CmpLinkHiveToMaster(
            &CmRegistrySystemCloneName,
            NULL,
            CloneHive,
            TRUE,
            SecurityDescriptor
            );

    if ( status != STATUS_SUCCESS)
    {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmInitSystem1: CmpLinkHiveToMaster(Clone) failed\n"));

        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,10,status,0); // could not link clone hive to master hive
        return FALSE;
    }
    CmpAddToHiveFileList(CloneHive);
    CmpMachineHiveList[CLONE_HIVE_INDEX].CmHive = CloneHive;

    CmpLinkKeyToHive(
        L"\\Registry\\Machine\\System\\Clone",
        L"\\Registry\\Machine\\CLONE\\CLONE"
        );


    //
    // Clone the current control set for the service controller
    //
    status = CmpCloneControlSet();

    //
    // If this didn't work, it's bad, but not bad enough to fail the boot
    //
    ASSERT(NT_SUCCESS(status));

#endif

    //
    // --- 8. Create the HARDWARE hive, fill in with data from loader ---
    //
    status = CmpInitializeHive(&HardwareHive,
                HINIT_CREATE,
                HIVE_VOLATILE,
                HFILE_TYPE_PRIMARY,     // i.e. no log, no alternate
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                0);
    if (!NT_SUCCESS(status)) {
        ExFreePool(SecurityDescriptor);

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitSystem1: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Could not initialize HARDWARE hive\n"));

        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,11,status,0); // could not initialize hardware hive
        return(FALSE);
    }

    //
    // Allocate the root node
    //
    status = CmpLinkHiveToMaster(
            &CmRegistryMachineHardwareName,
            NULL,
            HardwareHive,
            TRUE,
            SecurityDescriptor
            );
    if ( status != STATUS_SUCCESS )
    {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: CmpLinkHiveToMaster(Hardware) failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,12,status,0); // could not link hardware hive to master hive
        return FALSE;
    }
    CmpAddToHiveFileList(HardwareHive);

    ExFreePool(SecurityDescriptor);

    CmpMachineHiveList[0].CmHive = HardwareHive;

    //
    // put loader configuration tree data to our hardware registry.
    //
    status = CmpInitializeHardwareConfiguration(LoaderBlock);

    if (!NT_SUCCESS(status)) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,13,status,0); // could not initialize hardware configuration
        return(FALSE);
    }

    CmpNoMasterCreates = TRUE;
    CmpUnlockRegistry();

    //
    // put machine dependant configuration data to our hardware registry.
    //
    status = CmpInitializeMachineDependentConfiguration(LoaderBlock);
    if (!NT_SUCCESS(status)) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,14,status,0); // could not open CurrentControlSet\\Control
#if defined(_CM_LDR_)
        return(FALSE);
#endif
    }

    //
    // Write system start options to registry
    //
    status = CmpSetSystemValues(LoaderBlock);
    if (!NT_SUCCESS(status)) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,15,status,0);
#if defined(_CM_LDR_)
        return(FALSE);
#endif
    }

    ExFreePool(CmpLoadOptions.Buffer);

#if !defined(_IA64_)
    // chuckl 16-Apr-2002
    // Turned this off temporarily for IA64. It's only needed for remote boot,
    // which we're not doing on IA64 at the moment. And there seems to be a
    // problem with getting the IA64 update.exe to put a new ia64ldr.efi in
    // place. We need the new ia64ldr.efi in order for the NetworkLoaderBlock
    // field to valid -- it should be NULL for non-remote boot, but with the
    // old loader, we get an uninitialized value. So without the new loader,
    // we bugcheck in CmpSetNetworkValue(). Therefore, this code is turned
    // off for IA64 until both of the following are true: 1) we need to remote
    // boot IA64; and 2) update.exe knows how to put a new ia64ldr.efi in
    // place.
    //
    // Write Network LoaderBlock values to registry
    //
    if ( (LoaderBlock->Extension->Size >=
            RTL_SIZEOF_THROUGH_FIELD(LOADER_PARAMETER_EXTENSION, NetworkLoaderBlock)) &&
         (LoaderBlock->Extension->NetworkLoaderBlock != NULL) ) {
        status = CmpSetNetworkValue(LoaderBlock->Extension->NetworkLoaderBlock);
        if (!NT_SUCCESS(status)) {
            CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,16,status,0);
#if defined(_CM_LDR_)
            return(FALSE);
#endif
        }
    }
#endif

    return TRUE;
}

//
// All paralel threads will get this shared, and CmpInitializeHiveList will wait for it exclusive
//
KEVENT  CmpLoadWorkerEvent;
ULONG   CmpLoadWorkerIncrement = 0;
KEVENT  CmpLoadWorkerDebugEvent;

VOID
CmpInitializeHiveList(
    VOID
    )
/*++

Routine Description:

    This function is called to map hive files to hives.  It both
    maps existing hives to files, and creates new hives from files.

    It operates on files in "\SYSTEMROOT\CONFIG".

    NOTE:   MUST run in the context of the process that the CmpWorker
            thread runs in.  Caller is expected to arrange this.

    NOTE:   Will bugcheck on failure.

Arguments:

Return Value:

    NONE.

--*/
{
    #define MAX_NAME    128
    HANDLE  Thread;
    NTSTATUS Status;

    UCHAR   FileBuffer[MAX_NAME];
    UCHAR   RegBuffer[MAX_NAME];

    UNICODE_STRING TempName;
    UNICODE_STRING FileName;
    UNICODE_STRING RegName;

    USHORT  FileStart;
    USHORT  RegStart;
    ULONG   i;
    PSECURITY_DESCRIPTOR SecurityDescriptor;


#ifdef CM_PERF_ISSUES
    LARGE_INTEGER   StartSystemTime;
    LARGE_INTEGER   EndSystemTime;
    LARGE_INTEGER   deltaTime;
#endif //CM_PERF_ISSUES

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpInitializeHiveList\n"));

#ifdef CM_PERF_ISSUES
    KeQuerySystemTime(&StartSystemTime);
#endif //CM_PERF_ISSUES

    CmpNoWrite = FALSE;

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    FileName.MaximumLength = MAX_NAME;
    FileName.Length = 0;
    FileName.Buffer = (PWSTR)&(FileBuffer[0]);

    RegName.MaximumLength = MAX_NAME;
    RegName.Length = 0;
    RegName.Buffer = (PWSTR)&(RegBuffer[0]);

    RtlInitUnicodeString(
        &TempName,
        INIT_SYSTEMROOT_HIVEPATH
        );
    RtlAppendStringToString((PSTRING)&FileName, (PSTRING)&TempName);
    FileStart = FileName.Length;

    RtlInitUnicodeString(
        &TempName,
        INIT_REGISTRY_MASTERPATH
        );
    RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);
    RegStart = RegName.Length;

    //
    // Initialize the syncronization event
    //
    KeInitializeEvent (&CmpLoadWorkerEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent (&CmpLoadWorkerDebugEvent, SynchronizationEvent, FALSE);

    CmpSpecialBootCondition = TRUE;

    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    if (CmpShareSystemHives) {
        for (i = 0; i < CM_NUMBER_OF_MACHINE_HIVES; i++) {
            if (CmpMachineHiveList[i].Name) {
                CmpMachineHiveList[i].Flags |= HIVE_VOLATILE;
            }
        }
    }

    for (i = 0; i < CM_NUMBER_OF_MACHINE_HIVES; i++) {
        ASSERT( CmpMachineHiveList[i].Name != NULL );
        //
        // just spawn the Threads to load the hives in paralel
        //
        Status = PsCreateSystemThread(
            &Thread,
            THREAD_ALL_ACCESS,
            NULL,
            0,
            NULL,
            CmpLoadHiveThread,
            (PVOID)(ULONG_PTR)(ULONG)i
            );

        if (NT_SUCCESS(Status)) {
            ZwClose(Thread);
        } else {
            //
            // cannot spawn thread; Fatal error
            //
            CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_HIVE_LIST,3,i,Status);
        }
    }
    ASSERT( CmpMachineHiveList[i].Name == NULL );

    KeWaitForSingleObject( &CmpLoadWorkerEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    CmpSpecialBootCondition = FALSE;
    ASSERT( CmpLoadWorkerIncrement == CM_NUMBER_OF_MACHINE_HIVES );
    //
    // Now add all hives to the hivelist
    //
    for (i = 0; i < CM_NUMBER_OF_MACHINE_HIVES; i++) {
        ASSERT( CmpMachineHiveList[i].ThreadFinished == TRUE );
        ASSERT( CmpMachineHiveList[i].ThreadStarted == TRUE );

        if (CmpMachineHiveList[i].CmHive == NULL) {

            ASSERT( CmpMachineHiveList[i].CmHive2 != NULL );

            //
            // Compute the name of the file, and the name to link to in
            // the registry.
            //

            // REGISTRY

            RegName.Length = RegStart;
            RtlInitUnicodeString(
                &TempName,
                CmpMachineHiveList[i].BaseName
                );
            RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);

            // REGISTRY\MACHINE or REGISTRY\USER

            if (RegName.Buffer[ (RegName.Length / sizeof( WCHAR )) - 1 ] == '\\') {
                RtlInitUnicodeString(
                    &TempName,
                    CmpMachineHiveList[i].Name
                    );
                RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);
            }

            // REGISTRY\[MACHINE|USER]\HIVE

            // <sysroot>\config


            //
            // Link hive into master hive
            //
            Status = CmpLinkHiveToMaster(
                    &RegName,
                    NULL,
                    CmpMachineHiveList[i].CmHive2,
                    CmpMachineHiveList[i].Allocate,
                    SecurityDescriptor
                    );
            if ( Status != STATUS_SUCCESS)
            {

                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeHiveList: "));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpLinkHiveToMaster failed\n"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\ti=%d s='%ws'\n", i, CmpMachineHiveList[i]));

                CM_BUGCHECK(CONFIG_LIST_FAILED,BAD_CORE_HIVE,Status,i,&RegName);
            }

            if( CmpMachineHiveList[i].Allocate == TRUE ) {
                HvSyncHive((PHHIVE)(CmpMachineHiveList[i].CmHive2));
            }

        } else {
            //
            // do nothing here as all of it has been done in separate thread.
            //
        }

        if( CmpMachineHiveList[i].CmHive2 != NULL ) {
            CmpAddToHiveFileList(CmpMachineHiveList[i].CmHive2);
        }

    }   // for

    ExFreePool(SecurityDescriptor);

    //
    // Create symbolic link from SECURITY hive into SAM hive.
    //
    CmpLinkKeyToHive(
        L"\\Registry\\Machine\\Security\\SAM",
        L"\\Registry\\Machine\\SAM\\SAM"
        );

    //
    // Create symbolic link from S-1-5-18 to .Default
    //
    CmpNoMasterCreates = FALSE;
    CmpLinkKeyToHive(
        L"\\Registry\\User\\S-1-5-18",
        L"\\Registry\\User\\.Default"
        );
    CmpNoMasterCreates = TRUE;

    //
    // Create predefined handles.
    //
    CmpCreatePerfKeys();

    //
    // from now on we will attempt to self heal hives
    // we set this to true here for an eye towards longhorn where this is more useful
    //
    CmpSelfHeal = TRUE;

#ifdef CM_PERF_ISSUES
    KeQuerySystemTime(&EndSystemTime);
    deltaTime.QuadPart = EndSystemTime.QuadPart - StartSystemTime.QuadPart;
    DbgPrint("\nCmpInitializeHiveList took %lu.%lu ms\n",(ULONG)(deltaTime.LowPart/10000),(ULONG)(deltaTime.LowPart%10000));
    if( deltaTime.HighPart != 0 ) {
        DbgPrint("deltaTime.HighPart = %lu\n",(ULONG)deltaTime.HighPart);
    }
#endif //CM_PERF_ISSUES

    return;
}

NTSTATUS
CmpCreateObjectTypes(
    VOID
    )
/*++

Routine Description:

    Create the Key object type

Arguments:

    NONE.

Return Value:

    Status of the ObCreateType call

--*/
{
   NTSTATUS Status;
   OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
   UNICODE_STRING TypeName;

   //
   // Structure that describes the mapping of generic access rights to object
   // specific access rights for registry key objects.
   //

   GENERIC_MAPPING CmpKeyMapping = {
      KEY_READ,
      KEY_WRITE,
      KEY_EXECUTE,
      KEY_ALL_ACCESS
   };

    PAGED_CODE();
    //
    // --- Create the registry key object type ---
    //

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Key");

    //
    // Create key object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = CMP_KEY_INVALID_ATTRIBUTES;
    ObjectTypeInitializer.GenericMapping = CmpKeyMapping;
    ObjectTypeInitializer.ValidAccessMask = KEY_ALL_ACCESS;
    ObjectTypeInitializer.DefaultPagedPoolCharge = sizeof(CM_KEY_BODY);
    ObjectTypeInitializer.SecurityRequired = TRUE;
    ObjectTypeInitializer.PoolType = PagedPool;
    ObjectTypeInitializer.MaintainHandleCount = FALSE;
    ObjectTypeInitializer.UseDefaultObject = TRUE;

    ObjectTypeInitializer.DumpProcedure = NULL;
    ObjectTypeInitializer.OpenProcedure = NULL;
    ObjectTypeInitializer.CloseProcedure = CmpCloseKeyObject;
    ObjectTypeInitializer.DeleteProcedure = CmpDeleteKeyObject;
    ObjectTypeInitializer.ParseProcedure = CmpParseKey;
    ObjectTypeInitializer.SecurityProcedure = CmpSecurityMethod;
    ObjectTypeInitializer.QueryNameProcedure = CmpQueryKeyName;

    Status = ObCreateObjectType(
                &TypeName,
                &ObjectTypeInitializer,
                (PSECURITY_DESCRIPTOR)NULL,
                &CmpKeyObjectType
                );


    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateObjectTypes: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObCreateObjectType(Key) failed %08lx\n", Status));
    }

    return Status;
}



BOOLEAN
CmpCreateRegistryRoot(
    VOID
    )
/*++

Routine Description:

    Manually create \REGISTRY in the master hive, create a key
    object to refer to it, and insert the key object into
    the root (\) of the object space.

Arguments:

    None

Return Value:

    TRUE == success, FALSE == failure

--*/
{
    NTSTATUS                Status;
    UNICODE_STRING          NullString = { 0, 0, NULL };
    PVOID                   ObjectPointer;
    PCM_KEY_BODY            Object;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    PCM_KEY_CONTROL_BLOCK   kcb;
    HCELL_INDEX             RootCellIndex;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    PCM_KEY_NODE            TempNode;

    PAGED_CODE();
    //
    // --- Create hive entry for \REGISTRY ---
    //

    if (!CmpCreateRootNode(
            &(CmpMasterHive->Hive), L"REGISTRY", &RootCellIndex))
    {
        return FALSE;
    }

    //
    // --- Create a KEY object that refers to \REGISTRY ---
    //


    //
    // Create the object manager object
    //

    //
    // WARNING: \\REGISTRY is not in pool, so if anybody ever tries to
    //          free it, we are in deep trouble.  On the other hand,
    //          this implies somebody has removed \\REGISTRY from the
    //          root, so we're in trouble anyway.
    //

    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryRootName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        SecurityDescriptor
        );


    Status = ObCreateObject(
        KernelMode,
        CmpKeyObjectType,
        &ObjectAttributes,
        UserMode,
        NULL,                   // Parse context
        sizeof(CM_KEY_BODY),
        0,
        0,
        (PVOID *)&Object
        );

    ExFreePool(SecurityDescriptor);

    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateRegistryRoot: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObCreateObject(\\REGISTRY) failed %08lx\n", Status));
        return FALSE;
    }

    ASSERT( (&CmpMasterHive->Hive)->ReleaseCellRoutine == NULL );
    TempNode = (PCM_KEY_NODE)HvGetCell(&CmpMasterHive->Hive,RootCellIndex);
    if( TempNode == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }
    //
    // Create the key control block
    //
    kcb = CmpCreateKeyControlBlock(
            &(CmpMasterHive->Hive),
            RootCellIndex,
            TempNode,
            NULL,
            FALSE,
            &CmRegistryRootName
            );

    if (kcb==NULL) {
        return(FALSE);
    }

    //
    // Initialize the type specific body
    //
    Object->Type = KEY_BODY_TYPE;
    Object->KeyControlBlock = kcb;
    Object->NotifyBlock = NULL;
    Object->Process = PsGetCurrentProcess();
    ENLIST_KEYBODY_IN_KEYBODY_LIST(Object);

    //
    // Put the object in the root directory
    //
    Status = ObInsertObject(
                Object,
                NULL,
                (ACCESS_MASK)0,
                0,
                NULL,
                &CmpRegistryRootHandle
                );

    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateRegistryRoot: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObInsertObject(\\REGISTRY) failed %08lx\n", Status));
        return FALSE;
    }

    //
    // We cannot make the root permanent because registry objects in
    // general are not allowed to be.  (They're stable via virtue of being
    // stored in the registry, not the object manager.)  But we never
    // ever want the root to go away.  So reference it.
    //
    if (! NT_SUCCESS(Status = ObReferenceObjectByHandle(
                        CmpRegistryRootHandle,
                        KEY_READ,
                        NULL,
                        KernelMode,
                        &ObjectPointer,
                        NULL
                        )))
    {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateRegistryRoot: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObReferenceObjectByHandle failed %08lx\n", Status));
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
CmpCreateRootNode(
    IN PHHIVE   Hive,
    IN PWSTR    Name,
    OUT PHCELL_INDEX RootCellIndex
    )
/*++

Routine Description:

    Manually create the root node of a hive.

Arguments:

    Hive - pointer to a Hive (Hv level) control structure

    Name - pointer to a unicode name string

    RootCellIndex - supplies pointer to a variable to recieve
                    the cell index of the created node.

Return Value:

    TRUE == success, FALSE == failure

--*/
{
    UNICODE_STRING temp;
    PCELL_DATA CellData;
    CM_KEY_REFERENCE Key;
    LARGE_INTEGER systemtime;

    PAGED_CODE();
    //
    // Allocate the node.
    //
    RtlInitUnicodeString(&temp, Name);
    *RootCellIndex = HvAllocateCell(
                Hive,
                CmpHKeyNodeSize(Hive, &temp),
                Stable,
                HCELL_NIL
                );
    if (*RootCellIndex == HCELL_NIL) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateRootNode: HvAllocateCell failed\n"));
        return FALSE;
    }

    Hive->BaseBlock->RootCell = *RootCellIndex;

    CellData = HvGetCell(Hive, *RootCellIndex);
    if( CellData == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }

    //
    // Initialize the node
    //
    CellData->u.KeyNode.Signature = CM_KEY_NODE_SIGNATURE;
    CellData->u.KeyNode.Flags = KEY_HIVE_ENTRY | KEY_NO_DELETE;
    KeQuerySystemTime(&systemtime);
    CellData->u.KeyNode.LastWriteTime = systemtime;
//    CellData->u.KeyNode.TitleIndex = 0;
    CellData->u.KeyNode.Parent = HCELL_NIL;

    CellData->u.KeyNode.SubKeyCounts[Stable] = 0;
    CellData->u.KeyNode.SubKeyCounts[Volatile] = 0;
    CellData->u.KeyNode.SubKeyLists[Stable] = HCELL_NIL;
    CellData->u.KeyNode.SubKeyLists[Volatile] = HCELL_NIL;

    CellData->u.KeyNode.ValueList.Count = 0;
    CellData->u.KeyNode.ValueList.List = HCELL_NIL;
    CellData->u.KeyNode.Security = HCELL_NIL;
    CellData->u.KeyNode.Class = HCELL_NIL;
    CellData->u.KeyNode.ClassLength = 0;

    CellData->u.KeyNode.MaxValueDataLen = 0;
    CellData->u.KeyNode.MaxNameLen = 0;
    CellData->u.KeyNode.MaxValueNameLen = 0;
    CellData->u.KeyNode.MaxClassLen = 0;

    CellData->u.KeyNode.NameLength = CmpCopyName(Hive,
                                                 CellData->u.KeyNode.Name,
                                                 &temp);
    if (CellData->u.KeyNode.NameLength < temp.Length) {
        CellData->u.KeyNode.Flags |= KEY_COMP_NAME;
    }

    Key.KeyHive = Hive;
    Key.KeyCell = *RootCellIndex;

    HvReleaseCell(Hive, *RootCellIndex);

    return TRUE;
}


NTSTATUS
CmpLinkHiveToMaster(
    PUNICODE_STRING LinkName,
    HANDLE RootDirectory,
    PCMHIVE CmHive,
    BOOLEAN Allocate,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    The existing, "free floating" hive CmHive describes is linked into
    the name space at the node named by LinkName.  The node will be created.
    The hive is assumed to already have an appropriate root node.

Arguments:

    LinkName - supplies a pointer to a unicode string which describes where
                in the registry name space the hive is to be linked.
                All components but the last must exist.  The last must not.

    RootDirectory - Supplies the handle the LinkName is relative to.

    CmHive - pointer to a CMHIVE structure describing the hive to link in.

    Allocate - TRUE indicates that the root cell is to be created
               FALSE indicates the root cell already exists.

    SecurityDescriptor - supplies a pointer to the security descriptor to
               be placed on the hive root.

Return Value:

    TRUE == success, FALSE == failure

--*/
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              KeyHandle;
    CM_PARSE_CONTEXT    ParseContext;
    NTSTATUS            Status;
    PCM_KEY_BODY        KeyBody;

    PAGED_CODE();
    //
    // Fill in special ParseContext to indicate that we are creating
    // a link node and opening or creating a root node.
    //
    ParseContext.TitleIndex = 0;
    ParseContext.Class.Length = 0;
    ParseContext.Class.MaximumLength = 0;
    ParseContext.Class.Buffer = NULL;
    ParseContext.CreateOptions = 0;
    ParseContext.CreateLink = TRUE;
    ParseContext.ChildHive.KeyHive = &CmHive->Hive;
    if (Allocate) {

        //
        // Creating a new root node
        //

        ParseContext.ChildHive.KeyCell = HCELL_NIL;
    } else {

        //
        // Opening an existing root node
        //

        ParseContext.ChildHive.KeyCell = CmHive->Hive.BaseBlock->RootCell;
    }

    //
    // Create a path to the hive
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        LinkName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        (HANDLE)RootDirectory,
        SecurityDescriptor
        );

    Status = ObOpenObjectByName( &ObjectAttributes,
                                 CmpKeyObjectType,
                                 KernelMode,
                                 NULL,
                                 KEY_READ | KEY_WRITE,
                                 (PVOID)&ParseContext,
                                 &KeyHandle );

    if (!NT_SUCCESS(Status)) {
#ifdef CM_CHECK_FOR_ORPHANED_KCBS
        DbgPrint("CmpLinkHiveToMaster: ObOpenObjectByName for CmHive = %p , LinkName = %.*S failed with status %lx\n",CmHive,LinkName->Length/2,LinkName->Buffer,Status);
#endif //CM_CHECK_FOR_ORPHANED_KCBS
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpLinkHiveToMaster: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObOpenObjectByName() failed %08lx\n", Status));
        //CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\tLinkName='%ws'\n", LinkName->Buffer));
        return Status;
    }

    //
    // Report the notification event
    //
    Status = ObReferenceObjectByHandle(KeyHandle,
                                       0,
                                       CmpKeyObjectType,
                                       KernelMode,
                                       (PVOID *)&KeyBody,
                                       NULL);
    ASSERT(NT_SUCCESS(Status));
    if (NT_SUCCESS(Status)) {
        CmpReportNotify(KeyBody->KeyControlBlock,
                        KeyBody->KeyControlBlock->KeyHive,
                        KeyBody->KeyControlBlock->KeyCell,
                        REG_NOTIFY_CHANGE_NAME);

        ObDereferenceObject((PVOID)KeyBody);
    }

    ZwClose(KeyHandle);
    return STATUS_SUCCESS;
}


VOID
CmpSetVersionData(
    VOID
    )
/*++

Routine Description:

    Create \REGISTRY\MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion:
                CurrentVersion = VER_PRODUCTVERSION_STR             // From ntverp.h
                CurrentBuildNumber = VER_PRODUCTBUILD               // From ntverp.h
                CurrentType = "[Multiprocessor|Uniprocessor]        // From NT_UP
                                [Retail|Free|Checked]"              // From DBG, DEVL
                SystemRoot = "[c:\nt]"
                BuildLab = BUILD_MACHINE_TAG                        // From ntos\inti.c from makefile.def


    NOTE:   It is not worth bugchecking over this, so if it doesn't
            work, just fail.

Arguments:

Return Value:

--*/
{
    ANSI_STRING     AnsiString;
    UNICODE_STRING  NameString;
    UNICODE_STRING  ValueString;
    HANDLE          key1, key2;
    UCHAR           WorkString[128];
    WCHAR           ValueBuffer[128];
    OBJECT_ATTRIBUTES   ObjectAttributes;
    NTSTATUS            status;
    PUCHAR              proctype;
    PUCHAR              buildtype;
    PVERSION_DATA_KEY   VersionDataKey;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    PAGED_CODE();
    //
    // Get default security descriptor for the nodes we will create.
    //
    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    for (VersionDataKey = VersionDataKeys; VersionDataKey->InitialKeyPath != NULL ; VersionDataKey++) {

        //
        // Create the key
        //
        RtlInitUnicodeString(
            &NameString,
            VersionDataKey->InitialKeyPath
            );

        InitializeObjectAttributes(
            &ObjectAttributes,
            &NameString,
            OBJ_CASE_INSENSITIVE,
            (HANDLE)NULL,
            SecurityDescriptor
            );

        status = NtCreateKey(
                    &key1,
                    KEY_CREATE_SUB_KEY,
                    &ObjectAttributes,
                    0,
                    (PUNICODE_STRING)&nullclass,
                    0,
                    NULL
                    );

        if (!NT_SUCCESS(status)) {
#if DBG
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_WARNING_LEVEL,"CMINIT: CreateKey of %wZ failed - Status == %lx\n",
                       &NameString, status);
#endif //_CM_LDR_
#endif
            ExFreePool(SecurityDescriptor);
            return;
        }

#if defined(_WIN64)
        if (VersionDataKey->AdditionalKeyPath != NULL) {

            RtlInitUnicodeString(
                &NameString,
                VersionDataKey->AdditionalKeyPath
                );

            InitializeObjectAttributes(
                &ObjectAttributes,
                &NameString,
                OBJ_CASE_INSENSITIVE,
                key1,
                SecurityDescriptor
                );

            status = NtCreateKey(
                        &key2,
                        KEY_SET_VALUE,
                        &ObjectAttributes,
                        0,
                        (PUNICODE_STRING)&nullclass,
                        0,
                        NULL
                        );

            NtClose(key1);
            key1 = key2;
        }
#endif
        RtlInitUnicodeString(
            &NameString,
            L"Windows NT"
            );

        InitializeObjectAttributes(
            &ObjectAttributes,
            &NameString,
            OBJ_CASE_INSENSITIVE,
            key1,
            SecurityDescriptor
            );

        status = NtCreateKey(
                    &key2,
                    KEY_SET_VALUE,
                    &ObjectAttributes,
                    0,
                    (PUNICODE_STRING)&nullclass,
                    0,
                    NULL
                    );
        NtClose(key1);
        RtlInitUnicodeString(
            &NameString,
            L"CurrentVersion"
            );

        InitializeObjectAttributes(
            &ObjectAttributes,
            &NameString,
            OBJ_CASE_INSENSITIVE,
            key2,
            SecurityDescriptor
            );

        status = NtCreateKey(
                    &key1,
                    KEY_SET_VALUE,
                    &ObjectAttributes,
                    0,
                    (PUNICODE_STRING)&nullclass,
                    0,
                    NULL
                    );
        NtClose(key2);

        if (!NT_SUCCESS(status)) {
#if DBG
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_WARNING_LEVEL,"CMINIT: CreateKey of %wZ failed - Status == %lx\n",
                       &NameString, status);
#endif //_CM_LDR_
#endif
            ExFreePool(SecurityDescriptor);
            return;
        }


        //
        // Set the value entries for the key
        //
        RtlInitUnicodeString(
            &NameString,
            L"CurrentVersion"
            );

        status = NtSetValueKey(
            key1,
            &NameString,
            0,              // TitleIndex
            REG_SZ,
            CmVersionString.Buffer,
            CmVersionString.Length + sizeof( UNICODE_NULL )
            );
#if DBG
        if (!NT_SUCCESS(status)) {
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CMINIT: SetValueKey of %wZ failed - Status == %lx\n",&NameString, status);
#endif //_CM_LDR_
        }
#endif

        RtlInitUnicodeString(
            &NameString,
            L"CurrentBuildNumber"
            );

        sprintf(
            WorkString,
            "%u",
            NtBuildNumber & 0xFFFF
            );
        RtlInitAnsiString( &AnsiString, WorkString );

        ValueString.Buffer = ValueBuffer;
        ValueString.Length = 0;
        ValueString.MaximumLength = sizeof( ValueBuffer );

        RtlAnsiStringToUnicodeString( &ValueString, &AnsiString, FALSE );

        status = NtSetValueKey(
            key1,
            &NameString,
            0,              // TitleIndex
            REG_SZ,
            ValueString.Buffer,
            ValueString.Length + sizeof( UNICODE_NULL )
            );
#if DBG
        if (!NT_SUCCESS(status)) {
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CMINIT: SetValueKey of %wZ failed - Status == %lx\n",&NameString, status);
#endif //_CM_LDR_
        }
#endif

        RtlInitUnicodeString(
            &NameString,
            L"BuildLab"
            );

        RtlInitAnsiString( &AnsiString, NtBuildLab );

        ValueString.Buffer = ValueBuffer;
        ValueString.Length = 0;
        ValueString.MaximumLength = sizeof( ValueBuffer );

        status = RtlAnsiStringToUnicodeString( &ValueString, &AnsiString, FALSE );

        if (NT_SUCCESS(status)) {
            status = NtSetValueKey(
                key1,
                &NameString,
                0,
                REG_SZ,
                ValueString.Buffer,
                ValueString.Length + sizeof( UNICODE_NULL )
                );
#if DBG
            if (!NT_SUCCESS(status)) {
                DbgPrint("CMINIT: SetValueKey of %wZ failed - Status == %lx\n",
                         &NameString, status);
            }
        } else {
            DbgPrint("CMINIT: RtlAnsiStringToUnicodeString of %wZ failed - Status == %lx\n",
                     &NameString, status);
#endif
        }


        RtlInitUnicodeString(
            &NameString,
            L"CurrentType"
            );

#if defined(NT_UP)
        proctype = "Uniprocessor";
#else
        proctype = "Multiprocessor";
#endif

#if DBG
        buildtype = "Checked";
#else
#if DEVL
        buildtype = "Free";
#else
        buildtype = "Retail";
#endif

#endif

        sprintf(
            WorkString,
            "%s %s",
            proctype,
            buildtype
            );
        RtlInitAnsiString( &AnsiString, WorkString );

        ValueString.Buffer = ValueBuffer;
        ValueString.Length = 0;
        ValueString.MaximumLength = sizeof( ValueBuffer );

        RtlAnsiStringToUnicodeString( &ValueString, &AnsiString, FALSE );

        status = NtSetValueKey(
            key1,
            &NameString,
            0,              // TitleIndex
            REG_SZ,
            ValueString.Buffer,
            ValueString.Length + sizeof( UNICODE_NULL )
            );

        RtlInitUnicodeString(
            &NameString,
            L"CSDVersion"
            );


        if (CmCSDVersionString.Length != 0) {
            status = NtSetValueKey(
                key1,
                &NameString,
                0,              // TitleIndex
                REG_SZ,
                CmCSDVersionString.Buffer,
                CmCSDVersionString.Length + sizeof( UNICODE_NULL )
                );
#if DBG
            if (!NT_SUCCESS(status)) {
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CMINIT: SetValueKey of %wZ failed - Status == %lx\n",&NameString, status);
#endif //_CM_LDR_
            }
#endif
            (RtlFreeStringRoutine)( CmCSDVersionString.Buffer );
            RtlInitUnicodeString( &CmCSDVersionString, NULL );
        } else {
            status = NtDeleteValueKey(
                key1,
                &NameString
                );
#if DBG
            if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CMINIT: DeleteValueKey of %wZ failed - Status == %lx\n",&NameString, status);
#endif //_CM_LDR_
            }
#endif
        }

        //
        // High-order 16-bits of CSDVersion contain RC number or build number.  If non-zero
        // display it after the Service Pack number.
        //
        RtlInitUnicodeString(
                &NameString,
                L"CSDBuildNumber"
                );

        if (CmNtCSDVersion & 0xFFFF0000) {

            ULONG  Value = (CmNtCSDVersion & 0xFFFF0000) >> 16;

            sprintf(
               WorkString,
               "%u",
               Value
               );

            RtlInitAnsiString( &AnsiString, WorkString );

            ValueString.Buffer = ValueBuffer;
            ValueString.Length = 0;
            ValueString.MaximumLength = sizeof( ValueBuffer );

            RtlAnsiStringToUnicodeString( &ValueString, &AnsiString, FALSE );

            status = NtSetValueKey(
               key1,
               &NameString,
               0,
               REG_SZ,
               ValueString.Buffer,
               ValueString.Length + sizeof( UNICODE_NULL )
               );

#if DBG
            if (!NT_SUCCESS(status)) {
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CMINIT: SetValueKey of %wZ failed - Status == %lx\n",&NameString, status);
#endif //_CM_LDR_
            }
#endif
        } else {
            status = NtDeleteValueKey(
                key1,
                &NameString
                );
#if DBG
            if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CMINIT: DeleteValueKey of %wZ failed - Status == %lx\n",&NameString, status);
#endif //_CM_LDR_
            }
#endif
        }



        RtlInitUnicodeString(&NameString,
                             L"SystemRoot");
        status = NtSetValueKey(key1,
                               &NameString,
                               0,
                               REG_SZ,
                               NtSystemRoot.Buffer,
                               NtSystemRoot.Length + sizeof(UNICODE_NULL));
#if DBG
        if (!NT_SUCCESS(status)) {
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CMINIT: SetValueKey of %wZ failed - Status == %lx\n",&NameString,status);
#endif //_CM_LDR_
        }
#endif
        NtClose(key1);
    }

    (RtlFreeStringRoutine)( CmVersionString.Buffer );
    RtlInitUnicodeString( &CmVersionString, NULL );

    ExFreePool(SecurityDescriptor);

    //
    // Set each processor to it's optimal configuration.
    //
    // Note: this call is performed interlocked such that the user
    // can disable this automatic configuration update.
    //

    CmpInterlockedFunction(CmpProcessorControl, CmpConfigureProcessors);

    return;
}

NTSTATUS
CmpInterlockedFunction (
    PWCHAR RegistryValueKey,
    VOID (*InterlockedFunction)(VOID)
    )
/*++

Routine Description:

    This routine guards calling the InterlockedFunction in the
    passed RegistryValueKey.

    The RegistryValueKey will record the status of the first
    call to the InterlockedFunction.  If the system crashes
    durning this call then ValueKey will be left in a state
    where the InterlockedFunction will not be called on subsequent
    attempts.

Arguments:

    RegistryValueKey - ValueKey name for Control\Session Manager
    InterlockedFunction - Function to call

Return Value:

    STATUS_SUCCESS  - The interlocked function was successfully called


--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hControl, hSession;
    UNICODE_STRING      Name;
    UCHAR               Buffer [sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)];
    ULONG               length, Value;
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Open CurrentControlSet
    //

    InitializeObjectAttributes (
        &objectAttributes,
        &CmRegistryMachineSystemCurrentControlSet,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey (&hControl, KEY_READ | KEY_WRITE, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Open Control\Session Manager
    //

    RtlInitUnicodeString (&Name, CmpControlSessionManager);
    InitializeObjectAttributes (
        &objectAttributes,
        &Name,
        OBJ_CASE_INSENSITIVE,
        hControl,
        NULL
        );

    status = NtOpenKey (&hSession, KEY_READ | KEY_WRITE, &objectAttributes );
    NtClose (hControl);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Read ValueKey to interlock operation with
    //

    RtlInitUnicodeString (&Name, RegistryValueKey);
    status = NtQueryValueKey (hSession,
                              &Name,
                              KeyValuePartialInformation,
                              Buffer,
                              sizeof (Buffer),
                              &length );

    Value = 0;
    if (NT_SUCCESS(status)) {
        Value = ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data[0];
    }

    //
    // Value 0  - Before InterlockedFunction
    //       1  - In the middle of InterlockedFunction
    //       2  - After InterlockedFunction
    //
    // If the value is a 0, then we haven't tried calling this
    // interlocked function, set the value to a 1 and try it.
    //
    // If the value is a 1, then we crased durning an execution
    // of the interlocked function last time, don't try it again.
    //
    // If the value is a 2, then we called the interlocked function
    // before and it worked.  Call it again this time.
    //

    if (Value != 1) {

        if (Value != 2) {
            //
            // This interlocked function is not known to work.  Write
            // a 1 to this value so we can detect if we crash durning
            // this call.
            //

            Value = 1;
            NtSetValueKey (hSession, &Name, 0L, REG_DWORD, &Value, sizeof (Value));
            NtFlushKey    (hSession);   // wait until it's on the disk
        }

        InterlockedFunction();

        if (Value != 2) {
            //
            // The worker function didn't crash - update the value for
            // this interlocked function to 2.
            //

            Value = 2;
            NtSetValueKey (hSession, &Name, 0L, REG_DWORD, &Value, sizeof (Value));
        }

    } else {
        status = STATUS_UNSUCCESSFUL;
    }

    NtClose (hSession);
    return status;
}

VOID
CmpConfigureProcessors (
    VOID
    )
/*++

Routine Description:

    Set each processor to it's optimal settings for NT.

--*/
{
    ULONG   i;

    PAGED_CODE();

    //
    // Set each processor into its best NT configuration
    //

    for (i=0; i < (ULONG)KeNumberProcessors; i++) {
        KeSetSystemAffinityThread(AFFINITY_MASK(i));

#if i386
        // for now x86 only
        KeOptimizeProcessorControlState ();
#endif
    }

    //
    // Restore threads affinity
    //

    KeRevertToUserAffinityThread();
}

BOOLEAN
CmpInitializeSystemHive(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    Initializes the SYSTEM hive based on the raw hive image passed in
    from the OS Loader.

Arguments:

    LoaderBlock - Supplies a pointer to the Loader Block passed in by
        the OS Loader.

Return Value:

    TRUE - it worked

    FALSE - it failed

--*/

{
    PCMHIVE SystemHive;
    PVOID HiveImageBase;
    BOOLEAN Allocate=FALSE;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    NTSTATUS Status;
    STRING  TempString;


    PAGED_CODE();

    //
    // capture tail of boot.ini line (load options, portable)
    //
    RtlInitAnsiString(
        &TempString,
        LoaderBlock->LoadOptions
        );

    CmpLoadOptions.Length = 0;
    CmpLoadOptions.MaximumLength = (TempString.Length+1)*sizeof(WCHAR);
    CmpLoadOptions.Buffer = ExAllocatePool(
                                PagedPool, (TempString.Length+1)*sizeof(WCHAR));

    if (CmpLoadOptions.Buffer == NULL) {
        CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_SYSTEM_HIVE,1,LoaderBlock,0);
    }
    RtlAnsiStringToUnicodeString(
        &CmpLoadOptions,
        &TempString,
        FALSE
        );
    CmpLoadOptions.Buffer[TempString.Length] = UNICODE_NULL;
    CmpLoadOptions.Length += sizeof(WCHAR);


    //
    // move the loaded registry into the real registry
    //
    HiveImageBase = LoaderBlock->RegistryBase;

    //
    // We need to initialize the system hive as NO_LAZY_FLUSH
    //  - this is just temporary, untill we get a chance to open the primary
    // file for the hive. Failure to do so, will result in loss of data on the
    // LazyFlush worker (see CmpFileWrite, the
    //          if (FileHandle == NULL) {
    //              return TRUE;
    //          }
    // test. This might be a problem in 5.0 too, if system crashes between the
    // LazyFlush reported the hive as saved and the moment we actually open the
    // file and save it again
    //
    if (HiveImageBase == NULL) {
        //
        // No memory descriptor for the hive, so we must recreate it.
        //
        Status = CmpInitializeHive(&SystemHive,
                    HINIT_CREATE,
                    HIVE_NOLAZYFLUSH,
                    HFILE_TYPE_LOG,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CmpSystemFileName,
                    0);
        if (!NT_SUCCESS(Status)) {

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeSystemHive: "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Couldn't initialize newly allocated SYSTEM hive\n"));

            return(FALSE);
        }
        Allocate = TRUE;

    } else {

        //
        // There is a memory image for the hive, copy it and make it active
        //
        Status = CmpInitializeHive(&SystemHive,
                    HINIT_MEMORY,
                    HIVE_NOLAZYFLUSH,
                    HFILE_TYPE_LOG,
                    HiveImageBase,
                    NULL,
                    NULL,
                    NULL,
                    &CmpSystemFileName,
                    CM_CHECK_REGISTRY_SYSTEM_CLEAN);
        if (!NT_SUCCESS(Status)) {

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeSystemHive: "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Couldn't initialize OS Loader-loaded SYSTEM hive\n"));

            CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_SYSTEM_HIVE,2,SystemHive,Status);
        }

        Allocate = FALSE;

        //
        // Mark the system hive as volatile, while in MiniNT boot
        // case
        //
        if (CmpShareSystemHives) {
            SystemHive->Hive.HiveFlags = HIVE_VOLATILE;
        }
    }

    CmpBootType = SystemHive->Hive.BaseBlock->BootType;
    //
    // Create the link node
    //
    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    Status = CmpLinkHiveToMaster(&CmRegistryMachineSystemName,
                                 NULL,
                                 SystemHive,
                                 Allocate,
                                 SecurityDescriptor);
    ExFreePool(SecurityDescriptor);

    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmInitSystem1: CmpLinkHiveToMaster(Hardware) failed\n"));

        return(FALSE);
    }

    CmpMachineHiveList[SYSTEM_HIVE_INDEX].CmHive = SystemHive;

    return(TRUE);
}


PHANDLE
CmGetSystemDriverList(
    VOID
    )

/*++

Routine Description:

    Traverses the current SERVICES subtree and creates the list of drivers
    to be loaded during Phase 1 initialization.

Arguments:

    None

Return Value:

    A pointer to an array of handles, each of which refers to a key in
    the \Services section of the control set.  The caller will traverse
    this array and load and initialize the drivers described by the keys.

    The last key will be NULL.  The array is allocated in Pool and should
    be freed by the caller.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SystemHandle;
    UNICODE_STRING Name;
    NTSTATUS Status;
    PCM_KEY_BODY KeyBody;
    LIST_ENTRY DriverList;
    PHHIVE Hive;
    HCELL_INDEX RootCell;
    HCELL_INDEX ControlCell;
    ULONG DriverCount;
    PLIST_ENTRY Current;
    PHANDLE Handle;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    BOOLEAN Success;
    BOOLEAN AutoSelect;

    PAGED_CODE();
    InitializeListHead(&DriverList);
    RtlInitUnicodeString(&Name,
                         L"\\Registry\\Machine\\System");

    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE)NULL,
                               NULL);
    Status = NtOpenKey(&SystemHandle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't open registry key %wZ\n",&Name));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM:     status %08lx\n", Status));

        return(NULL);
    }


    Status = ObReferenceObjectByHandle( SystemHandle,
                                        KEY_QUERY_VALUE,
                                        CmpKeyObjectType,
                                        KernelMode,
                                        (PVOID *)(&KeyBody),
                                        NULL );
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't dereference System handle\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM:     status %08lx\n", Status));

        NtClose(SystemHandle);
        return(NULL);
    }

    CmpLockRegistryExclusive();

    Hive = KeyBody->KeyControlBlock->KeyHive;
    RootCell = KeyBody->KeyControlBlock->KeyCell;

    //
    // Now we have found out the PHHIVE and HCELL_INDEX of the root of the
    // SYSTEM hive, we can use all the same code that the OS Loader does.
    //

    RtlInitUnicodeString(&Name, L"Current");
    ControlCell = CmpFindControlSet(Hive,
                                    RootCell,
                                    &Name,
                                    &AutoSelect);
    if (ControlCell == HCELL_NIL) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't find control set\n"));

        CmpUnlockRegistry();
        ObDereferenceObject((PVOID)KeyBody);
        NtClose(SystemHandle);
        return(NULL);
    }

    Success = CmpFindDrivers(Hive,
                             ControlCell,
                             SystemLoad,
                             NULL,
                             &DriverList);


    if (!Success) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't find any valid drivers\n"));

        CmpFreeDriverList(Hive, &DriverList);
        CmpUnlockRegistry();
        ObDereferenceObject((PVOID)KeyBody);
        NtClose(SystemHandle);
        return(NULL);
    }

    if (!CmpSortDriverList(Hive,
                           ControlCell,
                           &DriverList)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't sort driver list\n"));

        CmpFreeDriverList(Hive, &DriverList);
        CmpUnlockRegistry();
        ObDereferenceObject((PVOID)KeyBody);
        NtClose(SystemHandle);
        return(NULL);
    }

    if (!CmpResolveDriverDependencies(&DriverList)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't resolve driver dependencies\n"));

        CmpFreeDriverList(Hive, &DriverList);
        CmpUnlockRegistry();
        ObDereferenceObject((PVOID)KeyBody);
        NtClose(SystemHandle);
        return(NULL);
    }
    CmpUnlockRegistry();
    ObDereferenceObject((PVOID)KeyBody);
    NtClose(SystemHandle);

    //
    // We now have a fully sorted and ordered list of drivers to be loaded
    // by IoInit.
    //

    //
    // Count the nodes in the list.
    //
    Current = DriverList.Flink;
    DriverCount = 0;
    while (Current != &DriverList) {
        ++DriverCount;
        Current = Current->Flink;
    }

    Handle = (PHANDLE)ExAllocatePool(NonPagedPool,
                                     (DriverCount+1) * sizeof(HANDLE));

    if (Handle == NULL) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM_DRIVER_LIST,1,0,0); // odds against this are huge
    }

    //
    // Walk the list, opening each registry key and adding it to the
    // table of handles.
    //
    Current = DriverList.Flink;
    DriverCount = 0;
    while (Current != &DriverList) {
        DriverEntry = CONTAINING_RECORD(Current,
                                        BOOT_DRIVER_LIST_ENTRY,
                                        Link);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &DriverEntry->RegistryPath,
                                   OBJ_CASE_INSENSITIVE,
                                   (HANDLE)NULL,
                                   NULL);

        Status = NtOpenKey(Handle+DriverCount,
                           KEY_READ | KEY_WRITE,
                           &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't open driver "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"key %wZ\n", &DriverEntry->RegistryPath));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"    status %08lx\n",Status));
        } else {
            ++DriverCount;
        }
        Current = Current->Flink;
    }
    Handle[DriverCount] = NULL;

    CmpFreeDriverList(Hive, &DriverList);

    return(Handle);
}


VOID
CmpFreeDriverList(
    IN PHHIVE Hive,
    IN PLIST_ENTRY DriverList
    )

/*++

Routine Description:

    Walks down the driver list, freeing each node in it.

    Note that this calls the hive's free routine pointer to free the memory.

Arguments:

    Hive - Supplies  a pointer to the hive control structure.

    DriverList - Supplies a pointer to the head of the Driver List.  Note
            that the head of the list is not actually freed, only all the
            entries in the list.

Return Value:

    None.

--*/

{
    PLIST_ENTRY         Next;
    PLIST_ENTRY         Current;
    PBOOT_DRIVER_NODE   DriverNode;

    PAGED_CODE();
    Current = DriverList->Flink;
    while (Current != DriverList) {
        Next = Current->Flink;
        DriverNode = (PBOOT_DRIVER_NODE)Current;
        if( DriverNode->Name.Buffer != NULL ){
            (Hive->Free)(DriverNode->Name.Buffer,DriverNode->Name.Length);
        }
        if( DriverNode->ListEntry.RegistryPath.Buffer != NULL ){
            (Hive->Free)(DriverNode->ListEntry.RegistryPath.Buffer,DriverNode->ListEntry.RegistryPath.MaximumLength);
        }
        if( DriverNode->ListEntry.FilePath.Buffer != NULL ){
            (Hive->Free)(DriverNode->ListEntry.FilePath.Buffer,DriverNode->ListEntry.FilePath.MaximumLength);
        }
        (Hive->Free)((PVOID)Current, sizeof(BOOT_DRIVER_NODE));
        Current = Next;
    }
}


NTSTATUS
CmpInitHiveFromFile(
    IN PUNICODE_STRING FileName,
    IN ULONG HiveFlags,
    OUT PCMHIVE *CmHive,
    IN OUT PBOOLEAN Allocate,
    IN OUT PBOOLEAN RegistryLocked,
    IN  ULONG       CheckFlags
    )

/*++

Routine Description:

    This routine opens a file and log, allocates a CMHIVE, and initializes
    it.

Arguments:

    FileName - Supplies name of file to be loaded.

    HiveFlags - Supplies hive flags to be passed to CmpInitializeHive

    CmHive   - Returns pointer to initialized hive (if successful)

    Allocate - IN: if TRUE ok to allocate, if FALSE hive must exist
                    (bug .log may get created)
               OUT: TRUE if actually created hive, FALSE if existed before

Return Value:

    NTSTATUS

--*/

{
    PCMHIVE         NewHive;
    ULONG           Disposition;
    ULONG           SecondaryDisposition;
    HANDLE          PrimaryHandle;
    HANDLE          LogHandle;
    NTSTATUS        Status;
    ULONG           FileType;
    ULONG           Operation;
    PULONG_PTR      HiveSection;
    PVOID           HiveData = NULL;
    BOOLEAN         Success;
    PEPROCESS       Process;
    LARGE_INTEGER   liOffset;
    BOOLEAN         NoBuffering = FALSE;
    BOOLEAN         LockedHeldOnCall;

    PAGED_CODE();

#ifndef CM_ENABLE_MAPPED_VIEWS
    NoBuffering = TRUE;
#endif //CM_ENABLE_MAPPED_VIEWS

RetryNoBuffering:

    *CmHive = NULL;
    LockedHeldOnCall = *RegistryLocked;

    Status = CmpOpenHiveFiles(FileName,
                              L".LOG",
                              &PrimaryHandle,
                              &LogHandle,
                              &Disposition,
                              &SecondaryDisposition,
                              *Allocate,
                              FALSE,
                              NoBuffering,
                              NULL);

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    if (LogHandle == NULL) {
        FileType = HFILE_TYPE_PRIMARY;
    } else {
        FileType = HFILE_TYPE_LOG;
    }

    if (Disposition == FILE_CREATED) {
        Operation = HINIT_CREATE;
        *Allocate = TRUE;
    } else {
        if( NoBuffering == TRUE ) {
            Operation = HINIT_FILE;
        } else {
            Operation = HINIT_MAPFILE;
        }
        *Allocate = FALSE;
    }

    if (CmpShareSystemHives) {
        FileType = HFILE_TYPE_PRIMARY;

        if (LogHandle) {
            ZwClose(LogHandle);
            LogHandle = NULL;
        }
    }

    if( !(*RegistryLocked) ) {
        //
        // Registry should be locked exclusive
        // if not, lock it now and signal this to the caller
        //
        CmpLockRegistryExclusive();
        *RegistryLocked = TRUE;
    }

    if( HvShutdownComplete == TRUE ) {
        ZwClose(PrimaryHandle);
        if (LogHandle != NULL) {
            ZwClose(LogHandle);
        }
        return STATUS_TOO_LATE;
    }

    Status = CmpInitializeHive(&NewHive,
                                Operation,
                                HiveFlags,
                                FileType,
                                HiveData,
                                PrimaryHandle,
                                LogHandle,
                                NULL,
                                FileName,
                                CheckFlags
                                );

    if (!NT_SUCCESS(Status)) {
        CmpTrackHiveClose = TRUE;
        ZwClose(PrimaryHandle);
        CmpTrackHiveClose = FALSE;
        if (LogHandle != NULL) {
            ZwClose(LogHandle);
        }

        if( Status == STATUS_RETRY ) {
            if( NoBuffering == FALSE ) {
                NoBuffering = TRUE;
                if( !LockedHeldOnCall ) {
                    *RegistryLocked = FALSE;
                    CmpUnlockRegistry();
                }
                goto RetryNoBuffering;
            }
        }
        return(Status);
    } else {
        *CmHive = NewHive;

        //
        // mark handles as protected. If other kernel component tries to close them ==> bugcheck.
        //
        CmpSetHandleProtection(PrimaryHandle,TRUE);
        if (LogHandle != NULL) {
            CmpSetHandleProtection(LogHandle,TRUE);
        }

        //
        // Capture the file name; in case we need it later for double load check
        //
        (*CmHive)->FileUserName.Buffer = ExAllocatePoolWithTag(PagedPool,
                                                            FileName->Length,
                                                            CM_NAME_TAG | PROTECTED_POOL);

        if ((*CmHive)->FileUserName.Buffer) {

            RtlCopyMemory((*CmHive)->FileUserName.Buffer,
                          FileName->Buffer,
                          FileName->Length);

            (*CmHive)->FileUserName.Length = FileName->Length;
            (*CmHive)->FileUserName.MaximumLength = FileName->Length;

        }
        if(((PHHIVE)(*CmHive))->BaseBlock->BootType & HBOOT_SELFHEAL) {
            //
            // Warn the user;
            //
            CmpRaiseSelfHealWarning(&((*CmHive)->FileUserName));
        }
        return(STATUS_SUCCESS);
    }
}


NTSTATUS
CmpAddDockingInfo (
    IN HANDLE Key,
    IN PROFILE_PARAMETER_BLOCK * ProfileBlock
    )
/*++
Routine Description:
    Write DockID SerialNumber DockState and Capabilities intot the given
    registry key.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING name;
    ULONG value;

    PAGED_CODE ();

    value = ProfileBlock->DockingState;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKING_STATE);
    status = NtSetValueKey (Key,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    if (!NT_SUCCESS (status)) {
        return status;
    }

    value = ProfileBlock->Capabilities;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CAPABILITIES);
    status = NtSetValueKey (Key,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    if (!NT_SUCCESS (status)) {
        return status;
    }

    value = ProfileBlock->DockID;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKID);
    status = NtSetValueKey (Key,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    if (!NT_SUCCESS (status)) {
        return status;
    }

    value = ProfileBlock->SerialNumber;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_SERIAL_NUMBER);
    status = NtSetValueKey (Key,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    if (!NT_SUCCESS (status)) {
        return status;
    }

    return status;
}


NTSTATUS
CmpAddAliasEntry (
    IN HANDLE IDConfigDB,
    IN PROFILE_PARAMETER_BLOCK * ProfileBlock,
    IN ULONG  ProfileNumber
    )
/*++
Routine Description:
    Create an alias entry in the IDConfigDB database for the given
    hardware profile.

    Create the "Alias" key if it does not exist.

Parameters:

    IDConfigDB - Pointer to "..\CurrentControlSet\Control\IDConfigDB"

    ProfileBlock - Description of the current Docking information

    ProfileNumber -

--*/
{
    OBJECT_ATTRIBUTES attributes;
    NTSTATUS        status = STATUS_SUCCESS;
    CHAR            asciiBuffer [128];
    WCHAR           unicodeBuffer [128];
    ANSI_STRING     ansiString;
    UNICODE_STRING  name;
    HANDLE          aliasKey = NULL;
    HANDLE          aliasEntry = NULL;
    ULONG           value;
    ULONG           disposition;
    ULONG           aliasNumber = 0;

    PAGED_CODE ();

    //
    // Find the Alias Key or Create it if it does not already exist.
    //
    RtlInitUnicodeString (&name,CM_HARDWARE_PROFILE_STR_ALIAS);

    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                IDConfigDB,
                                NULL);

    status = NtOpenKey (&aliasKey,
                        KEY_READ | KEY_WRITE,
                        &attributes);

    if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
        status = NtCreateKey (&aliasKey,
                              KEY_READ | KEY_WRITE,
                              &attributes,
                              0, // no title
                              NULL, // no class
                              0, // no options
                              &disposition);
    }

    if (!NT_SUCCESS (status)) {
        aliasKey = NULL;
        goto Exit;
    }

    //
    // Create an entry key
    //

    while (aliasNumber < 200) {
        aliasNumber++;

        sprintf(asciiBuffer, "%04d", aliasNumber);

        RtlInitAnsiString(&ansiString, asciiBuffer);
        name.MaximumLength = sizeof(unicodeBuffer);
        name.Buffer = unicodeBuffer;
        status = RtlAnsiStringToUnicodeString(&name,
                                              &ansiString,
                                              FALSE);
        ASSERT (STATUS_SUCCESS == status);

        InitializeObjectAttributes(&attributes,
                                   &name,
                                   OBJ_CASE_INSENSITIVE,
                                   aliasKey,
                                   NULL);

        status = NtOpenKey (&aliasEntry,
                            KEY_READ | KEY_WRITE,
                            &attributes);

        if (NT_SUCCESS (status)) {
            NtClose (aliasEntry);

        } else if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
            status = STATUS_SUCCESS;
            break;

        } else {
            break;
        }

    }
    if (!NT_SUCCESS (status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: cmpCreateAliasEntry error finding new set %08lx\n",status));

        aliasEntry = 0;
        goto Exit;
    }

    status = NtCreateKey (&aliasEntry,
                          KEY_READ | KEY_WRITE,
                          &attributes,
                          0,
                          NULL,
                          0,
                          &disposition);

    if (!NT_SUCCESS (status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: cmpCreateAliasEntry error creating new set %08lx\n",status));

        aliasEntry = 0;
        goto Exit;
    }

    //
    // Write the standard goo
    //
    CmpAddDockingInfo (aliasEntry, ProfileBlock);

    //
    // Write the Profile Number
    //
    value = ProfileNumber;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PROFILE_NUMBER);
    status = NtSetValueKey (aliasEntry,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

Exit:

    if (aliasKey) {
        NtClose (aliasKey);
    }

    if (aliasEntry) {
        NtClose (aliasEntry);
    }

    return status;
}


NTSTATUS
CmpHwprofileDefaultSelect (
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse,
    IN  PVOID Context
    )
{
    UNREFERENCED_PARAMETER (Context);

    * ProfileIndexToUse = 0;

    return STATUS_SUCCESS;
}




NTSTATUS
CmpCreateControlSet(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine sets up the symbolic links from

        \Registry\Machine\System\CurrentControlSet to
        \Registry\Machine\System\ControlSetNNN

        \Registry\Machine\System\CurrentControlSet\Hardware Profiles\Current to
        \Registry\Machine\System\ControlSetNNN\Hardware Profiles\NNNN

    based on the value of \Registry\Machine\System\Select:Current. and
                          \Registry\Machine\System\ControlSetNNN\Control\IDConfigDB:CurrentConfig

Arguments:

    None

Return Value:

    status

--*/

{
    UNICODE_STRING IDConfigDBName;
    UNICODE_STRING SelectName;
    UNICODE_STRING CurrentName;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE SelectHandle;
    HANDLE CurrentHandle;
    HANDLE IDConfigDB = NULL;
    HANDLE CurrentProfile = NULL;
    HANDLE ParentOfProfile = NULL;
    CHAR AsciiBuffer[128];
    WCHAR UnicodeBuffer[128];
    UCHAR ValueBuffer[128];
    ULONG ControlSet;
    ULONG HWProfile;
    PKEY_VALUE_FULL_INFORMATION Value;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG ResultLength;
    ULONG Disposition;
    BOOLEAN signalAcpiEvent = FALSE;

    PAGED_CODE();

    RtlInitUnicodeString(&SelectName, L"\\Registry\\Machine\\System\\Select");
    InitializeObjectAttributes(&Attributes,
                               &SelectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&SelectHandle,
                       KEY_READ,
                       &Attributes);
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: Couldn't open Select node %08lx\n",Status));

        return(Status);
    }

    RtlInitUnicodeString(&CurrentName, L"Current");
    Status = NtQueryValueKey(SelectHandle,
                             &CurrentName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             sizeof(ValueBuffer),
                             &ResultLength);
    NtClose(SelectHandle);
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: Couldn't query Select value %08lx\n",Status));

        return(Status);
    }
    Value = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    ControlSet = *(PULONG)((PUCHAR)Value + Value->DataOffset);

    RtlInitUnicodeString(&CurrentName, L"\\Registry\\Machine\\System\\CurrentControlSet");
    InitializeObjectAttributes(&Attributes,
                               &CurrentName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtCreateKey(&CurrentHandle,
                         KEY_CREATE_LINK,
                         &Attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                         &Disposition);
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: couldn't create CurrentControlSet %08lx\n",Status));

        return(Status);
    }

    //
    // Check to make sure that the key was created, not just opened.  Since
    // this key is always created volatile, it should never be present in
    // the hive when we boot.
    //
    ASSERT(Disposition == REG_CREATED_NEW_KEY);

    //
    // Create symbolic link for current hardware profile.
    //
    sprintf(AsciiBuffer, "\\Registry\\Machine\\System\\ControlSet%03d", ControlSet);
    RtlInitAnsiString(&AnsiString, AsciiBuffer);

    CurrentName.MaximumLength = sizeof(UnicodeBuffer);
    CurrentName.Buffer = UnicodeBuffer;
    Status = RtlAnsiStringToUnicodeString(&CurrentName,
                                          &AnsiString,
                                          FALSE);
    Status = NtSetValueKey(CurrentHandle,
                           &CmSymbolicLinkValueName,
                           0,
                           REG_LINK,
                           CurrentName.Buffer,
                           CurrentName.Length);

    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: couldn't create symbolic link "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"to %wZ\n",&CurrentName));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"    Status=%08lx\n",Status));

        NtClose(CurrentHandle);

        return(Status);
    }

    //
    // Determine the Current Hardware Profile Number
    //
    RtlInitUnicodeString(&IDConfigDBName, L"Control\\IDConfigDB");
    InitializeObjectAttributes(&Attributes,
                               &IDConfigDBName,
                               OBJ_CASE_INSENSITIVE,
                               CurrentHandle,
                               NULL);
    Status = NtOpenKey(&IDConfigDB,
                       KEY_READ,
                       &Attributes);
    NtClose(CurrentHandle);

    if (!NT_SUCCESS(Status)) {
        IDConfigDB = 0;
        goto Cleanup;
    }

    RtlInitUnicodeString(&CurrentName, L"CurrentConfig");
    Status = NtQueryValueKey(IDConfigDB,
                             &CurrentName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             sizeof(ValueBuffer),
                             &ResultLength);

    if (!NT_SUCCESS(Status) ||
        (((PKEY_VALUE_FULL_INFORMATION)ValueBuffer)->Type != REG_DWORD)) {

        goto Cleanup;
    }

    Value = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    HWProfile = *(PULONG)((PUCHAR)Value + Value->DataOffset);
    //
    // We know now the config set that the user selected.
    // namely: HWProfile.
    //

    RtlInitUnicodeString(
              &CurrentName,
              L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles");
    InitializeObjectAttributes(&Attributes,
                               &CurrentName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&ParentOfProfile,
                       KEY_READ,
                       &Attributes);

    if (!NT_SUCCESS (Status)) {
        ParentOfProfile = 0;
        goto Cleanup;
    }

    sprintf(AsciiBuffer, "%04d",HWProfile);
    RtlInitAnsiString(&AnsiString, AsciiBuffer);
    CurrentName.MaximumLength = sizeof(UnicodeBuffer);
    CurrentName.Buffer = UnicodeBuffer;
    Status = RtlAnsiStringToUnicodeString(&CurrentName,
                                          &AnsiString,
                                          FALSE);
    ASSERT (STATUS_SUCCESS == Status);

    InitializeObjectAttributes(&Attributes,
                               &CurrentName,
                               OBJ_CASE_INSENSITIVE,
                               ParentOfProfile,
                               NULL);

    Status = NtOpenKey (&CurrentProfile,
                        KEY_READ | KEY_WRITE,
                        &Attributes);

    if (!NT_SUCCESS (Status)) {
        CurrentProfile = 0;
        goto Cleanup;
    }

    //
    // We need to determine if Value was selected by exact match
    // (TRUE_MATCH) or because the profile selected was aliasable.
    //
    // If aliasable we need to manufacture another alias entry in the
    // alias table.
    //
    // If the profile information is there and not failed then we should
    // mark the Docking state information:
    // (DockID, SerialNumber, DockState, and Capabilities)
    //

    if (NULL != LoaderBlock->Extension) {
        PLOADER_PARAMETER_EXTENSION extension;
        extension = LoaderBlock->Extension;
        switch (extension->Profile.Status) {
        case HW_PROFILE_STATUS_PRISTINE_MATCH:
            //
            // If the selected profile is pristine then we need to clone.
            //
            Status = CmpCloneHwProfile (IDConfigDB,
                                        ParentOfProfile,
                                        CurrentProfile,
                                        HWProfile,
                                        extension->Profile.DockingState,
                                        &CurrentProfile,
                                        &HWProfile);
            if (!NT_SUCCESS (Status)) {
                CurrentProfile = 0;
                goto Cleanup;
            }

            RtlInitUnicodeString(&CurrentName, L"CurrentConfig");
            Status = NtSetValueKey (IDConfigDB,
                                    &CurrentName,
                                    0,
                                    REG_DWORD,
                                    &HWProfile,
                                    sizeof (HWProfile));
            if (!NT_SUCCESS (Status)) {
                goto Cleanup;
            }

            //
            // Fall through
            //
        case HW_PROFILE_STATUS_ALIAS_MATCH:
            //
            // Create the alias entry for this profile.
            //

            Status = CmpAddAliasEntry (IDConfigDB,
                                       &extension->Profile,
                                       HWProfile);

            //
            // Fall through
            //
        case HW_PROFILE_STATUS_TRUE_MATCH:
            //
            // Write DockID, SerialNumber, DockState, and Caps into the current
            // Hardware profile.
            //

            RtlInitUnicodeString (&CurrentName,
                                  CM_HARDWARE_PROFILE_STR_CURRENT_DOCK_INFO);

            InitializeObjectAttributes (&Attributes,
                                        &CurrentName,
                                        OBJ_CASE_INSENSITIVE,
                                        IDConfigDB,
                                        NULL);

            Status = NtCreateKey (&CurrentHandle,
                                  KEY_READ | KEY_WRITE,
                                  &Attributes,
                                  0,
                                  NULL,
                                  REG_OPTION_VOLATILE,
                                  &Disposition);

            ASSERT (STATUS_SUCCESS == Status);

            Status = CmpAddDockingInfo (CurrentHandle, &extension->Profile);

            NtClose(CurrentHandle);

            if (HW_PROFILE_DOCKSTATE_UNDOCKED == extension->Profile.DockingState) {
                signalAcpiEvent = TRUE;
            }

            break;


        case HW_PROFILE_STATUS_SUCCESS:
        case HW_PROFILE_STATUS_FAILURE:
            break;

        default:
            ASSERTMSG ("Invalid Profile status state", FALSE);
        }
    }

    //
    // Create the symbolic link.
    //
    RtlInitUnicodeString(&CurrentName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current");
    InitializeObjectAttributes(&Attributes,
                               &CurrentName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtCreateKey(&CurrentHandle,
                         KEY_CREATE_LINK,
                         &Attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                         &Disposition);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: couldn't create Hardware Profile\\Current %08lx\n",Status));
    } else {
        ASSERT(Disposition == REG_CREATED_NEW_KEY);

        sprintf(AsciiBuffer, "\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\%04d",HWProfile);
        RtlInitAnsiString(&AnsiString, AsciiBuffer);
        CurrentName.MaximumLength = sizeof(UnicodeBuffer);
        CurrentName.Buffer = UnicodeBuffer;
        Status = RtlAnsiStringToUnicodeString(&CurrentName,
                                              &AnsiString,
                                              FALSE);
        ASSERT (STATUS_SUCCESS == Status);

        Status = NtSetValueKey(CurrentHandle,
                               &CmSymbolicLinkValueName,
                               0,
                               REG_LINK,
                               CurrentName.Buffer,
                               CurrentName.Length);

        NtClose(CurrentHandle);

        if (!NT_SUCCESS(Status)) {

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: couldn't create symbolic link "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"to %wZ\n",&CurrentName));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"    Status=%08lx\n",Status));

        }
    }

    if (signalAcpiEvent) {
        //
        // We are booting in the undocked state.
        // This is interesting because our buddies in PnP cannot tell
        // us when we are booting without a dock.  They can only tell
        // us when they see a hot undock.
        //
        // Therefore in the interest of matching a boot undocked with
        // a hot undock, we need to simulate an acpi undock event.
        //

        PROFILE_ACPI_DOCKING_STATE newDockState;
        HANDLE profile;
        BOOLEAN changed;

        newDockState.DockingState = HW_PROFILE_DOCKSTATE_UNDOCKED;
        newDockState.SerialLength = 2;
        newDockState.SerialNumber[0] = L'\0';

        Status = CmSetAcpiHwProfile (&newDockState,
                                     CmpHwprofileDefaultSelect,
                                     NULL,
                                     &profile,
                                     &changed);

        ASSERT (NT_SUCCESS (Status));
        NtClose (profile);
    }


Cleanup:
    if (IDConfigDB) {
        NtClose (IDConfigDB);
    }
    if (CurrentProfile) {
        NtClose (CurrentProfile);
    }
    if (ParentOfProfile) {
        NtClose (ParentOfProfile);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
CmpCloneControlSet(
    VOID
    )

/*++

Routine Description:

    First, create a new hive, \registry\machine\clone, which will be
    HIVE_VOLATILE.

    Second, link \Registry\Machine\System\Clone to it.

    Third, tree copy \Registry\Machine\System\CurrentControlSet into
    \Registry\Machine\System\Clone (and thus into the clone hive.)

    When the service controller is done with the clone hive, it can
    simply NtUnloadKey it to free its storage.

Arguments:

    None.  \Registry\Machine\System\CurrentControlSet must already exist.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING Current;
    UNICODE_STRING Clone;
    HANDLE CurrentHandle;
    HANDLE CloneHandle;
    OBJECT_ATTRIBUTES Attributes;
    NTSTATUS Status;
    PCM_KEY_BODY CurrentKey;
    PCM_KEY_BODY CloneKey;
    ULONG Disposition;
    PSECURITY_DESCRIPTOR Security;
    ULONG SecurityLength;

    PAGED_CODE();

    RtlInitUnicodeString(&Current,
                         L"\\Registry\\Machine\\System\\CurrentControlSet");
    RtlInitUnicodeString(&Clone,
                         L"\\Registry\\Machine\\System\\Clone");

    InitializeObjectAttributes(&Attributes,
                               &Current,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&CurrentHandle,
                       KEY_READ,
                       &Attributes);
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet couldn't open CurrentControlSet %08lx\n",Status));

        return(Status);
    }

    //
    // Get the security descriptor from the key so we can create the clone
    // tree with the correct ACL.
    //
    Status = NtQuerySecurityObject(CurrentHandle,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   0,
                                   &SecurityLength);
    if (Status==STATUS_BUFFER_TOO_SMALL) {
        Security=ExAllocatePool(PagedPool,SecurityLength);
        if (Security!=NULL) {
            Status = NtQuerySecurityObject(CurrentHandle,
                                           DACL_SECURITY_INFORMATION,
                                           Security,
                                           SecurityLength,
                                           &SecurityLength);
            if (!NT_SUCCESS(Status)) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet - NtQuerySecurityObject failed %08lx\n",Status));
                ExFreePool(Security);
                Security=NULL;
            }
        }
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet - NtQuerySecurityObject returned %08lx\n",Status));
        Security=NULL;
    }

    InitializeObjectAttributes(&Attributes,
                               &Clone,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               Security);
    Status = NtCreateKey(&CloneHandle,
                         KEY_READ | KEY_WRITE,
                         &Attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         &Disposition);
    if (Security!=NULL) {
        ExFreePool(Security);
    }
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet couldn't create Clone %08lx\n",Status));
        NtClose(CurrentHandle);
        return(Status);
    }

    //
    // Check to make sure the key was created.  If it already exists,
    // something is wrong.
    //
    if (Disposition != REG_CREATED_NEW_KEY) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet: Clone tree already exists!\n"));

        //
        // WARNNOTE:
        //      If somebody somehow managed to create a key in our way,
        //      they'll thwart last known good.  Tough luck.
        //      Claim it worked and go on.
        //
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    Status = ObReferenceObjectByHandle(CurrentHandle,
                                       KEY_READ,
                                       CmpKeyObjectType,
                                       KernelMode,
                                       (PVOID *)(&CurrentKey),
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet: couldn't reference CurrentHandle %08lx\n",Status));
        goto Exit;
    }

    Status = ObReferenceObjectByHandle(CloneHandle,
                                       KEY_WRITE,
                                       CmpKeyObjectType,
                                       KernelMode,
                                       (PVOID *)(&CloneKey),
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet: couldn't reference CurrentHandle %08lx\n",Status));
        ObDereferenceObject((PVOID)CurrentKey);
        goto Exit;
    }

    CmpLockRegistryExclusive();

    if (CmpCopyTree(CurrentKey->KeyControlBlock->KeyHive,
                    CurrentKey->KeyControlBlock->KeyCell,
                    CloneKey->KeyControlBlock->KeyHive,
                    CloneKey->KeyControlBlock->KeyCell)) {
        //
        // Set the max subkey name property for the new target key.
        //
        CmpRebuildKcbCache(CloneKey->KeyControlBlock);
        Status = STATUS_SUCCESS;
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet: tree copy failed.\n"));
        Status = STATUS_REGISTRY_CORRUPT;
    }

    CmpUnlockRegistry();

    ObDereferenceObject((PVOID)CurrentKey);
    ObDereferenceObject((PVOID)CloneKey);

Exit:
    NtClose(CurrentHandle);
    NtClose(CloneHandle);
    return(Status);

}

NTSTATUS
CmpSaveBootControlSet(USHORT ControlSetNum)
/*++

Routine Description:

   This routine is responsible for saving the control set
   used to accomplish the latest boot into a different control
   set (presumably so that the different control set may be
   marked as the LKG control set).

   This routine is called from NtInitializeRegistry when
   a boot is accepted via that routine.

Arguments:

   ControlSetNum - The number of the control set that will
                   be used to save the boot control set.

Return Value:

   NTSTATUS result code from call, among the following:

      STATUS_SUCCESS - everything worked perfectly
      STATUS_REGISTRY_CORRUPT - could not save the boot control set,
                                it is likely that the copy or sync
                                operation used for this save failed
                                and some part of the boot control
                                set was not saved.
--*/
{
   UNICODE_STRING SavedBoot, Boot;
   HANDLE BootHandle, SavedBootHandle;
   OBJECT_ATTRIBUTES Attributes;
   NTSTATUS Status;
   PCM_KEY_BODY BootKey, SavedBootKey;
   ULONG Disposition;
   PSECURITY_DESCRIPTOR Security;
   ULONG SecurityLength;
   BOOLEAN CopyRet;
   WCHAR Buffer[128];

   //
   // Figure out where the boot control set is
   //

#if CLONE_CONTROL_SET

   //
   // If we have cloned the control set, then use the clone
   // since it is guaranteed to have an untouched copy of the
   // boot control set
   //

   RtlInitUnicodeString(&Boot,
                        L"\\Registry\\Machine\\System\\Clone");

   InitializeObjectAttributes(&Attributes,
                              &Boot,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);
#else

   //
   // If we are not using the clone, then just use the
   // current control set.
   //

   InitializeObjectAttributes(&Attributes,
                              &CmRegistryMachineSystemCurrentControlSet,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);
#endif

   //
   // Open the boot control set
   //

   Status = NtOpenKey(&BootHandle,
                      KEY_READ,
                      &Attributes);


   if (!NT_SUCCESS(Status)) return(Status);

   //
   // We may be saving the boot control set into a brand new
   // tree that we will create. If this is true, then we will
   // need to create the root node of this tree below
   // and give it the right security descriptor. So, we fish
   // the security descriptor out of the root node of the
   // boot control set tree.
   //

   Status = NtQuerySecurityObject(BootHandle,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  0,
                                  &SecurityLength);


   if (Status==STATUS_BUFFER_TOO_SMALL) {

      Security=ExAllocatePool(PagedPool,SecurityLength);

      if (Security!=NULL) {

         Status = NtQuerySecurityObject(BootHandle,
                                        DACL_SECURITY_INFORMATION,
                                        Security,
                                        SecurityLength,
                                        &SecurityLength);


         if (!NT_SUCCESS(Status)) {
            ExFreePool(Security);
            Security=NULL;
         }
      }

   } else {
      Security=NULL;
   }

   //
   // Now, create the path of the control set we will be saving to
   //

   swprintf(Buffer, L"\\Registry\\Machine\\System\\ControlSet%03d", ControlSetNum);

   RtlInitUnicodeString(&SavedBoot,
                        Buffer);

   //
   // Open/Create the control set to which we are saving
   //

   InitializeObjectAttributes(&Attributes,
                              &SavedBoot,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              Security);

   Status = NtCreateKey(&SavedBootHandle,
                        KEY_READ | KEY_WRITE,
                        &Attributes,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        &Disposition);


   if (Security) ExFreePool(Security);

   if (!NT_SUCCESS(Status)) {
      NtClose(BootHandle);
      return(Status);
   }

   //
   // Get the key objects for out two controls
   //

   Status = ObReferenceObjectByHandle(BootHandle,
                                      KEY_READ,
                                      CmpKeyObjectType,
                                      KernelMode,
                                      (PVOID *)(&BootKey),
                                      NULL);

   if (!NT_SUCCESS(Status)) goto Exit;

   Status = ObReferenceObjectByHandle(SavedBootHandle,
                                      KEY_WRITE,
                                      CmpKeyObjectType,
                                      KernelMode,
                                      (PVOID *)(&SavedBootKey),
                                      NULL);


   if (!NT_SUCCESS(Status)) {
      ObDereferenceObject((PVOID)BootKey);
      goto Exit;
   }

   //
   // Lock the registry and do the actual saving
   //

   CmpLockRegistryExclusive();

   if (Disposition == REG_CREATED_NEW_KEY) {

      //
      // If we are saving to a control set that we have just
      // created, it is most efficient to just copy
      // the boot control set tree into the new control set.
      //

      //
      // N.B. We copy the volatile keys only if we are using
      //      a clone and thus our boot control set tree is
      //      composed only of volatile keys.
      //

      CopyRet = CmpCopyTreeEx(BootKey->KeyControlBlock->KeyHive,
                              BootKey->KeyControlBlock->KeyCell,
                              SavedBootKey->KeyControlBlock->KeyHive,
                              SavedBootKey->KeyControlBlock->KeyCell,
                              CLONE_CONTROL_SET);

        //
        // Set the max subkey name property for the new target key.
        //
        CmpRebuildKcbCache(SavedBootKey->KeyControlBlock);
   } else {

      //
      // If we are saving to a control set that already exists
      // then its likely that this control set is nearly identical
      // to the boot control set (control sets don't change much
      // between boots).
      //
      // Furthermore, the control set we are saving to must be old
      // and hence has not been modified at all since it ceased
      // being a current control set.
      //
      // Thus, it is most efficient for us to simply synchronize
      // the target control set with the boot control set.
      //

      //
      // N.B. We sync the volatile keys only if we are using
      //      a clone for the same reasons as stated above.
      //

      CopyRet = CmpSyncTrees(BootKey->KeyControlBlock->KeyHive,
                             BootKey->KeyControlBlock->KeyCell,
                             SavedBootKey->KeyControlBlock->KeyHive,
                             SavedBootKey->KeyControlBlock->KeyCell,
                             CLONE_CONTROL_SET);
      CmpRebuildKcbCache(SavedBootKey->KeyControlBlock);
   }

   //
   // Check if the Copy/Sync succeeded and adjust our return code
   // accordingly.
   //

   if (CopyRet) {
      Status = STATUS_SUCCESS;
   } else {
      Status = STATUS_REGISTRY_CORRUPT;
   }

   //
   // All done. Clean up.
   //

   CmpUnlockRegistry();

   ObDereferenceObject((PVOID)BootKey);
   ObDereferenceObject((PVOID)SavedBootKey);

Exit:

   NtClose(BootHandle);
   NtClose(SavedBootHandle);

#if CLONE_CONTROL_SET

   //
   // If we have been using a clone, then the clone is no longer
   // needed since we have saved its contents into a non-volatile
   // control set. Thus, we can just erase it.
   //

   if(NT_SUCCESS(Status))
   {
      CmpDeleteCloneTree();
   }

#endif

   return(Status);

}

NTSTATUS
CmpDeleteCloneTree()
/*++

Routine Description:

   Deletes the cloned CurrentControlSet by unloading the CLONE hive.

Arguments:

   NONE.

Return Value:

   NTSTATUS return from NtUnloadKey.

--*/
{
   OBJECT_ATTRIBUTES   Obja;

   InitializeObjectAttributes(
       &Obja,
       &CmRegistrySystemCloneName,
       OBJ_CASE_INSENSITIVE,
       (HANDLE)NULL,
       NULL);

   return NtUnloadKey(&Obja);
}


VOID
CmBootLastKnownGood(
    ULONG ErrorLevel
    )

/*++

Routine Description:

    This function is called to indicate a failure during the boot process.
    The actual result is based on the value of ErrorLevel:

        IGNORE - Will return, boot should proceed
        NORMAL - Will return, boot should proceed

        SEVERE - If not booting LastKnownGood, will switch to LastKnownGood
                 and reboot the system.

                 If already booting LastKnownGood, will return.  Boot should
                 proceed.

        CRITICAL - If not booting LastKnownGood, will switch to LastKnownGood
                 and reboot the system.

                 If already booting LastKnownGood, will bugcheck.

Arguments:

    ErrorLevel - Supplies the severity level of the failure

Return Value:

    None.  If it returns, boot should proceed.  May cause the system to
    reboot.

--*/

{
    ARC_STATUS Status;

    PAGED_CODE();

    if (CmFirstTime != TRUE) {

        //
        // NtInitializeRegistry has been called, so handling
        // driver errors is not a task for ScReg.
        // Treat all errors as Normal
        //
        return;
    }

    switch (ErrorLevel) {
        case NormalError:
        case IgnoreError:
            break;

        case SevereError:
            if (CmIsLastKnownGoodBoot()) {
                break;
            } else {
                Status = HalSetEnvironmentVariable("LastKnownGood", "TRUE");
                if (Status == ESUCCESS) {
                    HalReturnToFirmware(HalRebootRoutine);
                }
            }
            break;

        case CriticalError:
            if (CmIsLastKnownGoodBoot()) {
                CM_BUGCHECK( CRITICAL_SERVICE_FAILED, BAD_LAST_KNOWN_GOOD, 1, 0, 0 );
            } else {
                Status = HalSetEnvironmentVariable("LastKnownGood", "TRUE");
                if (Status == ESUCCESS) {
                    HalReturnToFirmware(HalRebootRoutine);
                } else {
                    CM_BUGCHECK( SET_ENV_VAR_FAILED, BAD_LAST_KNOWN_GOOD, 2, 0, 0 );
                }
            }
            break;
    }
    return;
}


BOOLEAN
CmIsLastKnownGoodBoot(
    VOID
    )

/*++

Routine Description:

    Determines whether the current system boot is a LastKnownGood boot or
    not.  It does this by comparing the following two values:

        \registry\machine\system\select:Current
        \registry\machine\system\select:LastKnownGood

    If both of these values refer to the same control set, and this control
    set is different from:

        \registry\machine\system\select:Default

    we are booting LastKnownGood.

Arguments:

    None.

Return Value:

    TRUE  - Booting LastKnownGood
    FALSE - Not booting LastKnownGood

--*/

{
    NTSTATUS Status;
    ULONG Default;
    ULONG Current;
    ULONG LKG;
    RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
        {NULL,      RTL_QUERY_REGISTRY_DIRECT,
         L"Current", &Current,
         REG_DWORD, (PVOID)&Current, 0 },
        {NULL,      RTL_QUERY_REGISTRY_DIRECT,
         L"LastKnownGood", &LKG,
         REG_DWORD, (PVOID)&LKG, 0 },
        {NULL,      RTL_QUERY_REGISTRY_DIRECT,
         L"Default", &Default,
         REG_DWORD, (PVOID)&Default, 0 },
        {NULL,      0,
         NULL, NULL,
         REG_NONE, NULL, 0 }
    };

    PAGED_CODE();

    Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    L"\\Registry\\Machine\\System\\Select",
                                    QueryTable,
                                    NULL,
                                    NULL);
    //
    // If this failed, something is severely wrong.
    //

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmIsLastKnownGoodBoot: RtlQueryRegistryValues "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"failed, Status %08lx\n", Status));
        return(FALSE);
    }

    if ((LKG == Current) && (Current != Default)){
        return(TRUE);
    } else {
        return(FALSE);
    }
}

BOOLEAN
CmpLinkKeyToHive(
    PWSTR   KeyPath,
    PWSTR   HivePath
    )

/*++

Routine Description:

    Creates a symbolic link at KeyPath that points to HivePath.

Arguments:

    KeyPath - pointer to unicode string with name of key
              (e.g. L"\\Registry\\Machine\\Security\\SAM")

    HivePath - pointer to unicode string with name of hive root
               (e.g. L"\\Registry\\Machine\\SAM\\SAM")

Return Value:

    TRUE if links were successfully created, FALSE otherwise

--*/

{
    UNICODE_STRING KeyName;
    UNICODE_STRING LinkName;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE LinkHandle;
    ULONG Disposition;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Create link for CLONE hive
    //

    RtlInitUnicodeString(&KeyName, KeyPath);
    InitializeObjectAttributes(&Attributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtCreateKey(&LinkHandle,
                         KEY_CREATE_LINK,
                         &Attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                         &Disposition);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpLinkKeyToHive: couldn't create %S\n", &KeyName));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"    Status = %08lx\n",Status));
        return(FALSE);
    }

    //
    // Check to make sure that the key was created, not just opened.  Since
    // this key is always created volatile, it should never be present in
    // the hive when we boot.
    //
    if (Disposition != REG_CREATED_NEW_KEY) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpLinkKeyToHive: %S already exists!\n", &KeyName));
        NtClose(LinkHandle);
        return(FALSE);
    }

    RtlInitUnicodeString(&LinkName, HivePath);
    Status = NtSetValueKey(LinkHandle,
                           &CmSymbolicLinkValueName,
                           0,
                           REG_LINK,
                           LinkName.Buffer,
                           LinkName.Length);
    NtClose(LinkHandle);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpLinkKeyToHive: couldn't create symbolic link for %S\n", HivePath));
        return(FALSE);
    }

    return(TRUE);
}

VOID
CmpCreatePerfKeys(
    VOID
    )

/*++

Routine Description:

    Creates predefined keys for the performance text to support old apps on 1.0a

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE Perflib;
    NTSTATUS Status;
    WCHAR LanguageId[4];
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING String;
    USHORT Language;
    LONG i;
    WCHAR c;
    extern PWCHAR CmpRegistryPerflibString;

    RtlInitUnicodeString(&String, CmpRegistryPerflibString);

    InitializeObjectAttributes(&Attributes,
                               &String,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&Perflib,
                       KEY_WRITE,
                       &Attributes);
    if (!NT_SUCCESS(Status)) {
        return;
    }


    //
    // Always create the predefined keys for the english language
    //
    CmpCreatePredefined(Perflib,
                        L"009",
                        HKEY_PERFORMANCE_TEXT);

    //
    // If the default language is not english, create a predefined key for
    // that, too.
    //
    if (PsDefaultSystemLocaleId != 0x00000409) {
        Language = LANGIDFROMLCID(PsDefaultSystemLocaleId) & 0xff;
        LanguageId[3] = L'\0';
        for (i=2;i>=0;i--) {
            c = Language % 16;
            if (c>9) {
                LanguageId[i]= c+L'A'-10;
            } else {
                LanguageId[i]= c+L'0';
            }
            Language = Language >> 4;
        }
        CmpCreatePredefined(Perflib,
                            LanguageId,
                            HKEY_PERFORMANCE_NLSTEXT);
    }


}


VOID
CmpCreatePredefined(
    IN HANDLE Root,
    IN PWSTR KeyName,
    IN HANDLE PredefinedHandle
    )

/*++

Routine Description:

    Creates a special key that will always return the given predefined handle
    instead of a real handle.

Arguments:

    Root - supplies the handle the keyname is relative to

    KeyName - supplies the name of the key.

    PredefinedHandle - supplies the predefined handle to be returned when this
        key is opened.

Return Value:

    None.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    CM_PARSE_CONTEXT ParseContext;
    NTSTATUS Status;
    UNICODE_STRING Name;
    HANDLE Handle;

    ParseContext.Class.Length = 0;
    ParseContext.Class.Buffer = NULL;

    ParseContext.TitleIndex = 0;
    ParseContext.CreateOptions = REG_OPTION_VOLATILE | REG_OPTION_PREDEF_HANDLE;
    ParseContext.Disposition = 0;
    ParseContext.CreateLink = FALSE;
    ParseContext.PredefinedHandle = PredefinedHandle;

    RtlInitUnicodeString(&Name, KeyName);
    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               Root,
                               NULL);

    Status = ObOpenObjectByName(&ObjectAttributes,
                                CmpKeyObjectType,
                                KernelMode,
                                NULL,
                                KEY_READ,
                                (PVOID)&ParseContext,
                                &Handle);

    ASSERT(CmpMiniNTBoot || NT_SUCCESS(Status));

    if (NT_SUCCESS(Status))
        ZwClose(Handle);
}

BOOLEAN   CmpSystemHiveConversionFailed = FALSE;

NTSTATUS
CmpSetupPrivateWrite(
    PCMHIVE             CmHive
    )
/*++

Routine Description:

    Converts the primary file to private write stream

Arguments:

    CmHive - hive to convert, tipically SYSTEM

Return Value:

    NONE; bugchecks if something wrong

--*/
{
    ULONG       FileOffset;
    ULONG       Data;
    NTSTATUS    Status;

    PAGED_CODE()

    //
    //  We need to issue a read from the file, to trigger the cache initialization
    //
    FileOffset = 0;
    if ( ! (((PHHIVE)CmHive)->FileRead)(
                    (PHHIVE)CmHive,
                    HFILE_TYPE_PRIMARY,
                    &FileOffset,
                    (PVOID)&Data,
                    sizeof(ULONG)
                    )
       )
    {
        return STATUS_REGISTRY_IO_FAILED;
    }

    //
    // Aquire the file object for the primary; This should be called AFTER the
    // cache has been initialized.
    //
    Status = CmpAquireFileObjectForFile(CmHive,CmHive->FileHandles[HFILE_TYPE_PRIMARY],&(CmHive->FileObject));
    if( !NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // set the getCell and releaseCell routines to the right one(s)
    //
    CmHive->Hive.GetCellRoutine = HvpGetCellMapped;
    CmHive->Hive.ReleaseCellRoutine = HvpReleaseCellMapped;

    return STATUS_SUCCESS;
}

//
// This thread is used to load the machine hives in paralel
//
extern  ULONG   CmpCheckHiveIndex;

VOID
CmpLoadHiveThread(
    IN PVOID StartContext
    )
/*++

Routine Description:

    Loads the hive at index StartContext in CmpMachineHiveList

    Warning. We need to protect when enlisting the hives in CmpHiveListHead !!!

Arguments:

Return Value:

--*/
{
    UCHAR   FileBuffer[MAX_NAME];
    UCHAR   RegBuffer[MAX_NAME];

    UNICODE_STRING TempName;
    UNICODE_STRING FileName;
    UNICODE_STRING RegName;

    USHORT  FileStart;
    USHORT  RegStart;
    ULONG   i;
    PCMHIVE CmHive;
    HANDLE  PrimaryHandle;
    HANDLE  LogHandle;
    ULONG   PrimaryDisposition;
    ULONG   SecondaryDisposition;
    ULONG   Length;
    NTSTATUS Status;
    BOOLEAN RegistryLocked = TRUE;

    PVOID   ErrorParameters;
    ULONG   ErrorResponse;
    ULONG   ClusterSize;
    ULONG   LocalWorkerIncrement;

    PAGED_CODE();

    i = (ULONG)(ULONG_PTR)StartContext;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpLoadHiveThread %i ... starting\n",i));

    ASSERT( CmpMachineHiveList[i].Name != NULL );

    if( i == CmpCheckHiveIndex ) {
        //
        // we want to hold this thread until all the others finish, so we have a chance to debug it.
        // last one that finishes will wake us
        //
        KeWaitForSingleObject( &CmpLoadWorkerDebugEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
        ASSERT( CmpLoadWorkerIncrement == (CM_NUMBER_OF_MACHINE_HIVES - 1) );
        DbgBreakPoint();
    }
    //
    // signal that we have started
    //
    CmpMachineHiveList[i].ThreadStarted = TRUE;

    FileName.MaximumLength = MAX_NAME;
    FileName.Length = 0;
    FileName.Buffer = (PWSTR)&(FileBuffer[0]);

    RegName.MaximumLength = MAX_NAME;
    RegName.Length = 0;
    RegName.Buffer = (PWSTR)&(RegBuffer[0]);

    RtlInitUnicodeString(
        &TempName,
        INIT_SYSTEMROOT_HIVEPATH
        );
    RtlAppendStringToString((PSTRING)&FileName, (PSTRING)&TempName);
    FileStart = FileName.Length;

    RtlInitUnicodeString(
        &TempName,
        INIT_REGISTRY_MASTERPATH
        );
    RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);
    RegStart = RegName.Length;

    //
    // Compute the name of the file, and the name to link to in
    // the registry.
    //

    // REGISTRY

    RegName.Length = RegStart;
    RtlInitUnicodeString(
        &TempName,
        CmpMachineHiveList[i].BaseName
        );
    RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);

    // REGISTRY\MACHINE or REGISTRY\USER

    if (RegName.Buffer[ (RegName.Length / sizeof( WCHAR )) - 1 ] == '\\') {
        RtlInitUnicodeString(
            &TempName,
            CmpMachineHiveList[i].Name
            );
        RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);
    }

    // REGISTRY\[MACHINE|USER]\HIVE

    // <sysroot>\config

    RtlInitUnicodeString(
        &TempName,
        CmpMachineHiveList[i].Name
        );
    FileName.Length = FileStart;
    RtlAppendStringToString((PSTRING)&FileName, (PSTRING)&TempName);

    // <sysroot>\config\hive


    if (CmpMachineHiveList[i].CmHive == NULL) {

        //
        // Hive has not been inited in any way.
        //

        CmpMachineHiveList[i].Allocate = TRUE;
        Status = CmpInitHiveFromFile(&FileName,
                                     CmpMachineHiveList[i].Flags,
                                     &CmHive,
                                     &(CmpMachineHiveList[i].Allocate),
                                     &RegistryLocked,
                                     CM_CHECK_REGISTRY_CHECK_CLEAN
                                     );

        if ( (!NT_SUCCESS(Status)) ||
             (!CmpShareSystemHives && (CmHive->FileHandles[HFILE_TYPE_LOG] == NULL)) )
        {
            ErrorParameters = &FileName;
            ExRaiseHardError(
                STATUS_CANNOT_LOAD_REGISTRY_FILE,
                1,
                1,
                (PULONG_PTR)&ErrorParameters,
                OptionOk,
                &ErrorResponse
                );

        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpInitializeHiveList:\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"\tCmHive for '%ws' @", CmpMachineHiveList[i]));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"%08lx", CmHive));

        CmpMachineHiveList[i].CmHive2 = CmHive;
/*
//
// Dragos: This cannot be done here; we need to do it one step at the time back in CmpInitializeHiveList
//

        //
        // Link hive into master hive
        //
        Status = CmpLinkHiveToMaster(
                &RegName,
                NULL,
                CmHive,
                Allocate,
                SecurityDescriptor
                );
        if ( Status != STATUS_SUCCESS)
        {

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeHiveList: "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpLinkHiveToMaster failed\n"));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\ti=%d s='%ws'\n", i, CmpMachineHiveList[i]));

            CM_BUGCHECK(CONFIG_LIST_FAILED,BAD_CORE_HIVE,Status,i,&RegName);
        }
        CmpAddToHiveFileList(CmHive);

        if (Allocate) {
            //
            // I suspect this is the problem.
            //HvSyncHive((PHHIVE)CmHive);
            //
        }
*/

    } else {

        CmHive = CmpMachineHiveList[i].CmHive;

        if (!(CmHive->Hive.HiveFlags & HIVE_VOLATILE)) {

            //
            // CmHive already exists.  It is not an entirely volatile
            // hive (we do nothing for those.)
            //
            // First, open the files (Primary and Alternate) that
            // back the hive.  Stuff their handles into the CmHive
            // object.  Force the size of the files to match the
            // in memory images.  Call HvSyncHive to write changes
            // out to disk.
            //
            BOOLEAN NoBufering = FALSE; // first try to open it cached;

retryNoBufering:

            Status = CmpOpenHiveFiles(&FileName,
                                      L".LOG",
                                      &PrimaryHandle,
                                      &LogHandle,
                                      &PrimaryDisposition,
                                      &SecondaryDisposition,
                                      TRUE,
                                      TRUE,
                                      NoBufering,
                                      &ClusterSize);

            if ( ( ! NT_SUCCESS(Status)) ||
                 (LogHandle == NULL) )
            {
fatal:
                ErrorParameters = &FileName;
                ExRaiseHardError(
                    STATUS_CANNOT_LOAD_REGISTRY_FILE,
                    1,
                    1,
                    (PULONG_PTR)&ErrorParameters,
                    OptionOk,
                    &ErrorResponse
                    );

                //
                // WARNNOTE
                // We've just told the user that something essential,
                // like the SYSTEM hive, is hosed.  Don't try to run,
                // we just risk destroying user data.  Punt.
                //
                CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_HIVE_LIST,0,i,Status);
            }

            CmHive->FileHandles[HFILE_TYPE_LOG] = LogHandle;
            CmHive->FileHandles[HFILE_TYPE_PRIMARY] = PrimaryHandle;

            if( NoBufering == FALSE ) {
                //
                // intitialize cache and mark the stream as PRIVATE_WRITE;
                // next flush will do the actual conversion
                //
                Status = CmpSetupPrivateWrite(CmHive);
            }

            if( !NT_SUCCESS(Status) ) {
                if( (NoBufering == TRUE) || (Status != STATUS_RETRY) ) {
                    //
                    // we have tried both ways and it didn't work; bad luck
                    //
                    goto fatal;
                }

#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Failed to convert SYSTEM hive to mapped (0x%lx) ... loading it in paged pool\n",Status);
#endif //_CM_LDR_
                //
                // close handle and make another attempt to open them without buffering
                //
                CmpTrackHiveClose = TRUE;
                ZwClose(PrimaryHandle);
                CmpTrackHiveClose = FALSE;
                ZwClose(LogHandle);
                NoBufering = TRUE;

                goto retryNoBufering;
            }

            //
            // now that we successfully opened the hive files, clear off the lazy flush flag
            //
            ASSERT( CmHive->Hive.HiveFlags & HIVE_NOLAZYFLUSH );
            CmHive->Hive.HiveFlags &= (~HIVE_NOLAZYFLUSH);

            Length = CmHive->Hive.Storage[Stable].Length + HBLOCK_SIZE;

            //
            // When an in-memory hive is opened with no backing
            // file, ClusterSize is assumed to be 1.  When the file
            // is opened later (for the SYSTEM hive) we need
            // to update this field in the hive if we are
            // booting from media where the cluster size > 1
            //
            if (CmHive->Hive.Cluster != ClusterSize) {
                //
                // The cluster size is different than previous assumed.
                // Since a cluster in the dirty vector must be either
                // completely dirty or completely clean, go through the
                // dirty vector and mark all clusters that contain a dirty
                // logical sector as completely dirty.
                //
                PRTL_BITMAP  BitMap;
                ULONG        Index;

                BitMap = &(CmHive->Hive.DirtyVector);
                for (Index = 0;
                     Index < CmHive->Hive.DirtyVector.SizeOfBitMap;
                     Index += ClusterSize)
                {
                    if (!RtlAreBitsClear (BitMap, Index, ClusterSize)) {
                        RtlSetBits (BitMap, Index, ClusterSize);
                    }
                }
                //
                // Update DirtyCount and Cluster
                //
                CmHive->Hive.DirtyCount = RtlNumberOfSetBits(&CmHive->Hive.DirtyVector);
                CmHive->Hive.Cluster = ClusterSize;
            }

            if (!CmpFileSetSize(
                    (PHHIVE)CmHive, HFILE_TYPE_PRIMARY, Length,Length)
               )
            {
                //
                // WARNNOTE
                // Data written into the system hive since boot
                // cannot be written out, punt.
                //
                CmpCannotWriteConfiguration = TRUE;
            }

            ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);

            if( CmHive->Hive.BaseBlock->BootRecover != 0 ) {
                //
                // boot loader recovered the hive; we need to flush it all to the disk
                // mark everything dirty; the next flush will do take care of the rest
                //
                PRTL_BITMAP  BitMap;
                BitMap = &(CmHive->Hive.DirtyVector);
                RtlSetAllBits(BitMap);
                CmHive->Hive.DirtyCount = BitMap->SizeOfBitMap;
                //
                // we only need to flush the hive when the loader has recovered it
                //
                HvSyncHive((PHHIVE)CmHive);

            }

            CmpMachineHiveList[i].CmHive2 = CmHive;

            ASSERT( CmpMachineHiveList[i].CmHive == CmpMachineHiveList[i].CmHive2 );
/*
Cannot do that here as it requires the registry lock
            CmpAddToHiveFileList(CmpMachineHiveList[i].CmHive);
*/

            if( CmpCannotWriteConfiguration ) {
                //
                // The system disk is full; Give user a chance to log-on and make room
                //
                CmpDiskFullWarning();
            }

            //
            // copy the full file name for the conversion worker thread
            //
            SystemHiveFullPathName.MaximumLength = MAX_NAME;
            SystemHiveFullPathName.Length = 0;
            SystemHiveFullPathName.Buffer = (PWSTR)&(SystemHiveFullPathBuffer[0]);
            RtlAppendStringToString((PSTRING)&SystemHiveFullPathName, (PSTRING)&FileName);
        } else if (CmpMiniNTBoot) {
            //
            // copy the full file name for the conversion worker thread
            //
            SystemHiveFullPathName.MaximumLength = MAX_NAME;
            SystemHiveFullPathName.Length = 0;
            SystemHiveFullPathName.Buffer = (PWSTR)&(SystemHiveFullPathBuffer[0]);
            RtlAppendStringToString((PSTRING)&SystemHiveFullPathName, (PSTRING)&FileName);
        }
        if(i == SYSTEM_HIVE_INDEX) {
            //
            // marks the System\Select!Current value dirty so we preserve what was set by the loader.
            //
            CmpMarkCurrentValueDirty((PHHIVE)CmHive,CmHive->Hive.BaseBlock->RootCell);
        }
    }

    CmpMachineHiveList[i].ThreadFinished = TRUE;

    LocalWorkerIncrement = InterlockedIncrement (&CmpLoadWorkerIncrement);
    if ( LocalWorkerIncrement == CM_NUMBER_OF_MACHINE_HIVES ) {
        //
        // this was the last thread (the lazyest); signal the main thread
        //
        KeSetEvent (&CmpLoadWorkerEvent, 0, FALSE);
    }

    if ( (LocalWorkerIncrement == (CM_NUMBER_OF_MACHINE_HIVES -1)) && // there is one more thread
         (CmpCheckHiveIndex < CM_NUMBER_OF_MACHINE_HIVES ) // which is waiting to be debugged
        ) {
        //
        // wake up the thread to be debugged
        //
        KeSetEvent (&CmpLoadWorkerDebugEvent, 0, FALSE);
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpLoadHiveThread %i ... terminating\n",i));
    PsTerminateSystemThread(Status);
}


NTSTATUS
CmpSetNetworkValue(
    IN PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    )
/*++

Routine Description:

    This function will save the information in the Network Loader
    Block to the registry.

Arguments:
    NetworkLoaderBlock - Supplies a pointer to the network loader block
                         that was created by the OS Loader.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING string;
    HANDLE handle;
    ULONG disposition;


    ASSERT( NetworkLoaderBlock != NULL );
    ASSERT( NetworkLoaderBlock->DHCPServerACKLength > 0 );


    RtlInitUnicodeString( &string, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\PXE" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtCreateKey(&handle,
                         KEY_ALL_ACCESS,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING)NULL,
                         0,
                         &disposition
                         );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL, "CmpSetNetworkValue: Unable to open PXE key: %x\n", status ));
        goto Error;
    }

    RtlInitUnicodeString( &string, L"DHCPServerACK" );

    status = NtSetValueKey(handle,
                           &string,
                           0,
                           REG_BINARY,
                           NetworkLoaderBlock->DHCPServerACK,
                           NetworkLoaderBlock->DHCPServerACKLength
                           );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL, "CmpSetNetworkValue: Unable to set DHCPServerACK key: %x\n", status ));
        goto Error;
    }

    RtlInitUnicodeString( &string, L"BootServerReply" );

    status = NtSetValueKey(handle,
                           &string,
                           0,
                           REG_BINARY,
                           NetworkLoaderBlock->BootServerReplyPacket,
                           NetworkLoaderBlock->BootServerReplyPacketLength
                           );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL, "CmpSetNetworkValue: Unable to set BootServerReplyPacket key: %x\n", status ));
        goto Error;
    }

    status = STATUS_SUCCESS;

Cleanup:
    NtClose( handle );

    return status;

Error:
    goto Cleanup;
}



NTSTATUS
CmpSetSystemValues(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function will save the system start information to
    the registry.

Arguments:
    LoaderBlock -  Supplies a pointer to the loader block.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING string;
    UNICODE_STRING value;
    HANDLE handle;


    ASSERT( LoaderBlock != NULL );


    value.Buffer = NULL;

    //
    // Open the control key
    //

    RtlInitUnicodeString( &string, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(
                       &handle,
                       KEY_ALL_ACCESS,
                       &objectAttributes
                      );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpSetSystemValues: Unable to Open Control Key: %x\n", status ));
        goto Error;
    }

    //
    // Set the System start options key
    //

    RtlInitUnicodeString( &string, L"SystemStartOptions" );

    status = NtSetValueKey  (
                            handle,
                            &string,
                            0,
                            REG_SZ,
                            CmpLoadOptions.Buffer,
                            CmpLoadOptions.Length
                            );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpSetSystemValue: Unable to set SystemStartOptions key: %x\n", status ));
        goto Error;
    }

    //
    // Set the System Boot Device
    //

    RtlInitUnicodeString( &string, L"SystemBootDevice" );
    RtlCreateUnicodeStringFromAsciiz( &value, LoaderBlock->ArcBootDeviceName );

    status = NtSetValueKey(handle,
                           &string,
                           0,
                           REG_SZ,
                           value.Buffer,
                           value.Length + sizeof(WCHAR)
                           );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpSetSystemValue: Unable to set SystemBootDevice key: %x\n", status ));
        goto Error;
    }

    status = STATUS_SUCCESS;

Cleanup:
    if ( value.Buffer ) {
        RtlFreeUnicodeString(&value);
    }

    NtClose( handle );

    return status;

Error:
    goto Cleanup;
}

VOID
CmpMarkCurrentValueDirty(
                         IN PHHIVE SystemHive,
                         IN HCELL_INDEX RootCell
                         )
{
    PCM_KEY_NODE    Node;
    HCELL_INDEX     Select;
    UNICODE_STRING  Name;
    HCELL_INDEX     ValueCell;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    //
    // Find \SYSTEM\SELECT node.
    //
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,RootCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return;
    }
    HvReleaseCell(SystemHive,RootCell);
    RtlInitUnicodeString(&Name, L"select");
    Select = CmpFindSubKeyByName(SystemHive,
                                Node,
                                &Name);
    if (Select == HCELL_NIL) {
        return;
    }
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,Select);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return;
    }
    HvReleaseCell(SystemHive,Select);

    RtlInitUnicodeString(&Name, L"Current");
    ValueCell = CmpFindValueByName(SystemHive,
                                   Node,
                                   &Name);
    if (ValueCell != HCELL_NIL) {
        HvMarkCellDirty(SystemHive, ValueCell);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmsecache.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cmsecache.c

Abstract:

    This module implements the security cache.

Author:

    Dragos C. Sambotin (dragoss) 09-Sep-1999


--*/

#include "cmp.h"

#define SECURITY_CACHE_GROW_INCREMENTS  0x10

#ifdef HIVE_SECURITY_STATS
ULONG
CmpCheckForSecurityDuplicates(
    IN OUT PCMHIVE      CmHive
                              );
#endif

BOOLEAN
CmpFindMatchingDescriptorCell(
    IN PCMHIVE CmHive,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Type,
    OUT PHCELL_INDEX MatchingCell,
    OUT OPTIONAL PCM_KEY_SECURITY_CACHE *CachedSecurityPointer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpSecConvKey)
#pragma alloc_text(PAGE,CmpInitSecurityCache)
#pragma alloc_text(PAGE,CmpDestroySecurityCache)
#pragma alloc_text(PAGE,CmpRebuildSecurityCache)
#pragma alloc_text(PAGE,CmpAddSecurityCellToCache)
#pragma alloc_text(PAGE,CmpFindSecurityCellCacheIndex)
#pragma alloc_text(PAGE,CmpAdjustSecurityCacheSize)
#pragma alloc_text(PAGE,CmpRemoveFromSecurityCache)
#pragma alloc_text(PAGE,CmpFindMatchingDescriptorCell)
#pragma alloc_text(PAGE,CmpAssignSecurityToKcb)

#ifdef HIVE_SECURITY_STATS
#pragma alloc_text(PAGE,CmpCheckForSecurityDuplicates)
#endif

#pragma alloc_text(PAGE,CmpBuildSecurityCellMappingArray)
#endif

ULONG
CmpSecConvKey(
              IN ULONG  DescriptorLength,
              IN PULONG Descriptor
              )
/*++

Routine Description:

    Computes the ConvKey for the given security descriptor.
    The algorithm is stollen from the NTFS security hash. 
    (it was proven to be efficient there; why shouldn't do the same ?)


    For speed in the hash, we consider the security descriptor as an array
    of ULONGs.  The fragment at the end that is ignored should not affect
    the collision nature of this hash.

Arguments:

    DescriptorLength - length (in bytes) of the sd

    Descriptor - actual sd to cache

Return Value:

    ConvKey

Note:
    
      We may want to convert this to a macro
--*/

{
    ULONG   Count;     
    ULONG   Hash = 0;

    PAGED_CODE();

    Count = DescriptorLength / 4;

    while (Count--) {
        Hash = ((Hash << 3) | (Hash >> (32-3))) + *Descriptor++;
    }

    return Hash;
}

VOID
CmpInitSecurityCache(
    IN OUT PCMHIVE      CmHive
    )
{
    ULONG i;

    PAGED_CODE();

    CmHive->SecurityCache = NULL;        
    CmHive->SecurityCacheSize = 0;       
    CmHive->SecurityCount = 0;
    CmHive->SecurityHitHint = -1; // no hint

    for( i=0;i<CmpSecHashTableSize;i++) {
        InitializeListHead(&(CmHive->SecurityHash[i]));
    }
}

NTSTATUS
CmpAddSecurityCellToCache (
    IN OUT PCMHIVE      CmHive,
    IN HCELL_INDEX      SecurityCell,
    IN BOOLEAN          BuildUp
    )

/*++

Routine Description:

    This routine adds the specified security cell to the cache of the
    specified hive. It takes care of cache allocation (grow) as well.
    At build up time, cache size grows with a PAGE_SIZE, to avoid memory 
    fragmentation. After the table is builded, it's size is adjusted (most 
    of the hives never add new security cells). Then, at run-time, the size 
    grows with 16 entries at a time (same reason)
    The cache is ordered by the cell's index, so we can do a binary search on 
    cells retrieval.

Arguments:

    CmHive - the hive to which the security cell belongs

    SecurityCell - the security cell to be added to the cache

    BuildUp - specifies that this is build up time 

Return Value:

    NTSTATUS - STATUS_SUCCESS if the operation is successful and an
        appropriate error status otherwise (i.e STATUS_INSUFFICIENT_RESOURCES).

Note: 

    If the security cell is already IN the cache; this function will return TRUE.
--*/
{
    ULONG                   Index;
    ULONG                   Size;
    PCM_KEY_SECURITY        Security;
    PCM_KEY_SECURITY_CACHE  SecurityCached;

    PAGED_CODE();

    if( CmpFindSecurityCellCacheIndex (CmHive,SecurityCell,&Index) == TRUE ) {
        // 
        // cell already exist in the cache; return;
        //
        return STATUS_SUCCESS;
    }

    //
    // if this fails, we're doomed !
    //
    ASSERT( (PAGE_SIZE % sizeof(CM_KEY_SECURITY_CACHE_ENTRY)) == 0 );

    //
    // check if the cache can accomodate a new cell
    //
    if( CmHive->SecurityCount == CmHive->SecurityCacheSize ) {
        //
        // We're at the limit with the cache; we need to extend it by a page
        //
        // OBS: this takes care of the first allocation too, as SecurityCount 
        // and SecurityCacheSize are both initialized with 0
        //
        PCM_KEY_SECURITY_CACHE_ENTRY  Temp;

        // store the actual buffer
        Temp = CmHive->SecurityCache;
        
        //
        // compute the new size and allocate a new buffer 
        //
        if( BuildUp == TRUE ) {
            //
            // We are building up the cache; grow the table in page increments
            //
            ASSERT( ((CmHive->SecurityCacheSize * sizeof(CM_KEY_SECURITY_CACHE_ENTRY)) % PAGE_SIZE) == 0 );
            CmHive->SecurityCacheSize += (PAGE_SIZE / sizeof(CM_KEY_SECURITY_CACHE_ENTRY));
        } else {
            //
            // normal case (running time); a new security cell is added; grow the
            // table with a fixed number of increments (to avoid fragmentation, in
            // case of an Office install :-) )
            //
            CmHive->SecurityCacheSize += SECURITY_CACHE_GROW_INCREMENTS;

        }
        CmHive->SecurityCache = ExAllocatePoolWithTag(PagedPool, CmHive->SecurityCacheSize * sizeof(CM_KEY_SECURITY_CACHE_ENTRY),CM_SECCACHE_TAG|PROTECTED_POOL);
        if( CmHive->SecurityCache == NULL ) {
            //
            // bad luck; bail out
            //
            CmHive->SecurityCache = Temp;
            CmHive->SecurityCacheSize = CmHive->SecurityCount;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // copy existing data in the new location and free the old buffer
        //
        RtlCopyMemory(CmHive->SecurityCache,Temp,CmHive->SecurityCount*sizeof(CM_KEY_SECURITY_CACHE_ENTRY));
        if( Temp != NULL ) {
            ExFreePoolWithTag(Temp, CM_SECCACHE_TAG|PROTECTED_POOL );
        } else {
            ASSERT( CmHive->SecurityCount == 0 );
        }
    }

    //
    // try first to get the security cell from the hive; if this fails, there is no point to go on 
    //
    Security = (PCM_KEY_SECURITY)HvGetCell(&(CmHive->Hive),SecurityCell);
    if( Security == NULL ){
        //
        // we failed to map the view containing this cell; bail out
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // compute the size for the cached security structure
    //
    Size = FIELD_OFFSET(CM_KEY_SECURITY_CACHE,Descriptor) + Security->DescriptorLength;

    //
    // think forward: allocate and initialize a copy for the security cell, in order to store it in the cache
    //
    SecurityCached = (PCM_KEY_SECURITY_CACHE)ExAllocatePoolWithTag(PagedPool,Size,CM_SECCACHE_TAG|PROTECTED_POOL);
    if(SecurityCached == NULL) {
        //
        // bad luck; bail out
        //
        HvReleaseCell(&(CmHive->Hive),SecurityCell);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // from now on, nothing can go wrong !
    //
    RtlCopyMemory(&(SecurityCached->Descriptor),&(Security->Descriptor),Security->DescriptorLength);
    SecurityCached->Cell = SecurityCell;
    SecurityCached->DescriptorLength = Security->DescriptorLength;

    //
    // now add this to the hash table
    //
    SecurityCached->ConvKey = CmpSecConvKey(Security->DescriptorLength,(PULONG)(&(Security->Descriptor)));
    // add it to the end of the list with this conv key
    InsertTailList( &(CmHive->SecurityHash[SecurityCached->ConvKey % CmpSecHashTableSize]),
                    &(SecurityCached->List)
                   );
    
    HvReleaseCell(&(CmHive->Hive),SecurityCell);

    //
    // At this point we are sure we have space for at least one more entry
    // Move data to make room for the new entry
    //
    if( Index < CmHive->SecurityCount ) {
        //
        // RtlMoveMemory will take care of the overlapping problem
        //
        RtlMoveMemory( ((PUCHAR)CmHive->SecurityCache) + (Index+1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),     // destination
                       ((PUCHAR)CmHive->SecurityCache) + Index*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),         // source
                       (CmHive->SecurityCount - Index)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY)                  // size
                        );
    }

    //
    // setup the new entry
    //
    CmHive->SecurityCache[Index].Cell = SecurityCell;
    CmHive->SecurityCache[Index].CachedSecurity = SecurityCached;

    // update the count
    CmHive->SecurityCount++;

    return STATUS_SUCCESS;
}

BOOLEAN
CmpFindSecurityCellCacheIndex (
    IN PCMHIVE      CmHive,
    IN HCELL_INDEX  SecurityCell,
    OUT PULONG      Index
    )

/*++

Routine Description:

    Search (binary) for the specified cellindex in the security cache.
    Returns the index of the cache entry where the cell is cached or 
    it should be added

Arguments:

    CmHive - the hive to which the security cell belongs

    SecurityCell - the security cell to search for

    Index - out param to pass the index at which the cell is (or it should be)

Return Value:

    TRUE - the cell was found (at *Index)
    FALSE - the cell is not in the cache (it should be added at *Index)

--*/
{
    ULONG           High;
    ULONG           Low;
    ULONG           Current;
    USHORT          State = 0;  // state of the operation:  0 - normal binary search
                                //                          1 - last low
                                //                          2 - last high
    LONG            Result;
    LONG            Tmp1,Tmp2;
    
    PAGED_CODE();

    if( CmHive->SecurityCount == 0 ) {
        //
        // there is no cell in the security cache
        //
        *Index = 0;
        return FALSE;
    }

    // sanity asserts
    ASSERT( CmHive->SecurityCount <= CmHive->SecurityCacheSize );
    ASSERT( CmHive->SecurityCache != NULL );


    High = CmHive->SecurityCount - 1;
    Low = 0;
    if( (CmHive->SecurityHitHint >= 0) && ( (ULONG)CmHive->SecurityHitHint <= High) ) {
        //
        // try the last search
        //
        Current = CmHive->SecurityHitHint;
    } else {
        Current = High/2;
    }

    // sign adjustment
    Tmp1 = SecurityCell & ~HCELL_TYPE_MASK;
    if( SecurityCell & HCELL_TYPE_MASK ) {
        Tmp1 = -Tmp1;
    }

    while( TRUE ) {

        Tmp2 = CmHive->SecurityCache[Current].Cell & ~HCELL_TYPE_MASK;
        // sign adjustment
        if( CmHive->SecurityCache[Current].Cell & HCELL_TYPE_MASK ) {
            Tmp2 = -Tmp2;
        }

        Result = Tmp1 -  Tmp2;    
        
        if (Result == 0) {
            //
            // Success, return data to caller and exit
            //

            *Index = Current;
            //
            // we have a hit! update the count and exit
            //
            CmHive->SecurityHitHint = Current;
            return TRUE;
        }
        //
        // compute the next index to try
        //
        switch(State) {
        case 0:
            //
            // normal binary search state
            //
            if( Result < 0 ) {
                High = Current;
            } else {
                Low = Current;
            }
            if ((High - Low) <= 1) {
                //
                // advance to the new state
                //
                Current = Low;
                State = 1;
            } else {
                Current = Low + ( (High-Low) / 2 );
            }
            break;
        case 1:
            //
            // last low state
            //

            // this should be true
            ASSERT( Current == Low );
            if (Result < 0) {
                //
                // does not exist, under
                //
            
                *Index = Current;
                return FALSE;
            } else if( Low == High ) {
                        //
                        // low and high are identical; but current is bigger than them; insert after
                        //

                        *Index = Current + 1;
                        return FALSE;
                    } else {
                        //
                        // advance to the new state; i.e. look at high
                        //
                        State = 2;
                        Current = High;
                    }

            break;
        case 2:
            //
            // last high state; if we got here, High = Low +1 and Current == High
            //
            ASSERT( Current == High);
            ASSERT( High == (Low + 1) );
            if( Result < 0 ) {
                //
                // under High, but above Low; we should insert it here
                //

                *Index = Current;
                return FALSE;
            } else {
                //
                // above High; 
                //

                *Index = Current + 1;
                return FALSE;
            }
            break;
        default:
            ASSERT( FALSE );
            break;
        }
    }

    //
    // we shouldn't get here !!!
    //
    ASSERT( FALSE );
    return FALSE;
}

BOOLEAN
CmpAdjustSecurityCacheSize (
    IN PCMHIVE      CmHive
    )

/*++

Routine Description:

    Adjust the scusrity cache size for the specified hive. This function
    should be called after all the security cells for the hive were cached, 
    in order to give back extra memory used in the process.


Arguments:

    CmHive - the hive to which the security cell belongs

Return Value:

    TRUE - success
    FALSE - failure - the size remains the same

--*/
{
    PCM_KEY_SECURITY_CACHE_ENTRY  Buffer;
    
    PAGED_CODE();

    if( CmHive->SecurityCount < CmHive->SecurityCacheSize ) {
        //
        // cache size is bigger than what we need; there is a good chance 
        // nobody will ever add new security cells to this hive, so go on
        // and free the extra space
        //

        //
        // allocate a new buffer with the exact size we need
        //
        Buffer = ExAllocatePoolWithTag(PagedPool, CmHive->SecurityCount * sizeof(CM_KEY_SECURITY_CACHE_ENTRY),CM_SECCACHE_TAG|PROTECTED_POOL);
        
        if( Buffer == NULL ) {
            //
            // the system is low on resources; leave the cache as it is
            //
            return FALSE;
        }

        //
        // copy significant data inot the new buffer
        //
        RtlCopyMemory(Buffer,CmHive->SecurityCache,CmHive->SecurityCount*sizeof(CM_KEY_SECURITY_CACHE_ENTRY));

        //
        // free the old buffer and update cache members
        //
        ExFreePoolWithTag(CmHive->SecurityCache, CM_SECCACHE_TAG|PROTECTED_POOL );
        
        CmHive->SecurityCache = Buffer;
        CmHive->SecurityCacheSize = CmHive->SecurityCount;
    }

    return TRUE;
}

VOID
CmpRemoveFromSecurityCache (
    IN OUT PCMHIVE      CmHive,
    IN HCELL_INDEX      SecurityCell
    )

/*++

Routine Description:

    Removes the specified security cell from the security cache.
    (only if present !)
    For performance (and memory fragmentation) reasons, it does not 
    change (shrink) the cache size.

Arguments:

    CmHive - the hive to which the security cell belongs

    SecurityCell - the security cell to be removed from the cache

Return Value:

    <none>
--*/
{
    ULONG               Index;

    PAGED_CODE();

    if( CmpFindSecurityCellCacheIndex (CmHive,SecurityCell,&Index) == FALSE ) {
        // 
        // cell is not in the cache
        //
        return;
    }

    ASSERT( CmHive->SecurityCache[Index].Cell == SecurityCell );
    ASSERT( CmHive->SecurityCache[Index].CachedSecurity->Cell == SecurityCell );
    
    //
    // remove the cached structure from the hash
    //
    CmpRemoveEntryList(&(CmHive->SecurityCache[Index].CachedSecurity->List));
    
    //
    // free up the cached security cell;
    //
    ExFreePoolWithTag(CmHive->SecurityCache[Index].CachedSecurity, CM_SECCACHE_TAG|PROTECTED_POOL );

    //
    // move memory to reflect the new size, and update the cache count
    //
    RtlMoveMemory( ((PUCHAR)CmHive->SecurityCache) + Index*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),         // destination
                   ((PUCHAR)CmHive->SecurityCache) + (Index+1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),     // source
                   (CmHive->SecurityCount - Index - 1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY)              // size   
                 );
    
    CmHive->SecurityCount--;
}

VOID
CmpDestroySecurityCache (
    IN OUT PCMHIVE      CmHive
    )
/*++

Routine Description:

    Frees up all the cached security cells and the cache itself

Arguments:

    CmHive - the hive to which the security cell belongs

Return Value:

    <none>
--*/
{
    ULONG   i;

    PAGED_CODE();

    for( i=0;i<CmHive->SecurityCount;i++) {
        CmpRemoveEntryList(&(CmHive->SecurityCache[i].CachedSecurity->List));
        ExFreePoolWithTag(CmHive->SecurityCache[i].CachedSecurity, CM_SECCACHE_TAG|PROTECTED_POOL );
    }

    if( CmHive->SecurityCount != 0 ) {
        ASSERT( CmHive->SecurityCache != NULL );
        ExFreePoolWithTag(CmHive->SecurityCache, CM_SECCACHE_TAG|PROTECTED_POOL );
    }

    CmHive->SecurityCache = NULL;
    CmHive->SecurityCacheSize = CmHive->SecurityCount = 0;
}

BOOLEAN
CmpRebuildSecurityCache(
                        IN OUT PCMHIVE      CmHive
                        )
/*++

Routine Description:

    Rebuilds the security cache by reiterating all security cells
    and adding them to the cache; this routine is intended for hive
    refresh operations

Arguments:

    CmHive - the hive to which the security cell belongs

Return Value:

    TRUE or FALSE
--*/
{
    PCM_KEY_NODE            RootNode;
    PCM_KEY_SECURITY        SecurityCell;
    HCELL_INDEX             ListAnchor;
    HCELL_INDEX             NextCell;
    HCELL_INDEX             LastCell;
    PHHIVE                  Hive;
    PRELEASE_CELL_ROUTINE   ReleaseCellRoutine;
    BOOLEAN                 Result = TRUE;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    //
    // avoid extra work
    //
    Hive = &(CmHive->Hive);
    ReleaseCellRoutine = Hive->ReleaseCellRoutine;
    Hive->ReleaseCellRoutine = NULL;

    //
    // destroy existing cache and set up an empty one
    //
    CmpDestroySecurityCache(CmHive);
    CmpInitSecurityCache(CmHive);

    if (!HvIsCellAllocated(Hive,Hive->BaseBlock->RootCell)) {
        //
        // root cell HCELL_INDEX is bogus
        //
        Result = FALSE;
        goto JustReturn;
    }
    RootNode = (PCM_KEY_NODE) HvGetCell(Hive, Hive->BaseBlock->RootCell);
    if( RootNode == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        Result = FALSE;
        goto JustReturn;
    }
    ListAnchor = NextCell = RootNode->Security;

    do {
        if (!HvIsCellAllocated(Hive, NextCell)) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CM: CmpRebuildSecurityCache\n"));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"    NextCell: %08lx is invalid HCELL_INDEX\n",NextCell));
            Result = FALSE;
            goto JustReturn;
        }
        SecurityCell = (PCM_KEY_SECURITY) HvGetCell(Hive, NextCell);
        if( SecurityCell == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            Result = FALSE;
            goto JustReturn;
        }
        if (NextCell != ListAnchor) {
            //
            // Check to make sure that our Blink points to where we just
            // came from.
            //
            if (SecurityCell->Blink != LastCell) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"  Invalid Blink (%ld) on security cell %ld\n",SecurityCell->Blink, NextCell));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"  should point to %ld\n", LastCell));
                Result = FALSE;
                goto JustReturn;
            }
        }
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpValidSD:  SD shared by %d nodes\n",SecurityCell->ReferenceCount));
        if (!SeValidSecurityDescriptor(SecurityCell->DescriptorLength, &SecurityCell->Descriptor)) {
#if DBG
            CmpDumpSecurityDescriptor(&SecurityCell->Descriptor,"INVALID DESCRIPTOR");
#endif
            Result = FALSE;
            goto JustReturn;
        }

        if( !NT_SUCCESS(CmpAddSecurityCellToCache ( CmHive,NextCell,TRUE) ) ) {
            Result = FALSE;
            goto JustReturn;
        }

        LastCell = NextCell;
        NextCell = SecurityCell->Flink;
    } while ( NextCell != ListAnchor );

    //
    // adjust the size of the cache in case we allocated too much
    //
    CmpAdjustSecurityCacheSize ( (PCMHIVE)Hive );

JustReturn:
    Hive->ReleaseCellRoutine = ReleaseCellRoutine;
    return Result;
}

BOOLEAN
CmpFindMatchingDescriptorCell(
    IN PCMHIVE CmHive,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Type,
    OUT PHCELL_INDEX MatchingCell,
    OUT OPTIONAL PCM_KEY_SECURITY_CACHE *CachedSecurityPointer
    )

/*++

Routine Description:

    This routine attempts to find a security descriptor in the hive that
    is identical to the one passed in.  If it finds one, it returns its
    cell index.

    Obsolete:
    Currently, this routine checks the security descriptors of the parent
    and siblings of the node to find a match.

    New:
    It looks for the sd in the security cache for this hive. This will 
    eliminate duplicates and make the search process faster.

Arguments:

    CmHive - Supplies a pointer to the hive control structure for the node.
            Needed to get access to the cache

    SecurityDescriptor - Supplies the cooked security descriptor which
           should be searched for.

    Type - Indicates whether the Security Descriptor that matches must
            be in Stable or Volatile store

    MatchingCell - Returns the cell index of a security cell whose
           security descriptor is identical to SecurityDescriptor.
           Valid only if TRUE is returned.

    CachedSecurityPointer - pointer to the cached security (for update reasons)

Return Value:

    TRUE - Matching security descriptor found.  MatchingCell returns the
           cell index of the matching security descriptor.

    FALSE - No matching security descriptor found.  MatchingCell is invalid.

--*/

{
    ULONG                   DescriptorLength;
    ULONG                   ConvKey;
    PLIST_ENTRY             ListAnchor;
    PLIST_ENTRY             Current;
    PCM_KEY_SECURITY_CACHE  CachedSecurity;

    PAGED_CODE();
	
    DescriptorLength = RtlLengthSecurityDescriptor(SecurityDescriptor);

    //
    // calculate the conv key
    //
    ConvKey = CmpSecConvKey(DescriptorLength,(PULONG)SecurityDescriptor);

    ListAnchor = &(CmHive->SecurityHash[ConvKey % CmpSecHashTableSize]);
    if( IsListEmpty(ListAnchor) == TRUE ) {
        return FALSE;
    }

    //
    // iterate through the list of colisions for this convkey
    // start with teh first element in list
    //
    Current = (PLIST_ENTRY)(ListAnchor->Flink);
    while( Current != ListAnchor ){
        //
        // get the current cached security 
        //
        CachedSecurity = CONTAINING_RECORD(Current,
                                           CM_KEY_SECURITY_CACHE,
                                           List);

        //
        // see if it matches with the given descriptor; 
        //
        if( (CachedSecurity->ConvKey == ConvKey) &&                             // same convkey
            (Type == HvGetCellType(CachedSecurity->Cell)) &&                    // same cell type
            (DescriptorLength == CachedSecurity->DescriptorLength) &&  // same length
            (RtlEqualMemory(SecurityDescriptor,                                 // and, finally, bit-wise identical
                            &(CachedSecurity->Descriptor),
                            DescriptorLength))
            ) {
            //
            // we have found a match
            //
            *MatchingCell = CachedSecurity->Cell;
            if (ARGUMENT_PRESENT(CachedSecurityPointer)) {
                *CachedSecurityPointer = CachedSecurity;
            }
            return TRUE;
        }

        //
        // advance to the next element
        //
        Current = (PLIST_ENTRY)(Current->Flink);
    } 

    // sorry, no match
    return FALSE;
}

VOID
CmpAssignSecurityToKcb(
    IN PCM_KEY_CONTROL_BLOCK    Kcb,
    IN HCELL_INDEX              SecurityCell
    )
/*++

Routine Description:

    Establishes the connection between the KCB and the cached security
    descriptor.

    As most of the time this is called after the security cell has been 
    linked to the Key Node, and because the binary search starts with 
    the last cell looked up, we will not hit a performance impact here.

Arguments:

    Kcb - the KCb to which this security cell needs to be attached

    SecurityCell - Security cell for the kcb


Return Value:

    NONE; bugchecks on error

--*/
{
    ULONG   Index;
    PCMHIVE CmHive;

    PAGED_CODE();

    if( SecurityCell == HCELL_NIL ) {
        Kcb->CachedSecurity = NULL;
        return;
    }

    CmHive = (PCMHIVE)(Kcb->KeyHive);

    //
    // get the security descriptor from cache
    //
    if( CmpFindSecurityCellCacheIndex (CmHive,SecurityCell,&Index) == FALSE ) {
        Kcb->CachedSecurity = NULL;
        //
        //  we are doomed !!!
        //
        CM_BUGCHECK( REGISTRY_ERROR,BAD_SECURITY_CACHE,1,Kcb,SecurityCell);

    } 

    //
    // success; link the cached security to this KCB
    //
    Kcb->CachedSecurity = CmHive->SecurityCache[Index].CachedSecurity;

}

#ifdef HIVE_SECURITY_STATS
ULONG
CmpCheckForSecurityDuplicates(
    IN OUT PCMHIVE      CmHive
                              )
/*++

Routine Description:

    Iterates through the security cache for the specified hive and detects
    if there are any security descriptors which are duplicated

Arguments:

    CmHive - the hive in question

Return Value:

    number of duplicates (it should be 0)
--*/
{
    ULONG                   i,j,Duplicates = 0;
    PCM_KEY_SECURITY_CACHE  CachedSecurity1,CachedSecurity2;
    HCELL_INDEX             Cell1,Cell2;

    PAGED_CODE();

    for( i=0;i<CmHive->SecurityCount - 1;i++) {
        CachedSecurity1 = CmHive->SecurityCache[i].CachedSecurity;
        Cell1 = CmHive->SecurityCache[i].Cell;
        ASSERT( Cell1 == CachedSecurity1->Cell );
        for( j=i+1;j<CmHive->SecurityCount;j++) {
            CachedSecurity2 = CmHive->SecurityCache[j].CachedSecurity;
            Cell2 = CmHive->SecurityCache[j].Cell;
            ASSERT( Cell2 == CachedSecurity2->Cell );
            if ((CachedSecurity1->DescriptorLength == CachedSecurity2->DescriptorLength) &&
                (HvGetCellType(Cell1) == HvGetCellType(Cell2))          &&
                (RtlEqualMemory(&(CachedSecurity1->Descriptor),
                                &(CachedSecurity2->Descriptor),
                                CachedSecurity1->DescriptorLength))) {
                ASSERT( CachedSecurity1->ConvKey == CachedSecurity2->ConvKey );
                //
                // we've found a duplicate cell;
                //
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Duplicate security cell found in Hive %p Cell1=%8lx Cell2 = %8lx\n",(&(CmHive->Hive)),Cell1,Cell2);
#endif //_CM_LDR_
                Duplicates++;
                break;
            }
            
        }
    }

    return Duplicates;
}
#endif

BOOLEAN
CmpBuildSecurityCellMappingArray(
    IN PCMHIVE CmHive
    )
/*++

Routine Description:

    Iterates through the security cache for the specified hive and 
	build the array of mappings.

Arguments:

    CmHive - the hive in question

Return Value:

    TRUE/FALSE
--*/
{
    ULONG                   i;
    PAGED_CODE();

	ASSERT( CmHive->CellRemapArray == NULL );
	CmHive->CellRemapArray = ExAllocatePool(PagedPool,sizeof(CM_CELL_REMAP_BLOCK)*CmHive->SecurityCount);

	if( CmHive->CellRemapArray == NULL ) {
		return FALSE;
	}

    for( i=0;i<CmHive->SecurityCount;i++) {
		CmHive->CellRemapArray[i].OldCell = CmHive->SecurityCache[i].Cell;
		if( HvGetCellType(CmHive->SecurityCache[i].Cell) == (ULONG)Volatile ) {
			//
			// we preserve volatile cells
			//
			CmHive->CellRemapArray[i].NewCell = CmHive->SecurityCache[i].Cell;
		} else {
			CmHive->CellRemapArray[i].NewCell = HCELL_NIL;
		}
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmsubs2.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmsubs2.c

Abstract:

    This module various support routines for the configuration manager.

    The routines in this module are independent enough to be linked into
    any other program.  The routines in cmsubs.c are not.

Author:

    Bryan M. Willman (bryanwi) 12-Sep-1991

Revision History:

--*/

#include    "cmp.h"

BOOLEAN
CmpGetValueDataFromCache(
    IN PHHIVE               Hive,
    IN PPCM_CACHED_VALUE    ContainingList,
    IN PCELL_DATA           ValueKey,
    IN BOOLEAN              ValueCached,
    OUT PUCHAR              *DataPointer,
    OUT PBOOLEAN            Allocated,
    OUT PHCELL_INDEX        CellToRelease
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpGetValueDataFromCache)
#pragma alloc_text(PAGE,CmpQueryKeyData)
#pragma alloc_text(PAGE,CmpQueryKeyDataFromCache)
#pragma alloc_text(PAGE,CmpQueryKeyValueData)
#endif

//
// Define alignment macro.
//

#define ALIGN_OFFSET(Offset) (ULONG) \
        ((((ULONG)(Offset) + sizeof(ULONG)-1)) & (~(sizeof(ULONG) - 1)))

#define ALIGN_OFFSET64(Offset) (ULONG) \
        ((((ULONG)(Offset) + sizeof(ULONGLONG)-1)) & (~(sizeof(ULONGLONG) - 1)))

//
// Data transfer workers
//


#ifdef CMP_STATS

extern struct {
    ULONG   BasicInformation;
    UINT64  BasicInformationTimeCounter;
    UINT64  BasicInformationTimeElapsed;

    ULONG   NodeInformation;
    UINT64  NodeInformationTimeCounter;
    UINT64  NodeInformationTimeElapsed;

    ULONG   FullInformation;
    UINT64  FullInformationTimeCounter;
    UINT64  FullInformationTimeElapsed;

    ULONG   EnumerateKeyBasicInformation;
    UINT64  EnumerateKeyBasicInformationTimeCounter;
    UINT64  EnumerateKeyBasicInformationTimeElapsed;

    ULONG   EnumerateKeyNodeInformation;
    UINT64  EnumerateKeyNodeInformationTimeCounter;
    UINT64  EnumerateKeyNodeInformationTimeElapsed;

    ULONG   EnumerateKeyFullInformation;
    UINT64  EnumerateKeyFullInformationTimeCounter;
    UINT64  EnumerateKeyFullInformationTimeElapsed;
} CmpQueryKeyDataDebug;


UINT64  CmpGetTimeStamp()
{
                
    LARGE_INTEGER   CurrentTime;
    LARGE_INTEGER   PerfFrequency;
    UINT64          Freq;
    UINT64          Time;

    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

    //
    // Convert the perffrequency into 100ns interval.
    //
    Freq = 0;
    Freq |= PerfFrequency.HighPart;
    Freq = Freq << 32;
    Freq |= PerfFrequency.LowPart;


    //
    // Convert from LARGE_INTEGER to UINT64
    //
    Time = 0;
    Time |= CurrentTime.HighPart;
    Time = Time << 32;
    Time |= CurrentTime.LowPart;

    // Normalize cycles with the frequency.
    Time *= 10000000;
    Time /= Freq;

    return Time;
}   
#endif

NTSTATUS
CmpQueryKeyData(
    PHHIVE                  Hive,
    PCM_KEY_NODE            Node,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   KeyInformation,
    ULONG                   Length,
    PULONG                  ResultLength
#if defined(CMP_STATS) || defined(CMP_KCB_CACHE_VALIDATION)
    ,
    PCM_KEY_CONTROL_BLOCK   Kcb
#endif
    )
/*++

Routine Description:

    Do the actual copy of data for a key into caller's buffer.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Node - Supplies pointer to node whose subkeys are to be found

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS            status;
    PCELL_DATA          pclass;
    ULONG               requiredlength;
    LONG                leftlength;
    ULONG               offset;
    ULONG               minimumlength;
    PKEY_INFORMATION    pbuffer;
    USHORT              NameLength;
#ifdef CMP_STATS
    //LARGE_INTEGER       StartSystemTime;
    //LARGE_INTEGER       EndSystemTime;
    UINT64              StartSystemTime;
    UINT64              EndSystemTime;
    PUINT64             TimeCounter = NULL;
    PUINT64             TimeElapsed = NULL;

    //KeQuerySystemTime(&StartSystemTime);
    //StartSystemTime = KeQueryPerformanceCounter(NULL);
    StartSystemTime = CmpGetTimeStamp();
#endif //CMP_STATS


#ifdef CMP_KCB_CACHE_VALIDATION
    //
    // We have cached a lot of info into the kcb; Here is some validation code 
    //
    if( Kcb ) {
        BEGIN_KCB_LOCK_GUARD;                             
        CmpLockKCBTree();

        // number of values
        ASSERT( Node->ValueList.Count == Kcb->ValueCache.Count );

        // number of subkeys
        if( !(Kcb->ExtFlags & CM_KCB_INVALID_CACHED_INFO) ) {
            // there is some cached info
            ULONG   SubKeyCount = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];

            if( Kcb->ExtFlags & CM_KCB_NO_SUBKEY ) {
                ASSERT( SubKeyCount == 0 );
            } else if( Kcb->ExtFlags & CM_KCB_SUBKEY_ONE ) {
                ASSERT( SubKeyCount == 1 );
            } else if( Kcb->ExtFlags & CM_KCB_SUBKEY_HINT ) {
                ASSERT( SubKeyCount == Kcb->IndexHint->Count );
            } else {
                ASSERT( SubKeyCount == Kcb->SubKeyCount );
            }
        }

        // LastWriteTime
        ASSERT( Node->LastWriteTime.QuadPart == Kcb->KcbLastWriteTime.QuadPart );

        // MaxNameLen
        ASSERT( Node->MaxNameLen == Kcb->KcbMaxNameLen );

        // MaxValueNameLen
        ASSERT( Node->MaxValueNameLen == Kcb->KcbMaxValueNameLen );

        // MaxValueDataLen
        ASSERT( Node->MaxValueDataLen == Kcb->KcbMaxValueDataLen );

        CmpUnlockKCBTree();
        END_KCB_LOCK_GUARD;                             
    }

#endif //CMP_KCB_CACHE_VALIDATION

    pbuffer = (PKEY_INFORMATION)KeyInformation;
    NameLength = CmpHKeyNameLen(Node);

    switch (KeyInformationClass) {

    case KeyBasicInformation:

#ifdef CMP_STATS
        if(Kcb) {
            CmpQueryKeyDataDebug.BasicInformation++;
            TimeCounter = &(CmpQueryKeyDataDebug.BasicInformationTimeCounter);
            TimeElapsed = &(CmpQueryKeyDataDebug.BasicInformationTimeElapsed);
        } else {
            CmpQueryKeyDataDebug.EnumerateKeyBasicInformation++;
            TimeCounter = &(CmpQueryKeyDataDebug.EnumerateKeyBasicInformationTimeCounter);
            TimeElapsed = &(CmpQueryKeyDataDebug.EnumerateKeyBasicInformationTimeElapsed);
        }
#endif //CMP_STATS

        //
        // LastWriteTime, TitleIndex, NameLength, Name

        requiredlength = FIELD_OFFSET(KEY_BASIC_INFORMATION, Name) +
                         NameLength;

        minimumlength = FIELD_OFFSET(KEY_BASIC_INFORMATION, Name);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyBasicInformation.LastWriteTime =
                Node->LastWriteTime;

            pbuffer->KeyBasicInformation.TitleIndex = 0;

            pbuffer->KeyBasicInformation.NameLength =
                NameLength;

            leftlength = Length - minimumlength;

            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (Node->Flags & KEY_COMP_NAME) {
                CmpCopyCompressedName(pbuffer->KeyBasicInformation.Name,
                                      leftlength,
                                      Node->Name,
                                      Node->NameLength);
            } else {
                RtlCopyMemory(
                    &(pbuffer->KeyBasicInformation.Name[0]),
                    &(Node->Name[0]),
                    requiredlength
                    );
            }
        }

        break;


    case KeyNodeInformation:

#ifdef CMP_STATS
        if(Kcb) {
            CmpQueryKeyDataDebug.NodeInformation++;
            TimeCounter = &(CmpQueryKeyDataDebug.NodeInformationTimeCounter);
            TimeElapsed = &(CmpQueryKeyDataDebug.NodeInformationTimeElapsed);
        } else {
            CmpQueryKeyDataDebug.EnumerateKeyNodeInformation++;
            TimeCounter = &(CmpQueryKeyDataDebug.EnumerateKeyNodeInformationTimeCounter);
            TimeElapsed = &(CmpQueryKeyDataDebug.EnumerateKeyNodeInformationTimeElapsed);
        }
#endif //CMP_STATS
        //
        // LastWriteTime, TitleIndex, ClassOffset, ClassLength
        // NameLength, Name, Class
        //
        requiredlength = FIELD_OFFSET(KEY_NODE_INFORMATION, Name) +
                         NameLength +
                         Node->ClassLength;

        minimumlength = FIELD_OFFSET(KEY_NODE_INFORMATION, Name);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyNodeInformation.LastWriteTime =
                Node->LastWriteTime;

            pbuffer->KeyNodeInformation.TitleIndex = 0;

            pbuffer->KeyNodeInformation.ClassLength =
                Node->ClassLength;

            pbuffer->KeyNodeInformation.NameLength =
                NameLength;

            leftlength = Length - minimumlength;
            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (Node->Flags & KEY_COMP_NAME) {
                CmpCopyCompressedName(pbuffer->KeyNodeInformation.Name,
                                      leftlength,
                                      Node->Name,
                                      Node->NameLength);
            } else {
                RtlCopyMemory(
                    &(pbuffer->KeyNodeInformation.Name[0]),
                    &(Node->Name[0]),
                    requiredlength
                    );
            }

            if (Node->ClassLength > 0) {

                offset = FIELD_OFFSET(KEY_NODE_INFORMATION, Name) +
                            NameLength;
                offset = ALIGN_OFFSET(offset);

                pbuffer->KeyNodeInformation.ClassOffset = offset;

                pclass = HvGetCell(Hive, Node->Class);
                if( pclass == NULL ) {
                    //
                    // we couldn't map this cell
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                pbuffer = (PKEY_INFORMATION)((PUCHAR)pbuffer + offset);

                leftlength = (((LONG)Length - (LONG)offset) < 0) ?
                                    0 :
                                    Length - offset;

                requiredlength = Node->ClassLength;

                if (leftlength < (LONG)requiredlength) {
                    requiredlength = leftlength;
                    status = STATUS_BUFFER_OVERFLOW;
                }

                RtlCopyMemory(
                    pbuffer,
                    pclass,
                    requiredlength
                    );

                HvReleaseCell(Hive,Node->Class);

            } else {
                pbuffer->KeyNodeInformation.ClassOffset = (ULONG)-1;
            }
        }

        break;


    case KeyFullInformation:

#ifdef CMP_STATS
        if(Kcb) {
            CmpQueryKeyDataDebug.FullInformation++;
            TimeCounter = &(CmpQueryKeyDataDebug.FullInformationTimeCounter);
            TimeElapsed = &(CmpQueryKeyDataDebug.FullInformationTimeElapsed);
        } else {
            CmpQueryKeyDataDebug.EnumerateKeyFullInformation++;
            TimeCounter = &(CmpQueryKeyDataDebug.EnumerateKeyFullInformationTimeCounter);
            TimeElapsed = &(CmpQueryKeyDataDebug.EnumerateKeyFullInformationTimeElapsed);
        }
#endif //CMP_STATS

        //
        // LastWriteTime, TitleIndex, ClassOffset, ClassLength,
        // SubKeys, MaxNameLen, MaxClassLen, Values, MaxValueNameLen,
        // MaxValueDataLen, Class
        //
        requiredlength = FIELD_OFFSET(KEY_FULL_INFORMATION, Class) +
                         Node->ClassLength;

        minimumlength = FIELD_OFFSET(KEY_FULL_INFORMATION, Class);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyFullInformation.LastWriteTime =
                Node->LastWriteTime;

            pbuffer->KeyFullInformation.TitleIndex = 0;

            pbuffer->KeyFullInformation.ClassLength =
                Node->ClassLength;

            if (Node->ClassLength > 0) {

                pbuffer->KeyFullInformation.ClassOffset =
                        FIELD_OFFSET(KEY_FULL_INFORMATION, Class);

                pclass = HvGetCell(Hive, Node->Class);
                if( pclass == NULL ) {
                    //
                    // we couldn't map this cell
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                leftlength = Length - minimumlength;
                requiredlength = Node->ClassLength;

                if (leftlength < (LONG)requiredlength) {
                    requiredlength = leftlength;
                    status = STATUS_BUFFER_OVERFLOW;
                }

                RtlCopyMemory(
                    &(pbuffer->KeyFullInformation.Class[0]),
                    pclass,
                    requiredlength
                    );

                HvReleaseCell(Hive,Node->Class);

            } else {
                pbuffer->KeyFullInformation.ClassOffset = (ULONG)-1;
            }

            pbuffer->KeyFullInformation.SubKeys =
                Node->SubKeyCounts[Stable] +
                Node->SubKeyCounts[Volatile];

            pbuffer->KeyFullInformation.Values =
                Node->ValueList.Count;

            pbuffer->KeyFullInformation.MaxNameLen =
                Node->MaxNameLen;

            pbuffer->KeyFullInformation.MaxClassLen =
                Node->MaxClassLen;

            pbuffer->KeyFullInformation.MaxValueNameLen =
                Node->MaxValueNameLen;

            pbuffer->KeyFullInformation.MaxValueDataLen =
                Node->MaxValueDataLen;

        }

        break;


    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

#ifdef CMP_STATS
    if( TimeCounter && TimeElapsed ){
        //EndSystemTime = KeQueryPerformanceCounter(NULL);
        //KeQuerySystemTime(&EndSystemTime);
        EndSystemTime = CmpGetTimeStamp();
        if( (EndSystemTime - StartSystemTime) > 0 ) {
            (*TimeCounter)++;
            //(*TimeElapsed) += (ULONG)(EndSystemTime.QuadPart - StartSystemTime.QuadPart);
            (*TimeElapsed) += (EndSystemTime - StartSystemTime);
        }
    }
#endif //CMP_STATS

    return status;
}

NTSTATUS
CmpQueryKeyDataFromCache(
    PCM_KEY_CONTROL_BLOCK   Kcb,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   KeyInformation,
    ULONG                   Length,
    PULONG                  ResultLength
    )
/*++

Routine Description:

    Do the actual copy of data for a key into caller's buffer.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

    Works only for the information cached into kcb. I.e. KeyBasicInformation
    and KeyCachedInfo


Arguments:

    Kcb - Supplies pointer to the kcb to be queried

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyCachedInformation - return last write time, title index, name ....
            (see KEY_CACHED_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS            status;
    PKEY_INFORMATION    pbuffer;
    ULONG               requiredlength;
    ULONG               minimumlength;
    USHORT              NameLength;
    LONG                leftlength;
    PCM_KEY_NODE        Node; // this is to be used only in case of cache incoherency

    PAGED_CODE();

#ifdef CMP_KCB_CACHE_VALIDATION
    //
    // We have cached a lot of info into the kcb; Here is some validation code 
    //
    if( Kcb ) {
        BEGIN_KCB_LOCK_GUARD;                             
        CmpLockKCBTree();

        Node = (PCM_KEY_NODE)HvGetCell(Kcb->KeyHive,Kcb->KeyCell);
        if( Node != NULL ) {
            // number of values
            ASSERT( Node->ValueList.Count == Kcb->ValueCache.Count );

            // number of subkeys
            if( !(Kcb->ExtFlags & CM_KCB_INVALID_CACHED_INFO) ) {
                // there is some cached info
                ULONG   SubKeyCount = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];

                if( Kcb->ExtFlags & CM_KCB_NO_SUBKEY ) {
                    ASSERT( SubKeyCount == 0 );
                } else if( Kcb->ExtFlags & CM_KCB_SUBKEY_ONE ) {
                    ASSERT( SubKeyCount == 1 );
                } else if( Kcb->ExtFlags & CM_KCB_SUBKEY_HINT ) {
                    ASSERT( SubKeyCount == Kcb->IndexHint->Count );
                } else {
                    ASSERT( SubKeyCount == Kcb->SubKeyCount );
                }
            }

            // LastWriteTime
            ASSERT( Node->LastWriteTime.QuadPart == Kcb->KcbLastWriteTime.QuadPart );

            // MaxNameLen
            ASSERT( Node->MaxNameLen == Kcb->KcbMaxNameLen );

            // MaxValueNameLen
            ASSERT( Node->MaxValueNameLen == Kcb->KcbMaxValueNameLen );

            // MaxValueDataLen
            ASSERT( Node->MaxValueDataLen == Kcb->KcbMaxValueDataLen );
            HvReleaseCell(Kcb->KeyHive,Kcb->KeyCell);
        }
        
        CmpUnlockKCBTree();
        END_KCB_LOCK_GUARD;                             
    }

#endif //CMP_KCB_CACHE_VALIDATION

    //
    // we cannot afford to return the kcb NameBlock as the key name
    // for KeyBasicInformation as there are lots of callers expecting
    // the name to be case-sensitive; KeyCachedInformation is new
    // and used only by the Win32 layer, which is not case sensitive
    // Note: future clients of KeyCachedInformation must be made aware 
    // that name is NOT case-sensitive
    //
    ASSERT( KeyInformationClass == KeyCachedInformation );

    // 
    // we are going to need the nameblock; if it is NULL, bail out
    //
    if( Kcb->NameBlock == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pbuffer = (PKEY_INFORMATION)KeyInformation;
    
    if (Kcb->NameBlock->Compressed) {
        NameLength = CmpCompressedNameSize(Kcb->NameBlock->Name,Kcb->NameBlock->NameLength);
    } else {
        NameLength = Kcb->NameBlock->NameLength;
    }
    
    // Assume success
    status = STATUS_SUCCESS;

    switch (KeyInformationClass) {

#if 0
    case KeyBasicInformation:

        //
        // LastWriteTime, TitleIndex, NameLength, Name

        requiredlength = FIELD_OFFSET(KEY_BASIC_INFORMATION, Name) +
                         NameLength;

        minimumlength = FIELD_OFFSET(KEY_BASIC_INFORMATION, Name);

        *ResultLength = requiredlength;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyBasicInformation.LastWriteTime = Kcb->KcbLastWriteTime;

            pbuffer->KeyBasicInformation.TitleIndex = 0;

            pbuffer->KeyBasicInformation.NameLength = NameLength;

            leftlength = Length - minimumlength;

            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (Kcb->NameBlock->Compressed) {
                CmpCopyCompressedName(pbuffer->KeyBasicInformation.Name,
                                      leftlength,
                                      Kcb->NameBlock->Name,
                                      Kcb->NameBlock->NameLength);
            } else {
                RtlCopyMemory(
                    &(pbuffer->KeyBasicInformation.Name[0]),
                    &(Kcb->NameBlock->Name[0]),
                    requiredlength
                    );
            }
        }

        break;
#endif

    case KeyCachedInformation:

        //
        // LastWriteTime, TitleIndex, 
        // SubKeys, MaxNameLen, Values, MaxValueNameLen,
        // MaxValueDataLen, Name
        //
        requiredlength = sizeof(KEY_CACHED_INFORMATION);

        *ResultLength = requiredlength;

        if (Length < requiredlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyCachedInformation.LastWriteTime = Kcb->KcbLastWriteTime;

            pbuffer->KeyCachedInformation.TitleIndex = 0;

            pbuffer->KeyCachedInformation.NameLength = NameLength;

            pbuffer->KeyCachedInformation.Values = Kcb->ValueCache.Count;
            
            pbuffer->KeyCachedInformation.MaxNameLen = Kcb->KcbMaxNameLen;
            
            pbuffer->KeyCachedInformation.MaxValueNameLen = Kcb->KcbMaxValueNameLen;
            
            pbuffer->KeyCachedInformation.MaxValueDataLen = Kcb->KcbMaxValueDataLen;

            if( !(Kcb->ExtFlags & CM_KCB_INVALID_CACHED_INFO) ) {
                // there is some cached info
                if( Kcb->ExtFlags & CM_KCB_NO_SUBKEY ) {
                    pbuffer->KeyCachedInformation.SubKeys = 0;
                } else if( Kcb->ExtFlags & CM_KCB_SUBKEY_ONE ) {
                    pbuffer->KeyCachedInformation.SubKeys = 1;
                } else if( Kcb->ExtFlags & CM_KCB_SUBKEY_HINT ) {
                    pbuffer->KeyCachedInformation.SubKeys = Kcb->IndexHint->Count;
                } else {
                    pbuffer->KeyCachedInformation.SubKeys = Kcb->SubKeyCount;
                }
            } else {
                //
                // kcb cache is not coherent; get the info from knode
                // 
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Kcb cache incoherency detected, kcb = %p\n",Kcb));

                Node = (PCM_KEY_NODE)HvGetCell(Kcb->KeyHive,Kcb->KeyCell);
                if( Node == NULL ) {
                    //
                    // couldn't map view for this cell
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                pbuffer->KeyCachedInformation.SubKeys = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];
                HvReleaseCell(Kcb->KeyHive,Kcb->KeyCell);

            }

        }

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    return status;
}


BOOLEAN
CmpGetValueDataFromCache(
    IN PHHIVE               Hive,
    IN PPCM_CACHED_VALUE    ContainingList,
    IN PCELL_DATA           ValueKey,
    IN BOOLEAN              ValueCached,
    OUT PUCHAR              *DataPointer,
    OUT PBOOLEAN            Allocated,
    OUT PHCELL_INDEX        CellToRelease
)
/*++

Routine Description:

    Get the cached Value Data given a value node.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ContainingList - Address that stores the allocation address of the value node.
                     We need to update this when we do a re-allocate to cache
                     both value key and value data.

    ValueKey - pointer to the Value Key

    ValueCached - Indicating whether Value key is cached or not.

    DataPointer - out param to receive a pointer to the data

    Allocated - out param telling if the caller should free the DataPointer

Return Value:

    TRUE - data was retrieved
    FALSE - some error (STATUS_INSUFFICIENT_RESOURCES) occured

Note:
    
    The caller is responsible for freeing the DataPointer when we signal it to him
    by setting Allocated on TRUE;

    Also we must be sure that MAXIMUM_CACHED_DATA is smaller than CM_KEY_VALUE_BIG
--*/
{
    //
    // Cache the data if needed.
    //
    PCM_CACHED_VALUE OldEntry;
    PCM_CACHED_VALUE NewEntry;
    PUCHAR      Cacheddatapointer;
    ULONG       AllocSize;
    ULONG       CopySize;
    ULONG       DataSize;

    ASSERT( MAXIMUM_CACHED_DATA < CM_KEY_VALUE_BIG );

    //
    // this routine should not be called for small data
    //
    ASSERT( (ValueKey->u.KeyValue.DataLength & CM_KEY_VALUE_SPECIAL_SIZE) == 0 );
    
    //
    // init out params
    //
    *DataPointer = NULL;
    *Allocated = FALSE;
    *CellToRelease = HCELL_NIL;

    if (ValueCached) {
        OldEntry = (PCM_CACHED_VALUE) CMP_GET_CACHED_ADDRESS(*ContainingList);
        if (OldEntry->DataCacheType == CM_CACHE_DATA_CACHED) {
            //
            // Data is already cached, use it.
            //
            *DataPointer = (PUCHAR) ((ULONG_PTR) ValueKey + OldEntry->ValueKeySize);
        } else {
            if ((OldEntry->DataCacheType == CM_CACHE_DATA_TOO_BIG) ||
                (ValueKey->u.KeyValue.DataLength > MAXIMUM_CACHED_DATA ) 
               ){
                //
                // Mark the type and do not cache it.
                //
                OldEntry->DataCacheType = CM_CACHE_DATA_TOO_BIG;

                //
                // Data is too big to warrent caching, get it from the registry; 
                // - regardless of the size; we might be forced to allocate a buffer
                //
                if( CmpGetValueData(Hive,&(ValueKey->u.KeyValue),&DataSize,DataPointer,Allocated,CellToRelease) == FALSE ) {
                    //
                    // insufficient resources; return NULL
                    //
                    ASSERT( *Allocated == FALSE );
                    ASSERT( *DataPointer == NULL );
                    return FALSE;
                }

            } else {
                //
                // consistency check
                //
                ASSERT(OldEntry->DataCacheType == CM_CACHE_DATA_NOT_CACHED);

                //
                // Value data is not cached.
                // Check the size of value data, if it is smaller than MAXIMUM_CACHED_DATA, cache it.
                //
                // Anyway, the data is for sure not stored in a big data cell (see test above)
                //
                //
                *DataPointer = (PUCHAR)HvGetCell(Hive, ValueKey->u.KeyValue.Data);
                if( *DataPointer == NULL ) {
                    //
                    // we couldn't map this cell
                    // the caller must handle this gracefully !
                    //
                    return FALSE;
                }
                //
                // inform the caller it has to release this cell
                //
                *CellToRelease = ValueKey->u.KeyValue.Data;
                
                //
                // copy only valid data; cell might be bigger
                //
                //DataSize = (ULONG) HvGetCellSize(Hive, datapointer);
                DataSize = (ULONG)ValueKey->u.KeyValue.DataLength;

                //
                // consistency check
                //
                ASSERT(DataSize <= MAXIMUM_CACHED_DATA);

                //
                // Data is not cached and now we are going to do it.
                // Reallocate a new cached entry for both value key and value data.
                //
                CopySize = DataSize + OldEntry->ValueKeySize;
                AllocSize = CopySize + FIELD_OFFSET(CM_CACHED_VALUE, KeyValue);

                // Dragos: Changed to catch the memory violator
                // it didn't work
                //NewEntry = (PCM_CACHED_VALUE) ExAllocatePoolWithTagPriority(PagedPool, AllocSize, CM_CACHE_VALUE_DATA_TAG,NormalPoolPrioritySpecialPoolUnderrun);
                NewEntry = (PCM_CACHED_VALUE) ExAllocatePoolWithTag(PagedPool, AllocSize, CM_CACHE_VALUE_DATA_TAG);

                if (NewEntry) {
                    //
                    // Now fill the data to the new cached entry
                    //
                    NewEntry->DataCacheType = CM_CACHE_DATA_CACHED;
                    NewEntry->ValueKeySize = OldEntry->ValueKeySize;

                    RtlCopyMemory((PVOID)&(NewEntry->KeyValue),
                                  (PVOID)&(OldEntry->KeyValue),
                                  NewEntry->ValueKeySize);

                    Cacheddatapointer = (PUCHAR) ((ULONG_PTR) &(NewEntry->KeyValue) + OldEntry->ValueKeySize);
                    RtlCopyMemory(Cacheddatapointer, *DataPointer, DataSize);

                    // Trying to catch the BAD guy who writes over our pool.
                    CmpMakeSpecialPoolReadWrite( OldEntry );

                    *ContainingList = (PCM_CACHED_VALUE) CMP_MARK_CELL_CACHED(NewEntry);

                    // Trying to catch the BAD guy who writes over our pool.
                    CmpMakeSpecialPoolReadOnly( NewEntry );

                    //
                    // Free the old entry
                    //
                    ExFreePool(OldEntry);

                } 
            }
        }
    } else {
        if( CmpGetValueData(Hive,&(ValueKey->u.KeyValue),&DataSize,DataPointer,Allocated,CellToRelease) == FALSE ) {
            //
            // insufficient resources; return NULL
            //
            ASSERT( *Allocated == FALSE );
            ASSERT( *DataPointer == NULL );
            return FALSE;
        }
    }

    return TRUE;
}



NTSTATUS
CmpQueryKeyValueData(
    PHHIVE Hive,
    PPCM_CACHED_VALUE ContainingList,
    PCM_KEY_VALUE ValueKey,
    BOOLEAN     ValueCached,
    KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    PVOID KeyValueInformation,
    ULONG Length,
    PULONG ResultLength
    )
/*++

Routine Description:

    Do the actual copy of data for a key value into caller's buffer.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to whose sub keys are to be found

    KeyValueInformationClass - Specifies the type of information returned in
        KeyValueInformation.  One of the following types:

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS    status;
    PKEY_VALUE_INFORMATION pbuffer;
    PCELL_DATA  pcell;
    LONG        leftlength;
    ULONG       requiredlength;
    ULONG       minimumlength;
    ULONG       offset;
    ULONG       base;
    ULONG       realsize;
    PUCHAR      datapointer;
    BOOLEAN     small;
    USHORT      NameLength;
    BOOLEAN     BufferAllocated = FALSE;
    HCELL_INDEX CellToRelease = HCELL_NIL;

    pbuffer = (PKEY_VALUE_INFORMATION)KeyValueInformation;

    pcell = (PCELL_DATA) ValueKey;
    NameLength = CmpValueNameLen(&pcell->u.KeyValue);

    switch (KeyValueInformationClass) {

    case KeyValueBasicInformation:

        //
        // TitleIndex, Type, NameLength, Name
        //
        requiredlength = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name) +
                         NameLength;

        minimumlength = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyValueBasicInformation.TitleIndex = 0;

            pbuffer->KeyValueBasicInformation.Type =
                pcell->u.KeyValue.Type;

            pbuffer->KeyValueBasicInformation.NameLength =
                NameLength;

            leftlength = Length - minimumlength;
            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (pcell->u.KeyValue.Flags & VALUE_COMP_NAME) {
                CmpCopyCompressedName(pbuffer->KeyValueBasicInformation.Name,
                                      requiredlength,
                                      pcell->u.KeyValue.Name,
                                      pcell->u.KeyValue.NameLength);
            } else {
                RtlCopyMemory(&(pbuffer->KeyValueBasicInformation.Name[0]),
                              &(pcell->u.KeyValue.Name[0]),
                              requiredlength);
            }
        }

        break;



    case KeyValueFullInformation:
    case KeyValueFullInformationAlign64:

        //
        // TitleIndex, Type, DataOffset, DataLength, NameLength,
        // Name, Data
        //
        small = CmpIsHKeyValueSmall(realsize, pcell->u.KeyValue.DataLength);

        requiredlength = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name) +
                         NameLength +
                         realsize;

        minimumlength = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name);
        if (realsize > 0) {
            base = requiredlength - realsize;

#if defined(_WIN64)

            offset = ALIGN_OFFSET64(base);

#else

            if (KeyValueInformationClass == KeyValueFullInformationAlign64) {
                offset = ALIGN_OFFSET64(base);

            } else {
                offset = ALIGN_OFFSET(base);
            }

#endif

            if (offset > base) {
                requiredlength += (offset - base);
            }

#if DBG && defined(_WIN64)

            //
            // Some clients will have passed in a structure that they "know"
            // will be exactly the right size.  The fact that alignment
            // has changed on NT64 may cause these clients to have problems.
            //
            // The solution is to fix the client, but print out some debug
            // spew here if it looks like this is the case.  This problem
            // isn't particularly easy to spot from the client end.
            //

            if((KeyValueInformationClass == KeyValueFullInformation) &&
                (Length != minimumlength) &&
                (requiredlength > Length) &&
                ((requiredlength - Length) <=
                                (ALIGN_OFFSET64(base) - ALIGN_OFFSET(base)))) {

                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"ntos/config-64 KeyValueFullInformation: "
                                                                 "Possible client buffer size problem.\n"));

                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"    Required size = %d\n", requiredlength));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"    Supplied size = %d\n", Length));
            }

#endif

        }

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyValueFullInformation.TitleIndex = 0;

            pbuffer->KeyValueFullInformation.Type =
                pcell->u.KeyValue.Type;

            pbuffer->KeyValueFullInformation.DataLength =
                realsize;

            pbuffer->KeyValueFullInformation.NameLength =
                NameLength;

            leftlength = Length - minimumlength;
            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (pcell->u.KeyValue.Flags & VALUE_COMP_NAME) {
                CmpCopyCompressedName(pbuffer->KeyValueFullInformation.Name,
                                      requiredlength,
                                      pcell->u.KeyValue.Name,
                                      pcell->u.KeyValue.NameLength);
            } else {
                RtlCopyMemory(
                    &(pbuffer->KeyValueFullInformation.Name[0]),
                    &(pcell->u.KeyValue.Name[0]),
                    requiredlength
                    );
            }

            if (realsize > 0) {

                if (small == TRUE) {
                    datapointer = (PUCHAR)(&(pcell->u.KeyValue.Data));
                } else {
                    if( CmpGetValueDataFromCache(Hive, ContainingList, pcell, ValueCached,&datapointer,&BufferAllocated,&CellToRelease) == FALSE ){
                        //
                        // we couldn't map view for cell; treat it as insufficient resources problem
                        //
                        ASSERT( datapointer == NULL );
                        ASSERT( BufferAllocated == FALSE );
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                pbuffer->KeyValueFullInformation.DataOffset = offset;

                leftlength = (((LONG)Length - (LONG)offset) < 0) ?
                                    0 :
                                    Length - offset;

                requiredlength = realsize;

                if (leftlength < (LONG)requiredlength) {
                    requiredlength = leftlength;
                    status = STATUS_BUFFER_OVERFLOW;
                }

                ASSERT((small ? (requiredlength <= CM_KEY_VALUE_SMALL) : TRUE));

                if( datapointer != NULL ) {
                    RtlCopyMemory(
                        ((PUCHAR)pbuffer + offset),
                        datapointer,
                        requiredlength
                        );
                    if( BufferAllocated == TRUE ) {
                        ExFreePool(datapointer);
                    }
                    if( CellToRelease != HCELL_NIL ) {
                        HvReleaseCell(Hive,CellToRelease);
                    }
                }

            } else {
                pbuffer->KeyValueFullInformation.DataOffset = (ULONG)-1;
            }
        }

        break;


    case KeyValuePartialInformation:

        //
        // TitleIndex, Type, DataLength, Data
        //
        small = CmpIsHKeyValueSmall(realsize, pcell->u.KeyValue.DataLength);
        requiredlength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) +
                         realsize;

        minimumlength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyValuePartialInformation.TitleIndex = 0;

            pbuffer->KeyValuePartialInformation.Type =
                pcell->u.KeyValue.Type;

            pbuffer->KeyValuePartialInformation.DataLength =
                realsize;

            leftlength = Length - minimumlength;
            requiredlength = realsize;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (realsize > 0) {

                if (small == TRUE) {
                    datapointer = (PUCHAR)(&(pcell->u.KeyValue.Data));
                } else {
                    if( CmpGetValueDataFromCache(Hive, ContainingList, pcell, ValueCached,&datapointer,&BufferAllocated,&CellToRelease) == FALSE ){
                        //
                        // we couldn't map view for cell; treat it as insufficient resources problem
                        //
                        ASSERT( datapointer == NULL );
                        ASSERT( BufferAllocated == FALSE );
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                ASSERT((small ? (requiredlength <= CM_KEY_VALUE_SMALL) : TRUE));

                if( datapointer != NULL ) {
                    RtlCopyMemory((PUCHAR)&(pbuffer->KeyValuePartialInformation.Data[0]),
                                  datapointer,
                                  requiredlength);
                    if( BufferAllocated == TRUE ) {
                        ExFreePool(datapointer);
                    }
                    if(CellToRelease != HCELL_NIL) {
                        HvReleaseCell(Hive,CellToRelease);
                    }
                }
            }
        }

        break;
    case KeyValuePartialInformationAlign64:

        //
        // TitleIndex, Type, DataLength, Data
        //
        small = CmpIsHKeyValueSmall(realsize, pcell->u.KeyValue.DataLength);
        requiredlength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, Data) +
                         realsize;

        minimumlength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, Data);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyValuePartialInformationAlign64.Type =
                pcell->u.KeyValue.Type;

            pbuffer->KeyValuePartialInformationAlign64.DataLength =
                realsize;

            leftlength = Length - minimumlength;
            requiredlength = realsize;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (realsize > 0) {

                if (small == TRUE) {
                    datapointer = (PUCHAR)(&(pcell->u.KeyValue.Data));
                } else {
                    if( CmpGetValueDataFromCache(Hive, ContainingList, pcell, ValueCached,&datapointer,&BufferAllocated,&CellToRelease) == FALSE ){
                        //
                        // we couldn't map view for cell; treat it as insufficient resources problem
                        //
                        ASSERT( datapointer == NULL );
                        ASSERT( BufferAllocated == FALSE );
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                ASSERT((small ? (requiredlength <= CM_KEY_VALUE_SMALL) : TRUE));
                if( datapointer != NULL ) {
                    RtlCopyMemory((PUCHAR)&(pbuffer->KeyValuePartialInformationAlign64.Data[0]),
                                  datapointer,
                                  requiredlength);
                    if( BufferAllocated == TRUE ) {
                        ExFreePool(datapointer);
                    }
                    if(CellToRelease != HCELL_NIL) {
                        HvReleaseCell(Hive,CellToRelease);
                    }

                }
            }
        }

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmtredel.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmtredel.c

Abstract:

    This file contains code for CmpDeleteTree, and support.

Author:

    Bryan M. Willman (bryanwi) 24-Jan-92

Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpDeleteTree)
#pragma alloc_text(PAGE,CmpFreeKeyByCell)
#pragma alloc_text(PAGE,CmpMarkKeyDirty)
#endif

//
// Routine to actually call to do a tree delete
//

VOID
CmpDeleteTree(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Delete all child subkeys, recursively, of Hive.Cell.  Delete all
    value entries of Hive.Cell.  Do NOT delete Hive.Cell itself.

    NOTE:   If this call fails part way through, it will NOT undo
            any successfully completed deletes.

    NOTE:   This algorithm can deal with a hive of any depth, at the
            cost of some "redundent" scaning and mapping.

Arguments:

    Hive - pointer to hive control structure for hive to delete from

    Cell - index of cell at root of tree to delete

Return Value:

    BOOLEAN - Result code from call, among the following:
        TRUE - it worked
        FALSE - the tree delete was not completed (though more than 0
                keys may have been deleted)

--*/
{
    ULONG  count;
    HCELL_INDEX ptr1;
    HCELL_INDEX ptr2;
    HCELL_INDEX parent;
    PCM_KEY_NODE Node;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpDeleteTree:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tHive=%p Cell=%08lx\n",Hive,Cell));

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    ptr1 = Cell;

    while(TRUE) {

        Node = (PCM_KEY_NODE)HvGetCell(Hive, ptr1);
        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // bad luck! we cannot delete this tree
            //
            return;
        }
        count = Node->SubKeyCounts[Stable] +
                Node->SubKeyCounts[Volatile];
        parent = Node->Parent;

        if (count > 0) {                // ptr1->count > 0?

            //
            // subkeys exist, find and delete them
            //
            ptr2 = CmpFindSubKeyByNumber(Hive, Node, 0);
            
            //
            // release the cell here as we are overriding node
            //
            HvReleaseCell(Hive, ptr1);

            if( ptr2 == HCELL_NIL ) {
                //
                // we couldn't map view inside
                // bad luck! we cannot delete this tree
                //
                return;
            }

            Node = (PCM_KEY_NODE)HvGetCell(Hive, ptr2);
            if( Node == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // bad luck! we cannot delete this tree
                //
                return;
            }
            count = Node->SubKeyCounts[Stable] +
                    Node->SubKeyCounts[Volatile];

            //
            // release the cell here as we don't need it anymore
            //
            HvReleaseCell(Hive, ptr2);
            if (count > 0) {            // ptr2->count > 0?

                //
                // subkey has subkeys, descend to next level
                //
                ptr1 = ptr2;
                continue;

            } else {

                //
                // have found leaf, delete it
                //
                CmpFreeKeyByCell(Hive, ptr2, TRUE);
                continue;
            }

        } else {
            //
            // release the cell here as we don't need it anymore
            //
            HvReleaseCell(Hive, ptr1);

            //
            // no more subkeys at this level, we are now a leaf.
            //
            if (ptr1 != Cell) {

                //
                // we are not at the root cell, so ascend to parent
                //
                ptr1 = parent;          // ptr1 = ptr1->parent
                continue;

            } else {

                //
                // we are at the root cell, we are done
                //
                return;
            }
        } // outer if
    } // while
}


NTSTATUS
CmpFreeKeyByCell(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    BOOLEAN Unlink
    )
/*++

Routine Description:

    Actually free the storage for the specified cell.  We will first
    remove it from its parent's child key list, then free all of its
    values, then the key body itself.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Cell - index for cell to free storage for (the target)

    Unlink - if TRUE, target cell will be removed from parent cell's
             subkeylist, if FALSE, it will NOT be.

Return Value:

    NONE.

--*/
{
    PCELL_DATA  ptarget;
    PCELL_DATA  pparent;
    PCELL_DATA  plist;
    ULONG       i;

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // Mark dirty everything that we might touch
    //
    if (! CmpMarkKeyDirty(Hive, Cell
#if DBG
		,TRUE
#endif //DBG
		)) {
        return STATUS_NO_LOG_SPACE;
    }

    //
    // Map in the target
    //
    ptarget = HvGetCell(Hive, Cell);
    if( ptarget == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // we shouldn't hit this as we just marked the cell dirty
        //
        ASSERT( FALSE );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // release the cell here as it is dirty(pinned); it cannot go anywhere
    //
    HvReleaseCell(Hive, Cell);

    ASSERT((ptarget->u.KeyNode.SubKeyCounts[Stable] +
            ptarget->u.KeyNode.SubKeyCounts[Volatile]) == 0);


    if (Unlink == TRUE) {
        BOOLEAN Success;

        Success = CmpRemoveSubKey(Hive, ptarget->u.KeyNode.Parent, Cell);
        if (!Success) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        pparent = HvGetCell(Hive, ptarget->u.KeyNode.Parent);
        if( pparent == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // we shouldn't hit this as we just marked the cell dirty
            //
            ASSERT( FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        //
        // release the cell here as it is dirty(pinned); it cannot go anywhere
        //
        HvReleaseCell(Hive, ptarget->u.KeyNode.Parent);

        if ( (pparent->u.KeyNode.SubKeyCounts[Stable] +
              pparent->u.KeyNode.SubKeyCounts[Volatile]) == 0)
        {
            pparent->u.KeyNode.MaxNameLen = 0;
            pparent->u.KeyNode.MaxClassLen = 0;
        }
    }

    //
    // Target is now an unreferenced key, free it's actual storage
    //

    //
    // Free misc stuff
    //
    if (!(ptarget->u.KeyNode.Flags & KEY_HIVE_EXIT) &&
        !(ptarget->u.KeyNode.Flags & KEY_PREDEF_HANDLE) ) {

        //
        // First, free the value entries
        //
        if (ptarget->u.KeyNode.ValueList.Count > 0) {

            // target list
            plist = HvGetCell(Hive, ptarget->u.KeyNode.ValueList.List);
            if( plist == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // we shouldn't hit this as we just marked the cell dirty
                //
                ASSERT( FALSE );
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            //
            // release the cell here as it is dirty(pinned); it cannot go anywhere
            //
            HvReleaseCell(Hive, ptarget->u.KeyNode.ValueList.List);

            for (i = 0; i < ptarget->u.KeyNode.ValueList.Count; i++) {
                // 
                // even if we cannot free the value here, we ignore it.
                // nothing bad happens (just some leaks)
                //
                if( CmpFreeValue(Hive, plist->u.KeyList[i]) == FALSE ) {
                    //
                    // we couldn't map view inside call above
                    // this shouldn't happen as we just marked the values dirty
                    // (i.e. they should be PINNED into memory by now)
                    //
                    ASSERT( FALSE );
                }
            }

            HvFreeCell(Hive, ptarget->u.KeyNode.ValueList.List);
        }

        //
        // Free the security descriptor
        //
        CmpFreeSecurityDescriptor(Hive, Cell);
    }

    //
    // Free the key body itself, and Class data.
    //
    if( CmpFreeKeyBody(Hive, Cell) == FALSE ) {
        //
        // couldn't map view inside
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
CmpMarkKeyDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell
#if DBG
	, 
	BOOLEAN CheckNoSubkeys
#endif
    )
/*++

Routine Description:

    Mark all of the cells related to a key being deleted dirty.
    Includes the parent, the parent's child list, the key body,
    class, security, all value entry bodies, and all of their data cells.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Cell - index for cell holding keybody to make dirty

Return Value:

    TRUE - it worked

    FALSE - some error, most likely cannot get log space

--*/
{
    PCELL_DATA  ptarget;
    PCELL_DATA  plist;
    PCELL_DATA  security;
    PCELL_DATA  pvalue;
    ULONG       i;
    ULONG realsize;

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // Map in the target
    //
    ptarget = HvGetCell(Hive, Cell);
    if( ptarget == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }

#if DBG
	if(CheckNoSubkeys == TRUE) {
		ASSERT(ptarget->u.KeyNode.SubKeyCounts[Stable] == 0);
		ASSERT(ptarget->u.KeyNode.SubKeyCounts[Volatile] == 0);
	}
#endif //DBG

    if (ptarget->u.KeyNode.Flags & KEY_HIVE_EXIT) {

        //
        // If this is a link node, we are done.  Link nodes never have
        // classes, values, subkeys, or security descriptors.  Since
        // they always reside in the master hive, they're always volatile.
        //
        HvReleaseCell(Hive, Cell);
        return(TRUE);
    }

    //
    // mark cell itself
    //
    if (! HvMarkCellDirty(Hive, Cell)) {
        HvReleaseCell(Hive, Cell);
        return FALSE;
    }
    //
    // we can safely release it here, as it is now dirty/pinned
    //
    HvReleaseCell(Hive, Cell);

    //
    // Mark the class
    //
    if (ptarget->u.KeyNode.Class != HCELL_NIL) {
        if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.Class)) {
            return FALSE;
        }
    }

    //
    // Mark security
    //
    if (ptarget->u.KeyNode.Security != HCELL_NIL) {
        if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.Security)) {
            return FALSE;
        }

        security = HvGetCell(Hive, ptarget->u.KeyNode.Security);
        if( security == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // we shouldn't hit this as we just marked the cell dirty
            // (i.e. dirty == PINNED in memory)
            //
            ASSERT( FALSE );
            return FALSE;
        }

        //
        // we can safely release it here, as it is now dirty/pinned
        //
        HvReleaseCell(Hive, ptarget->u.KeyNode.Security);

        if (! (HvMarkCellDirty(Hive, security->u.KeySecurity.Flink) &&
               HvMarkCellDirty(Hive, security->u.KeySecurity.Blink)))
        {
            return FALSE;
        }
    }

    //
    // Mark the value entries and their data
    //
    if ( !(ptarget->u.KeyNode.Flags & KEY_PREDEF_HANDLE) && 
		  (ptarget->u.KeyNode.ValueList.Count > 0) 
	   ) {

        // target list
        if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.ValueList.List)) {
            return FALSE;
        }
        plist = HvGetCell(Hive, ptarget->u.KeyNode.ValueList.List);
        if( plist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // we shouldn't hit this as we just marked the cell dirty
            // (i.e. dirty == PINNED in memory)
            //
            ASSERT( FALSE );
            return FALSE;
        }

        //
        // we can safely release it here, as it is now dirty/pinned
        //
        HvReleaseCell(Hive, ptarget->u.KeyNode.ValueList.List);

        for (i = 0; i < ptarget->u.KeyNode.ValueList.Count; i++) {
            if (! HvMarkCellDirty(Hive, plist->u.KeyList[i])) {
                return FALSE;
            }

            pvalue = HvGetCell(Hive, plist->u.KeyList[i]);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // we shouldn't hit this as we just marked the cell dirty
                // (i.e. dirty == PINNED in memory)
                //
                ASSERT( FALSE );
                return FALSE;
            }

            //
            // we can safely release it here, as it is now dirty/pinned
            //
            HvReleaseCell(Hive,plist->u.KeyList[i]);

            if( !CmpMarkValueDataDirty(Hive,&(pvalue->u.KeyValue)) ) {
                return FALSE;
            }
        }
    }

    if (ptarget->u.KeyNode.Flags & KEY_HIVE_ENTRY) {

        //
        // if this is an entry node, we are done.  our parent will
        // be in the master hive (and thus volatile)
        //
        return TRUE;
    }

    //
    // Mark the parent's Subkey list
    //
    if (! CmpMarkIndexDirty(Hive, ptarget->u.KeyNode.Parent, Cell)) {
        return FALSE;
    }

    //
    // Mark the parent
    //
    if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.Parent)) {
        return FALSE;
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmtree.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmtree.c

Abstract:

    This module contains cm routines that understand the structure
    of the registry tree.

Author:

    Bryan M. Willman (bryanwi) 12-Sep-1991

Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpGetValueListFromCache)
#pragma alloc_text(PAGE,CmpGetValueKeyFromCache)
#pragma alloc_text(PAGE,CmpFindValueByNameFromCache)
#endif

#ifndef _CM_LDR_

PCELL_DATA
CmpGetValueListFromCache(
    IN PHHIVE  Hive,
    IN PCACHED_CHILD_LIST ChildList,
    OUT BOOLEAN    *IndexCached
)
/*++

Routine Description:

    Get the Valve Index Array.  Check if it is already cached, if not, cache it and return
    the cached entry.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ChildList - pointer/index to the Value Index array

    IndexCached - Indicating whether Value Index list is cached or not.

Return Value:

    Pointer to the Valve Index Array.

    NULL when we could not map view 

--*/
{
    PCELL_DATA              List;
    ULONG                   AllocSize;
    PCM_CACHED_VALUE_INDEX  CachedValueIndex;
    ULONG                   i;
    HCELL_INDEX             CellToRelease;

#ifndef _WIN64
    *IndexCached = TRUE;
    if (CMP_IS_CELL_CACHED(ChildList->ValueList)) {
        //
        // The entry is already cached.
        //
        List = CMP_GET_CACHED_CELLDATA(ChildList->ValueList);
    } else {
        //
        // The entry is not cached.  The element contains the hive index.
        //
        CellToRelease = CMP_GET_CACHED_CELL_INDEX(ChildList->ValueList);
        List = (PCELL_DATA) HvGetCell(Hive, CellToRelease);
        if( List == NULL ) {
            //
            // we couldn't map a view for this cell
            //
            return NULL;
        }

        //
        // Allocate a PagedPool to cache the value index cell.
        //

        AllocSize = ChildList->Count * sizeof(ULONG_PTR) + FIELD_OFFSET(CM_CACHED_VALUE_INDEX, Data);
        // Dragos: Changed to catch the memory violator
        // it didn't work
        //CachedValueIndex = (PCM_CACHED_VALUE_INDEX) ExAllocatePoolWithTagPriority(PagedPool, AllocSize, CM_CACHE_VALUE_INDEX_TAG,NormalPoolPrioritySpecialPoolUnderrun);
        CachedValueIndex = (PCM_CACHED_VALUE_INDEX) ExAllocatePoolWithTag(PagedPool, AllocSize, CM_CACHE_VALUE_INDEX_TAG);

        if (CachedValueIndex) {

            CachedValueIndex->CellIndex = CMP_GET_CACHED_CELL_INDEX(ChildList->ValueList);
            for (i=0; i<ChildList->Count; i++) {
                CachedValueIndex->Data.List[i] = (ULONG_PTR) List->u.KeyList[i];
            }

            ChildList->ValueList = CMP_MARK_CELL_CACHED(CachedValueIndex);

            // Trying to catch the BAD guy who writes over our pool.
            CmpMakeSpecialPoolReadOnly( CachedValueIndex );

            //
            // Now we have the stuff cached, use the cache data.
            //
            List = CMP_GET_CACHED_CELLDATA(ChildList->ValueList);
        } else {
            //
            // If the allocation fails, just do not cache it. continue.
            //
            *IndexCached = FALSE; 
        }
        HvReleaseCell(Hive, CellToRelease);
    }
#else
    CellToRelease = CMP_GET_CACHED_CELL_INDEX(ChildList->ValueList);
    List = (PCELL_DATA) HvGetCell(Hive, CMP_GET_CACHED_CELL_INDEX(ChildList->ValueList));
    *IndexCached = FALSE;
    if( List == NULL ) {
        //
        // we couldn't map a view for this cell
        // OBS: we can drop this as we return List anyway; just for clarity
        //
        return NULL;
    }
    HvReleaseCell(Hive, CellToRelease);
#endif

    return (List);
}

PCM_KEY_VALUE
CmpGetValueKeyFromCache(
    IN PHHIVE               Hive,
    IN PCELL_DATA           List,
    IN ULONG                Index,
    OUT PPCM_CACHED_VALUE   *ContainingList,
    IN BOOLEAN              IndexCached,
    OUT BOOLEAN             *ValueCached,
    OUT PHCELL_INDEX        CellToRelease
)
/*++

Routine Description:

    Get the Valve Node.  Check if it is already cached, if not but the index is cached, 
    cache and return the value node.

Arguments:

    Hive - pointer to hive control structure for hive of interest.

    List - pointer to the Value Index Array (of ULONG_PTR if cached and ULONG if non-cached)

    Index - Index in the Value index array

    ContainlingList - The address of the entry that will receive the found cached value.

    IndexCached - Indicate if the index list is cached.  If not, everything is from the
                  original registry data.

    ValueCached - Indicating whether Value is cached or not.

Return Value:

    Pointer to the Value Node.

    NULL when we couldn't map a view 
--*/
{
    PCM_KEY_VALUE       pchild;
    PULONG_PTR          CachedList;
    ULONG               AllocSize;
    ULONG               CopySize;
    PCM_CACHED_VALUE    CachedValue;

    *CellToRelease = HCELL_NIL;

    if (IndexCached) {
        //
        // The index array is cached, so List is pointing to an array of ULONG_PTR.
        // Use CachedList.
        //
        CachedList = (PULONG_PTR) List;
        *ValueCached = TRUE;
        if (CMP_IS_CELL_CACHED(CachedList[Index])) {
            pchild = CMP_GET_CACHED_KEYVALUE(CachedList[Index]);
            *ContainingList = &((PCM_CACHED_VALUE) CachedList[Index]);
        } else {
            pchild = (PCM_KEY_VALUE) HvGetCell(Hive, List->u.KeyList[Index]);
            if( pchild == NULL ) {
                //
                // we couldn't map a view for this cell
                // just return NULL; the caller must handle it gracefully
                //
                return NULL;
            }
            *CellToRelease = List->u.KeyList[Index];

            //
            // Allocate a PagedPool to cache the value node.
            //
            CopySize = (ULONG) HvGetCellSize(Hive, pchild);
            AllocSize = CopySize + FIELD_OFFSET(CM_CACHED_VALUE, KeyValue);
            
            // Dragos: Changed to catch the memory violator
            // it didn't work
            //CachedValue = (PCM_CACHED_VALUE) ExAllocatePoolWithTagPriority(PagedPool, AllocSize, CM_CACHE_VALUE_TAG,NormalPoolPrioritySpecialPoolUnderrun);
            CachedValue = (PCM_CACHED_VALUE) ExAllocatePoolWithTag(PagedPool, AllocSize, CM_CACHE_VALUE_TAG);

            if (CachedValue) {
                //
                // Set the information for later use if we need to cache data as well.
                //
                CachedValue->DataCacheType = CM_CACHE_DATA_NOT_CACHED;
                CachedValue->ValueKeySize = (USHORT) CopySize;

                RtlCopyMemory((PVOID)&(CachedValue->KeyValue), pchild, CopySize);


                // Trying to catch the BAD guy who writes over our pool.
                CmpMakeSpecialPoolReadWrite( CMP_GET_CACHED_ADDRESS(CachedList) );

                CachedList[Index] = CMP_MARK_CELL_CACHED(CachedValue);

                // Trying to catch the BAD guy who writes over our pool.
                CmpMakeSpecialPoolReadOnly( CMP_GET_CACHED_ADDRESS(CachedList) );


                // Trying to catch the BAD guy who writes over our pool.
                CmpMakeSpecialPoolReadOnly(CachedValue);

                *ContainingList = &((PCM_CACHED_VALUE) CachedList[Index]);
                //
                // Now we have the stuff cached, use the cache data.
                //
                pchild = CMP_GET_CACHED_KEYVALUE(CachedValue);
            } else {
                //
                // If the allocation fails, just do not cache it. continue.
                //
                *ValueCached = FALSE;
            }
        }
    } else {
        //
        // The Valve Index Array is from the registry hive, just get the cell and move on.
        //
        pchild = (PCM_KEY_VALUE) HvGetCell(Hive, List->u.KeyList[Index]);
        *ValueCached = FALSE;
        if( pchild == NULL ) {
            //
            // we couldn't map a view for this cell
            // just return NULL; the caller must handle it gracefully
            // OBS: we may remove this as we return pchild anyway; just for clarity
            //
            return NULL;
        }
        *CellToRelease = List->u.KeyList[Index];
    }
    return (pchild);
}

PCM_KEY_VALUE
CmpFindValueByNameFromCache(
    IN PHHIVE               Hive,
    IN PCACHED_CHILD_LIST   ChildList,
    IN PUNICODE_STRING      Name,
    OUT PPCM_CACHED_VALUE   *ContainingList,
    OUT ULONG               *Index,
    OUT BOOLEAN             *ValueCached,
    OUT PHCELL_INDEX        CellToRelease
    )
/*++

Routine Description:

    Find a value node given a value list array and a value name.  It sequentially walk
    through each value node to look for a match.  If the array and 
    value nodes touched are not already cached, cache them.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ChildList - pointer/index to the Value Index array

    Name - name of value to find

    ContainlingList - The address of the entry that will receive the found cached value.

    Index - pointer to variable to receive index for child
    
    ValueCached - Indicate if the value node is cached.

Return Value:

    HCELL_INDEX for the found cell
    HCELL_NIL if not found


Notes:
    
    New hives (Minor >= 4) have ValueList sorted; this implies ValueCache is sorted too;
    So, we can do a binary search here!

--*/
{
    NTSTATUS        status;
    PCM_KEY_VALUE   pchild;
    UNICODE_STRING  Candidate;
    LONG            Result;
    PCELL_DATA      List;
    BOOLEAN         IndexCached;
    ULONG           Current;

    *CellToRelease = HCELL_NIL;

    if (ChildList->Count != 0) {
        List = CmpGetValueListFromCache(Hive, ChildList, &IndexCached);
        if( List == NULL ) {
            //
            // couldn't map view; bail out
            //
            return NULL;
        }

        //
        // old plain hive; simulate a for
        //
        Current = 0;

        while( TRUE ) {
            if( *CellToRelease != HCELL_NIL ) {
                HvReleaseCell(Hive,*CellToRelease);
                *CellToRelease = HCELL_NIL;
            }
            pchild = CmpGetValueKeyFromCache(Hive, List, Current, ContainingList, IndexCached, ValueCached, CellToRelease);
            if( pchild == NULL ) {
                //
                // couldn't map view; bail out
                //
                return NULL;
            }

            try {
                //
                // Name has user-mode buffer.
                //

                if (pchild->Flags & VALUE_COMP_NAME) {
                    Result = CmpCompareCompressedName(  Name,
                                                        pchild->Name,
                                                        pchild->NameLength,
                                                        0);
                } else {
                    Candidate.Length = pchild->NameLength;
                    Candidate.MaximumLength = Candidate.Length;
                    Candidate.Buffer = pchild->Name;
                    Result = RtlCompareUnicodeString(   Name,
                                                        &Candidate,
                                                        TRUE);
                }


            } except (EXCEPTION_EXECUTE_HANDLER) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"CmpFindValueByNameFromCache: code:%08lx\n", GetExceptionCode()));
                //
                // the caller will bail out. Some ,alicious caller altered the Name buffer since we probed it.
                //
                return NULL;
            }

            if (Result == 0) {
                //
                // Success, fill the index, return data to caller and exit
                //
                *Index = Current;
                return(pchild);
            }

            //
            // compute the next index to try: old'n plain hive; go on
			//
            Current++;
            if( Current == ChildList->Count ) {
                //
                // we've reached the end of the list; nicely return
                //
                return NULL;
            }

        } // while(TRUE)
    }

    //
    // in the new design we shouldn't get here; we should exit the while loop with return
    //
    ASSERT( ChildList->Count == 0 );    
    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmwmi.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cmwmi.c

Abstract:

    This module contains support for tracing registry system calls 

Author:

    Dragos C. Sambotin (dragoss) 05-Mar-1999

Revision History:


--*/

#include    "cmp.h"
#pragma hdrstop
#include    <evntrace.h>

VOID
CmpWmiDumpKcbTable(
    VOID
);

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
PCM_TRACE_NOTIFY_ROUTINE CmpTraceRoutine = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmSetTraceNotifyRoutine)
#pragma alloc_text(PAGE,CmpWmiDumpKcbTable)
#pragma alloc_text(PAGE,CmpWmiDumpKcb)
#endif


NTSTATUS
CmSetTraceNotifyRoutine(
    IN PCM_TRACE_NOTIFY_ROUTINE NotifyRoutine,
    IN BOOLEAN Remove
    )
{
    if(Remove) {
        // we shouldn't be called if the bellow assert fails
        // but since we are and the caller think is legitimate
        // just remove the assert
        //ASSERT(CmpTraceRoutine != NULL);
        CmpTraceRoutine = NULL;
    } else {
        // we shouldn't be called if the bellow assert fails
        // but since we are and the caller think is legitimate
        // just remove the assert
        //ASSERT(CmpTraceRoutine == NULL);
        CmpTraceRoutine = NotifyRoutine;

        //
        // dump active kcbs to WMI
        //
        CmpWmiDumpKcbTable();
    }
    return STATUS_SUCCESS;
}

VOID
CmpWmiDumpKcbTable(
    VOID
)
/*++

Routine Description:

    Sends all kcbs addresses and names from the HashTable to WMI.

Arguments:

    none

Return Value:
    
    none

--*/
{
    ULONG                       i;
    PCM_KEY_HASH                Current;
    PCM_KEY_CONTROL_BLOCK       kcb;
    PUNICODE_STRING             KeyName;
    PCM_TRACE_NOTIFY_ROUTINE    TraceRoutine = CmpTraceRoutine;

    PAGED_CODE();

    if( TraceRoutine == NULL ) {
        return;
    }

    CmpLockRegistry();

    BEGIN_KCB_LOCK_GUARD;    
    CmpLockKCBTreeExclusive();

    for (i=0; i<CmpHashTableSize; i++) {
        Current = CmpCacheTable[i];
        while (Current) {
            kcb = CONTAINING_RECORD(Current, CM_KEY_CONTROL_BLOCK, KeyHash);
            KeyName = CmpConstructName(kcb);
            if(KeyName != NULL) {
                (*TraceRoutine)(STATUS_SUCCESS,
                                kcb, 
                                0, 
                                0,
                                KeyName,
                                EVENT_TRACE_TYPE_REGKCBDMP);
	     
                ExFreePoolWithTag(KeyName, CM_NAME_TAG | PROTECTED_POOL);
            }
            Current = Current->NextHash;
        }
    }

    CmpUnlockKCBTree();
    END_KCB_LOCK_GUARD;    
    
    CmpUnlockRegistry();
}

VOID
CmpWmiDumpKcb(
    PCM_KEY_CONTROL_BLOCK       kcb
)
/*++

Routine Description:

    dumps a single kcb

Arguments:

    none

Return Value:
    
    none

--*/
{
    PCM_TRACE_NOTIFY_ROUTINE    TraceRoutine = CmpTraceRoutine;
    PUNICODE_STRING             KeyName;

    PAGED_CODE();

    if( TraceRoutine == NULL ) {
        return;
    }

    KeyName = CmpConstructName(kcb);
    if(KeyName != NULL) {
        (*TraceRoutine)(STATUS_SUCCESS,
                        kcb, 
                        0, 
                        0,
                        KeyName,
                        EVENT_TRACE_TYPE_REGKCBDMP);
 
        ExFreePoolWithTag(KeyName, CM_NAME_TAG | PROTECTED_POOL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmworker.c ===
//depot/main/Base/ntos/config/cmworker.c#14 - integrate change 19035 (text)
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmworker.c

Abstract:

    This module contains support for the worker thread of the registry.
    The worker thread (actually an executive worker thread is used) is
    required for operations that must take place in the context of the
    system process.  (particularly file I/O)

Author:

    John Vert (jvert) 21-Oct-1992

Revision History:

--*/

#include    "cmp.h"

extern  LIST_ENTRY  CmpHiveListHead;

VOID
CmpInitializeHiveList(
    VOID
    );

//
// ----- LAZY FLUSH CONTROL -----
//
// LAZY_FLUSH_INTERVAL_IN_SECONDS controls how many seconds will elapse
// between when the hive is marked dirty and when the lazy flush worker
// thread is queued to write the data to disk.
//
#define LAZY_FLUSH_INTERVAL_IN_SECONDS  5

//
// LAZY_FLUSH_TIMEOUT_IN_SECONDS controls how long the lazy flush worker
// thread will wait for the registry lock before giving up and queueing
// the lazy flush timer again.
//
#define LAZY_FLUSH_TIMEOUT_IN_SECONDS 1

#define SECOND_MULT 10*1000*1000        // 10->mic, 1000->mil, 1000->second

PKPROCESS   CmpSystemProcess;
KTIMER      CmpLazyFlushTimer;
KDPC        CmpLazyFlushDpc;
WORK_QUEUE_ITEM CmpLazyWorkItem;

BOOLEAN CmpLazyFlushPending = FALSE;
BOOLEAN CmpForceForceFlush = FALSE;
BOOLEAN CmpHoldLazyFlush = TRUE;
BOOLEAN CmpDontGrowLogFile = FALSE;

extern BOOLEAN CmpNoWrite;
extern BOOLEAN CmpWasSetupBoot;
extern BOOLEAN HvShutdownComplete;
extern BOOLEAN CmpProfileLoaded;

//
// Indicate whether the "disk full" popup has been triggered yet or not.
//
extern BOOLEAN CmpDiskFullWorkerPopupDisplayed;

//
// set to true if disk full when trying to save the changes made between system hive loading and registry initalization
//
extern BOOLEAN CmpCannotWriteConfiguration;
extern UNICODE_STRING SystemHiveFullPathName;
extern HIVE_LIST_ENTRY CmpMachineHiveList[];
extern BOOLEAN  CmpTrackHiveClose;

#if DBG
PKTHREAD    CmpCallerThread = NULL;
#endif


#ifdef CMP_STATS

#define KCB_STAT_INTERVAL_IN_SECONDS  120   // 2 min.

extern struct {
    ULONG       CmpMaxKcbNo;
    ULONG       CmpKcbNo;
    ULONG       CmpStatNo;
    ULONG       CmpNtCreateKeyNo;
    ULONG       CmpNtDeleteKeyNo;
    ULONG       CmpNtDeleteValueKeyNo;
    ULONG       CmpNtEnumerateKeyNo;
    ULONG       CmpNtEnumerateValueKeyNo;
    ULONG       CmpNtFlushKeyNo;
    ULONG       CmpNtNotifyChangeMultipleKeysNo;
    ULONG       CmpNtOpenKeyNo;
    ULONG       CmpNtQueryKeyNo;
    ULONG       CmpNtQueryValueKeyNo;
    ULONG       CmpNtQueryMultipleValueKeyNo;
    ULONG       CmpNtRestoreKeyNo;
    ULONG       CmpNtSaveKeyNo;
    ULONG       CmpNtSaveMergedKeysNo;
    ULONG       CmpNtSetValueKeyNo;
    ULONG       CmpNtLoadKeyNo;
    ULONG       CmpNtUnloadKeyNo;
    ULONG       CmpNtSetInformationKeyNo;
    ULONG       CmpNtReplaceKeyNo;
    ULONG       CmpNtQueryOpenSubKeysNo;
} CmpStatsDebug;

KTIMER      CmpKcbStatTimer;
KDPC        CmpKcbStatDpc;
KSPIN_LOCK  CmpKcbStatLock;
BOOLEAN     CmpKcbStatShutdown;

VOID
CmpKcbStatDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

extern ULONG CmpNtFakeCreate;

struct {
    ULONG   BasicInformation;
    UINT64  BasicInformationTimeCounter;
    UINT64  BasicInformationTimeElapsed;

    ULONG   NodeInformation;
    UINT64  NodeInformationTimeCounter;
    UINT64  NodeInformationTimeElapsed;

    ULONG   FullInformation;
    UINT64  FullInformationTimeCounter;
    UINT64  FullInformationTimeElapsed;

    ULONG   EnumerateKeyBasicInformation;
    UINT64  EnumerateKeyBasicInformationTimeCounter;
    UINT64  EnumerateKeyBasicInformationTimeElapsed;

    ULONG   EnumerateKeyNodeInformation;
    UINT64  EnumerateKeyNodeInformationTimeCounter;
    UINT64  EnumerateKeyNodeInformationTimeElapsed;

    ULONG   EnumerateKeyFullInformation;
    UINT64  EnumerateKeyFullInformationTimeCounter;
    UINT64  EnumerateKeyFullInformationTimeElapsed;
} CmpQueryKeyDataDebug = {0};

#endif


VOID
CmpLazyFlushWorker(
    IN PVOID Parameter
    );

VOID
CmpLazyFlushDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
CmpDiskFullWarningWorker(
    IN PVOID WorkItem
    );

VOID
CmpDiskFullWarning(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpLazyFlush)
#pragma alloc_text(PAGE,CmpLazyFlushWorker)
#pragma alloc_text(PAGE,CmpDiskFullWarningWorker)
#pragma alloc_text(PAGE,CmpDiskFullWarning)
#pragma alloc_text(PAGE,CmpCmdHiveClose)
#pragma alloc_text(PAGE,CmpCmdInit)
#pragma alloc_text(PAGE,CmpCmdRenameHive)
#pragma alloc_text(PAGE,CmpCmdHiveOpen)
#pragma alloc_text(PAGE,CmSetLazyFlushState)

#ifndef CMP_STATS
#pragma alloc_text(PAGE,CmpShutdownWorkers)
#endif

#endif

VOID 
CmpCmdHiveClose(
                     PCMHIVE    CmHive
                     )
/*++

Routine Description:

    Closes all the file handles for the specified hive
Arguments:

    CmHive - the hive to close

Return Value:
    none
--*/
{
    ULONG                   i;
    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_BASIC_INFORMATION  BasicInfo;
    LARGE_INTEGER           systemtime;
    BOOLEAN                 oldFlag;

    PAGED_CODE();

    //
    // disable hard error popups, to workaround ObAttachProcessStack 
    //
    oldFlag = IoSetThreadHardErrorMode(FALSE);

    //
    // Close the files associated with this hive.
    //
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    for (i=0; i<HFILE_TYPE_MAX; i++) {
        if (CmHive->FileHandles[i] != NULL) {
            //
            // attempt to set change the last write time (profile guys are relying on it!)
            //
            if( i == HFILE_TYPE_PRIMARY ) {
                if( NT_SUCCESS(ZwQueryInformationFile(
                                        CmHive->FileHandles[i],
                                        &IoStatusBlock,
                                        &BasicInfo,
                                        sizeof(BasicInfo),
                                        FileBasicInformation) ) ) {

                    KeQuerySystemTime(&systemtime);

                    BasicInfo.LastWriteTime  = systemtime;
                    BasicInfo.LastAccessTime = systemtime;

                    ZwSetInformationFile(
                        CmHive->FileHandles[i],
                        &IoStatusBlock,
                        &BasicInfo,
                        sizeof(BasicInfo),
                        FileBasicInformation
                        );
                }

                CmpTrackHiveClose = TRUE;
                CmCloseHandle(CmHive->FileHandles[i]);
                CmpTrackHiveClose = FALSE;
                
            } else {
                CmCloseHandle(CmHive->FileHandles[i]);
            }
            
            CmHive->FileHandles[i] = NULL;
        }
    }
    //
    // restore hard error popups mode
    //
    IoSetThreadHardErrorMode(oldFlag);
}

VOID 
CmpCmdInit(
           BOOLEAN SetupBoot
            )
/*++

Routine Description:

    Initializes cm globals and flushes all hives to the disk.

Arguments:

    SetupBoot - whether the boot is from setup or a regular boot

Return Value:
    none
--*/
{
    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    //
    // Initialize lazy flush timer and DPC
    //
    KeInitializeDpc(&CmpLazyFlushDpc,
                    CmpLazyFlushDpcRoutine,
                    NULL);

    KeInitializeTimer(&CmpLazyFlushTimer);

    ExInitializeWorkItem(&CmpLazyWorkItem, CmpLazyFlushWorker, NULL);

#ifdef CMP_STATS
    KeInitializeDpc(&CmpKcbStatDpc,
                    CmpKcbStatDpcRoutine,
                    NULL);

    KeInitializeTimer(&CmpKcbStatTimer);

    KeInitializeSpinLock(&CmpKcbStatLock);
    CmpKcbStatShutdown = FALSE;
#endif

    CmpNoWrite = CmpMiniNTBoot;

    CmpWasSetupBoot = SetupBoot;
    
    if (SetupBoot == FALSE) {
        CmpInitializeHiveList();
    } 
   
    //
    // Since we are done with initialization, 
    // disable the hive sharing
    // 
    if (CmpMiniNTBoot && CmpShareSystemHives) {
        CmpShareSystemHives = FALSE;
    }    
    
#ifdef CMP_STATS
    CmpKcbStat();
#endif
}


NTSTATUS 
CmpCmdRenameHive(
            PCMHIVE                     CmHive,
            POBJECT_NAME_INFORMATION    OldName,
            PUNICODE_STRING             NewName,
            ULONG                       NameInfoLength
            )
/*++

Routine Description:

    rename a cmhive's primary handle

    replaces old REG_CMD_RENAME_HIVE worker case

Arguments:

    CmHive - hive to rename
    
    OldName - old name information

    NewName - the new name for the file

    NameInfoLength - sizeof name information structure

Return Value:

    <TBD>
--*/
{
    NTSTATUS                    Status;
    HANDLE                      Handle;
    PFILE_RENAME_INFORMATION    RenameInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    //
    // Rename a CmHive's primary handle
    //
    Handle = CmHive->FileHandles[HFILE_TYPE_PRIMARY];
    if (OldName != NULL) {
        ASSERT_PASSIVE_LEVEL();
        Status = ZwQueryObject(Handle,
                               ObjectNameInformation,
                               OldName,
                               NameInfoLength,
                               &NameInfoLength);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    RenameInfo = ExAllocatePool(PagedPool,
                                sizeof(FILE_RENAME_INFORMATION) + NewName->Length);
    if (RenameInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RenameInfo->ReplaceIfExists = FALSE;
    RenameInfo->RootDirectory = NULL;
    RenameInfo->FileNameLength = NewName->Length;
    RtlCopyMemory(RenameInfo->FileName,
                  NewName->Buffer,
                  NewName->Length);

    Status = ZwSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  (PVOID)RenameInfo,
                                  sizeof(FILE_RENAME_INFORMATION) +
                                  NewName->Length,
                                  FileRenameInformation);
    ExFreePool(RenameInfo);

    return Status;
}

NTSTATUS 
CmpCmdHiveOpen(
            POBJECT_ATTRIBUTES          FileAttributes,
            PSECURITY_CLIENT_CONTEXT    ImpersonationContext,
            PBOOLEAN                    Allocate,
            PBOOLEAN                    RegistryLockAquired,    // needed to avoid recursivity deadlock with ZwCreate calls calling back into registry
            PCMHIVE                     *NewHive,
		    ULONG						CheckFlags
            )
/*++

Routine Description:


    replaces old REG_CMD_HIVE_OPEN worker case

Arguments:


Return Value:

    <TBD>
--*/
{
    PUNICODE_STRING FileName;
    NTSTATUS        Status;
    HANDLE          NullHandle;

    PAGED_CODE();

    //
    // Open the file.
    //
    FileName = FileAttributes->ObjectName;

    Status = CmpInitHiveFromFile(FileName,
                                 0,
                                 NewHive,
                                 Allocate,
                                 RegistryLockAquired,
								 CheckFlags);
    //
    // NT Servers will return STATUS_ACCESS_DENIED. Netware 3.1x
    // servers could return any of the other error codes if the GUEST
    // account is disabled.
    //
    if (((Status == STATUS_ACCESS_DENIED) ||
         (Status == STATUS_NO_SUCH_USER) ||
         (Status == STATUS_WRONG_PASSWORD) ||
         (Status == STATUS_ACCOUNT_EXPIRED) ||
         (Status == STATUS_ACCOUNT_DISABLED) ||
         (Status == STATUS_ACCOUNT_RESTRICTION)) &&
        (ImpersonationContext != NULL)) {
        //
        // Impersonate the caller and try it again.  This
        // lets us open hives on a remote machine.
        //
        Status = SeImpersonateClientEx(
                        ImpersonationContext,
                        NULL);

        if ( NT_SUCCESS( Status ) ) {

            Status = CmpInitHiveFromFile(FileName,
                                         0,
                                         NewHive,
                                         Allocate,
                                         RegistryLockAquired,
										 CheckFlags);
            NullHandle = NULL;

            PsRevertToSelf();
        }
    }
    
    return Status;
}


VOID
CmpLazyFlush(
    VOID
    )

/*++

Routine Description:

    This routine resets the registry timer to go off at a specified interval
    in the future (LAZY_FLUSH_INTERVAL_IN_SECONDS).

Arguments:

    None

Return Value:

    None.

--*/

{
    LARGE_INTEGER DueTime;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpLazyFlush: setting lazy flush timer\n"));
    if ((!CmpNoWrite) && (!CmpHoldLazyFlush)) {

        DueTime.QuadPart = Int32x32To64(LAZY_FLUSH_INTERVAL_IN_SECONDS,
                                        - SECOND_MULT);

        //
        // Indicate relative time
        //

        KeSetTimer(&CmpLazyFlushTimer,
                   DueTime,
                   &CmpLazyFlushDpc);

    }


}


VOID
CmpLazyFlushDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the DPC routine triggered by the lazy flush timer.  All it does
    is queue a work item to an executive worker thread.  The work item will
    do the actual lazy flush to disk.

Arguments:

    Dpc - Supplies a pointer to the DPC object.

    DeferredContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpLazyFlushDpc: queuing lazy flush work item\n"));

    if ((!CmpLazyFlushPending) && (!CmpHoldLazyFlush)) {
        CmpLazyFlushPending = TRUE;
        ExQueueWorkItem(&CmpLazyWorkItem, DelayedWorkQueue);
    }

}


VOID
CmpLazyFlushWorker(
    IN PVOID Parameter
    )

/*++

Routine Description:

    Worker routine called to do a lazy flush.  Called by an executive worker
    thread in the system process.  

Arguments:

    Parameter - not used.

Return Value:

    None.

--*/

{
    BOOLEAN Result = TRUE;
    BOOLEAN ForceFlush;

    PAGED_CODE();

    if( CmpHoldLazyFlush ) {
        //
        // lazy flush mode is disabled
        //
        return;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpLazyFlushWorker: flushing hives\n"));

    ForceFlush = CmpForceForceFlush;
    if(ForceFlush == TRUE) {
        //
        // something bad happened and we may need to fix hive's use count
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpLazyFlushWorker: Force Flush - getting the reglock exclusive\n"));
        CmpLockRegistryExclusive();
    } else {
        CmpLockRegistry();
        ENTER_FLUSH_MODE();
    }
    if (!HvShutdownComplete) {
        //
        // this call will set CmpForceForceFlush to the right value
        //
        Result = CmpDoFlushAll(ForceFlush);
    } else {
        CmpForceForceFlush = FALSE;
    }

    if( ForceFlush == FALSE ) {
        EXIT_FLUSH_MODE();
    }

    CmpLazyFlushPending = FALSE;
    CmpUnlockRegistry();

    if( CmpCannotWriteConfiguration ) {
        //
        // Disk full; system hive has not been saved at initialization
        //
        if(Result) {
            //
            // All hives were saved; No need for disk full warning anymore
            //
            CmpCannotWriteConfiguration = FALSE;
        } else {
            //
            // Issue another hard error (if not already displayed) and postpone a lazy flush operation
            //
            CmpDiskFullWarning();
            CmpLazyFlush();
        }
    }
}

VOID
CmpDiskFullWarningWorker(
    IN PVOID WorkItem
    )

/*++

Routine Description:

    Displays hard error popup that indicates the disk is full.

Arguments:

    WorkItem - Supplies pointer to the work item. This routine will
               free the work item.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG Response;

    ExFreePool(WorkItem);

    Status = ExRaiseHardError(STATUS_DISK_FULL,
                              0,
                              0,
                              NULL,
                              OptionOk,
                              &Response);
}



VOID
CmpDiskFullWarning(
    VOID
    )
/*++

Routine Description:

    Raises a hard error of type STATUS_DISK_FULL if wasn't already raised

Arguments:

    None

Return Value:

    None

--*/
{
    PWORK_QUEUE_ITEM WorkItem;

    if( (!CmpDiskFullWorkerPopupDisplayed) && (CmpCannotWriteConfiguration) && (ExReadyForErrors) && (CmpProfileLoaded) ) {

        //
        // Queue work item to display popup
        //
        WorkItem = ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if (WorkItem != NULL) {

            CmpDiskFullWorkerPopupDisplayed = TRUE;
            ExInitializeWorkItem(WorkItem,
                                 CmpDiskFullWarningWorker,
                                 WorkItem);
            ExQueueWorkItem(WorkItem, DelayedWorkQueue);
        }
    }
}

VOID
CmpShutdownWorkers(
    VOID
    )
/*++

Routine Description:

    Shuts down the lazy flush worker (by killing the timer)

Arguments:

    None

Return Value:

    None

--*/
{
    PAGED_CODE();

    KeCancelTimer(&CmpLazyFlushTimer);

#ifdef CMP_STATS
    {
        KIRQL OldIrql;
        
        KeAcquireSpinLock(&CmpKcbStatLock, &OldIrql);
        CmpKcbStatShutdown = TRUE;
        KeCancelTimer(&CmpKcbStatTimer);
        KeReleaseSpinLock(&CmpKcbStatLock, OldIrql);
    }
#endif
}

VOID
CmSetLazyFlushState(BOOLEAN Enable)
/*++

Routine Description:
    
    Enables/Disables the lazy flusher; Designed for the standby/resume case, where 
    we we don't want the lazy flush to fire off, blocking registry writers until the 
    disk wakes up.

Arguments:

    Enable - TRUE = enable; FALSE = disable

Return Value:

    None.

--*/
{
    PAGED_CODE();

    CmpDontGrowLogFile = CmpHoldLazyFlush = !Enable;
}


#ifdef CMP_STATS

VOID
CmpKcbStat(
    VOID
    )

/*++

Routine Description:

    This routine resets the KcbStat timer to go off at a specified interval
    in the future 

Arguments:

    None

Return Value:

    None.

--*/

{
    LARGE_INTEGER DueTime;
    KIRQL OldIrql;

    DueTime.QuadPart = Int32x32To64(KCB_STAT_INTERVAL_IN_SECONDS,
                                    - SECOND_MULT);

    //
    // Indicate relative time
    //

    KeAcquireSpinLock(&CmpKcbStatLock, &OldIrql);
    if (! CmpKcbStatShutdown) {
        KeSetTimer(&CmpKcbStatTimer,
                   DueTime,
                   &CmpKcbStatDpc);
    }
    KeReleaseSpinLock(&CmpKcbStatLock, OldIrql);
}

VOID
CmpKcbStatDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    Dumps the kcb stats in the debugger and then reschedules another 
    Dpc in the future

Arguments:

    Dpc - Supplies a pointer to the DPC object.

    DeferredContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{
#ifndef _CM_LDR_
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"\n*********************************************************************\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  Stat No %8lu KcbNo = %8lu [MaxKcbNo = %8lu]          *\n",++CmpStatsDebug.CmpStatNo,CmpStatsDebug.CmpKcbNo,CmpStatsDebug.CmpMaxKcbNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*********************************************************************\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*                                                                   *\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  [Nt]API               [No. Of]Calls                              *\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*-------------------------------------------------------------------*\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtCreateKey              %8lu      Opens = %8lu          *\n",CmpStatsDebug.CmpNtCreateKeyNo,CmpNtFakeCreate);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtOpenKey                %8lu                                *\n",CmpStatsDebug.CmpNtOpenKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtEnumerateKey           %8lu                                *\n",CmpStatsDebug.CmpNtEnumerateKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtQueryKey               %8lu                                *\n",CmpStatsDebug.CmpNtQueryKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtDeleteKey              %8lu                                *\n",CmpStatsDebug.CmpNtDeleteKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtSetInformationKey      %8lu                                *\n",CmpStatsDebug.CmpNtSetInformationKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*-------------------------------------------------------------------*\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtSetValueKey            %8lu                                *\n",CmpStatsDebug.CmpNtSetValueKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtEnumerateValueKey      %8lu                                *\n",CmpStatsDebug.CmpNtEnumerateValueKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtQueryValueKey          %8lu                                *\n",CmpStatsDebug.CmpNtQueryValueKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtQueryMultipleValueKey  %8lu                                *\n",CmpStatsDebug.CmpNtQueryMultipleValueKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtDeleteValueKey         %8lu                                *\n",CmpStatsDebug.CmpNtDeleteValueKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*-------------------------------------------------------------------*\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtFlushKey               %8lu                                *\n",CmpStatsDebug.CmpNtFlushKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtLoadKey                %8lu                                *\n",CmpStatsDebug.CmpNtLoadKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtUnloadKey              %8lu                                *\n",CmpStatsDebug.CmpNtUnloadKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtSaveKey                %8lu                                *\n",CmpStatsDebug.CmpNtSaveKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtSaveMergedKeys         %8lu                                *\n",CmpStatsDebug.CmpNtSaveMergedKeysNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtRestoreKey             %8lu                                *\n",CmpStatsDebug.CmpNtRestoreKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtReplaceKey             %8lu                                *\n",CmpStatsDebug.CmpNtReplaceKeyNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*-------------------------------------------------------------------*\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtNotifyChgMultplKeys    %8lu                                *\n",CmpStatsDebug.CmpNtNotifyChangeMultipleKeysNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtQueryOpenSubKeys       %8lu                                *\n",CmpStatsDebug.CmpNtQueryOpenSubKeysNo);
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*-------------------------------------------------------------------*\n");
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*                                    [No.Of]Calls     [Time]        *\n");
    
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*-------------------------------------------------------------------*\n");

    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtQueryKey(KeyBasicInformation)     %8lu    %8lu         *\n",
        CmpQueryKeyDataDebug.BasicInformation,
        (ULONG)(CmpQueryKeyDataDebug.BasicInformationTimeCounter?CmpQueryKeyDataDebug.BasicInformationTimeElapsed/CmpQueryKeyDataDebug.BasicInformationTimeCounter:0));
    CmpQueryKeyDataDebug.BasicInformationTimeCounter = 0;
    CmpQueryKeyDataDebug.BasicInformationTimeElapsed = 0;

    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtQueryKey(KeyNodeInformation )     %8lu    %8lu         *\n",
        CmpQueryKeyDataDebug.NodeInformation,
        (ULONG)(CmpQueryKeyDataDebug.NodeInformationTimeCounter?CmpQueryKeyDataDebug.NodeInformationTimeElapsed/CmpQueryKeyDataDebug.NodeInformationTimeCounter:0));
    CmpQueryKeyDataDebug.NodeInformationTimeCounter = 0;
    CmpQueryKeyDataDebug.NodeInformationTimeElapsed = 0;

    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtQueryKey(KeyFullInformation )     %8lu    %8lu         *\n",
        CmpQueryKeyDataDebug.FullInformation,
        (ULONG)(CmpQueryKeyDataDebug.FullInformationTimeCounter?CmpQueryKeyDataDebug.FullInformationTimeElapsed/CmpQueryKeyDataDebug.FullInformationTimeCounter:0));
    CmpQueryKeyDataDebug.FullInformationTimeCounter = 0;
    CmpQueryKeyDataDebug.FullInformationTimeElapsed = 0;

    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtEnumerateKey(KeyBasicInformation) %8lu    %8lu         *\n",
        CmpQueryKeyDataDebug.EnumerateKeyBasicInformation,
        (ULONG)(CmpQueryKeyDataDebug.EnumerateKeyBasicInformationTimeCounter?CmpQueryKeyDataDebug.EnumerateKeyBasicInformationTimeElapsed/CmpQueryKeyDataDebug.EnumerateKeyBasicInformationTimeCounter:0));
    CmpQueryKeyDataDebug.EnumerateKeyBasicInformationTimeCounter = 0;
    CmpQueryKeyDataDebug.EnumerateKeyBasicInformationTimeElapsed = 0;

    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtEnumerateKey(KeyNodeInformation ) %8lu    %8lu         *\n",
        CmpQueryKeyDataDebug.EnumerateKeyNodeInformation,
        (ULONG)(CmpQueryKeyDataDebug.EnumerateKeyNodeInformationTimeCounter?CmpQueryKeyDataDebug.EnumerateKeyNodeInformationTimeElapsed/CmpQueryKeyDataDebug.EnumerateKeyNodeInformationTimeCounter:0));
    CmpQueryKeyDataDebug.EnumerateKeyNodeInformationTimeCounter = 0;
    CmpQueryKeyDataDebug.EnumerateKeyNodeInformationTimeElapsed = 0;

    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*  NtEnumerateKey(KeyFullInformation ) %8lu    %8lu         *\n",
        CmpQueryKeyDataDebug.EnumerateKeyFullInformation,
        (ULONG)(CmpQueryKeyDataDebug.EnumerateKeyFullInformationTimeCounter?CmpQueryKeyDataDebug.EnumerateKeyFullInformationTimeElapsed/CmpQueryKeyDataDebug.EnumerateKeyFullInformationTimeCounter:0));
    CmpQueryKeyDataDebug.EnumerateKeyFullInformationTimeCounter = 0;
    CmpQueryKeyDataDebug.EnumerateKeyFullInformationTimeElapsed = 0;
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,  "*********************************************************************\n\n");

    //
    // reschedule
    //
#endif //_CM_LDR_
    CmpKcbStat();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hive.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hive.h

Abstract:

    This module contains the private (internal) header file for the
    direct memory loaded hive manager.

Author:

    Bryan M. Willman (bryanwi) 28-May-91

Environment:

Revision History:

    26-Mar-92 bryanwi - changed to type 1.0 hive format

    13-Jan-99 Dragos C. Sambotin (dragoss) - factoring the data structure declarations
        in \nt\private\ntos\inc\hivedata.h :: to be available from outside.


--*/

#ifndef _HIVE_
#define _HIVE_

// Hive data structure declarations
// file location: \nt\private\ntos\inc
#include "hivedata.h"

#if DBG

extern ULONG HvHiveChecking;

#define DHvCheckHive(a) if(HvHiveChecking) ASSERT(HvCheckHive(a,NULL) == 0)
#define DHvCheckBin(h,a)  if(HvHiveChecking) ASSERT(HvCheckBin(h,a,NULL) == 0)

#else
#define DHvCheckHive(a)
#define DHvCheckBin(h,a)
#endif

#define ROUND_UP(a, b)  \
    ( ((ULONG)(a) + (ULONG)(b) - 1) & ~((ULONG)(b) - 1) )


//
// tombstone for an HBIN that is not resident in memory.  This list is searched
// before any new HBIN is added.
//

#define ASSERT_LISTENTRY(ListEntry) \
    ASSERT((ListEntry)->Flink->Blink==ListEntry); \
    ASSERT((ListEntry)->Blink->Flink==ListEntry);

//
// ===== Hive Private Procedure Prototypes =====
//
PHBIN
HvpAddBin(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type
    );

PHMAP_ENTRY
HvpGetCellMap(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
HvpFreeMap(
    PHHIVE          Hive,
    PHMAP_DIRECTORY Dir,
    ULONG           Start,
    ULONG           End
    );

BOOLEAN
HvpAllocateMap(
    PHHIVE          Hive,
    PHMAP_DIRECTORY Dir,
    ULONG           Start,
    ULONG           End
    );

BOOLEAN
HvpGrowLog1(
    PHHIVE  Hive,
    ULONG   Count
    );

BOOLEAN
HvpGrowLog2(
    PHHIVE  Hive,
    ULONG   Size
    );

ULONG
HvpHeaderCheckSum(
    PHBASE_BLOCK    BaseBlock
    );

NTSTATUS
HvpBuildMap(
    PHHIVE  Hive,
    PVOID   Image
    );

NTSTATUS
HvpBuildMapAndCopy(
    PHHIVE  Hive,
    PVOID   Image
    );

NTSTATUS
HvpInitMap(
    PHHIVE  Hive
    );

VOID
HvpCleanMap(
    PHHIVE  Hive
    );

NTSTATUS
HvpEnlistBinInMap(
    PHHIVE  Hive,
    ULONG   Length,
    PHBIN   Bin,
    ULONG   Offset,
    PVOID CmView OPTIONAL
    );

VOID
HvpFreeAllocatedBins(
    PHHIVE Hive
    );

BOOLEAN
HvpDoWriteHive(
    PHHIVE          Hive,
    ULONG           FileType
    );

struct _CELL_DATA *
HvpGetCellFlat(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

struct _CELL_DATA *
HvpGetCellPaged(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

struct _CELL_DATA *
HvpGetCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
HvpReleaseCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
HvpEnlistFreeCell(
    PHHIVE  Hive,
    HCELL_INDEX Cell,
    ULONG      Size,
    HSTORAGE_TYPE   Type,
    BOOLEAN CoalesceForward
    );

BOOLEAN
HvpEnlistFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    ULONG   BinOffset
    );


VOID
HvpDelistFreeCell(
    PHHIVE  Hive,
    HCELL_INDEX  Cell,
    HSTORAGE_TYPE Type
    );

//
// ===== Hive Public Procedure Prototypes =====
//
#define HINIT_CREATE            0
#define HINIT_MEMORY            1
#define HINIT_FILE              2
#define HINIT_MEMORY_INPLACE    3
#define HINIT_FLAT              4
#define HINIT_MAPFILE           5

#define HIVE_VOLATILE           1
#define HIVE_NOLAZYFLUSH        2
#define HIVE_HAS_BEEN_REPLACED  4

NTSTATUS
HvInitializeHive(
    PHHIVE                  Hive,
    ULONG                   OperationType,
    ULONG                   HiveFlags,
    ULONG                   FileTypes,
    PVOID                   HiveData OPTIONAL,
    PALLOCATE_ROUTINE       AllocateRoutine,
    PFREE_ROUTINE           FreeRoutine,
    PFILE_SET_SIZE_ROUTINE  FileSetSizeRoutine,
    PFILE_WRITE_ROUTINE     FileWriteRoutine,
    PFILE_READ_ROUTINE      FileReadRoutine,
    PFILE_FLUSH_ROUTINE     FileFlushRoutine,
    ULONG                   Cluster,
    PUNICODE_STRING         FileName
    );

BOOLEAN
HvSyncHive(
    PHHIVE  Hive
    );

NTSTATUS
HvWriteHive(
    PHHIVE  Hive,
	BOOLEAN	DontGrow,
	BOOLEAN	WriteThroughCache,
    BOOLEAN CrashSafe
    );

NTSTATUS
HvLoadHive(
    PHHIVE  Hive
    );

NTSTATUS
HvMapHive(
    PHHIVE  Hive
    );

VOID
HvRefreshHive(
    PHHIVE  Hive
    );

NTSTATUS
HvReadInMemoryHive(
    PHHIVE  Hive,
    PVOID   *HiveImage
    );

ULONG
HvCheckHive(
    PHHIVE  Hive,
    PULONG  Storage OPTIONAL
    );

ULONG
HvCheckBin(
    PHHIVE  Hive,
    PHBIN   Bin,
    PULONG  Storage
    );

ULONG 
HvpGetBinMemAlloc(
                IN PHHIVE           Hive,
                PHBIN               Bin,
                IN HSTORAGE_TYPE    Type
                );

BOOLEAN
HvMarkCellDirty(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

#if DBG
BOOLEAN
HvIsCellDirty(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    );

#ifndef _CM_LDR_
#define ASSERT_CELL_DIRTY(_Hive_,_Cell_) ASSERT(HvIsCellDirty(_Hive_,_Cell_) == TRUE)
#else
#define ASSERT_CELL_DIRTY(_Hive_,_Cell_) // nothing
#endif //_CM_LDR_

#else
#define ASSERT_CELL_DIRTY(_Hive_,_Cell_) // nothing
#endif //DBG

BOOLEAN
HvMarkDirty(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    ULONG       Length,
    BOOLEAN     DirtyAndPin
    );

/*
!!!not used anymore!!!
BOOLEAN
HvMarkClean(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    ULONG       Length
    );
*/
//
// IMPORTANT:
//      Every call to HvGetCell should be matched with a call to HvReleaseCell;
//      HvReleaseCell is only valid for mapped hives.
//
#define HvGetCell(Hive, Cell)       (((Hive)->GetCellRoutine)(Hive, Cell))
#define HvReleaseCell(Hive, Cell)   if((Hive)->ReleaseCellRoutine) ((Hive)->ReleaseCellRoutine)(Hive, Cell)

PHCELL
HvpGetHCell(PHHIVE      Hive,
            HCELL_INDEX Cell
            );

LONG
HvGetCellSize(
    PHHIVE      Hive,
    PVOID       Address
    );

HCELL_INDEX
HvAllocateCell(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    );

VOID
HvFreeCell(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

HCELL_INDEX
HvReallocateCell(
    PHHIVE      Hive,
    HCELL_INDEX Cell,
    ULONG       NewSize
    );

BOOLEAN
HvIsCellAllocated(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
HvFreeHive(
    PHHIVE Hive
    );

VOID
HvFreeHivePartial(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    HSTORAGE_TYPE Type
    );

// Dragos : From here start the changes.

#define CmpFindFirstSetRight KiFindFirstSetRight
extern const CCHAR KiFindFirstSetRight[256];
#define CmpFindFirstSetLeft KiFindFirstSetLeft
extern const CCHAR KiFindFirstSetLeft[256];

#define HvpComputeIndex(Index, Size)                                    \
    {                                                                   \
        Index = (Size >> HHIVE_FREE_DISPLAY_SHIFT) - 1;                 \
        if (Index >= HHIVE_LINEAR_INDEX ) {                             \
                                                                        \
            /*                                                          \
            ** Too big for the linear lists, compute the exponential    \
            ** list. Shitft the index to make sure we cover the whole   \
            ** range.                                                   \
            */                                                          \
            Index >>= 4;                                                \
                                                                        \
            if (Index > 255) {                                          \
                /*                                                      \
                ** Too big for all the lists, use the last index.       \
                */                                                      \
                Index = HHIVE_FREE_DISPLAY_SIZE-1;                      \
            } else {                                                    \
                Index = CmpFindFirstSetLeft[Index] +                    \
                        HHIVE_LINEAR_INDEX;                             \
            }                                                           \
        }                                                               \
    }

VOID
HvpFreeHiveFreeDisplay(
    IN PHHIVE           Hive
    );

NTSTATUS
HvpAdjustHiveFreeDisplay(
    IN PHHIVE           Hive,
    IN ULONG            HiveLength,
    IN HSTORAGE_TYPE    Type
    );

VOID
HvpAddFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    );

VOID
HvpRemoveFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    );

HCELL_INDEX
HvpFindFreeCell(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    );

BOOLEAN
HvpCheckViewBoundary(
                     IN ULONG Start,
                     IN ULONG End
    );

VOID
HvpDropPagedBins(
    PHHIVE  Hive
#if DBG
    ,
    IN BOOLEAN  Check
#endif
    );

VOID
HvpDropAllPagedBins(
    IN PHHIVE   Hive
    );

BOOLEAN
HvpWriteLog(
    PHHIVE          Hive
    );


BOOLEAN
HvHiveWillShrink(
                    IN PHHIVE Hive
                    );

BOOLEAN HvAutoCompressCheck(PHHIVE Hive);

NTSTATUS
HvCloneHive(PHHIVE  SourceHive,
            PHHIVE  DestHive,
            PULONG  NewLength
            );

NTSTATUS 
HvShrinkHive(PHHIVE  Hive,
             ULONG   NewLength
            );

HCELL_INDEX
HvShiftCell(PHHIVE Hive,HCELL_INDEX Cell);

#ifdef NT_RENAME_KEY
HCELL_INDEX
HvDuplicateCell(    
                    PHHIVE          Hive,
                    HCELL_INDEX     Cell,
                    HSTORAGE_TYPE   Type,
                    BOOLEAN         CopyData
                );

#endif

#ifdef CM_ENABLE_WRITE_ONLY_BINS
VOID HvpMarkAllBinsWriteOnly(IN PHHIVE Hive);
#endif //CM_ENABLE_WRITE_ONLY_BINS

#endif // _HIVE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmvalue.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cmvalue.c

Abstract:

    This module contains cm routines for operating on (sorted) 
    value list. Insertion, Deletion,Searching  ...

    Routines to deal with a KeyValue data; whether it is small,
    big - new hives format - , or normal

Author:

    Dragos C. Sambotin (dragoss) 12-Aug-1999

Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpFindValueByName)
#pragma alloc_text(PAGE,CmpFindNameInList)
#pragma alloc_text(PAGE,CmpAddValueToList)
#pragma alloc_text(PAGE,CmpRemoveValueFromList)
#pragma alloc_text(PAGE,CmpGetValueData)
#pragma alloc_text(PAGE,CmpMarkValueDataDirty)
#pragma alloc_text(PAGE,CmpFreeValue)
#pragma alloc_text(PAGE,CmpSetValueDataNew)
#pragma alloc_text(PAGE,CmpSetValueDataExisting)
#pragma alloc_text(PAGE,CmpFreeValueData)
#pragma alloc_text(PAGE,CmpValueToData)
#endif

HCELL_INDEX
CmpFindValueByName(
    PHHIVE Hive,
    PCM_KEY_NODE KeyNode,
    PUNICODE_STRING Name
    )
/*++

Routine Description:

    Underlying CmpFindNameInList was changed to return an error code;
    Had to make it a function instead of a macro

Arguments:

    Hive - pointer to hive control structure for hive of interest


Return Value:


  HCELL_INDEX or HCELL_NIL on error
--*/
{                                                                                   
    HCELL_INDEX CellIndex;                                                          

#ifndef _CM_LDR_
    PAGED_CODE();
#endif //_CM_LDR_
    
    if( CmpFindNameInList(Hive,&((KeyNode)->ValueList),Name,NULL,&CellIndex) == FALSE ) {  
        //
        // above should set this right
        //
        ASSERT( CellIndex == HCELL_NIL );
    }                                                                               
    return CellIndex;
}

BOOLEAN
CmpFindNameInList(
    IN PHHIVE  Hive,
    IN PCHILD_LIST ChildList,
    IN PUNICODE_STRING Name,
    IN OPTIONAL PULONG ChildIndex,
    OUT PHCELL_INDEX    CellIndex
    )
/*++

Routine Description:

    Find a child object in an object list. Child List must be sorted
    based on the name. (for new hives format)

Arguments:

    Hive - pointer to hive control structure for hive of interest

    List - pointer to mapped in list structure

    Count - number of elements in list structure

    Name - name of child object to find

    ChildIndex - pointer to variable to receive index for child; 

    CellIndex - pointer to receive the index of the child.
                On return, this is:
                    HCELL_INDEX for the found cell
                    HCELL_NIL if not found


Return Value:

    TRUE - success
    FALSE - error, insufficient resources

Notes:
    
    ChildIndex is always filled with the position where Name should be in the list.
    The difference whether Name is in the list or not is made upon CellIndex
        - CellIndex == HCELL_NIL ==> Name not found in the list
        - CellIndex <> HCELL_NIL ==> Name already exists in the list

--*/
{
    NTSTATUS        status;
    PCM_KEY_VALUE   pchild;
    UNICODE_STRING  Candidate;
    LONG            Result;
    PCELL_DATA      List = NULL;
    ULONG           Current;
    HCELL_INDEX     CellToRelease = HCELL_NIL;
    BOOLEAN         ReturnValue = FALSE;

#ifndef _CM_LDR_
    PAGED_CODE();
#endif //_CM_LDR_
    
    if (ChildList->Count != 0) {
        List = (PCELL_DATA)HvGetCell(Hive,ChildList->List);
        if( List == NULL ) {
            //
            // we could not map the view containing the cell
            //
            *CellIndex = HCELL_NIL;
            return FALSE;
        }

        //
        // old plain hive; simulate a for
        //
        Current = 0;
    
        while( TRUE ) {

            if( CellToRelease != HCELL_NIL ) {
                HvReleaseCell(Hive,CellToRelease);
                CellToRelease = HCELL_NIL;
            }
            pchild = (PCM_KEY_VALUE)HvGetCell(Hive, List->u.KeyList[Current]);
            if( pchild == NULL ) {
                //
                // we could not map the view containing the cell
                //
                *CellIndex = HCELL_NIL;
                ReturnValue = FALSE;
                goto JustReturn;
            }
            CellToRelease = List->u.KeyList[Current];

            if (pchild->Flags & VALUE_COMP_NAME) {
                Result = CmpCompareCompressedName(Name,
                                                   pchild->Name,
                                                   pchild->NameLength,
                                                   0);
            } else {
                Candidate.Length = pchild->NameLength;
                Candidate.MaximumLength = Candidate.Length;
                Candidate.Buffer = pchild->Name;
                Result = RtlCompareUnicodeString(Name,
                                                   &Candidate,
                                                   TRUE);
            }

            if (Result == 0) {
                //
                // Success, return data to caller and exit
                //

                if (ARGUMENT_PRESENT(ChildIndex)) {
                    *ChildIndex = Current;
                }
                *CellIndex = List->u.KeyList[Current];
                ReturnValue = TRUE;
                goto JustReturn;
            }
            //
            // compute the next index to try: old'n plain hive; go on
			//
            Current++;
            if( Current == ChildList->Count ) {
                //
                // we've reached the end of the list
                //
                if (ARGUMENT_PRESENT(ChildIndex)) {
                    *ChildIndex = Current;
                }
                //
                // nicely return
                //
                *CellIndex = HCELL_NIL;
                ReturnValue = TRUE;
                goto JustReturn;
            }
        }
    }
    //
    // in the new design we shouldn't get here; we should exit the while loop with return
    //
    ASSERT( ChildList->Count == 0 );    
    // add it first; as it's the only one
    if (ARGUMENT_PRESENT(ChildIndex)) {
        *ChildIndex = 0;
    }
    *CellIndex = HCELL_NIL;
    return TRUE;

JustReturn:
    if( List != NULL ) {
        HvReleaseCell(Hive,ChildList->List);
    }
    if( CellToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive,CellToRelease);
    }
    return ReturnValue;

}

BOOLEAN
CmpGetValueData(IN PHHIVE Hive,
                IN PCM_KEY_VALUE Value,
                OUT PULONG realsize,
                IN OUT PVOID *Buffer, 
                OUT PBOOLEAN Allocated,
                OUT PHCELL_INDEX CellToRelease
               )
/*++

Routine Description:

    Retrieves the real valueData, given the key value.
    

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Value - CM_KEY_VALUE to retrieve the data for.

    realsize - the actual size of the data (in bytes)

    Buffer - pointer to the data; if the cell is a BIG_CELL
            we should allocate a buffer 

    Allocated - here we signal the caller that he has to free the 
            buffer on return;
            TRUE - a new buffer was allocated to gather together the BIG_CELL data
            FALSE - Buffer points directly in the hive, the caller shouldn't free it

    CellToRelease - Cell to release after finishing work with Buffer

Return Value:

    TRUE - success

    FALSE - not enough resources available; (to map a cell or to allocate the buffer)

Notes:
    
    The caller is responsible to remove the buffer, when Allocated is set on TRUE on return;

--*/
{
   
#ifndef _CM_LDR_
    PAGED_CODE();
#endif //_CM_LDR_

    ASSERT_KEY_VALUE(Value);
    //
    // normally we don't allocate buffer
    //
    *Allocated = FALSE;
    *Buffer = NULL;
    *CellToRelease = HCELL_NIL;

    //
    // check for small values
    //
    if( CmpIsHKeyValueSmall(*realsize, Value->DataLength) == TRUE ) {
        //
        // data is stored inside the cell
        //
        *Buffer = &Value->Data;
        return TRUE;
    }

#ifndef _CM_LDR_
    //
    // check for big values
    //
    if( CmpIsHKeyValueBig(Hive,*realsize) == TRUE ) {
        //
        //
        //
        PCM_BIG_DATA    BigData = NULL;
        PUCHAR          WorkBuffer;
        ULONG           Length;
        USHORT          i;
        PUCHAR          PartialData;
        PHCELL_INDEX    Plist = NULL;
        
#ifndef _CM_LDR_
        try {
#endif //_CM_LDR_
            BigData = (PCM_BIG_DATA)HvGetCell(Hive,Value->Data);
            if( BigData == NULL ) {
                //
                // cannot map view containing the cell; bail out
                //
                return FALSE;
            }

            ASSERT_BIG_DATA(BigData);

            Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
            if( Plist == NULL ) {
                //
                // cannot map view containing the cell; bail out
                //
                return FALSE;
            }

            Length = Value->DataLength;
            //
            // sanity check
            //
            ASSERT( Length <= (ULONG)(BigData->Count * CM_KEY_VALUE_BIG) );

            //
            // allocate a buffer to merge bring all the pieces together
            //
            WorkBuffer = (PUCHAR)ExAllocatePoolWithTag(PagedPool, Length, CM_POOL_TAG);
            if( WorkBuffer == NULL ){
                return FALSE;
            }
        
            for(i=0;i<BigData->Count;i++) {
                //
                // sanity check
                //
                ASSERT( Length > 0 );

                PartialData = (PUCHAR)HvGetCell(Hive,Plist[i]);
                if( PartialData == NULL ){
                    //
                    // cannot map view containing the cell; bail out
                    //
                    ExFreePool(WorkBuffer);
                    return FALSE;
                }
            
                //
                // copy this piece of data to the work buffer
                //
                RtlCopyMemory(WorkBuffer + CM_KEY_VALUE_BIG*i,PartialData,(Length>CM_KEY_VALUE_BIG)?CM_KEY_VALUE_BIG:Length);
                HvReleaseCell(Hive,Plist[i]);

                //
                // adjust the data still to copy.
                // All cells in Plist should be of size CM_KEY_VALUE_BIG, except the last one, which is the remaining
                //
                Length -= CM_KEY_VALUE_BIG;
            }
#ifndef _CM_LDR_
        } finally {
            if( BigData != NULL ) {
                HvReleaseCell(Hive,Value->Data);
                if( Plist != NULL ) {
                    HvReleaseCell(Hive,BigData->List);
                }
            }
        }
#endif //_CM_LDR_
        //
        // if we are here; we successfuly have copied all data into WorkBuffer.
        // update the return buffer and return; Caller is responsible to free the return buffer
        // We signal the caller by setting Allocated on TRUE
        //
        *Buffer = WorkBuffer;
        *Allocated = TRUE;
        return TRUE;
    }
#endif //_CM_LDR_

    //
    // normal, old plain case
    //
    *Buffer = HvGetCell(Hive,Value->Data);
    if( *Buffer == NULL ) {
        //
        // insufficient resources to map the view containing this cell
        //
        return FALSE;
    }
    //
    // signal to the caller to release this cell after finishing with buffer
    //
    *CellToRelease = Value->Data;
    
    return TRUE;
}
               
PCELL_DATA 
CmpValueToData(IN PHHIVE Hive,
               IN PCM_KEY_VALUE Value,
               OUT PULONG realsize
               )              
/*++

Routine Description:

    Retrieves the real valueData, given the key value.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Value - CM_KEY_VALUE to retrieve the data for.

    realsize - the actual size of the data (in bytes)


Return Value:

    pointer to the value data; NULL if any error (insuficient resources)

Notes:
    
    This function doesn't support big cells; It is intended to be called just
    by the loader, which doesn't store large data. It'll bugcheck if big cell
    is queried.

--*/
{
    PCELL_DATA  Buffer;
    BOOLEAN     BufferAllocated;
    HCELL_INDEX CellToRelease;

#ifndef _CM_LDR_
    PAGED_CODE();
#endif //_CM_LDR_

    ASSERT( Hive->ReleaseCellRoutine == NULL );

    if( CmpGetValueData(Hive,Value,realsize,&Buffer,&BufferAllocated,&CellToRelease) == FALSE ) {
        //
        // insufficient resources; return NULL
        //
        ASSERT( BufferAllocated == FALSE );
        ASSERT( Buffer == NULL );
        return NULL;
    }
    
    //
    // we specificallly ignore CellToRelease as this is not a mapped view
    //
    if( BufferAllocated == TRUE ) {
        //
        // this function is not intended for big cells;
        //
#ifndef _CM_LDR_
        ExFreePool( Buffer );
#endif //_CM_LDR_
        CM_BUGCHECK( REGISTRY_ERROR,BIG_CELL_ERROR,0,Hive,Value);

        return NULL;
    }
    
    //
    // success
    //
    return Buffer;
}


#ifndef _CM_LDR_

NTSTATUS
CmpAddValueToList(
    IN PHHIVE  Hive,
    IN HCELL_INDEX ValueCell,
    IN ULONG Index,
    IN ULONG Type,
    IN OUT PCHILD_LIST ChildList
    )
/*++

Routine Description:

    Adds a value to the value list, keeping the list sorted 
    (for new hives format)

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ValueCell - value index

    Index - index at which to add the value 

    ChildList - pointer to the list of values


Return Value:

    STATUS_SUCCESS - success

    STATUS_INSUFFICIENT_RESOURCES - an error occured

--*/
{
    HCELL_INDEX     NewCell;
    ULONG           count;
    ULONG           AllocateSize;
    ULONG           i;
    PCELL_DATA      pdata;

    PAGED_CODE();

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // sanity check for index range
    //
    ASSERT( (((LONG)Index) >= 0) && (Index <= ChildList->Count) );

    count = ChildList->Count;
    count++;
    if (count > 1) {

        ASSERT_CELL_DIRTY(Hive,ChildList->List);

        if (count < CM_MAX_REASONABLE_VALUES) {

            //
            // A reasonable number of values, allocate just enough
            // space.
            //

            AllocateSize = count * sizeof(HCELL_INDEX);
        } else {

            //
            // An excessive number of values, pad the allocation out
            // to avoid fragmentation. (if there's this many values,
            // there'll probably be more pretty soon)
            //
            AllocateSize = ROUND_UP(count, CM_MAX_REASONABLE_VALUES) * sizeof(HCELL_INDEX);
            if (AllocateSize > HBLOCK_SIZE) {
                AllocateSize = ROUND_UP(AllocateSize, HBLOCK_SIZE);
            }
        }

        NewCell = HvReallocateCell(
                        Hive,
                        ChildList->List,
                        AllocateSize
                        );
    } else {
        NewCell = HvAllocateCell(Hive, sizeof(HCELL_INDEX), Type,ValueCell);
    }

    //
    // put ourselves on the list
    //
    if (NewCell != HCELL_NIL) {
        // sanity
        ChildList->List = NewCell;

        pdata = HvGetCell(Hive, NewCell);
        if( pdata == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            //
            // normally this shouldn't happen as we just allocated ValueCell
            // i.e. the bin containing NewCell should be mapped in memory at this point.
            //
            ASSERT( FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        //
        // make room for the new cell; move values in the reverse order !
        // adding at the end makes this a nop
        //
        for( i = count - 1; i > Index; i-- ) {
            pdata->u.KeyList[i] = pdata->u.KeyList[i-1];
        }
        pdata->u.KeyList[Index] = ValueCell;
        ChildList->Count = count;

        HvReleaseCell(Hive,NewCell);
        // sanity
        ASSERT_CELL_DIRTY(Hive,ValueCell);

    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CmpRemoveValueFromList(
    IN PHHIVE  Hive,
    IN ULONG Index,
    IN OUT PCHILD_LIST ChildList
    )
/*++

Routine Description:

    Removes the value at the specified index from the value list

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Index - index at which to add the value 

    ChildList - pointer to the list of values

Return Value:

    STATUS_SUCCESS - success

    STATUS_INSUFFICIENT_RESOURCES - an error occured

Notes:
    
    The caller is responsible for freeing the removed value

--*/
{
    ULONG       newcount;
    HCELL_INDEX newcell;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // sanity check for index range
    //
    ASSERT( (((LONG)Index) >= 0) && (Index <= ChildList->Count) );

    newcount = ChildList->Count - 1;

    if (newcount > 0) {
        PCELL_DATA pvector;

        //
        // more than one entry list, squeeze
        //
        pvector = HvGetCell(Hive, ChildList->List);
        if( pvector == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell here as the reglock is held exclusive
        HvReleaseCell(Hive,ChildList->List);

        // sanity
        ASSERT_CELL_DIRTY(Hive,ChildList->List);
        ASSERT_CELL_DIRTY(Hive,pvector->u.KeyList[Index]);

        for ( ; Index < newcount; Index++) {
            pvector->u.KeyList[ Index ] = pvector->u.KeyList[ Index + 1 ];
        }

        newcell = HvReallocateCell(
                    Hive,
                    ChildList->List,
                    newcount * sizeof(HCELL_INDEX)
                    );
        ASSERT(newcell != HCELL_NIL);
        ChildList->List = newcell;

    } else {

        //
        // list is empty, free it
        //
        HvFreeCell(Hive, ChildList->List);
        ChildList->List = HCELL_NIL;
    }
    ChildList->Count = newcount;

    return STATUS_SUCCESS;
}


BOOLEAN
CmpMarkValueDataDirty(  IN PHHIVE Hive,
                        IN PCM_KEY_VALUE Value
                      )
/*++

Routine Description:

    Marks the cell(s) storing the value data as dirty;
    Knows how to deal with bigcells

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Value - CM_KEY_VALUE to retrieve the data for.

Return Value:

    TRUE - success
    FALSE - failure to mark all the cells involved; 

--*/
{
    ULONG   realsize;

    PAGED_CODE();

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    ASSERT_KEY_VALUE(Value);

    if( Value->Data != HCELL_NIL ) {
        //
        // Could be that value was just partially initialized (CmpSetValueKeyNew case)
        //
        //
        // check for small values
        //
        if( CmpIsHKeyValueSmall(realsize, Value->DataLength) == TRUE ) {
            //
            // data is stored inside the cell
            //
            return TRUE;
        }

        //
        // check for big values
        //
        if( CmpIsHKeyValueBig(Hive,realsize) == TRUE ) {
            //
            //
            //
            PCM_BIG_DATA    BigData;
            PHCELL_INDEX    Plist;
            USHORT          i;
        
            BigData = (PCM_BIG_DATA)HvGetCell(Hive,Value->Data);
            if( BigData == NULL ) {
                //
                // cannot map view containing the cell; bail out
                //
                return FALSE;
            }

            ASSERT_BIG_DATA(BigData);

            if( BigData->List != HCELL_NIL ) {
                Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
                if( Plist == NULL ) {
                    //
                    // cannot map view containing the cell; bail out
                    //
                    HvReleaseCell(Hive,Value->Data);
                    return FALSE;
                }


                for(i=0;i<BigData->Count;i++) {
                    //
                    // mark this chunk dirty
                    //
                    if( Plist[i] != HCELL_NIL ) {
                        if (! HvMarkCellDirty(Hive, Plist[i])) {
                            HvReleaseCell(Hive,Value->Data);
                            HvReleaseCell(Hive,BigData->List);
                            return FALSE;
                        }
                    }
                }
                //
                // mark the list as dirty
                //
                if (! HvMarkCellDirty(Hive, BigData->List)) {
                    HvReleaseCell(Hive,Value->Data);
                    HvReleaseCell(Hive,BigData->List);
                    return FALSE;
                }
                //
                // we can safely remove it here as it is now dirty/pinned
                //
                HvReleaseCell(Hive,BigData->List);
            }
            //
            // we don't need this cell anymore
            //
            HvReleaseCell(Hive,Value->Data);
            //
            // fall through to mark the cell itself as dirty
            //
        }

        //
        // Data is a HCELL_INDEX; mark it dirty
        //
        if (! HvMarkCellDirty(Hive, Value->Data)) {
            return FALSE;
        }
    }
    
    return TRUE;
}

BOOLEAN
CmpFreeValueData(
    PHHIVE      Hive,
    HCELL_INDEX DataCell,
    ULONG       DataLength
    )
/*++

Routine Description:

    Free the Value Data DataCell carries with.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    DataCell - supplies index of value who's data to free

    DataLength - length of the data; used to detect the type of the cell

Return Value:

    TRUE: Success
    FALSE: Error
  
Notes:
    
      Knows how to deal with big cell(s)

--*/
{
    ULONG           realsize;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // check for small values
    //
    if( CmpIsHKeyValueSmall(realsize, DataLength) == TRUE ) {
        //
        // data is stored inside the cell; this is a nop
        //
    } else {
        //
        // Could be that value was just partially initialized (CmpSetValueKeyNew case)
        //
        if( DataCell == HCELL_NIL ) {
            return TRUE;
        }

        ASSERT(HvIsCellAllocated(Hive,DataCell));
        //
        // check for big values
        //
        if( CmpIsHKeyValueBig(Hive,realsize) == TRUE ) {
            //
            //
            //
            PCM_BIG_DATA    BigData;
            PHCELL_INDEX    Plist;
            USHORT          i;

            BigData = (PCM_BIG_DATA)HvGetCell(Hive,DataCell);
            if( BigData == NULL ) {
                //
                // cannot map view containing the cell; bail out
                // 
                // This shouldn't happen as this cell is marked ditry by
                // this time (i.e. its view is pinned in memory)
                //
                ASSERT( FALSE );
                return FALSE;
            }

            // release the cell here as the reglock is held exclusive
            HvReleaseCell(Hive,DataCell);

            ASSERT_BIG_DATA(BigData);

            if( BigData->List != HCELL_NIL ) {
                Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
                if( Plist == NULL ) {
                    //
                    // cannot map view containing the cell; bail out
                    //
                    // 
                    // This shouldn't happen as this cell is marked ditry by
                    // this time (i.e. its view is pinned in memory)
                    //
                    ASSERT( FALSE );
                    return FALSE;
                }

                // release the cell here as the reglock is held exclusive
                HvReleaseCell(Hive,BigData->List);

                for(i=0;i<BigData->Count;i++) {
                    //
                    // mark this chunk dirty
                    //
                    if( Plist[i] != HCELL_NIL ) {
                        HvFreeCell(Hive, Plist[i]);
                    }
                }
                //
                // mark the list as dirty
                //
                HvFreeCell(Hive, BigData->List);
            }
            //
            // fall through to free the cell data itself
            //
        
        }
        //
        // normal case free the Data cell
        //
        HvFreeCell(Hive, DataCell);
    }
    
    return TRUE;
}


BOOLEAN
CmpFreeValue(
    PHHIVE Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Free the value entry Hive.Cell refers to, including
    its name and data cells.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of value to delete

Return Value:

    TRUE: Success
    FALSE: Error
  

--*/
{
    PCM_KEY_VALUE   Value;
    ULONG           realsize;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // map in the cell
    //
    Value = (PCM_KEY_VALUE)HvGetCell(Hive, Cell);
    if( Value == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // sorry we cannot free value
        // 
        // This shouldn't happen as the value is marked ditry by
        // this time (i.e. its view is pinned in memory)
        //
        ASSERT( FALSE );
        return FALSE;
    }

    // release the cell here as the reglock is held exclusive
    HvReleaseCell(Hive,Cell);

    if( CmpFreeValueData(Hive,Value->Data,Value->DataLength) == FALSE ) {
        return FALSE;
    }

    //
    // free the cell itself
    //
    HvFreeCell(Hive, Cell);

    return TRUE;
}

NTSTATUS
CmpSetValueDataNew(
    IN PHHIVE           Hive,
    IN PVOID            Data,
    IN ULONG            DataSize,
    IN ULONG            StorageType,
    IN HCELL_INDEX      ValueCell,
    OUT PHCELL_INDEX    DataCell
    )
/*++

Routine Description:

    Allocates a new cell (or big data cell) to accomodate DataSize;
    Initialize and copy information from Data to the new cell;

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive
    
    Data - data buffer (possibly from user-mode)

    DataSize - size of the buffer

    StorageType - Stable or Volatile

    ValueCell - The value setting the data for (locality purposes).

    DataCell - return value:HCELL_INDEX of the new cell; HCELL_NIL on some error

Return Value:

    Status of the operation (STATUS_SUCCESS or the exception code - if any)

Notes:
        
      Knows how to deal with big cell(s)
      Data buffer comes from user mode, so it should be guarded by a try-except

--*/
{
    PCELL_DATA  pdata;
    
    PAGED_CODE();

    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // bogus args; we don't deal with small values here!
    //
    ASSERT(DataSize > CM_KEY_VALUE_SMALL);

    if( CmpIsHKeyValueBig(Hive,DataSize) == TRUE ) {
        //
        // request for a big data value
        //
        PCM_BIG_DATA    BigData = NULL;
        USHORT          Count;
        PHCELL_INDEX    Plist = NULL;
        NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // allocate the embedding cell
        //
        *DataCell = HvAllocateCell(Hive, sizeof(CM_BIG_DATA), StorageType,ValueCell);
        if (*DataCell == HCELL_NIL) {
            return status;
        }
        
        //
        // init the BIG_DATA cell
        //
        BigData = (PCM_BIG_DATA)HvGetCell(Hive,*DataCell);
        if( BigData == NULL) {
            //
            // couldn't map view for this cell
            // this shouldn't happen as we just allocated this cell 
            // (i.e. its view should be pinned in memory)
            //
            ASSERT( FALSE );
            goto Cleanup;
        }

        // release the cell here as the reglock is held exclusive
        HvReleaseCell(Hive,*DataCell);

        BigData->Signature = CM_BIG_DATA_SIGNATURE;
        BigData->Count = 0;
        BigData->List = HCELL_NIL;

        //
        // Compute the number of cells needed
        //
        Count = (USHORT)((DataSize + CM_KEY_VALUE_BIG - 1) / CM_KEY_VALUE_BIG);

        //
        // allocate the embeded list
        //
        BigData->List = HvAllocateCell(Hive, Count * sizeof(HCELL_INDEX), StorageType,*DataCell);
        if( BigData->List == HCELL_NIL ) {
            goto Cleanup;
        }

        Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
        if( Plist == NULL ) {
            //
            // cannot map view containing the cell; bail out
            //
            // 
            // This shouldn't happen as this cell is marked ditry by
            // this time (i.e. its view is pinned in memory)
            //
            ASSERT( FALSE );
            goto Cleanup;
        }

        // release the cell here as the reglock is held exclusive
        HvReleaseCell(Hive,BigData->List);

        //
        // allocate each chunk and copy the data; if we fail part through, we'll free the already allocated values
        //
        for( ;BigData->Count < Count;(BigData->Count)++) {
            //
            // allocate this chunk
            //
            Plist[BigData->Count] = HvAllocateCell(Hive, CM_KEY_VALUE_BIG, StorageType,BigData->List);
            if( Plist[BigData->Count] == HCELL_NIL ) {
                goto Cleanup;
            }
            pdata = HvGetCell(Hive,Plist[BigData->Count]);
            if( pdata == NULL ) {
                //
                // cannot map view containing the cell; bail out
                //
                // 
                // This shouldn't happen as this cell is marked ditry by
                // this time (i.e. its view is pinned in memory)
                //
                ASSERT( FALSE );
                goto Cleanup;
            }

            // release the cell here as the reglock is held exclusive
            HvReleaseCell(Hive,Plist[BigData->Count]);

            //
            // now, copy this chunk data
            //
            try {

                RtlCopyMemory(pdata, (PUCHAR)Data, (DataSize>CM_KEY_VALUE_BIG)?CM_KEY_VALUE_BIG:DataSize);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpSetValueDataNew: code:%08lx\n", GetExceptionCode()));

                status = GetExceptionCode();
                goto Cleanup;
            }
            
            //
            // update the data pointer and the remaining size
            //
            ((PUCHAR)Data) += CM_KEY_VALUE_BIG;
            DataSize -= CM_KEY_VALUE_BIG;

        }
        
        ASSERT( Count == BigData->Count );
        return STATUS_SUCCESS;

Cleanup:
        //
        // free what we already allocated
        //
        if( BigData != NULL) {
            if( Plist != NULL ) {
                for(;BigData->Count;BigData->Count--) {
                    if( Plist[BigData->Count] != HCELL_NIL ) {
                        HvFreeCell(Hive, Plist[BigData->Count]);
                    }
                }
            } else {
                ASSERT( BigData->Count == 0 );
            }

            if( BigData->List != HCELL_NIL ) {
                HvFreeCell(Hive, BigData->List);
            }
        }

        HvFreeCell(Hive, *DataCell);
        *DataCell = HCELL_NIL;
        return status;
    } else {
        //
        // normal old'n plain value
        //
        *DataCell = HvAllocateCell(Hive, DataSize, StorageType,ValueCell);
        if (*DataCell == HCELL_NIL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pdata = HvGetCell(Hive, *DataCell);
        if( pdata == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            //
            // normally this shouldn't happen as we just allocated ValueCell
            // i.e. the bin containing DataCell should be mapped in memory at this point.
            //
            ASSERT( FALSE );
            if (*DataCell != HCELL_NIL) {
                HvFreeCell(Hive, *DataCell);
                *DataCell = HCELL_NIL;
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell here as the reglock is held exclusive
        HvReleaseCell(Hive,*DataCell);

        //
        // copy the actual data, guarding the buffer as it may be a user-mode buffer
        //
        try {

            RtlCopyMemory(pdata, Data, DataSize);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpSetValueDataNew: code:%08lx\n", GetExceptionCode()));

            //
            // We have bombed out loading user data, clean up and exit.
            //
            if (*DataCell != HCELL_NIL) {
                HvFreeCell(Hive, *DataCell);
                *DataCell = HCELL_NIL;
            }
            return GetExceptionCode();
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CmpSetValueDataExisting(
    IN PHHIVE           Hive,
    IN PVOID            Data,
    IN ULONG            DataSize,
    IN ULONG            StorageType,
    IN HCELL_INDEX      OldDataCell
    )
/*++

Routine Description:

    Grows an existing big data cell and copies the new data into it.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive
    
    Data - data buffer (possibly from user-mode)

    DataSize - size of the buffer

    StorageType - Stable or Volatile

    OldDataCell - old big data cell
      
    NewDataCell - return value:HCELL_INDEX of the new cell; HCELL_NIL on some error

Return Value:

    Status of the operation (STATUS_SUCCESS or the exception code - if any)

Notes:
        
      Knows how to deal with big cell(s)
      Data buffer is secured by the time this function is called

--*/
{
    PCELL_DATA      pdata;
    PCM_BIG_DATA    BigData = NULL;
    USHORT          NewCount,i;
    PHCELL_INDEX    Plist = NULL;
    HCELL_INDEX     NewList;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // bogus args; we deal only with big data cells!
    //
    ASSERT(DataSize > CM_KEY_VALUE_BIG );

    
    BigData = (PCM_BIG_DATA)HvGetCell(Hive,OldDataCell);
    if( BigData == NULL) {
        //
        // couldn't map view for this cell
        // this shouldn't happen as we just marked it as dirty
        // (i.e. its view should be pinned in memory)
        //
        ASSERT( FALSE );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // release the cell here as the reglock is held exclusive
    HvReleaseCell(Hive,OldDataCell);

    ASSERT_BIG_DATA(BigData);


    
    Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
    if( Plist == NULL ) {
        //
        // cannot map view containing the cell; bail out
        // this shouldn't happen as we just marked it as dirty
        // (i.e. its view should be pinned in memory)
        //
        ASSERT(FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // release the cell here as the reglock is held exclusive
    HvReleaseCell(Hive,BigData->List);

    //
    // what's the new size?
    //
    NewCount = (USHORT)((DataSize + CM_KEY_VALUE_BIG - 1) / CM_KEY_VALUE_BIG);

    if( NewCount > BigData->Count ) {
        //
        // grow the list and allocate additional cells to it
        //
        NewList = HvReallocateCell(Hive,BigData->List,NewCount * sizeof(HCELL_INDEX));
        if( NewList == HCELL_NIL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // we can now safely alter the list; if allocating the aditional cells below fails
        // we'll end up with some wasted space, but we'll be safe
        //
        BigData->List = NewList;

        //
        // read the new list
        //
        Plist = (PHCELL_INDEX)HvGetCell(Hive,NewList);
        if( Plist == NULL ) {
            //
            // cannot map view containing the cell; bail out
            // this shouldn't happen as we just reallocated the cell
            // (i.e. its view should be pinned in memory)
            //
            ASSERT(FALSE);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell here as the reglock is held exclusive
        HvReleaseCell(Hive,NewList);

        for(i= BigData->Count;i<NewCount;i++) {
            Plist[i] = HvAllocateCell(Hive, CM_KEY_VALUE_BIG, StorageType,NewList);
            if( Plist[i] == HCELL_NIL ) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    } else if( NewCount < BigData->Count ) {
        //
        // shrink the list and free additional unneccessary cells
        //
        for(i=NewCount;i<BigData->Count;i++) {
            //
            // this CANNOT fail as the cell is already marked dirty (i.e. pinned in memory).
            //
            HvFreeCell(Hive,Plist[i]);
        }
        //
        // this WON'T fail, 'cause it's a shrink
        //
        NewList = HvReallocateCell(Hive,BigData->List,NewCount * sizeof(HCELL_INDEX));
        if( NewList == HCELL_NIL ) {
            ASSERT( FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // read the new list (in the current implementation we don't shrink cells, 
        // so this is not really needed - just to be consistent)
        //
        Plist = (PHCELL_INDEX)HvGetCell(Hive,NewList);
        if( Plist == NULL ) {
            //
            // cannot map view containing the cell; bail out
            // this shouldn't happen as we just reallocated the cell
            // (i.e. its view should be pinned in memory)
            //
            ASSERT(FALSE);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell here as the reglock is held exclusive
        HvReleaseCell(Hive,NewList);

        //
        // we can now safely alter the list
        //
        BigData->List = NewList;
    }

    //
    // if we came to this point, we have successfully grown the list and 
    // allocated the additional space; nothing should go wrong further
    //

    //
    // go on and fill in the data onto the (new) big data cell
    //
    for( i=0;i<NewCount;i++) {
        pdata = HvGetCell(Hive,Plist[i]);
        if( pdata == NULL ) {
            //
            // cannot map view containing the cell; bail out
            //
            // 
            // This shouldn't happen as this cell is marked dirty by
            // this time - or is a new allocated cell 
            // (i.e. its view is pinned in memory)
            //
            ASSERT( FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell here as the reglock is held exclusive
        HvReleaseCell(Hive,Plist[i]);

        //
        // now, copy this chunk data
        //
        RtlCopyMemory(pdata, (PUCHAR)Data, (DataSize>CM_KEY_VALUE_BIG)?CM_KEY_VALUE_BIG:DataSize);

        //
        // update the data pointer and the remaining size
        //
        Data = (PVOID)((PCHAR)Data + CM_KEY_VALUE_BIG);
        DataSize -= CM_KEY_VALUE_BIG;
    }
    

    BigData->Count = NewCount;
    return STATUS_SUCCESS;

}

#endif //_CM_LDR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hivebin.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivebin.c

Abstract:

    This module implements HvpAddBin - used to grow a hive.

Author:

    Bryan M. Willman (bryanwi) 27-Mar-92

Environment:


Revision History:

--*/

#include    "cmp.h"

//
// Private function prototypes
//
BOOLEAN
HvpCoalesceDiscardedBins(
    IN PHHIVE Hive,
    IN ULONG NeededSize,
    IN HSTORAGE_TYPE Type
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpAddBin)
#pragma alloc_text(PAGE,HvpCoalesceDiscardedBins)
#endif


PHBIN
HvpAddBin(
    IN PHHIVE  Hive,
    IN ULONG   NewSize,
    IN HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Grows either the Stable or Volatile storage of a hive by adding
    a new bin.  Bin will be allocated space in Stable store (e.g. file)
    if Type == Stable.  Memory image will be allocated and initialized.
    Map will be grown and filled in to describe the new bin.
    
      
WARNING:
    When adding a new bin, if the CM_VIEW_SIZE boundary is crossed:
    - add a free bin with the remaining space to the first CM_VIEW_SIZE barrier
    - from the next CM_VIEW_SIZE window, add a new bin of the desired size.

    Of course, this applies only to stable storage.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    NewSize - size of the object caller wishes to put in the hive.  New
                bin will be at least large enough to hold this.

    Type - Stable or Volatile

Return Value:

    Pointer to the new BIN if we succeeded, NULL if we failed.

--*/
{
    BOOLEAN         UseForIo;
    PHBIN           NewBin;
    PHBIN           RemainingBin;
    ULONG           OldLength;
    ULONG           NewLength;
    ULONG           CheckLength;
    ULONG           OldMap;
    ULONG           NewMap;
    ULONG           OldTable;
    ULONG           NewTable;
    PHMAP_DIRECTORY Dir;
    PHMAP_TABLE     newt;
    PHMAP_ENTRY     Me;
    PHCELL          t;
    ULONG           i;
    ULONG           j;
    PULONG          NewVector;
    PLIST_ENTRY     Entry;
    PFREE_HBIN      FreeBin;
    ULONG           TotalDiscardedSize;
    PCMHIVE			CmHive;

    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpAddBin:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p NewSize=%08lx\n",Hive,NewSize));

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    RemainingBin = NULL;
    //
    //  Round size up to account for bin overhead.  Caller should
    //  have accounted for cell overhead.
    //
    NewSize += sizeof(HBIN);
    if ((NewSize < HCELL_BIG_ROUND) &&
        ((NewSize % HBLOCK_SIZE) > HBIN_THRESHOLD)) {
        NewSize += HBLOCK_SIZE;
    }

    //
    // Try not to create HBINs smaller than the page size of the machine
    //  (it is not illegal to have bins smaller than the page size, but it
    //  is less efficient)
    //
    NewSize = ROUND_UP(NewSize, ((HBLOCK_SIZE >= PAGE_SIZE) ? HBLOCK_SIZE : PAGE_SIZE));

    //
    // see if there's a discarded HBIN of the right size
    //
    TotalDiscardedSize = 0;

Retry:

    Entry = Hive->Storage[Type].FreeBins.Flink;
    while (Entry != &Hive->Storage[Type].FreeBins) {
        FreeBin = CONTAINING_RECORD(Entry,
                                    FREE_HBIN,
                                    ListEntry);
        TotalDiscardedSize += FreeBin->Size;
        if ((FreeBin->Size >= NewSize) && ((CmHive->GrowOnlyMode == FALSE) || (Type == Volatile)) ) {

            if (!HvMarkDirty(Hive,
                             FreeBin->FileOffset + (Type * HCELL_TYPE_MASK),
                             FreeBin->Size,TRUE)) {
                goto ErrorExit1;
            }
            NewSize = FreeBin->Size;
            ASSERT_LISTENTRY(&FreeBin->ListEntry);
            RemoveEntryList(&FreeBin->ListEntry);

#ifdef  HV_TRACK_FREE_SPACE
	        Hive->Storage[Type].FreeStorage -= (NewSize - sizeof(HBIN));
	        ASSERT( (LONG)(Hive->Storage[Type].FreeStorage) >= 0 );
#endif


            if ( FreeBin->Flags & FREE_HBIN_DISCARDABLE ) {
                //
                // HBIN is still in memory, don't need any more allocs, just
                // fill in the block addresses.
                //
                for (i=0;i<NewSize;i+=HBLOCK_SIZE) {
                    Me = HvpGetCellMap(Hive, FreeBin->FileOffset+i+(Type*HCELL_TYPE_MASK));
                    VALIDATE_CELL_MAP(__LINE__,Me,Hive,FreeBin->FileOffset+i+(Type*HCELL_TYPE_MASK));
                    Me->BlockAddress = HBIN_BASE(Me->BinAddress)+i;
                    Me->BinAddress &= ~HMAP_DISCARDABLE;
                    // we cannot have the FREE_BIN_DISCARDABLE flag set 
                    // and FREE_HBIN_INVIEW not set on a mapped bin.
                    ASSERT( Me->BinAddress & HMAP_INPAGEDPOOL );
                    // we don't need to set it to NULL - just for debug purposes
                    ASSERT( (Me->CmView = NULL) == NULL );
                }
                (Hive->Free)(FreeBin, sizeof(FREE_HBIN));
#if DBG 
                {
                    UNICODE_STRING  HiveName;
                    RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) reusing FreeBin %p at FileOffset %lx; Type = %lu\n",
                        Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,HBIN_BASE(Me->BinAddress),((PHBIN)HBIN_BASE(Me->BinAddress))->FileOffset,(ULONG)Type));
                }
#endif
                return (PHBIN)HBIN_BASE(Me->BinAddress);
            }
            break;
        }
        Entry = Entry->Flink;
    }

    if ((Entry == &Hive->Storage[Type].FreeBins) &&
        (TotalDiscardedSize >= NewSize)) {
        //
        // No sufficiently large discarded bin was found,
        // but the total discarded space is large enough.
        // Attempt to coalesce adjacent discarded bins into
        // a larger bin and retry.
        //
        if (HvpCoalesceDiscardedBins(Hive, NewSize, Type)) {
            goto Retry;
        }
    }

    //
    // we need these sooner to do the computations in case we allocate a new bin
    //
    OldLength = Hive->Storage[Type].Length;
    CheckLength = OldLength;
    //
    //  Attempt to allocate the bin.
    //
    UseForIo = (BOOLEAN)((Type == Stable) ? TRUE : FALSE);
    if (Entry != &Hive->Storage[Type].FreeBins) {
        if( Type == Volatile ) {
            //
            // old plain method for volatile storage
            //
            //
            // Note we use ExAllocatePool directly here to avoid
            // charging quota for this bin again. When a bin
            // is discarded, its quota is not returned. This prevents
            // sparse hives from requiring more quota after
            // a reboot than on a running system.
            //
            NewBin = ExAllocatePoolWithTag((UseForIo) ? PagedPoolCacheAligned : PagedPool,
                                           NewSize,
                                           CM_HVBIN_TAG);
            if (NewBin == NULL) {
                InsertHeadList(&Hive->Storage[Type].FreeBins, Entry);
#ifdef  HV_TRACK_FREE_SPACE
    	        Hive->Storage[Type].FreeStorage += (NewSize - sizeof(HBIN));
#endif
                // this call is a nop
                //HvMarkClean(Hive, FreeBin->FileOffset, FreeBin->Size);
                goto ErrorExit1;
            }
        } else {
            //
            // for Stable, map the view containing the bin in memory
            // and fix the map
            //

            Me = HvpGetCellMap(Hive, FreeBin->FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FreeBin->FileOffset);

    
            if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                ASSERT( (Me->BinAddress & HMAP_INVIEW) == 0 );
                //
                // bin is in paged pool; allocate backing store
                //
                NewBin = (Hive->Allocate)(NewSize, UseForIo,CM_FIND_LEAK_TAG15);
                if (NewBin == NULL) {
                    InsertHeadList(&Hive->Storage[Type].FreeBins, Entry);
#ifdef  HV_TRACK_FREE_SPACE
        	        Hive->Storage[Type].FreeStorage += (NewSize - sizeof(HBIN));
#endif
                    goto ErrorExit1;
                }
            } else {
                //
                // The view containing this bin has been unmapped; map it again
                //
                if( (Me->BinAddress & HMAP_INVIEW) == 0 ) {
                    ASSERT( (Me->BinAddress & HMAP_INPAGEDPOOL) == 0 );
                    //
                    // map the bin
                    //
                    if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,FreeBin->FileOffset,TRUE)) ) {
                        InsertHeadList(&Hive->Storage[Type].FreeBins, Entry);
#ifdef  HV_TRACK_FREE_SPACE
            	        Hive->Storage[Type].FreeStorage += (NewSize - sizeof(HBIN));
#endif
                        return NULL;
                    }
                }

                ASSERT( Me->BinAddress & HMAP_INVIEW );
                NewBin = (PHBIN)HBIN_BASE(Me->BinAddress);
            }
        }
       
    } else {
#if 0
//
// this is no longer neccesssary as Mm is faulting one page at a time for MNW streams
//
        ASSERT( (CM_VIEW_SIZE >= PAGE_SIZE) && (CM_VIEW_SIZE >= HBLOCK_SIZE) );
        //
        // Don't do unneccessary work for volatile storage or volatile hives
        //
        if( (Type == Stable) && (!(Hive->HiveFlags & HIVE_VOLATILE)) ) {
            ULONG   RealHiveSize = OldLength + HBLOCK_SIZE;

            if( RealHiveSize != (RealHiveSize & (~(CM_VIEW_SIZE - 1)) ) ) {
                //
                // Hive size does not follow the CM_VIEW_SIZE increments pattern
                //
                ULONG FillUpSize;
                FillUpSize = ((OldLength + HBLOCK_SIZE + CM_VIEW_SIZE - 1) & (~(CM_VIEW_SIZE - 1))) - (OldLength + HBLOCK_SIZE);
        
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"HvpAddBin for (%p) NewSize (%lx) ",Hive,NewSize));
                if( FillUpSize >= NewSize ) {
                    //
                    // there is plenty of space in the remaining to the CM_VIEW_SIZE boundary to accomodate this bin
                    // adjust the size of the bin
                    //
                    NewSize = FillUpSize;
                    ASSERT( HvpCheckViewBoundary(CheckLength,CheckLength + NewSize - 1) == TRUE );
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Fits in the remaining to boundary, Adjusting size to %lx",NewSize));
                } else {
                    //
                    // we don't have space to fit this bin in the remaining to the CM_VIEW_SIZE boundary
                    // FillUpSize will be enlisted as a free bin. round up to CM_VIEW_SIZE
                    //
                    ASSERT( HvpCheckViewBoundary(CheckLength,CheckLength + NewSize - 1) == FALSE );
                    NewSize = ROUND_UP(NewSize, CM_VIEW_SIZE);
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Does not fit in the remaining to boundary, Rounding size to %lx",NewSize));
                }

            } else {
                //
                // Hive already follows the CM_VIEW_SIZE boundary pattern; don't break it
                //
                NewSize = ROUND_UP(NewSize, CM_VIEW_SIZE);
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"hive size already aligned, Rounding size to %lx",NewSize));
            }

        }
#endif

        //
        // this is a totally new bin. Allocate it from paged pool
        //
        NewBin = (Hive->Allocate)(NewSize, UseForIo,CM_FIND_LEAK_TAG16);
        if (NewBin == NULL) {
            goto ErrorExit1;
        }
    }

    //
    // Init the bin
    //
    NewBin->Signature = HBIN_SIGNATURE;
    NewBin->Size = NewSize;

    t = (PHCELL)((PUCHAR)NewBin + sizeof(HBIN));
    t->Size = NewSize - sizeof(HBIN);
    if (USE_OLD_CELL(Hive)) {
        t->u.OldCell.Last = (ULONG)HBIN_NIL;
    }

    if (Entry != &Hive->Storage[Type].FreeBins) {
        //
        // found a discarded HBIN we can use, just fill in the map and we
        // are done.
        //
        for (i=0;i<NewSize;i+=HBLOCK_SIZE) {
            Me = HvpGetCellMap(Hive, FreeBin->FileOffset+i+(Type*HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FreeBin->FileOffset+i+(Type*HCELL_TYPE_MASK));
            Me->BlockAddress = (ULONG_PTR)NewBin + i;
            //
            //  make sure to preserve the following flags:
            // HMAP_INVIEW|HMAP_INPAGEDPOOL
            //  and to clear the flag
            // HMAP_DISCARDABLE
            //
                        
            Me->BinAddress = (ULONG_PTR)((ULONG_PTR)NewBin | (Me->BinAddress&(HMAP_INVIEW|HMAP_INPAGEDPOOL)));
            Me->BinAddress &= ~HMAP_DISCARDABLE;
            if (i==0) {
                Me->BinAddress |= HMAP_NEWALLOC;
                Me->MemAlloc = NewSize;
            } else {
                Me->MemAlloc = 0;
            }

        }

        NewBin->FileOffset = FreeBin->FileOffset;

        (Hive->Free)(FreeBin, sizeof(FREE_HBIN));

#if DBG
        {
            UNICODE_STRING  HiveName;
            RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) reusing FreeBin %p at FileOffset %lx; Type = %lu\n",
                Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,NewBin,NewBin->FileOffset,(ULONG)Type));
        }
#endif

        return(NewBin);
    }


    //
    // Compute map growth needed, grow the map
    //

    if( (HvpCheckViewBoundary(CheckLength,CheckLength + NewSize - 1) == FALSE) &&
        (NewSize < CM_VIEW_SIZE)    // don't bother if we attempt to allocate a cell bigger then the view size
                                    // it'll cross the boundary anyway.
        ) {
        //
        // the bin to be allocated doesn't fit into the remaining 
        // of this CM_VIEW_SIZE window. Allocate it from the next CM_VIEW_SIZE window
        // and add the remaining of this to the free bin list
        //
        CheckLength += (NewSize+HBLOCK_SIZE);
        CheckLength &= (~(CM_VIEW_SIZE - 1));
        CheckLength -= HBLOCK_SIZE;
        
#if DBG
        {
            UNICODE_STRING  HiveName;
            RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) crossing boundary at %lx Size %lx, newoffset= %lx\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,OldLength,NewSize,CheckLength));
        }
#endif
    }

    NewLength = CheckLength + NewSize;
    NewBin->FileOffset = CheckLength;

    //CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"OldLength = %lx;NewLength = %lx (Type = %lx)\n",OldLength,NewLength,(ULONG)Type));

    if( CmpCanGrowSystemHive(Hive,NewLength) == FALSE ) {
        //
        // OOPS! we have reached the hard quota limit on the system hive
        //
        goto ErrorExit2;
    }

    ASSERT((OldLength % HBLOCK_SIZE) == 0);
    ASSERT((CheckLength % HBLOCK_SIZE) == 0);
    ASSERT((NewLength % HBLOCK_SIZE) == 0);

    if (OldLength == 0) {
        //
        // Need to create the first table
        //
        newt = (PVOID)((Hive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG17));
        if (newt == NULL) {
            goto ErrorExit2;
        }
        RtlZeroMemory(newt, sizeof(HMAP_TABLE));
        Hive->Storage[Type].SmallDir = newt;
        Hive->Storage[Type].Map = (PHMAP_DIRECTORY)&(Hive->Storage[Type].SmallDir);
    }

    if (OldLength > 0) {
        OldMap = (OldLength-1) / HBLOCK_SIZE;
    } else {
        OldMap = 0;
    }
    NewMap = (NewLength-1) / HBLOCK_SIZE;

    OldTable = OldMap / HTABLE_SLOTS;
    NewTable = NewMap / HTABLE_SLOTS;

#if DBG
    if( Type == Stable ) {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) Adding new bin %p at FileOffset %lx; Type = %lu\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,NewBin,NewBin->FileOffset,(ULONG)Type));
    }
#endif

    if (NewTable != OldTable) {

        //
        // Need some new Tables
        //
        if (OldTable == 0) {

            //
            // We can get here even if the real directory has already been created.
            // This can happen if we create the directory then fail on something 
            // later. So we need to handle the case where a directory already exists.
            //
            if (Hive->Storage[Type].Map == (PHMAP_DIRECTORY)&Hive->Storage[Type].SmallDir) {
                ASSERT(Hive->Storage[Type].SmallDir != NULL);

                //
                // Need a real directory
                //
                Dir = (Hive->Allocate)(sizeof(HMAP_DIRECTORY), FALSE,CM_FIND_LEAK_TAG18);
                if (Dir == NULL) {
                    goto ErrorExit2;
                }
                RtlZeroMemory(Dir, sizeof(HMAP_DIRECTORY));
    
                Dir->Directory[0] = Hive->Storage[Type].SmallDir;
                Hive->Storage[Type].SmallDir = NULL;
    
                Hive->Storage[Type].Map = Dir;
            } else {
                ASSERT(Hive->Storage[Type].SmallDir == NULL);
            }

        }
        Dir = Hive->Storage[Type].Map;

        //
        // Fill in directory with new tables
        //
        if (HvpAllocateMap(Hive, Dir, OldTable+1, NewTable) ==  FALSE) {
            goto ErrorExit3;
        }
    }

    //
    // If Type == Stable, and the hive is not marked WholeHiveVolatile,
    // grow the file, the log, and the DirtyVector
    //
    if( !NT_SUCCESS(HvpAdjustHiveFreeDisplay(Hive,NewLength,Type)) ) {
        goto ErrorExit3;
    }

    Hive->Storage[Type].Length = NewLength;
    if ((Type == Stable) && (!(Hive->HiveFlags & HIVE_VOLATILE))) {

        //
        // Grow the dirtyvector
        //
        NewVector = (PULONG)(Hive->Allocate)(ROUND_UP(NewMap+1,sizeof(ULONG)), TRUE,CM_FIND_LEAK_TAG19);
        if (NewVector == NULL) {
            goto ErrorExit3;
        }

        RtlZeroMemory(NewVector, NewMap+1);

        if (Hive->DirtyVector.Buffer != NULL) {

            RtlCopyMemory(
                (PVOID)NewVector,
                (PVOID)Hive->DirtyVector.Buffer,
                OldMap+1
                );
            (Hive->Free)(Hive->DirtyVector.Buffer, Hive->DirtyAlloc);
        }

        RtlInitializeBitMap(
            &(Hive->DirtyVector),
            NewVector,
            NewLength / HSECTOR_SIZE
            );
        Hive->DirtyAlloc = ROUND_UP(NewMap+1,sizeof(ULONG));

        //
        // Grow the log
        //
        if ( ! (HvpGrowLog2(Hive, NewSize))) {
            goto ErrorExit4;
        }

        //
        // Grow the primary
        //
        if ( !  (Hive->FileSetSize)(
                    Hive,
                    HFILE_TYPE_PRIMARY,
                    NewLength+HBLOCK_SIZE,
                    OldLength+HBLOCK_SIZE
                    ) )
        {
            goto ErrorExit4;
        }

        //
        // Mark new bin dirty so all control structures get written at next sync
        //
        ASSERT( ((NewLength - OldLength) % HBLOCK_SIZE) == 0 );
        if ( ! HvMarkDirty(Hive, OldLength,NewLength - OldLength,FALSE)) {
            //
            // we have grown the hive, so the new bins are in paged pool !!!
            //
            goto ErrorExit4;
        }
    } else {
        //
        // volatile hive; save dirty vector in case we encounter some error bellow
        //
        NewVector = Hive->DirtyVector.Buffer;
    }

    //
    // Add the remaining to the free bin list
    //
    if( CheckLength != OldLength ) {
        //
        // Allocate the bin from pagedpool (first flush will update the file image and free the memory)
        //
        RemainingBin = (Hive->Allocate)(CheckLength - OldLength, UseForIo,CM_FIND_LEAK_TAG20);
        if (RemainingBin == NULL) {
            goto ErrorExit4;
        }
        RemainingBin->Signature = HBIN_SIGNATURE;
        RemainingBin->Size = CheckLength - OldLength;
        RemainingBin->FileOffset = OldLength;

        t = (PHCELL)((PUCHAR)RemainingBin + sizeof(HBIN));
        t->Size = RemainingBin->Size - sizeof(HBIN);
        if (USE_OLD_CELL(Hive)) {
            t->u.OldCell.Last = (ULONG)HBIN_NIL;
        }

        //
        // add the free bin to the free bin list and update the map.
        //
        FreeBin = (Hive->Allocate)(sizeof(FREE_HBIN), FALSE,CM_FIND_LEAK_TAG21);
        if (FreeBin == NULL) {
            goto ErrorExit5;
        }
        
        FreeBin->Size = CheckLength - OldLength;
        FreeBin->FileOffset = OldLength;
        FreeBin->Flags = FREE_HBIN_DISCARDABLE;

        InsertHeadList(&Hive->Storage[Type].FreeBins, &FreeBin->ListEntry);
        
#ifdef  HV_TRACK_FREE_SPACE
        Hive->Storage[Type].FreeStorage += (FreeBin->Size - sizeof(HBIN));
	    ASSERT( Hive->Storage[Type].FreeStorage <= Hive->Storage[Type].Length );
#endif

        ASSERT_LISTENTRY(&FreeBin->ListEntry);
        ASSERT_LISTENTRY(FreeBin->ListEntry.Flink);

        for (i = OldLength; i < CheckLength; i += HBLOCK_SIZE) {
            Me = HvpGetCellMap(Hive, i + (Type*HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,i + (Type*HCELL_TYPE_MASK));

            Me->BinAddress = (ULONG_PTR)RemainingBin | HMAP_DISCARDABLE | HMAP_INPAGEDPOOL;
            if( i == OldLength ) {
                Me->BinAddress |= HMAP_NEWALLOC;
                Me->MemAlloc = CheckLength - OldLength;
            } else {
                Me->MemAlloc = 0;
            }
            Me->BlockAddress = (ULONG_PTR)FreeBin;

            // we don't need to set it to NULL - just for debug purposes
            ASSERT( (Me->CmView = NULL) == NULL );
        }

#if DBG
        {
            if( Type == Stable ) {
                UNICODE_STRING  HiveName;
                RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) adding bin starting at %lx size %lx to FreeBinList\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,FreeBin->FileOffset,FreeBin->Size));
            }
        }
#endif
    }
    //
    // Fill in the map, mark new allocation.
    //
    j = 0;
    for (i = CheckLength; i < NewLength; i += HBLOCK_SIZE) {
        Me = HvpGetCellMap(Hive, i + (Type*HCELL_TYPE_MASK));
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,i + (Type*HCELL_TYPE_MASK));
        Me->BlockAddress = (ULONG_PTR)NewBin + j;
        Me->BinAddress = (ULONG_PTR)NewBin;
        Me->BinAddress |= HMAP_INPAGEDPOOL;
        // we don't need to set it to NULL - just for debug purposes
        ASSERT( (Me->CmView = NULL) == NULL );

        if (j == 0) {
            //
            // First block of allocation, mark it.
            //
            Me->BinAddress |= HMAP_NEWALLOC;
            Me->MemAlloc = NewSize;
        } else {
            Me->MemAlloc = 0;
        }
        j += HBLOCK_SIZE;
    }

    if( Type == Stable) {
        CmpUpdateSystemHiveHysteresis(Hive,NewLength,OldLength);
    }
    return NewBin;

ErrorExit5:
    if( RemainingBin != NULL ){
        (Hive->Free)(RemainingBin, RemainingBin->Size);
    }
ErrorExit4:
    RtlInitializeBitMap(&Hive->DirtyVector,
                        NewVector,
                        OldLength / HSECTOR_SIZE);
    Hive->DirtyCount = RtlNumberOfSetBits(&Hive->DirtyVector);

ErrorExit3:
    Hive->Storage[Type].Length = OldLength;
    HvpFreeMap(Hive, Dir, OldTable+1, NewTable);

ErrorExit2:
    (Hive->Free)(NewBin, NewSize);

ErrorExit1:
    return NULL;
}

// Dragos: Modified functions
BOOLEAN
HvpCoalesceDiscardedBins(
    IN PHHIVE Hive,
    IN ULONG NeededSize,
    IN HSTORAGE_TYPE Type
    )

/*++

Routine Description:

    Walks through the list of discarded bins and attempts to
    coalesce adjacent discarded bins into one larger bin in
    order to satisfy an allocation request.

    It doesn't coalesce bins over the CM_VIEW_SIZE boundary.

    It doesn't coalesce bins from paged pool with bins mapped in
    system cache views.

Arguments:

    Hive - Supplies pointer to hive control block.

    NeededSize - Supplies size of allocation needed.

    Type - Stable or Volatile

Return Value:

    TRUE - A bin of the desired size was created.

    FALSE - No bin of the desired size could be created.

--*/

{
    PLIST_ENTRY List;
    PFREE_HBIN FreeBin;
    PFREE_HBIN PreviousFreeBin;
    PFREE_HBIN NextFreeBin;
    PHMAP_ENTRY Map;
    PHMAP_ENTRY PreviousMap;
    PHMAP_ENTRY NextMap;
    ULONG MapBlock;

    List = Hive->Storage[Type].FreeBins.Flink;

    while (List != &Hive->Storage[Type].FreeBins) {
        FreeBin = CONTAINING_RECORD(List, FREE_HBIN, ListEntry);

        if ((FreeBin->Flags & FREE_HBIN_DISCARDABLE)==0) {

            Map = HvpGetCellMap(Hive, FreeBin->FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,FreeBin->FileOffset);

            //
            // Scan backwards, coalescing previous discarded bins
            //
            while (FreeBin->FileOffset > 0) {
                PreviousMap = HvpGetCellMap(Hive, FreeBin->FileOffset - HBLOCK_SIZE);
                VALIDATE_CELL_MAP(__LINE__,PreviousMap,Hive,FreeBin->FileOffset - HBLOCK_SIZE);
                if( (BIN_MAP_ALLOCATION_TYPE(Map) != BIN_MAP_ALLOCATION_TYPE(PreviousMap)) || // different allocation type
                    ((PreviousMap->BinAddress & HMAP_DISCARDABLE) == 0) // previous bin is not discardable
                    ){
                    break;
                }
                
                PreviousFreeBin = (PFREE_HBIN)PreviousMap->BlockAddress;

                if (PreviousFreeBin->Flags & FREE_HBIN_DISCARDABLE) {
                    //
                    // this bin has not yet been discarded; can't coalesce with it.
                    //
                    break;
                }
                
                if( HvpCheckViewBoundary(PreviousFreeBin->FileOffset,FreeBin->Size + PreviousFreeBin->Size - 1) == FALSE ) {
                    //
                    // don't coalesce bins over the CM_VIEW_SIZE boundary
                    //
                    // substract 1 because addresses are from 0 to size - 1 !!!
                    //
                    break;
                }

                
                RemoveEntryList(&PreviousFreeBin->ListEntry);

                //
                // Fill in all the old map entries with the new one.
                //
                for (MapBlock = 0; MapBlock < PreviousFreeBin->Size; MapBlock += HBLOCK_SIZE) {
                    PreviousMap = HvpGetCellMap(Hive, PreviousFreeBin->FileOffset + MapBlock);
                    VALIDATE_CELL_MAP(__LINE__,PreviousMap,Hive,PreviousFreeBin->FileOffset + MapBlock);
                    PreviousMap->BlockAddress = (ULONG_PTR)FreeBin;
                }

                FreeBin->FileOffset = PreviousFreeBin->FileOffset;
                FreeBin->Size += PreviousFreeBin->Size;
                (Hive->Free)(PreviousFreeBin, sizeof(FREE_HBIN));
            }

            //
            // Scan forwards, coalescing subsequent discarded bins
            //
            while ((FreeBin->FileOffset + FreeBin->Size) < Hive->BaseBlock->Length) {
                NextMap = HvpGetCellMap(Hive, FreeBin->FileOffset + FreeBin->Size);
                VALIDATE_CELL_MAP(__LINE__,NextMap,Hive,FreeBin->FileOffset + FreeBin->Size);
                if( (BIN_MAP_ALLOCATION_TYPE(Map) != BIN_MAP_ALLOCATION_TYPE(NextMap)) || // different allocation type
                    ((NextMap->BinAddress & HMAP_DISCARDABLE) == 0) // previous bin is not discardable
                    ){
                    break;
                }
                NextFreeBin = (PFREE_HBIN)NextMap->BlockAddress;

                if (NextFreeBin->Flags & FREE_HBIN_DISCARDABLE) {
                    //
                    // this bin has not yet been discarded; can't coalesce with it.
                    //
                    break;
                }

                if( HvpCheckViewBoundary(FreeBin->FileOffset,FreeBin->Size + NextFreeBin->Size - 1) == FALSE ) {
                    //
                    // don't coalesce bins over the CM_VIEW_SIZE boundary
                    //
                    // substract 1 because addresses are from 0 to size - 1 !!!
                    //
                    break;
                }
                RemoveEntryList(&NextFreeBin->ListEntry);

                //
                // Fill in all the old map entries with the new one.
                //
                for (MapBlock = 0; MapBlock < NextFreeBin->Size; MapBlock += HBLOCK_SIZE) {
                    NextMap = HvpGetCellMap(Hive, NextFreeBin->FileOffset + MapBlock);
                    VALIDATE_CELL_MAP(__LINE__,NextMap,Hive,NextFreeBin->FileOffset + MapBlock);
                    NextMap->BlockAddress = (ULONG_PTR)FreeBin;
                }

                FreeBin->Size += NextFreeBin->Size;
                (Hive->Free)(NextFreeBin, sizeof(FREE_HBIN));
            }
            if (FreeBin->Size >= NeededSize) {
                return(TRUE);
            }
        }
        List=List->Flink;
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmwrapr2.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmwrapr2.c

Abstract:

    This module contains the source for wrapper routines called by the
    hive code, which in turn call the appropriate NT routines.  But not
    callable from user mode.

Author:

    Steven R. Wood (stevewo) 21-Apr-1992

Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpFileSetSize)
#endif

extern  KEVENT StartRegistryCommand;
extern  KEVENT EndRegistryCommand;

//
// Write-Control:
//  CmpNoWrite is initially true.  When set this way write and flush
//  do nothing, simply returning success.  When cleared to FALSE, I/O
//  is enabled.  This change is made after the I/O system is started
//  AND autocheck (chkdsk) has done its thing.
//

extern  BOOLEAN CmpNoWrite;


BOOLEAN
CmpFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize,
    ULONG       OldFileSize
    )
/*++

Routine Description:

    This routine sets the size of a file.  It must not return until
    the size is guaranteed, therefore, it does a flush.

    It is environment specific.

    This routine will force execution to the correct thread context.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileSize - 32 bit value to set the file's size to

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    NTSTATUS    status;

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // Call the worker to do real work for us.
    //
    status = CmpDoFileSetSize(Hive,FileType,FileSize,OldFileSize);
    
    if (!NT_SUCCESS(status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpFileSetSize:\n\t"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Failure: status = %08lx ", status));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hivecell.c ===
//depot/main/Base/ntos/config/hivecell.c#14 - integrate change 19035 (text)
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivecell.c

Abstract:

    This module implements hive cell procedures.

Author:

    Bryan M. Willman (bryanwi) 27-Mar-92

Environment:


Revision History:
    Dragos C. Sambotin (dragoss) 22-Dec-98
        Requests for cells bigger than 1K are doubled. This way 
        we avoid fragmentation and we make the value-growing 
        process more flexible.
    Dragos C. Sambotin (dragoss) 13-Jan-99
        At boot time, order the free cells list ascending.

--*/

#include    "cmp.h"

//
// Private procedures
//
HCELL_INDEX
HvpDoAllocateCell(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity
    );

ULONG
HvpAllocateInBin(
    PHHIVE  Hive,
    PHBIN   Bin,
    ULONG   Size,
    ULONG   Type
    );

BOOLEAN
HvpIsFreeNeighbor(
    PHHIVE  Hive,
    PHBIN   Bin,
    PHCELL  FreeCell,
    PHCELL  *FreeNeighbor,
    HSTORAGE_TYPE Type
    );

VOID
HvpDelistBinFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    HSTORAGE_TYPE Type
    );

#define SIXTEEN_K   0x4000

//  Double requests bigger  than 1KB                       
//  CmpSetValueKeyExisting  always allocates a bigger data 
//  value cell  exactly the required size. This creates    
//  problems when somebody  slowly grows a value one DWORD 
//  at a time to  some enormous size. An easy fix for this 
//  would be to set a  certain threshold (like 1K). Once a 
//  value size  crosses that threshold, allocate a new cell
//  that is twice  the old size. So the actual allocated   
//  size  would grow to 1k, then 2k, 4k, 8k, 16k, 32k,etc. 
//  This will reduce the fragmentation.                    
//
// Note:
//  For 5.1, this needs to be coherent with CM_KEY_VALUE_BIG
// 
//


#define HvpAdjustCellSize(Size)                                         \
    {                                                                   \
        ULONG   onek = SIXTEEN_K;                                       \
        ULONG   Limit = 0;                                              \
                                                                        \
        while( Size > onek ) {                                          \
            onek<<=1;                                                   \
            Limit++;                                                    \
        }                                                               \
                                                                        \
        Size = Limit?onek:Size;                                         \
    }   

extern  BOOLEAN HvShutdownComplete;     // Set to true after shutdown
                                        // to disable any further I/O


//#define CM_CHECK_FREECELL_LEAKS
#ifdef CM_CHECK_FREECELL_LEAKS
VOID
HvpCheckBinForFreeCell(
    PHHIVE          Hive,
    PHBIN           Bin,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type
    );

VOID
HvpCheckFreeCells(  PHHIVE          Hive,
                    ULONG           NewSize,
                    HSTORAGE_TYPE   Type
                    );
#endif //CM_CHECK_FREECELL_LEAKS

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpGetHCell)
#pragma alloc_text(PAGE,HvpGetCellMapped)
#pragma alloc_text(PAGE,HvpReleaseCellMapped)
#pragma alloc_text(PAGE,HvpGetCellPaged)
#pragma alloc_text(PAGE,HvpGetCellFlat)
#pragma alloc_text(PAGE,HvpGetCellMap)
#pragma alloc_text(PAGE,HvGetCellSize)
#pragma alloc_text(PAGE,HvAllocateCell)
#pragma alloc_text(PAGE,HvpDoAllocateCell)
#pragma alloc_text(PAGE,HvFreeCell)
#pragma alloc_text(PAGE,HvpIsFreeNeighbor)
#pragma alloc_text(PAGE,HvpEnlistFreeCell)
#pragma alloc_text(PAGE,HvpDelistFreeCell)
#pragma alloc_text(PAGE,HvReallocateCell)
#pragma alloc_text(PAGE,HvIsCellAllocated)
#pragma alloc_text(PAGE,HvpAllocateInBin)
#pragma alloc_text(PAGE,HvpDelistBinFreeCells)

#ifdef NT_RENAME_KEY
#pragma alloc_text(PAGE,HvDuplicateCell)
#endif

#ifdef CM_CHECK_FREECELL_LEAKS
#pragma alloc_text(PAGE,HvpCheckBinForFreeCell)
#pragma alloc_text(PAGE,HvpCheckFreeCells)
#endif //CM_CHECK_FREECELL_LEAKS

#pragma alloc_text(PAGE,HvAutoCompressCheck)
#pragma alloc_text(PAGE,HvShiftCell)

#endif

#ifdef CM_CHECK_FREECELL_LEAKS
VOID
HvpCheckBinForFreeCell(
    PHHIVE          Hive,
    PHBIN           Bin,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type
    )
{
    PHCELL  p;
    ULONG   celloffset;
    ULONG   size;
    ULONG   Index1,Index2;
    HCELL_INDEX cellindex;
    ULONG   BinOffset = Bin->FileOffset;


    //
    // Scan all the cells in the bin, total free and allocated, check
    // for impossible pointers.
    //
    celloffset = sizeof(HBIN);
    p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

    while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

        //
        // if free cell, check it out, add it to free list for hive
        //
        if (p->Size >= 0) {

            size = (ULONG)p->Size;

            if ( (size > Bin->Size)               ||
                 ( (PHCELL)(size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) ) ||
                 ((size % HCELL_PAD(Hive)) != 0) ||
                 (size == 0) )
            {
                return;
            }


            //
            // cell is free, and is not obviously corrupt, add to free list
            //
            celloffset = (ULONG)((PUCHAR)p - (PUCHAR)Bin);
            cellindex = BinOffset + celloffset;

            if( size >= NewSize ) {
                //
                // we found a free cell which was not detected by HvpFindFreeCell
                //
                HvpComputeIndex(Index1, size);
                HvpComputeIndex(Index2, NewSize);
                DbgPrint("HvpCheckBinForFreeCell: Free cell not found! %lx, Index1 = %lu Index2= %lu\n",cellindex,Index1,Index2);
                DbgBreakPoint();
            }


        } else {

            size = (ULONG)(p->Size * -1);

            if ( (size > Bin->Size)               ||
                 ( (PHCELL)(size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) ) ||
                 ((size % HCELL_PAD(Hive)) != 0) ||
                 (size == 0) )
            {
                return;
            }

        }

        ASSERT( ((LONG)size) >= 0);
        p = (PHCELL)((PUCHAR)p + size);
    }

}

VOID
HvpCheckFreeCells(  PHHIVE          Hive,
                    ULONG           NewSize,
                    HSTORAGE_TYPE   Type
                    )
{
    HCELL_INDEX p;
    ULONG       Length;
    PHMAP_ENTRY t;
    PHBIN       Bin;
    PFREE_HBIN  FreeBin;


    p = 0x80000000 * Type;     

    Length = Hive->Storage[Type].Length;

    //
    // for each bin in the space
    //
    while (p < Length) {
        t = HvpGetCellMap(Hive, p);
        if (t == NULL) {
            DbgPrint("HvpCheckFreeCells: Couldn't get map for %lx\n",p);
            return;
        }

    
        if( (t->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0) {
            //
            // view is not mapped, neither in paged pool
            // try to map it.
            //
        
            if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,p,FALSE)) ) {
                //
                // we cannot map this bin due to insufficient resources. 
                //
                DbgPrint("HvpCheckFreeCells: Couldn't map bin for %lx\n",p);
                return;
            }
        }

        if ((t->BinAddress & HMAP_DISCARDABLE) == 0) {

            Bin = (PHBIN)HBIN_BASE(t->BinAddress);

            //
            // bin header valid?
            //
            if ( (Bin->Size > Length)                           ||
                 (Bin->Signature != HBIN_SIGNATURE)             ||
                 (Bin->FileOffset != p)
               )
            {
                DbgPrint("HvpCheckFreeCells: Invalid bin header for bin %p\n",Bin);
                return;
            }

            //
            // structure inside the bin valid?
            //
            HvpCheckBinForFreeCell(Hive, Bin, NewSize,Type);

            p = (ULONG)p + Bin->Size;

        } else {
            //
            // Bin is not present, skip it and advance to the next one.
            //
            FreeBin = (PFREE_HBIN)t->BlockAddress;
            p+=FreeBin->Size;
        }
    }

}
#endif //CM_CHECK_FREECELL_LEAKS


PHCELL
HvpGetHCell(PHHIVE      Hive,
            HCELL_INDEX Cell
            )
/*++

Routine Description:

    Had to make it a function instead of a macro, because HvGetCell
    might fail now.

Arguments:

Return Value:

--*/
{                                                   
    PCELL_DATA pcell;                               
    pcell = HvGetCell(Hive,Cell);                   
    if( pcell == NULL ) {
        //
        // we couldn't map view for this cell
        //
        return NULL;
    }

    return 
        ( USE_OLD_CELL(Hive) ?                      
          CONTAINING_RECORD(pcell,                  
                            HCELL,                  
                            u.OldCell.u.UserData) : 
          CONTAINING_RECORD(pcell,                  
                            HCELL,                  
                            u.NewCell.u.UserData)); 
}

// Dragos: Changed functions!
//
//  Cell Procedures
//

#ifndef _CM_LDR_

VOID
HvpReleaseCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    This routine should never be called directly, always call it
    via the HvReleaseCell() macro.
    
    This routine is intended to work with mapped hives. It is intended
    to prevent views that are still in use to get unmapped

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:
    
      none

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    PHCELL          pcell;
    PHMAP_ENTRY     Map;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvpReleaseCellMapped:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);
    ASSERT_CM_LOCK_OWNED();
    #if DBG
        if (HvGetCellType(Cell) == Stable) {
            ASSERT(Cell >= sizeof(HBIN));
        } else {
            ASSERT(Cell >= (HCELL_TYPE_MASK + sizeof(HBIN)));
        }
    #endif

    if( HvShutdownComplete == TRUE ) {
        //
        // at shutdown we need to unmap all views
        //
#if DBG
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpReleaseCellMapped called after shutdown for Hive = %p Cell = %lx\n",Hive,(ULONG)Cell));
#endif
        return;
    }

    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    ASSERT((Cell - (Type * HCELL_TYPE_MASK)) < Hive->Storage[Type].Length);

    Map = &((Hive->Storage[Type].Map)->Directory[Table]->Table[Block]);

    CmLockHiveViews ((PCMHIVE)Hive);

    if( Map->BinAddress & HMAP_INVIEW ) {
        PCM_VIEW_OF_FILE CmView;
        CmView = Map->CmView;
        ASSERT( CmView != NULL );
        ASSERT( CmView->ViewAddress != NULL );
        ASSERT( CmView->UseCount != 0 );

        ASSERT( CmView->UseCount != 0 );

        CmView->UseCount--;
    } else {
        //
        // Bin is in memory (allocated from paged pool) ==> do nothing
        // 
        ASSERT( Map->BinAddress & HMAP_INPAGEDPOOL );
    }

    ASSERT( ((PCMHIVE)Hive)->UseCount != 0 );

    ((PCMHIVE)Hive)->UseCount--;

    CmUnlockHiveViews ((PCMHIVE)Hive);
    
    ASSERT( HBIN_BASE(Map->BinAddress) != 0);
}


struct _CELL_DATA *
HvpGetCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    This routine should never be called directly, always call it
    via the HvGetCell() macro.
    
    This routine is intended to work with mapped hives.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    PHCELL          pcell;
    PHMAP_ENTRY     Map;
    LONG            Size;
    PUCHAR          FaultAddress;
    PUCHAR          EndOfCell;
    UCHAR           TmpChar;
    PHBIN           Bin;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvGetCellPaged:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);
    ASSERT_CM_LOCK_OWNED();
    #if 0
        if (HvGetCellType(Cell) == Stable) {
            ASSERT(Cell >= sizeof(HBIN));
        } else {
            ASSERT(Cell >= (HCELL_TYPE_MASK + sizeof(HBIN)));
        }
    #endif

    if( HvShutdownComplete == TRUE ) {
        //
        // at shutdown we need to unmap all views
        //
#if DBG
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpGetCellMapped called after shutdown for Hive = %p Cell = %lx\n",Hive,(ULONG)Cell));
#endif
        return NULL;
    }

    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    ASSERT((Cell - (Type * HCELL_TYPE_MASK)) < Hive->Storage[Type].Length);

    Map = &((Hive->Storage[Type].Map)->Directory[Table]->Table[Block]);

    CmLockHiveViews ((PCMHIVE)Hive);

    if( Map->BinAddress & HMAP_INPAGEDPOOL ) {
        //
        // Bin is in memory (allocated from paged pool) ==> do nothing
        // 
    } else {
        PCM_VIEW_OF_FILE CmView;
        //
        // bin is either mapped, or invalid
        //
        ASSERT( Type == Stable );

        if( (Map->BinAddress & HMAP_INVIEW) == 0 ) {
            //
            // map the bin
            //
            if( !NT_SUCCESS (CmpMapCmView((PCMHIVE)Hive,Cell/*+HBLOCK_SIZE*/,&CmView,TRUE) ) ) {
                //
                // caller of HvGetCell should raise an STATUS_INSUFFICIENT_RESOURCES 
                // error as a result of this.!!!!
                //
                CmUnlockHiveViews ((PCMHIVE)Hive);
                return NULL;
            }
            
#if DBG
            if(CmView != Map->CmView) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmView = %p Map->CmView = %p\n",CmView,Map->CmView));
            }
#endif

            ASSERT( CmView == Map->CmView );
        } else {
            CmView = Map->CmView;
        }
        
        //
        // touch the view
        //
        CmpTouchView((PCMHIVE)Hive,CmView,(ULONG)Cell);
        //
        // don't hurt ourselves if not neccessary
        //
        if(Hive->ReleaseCellRoutine) CmView->UseCount++;
    }

    //
    // don't hurt ourselves if not neccessary
    //
    if(Hive->ReleaseCellRoutine) ((PCMHIVE)Hive)->UseCount++;
    CmUnlockHiveViews ((PCMHIVE)Hive);
    
    ASSERT( HBIN_BASE(Map->BinAddress) != 0);
    ASSERT((Map->BinAddress & HMAP_DISCARDABLE) == 0);

#ifdef CM_CHECK_MAP_NO_READ_SCHEME
    if( Map->BinAddress & HMAP_INVIEW ) {
        PHMAP_ENTRY     TempMap;

        Bin = (PHBIN)HBIN_BASE(Map->BinAddress);
        ASSERT( Bin->Signature == HBIN_SIGNATURE );
        TempMap = HvpGetCellMap(Hive, Bin->FileOffset);
        VALIDATE_CELL_MAP(__LINE__,TempMap,Hive,Bin->FileOffset);
        ASSERT( TempMap->BinAddress & HMAP_NEWALLOC );

    }
#endif //CM_CHECK_MAP_NO_READ_SCHEME

    pcell = (PHCELL)((ULONG_PTR)(Map->BlockAddress) + Offset);

    PERFINFO_HIVECELL_REFERENCE_PAGED(Hive, pcell, Cell, Type, Map);

#ifdef CM_MAP_NO_READ
    //
    // we need to make sure all the cell's data is faulted in inside a 
    // try/except block, as the IO to fault the data in can throw exceptions
    // STATUS_INSUFFICIENT_RESOURCES, in particular
    //

    try {
        //
        // this will fault in the first page containing the data
        //
        Size = pcell->Size;
        if( Size < 0 ) {
            Size *= -1;
        }
        //
        // check for bogus size
        //
        Bin = (PHBIN)HBIN_BASE(Map->BinAddress);
        if ( (Offset + (ULONG)Size) > Bin->Size ) {
            //
            // runs off bin; disallow access to this cell
            //
            //
            // restore the usecounts
            //
            CmLockHiveViews ((PCMHIVE)Hive);
            if( (Map->BinAddress & HMAP_INPAGEDPOOL) == 0 ) {
                ASSERT( Map->CmView != NULL );
                if(Hive->ReleaseCellRoutine) Map->CmView->UseCount--;
            }
            if(Hive->ReleaseCellRoutine) ((PCMHIVE)Hive)->UseCount--;
            CmUnlockHiveViews ((PCMHIVE)Hive);

            return NULL;

        }

        //
        // Now stand here like a man and fault in all pages storing cell's data
        //
        EndOfCell = (PUCHAR)((PUCHAR)pcell + Size);
        FaultAddress = (PUCHAR)((PUCHAR)(Map->BlockAddress) + ROUND_UP(Offset,PAGE_SIZE)); 

        while( FaultAddress < EndOfCell ) {
            TmpChar = *FaultAddress;
            FaultAddress += PAGE_SIZE;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpGetCellMapped: exception thrown while faulting in data, code:%08lx\n", GetExceptionCode()));

        //
        // restore the usecounts
        //
        CmLockHiveViews ((PCMHIVE)Hive);
        if( (Map->BinAddress & HMAP_INPAGEDPOOL) == 0 ) {
            ASSERT( Map->CmView != NULL );
            if(Hive->ReleaseCellRoutine) Map->CmView->UseCount--;
        }
        if(Hive->ReleaseCellRoutine) ((PCMHIVE)Hive)->UseCount--;
        CmUnlockHiveViews ((PCMHIVE)Hive);

        return NULL;
    }
#endif //CM_MAP_NO_READ


    if (USE_OLD_CELL(Hive)) {
        return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
}
#else
//
// these functions are just stubs for the loader
//
VOID
HvpReleaseCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
{
}

struct _CELL_DATA *
HvpGetCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
{
    return NULL;
}

#endif //_CM_LDR_

struct _CELL_DATA *
HvpGetCellPaged(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for hives with full maps.
    It is the normal version of the routine.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    PHCELL          pcell;
    PHMAP_ENTRY     Map;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvGetCellPaged:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);
    ASSERT_CM_LOCK_OWNED();
    #if DBG
        if (HvGetCellType(Cell) == Stable) {
            ASSERT(Cell >= sizeof(HBIN));
        } else {
            ASSERT(Cell >= (HCELL_TYPE_MASK + sizeof(HBIN)));
        }
    #endif

    if( HvShutdownComplete == TRUE ) {
        //
        // at shutdown we need to unmap all views
        //
#if DBG
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpGetCellPaged called after shutdown for Hive = %p Cell = %lx\n",Hive,(ULONG)Cell));
#endif
        return NULL;
    }

    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    ASSERT((Cell - (Type * HCELL_TYPE_MASK)) < Hive->Storage[Type].Length);

    Map = &((Hive->Storage[Type].Map)->Directory[Table]->Table[Block]);
    //
    // it is ilegal to call this routine for mapped hives
    //
    ASSERT( Map->BinAddress & HMAP_INPAGEDPOOL );

    ASSERT( HBIN_BASE(Map->BinAddress) != 0);
    ASSERT((Map->BinAddress & HMAP_DISCARDABLE) == 0);

    pcell = (PHCELL)((ULONG_PTR)(Map->BlockAddress) + Offset);

    PERFINFO_HIVECELL_REFERENCE_PAGED(Hive, pcell, Cell, Type, Map);

    if (USE_OLD_CELL(Hive)) {
        return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
}

VOID
HvpEnlistFreeCell(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Size,
    HSTORAGE_TYPE   Type,
    BOOLEAN         CoalesceForward
    )
/*++

Routine Description:

    Puts the newly freed cell on the appropriate list.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies index of cell to enlist

    Size - size of cell

    Type - indicates whether Stable or Volatile storage is desired.

    CoalesceForward - indicates whether we can coalesce forward or not.
        For the case where we have not finished scanning the hive and
        enlisting free cells, we do not want to coalesce forward.

Return Value:

    NONE.

--*/
{
    PHMAP_ENTRY Map;
    PHCELL      pcell;
    PHCELL      pcellLast;
    PHCELL      FirstCell;
    ULONG       Index;
    PHBIN       Bin;
    HCELL_INDEX FreeCell;
    PFREE_HBIN  FreeBin;
    PHBIN       FirstBin;
    PHBIN       LastBin;
    ULONG       FreeOffset;

    HvpComputeIndex(Index, Size);

    
#ifdef  HV_TRACK_FREE_SPACE
	Hive->Storage[Type].FreeStorage += Size;
	ASSERT( Hive->Storage[Type].FreeStorage <= Hive->Storage[Type].Length );
#endif
    
    //
    // the HvpGetHCell call bellow touches the view containing the cell, 
    // and makes sure the CM_VIEW_SIZE window is mapped in the system cache
    //
    pcell = HvpGetHCell(Hive, Cell);
    if( pcell == NULL ) {
        //
        // we couldn't map view for this cell
        // this shouldn't happen as the cell here is already marked dirty
        // or it's entire bin is mapped 
        //
        ASSERT( FALSE);
        return;
    }

    //
    // if we are here; we were called from HvInitializeHive, or with reglock 
    // held exclusive; therefore it is safe to release the cell here
    //
    HvReleaseCell(Hive,Cell);
    
    ASSERT(pcell->Size > 0);
    ASSERT(Size == (ULONG)pcell->Size);


    //
    // Check to see if this is the first cell in the bin and if the entire
    // bin consists just of this cell.
    //

    Map = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Map,Hive,Cell);
    ASSERT_BIN_VALID(Map);

    Bin = (PHBIN)HBIN_BASE(Map->BinAddress);
    if ((pcell == (PHCELL)(Bin + 1)) &&
        (Size == Bin->Size-sizeof(HBIN))) {

        //
        // We have a bin that is entirely free.  But we cannot do anything with it
        // unless the memalloc that contains the bin is entirely free.  Walk the
        // bins backwards until we find the first one in the alloc, then walk forwards
        // until we find the last one.  If any of the other bins in the memalloc
        // are not free, bail out.
        //
        FirstBin = Bin;
        while ( HvpGetBinMemAlloc(Hive,FirstBin,Type) == 0) {
            Map=HvpGetCellMap(Hive,(FirstBin->FileOffset - HBLOCK_SIZE) +
                                   (Type * HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,(FirstBin->FileOffset - HBLOCK_SIZE) +(Type * HCELL_TYPE_MASK));
            ASSERT_BIN_VALID(Map);
            FirstBin = (PHBIN)HBIN_BASE(Map->BinAddress);
            FirstCell = (PHCELL)(FirstBin+1);
            if ((ULONG)(FirstCell->Size) != FirstBin->Size-sizeof(HBIN)) {
                //
                // The first cell in the bin is either allocated, or not the only
                // cell in the HBIN.  We cannot free any HBINs.
                //
                goto Done;
            }
        }

        //
        // We can never discard the first bin of a hive as that always gets marked dirty
        // and written out.
        //
        if (FirstBin->FileOffset == 0) {
            goto Done;
        }

        LastBin = Bin;
        while (LastBin->FileOffset+LastBin->Size < FirstBin->FileOffset + HvpGetBinMemAlloc(Hive,FirstBin,Type)) {
            if (!CoalesceForward) {
                //
                // We are at the end of what's been built up. Just return and this
                // will get freed up when the next HBIN is added.
                //
                goto Done;
            }
            Map = HvpGetCellMap(Hive, (LastBin->FileOffset+LastBin->Size) +
                                      (Type * HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,(LastBin->FileOffset+LastBin->Size) + (Type * HCELL_TYPE_MASK));

            ASSERT(Map->BinAddress != 0);

            LastBin = (PHBIN)HBIN_BASE(Map->BinAddress);
            FirstCell = (PHCELL)(LastBin + 1);
            if ((ULONG)(FirstCell->Size) != LastBin->Size-sizeof(HBIN)) {
                //
                // The first cell in the bin is either allocated, or not the only
                // cell in the HBIN.  We cannot free any HBINs.
                //
                goto Done;
            }
        }

        //
        // All the bins in this alloc are freed.  Coalesce all the bins into
        // one alloc-sized bin, then either discard the bin or mark it as
        // discardable.
        //
        if (FirstBin->Size != HvpGetBinMemAlloc(Hive,FirstBin,Type)) {
            //
            // Mark the first HBLOCK of the first HBIN dirty, since
            // we will need to update the on disk field for the bin size
            //
            if (!HvMarkDirty(Hive,
                             FirstBin->FileOffset + (Type * HCELL_TYPE_MASK),
                             sizeof(HBIN) + sizeof(HCELL),FALSE)) {
                goto Done;
            }

        }


        FreeBin = (Hive->Allocate)(sizeof(FREE_HBIN), FALSE,CM_FIND_LEAK_TAG7);
        if (FreeBin == NULL) {
            goto Done;
        }

        //
        // Walk through the bins and delist each free cell
        //
        Bin = FirstBin;
        do {
            FirstCell = (PHCELL)(Bin+1);
            HvpDelistFreeCell(Hive, Bin->FileOffset + (ULONG)((PUCHAR)FirstCell - (PUCHAR)Bin) + (Type*HCELL_TYPE_MASK), Type);
            if (Bin==LastBin) {
                break;
            }
            Map = HvpGetCellMap(Hive, (Bin->FileOffset+Bin->Size)+
                                      (Type * HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,(Bin->FileOffset+Bin->Size)+(Type * HCELL_TYPE_MASK));
            Bin = (PHBIN)HBIN_BASE(Map->BinAddress);

        } while ( TRUE );

        //
        // Coalesce them all into one bin.
        //
        FirstBin->Size = HvpGetBinMemAlloc(Hive,FirstBin,Type);

        FreeBin->Size = FirstBin->Size;
        FreeBin->FileOffset = FirstBin->FileOffset;
        FirstCell = (PHCELL)(FirstBin+1);
        FirstCell->Size = FirstBin->Size - sizeof(HBIN);
        if (USE_OLD_CELL(Hive)) {
            FirstCell->u.OldCell.Last = (ULONG)HBIN_NIL;
        }

        InsertHeadList(&Hive->Storage[Type].FreeBins, &FreeBin->ListEntry);
        ASSERT_LISTENTRY(&FreeBin->ListEntry);
        ASSERT_LISTENTRY(FreeBin->ListEntry.Flink);

#ifdef  HV_TRACK_FREE_SPACE
	    Hive->Storage[Type].FreeStorage += (FirstBin->Size - sizeof(HBIN));
	    ASSERT( Hive->Storage[Type].FreeStorage <= Hive->Storage[Type].Length );
#endif

        FreeCell = FirstBin->FileOffset+(Type*HCELL_TYPE_MASK);
        Map = HvpGetCellMap(Hive, FreeCell);
        VALIDATE_CELL_MAP(__LINE__,Map,Hive,FreeCell);
        if( Map->BinAddress & HMAP_INPAGEDPOOL ) {
            //
            // the bin is allocated from paged pool; 
            // mark the free bin as not discarded; paged pool will be freed when the bin is 
            // discarded
            //
            FreeBin->Flags = FREE_HBIN_DISCARDABLE;
        } else {
            //
            // bin is not allocated from paged pool; mark it as already discarded
            //
            FreeBin->Flags = 0;
        }

        FreeOffset = 0;
        while (FreeOffset < FirstBin->Size) {
            Map = HvpGetCellMap(Hive, FreeCell);
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,FreeCell);
            //
            // adjust the bin address, but make sure to preserve the mapping flags
            // i.e. : if the view containing this bin is mapped into memory, add the flag
            //
            if (Map->BinAddress & HMAP_NEWALLOC) {
                Map->BinAddress = (ULONG_PTR)FirstBin | HMAP_DISCARDABLE | HMAP_NEWALLOC | BIN_MAP_ALLOCATION_TYPE(Map);
            } else {
                Map->BinAddress = (ULONG_PTR)FirstBin | HMAP_DISCARDABLE | BIN_MAP_ALLOCATION_TYPE(Map);
            }
            Map->BlockAddress = (ULONG_PTR)FreeBin;
            FreeCell += HBLOCK_SIZE;
            FreeOffset += HBLOCK_SIZE;
        }
		//
		// don't change the hints, we haven't added any free cell !!!
		//
		return;
    }


Done:
    HvpAddFreeCellHint(Hive,Cell,Index,Type);
    return;
}


VOID
HvpDelistFreeCell(
    PHHIVE  Hive,
    HCELL_INDEX  Cell,
    HSTORAGE_TYPE Type
    )
/*++

Routine Description:

    Updates the FreeSummary and FreeDisplay at the index corresponding to this cell

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies the cell index for the free cell to delist

    Type - Stable vs. Volatile

Return Value:

    NONE.

--*/
{
    PHCELL      pcell;
    ULONG       Index;
    
    pcell = HvpGetHCell(Hive, Cell);
    if( pcell == NULL ) {
        //
        // we couldn't map view for this cell
        // this shouldn't happen as the cell here is already marked dirty
        // or it's entire bin is mapped 
        //
        ASSERT( FALSE);
        return;
    }

    //
    // if we are here; we were called from HvInitializeHive, or with reglock 
    // held exclusive; therefore it is safe to release the cell here
    //
    HvReleaseCell(Hive,Cell);

    ASSERT(pcell->Size > 0);

    HvpComputeIndex(Index, pcell->Size);

#ifdef  HV_TRACK_FREE_SPACE
	Hive->Storage[Type].FreeStorage -= pcell->Size;
	ASSERT( (LONG)(Hive->Storage[Type].FreeStorage) >= 0 );
#endif

    HvpRemoveFreeCellHint(Hive,Cell,Index,Type);
   
    return;
}

HCELL_INDEX
HvAllocateCell(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    )
/*++

Routine Description:

    Allocates the space and the cell index for a new cell.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    NewSize - size in bytes of the cell to allocate

    Type - indicates whether Stable or Volatile storage is desired.

Return Value:

    New HCELL_INDEX if success, HCELL_NIL if failure.

--*/
{
    HCELL_INDEX NewCell;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvAllocateCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p NewSize=%08lx\n",Hive,NewSize));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);


    //
    // Make room for overhead fields and round up to HCELL_PAD boundary
    //
    if (USE_OLD_CELL(Hive)) {
        NewSize += FIELD_OFFSET(HCELL, u.OldCell.u.UserData);
    } else {
        NewSize += FIELD_OFFSET(HCELL, u.NewCell.u.UserData);
    }
    NewSize = ROUND_UP(NewSize, HCELL_PAD(Hive));

    // 
    // Adjust the size (an easy fix for granularity)
    //
    HvpAdjustCellSize(NewSize);
    //
    // reject impossible/unreasonable values
    //
    if (NewSize > HSANE_CELL_MAX) {
        return HCELL_NIL;
    }

    //
    // Do the actual storage allocation
    //
    NewCell = HvpDoAllocateCell(Hive, NewSize, Type, Vicinity);

#if DBG
    if (NewCell != HCELL_NIL) {
        ASSERT(HvIsCellAllocated(Hive, NewCell));
    }
#endif


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tNewCell=%08lx\n", NewCell));
    return NewCell;
}

HCELL_INDEX
HvpDoAllocateCell(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity
    )
/*++

Routine Description:

    Allocates space in the hive.  Does not affect cell map in any way.

    If Vicinity is not NIL, it defines the "window" where the new cell
    to be allocated (if one free is found). The window is ensured by 
    looking for a free cell of the desired size:

    1st - in the same CM_VIEW_SIZE window with the Vicinity cell.

Abstract:

    This first version allocates a new bin if a cell free cell big enough 
    cannot be found in the specified window. 
    
Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    NewSize - size in bytes of the cell to allocate

    Type - indicates whether Stable or Volatile storage is desired.
    
    Vicinity - the starting cell which defines the vicinity of the new 
                allocated cell.

Return Value:

    HCELL_INDEX of new cell, HCELL_NIL if failure

--*/
{
    ULONG       Index;
    HCELL_INDEX cell;
    PHCELL      pcell;
    HCELL_INDEX tcell;
    PHCELL      ptcell;
    PHBIN       Bin;
    PHMAP_ENTRY Me;
    ULONG       offset;
    PHCELL      next;
    ULONG       MinFreeSize;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvDoAllocateCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p NewSize=%08lx Type=%08lx\n",Hive,NewSize,Type));
    ASSERT(Hive->ReadOnly == FALSE);

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);


    //
    // Compute Index into Display
    //
    HvpComputeIndex(Index, NewSize);

#if DBG
    {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpDoAllocateCell] CellSize = %lu Vicinity = %lx :: Hive (%p) (%.*S)  ...\n",
            NewSize,Vicinity,Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
    }
#endif
    cell = HvpFindFreeCell(Hive,Index,NewSize,Type,Vicinity);
    if( cell != HCELL_NIL ) {
        //
        // found it !
        //
        pcell = HvpGetHCell(Hive, cell);
        if( pcell == NULL ) {
            //
            // we couldn't map view for this cell
            // this shouldn't happen as the cell here is already marked dirty
            // or it's entire bin is mapped 
            //
            ASSERT( FALSE);
            return HCELL_NIL;
        }
        
        // we are safe to release the cell here as the reglock is held exclusive
        HvReleaseCell(Hive,cell);

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL," found cell at index = %lx size = %lu \n",cell,pcell->Size));
        goto UseIt;
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL," not found\n"));
        //
        // No suitable cells were found on any free list.
        //
        // Either there is no large enough cell, or we
        // have no free cells left at all.  In either case, allocate a
        // new bin, with a new free cell certain to be large enough in
        // it, and use that cell.
        //

#ifdef CM_CHECK_FREECELL_LEAKS
        HvpCheckFreeCells(Hive,NewSize,Type);
#endif //CM_CHECK_FREECELL_LEAKS

        //
        // Attempt to create a new bin
        //
        if ((Bin = HvpAddBin(Hive, NewSize, Type)) != NULL) {

            //
            // It worked.  Use single large cell in Bin.
            //
            DHvCheckBin(Hive,Bin);
            cell = (Bin->FileOffset) + sizeof(HBIN) + (Type*HCELL_TYPE_MASK);
            pcell = HvpGetHCell(Hive, cell);
            if( pcell == NULL ) {
                //
                // we couldn't map view for this cell
                // this shouldn't happen as the entire bin is mapped 
                //
                ASSERT( FALSE);
                return HCELL_NIL;
            }

            // we are safe to release the cell here as the reglock is held exclusive
            HvReleaseCell(Hive,cell);

        } else {
            return HCELL_NIL;
        }
    }

UseIt:

    //
    // cell refers to a free cell we have pulled from its list
    // if it is too big, give the residue back
    // ("too big" means there is at least one HCELL of extra space)
    // always mark it allocated
    // return it as our function value
    //

    ASSERT(pcell->Size > 0);
    if (USE_OLD_CELL(Hive)) {
        MinFreeSize = FIELD_OFFSET(HCELL, u.OldCell.u.Next) + sizeof(HCELL_INDEX);
    } else {
        MinFreeSize = FIELD_OFFSET(HCELL, u.NewCell.u.Next) + sizeof(HCELL_INDEX);
    }
    if ((NewSize + MinFreeSize) <= (ULONG)pcell->Size) {

        //
        // Crack the cell, use part we need, put rest on
        // free list.
        //

        Me = HvpGetCellMap(Hive, cell);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,cell);
        //
        // at this point we are sure that the bin is in memory ??????
        //
        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
        offset = (ULONG)((ULONG_PTR)pcell - (ULONG_PTR)Bin);

        ptcell = (PHCELL)((PUCHAR)pcell + NewSize);
        if (USE_OLD_CELL(Hive)) {
            ptcell->u.OldCell.Last = offset;
        }
        ptcell->Size = pcell->Size - NewSize;

        if ((offset + pcell->Size) < Bin->Size) {
            next = (PHCELL)((PUCHAR)pcell + pcell->Size);
            if (USE_OLD_CELL(Hive)) {
                next->u.OldCell.Last = offset + NewSize;
            }
        }

        pcell->Size = NewSize;
        tcell = (HCELL_INDEX)((ULONG)cell + NewSize);

        HvpEnlistFreeCell(Hive, tcell, ptcell->Size, Type, TRUE);
    }

    //
    // return the cell we found.
    //
#if DBG
    if (USE_OLD_CELL(Hive)) {
        RtlFillMemory(
            &(pcell->u.OldCell.u.UserData),
            (pcell->Size - FIELD_OFFSET(HCELL, u.OldCell.u.UserData)),
            HCELL_ALLOCATE_FILL
            );
    } else {
        RtlFillMemory(
            &(pcell->u.NewCell.u.UserData),
            (pcell->Size - FIELD_OFFSET(HCELL, u.NewCell.u.UserData)),
            HCELL_ALLOCATE_FILL
            );
    }
#endif
    pcell->Size *= -1;

    return cell;
}


//
// Procedure used for checking only  (used in production systems, so
//  must always be here.)
//
BOOLEAN
HvIsCellAllocated(
    PHHIVE Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Report whether the requested cell is allocated or not.

Arguments:

    Hive - containing Hive.

    Cell - cel of interest

Return Value:

    TRUE if allocated, FALSE if not.

--*/
{
    ULONG   Type;
    PHCELL  Address;
    PHCELL  Below;
    PHMAP_ENTRY Me;
    PHBIN   Bin;
    ULONG   Offset;
    LONG    Size;


    ASSERT(Hive->Signature == HHIVE_SIGNATURE);

    if (Hive->Flat == TRUE) {
        return TRUE;
    }

    Type = HvGetCellType(Cell);

    if ( ((Cell & ~HCELL_TYPE_MASK) > Hive->Storage[Type].Length) || // off end
         (Cell % HCELL_PAD(Hive) != 0)                    // wrong alignment
       )
    {
        return FALSE;
    }

    Me = HvpGetCellMap(Hive, Cell);
    if (Me == NULL) {
        return FALSE;
    }
    if( Me->BinAddress & HMAP_DISCARDABLE ) {
        return FALSE;
    }

    //
    // this will bring the CM_VIEW_SIZE window mapping the bin in memory
    //
    Address = HvpGetHCell(Hive, Cell);
    if( Address == NULL ) {
        //
        // we couldn't map view for this cell
        //
        return FALSE;
    }

#ifndef _CM_LDR_
    try {
#endif //_CM_LDR_
        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
        Offset = (ULONG)((ULONG_PTR)Address - (ULONG_PTR)Bin);
        Size = Address->Size * -1;

        if ( (Address->Size >= 0) ||                    // not allocated
             ((Offset + (ULONG)Size) > Bin->Size) ||    // runs off bin, or too big
             (Offset < sizeof(HBIN))                    // pts into bin header
           )
        {
            return FALSE;
        }

        if (USE_OLD_CELL(Hive)) {
            if (Address->u.OldCell.Last != HBIN_NIL) {

                if (Address->u.OldCell.Last > Bin->Size) {            // bogus back pointer
                    return FALSE;
                }

                Below = (PHCELL)((PUCHAR)Bin + Address->u.OldCell.Last);
                Size = (Below->Size < 0) ?
                            Below->Size * -1 :
                            Below->Size;

                if ( ((ULONG_PTR)Below + Size) != (ULONG_PTR)Address ) {    // no pt back
                    return FALSE;
                }
            }
        }
#ifndef _CM_LDR_
    } finally {
        HvReleaseCell(Hive,Cell);
    }
#endif //_CM_LDR_

    return TRUE;
}

VOID
HvpDelistBinFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    HSTORAGE_TYPE Type
    )
/*++

Routine Description:

    If we are here, the hive needs recovery.

    Walks through the entire bin and removes its free cells from the list.
    If the bin is marked as free, it just delist it from the freebins list.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Bin - supplies a pointer to the HBIN of interest

    Type - Stable vs. Volatile

Return Value:

    NONE.

--*/
{
    PHCELL          p;
    ULONG           size;
    HCELL_INDEX     Cell;
    PHMAP_ENTRY     Map;
    PFREE_HBIN      FreeBin;
    PLIST_ENTRY     Entry;
    ULONG           CellOffset;
    HCELL_INDEX     cellindex;
    ULONG           i;
    ULONG           BinIndex;

    Cell = Bin->FileOffset+(Type*HCELL_TYPE_MASK);
    Map = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Map,Hive,Cell);

    //
    // When loading, bins are always in separate chunks (each bin in it's owns chunk)
    //
    ASSERT( HBIN_BASE(Map->BinAddress) == (ULONG_PTR)Bin );
    ASSERT( Map->BinAddress & HMAP_NEWALLOC );
    
    if( Map->BinAddress & HMAP_DISCARDABLE ) {
        //
        // The bin has been added to the freebins list
        // we have to take it out. No free cell from this bin is on the 
        // freecells list, so we don't have to delist them.
        //

        Entry = Hive->Storage[Type].FreeBins.Flink;
        while (Entry != &Hive->Storage[Type].FreeBins) {
            FreeBin = CONTAINING_RECORD(Entry,
                                        FREE_HBIN,
                                        ListEntry);

            
            if( FreeBin->FileOffset == Bin->FileOffset ){
                //
                // that's the bin we're looking for
                //
                
                // sanity checks
                ASSERT( FreeBin->Size == Bin->Size );
                ASSERT_LISTENTRY(&FreeBin->ListEntry);
                
                RemoveEntryList(&FreeBin->ListEntry);
                (Hive->Free)(FreeBin, sizeof(FREE_HBIN));
                //
                // the bin is not discardable anymore
                //
                Map->BinAddress &= (~HMAP_DISCARDABLE);
                return;
            }

            // advance to the new bin
            Entry = Entry->Flink;
        }

        // we shouldn't get here
        CM_BUGCHECK(REGISTRY_ERROR,BAD_FREE_BINS_LIST,1,(ULONG)Cell,(ULONG_PTR)Map);
        return;
    }

    //
    // as for the new way of dealing with free cells, all we have to do 
    // is to clear the bits in the FreeDisplay
    //
    BinIndex = Bin->FileOffset / HBLOCK_SIZE;
    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        RtlClearBits (&(Hive->Storage[Type].FreeDisplay[i]), BinIndex, Bin->Size / HBLOCK_SIZE);
        if( RtlNumberOfSetBits(&(Hive->Storage[Type].FreeDisplay[i]) ) == 0 ) {
            //
            // entire bitmap is 0 (i.e. no other free cells of this size)
            //
            Hive->Storage[Type].FreeSummary &= (~(1 << i));
        }
    }

    return;
}

struct _CELL_DATA *
HvpGetCellFlat(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for read only hives with
    single allocation flat images.  Such hives do not have cell
    maps ("page tables"), instead, we compute addresses by
    arithmetic against the base image address.

    Such hives cannot have volatile cells.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    PUCHAR          base;
    PHCELL          pcell;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvGetCellFlat:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == TRUE);
    ASSERT(HvGetCellType(Cell) == Stable);
    ASSERT(Cell >= sizeof(HBIN));
    ASSERT(Cell < Hive->BaseBlock->Length);
    ASSERT((Cell & 0x7)==0);

    //
    // Address is base of Hive image + Cell
    //
    base = (PUCHAR)(Hive->BaseBlock) + HBLOCK_SIZE;
    pcell = (PHCELL)(base + Cell);

    PERFINFO_HIVECELL_REFERENCE_FLAT(Hive, pcell, Cell);

    if (USE_OLD_CELL(Hive)) {
        return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
}

PHMAP_ENTRY
HvpGetCellMap(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Returns the address of the HMAP_ENTRY for the cell.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return map entry address for

Return Value:

    Address of MAP_ENTRY in memory.  NULL if no such cell or other error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    PHMAP_TABLE     ptab;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvpGetCellMapPaged:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);

    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;

    if ((Cell - (Type * HCELL_TYPE_MASK)) >= Hive->Storage[Type].Length) {
        return NULL;
    }

    ptab = (Hive->Storage[Type].Map)->Directory[Table];
    return &(ptab->Table[Block]);
}


LONG
HvGetCellSize(
    IN PHHIVE   Hive,
    IN PVOID    Address
    )
/*++

Routine Description:

    Returns the size of the specified Cell, based on its MEMORY
    ADDRESS.  Must always call HvGetCell first to get that
    address.

    NOTE:   This should be a macro if speed is issue.

    NOTE:   If you pass in some random pointer, you will get some
            random answer.  Only pass in valid Cell addresses.

Arguments:

    Hive - supplies hive control structure for the given cell

    Address - address in memory of the cell, returned by HvGetCell()

Return Value:

    Allocated size in bytes of the cell.

    If Negative, Cell is free, or Address is bogus.

--*/
{
    LONG    size;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvGetCellSize:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tAddress=%p\n", Address));

    if (USE_OLD_CELL(Hive)) {
        size = ( (CONTAINING_RECORD(Address, HCELL, u.OldCell.u.UserData))->Size ) * -1;
        size -= FIELD_OFFSET(HCELL, u.OldCell.u.UserData);
    } else {
        size = ( (CONTAINING_RECORD(Address, HCELL, u.NewCell.u.UserData))->Size ) * -1;
        size -= FIELD_OFFSET(HCELL, u.NewCell.u.UserData);
    }
    return size;
}

VOID
HvFreeCell(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:


    Frees the storage for a cell.

    NOTE:   CALLER is expected to mark relevent data dirty, so as to
            allow this call to always succeed.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - HCELL_INDEX of Cell to free.

Return Value:

    FALSE - failed, presumably for want of log space.

    TRUE - it worked

--*/
{
    PHBIN           Bin;
    PHCELL          tmp;
    HCELL_INDEX     newfreecell;
    PHCELL          freebase;
    ULONG           savesize;
    PHCELL          neighbor;
    ULONG           Type;
    PHMAP_ENTRY     Me;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvFreeCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->ReadOnly == FALSE);
    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // Get sizes and addresses
    //
    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);
    Type = HvGetCellType(Cell);

    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
    //
    // at this point, bin should be valid (either in memory or in the paged pool)
    //
    ASSERT_BIN_VALID(Me);

    DHvCheckBin(Hive,Bin);
    freebase = HvpGetHCell(Hive, Cell);
    if( freebase == NULL ) {
        //
        // we couldn't map view for this cell
        // this shouldn't happen as the cell here is already marked dirty
        // or it's entire bin is mapped 
        //
        ASSERT( FALSE);
        return;
    }

    //
    // We should hit this if there is any bogus code path where data is modified
    // but not marked as dirty; We could run into a lot of problems if this ASSERT
    // ever fires !!!
    //
    ASSERT_CELL_DIRTY(Hive,Cell);

    // release the cell right here as the reglock is held exclusive
    HvReleaseCell(Hive,Cell);

    //
    // go do actual frees, cannot fail from this point on
    //
    ASSERT(freebase->Size < 0);
    freebase->Size *= -1;

    savesize = freebase->Size;

    //
    // Look for free neighbors and coalesce them.  We will never travel
    // around this loop more than twice.
    //
    while (
        HvpIsFreeNeighbor(
            Hive,
            Bin,
            freebase,
            &neighbor,
            Type
            ) == TRUE
        )
    {

        if (neighbor > freebase) {

            //
            // Neighboring free cell is immediately above us in memory.
            //
            if (USE_OLD_CELL(Hive)) {
                tmp = (PHCELL)((PUCHAR)neighbor + neighbor->Size);
                if ( ((ULONG)((ULONG_PTR)tmp - (ULONG_PTR)Bin)) < Bin->Size) {
                        tmp->u.OldCell.Last = (ULONG)((ULONG_PTR)freebase - (ULONG_PTR)Bin);
                }
            }
            freebase->Size += neighbor->Size;

        } else {

            //
            // Neighboring free cell is immediately below us in memory.
            //

            if (USE_OLD_CELL(Hive)) {
                tmp = (PHCELL)((PUCHAR)freebase + freebase->Size);
                if ( ((ULONG)((ULONG_PTR)tmp - (ULONG_PTR)Bin)) < Bin->Size ) {
                    tmp->u.OldCell.Last = (ULONG)((ULONG_PTR)neighbor - (ULONG_PTR)Bin);
                }
            }
            neighbor->Size += freebase->Size;
            freebase = neighbor;
        }
    }

    //
    // freebase now points to the biggest free cell we could make, none
    // of which is on the free list.  So put it on the list.
    //
    newfreecell = (Bin->FileOffset) +
               ((ULONG)((ULONG_PTR)freebase - (ULONG_PTR)Bin)) +
               (Type*HCELL_TYPE_MASK);

#if DBG
    //
    // entire bin is in memory; no problem to call HvpGetHCell
    //
    ASSERT(HvpGetHCell(Hive, newfreecell) == freebase);
    HvReleaseCell(Hive,newfreecell);

    if (USE_OLD_CELL(Hive)) {
        RtlFillMemory(
            &(freebase->u.OldCell.u.UserData),
            (freebase->Size - FIELD_OFFSET(HCELL, u.OldCell.u.UserData)),
            HCELL_FREE_FILL
            );
    } else {
        RtlFillMemory(
            &(freebase->u.NewCell.u.UserData),
            (freebase->Size - FIELD_OFFSET(HCELL, u.NewCell.u.UserData)),
            HCELL_FREE_FILL
            );
    }
#endif

    HvpEnlistFreeCell(Hive, newfreecell, freebase->Size, Type, TRUE);

    return;
}

BOOLEAN
HvpIsFreeNeighbor(
    PHHIVE  Hive,
    PHBIN   Bin,
    PHCELL  FreeCell,
    PHCELL  *FreeNeighbor,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Reports on whether FreeCell has at least one free neighbor and
    if so where.  Free neighbor will be cut out of the free list.

Arguments:

    Hive - hive we're working on

    Bin - pointer to the storage bin

    FreeCell - supplies a pointer to a cell that has been freed, or
                the result of a coalesce.

    FreeNeighbor - supplies a pointer to a variable to receive the address
                    of a free neigbhor of FreeCell, if such exists

    Type - storage type of the cell

Return Value:

    TRUE if a free neighbor was found, else false.


--*/
{
    PHCELL      ptcell;
    HCELL_INDEX cellindex;
    ULONG       CellOffset;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpIsFreeNeighbor:\n\tBin=%p",Bin));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"FreeCell=%08lx\n", FreeCell));
    ASSERT(Hive->ReadOnly == FALSE);

    //
    // Neighbor above us?
    //
    *FreeNeighbor = NULL;
    cellindex = HCELL_NIL;

    ptcell = (PHCELL)((PUCHAR)FreeCell + FreeCell->Size);
    ASSERT( ((ULONG)((ULONG_PTR)ptcell - (ULONG_PTR)Bin)) <= Bin->Size);
    if (((ULONG)((ULONG_PTR)ptcell - (ULONG_PTR)Bin)) < Bin->Size) {
        if (ptcell->Size > 0) {
            *FreeNeighbor = ptcell;
            goto FoundNeighbor;
        }
    }

    //
    // Neighbor below us?
    //
    if (USE_OLD_CELL(Hive)) {
        if (FreeCell->u.OldCell.Last != HBIN_NIL) {
            ptcell = (PHCELL)((PUCHAR)Bin + FreeCell->u.OldCell.Last);
            if (ptcell->Size > 0) {
                *FreeNeighbor = ptcell;
                goto FoundNeighbor;
            }
        }
    } else {
        ptcell = (PHCELL)(Bin+1);
        while (ptcell < FreeCell) {

            //
            // scan through the cells from the start of the bin looking for neighbor.
            //
            if (ptcell->Size > 0) {

                if ((PHCELL)((PUCHAR)ptcell + ptcell->Size) == FreeCell) {
                    *FreeNeighbor = ptcell;
                    //
                    // Try and mark it dirty, since we will be changing
                    // the size field.  If this fails, ignore
                    // the free neighbor, we will not fail the free
                    // just because we couldn't mark the cell dirty
                    // so it could be coalesced.
                    //
                    // Note we only bother doing this for new hives,
                    // for old format hives we always mark the whole
                    // bin dirty.
                    //
                    if ((Type == Volatile) ||
                        (HvMarkCellDirty(Hive, (ULONG)((ULONG_PTR)ptcell-(ULONG_PTR)Bin) + Bin->FileOffset))) {
                        goto FoundNeighbor;
                    } else {
                        return(FALSE);
                    }

                } else {
                    ptcell = (PHCELL)((PUCHAR)ptcell + ptcell->Size);
                }
            } else {
                ptcell = (PHCELL)((PUCHAR)ptcell - ptcell->Size);
            }
        }
    }

    return(FALSE);

FoundNeighbor:

    CellOffset = (ULONG)((PUCHAR)ptcell - (PUCHAR)Bin);
    cellindex = Bin->FileOffset + CellOffset + (Type*HCELL_TYPE_MASK);
    HvpDelistFreeCell(Hive, cellindex, Type);
    return TRUE;
}

HCELL_INDEX
HvReallocateCell(
    PHHIVE  Hive,
    HCELL_INDEX Cell,
    ULONG    NewSize
    )
/*++

Routine Description:

    Grows or shrinks a cell.

    NOTE:

        MUST NOT FAIL if the cell is being made smaller.  Can be
        a noop, but must work.

    WARNING:

        If the cell is grown, it will get a NEW and DIFFERENT HCELL_INDEX!!!

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies index of cell to grow or shrink

    NewSize - desired size of cell  (this is an absolute size, not an
            increment or decrement.)

Return Value:

    New HCELL_INDEX for cell, or HCELL_NIL if failure.

    If return is HCELL_NIL, either old cell did not exist, or it did exist
    and we could not make a new one.  In either case, nothing has changed.

    If return is NOT HCELL_NIL, then it is the HCELL_INDEX for the Cell,
    which very probably moved.

--*/
{
    PUCHAR      oldaddress;
    LONG        oldsize;
    ULONG       oldalloc;
    HCELL_INDEX NewCell;            // return value
    PUCHAR      newaddress;
    ULONG       Type;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvReallocateCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p  Cell=%08lx  NewSize=%08lx\n",Hive,Cell,NewSize));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // Make room for overhead fields and round up to HCELL_PAD boundary
    //
    if (USE_OLD_CELL(Hive)) {
        NewSize += FIELD_OFFSET(HCELL, u.OldCell.u.UserData);
    } else {
        NewSize += FIELD_OFFSET(HCELL, u.NewCell.u.UserData);
    }
    NewSize = ROUND_UP(NewSize, HCELL_PAD(Hive));

    // 
    // Adjust the size (an easy fix for granularity)
    //
    HvpAdjustCellSize(NewSize);

    //
    // reject impossible/unreasonable values
    //
    if (NewSize > HSANE_CELL_MAX) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tNewSize=%08lx\n", NewSize));
        return HCELL_NIL;
    }

    //
    // Get sizes and addresses
    //
    oldaddress = (PUCHAR)HvGetCell(Hive, Cell);
    if( oldaddress == NULL ) {
        //
        // we couldn't map a view for this cell
        // caller should handle this as STATUS_INSUFFICIENT_RESOURCES
        //
        return HCELL_NIL;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    oldsize = HvGetCellSize(Hive, oldaddress);
    ASSERT(oldsize > 0);
    if (USE_OLD_CELL(Hive)) {
        oldalloc = (ULONG)(oldsize + FIELD_OFFSET(HCELL, u.OldCell.u.UserData));
    } else {
        oldalloc = (ULONG)(oldsize + FIELD_OFFSET(HCELL, u.NewCell.u.UserData));
    }
    Type = HvGetCellType(Cell);

    DHvCheckHive(Hive);

    if (NewSize == oldalloc) {

        //
        // This is a noop, return the same cell
        //
        NewCell = Cell;

    } else if (NewSize < oldalloc) {

        //
        // This is a shrink.
        //
        // PERFNOTE - IMPLEMENT THIS.  Do nothing for now.
        //
        NewCell = Cell;

    } else {

        //
        // This is a grow.
        //

        //
        // PERFNOTE - Someday we want to detect that there is a free neighbor
        //          above us and grow into that neighbor if possible.
        //          For now, always do the allocate, copy, free gig.
        //

        //
        // Allocate a new block of memory to hold the cell
        //

        if ((NewCell = HvpDoAllocateCell(Hive, NewSize, Type,HCELL_NIL)) == HCELL_NIL) {
            return HCELL_NIL;
        }
        ASSERT(HvIsCellAllocated(Hive, NewCell));
        newaddress = (PUCHAR)HvGetCell(Hive, NewCell);
        if( newaddress == NULL ) {
            //
            // we couldn't map a view for this cell
            // this shouldn't happen as we just allocated this cell
            // (i.e. it's containing bin should be PINNED into memory)
            //
            ASSERT( FALSE );
            return HCELL_NIL;
        }

        // release the cell here as we are holding the reglock exclusive
        HvReleaseCell(Hive,NewCell);

        //
        // oldaddress points to the old data block for the cell,
        // newaddress points to the new data block, copy the data
        //
        RtlMoveMemory(newaddress, oldaddress, oldsize);

        //
        // Free the old block of memory
        //
        HvFreeCell(Hive, Cell);
    }

    DHvCheckHive(Hive);
    return NewCell;
}


#ifdef NT_RENAME_KEY
HCELL_INDEX
HvDuplicateCell(    
                    PHHIVE          Hive,
                    HCELL_INDEX     Cell,
                    HSTORAGE_TYPE   Type,
                    BOOLEAN         CopyData
                )
/*++

Routine Description:

    Makes an identical copy of the given Cell in the specified storagetype

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - cell to duplicate

    Type - destination storage

    CopyData - if TRUE, data is copied, otherwise UserData is zeroed out

Return Value:

    New HCELL_INDEX for cell, or HCELL_NIL if failure.

    If return is HCELL_NIL, either old cell did not exist, or it did exist
    and we could not make a new one.  In either case, nothing has changed.

    If return is NOT HCELL_NIL, then it is the HCELL_INDEX for the Cell,
    which very probably moved.

--*/
{
    PUCHAR          CellAddress;
    PUCHAR          NewCellAddress;
    LONG            Size;
    HCELL_INDEX     NewCell;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(HvIsCellAllocated(Hive, Cell));

    //
    // Get sizes and addresses
    //
    CellAddress = (PUCHAR)HvGetCell(Hive, Cell);
    if( CellAddress == NULL ) {
        //
        // we couldn't map a view for this cell
        //
        return HCELL_NIL;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    Size = HvGetCellSize(Hive, CellAddress);

    NewCell = HvAllocateCell(Hive,Size,Type,((HSTORAGE_TYPE)HvGetCellType(Cell) == Type)?Cell:HCELL_NIL);
    if( NewCell == HCELL_NIL ) {
        return HCELL_NIL;
    }

    NewCellAddress = (PUCHAR)HvGetCell(Hive, NewCell);
    if( NewCellAddress == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen as we just allocated this cell
        // (i.e. it should be PINNED into memory at this point)
        //
        ASSERT( FALSE );
        HvFreeCell(Hive, NewCell);
        return HCELL_NIL;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,NewCell);

    ASSERT( HvGetCellSize(Hive, NewCellAddress) >= Size );
    
    //
    // copy/initialize user data
    //
    if( CopyData == TRUE ) {
        RtlCopyMemory(NewCellAddress,CellAddress,Size);
    } else {
        RtlZeroMemory(NewCellAddress, Size);
    }
    
    return NewCell;
}
#endif //NT_RENAME_KEY


BOOLEAN HvAutoCompressCheck(PHHIVE Hive)
/*++

Routine Description:

    Checks the hive for the compression 

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

Return Value:

    TRUE/FALSE

--*/
{
    PCMHIVE     CmHive;    
    ULONG       CompressLevel;
    PLIST_ENTRY AnchorAddr;
    PFREE_HBIN  FreeBin;
    ULONG       FreeSpace;

#ifndef _CM_LDR_
    PAGED_CODE();
#endif //_CM_LDR_

    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);
    
    CmHive = CONTAINING_RECORD(Hive, CMHIVE, Hive);

    if( CmHive->FileHandles[HFILE_TYPE_PRIMARY] == NULL ) {
        //
        // compress already scheduled or hive doesn't really have stable storage; bail out quickly
        //
        return FALSE;
    }

    if( IsListEmpty(&(Hive->Storage[Stable].FreeBins)) ) {
        //
        // no free bins; no worth bothering
        //
        return FALSE;
    }

    //
    // iterate through the free bins and see how much space is wasted
    //
    FreeSpace = 0;
	AnchorAddr = &(Hive->Storage[Stable].FreeBins);
	FreeBin = (PFREE_HBIN)(Hive->Storage[Stable].FreeBins.Flink);

	while ( FreeBin != (PFREE_HBIN)AnchorAddr ) {
        FreeBin = CONTAINING_RECORD(FreeBin,
                                    FREE_HBIN,
                                    ListEntry);

        FreeSpace += FreeBin->Size;

        //
        // skip to the next element
        //
        FreeBin = (PFREE_HBIN)(FreeBin->ListEntry.Flink);
	}
    CompressLevel = CM_HIVE_COMPRESS_LEVEL * (Hive->Storage[Stable].Length / 100);
    
    if( FreeSpace < CompressLevel ) {
        // disable temporary so we can test the system hive.
        return FALSE;
    }

    return TRUE;
}

HCELL_INDEX
HvShiftCell(PHHIVE Hive,HCELL_INDEX Cell)
{
    PHMAP_ENTRY t;
    PHBIN       Bin;
    
    ASSERT( HvGetCellType(Cell) == Stable );
    
    t = HvpGetCellMap(Hive, Cell);
    ASSERT( t->BinAddress & HMAP_INPAGEDPOOL );

    Bin = (PHBIN)HBIN_BASE(t->BinAddress);
    ASSERT( Bin->Signature == HBIN_SIGNATURE );
    
    return Cell - Bin->Spare;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmwrapr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmwrapr.c

Abstract:

    This module contains the source for wrapper routines called by the
    hive code, which in turn call the appropriate NT routines.

Author:

    Bryan M. Willman (bryanwi) 16-Dec-1991

Revision History:

--*/

#include    "cmp.h"

VOID
CmpUnmapCmViewSurroundingOffset(
        IN  PCMHIVE             CmHive,
        IN  ULONG               FileOffset
        );



#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG perftouchbuffer = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpAllocate)
#ifdef POOL_TAGGING
#pragma alloc_text(PAGE,CmpAllocateTag)
#endif
#pragma alloc_text(PAGE,CmpFree)
#pragma alloc_text(PAGE,CmpDoFileSetSize)
#pragma alloc_text(PAGE,CmpCreateEvent)
#pragma alloc_text(PAGE,CmpFileRead)
#pragma alloc_text(PAGE,CmpFileWrite)
#pragma alloc_text(PAGE,CmpFileFlush)
#pragma alloc_text(PAGE,CmpFileWriteThroughCache)
#endif

extern BOOLEAN CmpNoWrite;


//
// never read more than 64k, neither the filesystem nor some disk drivers
// like it much.
//
#define MAX_FILE_IO 0x10000

#define CmpIoFileRead       1
#define CmpIoFileWrite      2
#define CmpIoFileSetSize    3
#define CmpIoFileFlush      4

extern struct {
    ULONG       Action;
    HANDLE      Handle;
    NTSTATUS    Status;
} CmRegistryIODebug;

extern BOOLEAN CmpFlushOnLockRelease;
//
// Storage management
//

PVOID
CmpAllocate(
    ULONG   Size,
    BOOLEAN UseForIo,
    ULONG   Tag
    )
/*++

Routine Description:

    This routine makes more memory available to a hive.

    It is environment specific.

Arguments:

    Size - amount of space caller wants

    UseForIo - TRUE if object allocated will be target of I/O,
               FALSE if not.

Return Value:

    NULL if failure, address of allocated block if not.

--*/
{
    PVOID   result;
    ULONG   pooltype;
#if DBG
    PVOID   Caller;
    PVOID   CallerCaller;
    RtlGetCallersAddress(&Caller, &CallerCaller);
#endif

    if (CmpClaimGlobalQuota(Size) == FALSE) {
        return NULL;
    }

    pooltype = (UseForIo) ? PagedPoolCacheAligned : PagedPool;
    result = ExAllocatePoolWithTag(
                pooltype,
                Size,
                Tag
                );

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"**CmpAllocate: allocate:%08lx, ", Size));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"type:%d, at:%08lx  ", PagedPool, result));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"c:%p  cc:%p\n", Caller, CallerCaller));

    if (result == NULL) {
        CmpReleaseGlobalQuota(Size);
    }

    return result;
}

#ifdef POOL_TAGGING
PVOID
CmpAllocateTag(
    ULONG   Size,
    BOOLEAN UseForIo,
    ULONG   Tag
    )
/*++

Routine Description:

    This routine makes more memory available to a hive.

    It is environment specific.

Arguments:

    Size - amount of space caller wants

    UseForIo - TRUE if object allocated will be target of I/O,
               FALSE if not.

Return Value:

    NULL if failure, address of allocated block if not.

--*/
{
    PVOID   result;
    ULONG   pooltype;
#if DBG
    PVOID   Caller;
    PVOID   CallerCaller;
    RtlGetCallersAddress(&Caller, &CallerCaller);
#endif

    if (CmpClaimGlobalQuota(Size) == FALSE) {
        return NULL;
    }

    pooltype = (UseForIo) ? PagedPoolCacheAligned : PagedPool;
    result = ExAllocatePoolWithTag(
                pooltype,
                Size,
                Tag
                );

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"**CmpAllocate: allocate:%08lx, ", Size));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"type:%d, at:%08lx  ", PagedPool, result));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"c:%p  cc:%p\n", Caller, CallerCaller));

    if (result == NULL) {
        CmpReleaseGlobalQuota(Size);
    }

    return result;
}
#endif


VOID
CmpFree(
    PVOID   MemoryBlock,
    ULONG   GlobalQuotaSize
    )
/*++

Routine Description:

    This routine frees memory that has been allocated by the registry.

    It is environment specific


Arguments:

    MemoryBlock - supplies address of memory object to free

    GlobalQuotaSize - amount of global quota to release

Return Value:

    NONE

--*/
{
#if DBG
    PVOID   Caller;
    PVOID   CallerCaller;
    RtlGetCallersAddress(&Caller, &CallerCaller);
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"**FREEING:%08lx c,cc:%p,%p\n", MemoryBlock, Caller, CallerCaller));
#endif
    ASSERT(GlobalQuotaSize > 0);
    CmpReleaseGlobalQuota(GlobalQuotaSize);
    ExFreePool(MemoryBlock);
    return;
}


NTSTATUS
CmpDoFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize,
    ULONG       OldFileSize
    )
/*++

Routine Description:

    This routine sets the size of a file.  It must not return until
    the size is guaranteed.

    It is environment specific.

    Must be running in the context of the cmp worker thread.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileSize - 32 bit value to set the file's size to

    OldFileSize - old file size, in order to determine if this is a shrink;
                - ignored if file type is not primary, or hive doesn't use 
                the mapped views technique

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    PCMHIVE                         CmHive;
    HANDLE                          FileHandle;
    NTSTATUS                        Status;
    FILE_END_OF_FILE_INFORMATION    FileInfo;
    IO_STATUS_BLOCK                 IoStatus;
    BOOLEAN                         oldFlag;
    LARGE_INTEGER                   FileOffset;         // where the mapping starts

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);

    CmHive = (PCMHIVE)Hive;
    FileHandle = CmHive->FileHandles[FileType];
    if (FileHandle == NULL) {
        return TRUE;
    }

    //
    // disable hard error popups, to avoid self deadlock on bogus devices
    //
    oldFlag = IoSetThreadHardErrorMode(FALSE);

    FileInfo.EndOfFile.HighPart = 0L;
    if( FileType == HFILE_TYPE_PRIMARY ) {
        FileInfo.EndOfFile.LowPart  = ROUND_UP(FileSize, CM_FILE_GROW_INCREMENT);
    } else {
        FileInfo.EndOfFile.LowPart  = FileSize;
    }

    ASSERT_PASSIVE_LEVEL();

    Status = ZwSetInformationFile(
                FileHandle,
                &IoStatus,
                (PVOID)&FileInfo,
                sizeof(FILE_END_OF_FILE_INFORMATION),
                FileEndOfFileInformation
                );

    if (NT_SUCCESS(Status)) {
        ASSERT(IoStatus.Status == Status);
    } else {
        
        //
        // set debugging info
        //
        CmRegistryIODebug.Action = CmpIoFileSetSize;
        CmRegistryIODebug.Handle = FileHandle;
        CmRegistryIODebug.Status = Status;
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFileSetSize:\tHandle=%08lx  OldLength = %08lx NewLength=%08lx  \n", 
                                                        FileHandle, OldFileSize, FileSize);
#endif //_CM_LDR_
        if( (Status == STATUS_DISK_FULL) && ExIsResourceAcquiredExclusiveLite(&CmpRegistryLock) ) {
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Disk is full while attempting to grow file %lx; will flush upon lock release\n",FileHandle);
            CmpFlushOnLockRelease = TRUE;;
        }
    }

    //
    // restore hard error popups mode
    //
    IoSetThreadHardErrorMode(oldFlag);
    

    //
    // purge
    //
    if( HiveWritesThroughCache(Hive,FileType) && (OldFileSize > FileSize)) {
        //
        // first we have to unmap any possible mapped views in the last 256K window
        // to avoid deadlock on CcWaitOnActiveCount inside CcPurgeCacheSection call bellow
        //
        ULONG   Offset = FileSize & (~(_256K - 1));
        //
        // we are not allowed to shrink in shared mode.
        //
        ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

        while( Offset < OldFileSize ) {
            CmpUnmapCmViewSurroundingOffset((PCMHIVE)Hive,Offset);
            Offset += CM_VIEW_SIZE;
        }

        //
        // we need to take extra precaution here and unmap the very last view too
        //
        //CmpUnmapCmViewSurroundingOffset((PCMHIVE)Hive,OldFileSize-HBLOCK_SIZE);
        
        FileOffset.HighPart = 0;
        FileOffset.LowPart = FileSize;
        //
        // This is a shrink; Inform cache manager of the change of the size
        //
        CcPurgeCacheSection( ((PCMHIVE)Hive)->FileObject->SectionObjectPointer, (PLARGE_INTEGER)(((ULONG_PTR)(&FileOffset)) + 1), 
                            OldFileSize - FileSize, FALSE );

        //
        // Flush out this view to clear out the Cc dirty hints
        //
        CcFlushCache( ((PCMHIVE)Hive)->FileObject->SectionObjectPointer, (PLARGE_INTEGER)(((ULONG_PTR)(&FileOffset)) + 1),/*we are private writers*/
                            OldFileSize - FileSize,NULL);

    }
    
    return Status;
}

NTSTATUS
CmpCreateEvent(
    IN EVENT_TYPE  eventType,
    OUT PHANDLE eventHandle,
    OUT PKEVENT *event
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;

    InitializeObjectAttributes( &obja, NULL, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL );
    status = ZwCreateEvent(
        eventHandle,
        EVENT_ALL_ACCESS,
        &obja,
        eventType,
        FALSE);
    
    if (!NT_SUCCESS(status)) {
        return status;
    }
    
    status = ObReferenceObjectByHandle(
        *eventHandle,
        EVENT_ALL_ACCESS,
        NULL,
        KernelMode,
        event,
        NULL);
    
    if (!NT_SUCCESS(status)) {
        ZwClose(*eventHandle);
        return status;
    }
    return status;
}

BOOLEAN
CmpFileRead (
    PHHIVE      Hive,
    ULONG       FileType,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    )
/*++

Routine Description:

    This routine reads in a buffer from a file.

    It is environment specific.

    NOTE:   We assume the handle is opened for asynchronous access,
            and that we, and not the IO system, are keeping the
            offset pointer.

    NOTE:   Only 32bit offsets are supported, even though the underlying
            IO system on NT supports 64 bit offsets.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileOffset - pointer to variable providing 32bit offset on input,
                 and receiving new 32bit offset on output.

    DataBuffer - pointer to buffer

    DataLength - length of buffer

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    NTSTATUS status;
    LARGE_INTEGER   Offset;
    IO_STATUS_BLOCK IoStatus;
    PCMHIVE CmHive;
    HANDLE  FileHandle;
    ULONG LengthToRead;
    HANDLE eventHandle = NULL;
    PKEVENT eventObject = NULL;

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);
    CmHive = (PCMHIVE)Hive;
    FileHandle = CmHive->FileHandles[FileType];
    if (FileHandle == NULL) {
        return TRUE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpFileRead:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tHandle=%08lx  Offset=%08lx  ", FileHandle, *FileOffset));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Buffer=%p  Length=%08lx\n", DataBuffer, DataLength));

    //
    // Detect attempt to read off end of 2gig file (this should be irrelevent)
    //
    if ((0xffffffff - *FileOffset) < DataLength) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpFileRead: runoff\n"));
        return FALSE;
    }

    status = CmpCreateEvent(
        SynchronizationEvent,
        &eventHandle,
        &eventObject);
    if (!NT_SUCCESS(status))
        return FALSE;

    //
    // We'd really like to just call the filesystems and have them do
    // the right thing.  But the filesystem will attempt to lock our
    // entire buffer into memory, and that may fail for large requests.
    // So we split our reads into 64k chunks and call the filesystem for
    // each one.
    //
    ASSERT_PASSIVE_LEVEL();
    while (DataLength > 0) {

        //
        // Convert ULONG to Large
        //
        Offset.LowPart = *FileOffset;
        Offset.HighPart = 0L;

        //
        // trim request down if necessary.
        //
        if (DataLength > MAX_FILE_IO) {
            LengthToRead = MAX_FILE_IO;
        } else {
            LengthToRead = DataLength;
        }

        status = ZwReadFile(
                    FileHandle,
                    eventHandle,
                    NULL,               // apcroutine
                    NULL,               // apccontext
                    &IoStatus,
                    DataBuffer,
                    LengthToRead,
                    &Offset,
                    NULL                // key
                    );

        if (STATUS_PENDING == status) {
            status = KeWaitForSingleObject(eventObject, Executive,
                                           KernelMode, FALSE, NULL);
            ASSERT(STATUS_SUCCESS == status);
            status = IoStatus.Status;
        }

        //
        // adjust offsets
        //
        *FileOffset = Offset.LowPart + LengthToRead;
        DataLength -= LengthToRead;
        (PUCHAR)DataBuffer += LengthToRead;

        if (NT_SUCCESS(status)) {
            ASSERT(IoStatus.Status == status);
            if (IoStatus.Information != LengthToRead) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpFileRead:\n\t"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Failure1: status = %08lx  ", status));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"IoInformation = %08lx\n", IoStatus.Information));
                ObDereferenceObject(eventObject);
                ZwClose(eventHandle);
                return FALSE;
            }
        } else {
            //
            // set debugging info
            //
            CmRegistryIODebug.Action = CmpIoFileRead;
            CmRegistryIODebug.Handle = FileHandle;
            CmRegistryIODebug.Status = status;
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFileRead:\tFailure2: status = %08lx  IoStatus = %08lx\n", status, IoStatus.Status);
#endif //_CM_LDR_

            ObDereferenceObject(eventObject);
            ZwClose(eventHandle);
            return FALSE;
        }

    }
    ObDereferenceObject(eventObject);
    ZwClose(eventHandle);
    return TRUE;
}

BOOLEAN
CmpFileWriteThroughCache(
    PHHIVE              Hive,
    ULONG               FileType,
    PCMP_OFFSET_ARRAY   offsetArray,
    ULONG               offsetArrayCount
    )
/*++

Routine Description:

    This is routine writes dirty ranges of data using Cc mapped views.
    The benefit is that writes don't go through Cc Lazy Writer, so there 
    is no danger to be throttled or deffered.

    It also flushes the cache for the written ranges, guaranteeing that 
    the data was commited to the disk upon return.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    offsetArray - array of structures where each structure holds a 32bit offset
                  into the Hive file and pointer the a buffer written to that
                  file offset.

    offsetArrayCount - number of elements in the offsetArray.

Return Value:

    FALSE if failure
    TRUE if success

Note:

    This routine is intended to deal only with paged bins (i.e. bins crossing the 
    CM_VIEW_SIZE boundary or bins that were added after the last sync)

Assumption:

    We work on the assumption that the data to be written at one iteration never spans 
    over the CM_VIEW_SIZE boundary. HvpFindNextDirtyBlock takes care of that !!! 
--*/
{
    ULONG           i;
    PVOID           DataBuffer;
    ULONG           DataLength;
    ULONG           FileOffset;
    PCMHIVE         CmHive;
    NTSTATUS        Status;
    PVOID           Bcb;
    PVOID           FileBuffer;
    LARGE_INTEGER   Offset;
    IO_STATUS_BLOCK IoStatus;

    ASSERT_PASSIVE_LEVEL();

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    ASSERT( ((FileType == HFILE_TYPE_EXTERNAL) && (CmHive->FileObject != NULL)) || HiveWritesThroughCache(Hive,FileType) );

    //ASSERT( IsListEmpty(&(CmHive->PinViewListHead)) == TRUE);
    //ASSERT( CmHive->PinnedViews == 0 );

    Offset.HighPart = 0;
    //
    // iterate through the array of data
    //
    for(i=0;i<offsetArrayCount;i++) {
        DataBuffer =  offsetArray[i].DataBuffer;
        DataLength =  offsetArray[i].DataLength;
        FileOffset = offsetArray[i].FileOffset;
        //
        // data should never span over CM_VIEW_SIZE boundary
        //
        ASSERT( (FileOffset & (~(CM_VIEW_SIZE - 1))) == ((FileOffset + DataLength - 1) & (~(CM_VIEW_SIZE - 1))) );

        //
        // unmap any possible mapped view that could overlapp with this range ; not needed !!!!
        //
        //CmpUnmapCmViewSurroundingOffset(CmHive,FileOffset);

        //
        // map and pin data
        //
        Offset.LowPart = FileOffset;
        try {
            if( !CcPinRead (CmHive->FileObject,&Offset,DataLength,PIN_WAIT,&Bcb,&FileBuffer) ) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFileWriteThroughCache - could not pin read view i= %lu\n",i));
#if DBG
                DbgBreakPoint();
#endif //DBG
                return FALSE;        
            }
            //
            // copy data to pinned view; we need to do it inside try except, to protect against devices/volumes
            // dismounting from under us.
            //
            RtlCopyMemory(FileBuffer,DataBuffer, DataLength);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // in low-memory scenarios, CcPinRead throws a STATUS_INSUFFICIENT_RESOURCES
            // We want to catch this and treat as a  "not enough resources" problem, 
            // rather than letting it to surface the kernel call
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFileWriteThroughCache : CcPinRead has raised :%08lx\n",GetExceptionCode()));
            return FALSE;
        }

        //
        // dirty, unpin and flush
        //
        CcSetDirtyPinnedData (Bcb,NULL);
        CcUnpinData( Bcb );
        CcFlushCache (CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)(&Offset)) + 1)/*we are private writers*/,DataLength,&IoStatus);
        if(!NT_SUCCESS(IoStatus.Status) ) {
            return FALSE;
        }
    }

    return TRUE;
}

FAST_MUTEX      CmpWriteLock;   // used to syncronize access to the bellow;
                                // the only case we ned this is when NtSaveKey is called by different threads
                                // at the same time; all other calls to CmpFileWrite are made with the reg_lock 
                                // held exclusively
CM_WRITE_BLOCK CmpWriteBlock;

BOOLEAN
CmpFileWrite(
    PHHIVE              Hive,
    ULONG               FileType,
    PCMP_OFFSET_ARRAY   offsetArray,
    ULONG               offsetArrayCount,
    PULONG              FileOffset
    )
/*++

Routine Description:

    This routine writes an array of buffers out to a file.

    It is environment specific.

    NOTE:   We assume the handle is opened for asynchronous access,
            and that we, and not the IO system, are keeping the
            offset pointer.

    NOTE:   Only 32bit offsets are supported, even though the underlying
            IO system on NT supports 64 bit offsets.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    offsetArray - array of structures where each structure holds a 32bit offset
                  into the Hive file and pointer the a buffer written to that
                  file offset.

    offsetArrayCount - number of elements in the offsetArray.

    FileOffset - returns the file offset after the last write to the file.

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    NTSTATUS        status;
    LARGE_INTEGER   Offset;
    PCMHIVE         CmHive;
    HANDLE          FileHandle;
    ULONG           LengthToWrite;
    LONG            WaitBufferCount = 0;
    LONG            idx;
    ULONG           arrayCount = 0;
    PVOID           DataBuffer;
    ULONG           DataLength;
    BOOLEAN         ret_val = TRUE;

    if (CmpNoWrite) {
        return TRUE;
    }

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);
    CmHive = (PCMHIVE)Hive;
    FileHandle = CmHive->FileHandles[FileType];
    if (FileHandle == NULL) {
        return TRUE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpFileWrite:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tHandle=%08lx  ", FileHandle));

    //ASSERT( !HiveWritesThroughCache(Hive,FileType) );

    ExAcquireFastMutexUnsafe(&CmpWriteLock);
    
    for (idx = 0; idx < MAXIMUM_WAIT_OBJECTS; idx++) {
        CmpWriteBlock.EventHandles[idx] = NULL;
#if DBG
        CmpWriteBlock.EventObjects[idx] = NULL;
#endif
    }
    
    //
    // decide whether we wait for IOs to complete or just issue them and
    // rely on the CcFlushCache to do the job
    //
    
    // Bring pages being written into memory first to allow disk to write
    // buffer contiguously.
    for (idx = 0; (ULONG) idx < offsetArrayCount; idx++) {
        char * start = offsetArray[idx].DataBuffer;
        char * end = (char *) start + offsetArray[idx].DataLength;
        while (start < end) {
            // perftouchbuffer globally declared so that compiler won't try
            // to remove it and this loop (if its smart enough?).
            perftouchbuffer += (ULONG) *start;
            start += PAGE_SIZE;
        }
    }

    //
    // We'd really like to just call the filesystems and have them do
    // the right thing.  But the filesystem will attempt to lock our
    // entire buffer into memory, and that may fail for large requests.
    // So we split our reads into 64k chunks and call the filesystem for
    // each one.
    //
    ASSERT_PASSIVE_LEVEL();
    arrayCount = 0;
    DataLength = 0;
    // This outer loop is hit more than once if the MAXIMUM_WAIT_OBJECTS limit
    // is hit before the offset array is drained.
    while (arrayCount < offsetArrayCount) {
        WaitBufferCount = 0;

        // This loop fills the wait buffer.
        while ((arrayCount < offsetArrayCount) &&
               (WaitBufferCount < MAXIMUM_WAIT_OBJECTS)) {

            // If data length isn't zero than the wait buffer filled before the
            // buffer in the last offsetArray element was sent to write file.
            if (DataLength == 0) {
                *FileOffset = offsetArray[arrayCount].FileOffset;
                DataBuffer =  offsetArray[arrayCount].DataBuffer;
                DataLength =  offsetArray[arrayCount].DataLength;
                //
                // Detect attempt to read off end of 2gig file
                // (this should be irrelevent)
                //
                if ((0xffffffff - *FileOffset) < DataLength) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpFileWrite: runoff\n"));
                    goto Error_Exit;
                }
            }
            // else still more to write out of last buffer.

            while ((DataLength > 0) && (WaitBufferCount < MAXIMUM_WAIT_OBJECTS)) {

                //
                // Convert ULONG to Large
                //
                Offset.LowPart = *FileOffset;
                Offset.HighPart = 0L;

                //
                // trim request down if necessary.
                //
                if (DataLength > MAX_FILE_IO) {
                    LengthToWrite = MAX_FILE_IO;
                } else {
                    LengthToWrite = DataLength;
                }

                // Previously created events are reused.
                if (CmpWriteBlock.EventHandles[WaitBufferCount] == NULL) {
                    status = CmpCreateEvent(SynchronizationEvent,
                                            &(CmpWriteBlock.EventHandles[WaitBufferCount]),
                                            &(CmpWriteBlock.EventObjects[WaitBufferCount]));
                    if (!NT_SUCCESS(status)) {
                        // Make sure we don't try to clean this up.
                        CmpWriteBlock.EventHandles[WaitBufferCount] = NULL;
                        goto Error_Exit;
                    }
                }
                
                status = ZwWriteFile(FileHandle,
                                     CmpWriteBlock.EventHandles[WaitBufferCount],
                                     NULL,               // apcroutine
                                     NULL,               // apccontext
                                     &(CmpWriteBlock.IoStatus[WaitBufferCount]),
                                     DataBuffer,
                                     LengthToWrite,
                                     &Offset,
                                     NULL);
                        
                if (!NT_SUCCESS(status)) {
                    goto Error_Exit;
                } 

                WaitBufferCount++;
                
                //
                // adjust offsets
                //
                *FileOffset = Offset.LowPart + LengthToWrite;
                DataLength -= LengthToWrite;
                (PUCHAR)DataBuffer += LengthToWrite;
            } // while (DataLength > 0 && WaitBufferCount < MAXIMUM_WAIT_OBJECTS)
            
            arrayCount++;
            
        } // while (arrayCount < offsetArrayCount && 
          //        WaitBufferCount < MAXIMUM_WAIT_OBJECTS)

        status = KeWaitForMultipleObjects(WaitBufferCount, 
                                          CmpWriteBlock.EventObjects,
                                          WaitAll,
                                          Executive,
                                          KernelMode, 
                                          FALSE, 
                                          NULL,
                                          CmpWriteBlock.WaitBlockArray);
    
        if (!NT_SUCCESS(status))
            goto Error_Exit;
    
        for (idx = 0; idx < WaitBufferCount; idx++) {
            if (!NT_SUCCESS(CmpWriteBlock.IoStatus[idx].Status)) {
                status = CmpWriteBlock.IoStatus[idx].Status;
                ret_val = FALSE;
                goto Done;
            }
        }
        
        // There may still be more to do if the last element held a big buffer
        // and the wait buffer filled before it was all sent to the file.
        if (DataLength > 0) {
            arrayCount--;
        }

    } // while (arrayCount < offsetArrayCount)

    ret_val = TRUE;

    goto Done;
Error_Exit:
    //
    // set debugging info
    //
    CmRegistryIODebug.Action = CmpIoFileWrite;
    CmRegistryIODebug.Handle = FileHandle;
    CmRegistryIODebug.Status = status;
#ifndef _CM_LDR_
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFileWrite: error exiting %d\n", status);
#endif //_CM_LDR_
    //
    // if WaitBufferCount > 0 then we have successfully issued
    // some I/Os, but not all of them. This is an error, but we
    // cannot return from this routine until all the successfully
    // issued I/Os have completed.
    //
    if (WaitBufferCount > 0) {
        //
        // only if we decided that we want to wait for the write to complete 
        // (log files and hives not using the mapped views technique)
        //
        status = KeWaitForMultipleObjects(WaitBufferCount, 
                                          CmpWriteBlock.EventObjects,
                                          WaitAll,
                                          Executive,
                                          KernelMode, 
                                          FALSE, 
                                          NULL,
                                          CmpWriteBlock.WaitBlockArray);
    }


    ret_val = FALSE;
Done:
    idx = 0;
    // Clean up open event handles and objects.
    while ((idx < MAXIMUM_WAIT_OBJECTS) && (CmpWriteBlock.EventHandles[idx] != NULL)) {
        ASSERT( CmpWriteBlock.EventObjects[idx] );
        ObDereferenceObject(CmpWriteBlock.EventObjects[idx]);
        ZwClose(CmpWriteBlock.EventHandles[idx]);
        idx++;
    }

    ExReleaseFastMutexUnsafe(&CmpWriteLock);

    return ret_val;
}


BOOLEAN
CmpFileFlush (
    PHHIVE          Hive,
    ULONG           FileType,
    PLARGE_INTEGER  FileOffset,
    ULONG           Length
    )
/*++

Routine Description:

    This routine performs a flush on a file handle.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileOffset - If this parameter is supplied (not NULL), then only the
                 byte range specified by FileOffset and Length are flushed.

    Length - Defines the length of the byte range to flush, starting at
             FileOffset.  This parameter is ignored if FileOffset is
             specified as NULL.
    

Return Value:

    FALSE if failure
    TRUE if success

Note: 
    
    FileOffset and Length are only taken into account when FileType == HFILE_TYPE_PRIMARY
    and the hive uses the mapped-views method.
--*/
{
    NTSTATUS        status;
    IO_STATUS_BLOCK IoStatus;
    PCMHIVE         CmHive;
    HANDLE          FileHandle;

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);
    CmHive = (PCMHIVE)Hive;
    FileHandle = CmHive->FileHandles[FileType];
    if (FileHandle == NULL) {
        return TRUE;
    }

    if (CmpNoWrite) {
        return TRUE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpFileFlush:\n\tHandle = %08lx\n", FileHandle));

    ASSERT_PASSIVE_LEVEL();


    if( HiveWritesThroughCache(Hive,FileType) == TRUE ) {       
        //
        // OK, we need to flush using CcFlushCache
        //
        CcFlushCache (CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)((ULONG_PTR)FileOffset + 1)/*we are private writers*/,Length,&IoStatus);
        status = IoStatus.Status;
    } else {
        //
        // hive loaded into paged pool; or not primary
        //
        status = ZwFlushBuffersFile(
                    FileHandle,
                    &IoStatus
                    );
    }

    if (NT_SUCCESS(status)) {
        ASSERT(IoStatus.Status == status);
        return TRUE;
    } else {
        //
        // set debugging info
        //
        CmRegistryIODebug.Action = CmpIoFileFlush;
        CmRegistryIODebug.Handle = FileHandle;
        CmRegistryIODebug.Status = status;

#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFileFlush:\tFailure1: status = %08lx  IoStatus = %08lx\n",status,IoStatus.Status);
#endif //_CM_LDR_

#ifdef DRAGOSS_PRIVATE_DEBUG
        DbgBreakPoint();
#endif //DRAGOSS_PRIVATE_DEBUG

        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hivechek.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivechek.c

Abstract:

    This module implements consistency checking for hives.

Author:

    Bryan M. Willman (bryanwi) 09-Dec-91

Environment:


Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvCheckHive)
#pragma alloc_text(PAGE,HvCheckBin)
#endif

//
// debug structures
//
extern struct {
    PHHIVE      Hive;
    ULONG       Status;
    ULONG       Space;
    HCELL_INDEX MapPoint;
    PHBIN       BinPoint;
} HvCheckHiveDebug;

extern struct {
    PHBIN       Bin;
    ULONG       Status;
    PHCELL      CellPoint;
} HvCheckBinDebug;


#if DBG
ULONG HvHiveChecking=0;
#endif

ULONG
HvCheckHive(
    PHHIVE  Hive,
    PULONG  Storage OPTIONAL
    )
/*++

Routine Description:

    Check the consistency of a hive.  Apply CheckBin to bins, make sure
    all pointers in the cell map point to correct places.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest.

    Storage - supplies adddress of ULONG to receive size of allocated user data

Return Value:

    0 if Hive is OK.  Error return indicator if not.  Error value
    comes from one of the check procedures.

    RANGE:  2000 - 2999

--*/
{
    HCELL_INDEX p;
    ULONG       Length;
    ULONG       localstorage = 0;
    PHMAP_ENTRY t;
    PHBIN       Bin;
    ULONG   i;
    ULONG   rc;
    PFREE_HBIN  FreeBin;

    HvCheckHiveDebug.Hive = Hive;
    HvCheckHiveDebug.Status = 0;
    HvCheckHiveDebug.Space = (ULONG)-1;
    HvCheckHiveDebug.MapPoint = HCELL_NIL;
    HvCheckHiveDebug.BinPoint = 0;

    p = 0;

#ifdef CM_MAP_NO_READ
#ifndef _CM_LDR_
    //
    // we need to make sure all the cell's data is faulted in inside a 
    // try/except block, as the IO to fault the data in can throw exceptions
    // STATUS_INSUFFICIENT_RESOURCES, in particular
    //

    try {
#endif //_CM_LDR_
#endif //CM_MAP_NO_READ

        //
        // one pass for Stable space, one pass for Volatile
        //
        for (i = 0; i <= Volatile; i++) {
            Length = Hive->Storage[i].Length;

            //
            // for each bin in the space
            //
            while (p < Length) {
                t = HvpGetCellMap(Hive, p);
                if (t == NULL) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckHive:"));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBin@:%p invalid\n", Bin));
                    HvCheckHiveDebug.Status = 2005;
                    HvCheckHiveDebug.Space = i;
                    HvCheckHiveDebug.MapPoint = p;
                    return 2005;
                }

            
                if( (t->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0) {
                    //
                    // view is not mapped, neither in paged pool
                    // try to map it.
                    //
                
                    // volatile info is always in paged pool
                    ASSERT( i == Stable );

                    if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,p,FALSE)) ) {
                        //
                        // we cannot map this bin due to insufficient resources. 
                        //
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckHive:"));
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tinsufficient resources while mapping Bin@:%p\n", Bin));
                        HvCheckHiveDebug.Status = 2006;
                        HvCheckHiveDebug.Space = i;
                        HvCheckHiveDebug.MapPoint = p;
                        return 2010;
                    }
                }

                if ((t->BinAddress & HMAP_DISCARDABLE) == 0) {

                    Bin = (PHBIN)HBIN_BASE(t->BinAddress);

                    //
                    // bin header valid?
                    //
                    if ( (Bin->Size > Length)                           ||
                         (Bin->Signature != HBIN_SIGNATURE)             ||
                         (Bin->FileOffset != p)
                       )
                    {
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckHive:"));
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBin@:%p invalid\n", Bin));
                        HvCheckHiveDebug.Status = 2010;
                        HvCheckHiveDebug.Space = i;
                        HvCheckHiveDebug.MapPoint = p;
                        HvCheckHiveDebug.BinPoint = Bin;
                        return 2010;
                    }

                    //
                    // structure inside the bin valid?
                    //
                    rc = HvCheckBin(Hive, Bin, &localstorage);
                    if (rc != 0) {
                        HvCheckHiveDebug.Status = rc;
                        HvCheckHiveDebug.Space = i;
                        HvCheckHiveDebug.MapPoint = p;
                        HvCheckHiveDebug.BinPoint = Bin;
                        return rc;
                    }

                    p = (ULONG)p + Bin->Size;

                } else {
                    //
                    // Bin is not present, skip it and advance to the next one.
                    //
                    FreeBin = (PFREE_HBIN)t->BlockAddress;
                    p+=FreeBin->Size;
                }
            }

            p = 0x80000000;     // Beginning of Volatile space
        }

#ifdef CM_MAP_NO_READ
#ifndef _CM_LDR_
    } except (EXCEPTION_EXECUTE_HANDLER) {
        HvCheckHiveDebug.Status = 2015;
        HvCheckHiveDebug.Space = GetExceptionCode();
        return HvCheckHiveDebug.Status;
    }
#endif //_CM_LDR_
#endif //CM_MAP_NO_READ

    if (ARGUMENT_PRESENT(Storage)) {
        *Storage = localstorage;
    }
    return 0;
}


ULONG
HvCheckBin(
    PHHIVE  Hive,
    PHBIN   Bin,
    PULONG  Storage
    )
/*++

Routine Description:

    Step through all of the cells in the bin.  Make sure that
    they are consistent with each other, and with the bin header.

Arguments:

    Hive - pointer to the hive control structure

    Bin - pointer to bin to check

    Storage - pointer to a ulong to get allocated user data size

Return Value:

    0 if Bin is OK.  Number of test in procedure that failed if not.

    RANGE:  1 - 1999

--*/
{
    PHCELL  p;
    PHCELL  np;
    PHCELL  lp;
    ULONG   freespace = 0L;
    ULONG   allocated = 0L;
    ULONG   userallocated = 0L;

    HvCheckBinDebug.Bin = Bin;
    HvCheckBinDebug.Status = 0;
    HvCheckBinDebug.CellPoint = 0;

    //
    // Scan all the cells in the bin, total free and allocated, check
    // for impossible pointers.
    //
    p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));
    lp = p;

    // DRAGOS:
    // The way allocated and freespace are computed implies the following invariants:
    // 1. allocated + freespace = p + p->Size - (Bin + sizeof(HBIN)). This is because p->Size is added either to allocated or to freespace.
    //    So, assuming that allocated > Bin->Size , then
    //              ==> p + p->Size - (Bin + sizeof(HBIN)) > Bin->Size.
    //              ==> p + p->Size > Bin + Bin->Size + sizeof(HBIN)
    //              ==> p + p->Size > Bin + Bin->Size
    //      This proves that the test "NeverFail 1" (see bellow) will never fail, because when something is wrong, the test above it (namely "Fail 1") will fail 
    //      and the function will exit.
    //
    //    The same logic applies to the test "NeverFail 2", so it can be removed also.
    //
    // 2. The new value of p is always calculated as p = p + p->Size. By the time this is done, the new value of p (ie. p + p->Size) is already checked against 
    //      Bin + Bin->Size (see tests "Fail 1" and "Fail 2"). So, if p > Bin + Bin->Size, either "Fail 1" or "Fail 2" will fail before asigning the new bogus value 
    //      to p. Therefore, the only possible path to exit the while loop (except a return 20 or return 40), is when p == Bin + Bin->Size.
    //      ==> test "NeverFail 3" can be removed as it will never fail !
    //
    // 3. Considering 1 (where p + p->Size became p) 
    //              ==> allocated + freespace =  p - (Bin + sizeof(HBIN))
    //    But, Considering 2 (above), when the while loop exits, p = Bin + Bin->Size
    //              ==> allocated + freespace = Bin + Bin->Size - (Bin + sizeof(HBIN))
    //              ==> allocated + freespace + sizeof(HBIN) = Bin->Size
    //       This proves that test "NeverFail 4" (see bellow) will never fail as the expresion tested is always true (if the flow of execution reaches the test point).
    //

    while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

        //
        // Check last pointer
        //
        if (USE_OLD_CELL(Hive)) {
            if (lp == p) {
                if (p->u.OldCell.Last != HBIN_NIL) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 20: First cell has wrong last pointer\n"));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                    HvCheckBinDebug.Status = 20;
                    HvCheckBinDebug.CellPoint = p;
                    return 20;
                }
            } else {
                if ((PHCELL)(p->u.OldCell.Last + (PUCHAR)Bin) != lp) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 30: incorrect last pointer\n"));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"p = %p\n", (ULONG_PTR)p));
                    HvCheckBinDebug.Status = 30;
                    HvCheckBinDebug.CellPoint = p;
                    return 30;
                }
            }
        }

        
        //
        // Check size
        //
        if (p->Size < 0) {

            //
            // allocated cell
            //

            // DRAGOS:    Fail 1
            // This test will alway fail prior to the failure of the bellow test
            //
            if ( ((ULONG)(p->Size * -1) > Bin->Size)        ||
                 ( (PHCELL)((p->Size * -1) + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) )
               )
            {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 40: impossible allocation\n"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                HvCheckBinDebug.Status = 40;
                HvCheckBinDebug.CellPoint = p;
                return 40;
            }

            allocated += (p->Size * -1);
            if (USE_OLD_CELL(Hive)) {
                userallocated += (p->Size * -1) - FIELD_OFFSET(HCELL, u.OldCell.u.UserData);
            } else {
                userallocated += (p->Size * -1) - FIELD_OFFSET(HCELL, u.NewCell.u.UserData);
            }

            //
            // DRAGOS:   NeverFail 1
            // This test will never fail. If a size is wrong the above test (Fail 1)will fail. We can remove this test (it's useless).
            //
            if (allocated > Bin->Size) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 50: allocated exceeds available\n"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                HvCheckBinDebug.Status = 50;
                HvCheckBinDebug.CellPoint = p;
                return 50;
            }

            np = (PHCELL)((PUCHAR)p + (p->Size * -1));



        } else {

            //
            // free cell
            //

            // DRAGOS:    Fail 2
            // This test will alway fail prior to the failure of the bellow test
            //
            if ( ((ULONG)p->Size > Bin->Size)               ||
                 ( (PHCELL)(p->Size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) ) ||
                 (p->Size == 0) )
            {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 60: impossible free block\n"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                HvCheckBinDebug.Status = 60;
                HvCheckBinDebug.CellPoint = p;
                return 60;
            }

            freespace = freespace + p->Size;

            //
            // DRAGOS:   NeverFail 2
            // This test will never fail. If a size is wrong the above test (Fail 2) will fail. We can remove this test (it's useless).
            //
            if (freespace > Bin->Size) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 70: free exceeds available\n"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                HvCheckBinDebug.Status = 70;
                HvCheckBinDebug.CellPoint = p;
                return 70;
            }

            np = (PHCELL)((PUCHAR)p + p->Size);

        }

        lp = p;
        p = np;
    }

    // DRAGOS:  NeverFail 4
    // This test never fails. If the while loop exits, the condition tested here is always true!!!
    // We can remove this test (it's useless)
    //
    if ((freespace + allocated + sizeof(HBIN)) != Bin->Size) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 995: sizes do not add up\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"freespace = %08lx  ", freespace));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"allocated = %08lx  ", allocated));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"size = %08lx\n", Bin->Size));
        HvCheckBinDebug.Status = 995;
        return 995;
    }

    // DRAGOS:  NeverFail 3
    // This test never fails. The only way out of the while loop is when p == Bin + Bin->Size !!!!!!!
    // We can remove this test (it's useless)
    //
    if (p != (PHCELL)((PUCHAR)Bin + Bin->Size)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 1000: last cell points off the end\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
        HvCheckBinDebug.Status = 1000;
        return 1000;
    }

    if (ARGUMENT_PRESENT(Storage)) {
        *Storage += userallocated;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hivefree.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivefree.c

Abstract:

    Hive free code

Author:

    Bryan M. Willman (bryanwi) 30-Mar-92

Environment:


Revision History:
    Dragos C. Sambotin (dragoss) 25-Jan-99
        Implementation of bin-size chunk loading of hives.
--*/

#include "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvFreeHive)
#pragma alloc_text(PAGE,HvFreeHivePartial)
#endif


// Dragos: Modified functions

VOID
HvFreeHive(
    PHHIVE Hive
    )
/*++

Routine Description:

    Free all of the pieces of a hive.

Arguments:

    Hive - supplies a pointer to hive control structure for hive to free.
            this structure itself will NOT be freed, but everything it
            points to will.

Return Value:

    NONE.

--*/
{
    PHMAP_DIRECTORY Dir;
    PHMAP_ENTRY     Me;
    PHMAP_ENTRY     TempMe;
    HCELL_INDEX     Address;
    ULONG           Type;
    ULONG           Length;
    PHBIN           Bin;
    ULONG           Tables;
    PFREE_HBIN      FreeBin;

    ASSERT(Hive->Flat == FALSE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Stable == 0);
    ASSERT(Volatile == 1);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvFreeHive(%ws) :\n", Hive->BaseBlock->FileName));
    //
    // Iterate through both types of storage
    //
    for (Type = 0; Type <= Volatile; Type++) {

        Address = HCELL_TYPE_MASK * Type;
        Length = Hive->Storage[Type].Length + (HCELL_TYPE_MASK * Type);

        if (Length > (HCELL_TYPE_MASK * Type)) {

            //
            // Sweep through bin set
            //
            do {
                Me = HvpGetCellMap(Hive, Address);
                VALIDATE_CELL_MAP(__LINE__,Me,Hive,Address);
                    if (Me->BinAddress & HMAP_DISCARDABLE) {
                        //
                        // hbin is either discarded or discardable, check the tombstone
                        //
                        FreeBin = (PFREE_HBIN)Me->BlockAddress;
                        Address += FreeBin->Size;
                        if (FreeBin->Flags & FREE_HBIN_DISCARDABLE) {
                            CmpFree((PHBIN)HBIN_BASE(Me->BinAddress), FreeBin->Size);
                        } else if(Me->BinAddress & HMAP_INPAGEDPOOL) {
                            //
                            // The bin has been freed, but quota is still charged.
                            // Since the hive is being freed, the quota must be
                            // returned here.
                            //
                            CmpReleaseGlobalQuota(FreeBin->Size);
                        }

                        CmpFree(FreeBin, sizeof(FREE_HBIN));
                    } else {
                        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                            ASSERT( Me->BinAddress & HMAP_INPAGEDPOOL );

                            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
                            Address += HvpGetBinMemAlloc(Hive,Bin,Type);
#if 0
                            //
                            // Make sure that the next bin in the list is
                            // actually the start of an alloc before freeing it
                            //
                            if (Address < Length) {
                                TempMe = HvpGetCellMap(Hive, Address);
                                VALIDATE_CELL_MAP(__LINE__,TempMe,Hive,Address);
                                ASSERT(TempMe->BinAddress & HMAP_NEWALLOC);
                            }
#endif

#if DBG
                            if( Type == Stable ) {
                                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvFreeHive: BinAddress = 0x%p\t Size = 0x%lx\n", Bin, HvpGetBinMemAlloc(Hive,Bin,Type)));
                            }
#endif

                            //
                            // free the actual bin only if it is allocated from paged pool
                            //
                            if(HvpGetBinMemAlloc(Hive,Bin,Type)) {
                                CmpFree(Bin, HvpGetBinMemAlloc(Hive,Bin,Type));
                            }
                        } else {
                            //
                            // bin was mapped into view; advance carefully
                            //
                            Address += HBLOCK_SIZE;
                        }

                    }
            } while (Address < Length);

            //
            // Free map table storage
            //
            ASSERT(Hive->Storage[Type].Length != (HCELL_TYPE_MASK * Type));
            Tables = (((Hive->Storage[Type].Length) / HBLOCK_SIZE)-1) / HTABLE_SLOTS;
            Dir = Hive->Storage[Type].Map;
            HvpFreeMap(Hive, Dir, 0, Tables);

            if (Tables > 0) {
                CmpFree(Hive->Storage[Type].Map, sizeof(HMAP_DIRECTORY));  // free dir if it exists
            }
        }
        Hive->Storage[Type].Length = 0;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"\n"));
    //
    // Free the base block
    //
    (Hive->Free)(Hive->BaseBlock, sizeof(HBASE_BLOCK));
    Hive->BaseBlock = NULL;
    
    //
    // Free the dirty vector
    //
    if (Hive->DirtyVector.Buffer != NULL) {
        CmpFree((PVOID)(Hive->DirtyVector.Buffer), Hive->DirtyAlloc);
    }

    HvpFreeHiveFreeDisplay(Hive);
    return;
}

VOID
HvFreeHivePartial(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    HSTORAGE_TYPE Type
    )
/*++

Routine Description:

    Free the memory and associated maps for the end of a hive
    starting at Start.  The baseblock, hive, etc will not be touched.

Arguments:

    Hive - supplies a pointer to hive control structure for hive to
            partially free.

    Start - HCELL_INDEX of first bin to free, will free from this
            bin (inclusive) to the end of the hives stable storage.

    Type - Type of storage (Stable or Volatile) to be freed.

Return Value:

    NONE.

--*/
{
    PHMAP_DIRECTORY Dir;
    PHMAP_ENTRY     Me;
    HCELL_INDEX     Address;
    ULONG           StartTable;
    ULONG           Length;
    PHBIN           Bin;
    ULONG           Tables;
    ULONG           FirstBit;
    ULONG           LastBit;
    PFREE_HBIN      FreeBin;

    ASSERT(Hive->Flat == FALSE);
    ASSERT(Hive->ReadOnly == FALSE);

    Address = Start;
    Length = Hive->Storage[Type].Length;
    ASSERT(Address <= Length);

    if (Address == Length) {
        return;
    }

    //
    // Sweep through bin set
    //
    do {
        Me = HvpGetCellMap(Hive, Address + (Type*HCELL_TYPE_MASK));
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Address + (Type*HCELL_TYPE_MASK));
        if (Me->BinAddress & HMAP_DISCARDABLE) {
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            if (FreeBin->Flags & FREE_HBIN_DISCARDABLE) {
                CmpFree((PVOID)HBIN_BASE(Me->BinAddress), FreeBin->Size);
            } else {
                //
                // The bin has been freed, but quota is still charged.
                // Since the file will now shrink, the quota must be
                // returned here.
                //
                if( Me->BinAddress & HMAP_INPAGEDPOOL) {
                    //
                    // we charge quota only for bins in paged-pool
                    //
                    CmpReleaseGlobalQuota(FreeBin->Size);
                }
            }
            RemoveEntryList(&FreeBin->ListEntry);
            Address += FreeBin->Size;
            CmpFree(FreeBin, sizeof(FREE_HBIN));

        } else {
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            Address += HvpGetBinMemAlloc(Hive,Bin,Type);
            
            if( Me->BinAddress & HMAP_INPAGEDPOOL && HvpGetBinMemAlloc(Hive,Bin,Type) ) {
                //
                // free the bin only if it is allocated from paged pool
                //
                CmpFree(Bin, HvpGetBinMemAlloc(Hive,Bin,Type));
            }
        }
    } while (Address < Length);

    //
    // Free map table storage
    //
    Tables = (((Hive->Storage[Type].Length) / HBLOCK_SIZE) - 1) / HTABLE_SLOTS;
    Dir = Hive->Storage[Type].Map;
    if (Start > 0) {
        StartTable = ((Start-1) / HBLOCK_SIZE) / HTABLE_SLOTS;
    } else {
        StartTable = (ULONG)-1;
    }
    HvpFreeMap(Hive, Dir, StartTable+1, Tables);

    //
    // update hysteresis (eventually queue work item)
    //
    if( Type == Stable) {
        CmpUpdateSystemHiveHysteresis(Hive,(Start&(~HCELL_TYPE_MASK)),Hive->Storage[Type].Length);
    }

    Hive->Storage[Type].Length = (Start&(~HCELL_TYPE_MASK));

    if (Type==Stable) {
        //
        // Clear dirty vector for data past Hive->Storage[Stable].Length
        //
        FirstBit = Start / HSECTOR_SIZE;
        LastBit = Hive->DirtyVector.SizeOfBitMap;
        ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
        RtlClearBits(&Hive->DirtyVector, FirstBit, LastBit-FirstBit);
        Hive->DirtyCount = RtlNumberOfSetBits(&Hive->DirtyVector);
    }

    HvpAdjustHiveFreeDisplay(Hive,Hive->Storage[Type].Length,Type);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hivehint.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    hivehint.c

Abstract:

    This module contains free space display support.

Author:

    Dragos C. Sambotin (dragoss) 15-Jul-1999

Revision History:

--*/

#include "cmp.h"

NTSTATUS
HvpAdjustBitmap(
    IN PHHIVE           Hive,
    IN ULONG            HiveLength,
    IN OUT PRTL_BITMAP  Bitmap
    );

HCELL_INDEX
HvpFindFreeCellInBin(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    PHBIN           Bin
    );

HCELL_INDEX
HvpFindFreeCellInThisViewWindow(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    );

HCELL_INDEX
HvpScanForFreeCellInViewWindow(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     FileOffsetStart
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpAdjustHiveFreeDisplay)
#pragma alloc_text(PAGE,HvpFreeHiveFreeDisplay)
#pragma alloc_text(PAGE,HvpAdjustBitmap)
#pragma alloc_text(PAGE,HvpAddFreeCellHint)
#pragma alloc_text(PAGE,HvpRemoveFreeCellHint)
#pragma alloc_text(PAGE,HvpFindFreeCellInBin)
#pragma alloc_text(PAGE,HvpFindFreeCellInThisViewWindow)
#pragma alloc_text(PAGE,HvpScanForFreeCellInViewWindow)
#pragma alloc_text(PAGE,HvpCheckViewBoundary)
#pragma alloc_text(PAGE,HvpFindFreeCell)
#endif

NTSTATUS
HvpAdjustHiveFreeDisplay(
    IN PHHIVE           Hive,
    IN ULONG            HiveLength,
    IN HSTORAGE_TYPE    Type
    )
/*++

Routine Description:

    calls HvpAdjustBitmap for all bitmap sizes 

    !!! - to be called when the size of the hive changes (shrink or grow case).

Arguments:

    Hive - used for quota tracking.

    HiveLength - the new length of the hive.
    
    Type - Stable or Volatile.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG       i;
    NTSTATUS    Status;

    PAGED_CODE();

    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        Status = HvpAdjustBitmap(Hive,HiveLength,&(Hive->Storage[Type].FreeDisplay[i]) );
        if( !NT_SUCCESS(Status) ){
            return Status;
        }
    }
    
    return STATUS_SUCCESS;
}

#define ROUND_UP_NOZERO(a, b)   (a)?ROUND_UP(a,b):(b)
#define ROUND_INCREMENTS        0x100

VOID
HvpFreeHiveFreeDisplay(
    IN PHHIVE           Hive
    )
/*++

Routine Description:

    Frees the storage allocated for the free display bitmaps

Arguments:

    Hive - used for quota tracking.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG       i,j;
    NTSTATUS    Status;
    ULONG       BufferSize;

    PAGED_CODE();

    for( i=Stable;i<=Volatile;i++) {
        //
        // we may loose some quota here; due to rounding
        // we can prevent that by keeping the real size of 
        // the bitmaps as a member of the hive struct
        //
        BufferSize = ROUND_UP_NOZERO(Hive->Storage[i].FreeDisplay[0].SizeOfBitMap / 8,ROUND_INCREMENTS);             

        for (j = 0; j < HHIVE_FREE_DISPLAY_SIZE; j++) {
            if( Hive->Storage[i].FreeDisplay[j].Buffer != NULL ) {
                (Hive->Free)(Hive->Storage[i].FreeDisplay[j].Buffer, BufferSize);
            }
        }
    }
    
    return;
}

NTSTATUS
HvpAdjustBitmap(
    IN PHHIVE           Hive,
    IN ULONG            HiveLength,
    IN OUT PRTL_BITMAP  Bitmap
    )
/*++

Routine Description:

    When the length of the hive grows/shrinks, adjust the bitmap accordingly.
    - allocates a bitmap buffer large enough.
    - copies the relevant information from the old bitmap.

Arguments:

    Hive - used for quota tracking.

    HiveLength - the new length of the hive.
    
    Bitmap - bitmap to operate on.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG       VectorSize;
    ULONG       NewBufferSize;
    ULONG       OldBufferSize;
    PULONG      Vector;
    PULONG      OldVector;
    ULONG       OldVectorSize;

    PAGED_CODE();

    VectorSize = HiveLength / HBLOCK_SIZE;  // Vector size == bits

    NewBufferSize = ROUND_UP_NOZERO( (VectorSize + 7) / 8,ROUND_INCREMENTS);             // BufferSize == Bytes

    if( Bitmap->SizeOfBitMap == 0 ) {
        OldBufferSize = 0;
    } else {
        OldBufferSize = ROUND_UP_NOZERO( (Bitmap->SizeOfBitMap + 7) / 8, ROUND_INCREMENTS);
    }
    
    if( NewBufferSize <= OldBufferSize ) {
        //
        // We don't shrink the vector; next time we grow, we'll perform 
        // the adjustments
        //


        //
        // Clear all the unused bits and return;
        //
        // we don't really need to do this as nobody will write in here
        // we'll drop it in the final implementation
        //
        OldVectorSize = Bitmap->SizeOfBitMap;
        //
        // set the new size
        //
        RtlInitializeBitMap(Bitmap,Bitmap->Buffer,VectorSize);
        if( OldVectorSize < VectorSize ) {
            RtlClearBits (Bitmap,OldVectorSize,VectorSize - OldVectorSize);
        }
        return STATUS_SUCCESS;
    }

    //
    // else, the bitmap has enlarged. Allocate a new buffer and copy the bits already set.
    //
    Vector = (PULONG)((Hive->Allocate)(NewBufferSize, TRUE,CM_FIND_LEAK_TAG39));
    if (Vector == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    OldVector = Bitmap->Buffer;
    //CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"HvpAdjustBitmap: Old %lu :: %lu (%lx) New %lu :: %lu (%lx)\n",OldBufferSize,Bitmap->SizeOfBitMap,OldVector,NewBufferSize,VectorSize,Vector));
    RtlZeroMemory(Vector,NewBufferSize);
    RtlInitializeBitMap(Bitmap, Vector, VectorSize);

    if( OldVector != NULL ) {
        //
        // copy the already set bits
        //
        RtlCopyMemory (Vector,OldVector,OldBufferSize);

        //
        // Free the old vector
        //
        (Hive->Free)(OldVector, OldBufferSize);
    }

    return STATUS_SUCCESS;
}

VOID
HvpAddFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Sets the corresponding bit in the bitmap

Arguments:

    Hive - hive operating on

    Cell - free cell
    
    Index - index in FreeDisplay (based on the free cell size)

    Type - storage type (Stable or Volatile)

Return Value:

    VOID

--*/
{
    ULONG           BinIndex;
    PHMAP_ENTRY     Me;
    PHBIN           Bin;

    PAGED_CODE();

    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);

    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
    //
    // compute the bin index and for the begining of the bin
    //
    BinIndex = Bin->FileOffset / HBLOCK_SIZE;
    
    RtlSetBits (&(Hive->Storage[Type].FreeDisplay[Index]), BinIndex, Bin->Size / HBLOCK_SIZE);

    Hive->Storage[Type].FreeSummary |= (1 << Index);
}

VOID
HvpRemoveFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Clears the corresponding bit in the bitmap

Arguments:

    Hive - hive operating on

    Cell - free cell
    
    Index - index in FreeDisplay (based on the free cell size)

    Type - storage type (Stable or Volatile)

Return Value:

    VOID

--*/
{
    ULONG           BinIndex;
    ULONG           TempIndex;
    PHMAP_ENTRY     Me;
    PHBIN           Bin;
    ULONG           CellOffset;
    ULONG           Size;
    PHCELL          p;
    BOOLEAN         CellFound = FALSE;

    PAGED_CODE();

    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);

    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);

    CellOffset = Bin->FileOffset + sizeof(HBIN);

    
#ifdef CM_MAP_NO_READ
    //
    // we ned to be protected against exception raised by the FS while faulting in data
    //
    try {
#endif //CM_MAP_NO_READ

        //
        // There is a chance we can find a suitable free cell
        //

        p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

        while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

            //
            // if free cell, check it out, add it to free list for hive
            //
            if (p->Size >= 0) {

                Size = (ULONG)p->Size;

                HvpComputeIndex(TempIndex, Size);
                if ((Index == TempIndex) && (CellOffset != (Cell&(~HCELL_TYPE_MASK)) )) {
                    //
                    // there is at least one free cell of this size (this one)
                    // different than the one being delisted
                    //
                    CellFound = TRUE;
                    break;
                }

            } else {
                //
                // used cell
                //
                Size = (ULONG)(p->Size * -1);

            }

            ASSERT( ((LONG)Size) >= 0);
            p = (PHCELL)((PUCHAR)p + Size);
            CellOffset += Size;
        }

#ifdef CM_MAP_NO_READ
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpRemoveFreeCellHint: exception thrown ehile faulting in data, code:%08lx\n", GetExceptionCode()));
        //
        // better not use cells inthis range rather than leaving false hints
        //
        CellFound = FALSE;
    }
#endif //CM_MAP_NO_READ
    
    if( CellFound == FALSE ) {
        //
        // no cell with this index was found
        // compute the bin index and for the begining of the bin
        //
        BinIndex = Bin->FileOffset / HBLOCK_SIZE;
    
        RtlClearBits (&(Hive->Storage[Type].FreeDisplay[Index]), BinIndex, Bin->Size / HBLOCK_SIZE);
    }

    if( RtlNumberOfSetBits(&(Hive->Storage[Type].FreeDisplay[Index]) ) != 0 ) {
        //
        // there are still some other free cells of this size
        //
        Hive->Storage[Type].FreeSummary |= (1 << Index);
    } else {
        //
        // entire bitmap is 0 (i.e. no other free cells of this size)
        //
        Hive->Storage[Type].FreeSummary &= (~(1 << Index));
    }
}

HCELL_INDEX
HvpFindFreeCellInBin(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    PHBIN           Bin 
    )
/*++

Routine Description:

    Lookup for a free cell with the size NewSize in this particular bin

Arguments:

    Hive - target hive.

    Index - index in FreeDisplay (based on the free cell size)

    NewSize - desired size

    Type - storage type (Stable or Volatile)

    Bin - Bin in question

Return Value:

    A free cellindex with a size bigger than NewSize, or HCELL_NIL

--*/
{

    ULONG           BinIndex;
    ULONG           CellOffset;
    PHCELL          p;
    ULONG           BinOffset;
    ULONG           Size;
    HCELL_INDEX     cellindex;
    ULONG           FoundCellIndex;

    PAGED_CODE();

    BinOffset = Bin->FileOffset;
    BinIndex = BinOffset/HBLOCK_SIZE;

    if( RtlCheckBit(&(Hive->Storage[Type].FreeDisplay[Index]), BinIndex) == 0 ) {
        //
        // no hint for this bin
        //
        return HCELL_NIL;
    }

    CellOffset = sizeof(HBIN);
    
#ifdef CM_MAP_NO_READ
    //
    // we ned to be protected against exception raised by the FS while faulting in data
    //
    try {
#endif //CM_MAP_NO_READ

        //
        // There is a chance we can find a suitable free cell
        //
        p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

        while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

            //
            // if free cell, check it out, add it to free list for hive
            //
            if (p->Size >= 0) {

                Size = (ULONG)p->Size;

                //
                // cell is free, and is not obviously corrupt, add to free list
                //
                CellOffset = (ULONG)((PUCHAR)p - (PUCHAR)Bin);
                cellindex = BinOffset + CellOffset + (Type*HCELL_TYPE_MASK);

                if (NewSize <= (ULONG)Size) {
                    //
                    // Found a big enough cell.
                    //
                    HvpComputeIndex(FoundCellIndex, Size);
                    if( Index == FoundCellIndex ) {
                        //
                        // and enlisted at the same index (we want to avoid fragmentation if possible!)
                        //

                        if (! HvMarkCellDirty(Hive, cellindex)) {
                            return HCELL_NIL;
                        }

                        HvpDelistFreeCell(Hive, cellindex, Type);

                        ASSERT(p->Size > 0);
                        ASSERT(NewSize <= (ULONG)p->Size);
                        return cellindex;
                    }
                }

            } else {
                //
                // used cell
                //
                Size = (ULONG)(p->Size * -1);

            }

            ASSERT( ((LONG)Size) >= 0);
            p = (PHCELL)((PUCHAR)p + Size);
        }
#ifdef CM_MAP_NO_READ
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpFindFreeCellInBin: exception thrown ehile faulting in data, code:%08lx\n", GetExceptionCode()));
        return HCELL_NIL;
    }
#endif //CM_MAP_NO_READ

    //
    // no free cell matching this size on this bin ; We did all this work for nothing!
    //
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpFindFreeCellInBin] (Offset,Size) = (%lx,%lx) ==> No Match\n",BinOffset,Bin->Size));
    return HCELL_NIL;
}

HCELL_INDEX
HvpScanForFreeCellInViewWindow(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     FileOffsetStart
    )
/*++

Routine Description:

    Lookup for a free cell with the size NewSize in the CM_VIEW_SIZE window defined by
    Vicinity. 

    If it doesn't find a free cell for the specifed index, tries with the 


Arguments:

    Hive - target hive.

    Index - index in FreeDisplay (based on the free cell size)

    NewSize - desired size

    Type - storage type (Stable or Volatile)

    Vicinity - defines the window; it is never HCELL_NIL !!!

Return Value:

    A free cellindex with a size bigger than NewSize, or HCELL_NIL

Note:

    Vicinity is a physical file offset at this point. we need to 
    convert it to a logical one prior to accessing the map
--*/
{
    ULONG           FileOffsetEnd;
    HCELL_INDEX     Cell;
    PHMAP_ENTRY     Me;
    PHBIN           Bin;
    PFREE_HBIN      FreeBin;
    ULONG           BinFileOffset;
    ULONG           BinSize;

    PAGED_CODE();

    FileOffsetEnd = FileOffsetStart + CM_VIEW_SIZE;
    FileOffsetEnd -= HBLOCK_SIZE;
    if( FileOffsetStart != 0 ) {
        FileOffsetStart -= HBLOCK_SIZE;
    }
    if( FileOffsetEnd > Hive->Storage[Type].Length ) {
        FileOffsetEnd = Hive->Storage[Type].Length;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"\t[HvpScanForFreeCellInViewWindow] (Start,End) = (%lx,%lx) Size = %lx\n",FileOffsetStart,FileOffsetEnd,Hive->Storage[Type].Length));

    //
    // sanity ASSERT
    //
    ASSERT( FileOffsetStart < FileOffsetEnd );


    //
    // the caller already checked for this; remember, hints are for real!
    //
    ASSERT( !RtlAreBitsClear( &(Hive->Storage[Type].FreeDisplay[Index]),FileOffsetStart/HBLOCK_SIZE,(FileOffsetEnd - FileOffsetStart) / HBLOCK_SIZE) );
    
    while( FileOffsetStart < FileOffsetEnd ) {
        Cell = FileOffsetStart + (Type*HCELL_TYPE_MASK);
        Me = HvpGetCellMap(Hive, Cell);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);

        //
        // skip discarded bins
        //
        if(Me->BinAddress & HMAP_DISCARDABLE) {
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            if( FreeBin->FileOffset == FileOffsetStart ) {
                FileOffsetStart += FreeBin->Size;
            } else {
                //
                // the bin does not start in this window;
                // skip to the next bin in this window
                //
                FileOffsetStart = FreeBin->FileOffset + FreeBin->Size;
            }
            continue;
        }

        if((Me->BinAddress & (HMAP_INVIEW|HMAP_INPAGEDPOOL)) == 0) {
            //
            // bin is not mapped, map it now!!!
            // do not touch the view as we may iterate through 
            // the hole hive; this will keep the view for this window
            // mapped, as we hold the registry lock exclusive
            //
            if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,Cell,FALSE)) ) {
                //
                // cannot map bin due to insufficient resources
                //
                return HCELL_NIL;
            }
            ASSERT( Me->BinAddress & HMAP_INVIEW );
        }

        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);

#ifdef CM_MAP_NO_READ
        //
        // we need to protect against in-page-errors thrown by mm while faulting in data
        //
        try {
#endif //CM_MAP_NO_READ
        BinFileOffset = Bin->FileOffset;
        BinSize = Bin->Size;
#ifdef CM_MAP_NO_READ
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpScanForFreeCellInViewWindow: exception thrown while faulting in data, code:%08lx\n", GetExceptionCode()));
            return HCELL_NIL;
        }
#endif //CM_MAP_NO_READ
        if( BinFileOffset == FileOffsetStart ) {

            Cell = HvpFindFreeCellInBin(Hive,Index,NewSize,Type,Bin);
            if( Cell != HCELL_NIL ) {
                //found it!
                return Cell;
            }
                
            FileOffsetStart += BinSize;
        } else {
            //
            // bin does not start in this CM_VIEW_SIZE window; skip to the next bin in this window
            //
            FileOffsetStart = BinFileOffset + BinSize;
        }
    }

    //
    // no free cell matching this size on the CM_VIEW_SIZE window ; We did all this work for nothing!
    //
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpScanForFreeCellInViewWindow] (Start,End) = (%lx,%lx) ==> No Match\n",FileOffsetStart,FileOffsetEnd));
    return HCELL_NIL;
}

HCELL_INDEX
HvpFindFreeCellInThisViewWindow(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity
    )
/*++

Routine Description:

    Lookup for a free cell with the size NewSize in the window defined by
    Vicinity. 

    If it doesn't find a free cell for the specifed index, tries with the 


Arguments:

    Hive - target hive.

    Index - index in FreeDisplay (based on the free cell size)

    NewSize - desired size

    Type - storage type (Stable or Volatile)

    Vicinity - defines the window; it is never HCELL_NIL !!!

Return Value:

    A free cellindex with a size bigger than NewSize, or HCELL_NIL

Note:

    Vicinity is a logical file offset at this point. This function
    converts it to a physical one, and HvpScanForFindFreeCellInViewWindow
    converts it back to logical prior to getting the cell map.

--*/
{
    HCELL_INDEX     Cell;
    ULONG           FileOffsetStart;
    ULONG           FileOffsetEnd;
    ULONG           VicinityViewOffset;
    ULONG           Summary;
    ULONG           Offset;
    ULONG           RunLength;

    PAGED_CODE();

    ASSERT( Vicinity != HCELL_NIL );

    VicinityViewOffset = ((Vicinity&(~HCELL_TYPE_MASK)) + HBLOCK_SIZE) & (~(CM_VIEW_SIZE - 1));
    FileOffsetStart = VicinityViewOffset & (~(CM_VIEW_SIZE - 1));

    FileOffsetEnd = FileOffsetStart + CM_VIEW_SIZE;
    if( FileOffsetEnd > (Hive->Storage[Type].Length + HBLOCK_SIZE) ) {
        FileOffsetEnd = Hive->Storage[Type].Length + HBLOCK_SIZE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpFindFreeCellInThisViewWindow] Vicinity = %lx (Start,End) = (%lx,%lx) Size = %lx\n",Vicinity,FileOffsetStart,FileOffsetEnd,Hive->Storage[Type].Length));

    //
    // sanity assert
    //
    ASSERT( FileOffsetStart < FileOffsetEnd );
    
    //
    // at this point the offset is physical (file-oriented, i.e. it is
    // translated with HBLOCK_SIZE; HvpScanForFreeCellInViewWindow will do the 
    // reverse computation to adjust the offset)
    //

    //
    // Compute Summary vector of Display entries that are non null
    //
    Summary = Hive->Storage[Type].FreeSummary;
    Summary = Summary & ~((1 << Index) - 1);
    //
    // We now have a summary of lists that are non-null and may
    // contain entries large enough to satisfy the request.
    // Iterate through the list and pull the first cell that is
    // big enough.  If no cells are big enough, advance to the
    // next non-null list.
    //
    ASSERT(HHIVE_FREE_DISPLAY_SIZE == 24);

    Offset = FileOffsetStart?(FileOffsetStart-HBLOCK_SIZE):0;
    RunLength = FileOffsetEnd - FileOffsetStart;
    if( FileOffsetStart == 0 ) {
        //
        // first run is one block shorter !
        //
        RunLength -= HBLOCK_SIZE;
    }
    Offset /= HBLOCK_SIZE;
    RunLength /= HBLOCK_SIZE;

    while (Summary != 0) {
        if (Summary & 0xff) {
            Index = CmpFindFirstSetRight[Summary & 0xff];
        } else if (Summary & 0xff00) {
            Index = CmpFindFirstSetRight[(Summary & 0xff00) >> 8] + 8;
        } else  {
            ASSERT(Summary & 0xff0000);
            Index = CmpFindFirstSetRight[(Summary & 0xff0000) >> 16] + 16;
        }

        //
        // we go down this path only if we have any hints
        //
        if( !RtlAreBitsClear( &(Hive->Storage[Type].FreeDisplay[Index]),Offset,RunLength) ) {

            //
            // we have a reason to scan this view
            //
            Cell = HvpScanForFreeCellInViewWindow(Hive,Index,NewSize,Type,VicinityViewOffset);
            if( Cell != HCELL_NIL ) {
                // found it
                return Cell;
            }

            //
            // if we got here, the hints are invalid
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpFindFreeCellInThisViewWindow] (Start,End) = (%lx,%lx) Offset = %lx RunLength = %lx\n",FileOffsetStart,FileOffsetEnd,Offset,RunLength));

        }
        //
        // No suitable cell was found of this size.
        // Clear the bit in the summary and try the
        // next biggest size
        //
        ASSERT(Summary & (1 << Index));
        Summary = Summary & ~(1 << Index);
    }
    
    return HCELL_NIL;
}

HCELL_INDEX
HvpFindFreeCell(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    )
/*++

Routine Description:

    Lookup for a free cell. First try is in the CM_VIEW_SIZE window defined 
    by Vicinity. If no free cell is found in this window (or vicinity 
    if NIL), entire hive is searched (window by window).

Arguments:

    Hive - target hive.

    Index - index in FreeDisplay (based on the free cell size)

    NewSize - desired size

    Type - storage type (Stable or Volatile)

    Vicinity - defines the window.

Return Value:

    A free cellindex with a size bigger than NewSize, or HCELL_NIL

Optimization:

    When Vicinity is HCELL_NIL or if a cell is not found in the same window
    as the vicinity, we don't really care where the cell gets allocated.
    So, rather than iterating the whole hive, is a good ideea to search first 
    in the pinned view list, then in the mapped view list, and at the end
    in the rest of unmapped views.

    DRAGOS: This is not finished: need to determine whether we need it or not
--*/
{
    HCELL_INDEX         Cell = HCELL_NIL;
    ULONG               FileOffset = 0;
    PCMHIVE             CmHive;

/*  
    PCMHIVE             CmHive;
    PCM_VIEW_OF_FILE    CmView;
    USHORT              NrViews;
*/

    PAGED_CODE();

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);
#if DBG
    {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpFindFreeCell] CellSize = %lu Vicinity = %lx :: Hive (%p) (%.*S)  ...",NewSize,Vicinity,Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
    }
#endif

    //
    // Vicinity should have the same storage as the new cell !
    //
    ASSERT( (Vicinity == HCELL_NIL) || (HvGetCellType(Vicinity) == (ULONG)Type) );
    
    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);



    if( (Vicinity != HCELL_NIL) &&  (CmHive->GrowOnlyMode == FALSE) ) {
        //
        // try first in this window
        //
        Cell = HvpFindFreeCellInThisViewWindow(Hive,Index,NewSize,Type,Vicinity);
    }

    if( Cell != HCELL_NIL ) {
        //
        // found it!!!
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"found cell %lx \n",Cell));
        return Cell;
    } 

/*
    //
    // Optimization:
    //      Step 1 : Search first in the pinned views
    //
    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);
    //
    // iterate through the pinned views
    //
    CmView = (PCM_VIEW_OF_FILE)CmHive->PinViewListHead.Flink;

    for(NrViews = CmHive->PinnedViews;NrViews;NrViews--) {
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);
        
        ASSERT( (CmView->FileOffset + CmView->Size) != 0 && (CmView->ViewAddress != 0));

        FileOffset = CmView->FileOffset;
        // adjust the offset
        if( FileOffset > 0 ) {
            FileOffset -= HBLOCK_SIZE;
        }

        //
        // search in this window
        //
        Cell = FileOffset + (Type*HCELL_TYPE_MASK);
        Cell = HvpFindFreeCellIn256kWindow(Hive,Index,NewSize,Type,Cell);
        if( Cell != HCELL_NIL ) {
            //
            // found it!
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"found cell %lx \n",Cell));
            return Cell;
        }

        CmView = (PCM_VIEW_OF_FILE)CmView->PinViewList.Flink;
    }

    //
    // Step 2: Search in the mapped views
    //
    CmView = (PCM_VIEW_OF_FILE)CmHive->LRUViewListHead.Flink;

    for(NrViews = CmHive->MappedViews;NrViews;NrViews--) {
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    LRUViewList);
        
        ASSERT( (CmView->FileOffset + CmView->Size) != 0 && (CmView->ViewAddress != 0));

        FileOffset = CmView->FileOffset;
        // adjust the offset
        if( FileOffset > 0 ) {
            FileOffset -= HBLOCK_SIZE;
        }

        //
        // search in this window
        //
        Cell = FileOffset + (Type*HCELL_TYPE_MASK);
        Cell = HvpFindFreeCellIn256kWindow(Hive,Index,NewSize,Type,Cell);
        if( Cell != HCELL_NIL ) {
            //
            // found it!
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"found cell %lx \n",Cell));
            return Cell;
        }

        CmView = (PCM_VIEW_OF_FILE)CmView->LRUViewList.Flink;
    }
    FileOffset = 0;
*/
    //
    // bad luck!; we did not found it in this window. 
    // We have to search the entire hive
    //

    while( FileOffset < Hive->Storage[Type].Length ) {
        //
        // don't search again in the vicinity window
        // we already did it once
        //
		if( ( ((CmHive->GrowOnlyMode == FALSE) || (Type == Volatile)) && 
			  ((Vicinity == HCELL_NIL) || (HvpCheckViewBoundary(FileOffset,Vicinity&(~HCELL_TYPE_MASK)) == FALSE)) )  || 
            ( (CmHive->GrowOnlyMode == TRUE) && (FileOffset >= CmHive->GrowOffset) )
          ) {
            //
            // search in this window
            //
            Cell = FileOffset + (Type*HCELL_TYPE_MASK);
            Cell = HvpFindFreeCellInThisViewWindow(Hive,Index,NewSize,Type,Cell);
            if( Cell != HCELL_NIL ) {
                //
                // found it!
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"found cell %lx \n",Cell));
                return Cell;
            }
        }
        
        //
        // advance to the new window
        //
        if( FileOffset == 0) {
            // account for the base block
            FileOffset += (CM_VIEW_SIZE - HBLOCK_SIZE);
        } else {
            FileOffset += CM_VIEW_SIZE;
        }
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"No cell found.\n"));

    return HCELL_NIL;
}


BOOLEAN
HvpCheckViewBoundary(
                     IN ULONG Start,
                     IN ULONG End
    )
/*++

Routine Description:

    Checks if addresses are in the same CM_VIEW_SIZE boundary.
    We may convert this function to a macro for performance 
    reasons

Arguments:

    Start - starting address

    End - ending address

Return Value:

    TRUE - yes, addresses are in the same view

    FALSE - no, addresses are NOT in the same view

--*/
{
    PAGED_CODE();
    //
    // account for the header
    //
    Start += HBLOCK_SIZE;
    End += HBLOCK_SIZE;
    
    //
    // truncate to the CM_VIEW_SIZE segment
    //
    Start &= (~(CM_VIEW_SIZE - 1));
    End &= (~(CM_VIEW_SIZE - 1));

    if( Start != End ){
        return FALSE;
    } 
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hiveinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hiveinit.c

Abstract:

    Hive initialization code.

Author:

    Bryan M. Willman (bryanwi) 12-Sep-91

Environment:


Revision History:
    Dragos C. Sambotin (dragoss) 25-Jan-99
        Implementation of bin-size chunk loading of hives.
--*/

#include    "cmp.h"

VOID
HvpFillFileName(
    PHBASE_BLOCK            BaseBlock,
    PUNICODE_STRING         FileName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvInitializeHive)
#pragma alloc_text(PAGE,HvpFillFileName)
#pragma alloc_text(PAGE,HvpFreeAllocatedBins)
#endif

// Dragos: Modified functions
VOID
HvpFreeAllocatedBins(
    PHHIVE Hive
    )
/*++

Routine Description:

    Free all the bins allocated for the specified hive.
    It applies only to stable storage. Not all bins are allocated.
    Those that are not allocated have BinAddress set to 0
    
Arguments:

    Hive - supplies a pointer to hive control structure for hive who's bin to free.

Return Value:

    NONE.

--*/
{
    ULONG           Length;
    PHBIN           Bin;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_ENTRY     Me;
    PHMAP_TABLE     Tab;
    ULONG           i;
    ULONG           j;

    //
    // calculate the number of tables in the map
    //
    Length = Hive->Storage[Stable].Length;
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    if( Hive->Storage[Stable].Map ) {
        //
        // iterate through the directory 
        //
        for (i = 0; i <= Tables; i++) {
            Tab = Hive->Storage[Stable].Map->Directory[i];

            ASSERT(Tab);
            
            //
            // iterate through the slots in the directory
            //
            for(j=0;j<HTABLE_SLOTS;j++) {
                Me = &(Tab->Table[j]);
                //
                // BinAddress non-zero means allocated bin
                //
                if( Me->BinAddress ) {
                    //
                    // a bin is freed if it is a new alloc AND it resides in paged pool
                    //
                    if( (Me->BinAddress & HMAP_NEWALLOC) && (Me->BinAddress & HMAP_INPAGEDPOOL) ) {
                        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
                        (Hive->Free)(Bin, HvpGetBinMemAlloc(Hive,Bin,Stable));
                    }
                    
                    Me->BinAddress = 0;
                }
            }
        }
    }
   
}

NTSTATUS
HvInitializeHive(
    PHHIVE                  Hive,
    ULONG                   OperationType,
    ULONG                   HiveFlags,
    ULONG                   FileType,
    PVOID                   HiveData OPTIONAL,
    PALLOCATE_ROUTINE       AllocateRoutine,
    PFREE_ROUTINE           FreeRoutine,
    PFILE_SET_SIZE_ROUTINE  FileSetSizeRoutine,
    PFILE_WRITE_ROUTINE     FileWriteRoutine,
    PFILE_READ_ROUTINE      FileReadRoutine,
    PFILE_FLUSH_ROUTINE     FileFlushRoutine,
    ULONG                   Cluster,
    PUNICODE_STRING         FileName OPTIONAL
    )
/*++

Routine Description:

    Initialize a hive.

    Core HHive fields are always inited.

    File calls WILL be made BEFORE this call returns.

    Caller is expected to create/open files and store file handles
    in a way that can be derived from the hive pointer.

    Three kinds of initialization can be done, selected by OperationType:

        HINIT_CREATE

            Create a new hive from scratch.  Will have 0 storage.
            [Used to do things like create HARDWARE hive and for parts
             of SaveKey and RestoreKey]


        HINIT_MEMORY_INPLACE

            Build a hive control structure which allows read only
            access to a contiguous in-memory image of a hive.
            No part of the image will be copied, but a map will
            be made.
            [Used by osloader.]


        HINIT_FLAT

            Support very limited (read-only, no checking code) operation
            against a hive image.


        HINIT_MEMORY

            Create a new hive, using a hive image already in memory,
            at address supplied by pointer HiveData.  The data will
            be copied.  Caller is expected to free HiveData.
            [Used for SYSTEM hive]


        HINIT_FILE

            Create a hive, reading its data from a file.  Recovery processing
            via log file will be done if a log is available.  If a log
            is recovered, flush and clear operation will proceed.


        HINIT_MAPFILE

            Create a hive, reading its data from a file.  Data reading is
            done by mapping views of the file in the system cache.
            

  NOTE:   The HHive is not a completely opaque structure, because it
            is really only used by a limited set of code.  Do not assume
            that only this routine sets all of these values.


Arguments:

    Hive - supplies a pointer to hive control structure to be initialized
            to describe this hive.

    OperationType - specifies whether to create a new hive from scratch,
            from a memory image, or by reading a file from disk.

    HiveFlags - HIVE_VOLATILE - Entire hive is to be volatile, regardless
                                   of the types of cells allocated
                HIVE_NO_LAZY_FLUSH - Data in this hive is never written
                                   to disk except by an explicit FlushKey

    FileType - HFILE_TYPE_*, HFILE_TYPE_LOG set up for logging support respectively.

    HiveData - if present, supplies a pointer to an in memory image of
            from which to init the hive.  Only useful when OperationType
            is set to HINIT_MEMORY.

    AllocateRoutine - supplies a pointer to routine called to allocate
                        memory.  WILL be called before this routine returns.

    FreeRoutine - supplies a pointer to routine called to free memory.
                   CAN be called before this routine returns.

    FileSetSizeRoutine - supplies a pointer to a routine used to set the
                         size of a file. CAN be called before this
                         routine returns.

    FileWriteRoutine - supplies a pointer to routine called to write memory
                        to a file.

    FileReadRoutine - supplies a pointer to routine called to read from
                        a file into memory. CAN be called before this
                        routine returns.

    FileFlushRoutine - supplies a pointer to routine called to flush a file.

    Cluster - clustering factor in HSECTOR_SIZE units.  (i.e.  Size of
            physical sector in media / HSECTOR_SIZE.  1 for 512 byte
            physical sectors (or smaller), 2 for 1024, 4 for 2048, etc.
            (Numbers greater than 8 won't work.)

    FileName - some path like "...\system32\config\system", last
                32 or so characters will be copied into baseblock
                (and thus to disk) as a debugging aid.  May be null.


Return Value:

    NTSTATUS code.

--*/
{
    BOOLEAN         UseForIo;
    PHBASE_BLOCK    BaseBlock = NULL;
    NTSTATUS        Status;
    ULONG           i;
    ULONG           Alignment;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"HvInitializeHive:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"\tHive=%p\n", Hive));

    //
    // reject invalid parameter combinations
    //
    if ( (! ARGUMENT_PRESENT(HiveData)) &&
         ((OperationType == HINIT_MEMORY) ||
          (OperationType == HINIT_FLAT) ||
          (OperationType == HINIT_MEMORY_INPLACE))
       )
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ( ! ((OperationType == HINIT_CREATE) ||
            (OperationType == HINIT_MEMORY) ||
            (OperationType == HINIT_MEMORY_INPLACE) ||
            (OperationType == HINIT_FLAT) ||
            (OperationType == HINIT_FILE) ||
            (OperationType == HINIT_MAPFILE))
       )
    {
        return STATUS_INVALID_PARAMETER;
    }


    //
    // static and global control values
    //
    Hive->Signature = HHIVE_SIGNATURE;

    Hive->Allocate = AllocateRoutine;
    Hive->Free = FreeRoutine;
    Hive->FileSetSize = FileSetSizeRoutine;
    Hive->FileWrite = FileWriteRoutine;
    Hive->FileRead = FileReadRoutine;
    Hive->FileFlush = FileFlushRoutine;

    Hive->Log = (BOOLEAN)((FileType == HFILE_TYPE_LOG) ? TRUE : FALSE);

    if (Hive->Log  && (HiveFlags & HIVE_VOLATILE)) {
        return STATUS_INVALID_PARAMETER;
    }

    Hive->HiveFlags = HiveFlags;

    if ((Cluster == 0) || (Cluster > HSECTOR_COUNT)) {
        return STATUS_INVALID_PARAMETER;
    }
    Hive->Cluster = Cluster;

    Hive->RefreshCount = 0;

    Hive->StorageTypeCount = HTYPE_COUNT;


    Hive->Storage[Volatile].Length = 0;
#ifdef  HV_TRACK_FREE_SPACE
	Hive->Storage[Volatile].FreeStorage = 0;
#endif
    Hive->Storage[Volatile].Map = NULL;
    Hive->Storage[Volatile].SmallDir = NULL;
    Hive->Storage[Volatile].Guard = (ULONG)-1;
    Hive->Storage[Volatile].FreeSummary = 0;
    InitializeListHead(&Hive->Storage[Volatile].FreeBins);
    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        RtlInitializeBitMap(&(Hive->Storage[Volatile].FreeDisplay[i]), NULL, 0);
    }

    Hive->Storage[Stable].Length = 0;
#ifdef  HV_TRACK_FREE_SPACE
	Hive->Storage[Stable].FreeStorage = 0;
#endif
    Hive->Storage[Stable].Map = NULL;
    Hive->Storage[Stable].SmallDir = NULL;
    Hive->Storage[Stable].Guard = (ULONG)-1;
    Hive->Storage[Stable].FreeSummary = 0;
    InitializeListHead(&Hive->Storage[Stable].FreeBins);
    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        RtlInitializeBitMap(&(Hive->Storage[Stable].FreeDisplay[i]), NULL, 0);
    }

    RtlInitializeBitMap(&(Hive->DirtyVector), NULL, 0);
    Hive->DirtyCount = 0;
    Hive->DirtyAlloc = 0;
    Hive->LogSize = 0;

    Hive->GetCellRoutine = HvpGetCellPaged;
    Hive->ReleaseCellRoutine = NULL;
    Hive->Flat = FALSE;
    Hive->ReadOnly = FALSE;
    UseForIo = (BOOLEAN)!(Hive->HiveFlags & HIVE_VOLATILE);

    //
    // new create case
    //
    if (OperationType == HINIT_CREATE) {

        BaseBlock = (PHBASE_BLOCK)((Hive->Allocate)(sizeof(HBASE_BLOCK), UseForIo,CM_FIND_LEAK_TAG11));
        if (BaseBlock == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // Make sure the buffer we got back is cluster-aligned. If not, try
        // harder to get an aligned buffer.
        //
        Alignment = Cluster * HSECTOR_SIZE - 1;
        if (((ULONG_PTR)BaseBlock & Alignment) != 0) {
            (Hive->Free)(BaseBlock, sizeof(HBASE_BLOCK));
            BaseBlock = (PHBASE_BLOCK)((Hive->Allocate)(PAGE_SIZE, TRUE,CM_FIND_LEAK_TAG12));
            if (BaseBlock == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Return the quota for the extra allocation, as we are not really using
            // it and it will not be accounted for later when we free it.
            //
            CmpReleaseGlobalQuota(PAGE_SIZE - sizeof(HBASE_BLOCK));
        }

        BaseBlock->Signature = HBASE_BLOCK_SIGNATURE;
        BaseBlock->Sequence1 = 1;
        BaseBlock->Sequence2 = 1;
        BaseBlock->TimeStamp.HighPart = 0;
        BaseBlock->TimeStamp.LowPart = 0;
        BaseBlock->Major = HSYS_MAJOR;
        BaseBlock->Minor = HSYS_MINOR;
        BaseBlock->Type = HFILE_TYPE_PRIMARY;
        BaseBlock->Format = HBASE_FORMAT_MEMORY;
        BaseBlock->RootCell = HCELL_NIL;
        BaseBlock->Length = 0;
        BaseBlock->Cluster = Cluster;
        BaseBlock->CheckSum = 0;
        HvpFillFileName(BaseBlock, FileName);
        Hive->BaseBlock = BaseBlock;
        Hive->Version = HSYS_MINOR;
        Hive->BaseBlock->BootType = 0;

        return STATUS_SUCCESS;
    }

    //
    // flat image case
    //
    if (OperationType == HINIT_FLAT) {
        Hive->BaseBlock = (PHBASE_BLOCK)HiveData;
        Hive->Version = Hive->BaseBlock->Minor;
        Hive->Flat = TRUE;
        Hive->ReadOnly = TRUE;
        Hive->GetCellRoutine = HvpGetCellFlat;
        Hive->Storage[Stable].Length = Hive->BaseBlock->Length;
        Hive->StorageTypeCount = 1;
        Hive->BaseBlock->BootType = 0;

        // don't init this as we don't need it!!!
        //Status = HvpAdjustHiveFreeDisplay(Hive,Hive->Storage[Stable].Length,Stable);
        return STATUS_SUCCESS;
    }

    //
    // readonly image case
    //
    if (OperationType == HINIT_MEMORY_INPLACE) {
        BaseBlock = (PHBASE_BLOCK)HiveData;

        if ( (BaseBlock->Signature != HBASE_BLOCK_SIGNATURE)    ||
             (BaseBlock->Type != HFILE_TYPE_PRIMARY)            ||
             (BaseBlock->Major != HSYS_MAJOR)                   ||
             (BaseBlock->Minor > HSYS_MINOR_SUPPORTED)          ||
             (BaseBlock->Format != HBASE_FORMAT_MEMORY)         ||
             (BaseBlock->Sequence1 != BaseBlock->Sequence2)     ||
             (HvpHeaderCheckSum(BaseBlock) !=
              (BaseBlock->CheckSum))
           )
        {
            return STATUS_REGISTRY_CORRUPT;
        }

        Hive->BaseBlock = BaseBlock;
        Hive->Version = BaseBlock->Minor;
        Hive->ReadOnly = TRUE;
        Hive->StorageTypeCount = 1;
        Hive->BaseBlock->BootType = 0;
        Status = HvpAdjustHiveFreeDisplay(Hive,BaseBlock->Length,Stable);
        if( !NT_SUCCESS(Status) ) {
            return Status;
        }

        if ( !NT_SUCCESS(HvpBuildMap(
                            Hive,
                            (PUCHAR)HiveData + HBLOCK_SIZE
                            )))
        {
            return STATUS_REGISTRY_CORRUPT;
        }

        return(STATUS_SUCCESS);
    }

    //
    // memory copy case
    //
    if (OperationType == HINIT_MEMORY) {
        BaseBlock = (PHBASE_BLOCK)HiveData;

        if ( (BaseBlock->Signature != HBASE_BLOCK_SIGNATURE)    ||
             (BaseBlock->Type != HFILE_TYPE_PRIMARY)            ||
             (BaseBlock->Format != HBASE_FORMAT_MEMORY)         ||
             (BaseBlock->Major != HSYS_MAJOR)                   ||
             (BaseBlock->Minor > HSYS_MINOR_SUPPORTED)          ||
             (HvpHeaderCheckSum(BaseBlock) !=
              (BaseBlock->CheckSum))
           )
        {
            return STATUS_REGISTRY_CORRUPT;
        }

        Hive->BaseBlock = (PHBASE_BLOCK)((Hive->Allocate)(sizeof(HBASE_BLOCK), UseForIo,CM_FIND_LEAK_TAG13));
        if (Hive->BaseBlock==NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        //
        // Make sure the buffer we got back is cluster-aligned. If not, try
        // harder to get an aligned buffer.
        //
        Alignment = Cluster * HSECTOR_SIZE - 1;
        if (((ULONG_PTR)Hive->BaseBlock & Alignment) != 0) {
            (Hive->Free)(Hive->BaseBlock, sizeof(HBASE_BLOCK));
            Hive->BaseBlock = (PHBASE_BLOCK)((Hive->Allocate)(PAGE_SIZE, TRUE,CM_FIND_LEAK_TAG14));
            if (Hive->BaseBlock == NULL) {
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        RtlCopyMemory(Hive->BaseBlock, BaseBlock, HSECTOR_SIZE);
        Hive->BaseBlock->BootRecover = BaseBlock->BootRecover;
        Hive->BaseBlock->BootType = BaseBlock->BootType;

        Hive->Version = Hive->BaseBlock->Minor;

        Status = HvpAdjustHiveFreeDisplay(Hive,BaseBlock->Length,Stable);
        if( !NT_SUCCESS(Status) ) {
            (Hive->Free)(Hive->BaseBlock, sizeof(HBASE_BLOCK));
            Hive->BaseBlock = NULL;
            return Status;
        }

        if ( !NT_SUCCESS(HvpBuildMapAndCopy(Hive,
                                            (PUCHAR)HiveData + HBLOCK_SIZE))) {

            (Hive->Free)(Hive->BaseBlock, sizeof(HBASE_BLOCK));
            Hive->BaseBlock = NULL;
            return STATUS_REGISTRY_CORRUPT;
        }

        HvpFillFileName(Hive->BaseBlock, FileName);
        
      
        return(STATUS_SUCCESS);
    }

#ifndef CM_ENABLE_MAPPED_VIEWS
    if( OperationType == HINIT_MAPFILE ) {
        OperationType = HINIT_FILE;
    }
#endif //CM_ENABLE_MAPPED_VIEWS
    //
    // file read case
    //
    if (OperationType == HINIT_FILE) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvInitializeHive(%wZ,HINIT_FILE) :\n", FileName));
        //
        // get the file image (possible recovered via log) into memory
        //
        Status = HvLoadHive(Hive);
        if ((Status != STATUS_SUCCESS) && (Status != STATUS_REGISTRY_RECOVERED)) {
            return Status;
        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"\n"));
        
        if (Status == STATUS_REGISTRY_RECOVERED) {

            //
            // We have a good hive, with a log, and a dirty map,
            // all set up.  Only problem is that we need to flush
            // the file so the log can be cleared and new writes
            // posted against the hive.  Since we know we have
            // a good log in hand, we just write the hive image.
            //
            if ( ! HvpDoWriteHive(Hive, HFILE_TYPE_PRIMARY)) {
                //
                // DRAGOS: Here we need cleanup 
                // Clean up the bins already allocated 
                //
                HvpFreeAllocatedBins( Hive );

                return STATUS_REGISTRY_IO_FAILED;
            }

            //
            // If we get here, we have recovered the hive, and
            // written it out to disk correctly.  So we clear
            // the log here.
            //
            RtlClearAllBits(&(Hive->DirtyVector));
            Hive->DirtyCount = 0;
            (Hive->FileSetSize)(Hive, HFILE_TYPE_LOG, 0,0);
            Hive->LogSize = 0;
        }

        //
        // slam debug name data into base block
        //
        HvpFillFileName(Hive->BaseBlock, FileName);

        return STATUS_SUCCESS;
    }

    //
    // file map case
    //
    if (OperationType == HINIT_MAPFILE) {

        Hive->GetCellRoutine = HvpGetCellMapped;
        Hive->ReleaseCellRoutine = HvpReleaseCellMapped;

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvInitializeHive(%wZ,HINIT_MAPFILE) :\n", FileName));

        Status = HvMapHive(Hive);
        if ((Status != STATUS_SUCCESS) && (Status != STATUS_REGISTRY_RECOVERED)) {
            return Status;
        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"\n"));
        
        if (Status == STATUS_REGISTRY_RECOVERED) {

            //
            // We have a good hive, with a log, and a dirty map,
            // all set up.  Only problem is that we need to flush
            // the file so the log can be cleared and new writes
            // posted against the hive.  Since we know we have
            // a good log in hand, we just write the hive image.
            //
            if ( ! HvpDoWriteHive(Hive, HFILE_TYPE_PRIMARY)) {
                //
                // DRAGOS: Here we need cleanup 
                // Clean up the bins already allocated 
                //
                HvpFreeAllocatedBins( Hive );

                return STATUS_REGISTRY_IO_FAILED;
            }

            //
            // If we get here, we have recovered the hive, and
            // written it out to disk correctly.  So we clear
            // the log here.
            //
            RtlClearAllBits(&(Hive->DirtyVector));
            Hive->DirtyCount = 0;
            (Hive->FileSetSize)(Hive, HFILE_TYPE_LOG, 0,0);
            Hive->LogSize = 0;
        }

        //
        // slam debug name data into base block
        //
        HvpFillFileName(Hive->BaseBlock, FileName);

        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

VOID
HvpFillFileName(
    PHBASE_BLOCK            BaseBlock,
    PUNICODE_STRING         FileName
    )
/*++

Routine Description:

    Zero out the filename portion of the base block.
    If FileName is not NULL, copy last 64 bytes into name tail
        field of base block

Arguments:

    BaseBlock - supplies pointer to a base block

    FileName - supplies pointer to a unicode STRING

Return Value:

    None.

--*/
{
    ULONG   offset;
    ULONG   length;
    PUCHAR  sptr;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpFillFileName: %wZ\n", FileName));

    RtlZeroMemory((PVOID)&(BaseBlock->FileName[0]), HBASE_NAME_ALLOC);

    if (FileName == NULL) {
        return;
    }

    //
    // Account for 0 at the end, so we have nice debug spews
    //
    if (FileName->Length < HBASE_NAME_ALLOC) {
        offset = 0;
        length = FileName->Length;
    } else {
        offset = FileName->Length - HBASE_NAME_ALLOC + sizeof(WCHAR);
        length = HBASE_NAME_ALLOC - sizeof(WCHAR);
    }

    sptr = (PUCHAR)&(FileName->Buffer[0]);
    RtlCopyMemory(
        (PVOID)&(BaseBlock->FileName[0]),
        (PVOID)&(sptr[offset]),
        length
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hivesum.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivesum.c

Abstract:

    Hive header checksum module.

Author:

    Bryan M. Willman (bryanwi) 9-Apr-92

Environment:


Revision History:

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpHeaderCheckSum)
#endif

ULONG
HvpHeaderCheckSum(
    PHBASE_BLOCK    BaseBlock
    )
/*++

Routine Description:

    Compute the checksum for a hive disk header.

Arguments:

    BaseBlock - supplies pointer to the header to checksum

Return Value:

    the check sum.

--*/
{
    ULONG   sum;
    ULONG   i;

    sum = 0;
    for (i = 0; i < 127; i++) {
        sum ^= ((PULONG)BaseBlock)[i];
    }
    if (sum == (ULONG)-1) {
        sum = (ULONG)-2;
    }
    if (sum == 0) {
        sum = 1;
    }
    return sum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hiveload.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hiveload.c

Abstract:

    This module implements procedures to read a hive into memory, applying
    logs, etc.

    NOTE:   Alternate image loading is not supported here, that is
            done by the boot loader.

Author:

    Bryan M. Willman (bryanwi) 30-Mar-92

Environment:


Revision History:
    Dragos C. Sambotin (dragoss) 25-Jan-99
        Implementation of bin-size chunk loading of hives.
    Dragos C. Sambotin (dragoss) 10-Apr-99
        64K IO reads when loading the hive

--*/

#include    "cmp.h"

#define		IO_BUFFER_SIZE  _64K  //64K

typedef enum _RESULT {
    NotHive,
    Fail,
    NoMemory,
    HiveSuccess,
    RecoverHeader,
    RecoverData,
    SelfHeal
} RESULT;

RESULT
HvpGetHiveHeader(
    PHHIVE          Hive,
    PHBASE_BLOCK    *BaseBlock,
    PLARGE_INTEGER  TimeStamp
    );

RESULT
HvpGetLogHeader(
    PHHIVE          Hive,
    PHBASE_BLOCK    *BaseBlock,
    PLARGE_INTEGER  TimeStamp
    );

RESULT
HvpRecoverData(
    PHHIVE          Hive
    );

NTSTATUS
HvpReadFileImageAndBuildMap(
                            PHHIVE  Hive,
                            ULONG   Length
                            );

NTSTATUS
HvpMapFileImageAndBuildMap(
                            PHHIVE  Hive,
                            ULONG   Length
                            );

VOID
HvpDelistBinFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    HSTORAGE_TYPE Type
    );

NTSTATUS
HvpRecoverWholeHive(PHHIVE  Hive,
                    ULONG   FileOffset);
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvMapHive)
#pragma alloc_text(PAGE,HvLoadHive)
#pragma alloc_text(PAGE,HvpGetHiveHeader)
#pragma alloc_text(PAGE,HvpGetLogHeader)
#pragma alloc_text(PAGE,HvpRecoverData)
#pragma alloc_text(PAGE,HvpReadFileImageAndBuildMap)
#pragma alloc_text(PAGE,HvpMapFileImageAndBuildMap)
#pragma alloc_text(PAGE,HvpRecoverWholeHive)
#pragma alloc_text(PAGE,HvCloneHive)
#pragma alloc_text(PAGE,HvShrinkHive)
#endif

extern  PUCHAR      CmpStashBuffer;
extern  ULONG       CmpStashBufferSize;

extern struct {
    PHHIVE      Hive;
    ULONG       Status;
    ULONG       Space;
    HCELL_INDEX MapPoint;
    PHBIN       BinPoint;
} HvCheckHiveDebug;

extern struct {
    PHHIVE      Hive;
    ULONG       FileOffset;
    ULONG       FailPoint; // look in HvpRecoverData for exact point of failure
} HvRecoverDataDebug;

#if 0
VOID
HvDumpFileObjectState(
                        IN HANDLE FileHandle
                      )
{
    NTSTATUS        Status;
    PFILE_OBJECT    FileObject;

    Status = ObReferenceObjectByHandle ( FileHandle,
                                         FILE_READ_DATA | FILE_WRITE_DATA,
                                         IoFileObjectType,
                                         KernelMode,
                                         (PVOID *)(&FileObject),
                                         NULL );
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"[HvDumpFileObjectState] Could not reference file object status = %x\n",Status));
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"[HvDumpFileObjectState] FileObject = %p \n",FileObject));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"                        \t SharedCacheMap     = %p \n",FileObject->SectionObjectPointer->SharedCacheMap));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"                        \t DataSectionObject  = %p \n",FileObject->SectionObjectPointer->DataSectionObject));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"                        \t ImageSectionObject = %p \n\n",FileObject->SectionObjectPointer->ImageSectionObject));
        ObDereferenceObject((PVOID)(FileObject));

    }    

}
#endif //0

// Dragos: Modified functions:

NTSTATUS
HvMapHive(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Hive must be fully initialized, in particular, file handles
    must be set up.  This routine is not intended for loading hives
    from images already in memory.

    This routine will apply whatever fixes are available for errors
    in the hive image.  In particular, if a log exists, and is applicable,
    this routine will automatically apply it.

    The difference from HvLoadHive is that this routine is NOT loading the 
    hive into memory. It instead maps view of the hive in memory and does 
    the bin enlisting and hive checking stuff.

    If errors are detected, the memory hive-loading is performed, log is applied
    and then bins are discarded.

    ALGORITHM:

        call HvpGetHiveHeader()

        if (NoMemory or NoHive)
            return failure

        if (RecoverData or RecoverHeader) and (no log)
            return falure

        if (RecoverHeader)
            call HvpGetLogHeader
            if (fail)
                return failure
            fix up baseblock

        Read Data

        if (RecoverData or RecoverHeader)
            HvpRecoverData
            return STATUS_REGISTRY_RECOVERED

        clean up sequence numbers

        return success OR STATUS_REGISTRY_RECOVERED

    If STATUS_REGISTRY_RECOVERED is returned, then

        If (Log) was used, DirtyVector and DirtyCount are set,
            caller is expected to flush the changes (using a
            NEW log file)

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    TailDisplay - array containing the tail ends of the free cell lists - optional

Return Value:

    STATUS:

        STATUS_INSUFFICIENT_RESOURCES   - memory alloc failure, etc
        STATUS_NOT_REGISTRY_FILE        - bad signatures and the like
        STATUS_REGISTRY_CORRUPT         - bad signatures in the log,
                                          bad stuff in both in alternate,
                                          inconsistent log

        STATUS_REGISTRY_IO_FAILED       - data read failed

        STATUS_RECOVERED                - successfully recovered the hive,
                                          a semi-flush of logged data
                                          is necessary.

        STATUS_SUCCESS                  - it worked, no recovery needed

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           result1;
    ULONG           result2;
    NTSTATUS        status;
    LARGE_INTEGER   TimeStamp;

#if DBG
    UNICODE_STRING  HiveName;
#endif

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);

#if 0
    HvDumpFileObjectState(((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY]);
#endif 

    BaseBlock = NULL;
    result1 = HvpGetHiveHeader(Hive, &BaseBlock, &TimeStamp);

    //
    // bomb out for total errors
    //
    if (result1 == NoMemory) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit1;
    }
    if (result1 == NotHive) {
        status = STATUS_NOT_REGISTRY_FILE;
        goto Exit1;
    }

    //
    // if recovery needed, and no log, bomb out
    //
    if ( ((result1 == RecoverData) ||
          (result1 == RecoverHeader))  &&
          (Hive->Log == FALSE) )
    {
        status = STATUS_REGISTRY_CORRUPT;
        goto Exit1;
    }

    //
    // need to recover header using log, so try to get it from log
    //
    if (result1 == RecoverHeader) {
        result2 = HvpGetLogHeader(Hive, &BaseBlock, &TimeStamp);
        if (result2 == NoMemory) {
            status =  STATUS_INSUFFICIENT_RESOURCES;
            goto Exit1;
        }
        if (result2 == Fail) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Exit1;
        }
        BaseBlock->Type = HFILE_TYPE_PRIMARY;
        if( result2 == SelfHeal ) {
            //
            // tag as self heal so we can fire a warning later on.
            //
            BaseBlock->BootType = HBOOT_SELFHEAL;
        } else {
            BaseBlock->BootType = 0;
        }
    } else {
        BaseBlock->BootType = 0;
    }

    Hive->BaseBlock = BaseBlock;
    Hive->Version = Hive->BaseBlock->Minor;

#if DBG
    RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
#endif

    status = HvpAdjustHiveFreeDisplay(Hive,BaseBlock->Length,Stable);
    if( !NT_SUCCESS(status) ) {
        goto Exit1;
    }

    //
    // at this point, we have a sane baseblock.  we know for sure that the 
    // pimary registry file is valid, so we don't need any data recovery
    //

#if 0
    HvDumpFileObjectState(((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY]);
#endif

#if DBG
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Aquiring FileObject for hive (%p) (%.*S) ...",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
#endif
    status = CmpAquireFileObjectForFile((PCMHIVE)Hive,((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY],&(((PCMHIVE)Hive)->FileObject));
#if DBG
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL," Status = %lx\n",status));
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Initializing HiveViewList for hive (%p) (%.*S) \n\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
#endif

    if( !NT_SUCCESS(status) ) {
        //
        // if status is STATUS_RETRY, top level routine will try to load it in the old fashioned way
        //
        goto Exit1;
    }

#if 0
    HvDumpFileObjectState(((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY]);
#endif

    CmpPrefetchHiveFile( ((PCMHIVE)Hive)->FileObject,BaseBlock->Length);

#ifdef CM_MAP_NO_READ
    //
    // we need to make sure all the cell's data is faulted in inside a 
    // try/except block, as the IO to fault the data in can throw exceptions
    // STATUS_INSUFFICIENT_RESOURCES, in particular
    //

    try {
#endif //CM_MAP_NO_READ

        status = HvpMapFileImageAndBuildMap(Hive,BaseBlock->Length);

        //
        // if STATUS_REGISTRY_CORRUPT and RecoverData don't bail out, keep recovering
        //
        if( !NT_SUCCESS(status) ) {
            //
            // need recovery but none available (RecoverHeader implies recover data).
            //
            if( (status !=  STATUS_REGISTRY_CORRUPT) && (status !=  STATUS_REGISTRY_RECOVERED) ) {
                goto Exit2;
            }
            if( (status == STATUS_REGISTRY_CORRUPT) && (result1 != RecoverData) && (result1 != RecoverHeader) ) {
                goto Exit2;
            }
            //
            // in case the above call returns STATUS_REGISTRY_RECOVERED, we should be sefl healing the hive
            //
            ASSERT( (status != STATUS_REGISTRY_RECOVERED) || CmDoSelfHeal() );
        }
    
        //
        // apply data recovery if we need it
        //
        if ( (result1 == RecoverHeader) ||      // -> implies recover data
             (result1 == RecoverData) )
        {
            result2 = HvpRecoverData(Hive);
            if (result2 == NoMemory) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit2;
            }
            if (result2 == Fail) {
                status = STATUS_REGISTRY_CORRUPT;
                goto Exit2;
            }
            status = STATUS_REGISTRY_RECOVERED;
        }
#ifdef CM_MAP_NO_READ
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvMapHive: exception thrown ehile faulting in data, code:%08lx\n", GetExceptionCode()));
        status = GetExceptionCode();
        goto Exit2;
    }
#endif //CM_MAP_NO_READ

    BaseBlock->Sequence2 = BaseBlock->Sequence1;
    return status;


Exit2:
    //
    // Clean up the bins already allocated 
    //
    HvpFreeAllocatedBins( Hive );

    //
    // Clean up the directory table
    //
    HvpCleanMap( Hive );

Exit1:
    if (BaseBlock != NULL) {
        (Hive->Free)(BaseBlock, sizeof(HBASE_BLOCK));
    }

    Hive->BaseBlock = NULL;
    Hive->DirtyCount = 0;
    return status;
}

/*++++++++++++++++++++++++++++++++++++++++
This routine loads the hive into paged pool. We might not need it anymore!
Support will be dropped as we see fit.
----------------------------------------*/
NTSTATUS
HvLoadHive(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Hive must be fully initialized, in particular, file handles
    must be set up.  This routine is not intended for loading hives
    from images already in memory.

    This routine will apply whatever fixes are available for errors
    in the hive image.  In particular, if a log exists, and is applicable,
    this routine will automatically apply it.

    ALGORITHM:

        call HvpGetHiveHeader()

        if (NoMemory or NoHive)
            return failure

        if (RecoverData or RecoverHeader) and (no log)
            return falure

        if (RecoverHeader)
            call HvpGetLogHeader
            if (fail)
                return failure
            fix up baseblock

        Read Data

        if (RecoverData or RecoverHeader)
            HvpRecoverData
            return STATUS_REGISTRY_RECOVERED

        clean up sequence numbers

        return success OR STATUS_REGISTRY_RECOVERED

    If STATUS_REGISTRY_RECOVERED is returned, then

        If (Log) was used, DirtyVector and DirtyCount are set,
            caller is expected to flush the changes (using a
            NEW log file)

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    TailDisplay - array containing the tail ends of the free cell lists - optional

Return Value:

    STATUS:

        STATUS_INSUFFICIENT_RESOURCES   - memory alloc failure, etc
        STATUS_NOT_REGISTRY_FILE        - bad signatures and the like
        STATUS_REGISTRY_CORRUPT         - bad signatures in the log,
                                          bad stuff in both in alternate,
                                          inconsistent log

        STATUS_REGISTRY_IO_FAILED       - data read failed

        STATUS_RECOVERED                - successfully recovered the hive,
                                          a semi-flush of logged data
                                          is necessary.

        STATUS_SUCCESS                  - it worked, no recovery needed

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           result1;
    ULONG           result2;
    NTSTATUS        status;
    LARGE_INTEGER   TimeStamp;
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);

    BaseBlock = NULL;
    result1 = HvpGetHiveHeader(Hive, &BaseBlock, &TimeStamp);

    //
    // bomb out for total errors
    //
    if (result1 == NoMemory) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit1;
    }
    if (result1 == NotHive) {
        status = STATUS_NOT_REGISTRY_FILE;
        goto Exit1;
    }

    //
    // if recovery needed, and no log, bomb out
    //
    if ( ((result1 == RecoverData) ||
          (result1 == RecoverHeader))  &&
          (Hive->Log == FALSE) )
    {
        status = STATUS_REGISTRY_CORRUPT;
        goto Exit1;
    }

    //
    // need to recover header using log, so try to get it from log
    //
    if (result1 == RecoverHeader) {
        result2 = HvpGetLogHeader(Hive, &BaseBlock, &TimeStamp);
        if (result2 == NoMemory) {
            status =  STATUS_INSUFFICIENT_RESOURCES;
            goto Exit1;
        }
        if (result2 == Fail) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Exit1;
        }
        BaseBlock->Type = HFILE_TYPE_PRIMARY;
        if( result2 == SelfHeal ) {
            //
            // tag as self heal so we can fire a warning later on.
            //
            BaseBlock->BootType = HBOOT_SELFHEAL;
        } else {
            BaseBlock->BootType = 0;
        }
    } else {
        BaseBlock->BootType = 0;
    }
    Hive->BaseBlock = BaseBlock;
    Hive->Version = Hive->BaseBlock->Minor;

    status = HvpAdjustHiveFreeDisplay(Hive,BaseBlock->Length,Stable);
    if( !NT_SUCCESS(status) ) {
        goto Exit1;
    }
    //
    // at this point, we have a sane baseblock.  we may or may not still
    // need to apply data recovery
    //
    status = HvpReadFileImageAndBuildMap(Hive,BaseBlock->Length);
    
    
    //
    // if STATUS_REGISTRY_CORRUPT and RecoverData don't bail out, keep recovering
    //
    if( !NT_SUCCESS(status) ) {
        //
        // need recovery but none available (RecoverHeader implies recover data).
        //
        if( (status !=  STATUS_REGISTRY_CORRUPT) && (status !=  STATUS_REGISTRY_RECOVERED) ) {
            goto Exit2;
        }
        if( (status == STATUS_REGISTRY_CORRUPT) && (result1 != RecoverData) && (result1 != RecoverHeader) ) {
            goto Exit2;
        }
        //
        // in case the above call returns STATUS_REGISTRY_RECOVERED, we should be self healing the hive
        //
        ASSERT( (status != STATUS_REGISTRY_RECOVERED) || CmDoSelfHeal() );
    }
    
    //
    // apply data recovery if we need it
    //
    if ( (result1 == RecoverHeader) ||      // -> implies recover data
         (result1 == RecoverData) )
    {
        result2 = HvpRecoverData(Hive);
        if (result2 == NoMemory) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit2;
        }
        if (result2 == Fail) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Exit2;
        }
        status = STATUS_REGISTRY_RECOVERED;
    }

    BaseBlock->Sequence2 = BaseBlock->Sequence1;
    return status;


Exit2:
    //
    // Clean up the bins already allocated 
    //
    HvpFreeAllocatedBins( Hive );

    //
    // Clean up the directory table
    //
    HvpCleanMap( Hive );

Exit1:
    if (BaseBlock != NULL) {
        (Hive->Free)(BaseBlock, sizeof(HBASE_BLOCK));
    }

    Hive->BaseBlock = NULL;
    Hive->DirtyCount = 0;
    return status;
}

NTSTATUS
HvpReadFileImageAndBuildMap(
                            PHHIVE  Hive,
                            ULONG   Length
                            )

/*++

Routine Description:

    Read the hive from the file and allocate storage for the hive
    image in chunks of HBINs. Build the hive map "on the fly".
        Optimized to read chunks of 64K from the file.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Length - the length of the hive, in bytes

    TailDisplay - array containing the tail ends of the free cell lists - optional

Return Value:

    STATUS:

        STATUS_INSUFFICIENT_RESOURCES   - memory alloc failure, etc

        STATUS_REGISTRY_IO_FAILED       - data read failed

        STATUS_REGISTRY_CORRUPT         - base block is corrupt

        STATUS_SUCCESS                  - it worked

--*/
{
    ULONG           FileOffset;
    NTSTATUS        Status = STATUS_SUCCESS;
    PHBIN           Bin;                        // current bin
    ULONG           BinSize = 0;        // size of the current bin
    ULONG           BinOffset = 0;      // current offset inside current bin
    ULONG           BinFileOffset;  // physical offset of the bin in the file (used for consistency checking)
    ULONG           BinDataInBuffer;// the amount of data needed to be copied in the current bin available in the buffer
    ULONG           BinDataNeeded;  // 
    PUCHAR                      IOBuffer;
    ULONG           IOBufferSize;       // valid data in IOBuffer (only at the end of the file this is different than IO_BUFFER_SIZE)
    ULONG           IOBufferOffset;     // current offset inside IOBuffer
    NTSTATUS        Status2 = STATUS_SUCCESS; // used to force recoverData upon exit
    BOOLEAN         MarkBinDirty;

    //
    // Init the map
    //
    Status = HvpInitMap(Hive);

    if( !NT_SUCCESS(Status) ) {
        //
        // return failure 
        //
        return Status;
    }

    //
    // Allocate a IO_BUFFER_SIZE for I/O operations from paged pool. 
	// It will be freed at the end of the function.
    //
    IOBuffer = (PUCHAR)ExAllocatePool(PagedPool, IO_BUFFER_SIZE);
    if (IOBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        HvpCleanMap( Hive );
        return Status;
    }

    //
    // Start right after the hive header
    //
    FileOffset = HBLOCK_SIZE;
    BinFileOffset = FileOffset;
    Bin = NULL;

    //
    // outer loop : reads IO_BUFFER_SIZE chunks from the file
    //
    while( FileOffset < (Length + HBLOCK_SIZE) ) {
        //
        // we are at the begining of the IO buffer
        //
        IOBufferOffset = 0;

        //
        // the buffer size will be either IO_BufferSize, or the amount 
        // uread from the file (when this is smaller than IO_BUFFER_SIZE)
        //
        IOBufferSize = Length + HBLOCK_SIZE - FileOffset;
        IOBufferSize = ( IOBufferSize > IO_BUFFER_SIZE ) ? IO_BUFFER_SIZE : IOBufferSize;
        
        ASSERT( (IOBufferSize % HBLOCK_SIZE) == 0 );
        
        //
        // read data from the file
        //
        if ( ! (Hive->FileRead)(
                        Hive,
                        HFILE_TYPE_PRIMARY,
                        &FileOffset,
                        (PVOID)IOBuffer,
                        IOBufferSize
                        )
           )
        {
            Status = STATUS_REGISTRY_IO_FAILED;
            goto ErrorExit;
        }
        
        //
        // inner loop: breaks the buffer into bins
        //
        while( IOBufferOffset < IOBufferSize ) {

            MarkBinDirty = FALSE;
            if( Bin == NULL ) {
                //
                // this is the beginning of a new bin
                // perform bin validation and allocate the bin
                //
                // temporary bin points to the current location inside the buffer
                Bin = (PHBIN)(IOBuffer + IOBufferOffset);
                //
                // Check the validity of the bin header
                //
                BinSize = Bin->Size;
                if ( (BinSize > Length)                         ||
                     (BinSize < HBLOCK_SIZE)                    ||
                     (Bin->Signature != HBIN_SIGNATURE)         ||
                     (Bin->FileOffset != (BinFileOffset - HBLOCK_SIZE) )) {
                    //
                    // Bin is bogus
                    //
                    Bin = (PHBIN)(Hive->Allocate)(HBLOCK_SIZE, TRUE,CM_FIND_LEAK_TAG30);
                    if (Bin == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorExit;
                    }
                    //
                    // copy the data already read in the first HBLOCK of the bin
                    //
                    RtlCopyMemory(Bin,(IOBuffer + IOBufferOffset), HBLOCK_SIZE);
                    
                    Status2 = STATUS_REGISTRY_CORRUPT;
                    HvCheckHiveDebug.Hive = Hive;
                    HvCheckHiveDebug.Status = 0xA001;
                    HvCheckHiveDebug.Space = Length;
                    HvCheckHiveDebug.MapPoint = BinFileOffset - HBLOCK_SIZE;
                    HvCheckHiveDebug.BinPoint = Bin;
            
                    //goto ErrorExit;
                    //
                    // DO NOT EXIT; Fix this bin header and go on. RecoverData should fix it.
                    // If not, CmCheckRegistry called later will prevent loading of an invalid hive
                    //
                    // NOTE: Still, mess the signature, to make sure that if this particular bin doesn't get recovered, 
                    //       we'll fail the hive loading request.
                    //
                    if( CmDoSelfHeal() ) {
                        //
                        // put the correct signature, fileoffset and binsize in place;
                        // HvEnlistBinInMap will take care of the cells consistency.
                        //
                        Bin->Signature = HBIN_SIGNATURE;
                        Bin->FileOffset = BinFileOffset - HBLOCK_SIZE;
                        if ( ((Bin->FileOffset + BinSize) > Length)   ||
                             (BinSize < HBLOCK_SIZE)            ||
                             (BinSize % HBLOCK_SIZE) ) {
                            BinSize = Bin->Size = HBLOCK_SIZE;
                        }
                        //
                        // signal back to the caller that we have altered the hive.
                        //
                        Status2 = STATUS_REGISTRY_RECOVERED;
                        CmMarkSelfHeal(Hive);
                        //
                        // mark the bin dirty after enlisting.
                        //
                        MarkBinDirty = TRUE;
                    } else {
                        Bin->Signature = 0; //TRICK!!!!
                        BinSize = Bin->Size = HBLOCK_SIZE;
                        Bin->FileOffset = BinOffset;
                        //
                        // simulate as the entire bin is a used cell
                        //
                        ((PHCELL)((PUCHAR)Bin + sizeof(HBIN)))->Size = sizeof(HBIN) - BinSize; //TRICK!!!!
                    }
                    //
                    // Now that we have the entire bin in memory, Enlist It!
                    //
                    Status = HvpEnlistBinInMap(Hive, Length, Bin, BinFileOffset - HBLOCK_SIZE, NULL);

                    if( CmDoSelfHeal() && ((Status == STATUS_REGISTRY_RECOVERED) || MarkBinDirty) ) {
                        //
                        // self heal: enlist fixed the bin
                        //
                        Status2 = STATUS_REGISTRY_RECOVERED;
                        Status = STATUS_SUCCESS;
                        CmMarkSelfHeal(Hive);
                        //
                        // we are in self-heal mode and we have changed data in the bin; mark it all dirty.
                        //
                        HvMarkDirty(Hive,BinOffset,BinSize,TRUE);
                        HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
                    }

                    if( !NT_SUCCESS(Status) ) {
                        goto ErrorExit;
                    }
                    
                    //
                    // Adjust the offsets
                    //
                    BinFileOffset += Bin->Size;
                    IOBufferOffset += Bin->Size;
                    
                    //
                    // another bin is on his way 
                    //
                    Bin = NULL;
                } else {
                    //
                    // bin is valid; allocate a pool chunk of the right size
                    //
                    Bin = (PHBIN)(Hive->Allocate)(BinSize, TRUE,CM_FIND_LEAK_TAG31);
                    if (Bin == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorExit;
                    }
            
                    //
                    // the chunk is allocated; set the offset inside the bin and continue
                    // the next iteration of the inner loop will start by copying data in this bin
                    //
                    BinOffset = 0;
                }
            } else {
                //
                // if we are here, the bin is allocated, the BinSize and BinOffset are set
                // We have to calculate how much for this bin is available in the buffer,
                // and copy it. If we finished with this bin, enlist it and mark the begining of a new one
                //
                ASSERT( Bin != NULL );
                BinDataInBuffer = (IOBufferSize - IOBufferOffset);
                BinDataNeeded = (BinSize - BinOffset);
                
                if( BinDataInBuffer >= BinDataNeeded ) {
                    //
                    // we have available more than what we need; Finish the bin
                    //
                    RtlCopyMemory(((PUCHAR)Bin + BinOffset),(IOBuffer + IOBufferOffset), BinDataNeeded);
                    //
                    // enlist it
                    //
                    Status = HvpEnlistBinInMap(Hive, Length, Bin, BinFileOffset - HBLOCK_SIZE, NULL);

                    if( CmDoSelfHeal() && (Status == STATUS_REGISTRY_RECOVERED) ) {
                        //
                        // self heal: enlist fixed the bin
                        //
                        Status2 = STATUS_REGISTRY_RECOVERED;
                        Status = STATUS_SUCCESS;
                        CmMarkSelfHeal(Hive);
                        //
                        // we are in self-heal mode and we have changed data in the bin; mark it all dirty.
                        //
                        HvMarkDirty(Hive,BinOffset,BinSize,TRUE);
                        HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
                    }

                    if( !NT_SUCCESS(Status) ) {
                        goto ErrorExit;
                    }
                    //
                    // Adjust the offsets
                    //
                    BinFileOffset += BinSize;
                    IOBufferOffset += BinDataNeeded;
                    //
                    // mark the begining of a new bin
                    //
                    Bin = NULL;
                } else {
                    //
                    // we do not have all bin data in the buffer
                    // copy what we can 
                    //
                    RtlCopyMemory(((PUCHAR)Bin + BinOffset),(IOBuffer + IOBufferOffset), BinDataInBuffer);
                    
                    //
                    // adjust the offsets; this should be the last iteration of the inner loop
                    //
                    BinOffset += BinDataInBuffer;
                    IOBufferOffset += BinDataInBuffer;

                    // 
                    // if we are here, the buffer must have beed exausted  
                    //
                    ASSERT( IOBufferOffset == IOBufferSize );
                }
            }
        }
    }

    //
    // if we got here, we shouldn't have a bin under construction
    //
    ASSERT( Bin == NULL );

    //
    // Free the buffer used for I/O operations
    //
    ExFreePool(IOBuffer);

    Status = NT_SUCCESS(Status)?Status2:Status;

    return Status;

ErrorExit:
    //
    // Free the buffer used for I/O operations
    //
    ExFreePool(IOBuffer);

    return Status;
}

RESULT
HvpGetHiveHeader(
    PHHIVE          Hive,
    PHBASE_BLOCK    *BaseBlock,
    PLARGE_INTEGER  TimeStamp
    )
/*++

Routine Description:

    Examine the base block sector and possibly the first sector of
    the first bin, and decide what (if any) recovery needs to be applied
    based on what we find there.

    ALGORITHM:

        read BaseBlock from offset 0
        if ( (I/O error)    OR
             (checksum wrong) )
        {
            read bin block from offset HBLOCK_SIZE (4k)
            if (2nd I/O error)
                return NotHive
            }
            check bin sign., offset.
            if (OK)
                return RecoverHeader, TimeStamp=from Link field
            } else {
                return NotHive
            }
        }

        if (wrong type or signature or version or format)
            return NotHive
        }

        if (seq1 != seq2) {
            return RecoverData, TimeStamp=BaseBlock->TimeStamp, valid BaseBlock
        }

        return ReadData, valid BaseBlock

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    BaseBlock - supplies pointer to variable to receive pointer to
            HBASE_BLOCK, if we can successfully read one.

    TimeStamp - pointer to variable to receive time stamp (serial number)
            of hive, be it from the baseblock or from the Link field
            of the first bin.

Return Value:

    RESULT code

--*/
{
    PHBASE_BLOCK    buffer;
    BOOLEAN         rc;
    ULONG           FileOffset;
    ULONG           Alignment;

    ASSERT(sizeof(HBASE_BLOCK) >= (HSECTOR_SIZE * Hive->Cluster));

    //
    // allocate buffer to hold base block
    //
    *BaseBlock = NULL;
    buffer = (PHBASE_BLOCK)((Hive->Allocate)(sizeof(HBASE_BLOCK), TRUE,CM_FIND_LEAK_TAG32));
    if (buffer == NULL) {
        return NoMemory;
    }
    //
    // Make sure the buffer we got back is cluster-aligned. If not, try
    // harder to get an aligned buffer.
    //
    Alignment = Hive->Cluster * HSECTOR_SIZE - 1;
    if (((ULONG_PTR)buffer & Alignment) != 0) {
        (Hive->Free)(buffer, sizeof(HBASE_BLOCK));
        buffer = (PHBASE_BLOCK)((Hive->Allocate)(PAGE_SIZE, TRUE,CM_FIND_LEAK_TAG33));
        if (buffer == NULL) {
            return NoMemory;
        }
    }
    RtlZeroMemory((PVOID)buffer, sizeof(HBASE_BLOCK));

    //
    // attempt to read base block
    //
    FileOffset = 0;
    rc = (Hive->FileRead)(Hive,
                          HFILE_TYPE_PRIMARY,
                          &FileOffset,
                          (PVOID)buffer,
                          HSECTOR_SIZE * Hive->Cluster);

    if ( (rc == FALSE)  ||
         (HvpHeaderCheckSum(buffer) != buffer->CheckSum)) {
        //
        // base block is toast, try the first block in the first bin
        //
        FileOffset = HBLOCK_SIZE;
        rc = (Hive->FileRead)(Hive,
                              HFILE_TYPE_PRIMARY,
                              &FileOffset,
                              (PVOID)buffer,
                              HSECTOR_SIZE * Hive->Cluster);

        if ( (rc == FALSE) ||
             ( ((PHBIN)buffer)->Signature != HBIN_SIGNATURE)           ||
             ( ((PHBIN)buffer)->FileOffset != 0)
           )
        {
            //
            // the bin is toast too, punt
            //
            (Hive->Free)(buffer, sizeof(HBASE_BLOCK));
            return NotHive;
        }

        //
        // base block is bogus, but bin is OK, so tell caller
        // to look for a log file and apply recovery
        //
        *TimeStamp = ((PHBIN)buffer)->TimeStamp;
        (Hive->Free)(buffer, sizeof(HBASE_BLOCK));
        return RecoverHeader;
    }

    //
    // base block read OK, but is it valid?
    //
    if ( (buffer->Signature != HBASE_BLOCK_SIGNATURE)   ||
         (buffer->Type != HFILE_TYPE_PRIMARY)           ||
         (buffer->Major != HSYS_MAJOR)                  ||
         (buffer->Minor > HSYS_MINOR_SUPPORTED)         ||
         ((buffer->Major == 1) && (buffer->Minor == 0)) ||
         (buffer->Format != HBASE_FORMAT_MEMORY)
       )
    {
        //
        // file is simply not a valid hive
        //
        (Hive->Free)(buffer, sizeof(HBASE_BLOCK));
        return NotHive;
    }

    //
    // see if recovery is necessary
    //
    *BaseBlock = buffer;
    *TimeStamp = buffer->TimeStamp;
    if ( (buffer->Sequence1 != buffer->Sequence2) ) {
        return RecoverData;
    }

    return HiveSuccess;
}

RESULT
HvpGetLogHeader(
    PHHIVE          Hive,
    PHBASE_BLOCK    *BaseBlock,
    PLARGE_INTEGER  TimeStamp
    )
/*++

Routine Description:

    Read and validate log file header.  Return it if it's valid.

    ALGORITHM:

        read header
        if ( (I/O error) or
           (wrong signature,
            wrong type,
            seq mismatch
            wrong checksum,
            wrong timestamp
           )
            return Fail
        }
        return baseblock, OK

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    BaseBlock - supplies pointer to variable to receive pointer to
            HBASE_BLOCK, if we can successfully read one.

    TimeStamp - pointer to variable holding TimeStamp, which must
            match the one in the log file.

Return Value:

    RESULT

--*/
{
    PHBASE_BLOCK    buffer;
    BOOLEAN         rc;
    ULONG           FileOffset;

    ASSERT(sizeof(HBASE_BLOCK) == HBLOCK_SIZE);
    ASSERT(sizeof(HBASE_BLOCK) >= (HSECTOR_SIZE * Hive->Cluster));

    //
    // allocate buffer to hold base block
    //
    *BaseBlock = NULL;
    buffer = (PHBASE_BLOCK)((Hive->Allocate)(sizeof(HBASE_BLOCK), TRUE,CM_FIND_LEAK_TAG34));
    if (buffer == NULL) {
        return NoMemory;
    }
    RtlZeroMemory((PVOID)buffer, HSECTOR_SIZE);

    //
    // attempt to read base block
    //
    FileOffset = 0;
    rc = (Hive->FileRead)(Hive,
                          HFILE_TYPE_LOG,
                          &FileOffset,
                          (PVOID)buffer,
                          HSECTOR_SIZE * Hive->Cluster);

    if ( (rc == FALSE)                                              ||
         (buffer->Signature != HBASE_BLOCK_SIGNATURE)               ||
         (buffer->Type != HFILE_TYPE_LOG)                           ||
         (buffer->Sequence1 != buffer->Sequence2)                   ||
         (HvpHeaderCheckSum(buffer) != buffer->CheckSum)            ||
         (TimeStamp->LowPart != buffer->TimeStamp.LowPart)          ||
         (TimeStamp->HighPart != buffer->TimeStamp.HighPart)) {
        
        if( CmDoSelfHeal() ) {
            //
            // We are in self healing mode; Fix the header and go on
            //
            FILE_FS_SIZE_INFORMATION        FsSizeInformation;
            IO_STATUS_BLOCK                 IoStatusBlock;
            FILE_END_OF_FILE_INFORMATION    FileInfo;
            ULONG                           Cluster;
            NTSTATUS                        Status;

            Status = ZwQueryVolumeInformationFile(
                        ((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY],
                        &IoStatusBlock,
                        &FsSizeInformation,
                        sizeof(FILE_FS_SIZE_INFORMATION),
                        FileFsSizeInformation
                        );
            if (!NT_SUCCESS(Status)) {
                Cluster = 1;
            } else if (FsSizeInformation.BytesPerSector > HBLOCK_SIZE) {
                (Hive->Free)(buffer, sizeof(HBASE_BLOCK));
                return Fail;
            }
            Cluster = FsSizeInformation.BytesPerSector / HSECTOR_SIZE;
            Cluster = (Cluster < 1) ? 1 : Cluster;

            Status = ZwQueryInformationFile(
                        ((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY],
                        &IoStatusBlock,
                        (PVOID)&FileInfo,
                        sizeof(FILE_END_OF_FILE_INFORMATION),
                        FileEndOfFileInformation
                        );

            if(!NT_SUCCESS(Status)) {
                (Hive->Free)(buffer, sizeof(HBASE_BLOCK));
                return Fail;
            } 
            buffer->Signature = HBASE_BLOCK_SIGNATURE;
            buffer->Sequence1 = buffer->Sequence2 = 1;
            buffer->Cluster = Cluster;
            buffer->Length = FileInfo.EndOfFile.LowPart - HBLOCK_SIZE;
            buffer->CheckSum = HvpHeaderCheckSum(buffer);
            *BaseBlock = buffer;
            return SelfHeal;
        } else {
            //
            // Log is unreadable, invalid, or doesn't apply the right hive
            //
            (Hive->Free)(buffer, sizeof(HBASE_BLOCK));
            return Fail;
        }
    }

    *BaseBlock = buffer;
    return HiveSuccess;
}

NTSTATUS
HvpMapFileImageAndBuildMap(
                            PHHIVE  Hive,
                            ULONG   Length
                            )

/*++

Routine Description:

    map views of the file in memory and initialize the bin map.


    we are based on the assumption that no bin is crossing the CM_VIEW_SIZE boundary.
    asserts and validation code should be added later on this matter.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Length - the length of the hive, in bytes

Return Value:

    STATUS:

        STATUS_INSUFFICIENT_RESOURCES   - memory alloc failure, etc

        STATUS_REGISTRY_IO_FAILED       - data read failed

        STATUS_REGISTRY_CORRUPT         - base block is corrupt

        STATUS_SUCCESS                  - it worked

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               FileOffset = 0;
    ULONG               BinOffset = 0;
    PCM_VIEW_OF_FILE    CmView;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;                        // current bin
    ULONG               BinSize;                    // size of the current bin
    NTSTATUS            Status2 = STATUS_SUCCESS;   // used to force recoverData upon exit
    BOOLEAN             MarkBinDirty;

    //
    // Init the map
    //
    Status = HvpInitMap(Hive);

    if( !NT_SUCCESS(Status) ) {
        //
        // return failure 
        //
        return Status;
    }

    //
    // mark all entries in the map as invalid
    // 
    // I moved this in HvpAllocateMap.
    //
    while( BinOffset < Length) {
        Status = CmpMapCmView((PCMHIVE)Hive,BinOffset,&CmView,FALSE/*map not initialized yet*/);
        if( !NT_SUCCESS(Status) ) {
            goto ErrorExit;
        }

        //
        // touch the view
        //
        CmpTouchView((PCMHIVE)Hive,CmView,BinOffset);
        
        //
        // iterate through the map (starting with this offset)
        // the stop condition is when we get an invalid bin
        // (valid bins should be mapped in view)
        //
        while((Me = HvpGetCellMap(Hive, BinOffset)) != NULL) {
            //
            // attention here ! Bins crossing the CM_VIEW_SIZE boundary 
            // should be allocated from paged pool !!!!!
            //
            if( (Me->BinAddress & HMAP_INVIEW) == 0 ) {
                //
                // we have reached the end of the view
                //
                break;
            }
            
            Bin = (PHBIN)Me->BlockAddress;
            MarkBinDirty = FALSE;
            //
            // we should be here at the begining of a new bin
            //
            BinSize = Bin->Size;
            if ( (BinSize > Length)                         ||
                 (BinSize < HBLOCK_SIZE)                    ||
                 (Bin->Signature != HBIN_SIGNATURE)         ||
                 (Bin->FileOffset != BinOffset ) ) {
                    //
                    // Bin is bogus
                    //
                    Status2 = STATUS_REGISTRY_CORRUPT;
                    HvCheckHiveDebug.Hive = Hive;
                    HvCheckHiveDebug.Status = 0xA001;
                    HvCheckHiveDebug.Space = Length;
                    HvCheckHiveDebug.MapPoint = BinOffset;
                    HvCheckHiveDebug.BinPoint = Bin;
            
                    //goto ErrorExit;
                    //
                    // DO NOT EXIT; Fix this bin header and go on. RecoverData should fix it.
                    // If not, CmCheckRegistry called later will prevent loading of an invalid hive
                    //
                    // NOTE: Still, mess the signature, to make sure that if this particular bin doesn't get recovered, 
                    //       we'll fail the hive loading request.
                    //
                    if( CmDoSelfHeal() ) {
                        //
                        // put the correct signature, fileoffset and binsize in place;
                        // HvEnlistBinInMap will take care of the cells consistency.
                        //
                        Bin->Signature = HBIN_SIGNATURE;
                        Bin->FileOffset = BinOffset;
                        if ( ((BinOffset + BinSize) > Length)   ||
                             (BinSize < HBLOCK_SIZE)            ||
                             (BinSize % HBLOCK_SIZE) ) {
                            BinSize = Bin->Size = HBLOCK_SIZE;
                        }
                        //
                        // signal back to the caller that we have altered the hive.
                        //
                        Status2 = STATUS_REGISTRY_RECOVERED;
                        CmMarkSelfHeal(Hive);
                        //
                        // remember to mark the bin dirty after we enlist it
                        //
                        MarkBinDirty = TRUE;
                    } else {
                        Bin->Signature = 0; //TRICK!!!!
                        BinSize = Bin->Size = HBLOCK_SIZE;
                        Bin->FileOffset = BinOffset;
                        //
                        // simulate as the entire bin is a used cell
                        //
                        ((PHCELL)((PUCHAR)Bin + sizeof(HBIN)))->Size = sizeof(HBIN) - BinSize; //TRICK!!!!
                    }
            }
            //
            // Bins crossing the CM_VIEW_SIZE boundary problem.
            // We fix it here, by loading the entire bin 
            // into paged pool
            //
            if( HvpCheckViewBoundary(BinOffset,BinOffset+BinSize-1) == FALSE ) {
                //
                // it is ilegal to fall through here if we did the trick above.
                //
                ASSERT( Bin->Signature == HBIN_SIGNATURE );
                //
                // load it in the old fashioned way (into paged pool)
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"HvpMapFileImageAndBuildMap: Bin crossing CM_VIEW_SIZE boundary at BinOffset = %lx BinSize = %lx\n",BinOffset,BinSize));
                // first, allocate the bin
                Bin = (PHBIN)(Hive->Allocate)(BinSize, TRUE,CM_FIND_LEAK_TAG35);
                if (Bin == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }

                //
                // read data from the file
                //
                FileOffset = BinOffset + HBLOCK_SIZE;
                if ( ! (Hive->FileRead)(
                                Hive,
                                HFILE_TYPE_PRIMARY,
                                &FileOffset,
                                (PVOID)Bin,
                                BinSize
                                )
                   )
                {
                    Status = STATUS_REGISTRY_IO_FAILED;
                    goto ErrorExit;
                }
                
                ASSERT( (FileOffset - HBLOCK_SIZE) == (BinOffset + BinSize) );
                //
                // enlist the bin as in paged pool
                //
                Status = HvpEnlistBinInMap(Hive, Length, Bin, BinOffset, NULL);
            } else {
                //
                // Now that we have the entire bin mapped in memory, Enlist It!
                //
                Status = HvpEnlistBinInMap(Hive, Length, Bin, BinOffset, CmView);
            }

            //
            // account for self healing
            //
            if( CmDoSelfHeal() && ((Status == STATUS_REGISTRY_RECOVERED) || MarkBinDirty) ) {
                Status2 = STATUS_REGISTRY_RECOVERED;
                Status = STATUS_SUCCESS;
                CmMarkSelfHeal(Hive);
                //
                // we are in self-heal mode and we have changed data in the bin; mark it all dirty.
                //
                HvMarkDirty(Hive,BinOffset,BinSize,TRUE);
                HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
            }
            
            //
            // advance to the new bin
            //
            BinOffset += BinSize;


            if( !NT_SUCCESS(Status) ) {
                goto ErrorExit;
            }
        }
        
    }
    
    Status = NT_SUCCESS(Status)?Status2:Status;

    return Status;

ErrorExit:
    //
    // DO NOT Clean up the directory table, as we may want to recover the hive
    //

    return Status;

}

RESULT
HvpRecoverData(
    PHHIVE          Hive
    )
/*++

Routine Description:

    Apply the corrections in the log file to the hive memory image.

    ALGORITHM:

        compute size of dirty vector
        read in dirty vector
        if (i/o error)
            return Fail

        skip first cluster of data (already processed as log)
        sweep vector, looking for runs of bits
            address of first bit is used to compute memory offset
            length of run is length of block to read
            assert always a cluster multiple
            file offset kept by running counter
            read
            if (i/o error)
                return fail

        return success

    NOTE:  This routine works with hives mapped OR loaded into paged pool

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest


Return Value:

    RESULT

--*/
{
    ULONG               Cluster;
    ULONG               ClusterSize;
    ULONG               HeaderLength;
    ULONG               VectorSize;
    PULONG              Vector;
    ULONG               FileOffset;
    BOOLEAN             rc;
    ULONG               Current;
    ULONG               Start;
    ULONG               End;
    ULONG               Address;
    PUCHAR              MemoryBlock;
    RTL_BITMAP          BitMap;
    ULONG               Length;
    ULONG               DirtyVectorSignature = 0;
    ULONG               RequestedReadBufferSize;
    ULONG               i;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;
    PHBIN               NewBin;
    PUCHAR              SectorImage;
    PUCHAR              Source;
    PHBIN               SourceBin;
    ULONG               SectorOffsetInBin;
    ULONG               SectorOffsetInBlock;
    ULONG               BlockOffsetInBin;
    ULONG               NumberOfSectors;
    PCM_VIEW_OF_FILE    CmView;
    NTSTATUS            Status;

    //
    // compute size of dirty vector, read and check signature, read vector
    //
    Cluster = Hive->Cluster;
    ClusterSize = Cluster * HSECTOR_SIZE;
    HeaderLength = ROUND_UP(HLOG_HEADER_SIZE, ClusterSize);
    Length = Hive->BaseBlock->Length;
    VectorSize = (Length / HSECTOR_SIZE) / 8;       // VectorSize == Bytes
    FileOffset = ROUND_UP(HLOG_HEADER_SIZE, HeaderLength);
    HvRecoverDataDebug.Hive = Hive;
    HvRecoverDataDebug.FailPoint = 0;

    //
    // we need to align the reads at sector size too
    //
    RequestedReadBufferSize = VectorSize + sizeof(DirtyVectorSignature);

    LOCK_STASH_BUFFER();
    if( CmpStashBufferSize < RequestedReadBufferSize ) {
        PUCHAR TempBuffer =  ExAllocatePoolWithTag(PagedPool, ROUND_UP(RequestedReadBufferSize,PAGE_SIZE),CM_STASHBUFFER_TAG);
        if (TempBuffer == NULL) {
            HvRecoverDataDebug.FailPoint = 1;
            UNLOCK_STASH_BUFFER();
            return Fail;
        }
        if( CmpStashBuffer != NULL ) {
            ExFreePool( CmpStashBuffer );
        }
        CmpStashBuffer = TempBuffer;
        CmpStashBufferSize = ROUND_UP(RequestedReadBufferSize,PAGE_SIZE);

    }

    
    //
    // get the signature and dirty vector at one time
    //
    RequestedReadBufferSize = ROUND_UP(RequestedReadBufferSize,ClusterSize);
    ASSERT( RequestedReadBufferSize <= CmpStashBufferSize);
    ASSERT( (RequestedReadBufferSize % HSECTOR_SIZE) == 0 );

    rc = (Hive->FileRead)(
            Hive,
            HFILE_TYPE_LOG,
            &FileOffset,
            (PVOID)CmpStashBuffer,
            RequestedReadBufferSize
            );
    if (rc == FALSE) {
        HvRecoverDataDebug.FailPoint = 2;
        UNLOCK_STASH_BUFFER();
        if( CmDoSelfHeal() ) {
            //
            // .LOG is bad too. attempt to load at the extent of some data loss.
            //
            CmMarkSelfHeal(Hive);
            return SelfHeal;
        } else {
            return Fail;
        }
    }
    
    //
    // check the signature
    //
    DirtyVectorSignature = *((ULONG *)CmpStashBuffer);
    if (DirtyVectorSignature != HLOG_DV_SIGNATURE) {
        UNLOCK_STASH_BUFFER();
        HvRecoverDataDebug.FailPoint = 3;
        if( CmDoSelfHeal() ) {
            //
            // .LOG is bad too. attempt to load at the extent of some data loss.
            //
            CmMarkSelfHeal(Hive);
            return SelfHeal;
        } else {
            return Fail;
        }
    }

    //
    // get the actual vector
    //
    Vector = (PULONG)((Hive->Allocate)(ROUND_UP(VectorSize,sizeof(ULONG)), TRUE,CM_FIND_LEAK_TAG36));
    if (Vector == NULL) {
        UNLOCK_STASH_BUFFER();
        HvRecoverDataDebug.FailPoint = 4;
        return NoMemory;
    }
    RtlCopyMemory(Vector,CmpStashBuffer + sizeof(DirtyVectorSignature),VectorSize); 

    UNLOCK_STASH_BUFFER();

    FileOffset = ROUND_UP(FileOffset, ClusterSize);


    //
    // step through the diry map, reading in the corresponding file bytes
    //
    Current = 0;
    VectorSize = VectorSize * 8;        // VectorSize == bits

    RtlInitializeBitMap(&BitMap, Vector, VectorSize);
    if( RtlNumberOfSetBits(&BitMap) == VectorSize ) {
        //
        // the entire hive is marked as dirty; easier to start from scratch
        //
        if( !NT_SUCCESS(HvpRecoverWholeHive(Hive,FileOffset)) ) {
            goto ErrorExit;
        }
        goto Done;
    }


    while (Current < VectorSize) {

        //
        // find next contiguous block of entries to read in
        //
        for (i = Current; i < VectorSize; i++) {
            if (RtlCheckBit(&BitMap, i) == 1) {
                break;
            }
        }
        Start = i;

        for ( ; i < VectorSize; i++) {
            if (RtlCheckBit(&BitMap, i) == 0) {
                break;
            }
        }
        End = i;
        Current = End;

        //
        // Start == number of 1st sector, End == number of Last sector + 1
        //
        Length = (End - Start) * HSECTOR_SIZE;

        if( 0 == Length ) {
            // no more dirty blocks.
            break;
        }
        //
        // allocate a buffer to read the whole run from the file; This is a temporary
        // block that'll be freed immediately, so don't charge quota for it.
        //
        MemoryBlock = (PUCHAR)ExAllocatePoolWithTag(PagedPool, Length, CM_POOL_TAG);
        if( MemoryBlock == NULL ) {        
            HvRecoverDataDebug.FailPoint = 5;
            goto ErrorExit;
        }

        rc = (Hive->FileRead)(
                Hive,
                HFILE_TYPE_LOG,
                &FileOffset,
                (PVOID)MemoryBlock,
                Length
                );

        ASSERT((FileOffset % ClusterSize) == 0);
        if (rc == FALSE) {
            ExFreePool(MemoryBlock);
            HvRecoverDataDebug.FailPoint = 6;
            HvRecoverDataDebug.FileOffset = FileOffset;
            if( CmDoSelfHeal() ) {
                //
                // .LOG is bad too. attempt to load at the extent of some data loss.
                //
                CmMarkSelfHeal(Hive);
                //
                // clear off what we have missed
                //
                RtlClearBits(&BitMap,FileOffset/HSECTOR_SIZE,(Hive->BaseBlock->Length - FileOffset)/HSECTOR_SIZE);
                goto Done;
            } else {
                goto ErrorExit;
            }
        }
        
        Source = MemoryBlock;
        //
        // copy recovered data in the right locations inside the in-memory bins
        //
        while( Start < End ) {
            Address = Start * HSECTOR_SIZE;
        
            Me = HvpGetCellMap(Hive, Address);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,Address);
            if( (Me->BinAddress & (HMAP_INVIEW|HMAP_INPAGEDPOOL)) == 0 ) {
                //
                // bin is not in memory, neither in paged pool ==> map it
                //
                if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,Address,FALSE)) ) {
                    ExFreePool(MemoryBlock);
                    HvRecoverDataDebug.FailPoint = 7;
                    HvRecoverDataDebug.FileOffset = Address;
                    goto ErrorExit;
                }
            }

            if( Me->BinAddress & HMAP_INVIEW ) {
                //
                // pin the view (if not already pinned), as changes have 
                // to be flushed to the disk.
                //
                ASSERT( Me->CmView != NULL );

                if( IsListEmpty(&(Me->CmView->PinViewList)) == TRUE ) {
                    //
                    // the view is not already pinned.  pin it
                    //
                    ASSERT_VIEW_MAPPED( Me->CmView );
                    if( !NT_SUCCESS(CmpPinCmView ((PCMHIVE)Hive,Me->CmView)) ) {
                        //
                        // could not pin view
                        //
                        ExFreePool(MemoryBlock);
                        HvRecoverDataDebug.FailPoint = 10;
                        HvRecoverDataDebug.FileOffset = Address;
                        goto ErrorExit;
                    }
                } else {
                    //
                    // view is already pinned; do nothing
                    //
                    ASSERT_VIEW_PINNED( Me->CmView );
                }
                CmView = Me->CmView;
            } else {
                CmView = NULL;
            }
    
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            //
            // compute the memory address where data should be copied
            //
            SectorOffsetInBin = Address - Bin->FileOffset;
            
            if( ( SectorOffsetInBin == 0 ) && ( ((PHBIN)Source)->Size > Bin->Size ) ){
                //
                // Bin in the log file is bigger than the one in memory;
                // two or more bins must have been coalesced
                //
                ASSERT( Me->BinAddress & HMAP_NEWALLOC );
                
                SourceBin = (PHBIN)Source;

                //
                // new bin must have the right offset
                //
                ASSERT(Address == SourceBin->FileOffset);
                ASSERT( SourceBin->Signature == HBIN_SIGNATURE );
                //
                // entire bin should be dirty
                //
                ASSERT( (SourceBin->FileOffset + SourceBin->Size) <= End * HSECTOR_SIZE );

                if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                   
                    //
                    // Allocate the right size for the new bin
                    //
                    NewBin = (PHBIN)(Hive->Allocate)(SourceBin->Size, TRUE,CM_FIND_LEAK_TAG37);
                    if (NewBin == NULL) {
                        HvRecoverDataDebug.FailPoint = 8;
                        goto ErrorExit;
                    }
                } else {
                    //
                    // bin is mapped in the system cache
                    //
                    ASSERT( Me->BinAddress & HMAP_INVIEW );
                    NewBin = Bin;
                }
                
                //
                // Copy the old data into the new bin and free old bins
                //
                while(Bin->FileOffset < (Address + SourceBin->Size)) {
                
                    //
                    // Delist this bin free cells
                    //
                    HvpDelistBinFreeCells(Hive,Bin,Stable);

                    if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                        RtlCopyMemory((PUCHAR)NewBin + (Bin->FileOffset - Address),Bin, Bin->Size);
                    }


                    //
                    // Advance to the new bin
                    //
                    if( (Bin->FileOffset + Bin->Size) < Hive->BaseBlock->Length ) {
                        Me = HvpGetCellMap(Hive, Bin->FileOffset + Bin->Size);
                        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Bin->FileOffset + Bin->Size);


                    
                        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                            //
                            // Free the old bin
                            //
                            (Hive->Free)(Bin, Bin->Size);
                        }
        
                        //
                        // the new address must be the begining of a new allocation
                        //
                        ASSERT( Me->BinAddress & HMAP_NEWALLOC );
            
                        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
                    } else {
                        //
                        // we are at the end of the hive here; just break out of the loop
                        //
                        ASSERT( (Address + SourceBin->Size) == Hive->BaseBlock->Length );
                        ASSERT( (Bin->FileOffset + Bin->Size) == Hive->BaseBlock->Length );
                        
                        //
                        // Free the old bin
                        //
                        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                            (Hive->Free)(Bin, Bin->Size);
                        }
                        
                        //
                        // debug purposes only
                        //
                        ASSERT( (Bin = NULL) == NULL );

                        // bail out of while loop
                        break;
                    }

                }    

#if DBG
                //
                // validation: bin size increase must come from coalescing of former bins
                // (i.e. bins are never split!!!)
                //
                if( Bin != NULL ) {
                    ASSERT( Bin->FileOffset == (Address + SourceBin->Size));
                } 
#endif
                //
                // Now overwrite the modified data !
                //
                
                while( (Address < (SourceBin->FileOffset + SourceBin->Size)) && (Start < End) ) {
                    RtlCopyMemory((PUCHAR)NewBin + (Address - SourceBin->FileOffset),Source, HSECTOR_SIZE);
                    
                    // 
                    // skip to the next sector
                    //
                    Start++;
                    Source += HSECTOR_SIZE;
                    Address += HSECTOR_SIZE;
                }

                //
                // first sector of the new bin is always restaured from the log file!
                //
                ASSERT(NewBin->FileOffset == SourceBin->FileOffset);
                ASSERT(NewBin->Size == SourceBin->Size);

            } else {
                //
                // Normal case: sector recovery somewhere in the middle of the bin
                //

                //
                // Offset should fall within bin memory layout
                //
                ASSERT( SectorOffsetInBin < Bin->Size );
            
                if(Me->BinAddress & HMAP_DISCARDABLE) {
                    //
                    // bin is free (discarded); That means it is entirely present in the log file.
                    //
                    ASSERT( SectorOffsetInBin == 0 );
                    SectorImage = (PUCHAR)Bin;
                } else {
                    BlockOffsetInBin = (ULONG)((PUCHAR)Me->BlockAddress - (PUCHAR)Bin);
                    SectorOffsetInBlock = SectorOffsetInBin - BlockOffsetInBin;
            
                    //
                    // sanity check; address should  be the same relative to either begining of the bin or begining of the block
                    //
                    ASSERT(((PUCHAR)Me->BlockAddress + SectorOffsetInBlock) == ((PUCHAR)Bin + SectorOffsetInBin));
                    SectorImage = (PUCHAR)((PUCHAR)Me->BlockAddress + SectorOffsetInBlock);
                }

                DbgPrint("HvpRecoverData: SectorOffsetInBin = %lx,SectorImage = %p, Bin = %p, Source = %p\n",
                    SectorOffsetInBin,SectorImage,Bin,Source);
                if( SectorImage == (PUCHAR)Bin ) {
                    //
                    // we are at the beggining of a bin. Check the validity of the data in the .LOG
                    //
                    PHBIN   LogBin = (PHBIN)Source;
                    if ( (LogBin->Size < HBLOCK_SIZE)               ||
                         (LogBin->Signature != HBIN_SIGNATURE)      ||
                         (Bin->FileOffset != LogBin->FileOffset ) ) {

                        //
                        // Bin in .LOG is not valid. All we can do now is throw it away and hope the self healing process 
                        // will successfully recover the hive.
                        //
                        if( CmDoSelfHeal() ) {
                            CmMarkSelfHeal(Hive);
                            ExFreePool(MemoryBlock);
                            // clear off the remaining sirty bits
                            RtlClearBits(&BitMap,Bin->FileOffset/HSECTOR_SIZE,
                                                (Hive->BaseBlock->Length - Bin->FileOffset)/HSECTOR_SIZE);
                            goto Done;
                        }
                    }

                }
                //
                // Delist this bin free cells
                //
                HvpDelistBinFreeCells(Hive,Bin,Stable);

                //
                // both source and destination should be valid at this point
                //
                ASSERT( SectorImage < ((PUCHAR)Bin + Bin->Size) );
                ASSERT( Source < (MemoryBlock + Length) );

                NumberOfSectors = 0;
                while( ( (SectorImage + (NumberOfSectors * HSECTOR_SIZE)) < (PUCHAR)((PUCHAR)Bin + Bin->Size) ) &&
                        ( (Start + NumberOfSectors ) < End )    ) {
                    //
                    // we are still inside the same bin;
                    // deal with all sectors inside the same bin at once
                    //
                    NumberOfSectors++;
                }

                //
                // finally, copy the memory
                //
                RtlCopyMemory(SectorImage,Source, NumberOfSectors * HSECTOR_SIZE);

                NewBin = Bin;

                //
                // skip to the next sector
                //
                Start += NumberOfSectors;
                Source += NumberOfSectors * HSECTOR_SIZE;

            }

            //
            // rebuild the map anyway
            //
            Status = HvpEnlistBinInMap(Hive, Length, NewBin, NewBin->FileOffset, CmView);
            if( !NT_SUCCESS(Status) ) {
                HvRecoverDataDebug.FailPoint = 9;
                HvRecoverDataDebug.FileOffset = NewBin->FileOffset;
                if( CmDoSelfHeal() && (Status == STATUS_REGISTRY_RECOVERED) ) {
                    //
                    // .LOG is bad too, but enlisting fixed the bin
                    //
                    CmMarkSelfHeal(Hive);
                } else {
                    goto ErrorExit;
                }
                goto ErrorExit;
            }
        }
    
        //
        // get rid of the temporary pool
        //
        ExFreePool(MemoryBlock);
    }

Done:
    //
    // put correct dirty vector in Hive so that recovered data
    // can be correctly flushed
    //
    if (Hive->DirtyVector.Buffer != NULL) {
        Hive->Free((PVOID)(Hive->DirtyVector.Buffer), Hive->DirtyAlloc);
    }
    RtlInitializeBitMap(&(Hive->DirtyVector), Vector, VectorSize);
    Hive->DirtyCount = RtlNumberOfSetBits(&Hive->DirtyVector);
    Hive->DirtyAlloc = ROUND_UP(VectorSize/8,sizeof(ULONG));
    HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
    return HiveSuccess;

ErrorExit:
    //
    // free the dirty vector and return failure
    //
    (Hive->Free)(Vector, ROUND_UP(VectorSize/8,sizeof(ULONG)));
    return Fail;
}

NTSTATUS
HvpRecoverWholeHive(PHHIVE  Hive,
                    ULONG   FileOffset
                    ) 
/*++

Routine Description:

    We have the whole hive inside the log. Redo the mapping and copy from the log 
    to the actual storage.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest
    
    FileOffset - where the actual hive data starts in the log file.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               BinOffset = 0;
    PCM_VIEW_OF_FILE    CmView = NULL;
    BOOLEAN             rc;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;                        // current bin
    PHBIN               LogBin;
    ULONG               LogBinSize;                 // size of the current bin
    ULONG               Length;
    LOGICAL             MappedHive;
    PFREE_HBIN          FreeBin;
    ULONG               i;
    PCM_VIEW_OF_FILE    EnlistCmView;
    
    //
    // free the bins that may have been allocated from paged pool.
    //
    HvpFreeAllocatedBins( Hive );
    CmpDestroyHiveViewList((PCMHIVE)Hive);

    //
    // free all free bins.
    //
    while( !IsListEmpty(&(Hive->Storage[Stable].FreeBins)) ) {
        FreeBin = (PFREE_HBIN)RemoveHeadList(&(Hive->Storage[Stable].FreeBins));
        FreeBin = CONTAINING_RECORD(FreeBin,
                                    FREE_HBIN,
                                    ListEntry);
        (Hive->Free)(FreeBin, sizeof(FREE_HBIN));
    }
    //
    // invalidate all free cell hints;
    //
#ifdef  HV_TRACK_FREE_SPACE
	Hive->Storage[Stable].FreeStorage = 0;
#endif
    Hive->Storage[Stable].FreeSummary = 0;
    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        RtlClearAllBits(&(Hive->Storage[Stable].FreeDisplay[i]));
    }


    //
    // we'll use CmpStashBuffer to read from the log.
    //
    MappedHive = ( ((PCMHIVE)Hive)->FileObject != NULL );
    Length = Hive->BaseBlock->Length;
    BinOffset = 0;

    while( BinOffset < Length) {
        Me = HvpGetCellMap(Hive, BinOffset);
        if( MappedHive && !(Me->BinAddress & HMAP_INVIEW) ) {
            //
            // first, pin the old view (if any)
            //
            if( CmView ) {
                //
                // pin the view (is already marked dirty)
                //
                if( IsListEmpty(&(CmView->PinViewList)) == TRUE ) {
                    //
                    // the view is not already pinned.  pin it
                    //
                    ASSERT_VIEW_MAPPED( CmView );
                    Status = CmpPinCmView ((PCMHIVE)Hive,CmView);
                    if( !NT_SUCCESS(Status)) {
                        //
                        // could not pin view
                        //
                        HvRecoverDataDebug.FailPoint = 13;
                        HvRecoverDataDebug.FileOffset = FileOffset;
                        return Status;
                    }
                } else {
                    //
                    // view is already pinned; do nothing
                    //
                    ASSERT_VIEW_PINNED( CmView );
                }
            }

            Status = CmpMapCmView((PCMHIVE)Hive,BinOffset,&CmView,FALSE/*map not initialized yet*/);
            if( !NT_SUCCESS(Status) ) {
                HvRecoverDataDebug.FailPoint = 10;
                HvRecoverDataDebug.FileOffset = FileOffset;
                return Status;
            }
        }

        rc = (Hive->FileRead)(
                Hive,
                HFILE_TYPE_LOG,
                &FileOffset,
                (PVOID)CmpStashBuffer,
                HBLOCK_SIZE
                );
        if (rc == FALSE) {
            HvRecoverDataDebug.FailPoint = 11;
            HvRecoverDataDebug.FileOffset = FileOffset;
            return STATUS_REGISTRY_IO_FAILED;
        }
        LogBin = (PHBIN)CmpStashBuffer;
        LogBinSize = LogBin->Size;
        if( (LogBin->Signature != HBIN_SIGNATURE) ||
            (LogBin->FileOffset != BinOffset) ) {
            HvRecoverDataDebug.FailPoint = 17;
            HvRecoverDataDebug.FileOffset = FileOffset;
            return STATUS_REGISTRY_IO_FAILED;
        }
        

        //
        // Bins crossing the CM_VIEW_SIZE boundary problem.
        // We fix it here, by loading the entire bin 
        // into paged pool
        //
        FileOffset -= HBLOCK_SIZE;
        if( (!MappedHive) || (HvpCheckViewBoundary(BinOffset,BinOffset+LogBinSize-1) == FALSE) ) {
            //
            // load it in the old fashioned way (into paged pool)
            //

            // first, allocate the bin
            Bin = (PHBIN)(Hive->Allocate)(LogBinSize, TRUE,CM_FIND_LEAK_TAG35);
            if (Bin == NULL) {
                HvRecoverDataDebug.FailPoint = 12;
                HvRecoverDataDebug.FileOffset = FileOffset;
                return  STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // this will enlist the bin as in paged pool
            //
            EnlistCmView = NULL;
        } else {
            ASSERT(Me->BinAddress & HMAP_INVIEW);
            ASSERT(Me->CmView == CmView );
            Bin = (PHBIN)Me->BlockAddress;

            EnlistCmView = CmView;
        }
        //
        // read data from the file
        //
        if ( ! (Hive->FileRead)(
                        Hive,
                        HFILE_TYPE_LOG,
                        &FileOffset,
                        (PVOID)Bin,
                        LogBinSize
                        )
           )
        {
            HvRecoverDataDebug.FailPoint = 14;
            HvRecoverDataDebug.FileOffset = FileOffset;
            return STATUS_REGISTRY_IO_FAILED;
        }
        //
        // enlist the bin;
        //
        Status = HvpEnlistBinInMap(Hive, Length, Bin, BinOffset, CmView);

        if( !NT_SUCCESS(Status) ) {
            HvRecoverDataDebug.FailPoint = 15;
            HvRecoverDataDebug.FileOffset = FileOffset;
            return Status;
        }

        //
        // advance to the new bin
        //
        BinOffset += LogBinSize;
    }

    if( CmView ) {
        //
        // pin the view (is already marked dirty)
        //
        if( IsListEmpty(&(CmView->PinViewList)) == TRUE ) {
            //
            // the view is not already pinned.  pin it
            //
            ASSERT_VIEW_MAPPED( CmView );
            Status = CmpPinCmView ((PCMHIVE)Hive,CmView);
            if( !NT_SUCCESS(Status)) {
                //
                // could not pin view
                //
                HvRecoverDataDebug.FailPoint = 16;
                HvRecoverDataDebug.FileOffset = FileOffset;
                return Status;
            }
        } else {
            //
            // view is already pinned; do nothing
            //
            ASSERT_VIEW_PINNED( CmView );
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS 
HvCloneHive(PHHIVE  SourceHive,
            PHHIVE  DestHive,
            PULONG  NewLength
            )
/*++

Routine Description:

    Duplicates the bins from the source hive to the destination hive.
    Allocates the map, and recomputes the PhysicalOffset for each bin.
    It does not touch the freedisplay.
  
      
Arguments:

    SourceHive - 

    DestHive - 

Return Value:

    TBS

--*/
{
    ULONG           Length;
    NTSTATUS        Status;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_TABLE     t = NULL;
    PHMAP_DIRECTORY d = NULL;
    ULONG           FileOffset;
    ULONG           ShiftOffset;
    PHMAP_ENTRY     Me;
    PFREE_HBIN      FreeBin;
    ULONG           BinSize;
    PHBIN           Bin,NewBin;
    
    Length = DestHive->BaseBlock->Length = SourceHive->BaseBlock->Length;

    //
    // Compute size of data region to be mapped
    //
    if ((Length % HBLOCK_SIZE) != 0 ) {
        Status = STATUS_REGISTRY_CORRUPT;
        goto ErrorExit1;
    }
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    DestHive->Storage[Stable].Length = Length;

    //
    // allocate and build structure for map
    //
    if (Tables == 0) {

        //
        // Just 1 table, no need for directory
        //
        t = (DestHive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG23);
        if (t == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(t, sizeof(HMAP_TABLE));
        DestHive->Storage[Stable].Map =
            (PHMAP_DIRECTORY)&(DestHive->Storage[Stable].SmallDir);
        DestHive->Storage[Stable].SmallDir = t;

    } else {

        //
        // Need directory and multiple tables
        //
        d = (PHMAP_DIRECTORY)(DestHive->Allocate)(sizeof(HMAP_DIRECTORY), FALSE,CM_FIND_LEAK_TAG24);
        if (d == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(d, sizeof(HMAP_DIRECTORY));

        //
        // Allocate tables and fill in dir
        //
        if (HvpAllocateMap(DestHive, d, 0, Tables) == FALSE) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        DestHive->Storage[Stable].Map = d;
        DestHive->Storage[Stable].SmallDir = 0;
    }

    //
    // Now we have to allocate the memory for the HBINs and fill in
    // the map appropriately.  We'll keep track of the freebins 
    // and update the Spare field in each bin accordingly.
    //
    // temporary mark the hive as read only, so we won't enlist the free cells
    DestHive->ReadOnly = TRUE;
    FileOffset = ShiftOffset = 0;
    while(FileOffset < Length) {
        Me = HvpGetCellMap(SourceHive, FileOffset);
       
        if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0) {
            //
            // view is not mapped, neither in paged pool
            // try to map it.
            //
            // do not touch the view as we have no interest in it afterwards
            //
            if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)SourceHive,FileOffset,FALSE)) ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit2;
            }
        }

        if( Me->BinAddress & HMAP_DISCARDABLE ) {
            //
            // bin is discardable. If it is not discarded yet, save it as it is
            // else, allocate, initialize and save a fake bin
            //
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            BinSize = FreeBin->Size;
            //
            // all we need to do here is to keep track of shifting offset
            //
            ShiftOffset += BinSize;

            //
            // we leave "holes" (map filled with 0); we'll detect them later and shrink the map.
            // 
               
        } else {
#ifdef CM_MAP_NO_READ
        //
        // we need to make sure all the cell's data is faulted in inside a 
        // try/except block, as the IO to fault the data in can throw exceptions
        // STATUS_INSUFFICIENT_RESOURCES, in particular
        //
            try {
#endif //CM_MAP_NO_READ

                Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
                ASSERT( Bin->Signature == HBIN_SIGNATURE );
                ASSERT( Bin->FileOffset == FileOffset );
                BinSize = Bin->Size;
                //
                // Allocate the new bin
                //
                NewBin = (PHBIN)(DestHive->Allocate)(BinSize, TRUE,CM_FIND_LEAK_TAG35);
                if (NewBin == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit2;
                }
                //
                // copy data over the new bin and update the Spare field
                //
                RtlCopyMemory(NewBin,Bin,BinSize);
                NewBin->Spare = ShiftOffset;
                Status = HvpEnlistBinInMap(DestHive, Length, NewBin, FileOffset, NULL);
                if( !NT_SUCCESS(Status) ) {
                    goto ErrorExit2;
                }

#ifdef CM_MAP_NO_READ
            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
                goto ErrorExit2;
            }
#endif //CM_MAP_NO_READ
        }

        FileOffset += BinSize;
    }

    DestHive->ReadOnly = FALSE;
    *NewLength = Length - ShiftOffset;
    return STATUS_SUCCESS;

ErrorExit2:
    if (d != NULL) {

        //
        // directory was built and allocated, so clean it up
        //

        HvpFreeMap(DestHive, d, 0, Tables);
        (DestHive->Free)(d, sizeof(HMAP_DIRECTORY));
    }

ErrorExit1:
    return Status;
}


NTSTATUS 
HvShrinkHive(PHHIVE  Hive,
             ULONG   NewLength
            )
/*++

Routine Description:

    Initialize free display and move free bins at the end.
    Renlist all bins. Update/shrink the map and the length of the hive.
      
Arguments:

    Hive - 

    NewLength - 

Return Value:

    TBS

--*/
{
    NTSTATUS        Status;
    ULONG           Offset;
    ULONG           Length;
    PHMAP_ENTRY     Me;
    PHBIN           Bin;
    ULONG           OldTable;
    ULONG           NewTable;

    PAGED_CODE();

    Status = HvpAdjustHiveFreeDisplay(Hive,NewLength,Stable);
    if( !NT_SUCCESS(Status) ) {
        goto ErrorExit;
    }

    //
    // iterate through the map and move bins toward the beggining.
    //
    Offset = 0;
    Length = Hive->BaseBlock->Length;
    while( Offset < Length ) {
        Me = HvpGetCellMap(Hive, Offset);
       
        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
            //
            // we only care about bins in paged pool
            //
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            ASSERT( Bin->Signature == HBIN_SIGNATURE );
            ASSERT( Bin->FileOffset == Offset );
            //
            // shift the bin and enlist it again.
            //
            Bin->FileOffset -= Bin->Spare;
            Status = HvpEnlistBinInMap(Hive, Length, Bin, Bin->FileOffset, NULL);
            if( !NT_SUCCESS(Status) ) {
                goto ErrorExit;
            }
            Offset += Bin->Size;

        } else {
            //
            // advance carefully.
            //
            Offset += HBLOCK_SIZE;
        }
    }
    
    //
    // now shrink the map and update the length
    //
    OldTable = ( (Length-1) / HBLOCK_SIZE ) / HTABLE_SLOTS;
    NewTable = ( (NewLength-1) / HBLOCK_SIZE ) / HTABLE_SLOTS;
    ASSERT( OldTable >= NewTable );
    HvpFreeMap(Hive, Hive->Storage[Stable].Map, NewTable+1, OldTable);
    Hive->Storage[Stable].Length = NewLength;
    Hive->BaseBlock->Length = NewLength;

ErrorExit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hwprofil.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    hwprofil.c

Abstract:

    This module contains support for changing the Hardware profile
    based on the current docking state, either at boot time or by
    ACPI dock.

Author:

    Kenneth D. Ray (kenray) Jan 1998

Revision History:

--*/

#include "cmp.h"

NTSTATUS
CmDeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key,
    PVOID   TemporaryBuffer,
    ULONG   LengthTemporaryBuffer,
    BOOLEAN ThisKeyToo
    );

NTSTATUS
CmpGetAcpiProfileInformation (
    IN  HANDLE  IDConfigDB,
    OUT PCM_HARDWARE_PROFILE_LIST * ProfileList,
    OUT PCM_HARDWARE_PROFILE_ACPI_ALIAS_LIST * AliasList,
    IN  PWCHAR  NameBuffer,
    IN  PUCHAR  ValueBuffer,
    IN  ULONG   Len
    );

NTSTATUS
CmpFilterAcpiDockingState (
    IN     PPROFILE_ACPI_DOCKING_STATE  NewDockState,
    IN     ULONG                        CurrentDockingState,
    IN     PWCHAR                       CurrentAcpiSN,
    IN     ULONG                        CurrentProfileNumber,
    IN OUT PCM_HARDWARE_PROFILE_LIST    ProfileList,
    IN OUT PCM_HARDWARE_PROFILE_ACPI_ALIAS_LIST AliasList
    );

NTSTATUS
CmpMoveBiosAliasTable (
    IN HANDLE   IDConfigDB,
    IN HANDLE   CurrentInfo,
    IN ULONG    CurrentProfileNumber,
    IN ULONG    NewProfileNumber,
    IN PWCHAR   nameBuffer,
    IN PCHAR    valueBuffer,
    IN ULONG    bufferLen
    );

#pragma alloc_text(PAGE,CmDeleteKeyRecursive)
#pragma alloc_text(PAGE,CmpCloneHwProfile)
#pragma alloc_text(PAGE,CmSetAcpiHwProfile)
#pragma alloc_text(PAGE,CmpFilterAcpiDockingState)
#pragma alloc_text(PAGE,CmpGetAcpiProfileInformation)
#pragma alloc_text(PAGE,CmpAddAcpiAliasEntry)
#pragma alloc_text(PAGE,CmpMoveBiosAliasTable)
#pragma alloc_text(PAGE,CmpCreateHwProfileFriendlyName)

extern UNICODE_STRING  CmSymbolicLinkValueName;

NTSTATUS
CmpGetAcpiProfileInformation (
    IN  HANDLE  IDConfigDB,
    OUT PCM_HARDWARE_PROFILE_LIST * ProfileList,
    OUT PCM_HARDWARE_PROFILE_ACPI_ALIAS_LIST * AliasList,
    IN  PWCHAR  nameBuffer,
    IN  PUCHAR  valueBuffer,
    IN  ULONG   bufferLen
    )
/*++
Routine Description:

    Obtain the alias and hardware profile information from the registry.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    HANDLE      acpiAlias = NULL;
    HANDLE      profiles = NULL;
    HANDLE      entry = NULL;
    ULONG       len = 0;
    ULONG       i, j;
    OBJECT_ATTRIBUTES   attributes;
    UNICODE_STRING      name;
    KEY_FULL_INFORMATION        keyInfo;
    PKEY_VALUE_FULL_INFORMATION value;
    PKEY_BASIC_INFORMATION      basicInfo;

    PAGED_CODE ();

    *ProfileList = NULL;
    *AliasList = NULL;

    value = (PKEY_VALUE_FULL_INFORMATION) valueBuffer;
    basicInfo = (PKEY_BASIC_INFORMATION) valueBuffer;

    //
    // Open a handle to the Profile information
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_HARDWARE_PROFILES);
    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                IDConfigDB,
                                NULL);
    status = ZwOpenKey (&profiles,
                        KEY_READ,
                        &attributes);

    if (!NT_SUCCESS (status)) {
        profiles = NULL;
        goto Clean;
    }

    //
    // Find the number of profile Sub Keys
    //
    status = ZwQueryKey (profiles,
                         KeyFullInformation,
                         &keyInfo,
                         sizeof (keyInfo),
                         &len);

    if (!NT_SUCCESS (status)) {
        goto Clean;
    }

    ASSERT (0 < keyInfo.SubKeys);

    len = sizeof (CM_HARDWARE_PROFILE_LIST)
        + (sizeof (CM_HARDWARE_PROFILE) * (keyInfo.SubKeys - 1));

    * ProfileList = ExAllocatePool (PagedPool, len);
    if (NULL == *ProfileList) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean;
    }
    RtlZeroMemory (*ProfileList, len);

    (*ProfileList)->MaxProfileCount = keyInfo.SubKeys;
    (*ProfileList)->CurrentProfileCount = 0;

    //
    // Iterrate the profiles
    //
    for (i = 0; i < keyInfo.SubKeys; i++) {
        CM_HARDWARE_PROFILE TempProfile;
        UNICODE_STRING      KeyName;
        ULONG               realsize;

        //
        // Get the first key in the list.
        //
        status = ZwEnumerateKey (profiles,
                                 i,
                                 KeyBasicInformation,
                                 basicInfo,
                                 bufferLen - sizeof (UNICODE_NULL), // term 0
                                 &len);

        if (!NT_SUCCESS (status)) {
            //
            // This should never happen.
            //
            break;
        }

        basicInfo->Name [basicInfo->NameLength/sizeof(WCHAR)] = 0;
        name.Length = (USHORT) basicInfo->NameLength;
        name.MaximumLength = (USHORT) basicInfo->NameLength + sizeof (UNICODE_NULL);
        name.Buffer = basicInfo->Name;

        InitializeObjectAttributes (&attributes,
                                    &name,
                                    OBJ_CASE_INSENSITIVE,
                                    profiles,
                                    NULL);
        status = ZwOpenKey (&entry,
                            KEY_READ,
                            &attributes);
        if (!NT_SUCCESS (status)) {
            break;
        }

        //
        // Fill in the temporary profile structure with this
        // profile's data.
        //
        RtlUnicodeStringToInteger(&name, 0, &TempProfile.Id);

        //
        // Find the pref order of this entry.
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PREFERENCE_ORDER);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if ((!NT_SUCCESS (status)) || (value->Type != REG_DWORD)) {
            TempProfile.PreferenceOrder = -1;

        } else {
            TempProfile.PreferenceOrder
                = * (PULONG) ((PUCHAR) value + value->DataOffset);
        }

        //
        // Extract the friendly name
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_FRIENDLY_NAME);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if (!NT_SUCCESS (status) || (value->Type != REG_SZ)) {
            WCHAR tmpname[] = L"-------"; // as taken from cmboot.c
            ULONG len;
            PVOID buffer;

            len = sizeof (tmpname);
            buffer = ExAllocatePool (PagedPool, len);

            TempProfile.NameLength = len;
            TempProfile.FriendlyName = buffer;
            if (NULL == buffer) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                ZwClose (entry);
                goto Clean;
            }
            RtlCopyMemory (buffer, tmpname, value->DataLength);

        } else {
            PVOID buffer;

            buffer = ExAllocatePool (PagedPool, value->DataLength);
            TempProfile.NameLength = value->DataLength;
            TempProfile.FriendlyName = buffer;
            if (NULL == buffer) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                ZwClose (entry);
                goto Clean;
            }
            RtlCopyMemory (buffer,
                           (PUCHAR) value + value->DataOffset,
                           value->DataLength);
        }

        TempProfile.Flags = 0;
        //
        // Is this aliasable?
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ALIASABLE);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if (NT_SUCCESS (status) && (value->Type == REG_DWORD)) {
            if (* (PULONG) ((PUCHAR) value + value->DataOffset)) {
                TempProfile.Flags |= CM_HP_FLAGS_ALIASABLE;
            }

        } else {
            TempProfile.Flags |= CM_HP_FLAGS_ALIASABLE;
        }

        //
        // Is this pristine?
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PRISTINE);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if (NT_SUCCESS (status) && (value->Type == REG_DWORD)) {
            if (* (PULONG) ((PUCHAR) value + value->DataOffset)) {
                TempProfile.Flags = CM_HP_FLAGS_PRISTINE;
                // No other flags set;
            }
        }

        //
        // If we see a profile with the ID of zero (AKA an illegal)
        // ID for a hardware profile to possess, then we know that this
        // must be a pristine profile.
        //
        if (0 == TempProfile.Id) {
            TempProfile.Flags = CM_HP_FLAGS_PRISTINE;
            // NO other flags set.

            TempProfile.PreferenceOrder = -1; // move to the end of the list.
        }


        //
        // Insert this new profile into the appropriate spot in the
        // profile array. Entries are sorted by preference order.
        //
        for (j=0; j < (*ProfileList)->CurrentProfileCount; j++) {
            if ((*ProfileList)->Profile[j].PreferenceOrder >=
                TempProfile.PreferenceOrder) {

                //
                // Insert at position j.
                //
                RtlMoveMemory(&(*ProfileList)->Profile[j+1],
                              &(*ProfileList)->Profile[j],
                              sizeof(CM_HARDWARE_PROFILE) *
                              ((*ProfileList)->MaxProfileCount-j-1));
                break;
            }
        }
        (*ProfileList)->Profile[j] = TempProfile;
        ++(*ProfileList)->CurrentProfileCount;

        ZwClose (entry);
    }

    //
    // Open a handle to the ACPI Alias information
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ACPI_ALIAS);
    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                IDConfigDB,
                                NULL);
    status = ZwOpenKey (&acpiAlias,
                        KEY_READ,
                        &attributes);

    if (!NT_SUCCESS (status)) {
        //
        // So we don't have an alias table.  This is ok.
        //
        status = STATUS_SUCCESS;
        acpiAlias = NULL;
        goto Clean;
    }

    //
    // Find the number of Acpi Alias Sub Keys
    //
    status = ZwQueryKey (acpiAlias,
                         KeyFullInformation,
                         &keyInfo,
                         sizeof (keyInfo),
                         &len);

    if (!NT_SUCCESS (status)) {
        goto Clean;
    }


    ASSERT (0 < keyInfo.SubKeys);

    * AliasList = ExAllocatePool (
                        PagedPool,
                        sizeof (CM_HARDWARE_PROFILE_LIST) +
                        (sizeof (CM_HARDWARE_PROFILE) * (keyInfo.SubKeys - 1)));

    if (NULL == *AliasList) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean;
    }

    (*AliasList)->MaxAliasCount =
        (*AliasList)->CurrentAliasCount = keyInfo.SubKeys;

    //
    // Iterrate the alias entries
    //
    for (i = 0; i < keyInfo.SubKeys; i++) {

        //
        // Get the first key in the list.
        //
        status = ZwEnumerateKey (acpiAlias,
                                 i,
                                 KeyBasicInformation,
                                 basicInfo,
                                 bufferLen - sizeof (UNICODE_NULL), // term 0
                                 &len);

        if (!NT_SUCCESS (status)) {
            //
            // This should never happen.
            //
            break;
        }

        basicInfo->Name [basicInfo->NameLength/sizeof(WCHAR)] = 0;
        name.Length = (USHORT) basicInfo->NameLength;
        name.MaximumLength = (USHORT) basicInfo->NameLength + sizeof (UNICODE_NULL);
        name.Buffer = basicInfo->Name;

        InitializeObjectAttributes (&attributes,
                                    &name,
                                    OBJ_CASE_INSENSITIVE,
                                    acpiAlias,
                                    NULL);
        status = ZwOpenKey (&entry,
                            KEY_READ,
                            &attributes);
        if (!NT_SUCCESS (status)) {
            break;
        }

        //
        // Extract The Profile number to which this alias refers.
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PROFILE_NUMBER);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
            status = STATUS_REGISTRY_CORRUPT;
            ZwClose (entry);
            goto Clean;
        }
        (*AliasList)->Alias[i].ProfileNumber =
            * (PULONG) ((PUCHAR) value + value->DataOffset);

        //
        // Extract The Docking State.
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKING_STATE);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
            status = STATUS_REGISTRY_CORRUPT;
            ZwClose (entry);
            goto Clean;
        }
        (*AliasList)->Alias[i].DockState =
            * (PULONG) ((PUCHAR) value + value->DataOffset);


        //
        // Find the SerialNumber
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ACPI_SERIAL_NUMBER);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if (!NT_SUCCESS (status) || (value->Type != REG_BINARY)) {
            status = STATUS_REGISTRY_CORRUPT;
            ZwClose (entry);
            goto Clean;
        }

        (*AliasList)->Alias[i].SerialLength = value->DataLength;
        (*AliasList)->Alias[i].SerialNumber =
                    (value->DataLength) ?
                    ExAllocatePool (PagedPool, value->DataLength) :
                    0;

        if (value->DataLength && (NULL == (*AliasList)->Alias[i].SerialNumber)) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            ZwClose (entry);
            goto Clean;
        }

        if (value->DataLength) {
            RtlCopyMemory ((*AliasList)->Alias[i].SerialNumber,
                           (PUCHAR) value + value->DataOffset,
                           value->DataLength);
        }

        ZwClose (entry);
    }

Clean:
    if (NULL != acpiAlias) {
        NtClose (acpiAlias);
    }
    if (NULL != profiles) {
        NtClose (profiles);
    }

    if (!NT_SUCCESS (status)) {
        if (NULL != *ProfileList) {
            for (i = 0; i < (*ProfileList)->CurrentProfileCount; i++) {
                if ((*ProfileList)->Profile[i].FriendlyName) {
                    ExFreePool ((*ProfileList)->Profile[i].FriendlyName);
                }
            }
            ExFreePool (*ProfileList);
            *ProfileList = 0;
        }
        if (NULL != *AliasList) {
            for (i = 0; i < (*AliasList)->CurrentAliasCount; i++) {
                if ((*AliasList)->Alias[i].SerialNumber) {
                    ExFreePool ((*AliasList)->Alias[i].SerialNumber);
                }
            }
            ExFreePool (*AliasList);
            *AliasList = 0;
        }
    }
    return status;
}

NTSTATUS
CmpAddAcpiAliasEntry (
    IN HANDLE                       IDConfigDB,
    IN PPROFILE_ACPI_DOCKING_STATE  NewDockState,
    IN ULONG                        ProfileNumber,
    IN PWCHAR                       nameBuffer,
    IN PVOID                        valueBuffer,
    IN ULONG                        valueBufferLength,
    IN BOOLEAN                      PreventDuplication
    )
/*++
Routine Description:
    Set the Acpi Alais entry.


    Routine Description:
    Create an alias entry in the IDConfigDB database for the given
    hardware profile.

    Create the "AcpiAlias" key if it does not exist.

Parameters:

    IDConfigDB - Pointer to "..\CurrentControlSet\Control\IDConfigDB"

    NewDockState - The new docking state for which this alias points.

    ProfileNumber -The profile number to which this alias points.

    nameBuffer - a temp scratch space for writing things.
                (assumed to be at least 128 WCHARS)

--*/
{
    OBJECT_ATTRIBUTES attributes;
    NTSTATUS        status = STATUS_SUCCESS;
    ANSI_STRING     ansiString;
    UNICODE_STRING  name;
    HANDLE          aliasKey = NULL;
    HANDLE          aliasEntry = NULL;
    ULONG           value;
    ULONG           disposition;
    ULONG           aliasNumber = 0;
    ULONG           len;
    PKEY_VALUE_FULL_INFORMATION   keyInfo;

    PAGED_CODE ();

    keyInfo = (PKEY_VALUE_FULL_INFORMATION) valueBuffer;

    //
    // Find the Alias Key or Create it if it does not already exist.
    //
    RtlInitUnicodeString (&name,CM_HARDWARE_PROFILE_STR_ACPI_ALIAS);

    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                IDConfigDB,
                                NULL);

    status = NtOpenKey (&aliasKey,
                        KEY_READ | KEY_WRITE,
                        &attributes);

    if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
        status = NtCreateKey (&aliasKey,
                              KEY_READ | KEY_WRITE,
                              &attributes,
                              0, // no title
                              NULL, // no class
                              0, // no options
                              &disposition);
    }

    if (!NT_SUCCESS (status)) {
        aliasKey = NULL;
        goto Exit;
    }

    //
    // Create an entry key
    //

    while (aliasNumber < 200) {
        aliasNumber++;

        swprintf (nameBuffer, L"%04d", aliasNumber);
        RtlInitUnicodeString (&name, nameBuffer);

        InitializeObjectAttributes(&attributes,
                                   &name,
                                   OBJ_CASE_INSENSITIVE,
                                   aliasKey,
                                   NULL);

        status = NtOpenKey (&aliasEntry,
                            KEY_READ | KEY_WRITE,
                            &attributes);

        if (NT_SUCCESS (status)) {

            if (PreventDuplication) {
                //
                // If we have a matching DockingState, SerialNumber, and
                // Profile Number, then we should not make this alias
                //

                //
                // Extract The DockingState to which this alias refers.
                //
                RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKING_STATE);
                status = NtQueryValueKey(aliasEntry,
                                         &name,
                                         KeyValueFullInformation,
                                         valueBuffer,
                                         valueBufferLength,
                                         &len);

                if (!NT_SUCCESS (status) || (keyInfo->Type != REG_DWORD)) {
                    status = STATUS_REGISTRY_CORRUPT;
                    goto Exit;
                }

                if (NewDockState->DockingState !=
                    * (PULONG) ((PUCHAR) keyInfo + keyInfo->DataOffset)) {
                    //
                    // Not a dupe
                    //

                    NtClose (aliasEntry);
                    aliasEntry = NULL;
                    continue;
                }

                //
                // Extract the SerialNumber
                //
                RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ACPI_SERIAL_NUMBER);
                status = NtQueryValueKey(aliasEntry,
                                         &name,
                                         KeyValueFullInformation,
                                         valueBuffer,
                                         valueBufferLength,
                                         &len);

                if (!NT_SUCCESS (status) || (keyInfo->Type != REG_BINARY)) {
                    status = STATUS_REGISTRY_CORRUPT;
                    goto Exit;
                }

                if (NewDockState->SerialLength != keyInfo->DataLength) {
                    //
                    // Not a dupe
                    //

                    NtClose (aliasEntry);
                    aliasEntry = NULL;
                    continue;
                }

                if (!RtlEqualMemory (NewDockState->SerialNumber,
                                     ((PUCHAR) keyInfo + keyInfo->DataOffset),
                                     NewDockState->SerialLength)) {
                    //
                    // Not a dupe
                    //

                    NtClose (aliasEntry);
                    aliasEntry = NULL;
                    continue;
                }

                status = STATUS_SUCCESS;
                goto Exit;

            }

        } else if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
            status = STATUS_SUCCESS;
            break;

        } else {
            break;
        }

    }
    if (!NT_SUCCESS (status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: cmpCreateAcpiAliasEntry error finding new set %08lx\n",status));
        aliasEntry = 0;
        goto Exit;
    }

    status = NtCreateKey (&aliasEntry,
                          KEY_READ | KEY_WRITE,
                          &attributes,
                          0,
                          NULL,
                          0,
                          &disposition);

    if (!NT_SUCCESS (status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: cmpCreateAcpiAliasEntry error creating new set %08lx\n",status));
        aliasEntry = 0;
        goto Exit;
    }

    //
    // Write the Docking State;
    //
    value = NewDockState->DockingState;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKING_STATE);
    status = NtSetValueKey (aliasEntry,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    //
    // Write the Serial Number
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ACPI_SERIAL_NUMBER);
    status = NtSetValueKey (aliasEntry,
                            &name,
                            0,
                            REG_BINARY,
                            NewDockState->SerialNumber,
                            NewDockState->SerialLength);

    //
    // Write the Profile Number
    //
    value = ProfileNumber;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PROFILE_NUMBER);
    status = NtSetValueKey (aliasEntry,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

Exit:

    if (aliasKey) {
        NtClose (aliasKey);
    }

    if (aliasEntry) {
        NtClose (aliasEntry);
    }

    return status;
}

NTSTATUS
CmSetAcpiHwProfile (
    IN PPROFILE_ACPI_DOCKING_STATE NewDockState,
    IN PCM_ACPI_SELECTION_ROUTINE  Select,
    IN PVOID Context,
    OUT PHANDLE NewProfile,
    OUT PBOOLEAN ProfileChanged
    )
/*++
Routine Description:

    The ACPI docking state of the machine has changed.

    Based on the new change calculate the new HW Profile(s) consitent with the
    new ACPI docking state.

    Pass the list of known profiles to the callers selection routine.

    Set the new current profile.

    Patch up any ACPI alias entries if a new profile for this ACPI state has
    been used.

Arguments:

    NewDockStateArray - The list of possible Docking States that we might enter.

    Select - Call back to select which profile to enter, given the list of
             possible profiles.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    HANDLE          IDConfigDB = NULL;
    HANDLE          HardwareProfile = NULL;
    HANDLE          currentInfo = NULL;
    HANDLE          currentSymLink = NULL;
    HANDLE          parent = NULL;
    WCHAR           nameBuffer[128];
    UNICODE_STRING  name;
    UCHAR           valueBuffer[256];
    ULONG           len;
    ULONG           i;
    ULONG           selectedElement;
    ULONG           profileNum;
    ULONG           currentDockingState;
    ULONG           currentProfileNumber;
    ULONG           disposition;
    ULONG           flags;
    PWCHAR          currentAcpiSN = NULL;
    PCM_HARDWARE_PROFILE_ACPI_ALIAS_LIST  AliasList = NULL;
    PCM_HARDWARE_PROFILE_LIST             ProfileList = NULL;
    PKEY_VALUE_FULL_INFORMATION           value;
    OBJECT_ATTRIBUTES                     attributes;

    PAGED_CODE ();

    *ProfileChanged = FALSE;

    value = (PKEY_VALUE_FULL_INFORMATION) valueBuffer;

    //
    // Open The Hardware Profile Database
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DATABASE);
    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    status = ZwOpenKey (&IDConfigDB,
                        KEY_READ,
                        &attributes);

    if (!NT_SUCCESS (status)) {
        IDConfigDB = NULL;
        goto Clean;
    }

    //
    // Obtain the total list of profiles
    //
    status = CmpGetAcpiProfileInformation (IDConfigDB,
                                           &ProfileList,
                                           &AliasList,
                                           nameBuffer,
                                           valueBuffer,
                                           sizeof (valueBuffer));

    if (!NT_SUCCESS (status)) {
        goto Clean;
    }

    //
    // Determine the current Dock information.
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CCS_CURRENT);
    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    status = ZwOpenKey (&HardwareProfile,
                        KEY_READ,
                        &attributes);
    if (!NT_SUCCESS (status)) {
        HardwareProfile = NULL;
        goto Clean;
    }
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CURRENT_DOCK_INFO);
    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                IDConfigDB,
                                NULL);

    status = ZwOpenKey (&currentInfo,
                        KEY_READ,
                        &attributes);
    if (!NT_SUCCESS (status)) {
        currentInfo = NULL;
        goto Clean;
    }

    //
    // The current Docking State
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKING_STATE);
    status = NtQueryValueKey (currentInfo,
                              &name,
                              KeyValueFullInformation,
                              valueBuffer,
                              sizeof (valueBuffer),
                              &len);

    if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
        status = STATUS_REGISTRY_CORRUPT;
        goto Clean;
    }
    currentDockingState = * (PULONG) ((PUCHAR) value + value->DataOffset);

    //
    // The current ACPI Serial Number
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ACPI_SERIAL_NUMBER);
    status = NtQueryValueKey(currentInfo,
                             &name,
                             KeyValueFullInformation,
                             valueBuffer,
                             sizeof (valueBuffer),
                             &len);

    if (NT_SUCCESS (status) && (value->Type == REG_BINARY)) {

        currentAcpiSN = ExAllocatePool (PagedPool, value->DataLength);

        if (NULL == currentAcpiSN) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Clean;
        }
        RtlCopyMemory (currentAcpiSN,
                       (PUCHAR) value + value->DataOffset,
                       value->DataLength);
    } else {
        currentAcpiSN = 0;
    }

    //
    // The current Profile Number
    //
    RtlInitUnicodeString(&name, L"CurrentConfig");
    status = NtQueryValueKey(IDConfigDB,
                             &name,
                             KeyValueFullInformation,
                             valueBuffer,
                             sizeof (valueBuffer),
                             &len);

    if (!NT_SUCCESS(status) || (value->Type != REG_DWORD)) {
        status = STATUS_REGISTRY_CORRUPT;
        goto Clean;
    }
    currentProfileNumber = *(PULONG)((PUCHAR)value + value->DataOffset);

    //
    // Filter the current list of hardware profiles based on the current
    // docking state, the new acpi state, and the acpi alias tables
    //
    status = CmpFilterAcpiDockingState (NewDockState,
                                        currentDockingState,
                                        currentAcpiSN,
                                        currentProfileNumber,
                                        ProfileList,
                                        AliasList);

    if (!NT_SUCCESS (status)) {
        goto Clean;
    }

    //
    // Allow the caller a chance to select from the filtered list.
    //
    status = Select (ProfileList, &selectedElement, Context);

    //
    // If the user selected -1 then he is not interested in selecting any of
    // the profiles.
    //
    if (-1 == selectedElement) {
        ASSERT (STATUS_MORE_PROCESSING_REQUIRED == status);
        goto Clean;
    }

    if (!NT_SUCCESS (status)) {
        goto Clean;
    }

    //
    // Fine! We have finally made the new selection.
    // Set it.
    //

    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CCS_HWPROFILE);
    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
    status = ZwOpenKey (&parent, KEY_READ, &attributes);
    if (!NT_SUCCESS (status)) {
        parent = NULL;
        goto Clean;
    }

    //
    // How did we get here?
    //
    flags = ProfileList->Profile[selectedElement].Flags;
    profileNum = ProfileList->Profile[selectedElement].Id;

    //
    // Check for duplicate
    //
    if (flags & CM_HP_FLAGS_DUPLICATE) {
        //
        // If there is a duplicate then we need to adjust the pnp
        // bios alias table.
        //
        // This happens if we booted PnP bios detected docked, and then
        // we received a set state for ACPI as docked, then we have the
        // potential for duplicates.  See Comment in CmpFilterAcpiDockingState
        // for details.
        //
        // We need to find any pnp bios alias entries that match the current
        // state and point them to the duplicate entry.
        //

        ASSERT (flags & CM_HP_FLAGS_TRUE_MATCH);
        ASSERT (!(flags & CM_HP_FLAGS_PRISTINE));

        status = CmpMoveBiosAliasTable (IDConfigDB,
                                        currentInfo,
                                        currentProfileNumber,
                                        profileNum,
                                        nameBuffer,
                                        valueBuffer,
                                        sizeof (valueBuffer));

        if (!NT_SUCCESS (status)) {
            goto Clean;
        }
    }

    if ((flags & CM_HP_FLAGS_PRISTINE) || (profileNum != currentProfileNumber)){
        //
        // The profile Number Changed or will change.
        //
        *ProfileChanged = TRUE;

        ASSERT (currentInfo);
        ZwClose (currentInfo);
        currentInfo = NULL;

        if (flags & CM_HP_FLAGS_PRISTINE) {
            //
            // If the selected profile is pristine then we need to clone.
            //
            ASSERT (!(flags & CM_HP_FLAGS_TRUE_MATCH));
            status = CmpCloneHwProfile (IDConfigDB,
                                        parent,
                                        HardwareProfile,
                                        profileNum,
                                        NewDockState->DockingState,
                                        &HardwareProfile,
                                        &profileNum);
            if (!NT_SUCCESS (status)) {
                HardwareProfile = 0;
                goto Clean;
            }
        } else {
            ASSERT (HardwareProfile);
            ZwClose (HardwareProfile);

            //
            // Open the new profile
            //
            swprintf (nameBuffer, L"%04d\0", profileNum);
            RtlInitUnicodeString (&name, nameBuffer);
            InitializeObjectAttributes (&attributes,
                                        &name,
                                        OBJ_CASE_INSENSITIVE,
                                        parent,
                                        NULL);
            status = ZwOpenKey (&HardwareProfile, KEY_READ, &attributes);
            if (!NT_SUCCESS (status)) {
                HardwareProfile = NULL;
                goto Clean;
            }
        }

        ASSERT (currentProfileNumber != profileNum);

        //
        // Open the current info for the profile.
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CURRENT_DOCK_INFO);
        InitializeObjectAttributes (&attributes,
                                    &name,
                                    OBJ_CASE_INSENSITIVE,
                                    IDConfigDB,
                                    NULL);

        status = NtCreateKey (&currentInfo,
                              KEY_READ | KEY_WRITE,
                              &attributes,
                              0,
                              NULL,
                              REG_OPTION_VOLATILE,
                              &disposition);

        if (!NT_SUCCESS (status)) {
            currentInfo = NULL;
            goto Clean;
        }

        //
        // Set CurrentConfig in the Database
        //
        RtlInitUnicodeString(&name, L"CurrentConfig");
        status = NtSetValueKey(IDConfigDB,
                                 &name,
                                 0,
                                 REG_DWORD,
                                 &profileNum,
                                 sizeof (profileNum));

         if (!NT_SUCCESS(status)) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Clean;
        }
    }

    //
    // Write the new Docking State to the current Info key
    //
    i = NewDockState->DockingState;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKING_STATE);
    status = ZwSetValueKey (currentInfo,
                            &name,
                            0,
                            REG_DWORD,
                            &i,
                            sizeof (ULONG));

    //
    // Write the new ACPI information to the current Info key
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ACPI_SERIAL_NUMBER);
    status = ZwSetValueKey (currentInfo,
                            &name,
                            0,
                            REG_BINARY,
                            NewDockState->SerialNumber,
                            NewDockState->SerialLength);

    if (!(flags & CM_HP_FLAGS_TRUE_MATCH)) {
        //
        // Add the alias entry for this profile.
        //
        status = CmpAddAcpiAliasEntry (IDConfigDB,
                                       NewDockState,
                                       profileNum,
                                       nameBuffer,
                                       valueBuffer,
                                       sizeof (valueBuffer),
                                       FALSE); // Don't Prevent Duplication
    }

    if (profileNum != currentProfileNumber) {
        //
        // Move the symbolic link.
        //
        RtlInitUnicodeString(&name, CM_HARDWARE_PROFILE_STR_CCS_CURRENT);
        InitializeObjectAttributes(&attributes,
                                   &name,
                                   OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                                   NULL,
                                   NULL);

        status = NtCreateKey(&currentSymLink,
                             KEY_CREATE_LINK,
                             &attributes,
                             0,
                             NULL,
                             REG_OPTION_OPEN_LINK,
                             &disposition);

        ASSERT (STATUS_SUCCESS == status);
        ASSERT (REG_OPENED_EXISTING_KEY == disposition);

        swprintf (nameBuffer,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\%04d",
                  profileNum);
        RtlInitUnicodeString (&name, nameBuffer);
        status = NtSetValueKey (currentSymLink,
                                &CmSymbolicLinkValueName,
                                0,
                                REG_LINK,
                                name.Buffer,
                                name.Length);

        ASSERT (STATUS_SUCCESS == status);
    }


Clean:
    if (NT_SUCCESS (status)) {
        // NB more process required is not a success code.
        *NewProfile = HardwareProfile;
    } else if (NULL != HardwareProfile) {
        ZwClose (HardwareProfile);
    }

    if (NULL != IDConfigDB) {
        ZwClose (IDConfigDB);
    }
    if (NULL != currentInfo) {
        ZwClose (currentInfo);
    }
    if (NULL != parent) {
        ZwClose (parent);
    }
    if (NULL != currentAcpiSN) {
        ExFreePool (currentAcpiSN);
    }
    if (NULL != ProfileList) {
        for (i = 0; i < ProfileList->CurrentProfileCount; i++) {
            if (ProfileList->Profile[i].FriendlyName) {
                ExFreePool (ProfileList->Profile[i].FriendlyName);
            }
        }
        ExFreePool (ProfileList);
    }
    if (NULL != AliasList) {
        for (i = 0; i < AliasList->CurrentAliasCount; i++) {
            if (AliasList->Alias[i].SerialNumber) {
                ExFreePool (AliasList->Alias[i].SerialNumber);
            }
        }
        ExFreePool (AliasList);
    }

    return status;
}

NTSTATUS
CmpFilterAcpiDockingState (
    IN     PPROFILE_ACPI_DOCKING_STATE  NewDockingState,
    IN     ULONG                        CurrentDockState,
    IN     PWCHAR                       CurrentAcpiSN,
    IN     ULONG                        CurrentProfileNumber,
    IN OUT PCM_HARDWARE_PROFILE_LIST    ProfileList,
    IN OUT PCM_HARDWARE_PROFILE_ACPI_ALIAS_LIST AliasList
    )
/*++
Routine Description:
    Given the new state of things and the current state of things,
    prune the given list of profiles.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG i = 0;
    ULONG j;
    ULONG len;
    ULONG mask = HW_PROFILE_DOCKSTATE_UNDOCKED | HW_PROFILE_DOCKSTATE_DOCKED;
    ULONG flags;
    PCM_HARDWARE_PROFILE_ACPI_ALIAS alias;
    BOOLEAN trueMatch = FALSE;
    BOOLEAN dupDetect = FALSE;
    BOOLEAN currentListed = FALSE;
    BOOLEAN keepCurrent = FALSE;

    PAGED_CODE ();

    //
    // Check for duplicate:
    //
    // If the user boots undocked, and then hot docks.  We will generate
    // a profile alias for the pnp reported undocked state [A], and one for the
    // ACPI reported docked state [B}.  If the use subsequently reboots docked,
    // then we will create a third pnp reported docked state [C] profile alias.
    // {C] is really a duplicate of [B}, but we wont know this until such time
    // as the ACPI state for {B] is reported.
    //
    // The same can happen for undocked scenerios.
    //
    // Detection: If the Current Dock State is the same as
    // NewDockingState.DockingState then there is a potential for a duplicate.
    // In order to also have a duplicate we must have an acpi already pointing
    // to a profile different than the current one.
    // This must also be the first ACPI change since we booted, therefore
    // CurrentAcpiSn Should be Zero.
    // In other words there must be at least one true match and none of the
    // true matches can point to the current profile.
    //

    if (AliasList) {
        while (i < AliasList->CurrentAliasCount) {
            alias = &AliasList->Alias[i];

            if (((alias->DockState & mask) != 0) &&
                ((alias->DockState & mask) !=
                 (NewDockingState->DockingState & mask))) {

                //
                // This alias claims to be docked or undocked, but does not
                // match the current state.  Therefore skip it.
                //
                ;

            } else if (alias->SerialLength != NewDockingState->SerialLength) {
                //
                // This alias has an incompatible serial number
                //
                ;

            } else if (alias->SerialLength ==
                       RtlCompareMemory (NewDockingState->SerialNumber,
                                         alias->SerialNumber,
                                         alias->SerialLength)) {
                //
                // NB RtlCompareMemory can work with zero length memory
                // addresses.  This is a requirement here.
                //



                //
                // This alias matches so mark the profile.
                //
                for (j = 0; j < ProfileList->CurrentProfileCount; j++) {
                    if (ProfileList->Profile[j].Id == alias->ProfileNumber) {

                        //
                        // Alias entries should never point to a pristine profile
                        //
                        ASSERT (!(ProfileList->Profile[j].Flags &
                                  CM_HP_FLAGS_PRISTINE));

                        ProfileList->Profile[j].Flags |= CM_HP_FLAGS_TRUE_MATCH;
                        trueMatch = TRUE;
                    }
                    if ((CurrentDockState == NewDockingState->DockingState) &&
                        (NULL == CurrentAcpiSN)) {
                        //
                        // The dock state did not change during this acpi
                        // event; therefore, we might just have a duplicate
                        // on our hands.
                        //
                        dupDetect = TRUE;
                    }
                    if (alias->ProfileNumber == CurrentProfileNumber) {
                        //
                        // There exists an entry in the acpi alias table that
                        // if chosen would result in no change of Hardware
                        // Profile.  Therefore, we should chose this one, and
                        // ignore the duplicate.
                        //
                        currentListed = TRUE;
                    }
                }
            }
            i++;
        }
    }

    if ((!dupDetect) &&
        (NULL == CurrentAcpiSN) &&
        (!trueMatch) &&
        (CurrentDockState == NewDockingState->DockingState)) {

        //
        // (1) The docking state did not change,
        // (2) the current profile has not yet, on this boot, been marked with
        //     an ACPI serial number.
        // (3) There was no Alias match.
        //
        // Therefore we should keep the current profile regardless of it being
        // aliasable.
        //

        keepCurrent = TRUE;
        trueMatch = TRUE;  // prevent pristine from being listed.
    }

    i = 0;
    while (i < ProfileList->CurrentProfileCount) {

        flags = ProfileList->Profile[i].Flags;

        if (dupDetect) {
            if (flags & CM_HP_FLAGS_TRUE_MATCH) {
                if (currentListed) {
                    if (ProfileList->Profile[i].Id == CurrentProfileNumber) {
                        //
                        // Let this one live.  This results in no change of
                        // profile number.
                        //
                        i++;
                        continue;
                    }
                    //
                    // Bounce any true matches that do not result in no change
                    // of profile.
                    //
                    ;

                } else {
                    //
                    // We did not find the current one listed so we definately
                    // have a duplicate.
                    //
                    // Mark it as such. and list it live.
                    //
                    ProfileList->Profile[i].Flags |= CM_HP_FLAGS_DUPLICATE;
                    i++;
                    continue;
                }
            }
            //
            // Bounce all non True matches in a duplicate detected situation.
            //
            ;

        } else if ((flags & CM_HP_FLAGS_PRISTINE) && !trueMatch) {
            //
            // Leave this one in the list
            //
            i++;
            continue;

        } else if (flags & CM_HP_FLAGS_ALIASABLE) {
            //
            // Leave this one in the list
            //
            ASSERT (! (flags & CM_HP_FLAGS_PRISTINE));
            i++;
            continue;

        } else if (flags & CM_HP_FLAGS_TRUE_MATCH) {
            //
            // Leave this one in the list
            //
            i++;
            continue;

        } else if (keepCurrent &&
                   (ProfileList->Profile[i].Id == CurrentProfileNumber)) {
            //
            // Leave this one in the list
            //
            i++;
            continue;
        }

        //
        // discard this profile by (1) shifting remaining profiles in
        //   array to fill in the space of this discarded profile
        //   and (2) decrementing profile count
        //
        len = ProfileList->CurrentProfileCount - i - 1;
        if (0 < len) {
            RtlMoveMemory(&ProfileList->Profile[i],
                          &ProfileList->Profile[i+1],
                          sizeof(CM_HARDWARE_PROFILE) * len);
        }

        --ProfileList->CurrentProfileCount;
    }

    return status;
}



NTSTATUS
CmpMoveBiosAliasTable (
    IN HANDLE   IDConfigDB,
    IN HANDLE   CurrentInfo,
    IN ULONG    CurrentProfileNumber,
    IN ULONG    NewProfileNumber,
    IN PWCHAR   nameBuffer,
    IN PCHAR    valueBuffer,
    IN ULONG    bufferLen
    )
/*++
Routine Description:
    Search the Alias table for bios entries which match the current
    docking state, and point from current profile number to new profile number.


    Assumption: If the profile is cloned (therefore created by
    CmpCloneHwProfile, and we have just moved the bios table to point
    away from this entry, then we *should* be able to safely delete
    the old hardware profile key.
    (in both IDConfigDB\HardwareProfiles and CCS\HardwareProfiles


--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    HANDLE          alias = NULL;
    HANDLE          entry = NULL;
    HANDLE          hwprofile = NULL;
    UNICODE_STRING  name;
    ULONG           currentDockId;
    ULONG           currentSerialNumber;
    ULONG           len;
    ULONG           i;
    OBJECT_ATTRIBUTES           attributes;
    KEY_FULL_INFORMATION        keyInfo;
    PKEY_BASIC_INFORMATION      basicInfo;
    PKEY_VALUE_FULL_INFORMATION value;

    PAGED_CODE ();

    value = (PKEY_VALUE_FULL_INFORMATION) valueBuffer;
    basicInfo = (PKEY_BASIC_INFORMATION) valueBuffer;

    //
    // Extract the current Serial Number and DockID
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_SERIAL_NUMBER);
    status = NtQueryValueKey(CurrentInfo,
                             &name,
                             KeyValueFullInformation,
                             valueBuffer,
                             bufferLen,
                             &len);
    if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
        status = STATUS_REGISTRY_CORRUPT;
        goto Clean;
    }
    currentSerialNumber = * (PULONG) ((PUCHAR) value + value->DataOffset);

    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKID);
    status = NtQueryValueKey(CurrentInfo,
                             &name,
                             KeyValueFullInformation,
                             valueBuffer,
                             bufferLen,
                             &len);
    if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
        status = STATUS_REGISTRY_CORRUPT;
        goto Clean;
    }
    currentDockId = * (PULONG) ((PUCHAR) value + value->DataOffset);

    //
    // Open a handle to the Alias information
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ALIAS);
    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                IDConfigDB,
                                NULL);
    status = ZwOpenKey (&alias,
                        KEY_READ,
                        &attributes);

    if (!NT_SUCCESS (status)) {
        //
        // So we don't have an alias table.  This is ok, albeit a bit strange
        //
        status = STATUS_SUCCESS;
        alias = NULL;
        goto Clean;
    }


    status = ZwQueryKey (alias,
                         KeyFullInformation,
                         &keyInfo,
                         sizeof (keyInfo),
                         &len);

    if (!NT_SUCCESS (status)) {
        goto Clean;
    }
    ASSERT (0 < keyInfo.SubKeys);

    //
    // Iterrate the alias entries
    //
    for (i = 0; i < keyInfo.SubKeys; i++) {

        //
        // Get the first key in the list.
        //
        status = ZwEnumerateKey (alias,
                                 i,
                                 KeyBasicInformation,
                                 basicInfo,
                                 bufferLen - sizeof (UNICODE_NULL), // term 0
                                 &len);

        if (!NT_SUCCESS (status)) {
            //
            // This should never happen.
            //
            break;
        }

        basicInfo->Name [basicInfo->NameLength/sizeof(WCHAR)] = 0;
        name.Length = (USHORT) basicInfo->NameLength;
        name.MaximumLength = (USHORT) basicInfo->NameLength + sizeof (UNICODE_NULL);
        name.Buffer = basicInfo->Name;

        InitializeObjectAttributes (&attributes,
                                    &name,
                                    OBJ_CASE_INSENSITIVE,
                                    alias,
                                    NULL);
        status = ZwOpenKey (&entry,
                            KEY_READ | KEY_WRITE,
                            &attributes);
        if (!NT_SUCCESS (status)) {
            break;
        }

        //
        // Extract The Profile number to which this alias refers.
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PROFILE_NUMBER);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Clean;
        }

        if (CurrentProfileNumber != *(PULONG)((PUCHAR)value + value->DataOffset)) {

            //
            // Not a match
            //
            ZwClose (entry);
            entry = NULL;
            continue;
        }

        //
        // Compare the Dock ID
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKID);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);
        if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Clean;
        }
        if (currentDockId != * (PULONG) ((PUCHAR) value + value->DataOffset)) {
            //
            // Not a match
            //
            ZwClose (entry);
            entry = NULL;
            continue;
        }

        //
        // Compare the SerialNumber
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_SERIAL_NUMBER);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);
        if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Clean;
        }
        if (currentSerialNumber != *(PULONG)((PUCHAR)value + value->DataOffset)) {
            //
            // Not a match
            //
            ZwClose (entry);
            entry = NULL;
            continue;
        }

        //
        // This must be a match.
        // move the profile number
        //

        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PROFILE_NUMBER);
        status = NtSetValueKey (entry,
                                &name,
                                0,
                                REG_DWORD,
                                &NewProfileNumber,
                                sizeof (NewProfileNumber));

        ASSERT (STATUS_SUCCESS == status);

        ZwClose (entry);
        entry = NULL;

        //
        // We most likely have left a dangling profile here.
        // Try to attempt to clean it up.
        //
        // If this profile is cloned then we created it and can therefore
        // get rid of it.
        //

        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_HARDWARE_PROFILES);
        InitializeObjectAttributes (&attributes,
                                    &name,
                                    OBJ_CASE_INSENSITIVE,
                                    IDConfigDB,
                                    NULL);
        status = ZwOpenKey (&hwprofile, KEY_READ | KEY_WRITE, &attributes);
        if (!NT_SUCCESS (status)) {
            hwprofile = NULL;
            status = STATUS_REGISTRY_CORRUPT;
            goto Clean;
        }

        swprintf (nameBuffer, L"%04d\0", CurrentProfileNumber);
        RtlInitUnicodeString (&name, nameBuffer);
        InitializeObjectAttributes (&attributes,
                                    &name,
                                    OBJ_CASE_INSENSITIVE,
                                    hwprofile,
                                    NULL);
        status = ZwOpenKey (&entry, KEY_ALL_ACCESS, &attributes);
        if (!NT_SUCCESS (status)) {
            entry = NULL;
            status = STATUS_REGISTRY_CORRUPT;
            goto Clean;
        }

        //
        // Test for the Cloned Bit.
        //

        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CLONED);
        status = NtQueryValueKey(entry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 bufferLen,
                                 &len);

        if (!NT_SUCCESS (status) || (value->Type != REG_DWORD)) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Clean;
        }

        if (*(PULONG)((PUCHAR)value + value->DataOffset)) {
            //
            // We cloned this one.
            //
            status = ZwDeleteKey (entry);
            ASSERT (NT_SUCCESS (status));

            ZwClose (entry);
            ZwClose (hwprofile);
            entry = hwprofile = NULL;

            RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CCS_HWPROFILE);
            InitializeObjectAttributes (&attributes,
                                        &name,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL);
            status = ZwOpenKey (&hwprofile, KEY_READ | KEY_WRITE, &attributes);
            if (!NT_SUCCESS (status)) {
                hwprofile = NULL;
                status = STATUS_REGISTRY_CORRUPT;
                goto Clean;
            }

            swprintf (nameBuffer, L"%04d\0", CurrentProfileNumber);

            status = CmDeleteKeyRecursive (hwprofile,
                                           nameBuffer,
                                           valueBuffer,
                                           bufferLen,
                                           TRUE);

            ASSERT (NT_SUCCESS (status));
            ZwClose (hwprofile);
            hwprofile = NULL;

        } else {
            //
            // We didn't clone this one.
            // don't do anything else.
            //
            ZwClose (entry);
            ZwClose (hwprofile);
            entry = hwprofile = NULL;
        }

        CM_HARDWARE_PROFILE_STR_CCS_HWPROFILE;



    }

Clean:

    if (alias) {
        ZwClose (alias);
    }
    if (entry) {
        ZwClose (entry);
    }
    if (hwprofile) {
        ZwClose (hwprofile);
    }

    return status;
}


NTSTATUS
CmpCloneHwProfile (
    IN HANDLE IDConfigDB,
    IN HANDLE Parent,
    IN HANDLE OldProfile,
    IN ULONG  OldProfileNumber,
    IN USHORT DockingState,
    OUT PHANDLE NewProfile,
    OUT PULONG  NewProfileNumber
    )
/*++
Routine Description

    The given hardware profile key needs cloning.
    Clone the key and then return the new profile.

Return:

    STATUS_SUCCESS - if the profile has been cloned, in which case the new
        profile key has been opened for read / write privs.  The old profile
        will be closed.

    <unsuccessful> - for a given error.  NewProfile is invalid and the Old
        Profile has also been closed.


                (Copied lovingly from CmpCloneControlSet)


--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING newProfileName;
    UNICODE_STRING name;
    UNICODE_STRING friendlyName;
    UNICODE_STRING guidStr;
    PCM_KEY_BODY oldProfileKey;
    PCM_KEY_BODY newProfileKey;
    OBJECT_ATTRIBUTES attributes;
    PSECURITY_DESCRIPTOR security;
    ULONG securityLength;
    WCHAR nameBuffer [64];
    HANDLE IDConfigDBEntry = NULL;
    ULONG disposition;
    ULONG value;
    UUID  uuid;
    PKEY_BASIC_INFORMATION keyBasicInfo;
    PKEY_FULL_INFORMATION keyFullInfo;
    PKEY_VALUE_FULL_INFORMATION keyValueInfo;
    ULONG  length, profileSubKeys, i;
    UCHAR  valueBuffer[256];
    HANDLE hardwareProfiles=NULL;
    HANDLE profileEntry=NULL;

    PAGED_CODE ();

    keyFullInfo  = (PKEY_FULL_INFORMATION)  valueBuffer;
    keyBasicInfo = (PKEY_BASIC_INFORMATION) valueBuffer;
    keyValueInfo = (PKEY_VALUE_FULL_INFORMATION) valueBuffer;

    *NewProfile = 0;
    *NewProfileNumber = OldProfileNumber;

    //
    // Find the new profile number.
    //

    while (*NewProfileNumber < 200) {
        (*NewProfileNumber)++;

        swprintf (nameBuffer, L"%04d", *NewProfileNumber);
        RtlInitUnicodeString (&newProfileName, nameBuffer);

        InitializeObjectAttributes(&attributes,
                                   &newProfileName,
                                   OBJ_CASE_INSENSITIVE,
                                   Parent,
                                   NULL);

        status = NtOpenKey (NewProfile,
                            KEY_READ | KEY_WRITE,
                            &attributes);

        if (NT_SUCCESS (status)) {
            NtClose (*NewProfile);

        } else if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
            status = STATUS_SUCCESS;
            break;

        } else {
            break;
        }

    }
    if (!NT_SUCCESS (status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHwProfile error finding new profile key %08lx\n", status));
        goto Exit;
    }

    //
    // Get the security descriptor from the old key to create the new clone one.
    //

    status = NtQuerySecurityObject (OldProfile,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &securityLength);

    if (STATUS_BUFFER_TOO_SMALL == status) {

        security = ExAllocatePool (PagedPool, securityLength);

        if (security != NULL) {
            status = NtQuerySecurityObject(OldProfile,
                                           DACL_SECURITY_INFORMATION,
                                           security,
                                           securityLength,
                                           &securityLength);
            if (!NT_SUCCESS (status)) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHwProfile"
                         " - NtQuerySecurityObject failed %08lx\n", status));
                ExFreePool(security);
                security=NULL;
            }
        }
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHwProfile"
                 " - NtQuerySecurityObject returned %08lx\n", status));
        security=NULL;
    }

    //
    // Create the new key
    //
    InitializeObjectAttributes  (&attributes,
                                 &newProfileName,
                                 OBJ_CASE_INSENSITIVE,
                                 Parent,
                                 security);

    status = NtCreateKey (NewProfile,
                          KEY_READ | KEY_WRITE,
                          &attributes,
                          0,
                          NULL,
                          0,
                          &disposition);

    if (NULL != security) {
        ExFreePool (security);
    }
    if (!NT_SUCCESS (status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHwProfile couldn't create Clone %08lx\n",status));
        goto Exit;
    }

    //
    // Check to make sure the key was created.  If it already exists,
    // something is wrong.
    //
    if (disposition != REG_CREATED_NEW_KEY) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHwProfile: Clone tree already exists!\n"));

        //
        // WARNNOTE:
        //      If somebody somehow managed to create a key in our way,
        //      they'll thwart duplication of the prestine.  Tough luck.
        //      Claim it worked and go on.
        //
        status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // Create the IDConfigDB Entry
    //
    swprintf (nameBuffer, L"Hardware Profiles\\%04d", *NewProfileNumber);
    RtlInitUnicodeString (&name, nameBuffer);

    InitializeObjectAttributes  (&attributes,
                                 &name,
                                 OBJ_CASE_INSENSITIVE,
                                 IDConfigDB,
                                 NULL);

    status = NtCreateKey (&IDConfigDBEntry,
                          KEY_READ | KEY_WRITE,
                          &attributes,
                          0,
                          NULL,
                          0,
                          &disposition);

    if (!NT_SUCCESS (status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHwProfile couldn't create Clone %08lx\n",status));
        IDConfigDBEntry = NULL;
        goto Exit;
    }

    //
    // Determine the next PreferenceOrder for the new profile.  (The
    // PrefenceOrder for the new profile will be incrementally next from the
    // greatest PreferenceOrder value of all the current profiles; assumes
    // current set of PreferenceOrder values is incremental)
    //

    //
    // Open the Hardware Profiles key
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_HARDWARE_PROFILES);

    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                IDConfigDB,
                                NULL);
    status = ZwOpenKey (&hardwareProfiles,
                        KEY_READ,
                        &attributes);
    
    if (!NT_SUCCESS (status)) {
        hardwareProfiles = NULL;
        goto Exit;
    }

    //
    // Find the number of profile Sub Keys
    //
    status = ZwQueryKey (hardwareProfiles,
                         KeyFullInformation,
                         valueBuffer,
                         sizeof (valueBuffer),
                         &length);

    if (!NT_SUCCESS (status)) {
        goto Exit;
    }

    //
    // At very least, the Pristine and the new profile key we just created,
    // should be there. 
    //
    profileSubKeys = keyFullInfo->SubKeys;
    ASSERT (1 < profileSubKeys);

    //
    // Initialize the highest PreferenceOrder value found to -1.
    //
    value = -1;

    //
    // Iterrate the profiles
    //
    for (i = 0; i < profileSubKeys; i++) {
    
        //
        // Enumerate all profile subkeys, noting their PreferenceOrder values.
        //
        status = ZwEnumerateKey (hardwareProfiles,
                                 i,
                                 KeyBasicInformation,
                                 valueBuffer,
                                 sizeof(valueBuffer) - sizeof (UNICODE_NULL), //term 0
                                 &length);
        if(!NT_SUCCESS(status)) {
            break;
        }
        
        //
        // Zero-terminate the subkey name just in case.
        //
        keyBasicInfo->Name[keyBasicInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // If this is the Pristine, or the NewProfile key, ignore it.
        //
        if ((!_wtoi(keyBasicInfo->Name)) || 
            ((ULONG)(_wtoi(keyBasicInfo->Name)) == *NewProfileNumber)) {
            continue;
        }
        
        //
        // Open this profile key
        //
        name.Length = (USHORT) keyBasicInfo->NameLength;
        name.MaximumLength = (USHORT) keyBasicInfo->NameLength + sizeof (UNICODE_NULL);
        name.Buffer = keyBasicInfo->Name;

        InitializeObjectAttributes (&attributes,
                                    &name,
                                    OBJ_CASE_INSENSITIVE,
                                    hardwareProfiles,
                                    NULL);
        status = ZwOpenKey (&profileEntry,
                            KEY_READ,
                            &attributes);
        if (!NT_SUCCESS (status)) {
            profileEntry = NULL;
            continue;
        }

        //
        // Extract The PreferenceOrder value for this Profile.
        //
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PREFERENCE_ORDER);
        status = NtQueryValueKey(profileEntry,
                                 &name,
                                 KeyValueFullInformation,
                                 valueBuffer,
                                 sizeof(valueBuffer),
                                 &length);

        if (!NT_SUCCESS (status) || (keyValueInfo->Type != REG_DWORD)) {
            //
            // No PreferenceOrder; continue on as best we can
            //
            ZwClose(profileEntry);
            profileEntry=NULL;
            continue;
        }

        //
        // If this is a the highest PreferenceOrder so far, reassign value to
        // this PreferenceOrder, OR assign it this valid PreferenceOrder if
        // value is still unassigned.
        //
        if (((*(PULONG) ((PUCHAR)keyValueInfo + keyValueInfo->DataOffset)) > value) ||
            (value == -1)) {
            value = (* (PULONG) ((PUCHAR)keyValueInfo + keyValueInfo->DataOffset));
        }
        
        ZwClose(profileEntry);
        profileEntry=NULL;
    }

    //
    // Increment value one above the greatest PreferenceOrder found.
    // (If no other profiles were found, (value+=1) == 0, the most preferred
    // profile) 
    //
    value += 1;

    //
    // Give the new profile a preference order.
    //
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PREFERENCE_ORDER);
    status = NtSetValueKey (IDConfigDBEntry,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    //
    // Give the new profile a friendly name, based on the DockingState
    //
    status = CmpCreateHwProfileFriendlyName(IDConfigDB,
                                            DockingState,
                                            *NewProfileNumber,
                                            &friendlyName);

    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_FRIENDLY_NAME);
        status = NtSetValueKey (IDConfigDBEntry,
                                &name,
                                0,
                                REG_SZ,
                                friendlyName.Buffer,
                                friendlyName.Length + sizeof(UNICODE_NULL));
        RtlFreeUnicodeString(&friendlyName);
    }

    //
    // Set the aliasable flag on the new "cloned profile" to be false
    //
    value = FALSE;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_ALIASABLE);
    status = NtSetValueKey (IDConfigDBEntry,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    //
    // Set the cloned profile on the new "cloned profile" to be true;
    //
    value = TRUE;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CLONED);
    status = NtSetValueKey (IDConfigDBEntry,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    //
    // Set the HwProfileGuid for the brand new profile
    //

    status = ExUuidCreate (&uuid);
    if (NT_SUCCESS (status)) {

        status = RtlStringFromGUID (&uuid, &guidStr);
        if (NT_SUCCESS (status)) {
            RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_HW_PROFILE_GUID);

            status = NtSetValueKey (IDConfigDBEntry,
                                    &name,
                                    0,
                                    REG_SZ,
                                    guidStr.Buffer,
                                    guidStr.MaximumLength);

            RtlFreeUnicodeString(&guidStr);
        } else {
            //
            // What's a fella to do?
            // let's just go on.
            //
            status = STATUS_SUCCESS;
        }

    } else {
        //
        // let's just go on.
        //
        status = STATUS_SUCCESS;
    }


    //
    // Clone the key
    //
    // (Copied lovingly from CmpCloneControlSet)
    //
    //
    status = ObReferenceObjectByHandle (OldProfile,
                                        KEY_READ,
                                        CmpKeyObjectType,
                                        KernelMode,
                                        (PVOID *)(&oldProfileKey),
                                        NULL);

    if (!NT_SUCCESS(status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHWProfile: couldn't reference CurrentHandle %08lx\n",
                    status));
        goto Exit;
    }

    status = ObReferenceObjectByHandle (*NewProfile,
                                        KEY_WRITE,
                                        CmpKeyObjectType,
                                        KernelMode,
                                        (PVOID *)(&newProfileKey),
                                        NULL);

    if (!NT_SUCCESS(status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHWProfile: couldn't reference CurrentHandle %08lx\n",
                 status));
        goto Exit;
    }

    CmpLockRegistryExclusive();

    //
    // Note: This copy tree command does not copy the values in the
    // root keys.  We are relying on this, since the values stored there
    // are things like "pristine" which we do not wish to have moved to the
    // new tree.
    //
    if (CmpCopyTree(oldProfileKey->KeyControlBlock->KeyHive,
                    oldProfileKey->KeyControlBlock->KeyCell,
                    newProfileKey->KeyControlBlock->KeyHive,
                    newProfileKey->KeyControlBlock->KeyCell)) {
        
        //
        // Set the max subkey name property for the new target key.
        //
        PCM_KEY_NODE    SourceNode;
        PCM_KEY_NODE    DestNode;
        SourceNode = (PCM_KEY_NODE)HvGetCell(oldProfileKey->KeyControlBlock->KeyHive,oldProfileKey->KeyControlBlock->KeyCell);
        if( SourceNode != NULL ) {
            DestNode = (PCM_KEY_NODE)HvGetCell(newProfileKey->KeyControlBlock->KeyHive,newProfileKey->KeyControlBlock->KeyCell);
            if( DestNode != NULL ) {
                //
                // CmpCopyTree doesn't do this.
                //
                ASSERT_CELL_DIRTY(newProfileKey->KeyControlBlock->KeyHive,newProfileKey->KeyControlBlock->KeyCell);
                
                DestNode->MaxNameLen = SourceNode->MaxNameLen;
                DestNode->MaxClassLen = SourceNode->MaxClassLen;

                HvReleaseCell(newProfileKey->KeyControlBlock->KeyHive,newProfileKey->KeyControlBlock->KeyCell);
                CmpRebuildKcbCache(newProfileKey->KeyControlBlock);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            HvReleaseCell(oldProfileKey->KeyControlBlock->KeyHive,oldProfileKey->KeyControlBlock->KeyCell);
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneHwProfile: tree copy failed.\n"));
        status = STATUS_REGISTRY_CORRUPT;
    }
    CmpUnlockRegistry();


Exit:
    NtClose (OldProfile);
    if (IDConfigDBEntry) {
        NtClose (IDConfigDBEntry);
    }
    if (hardwareProfiles) {
        NtClose (hardwareProfiles);
    }
    if (!NT_SUCCESS (status)) {
        if (*NewProfile) {
            NtClose (*NewProfile);
        }
    }    

    return status;
}

NTSTATUS
CmDeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key,
    PVOID   TemporaryBuffer,
    ULONG   LengthTemporaryBuffer,
    BOOLEAN ThisKeyToo
    )
/*++

Routine Description:

    Routine to recursively delete all subkeys under the given
    key, including the key given.

Arguments:

    hKeyRoot:    Handle to root relative to which the key to be deleted is
                 specified.

    Key:         Root relative path of the key which is to be recursively deleted.

    ThisKeyToo:  Whether after deletion of all subkeys, this key itself is to
                 be deleted.

Return Value:

    Status is returned.

--*/
{
    ULONG ResultLength;
    PKEY_BASIC_INFORMATION KeyInfo;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    PWSTR SubkeyName;
    HANDLE hKey;

    //
    // Initialize
    //

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;

    //
    // Open the key
    //

    RtlInitUnicodeString (&UnicodeString,Key);

    InitializeObjectAttributes(&Obja,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               hKeyRoot,
                               NULL);

    Status = ZwOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS(Status) ) {
        return(Status);
    }

    //
    // Enumerate all subkeys of the current key. if any exist they should
    // be deleted first.  since deleting the subkey affects the subkey
    // index, we always enumerate on subkeyindex 0
    //
    while(1) {
        Status = ZwEnumerateKey(
                    hKey,
                    0,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    LengthTemporaryBuffer,
                    &ResultLength
                    );
        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = ExAllocatePool (PagedPool,
                                     ((wcslen (KeyInfo->Name) + 1) *
                                      sizeof (WCHAR)));
        if (!SubkeyName) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        wcscpy(SubkeyName, KeyInfo->Name);
        Status = CmDeleteKeyRecursive( hKey,
                                       SubkeyName,
                                       TemporaryBuffer,
                                       LengthTemporaryBuffer,
                                       TRUE);
        ExFreePool(SubkeyName);
        if(!NT_SUCCESS(Status)) {
            break;
        }
    }

    //
    // Check the status, if the status is anything other than
    // STATUS_NO_MORE_ENTRIES we failed in deleting some subkey,
    // so we cannot delete this key too
    //

    if( Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS (Status)) {
        ZwClose(hKey);
        return (Status);
    }

    //
    // else delete the current key if asked to do so
    //
    if( ThisKeyToo ) {
        Status = ZwDeleteKey (hKey);
    }

    ZwClose(hKey);
    return(Status);
}

NTSTATUS
CmpCreateHwProfileFriendlyName (
    IN HANDLE           IDConfigDB,
    IN ULONG            DockingState,
    IN ULONG            NewProfileNumber,
    OUT PUNICODE_STRING FriendlyName
    )
/*++

Routine Description:

    Create a new FriendlyName for a new Hardware Profile, given the DockState.
    If a new profile name based on the DockState cannot be created, an attempt
    is made to create a default FriendlyName based on NewProfileNumber.  If
    successful, a unicode string with the new profile friendlyName is created.
    It is the responsibility of the caller to free this using
    RtlFreeUnicodeString.  If unsuccesful, no string is returned.

Arguments:

    IDConfigDB:       Handle to the IDConfigDB registry key.

    DockingState:     The Docking State of the profile for which the new
                      FriendlyName is being created.  This should be one of:
                      HW_PROFILE_DOCKSTATE_DOCKED,
                      HW_PROFILE_DOCKSTATE_UNDOCKED, or
                      HW_PROFILE_DOCKSTATE_UNKNOWN

    NewProfileNumber: The number of the new profile being created.  If unable to
                      create a DockState specific FriendlyName, this value will
                      be used to create a (not-so) FriendlyName.

    FriendlyName:     Supplies a unicode string to receive the FriendlyName for this
                      new profile.  The caller is expected to free this with
                      RtlFreeUnicodeString.

Return:

    NTSTATUS code.    Currently returns STATUS_SUCCESS, or STATUS_UNSUCCESSFUL.

Notes:

    The new FriendlyName is generated from the DockState and appropriate
    counter, and may not necessarily be unique among the existing Hardware
    Profiles.

    The naming scheme used here (including the localized strings in the kernel
    message table) should be kept in sync with that provided to the user through
    the Hardware Profile control panel applet.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    ANSI_STRING       ansiString;
    UNICODE_STRING    unicodeString;
    UNICODE_STRING    labelName, keyName;
    PMESSAGE_RESOURCE_ENTRY messageEntry;
    PKLDR_DATA_TABLE_ENTRY dataTableEntry;
    ULONG             messageId;
    UCHAR             valueBuffer[256];
    WCHAR             friendlyNameBuffer[MAX_FRIENDLY_NAME_LENGTH/sizeof(WCHAR)];
    PKEY_VALUE_FULL_INFORMATION  keyValueInfo;
    ULONG             length, index;
    HANDLE            hardwareProfiles=NULL;
    OBJECT_ATTRIBUTES attributes;

    PAGED_CODE ();

    //
    // Make sure we were given a place to put the FriendlyName
    //
    if (!FriendlyName) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If we don't have a handle to IDConfigDB, try to assign a default
    // FriendlyName on the way out.
    //
    if (!IDConfigDB) {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Determine the appropriate message to use, based on the DockState.
    //
    if ((DockingState & HW_PROFILE_DOCKSTATE_UNKNOWN) == HW_PROFILE_DOCKSTATE_UNKNOWN){
        messageId = HARDWARE_PROFILE_UNKNOWN_STRING;
        RtlInitUnicodeString(&labelName, CM_HARDWARE_PROFILE_STR_UNKNOWN);
    } else if (DockingState & HW_PROFILE_DOCKSTATE_DOCKED) {
        messageId = HARDWARE_PROFILE_DOCKED_STRING;
        RtlInitUnicodeString(&labelName, CM_HARDWARE_PROFILE_STR_DOCKED);
    } else if (DockingState & HW_PROFILE_DOCKSTATE_UNDOCKED) {
        messageId = HARDWARE_PROFILE_UNDOCKED_STRING;
        RtlInitUnicodeString(&labelName, CM_HARDWARE_PROFILE_STR_UNDOCKED);
    } else {
        messageId = HARDWARE_PROFILE_UNKNOWN_STRING;
        RtlInitUnicodeString(&labelName, CM_HARDWARE_PROFILE_STR_UNKNOWN);
    }

    //
    // Find the message entry in the kernel's own message table.  KeLoaderBlock
    // is available when we're creating hardware profiles during system
    // initialization only; for profiles created thereafter, use the the first
    // entry of the PsLoadedModuleList to get the image base of the kernel.
    //
    if (KeLoaderBlock) {
        dataTableEntry = CONTAINING_RECORD(KeLoaderBlock->LoadOrderListHead.Flink,
                                           KLDR_DATA_TABLE_ENTRY,
                                           InLoadOrderLinks);
    } else if (PsLoadedModuleList.Flink) {
        dataTableEntry = CONTAINING_RECORD(PsLoadedModuleList.Flink,
                                           KLDR_DATA_TABLE_ENTRY,
                                           InLoadOrderLinks);
    } else {
        status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    status = RtlFindMessage(dataTableEntry->DllBase,
                            (ULONG_PTR)11, // RT_MESSAGETABLE
                            MAKELANGID(LANG_NEUTRAL,SUBLANG_SYS_DEFAULT), // System default language
                            messageId,
                            &messageEntry);

    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if(!(messageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {
        //
        // If the message is not unicode, convert to unicode.
        // Let the conversion routine allocate the buffer.
        //
        RtlInitAnsiString(&ansiString,messageEntry->Text);
        status = RtlAnsiStringToUnicodeString(&unicodeString,&ansiString,TRUE);
    } else {
        //
        // Message is already unicode. Make a copy.
        //
        status = RtlCreateUnicodeString(&unicodeString,(PWSTR)messageEntry->Text);
    }

    if(!NT_SUCCESS(status)) {
        goto Exit;
    }

    //
    // Strip the trailing CRLF.
    //
    if (unicodeString.Length  > 2 * sizeof(WCHAR)) {
        unicodeString.Length -= 2 * sizeof(WCHAR);
        unicodeString.Buffer[unicodeString.Length / sizeof(WCHAR)] = UNICODE_NULL;
    }

    //
    // Check that the size of the label, with any numeric tag that may
    // potentially be added (up to 4 digits, preceded by a space) is not too
    // big.
    //
    if ((unicodeString.Length + 5*sizeof(WCHAR) + sizeof(UNICODE_NULL)) >
        MAX_FRIENDLY_NAME_LENGTH) {
        status = STATUS_UNSUCCESSFUL;
        goto Clean;
    }

    //
    // Open the Hardware Profiles key.
    //
    RtlInitUnicodeString(&keyName, CM_HARDWARE_PROFILE_STR_HARDWARE_PROFILES);
    InitializeObjectAttributes(&attributes,
                               &keyName,
                               OBJ_CASE_INSENSITIVE,
                               IDConfigDB,
                               NULL);
    status = ZwOpenKey(&hardwareProfiles,
                       KEY_READ,
                       &attributes);
    if (!NT_SUCCESS(status)) {
        hardwareProfiles = NULL;
        goto Clean;
    }

    //
    // Retrieve the counter of FriendlyNames we have previously assigned, based
    // on this DockState.
    //
    keyValueInfo = (PKEY_VALUE_FULL_INFORMATION) valueBuffer;
    status = ZwQueryValueKey(hardwareProfiles,
                             &labelName,
                             KeyValueFullInformation,
                             valueBuffer,
                             sizeof(valueBuffer),
                             &length);

    if (NT_SUCCESS(status) && (keyValueInfo->Type == REG_DWORD)) {
        //
        // Increment the counter.
        //
        index = (* (PULONG) ((PUCHAR)keyValueInfo + keyValueInfo->DataOffset));
        index++;
    } else {
        //
        // Missing or invalid counter value; start the counter at "1".
        //
        index = 1;
    }               

    //
    // Update the counter in the registry.
    //
    status = ZwSetValueKey(hardwareProfiles,
                           &labelName,
                           0,
                           REG_DWORD,
                           &index,
                           sizeof(index));
    if (!NT_SUCCESS(status)) {
        goto Clean;
    }

    //
    // Copy the FriendlyName, adding the index if necessary.
    //
    if ((messageId == HARDWARE_PROFILE_UNKNOWN_STRING) || (index > 1)) {
        swprintf(friendlyNameBuffer, L"%s %u",
                 unicodeString.Buffer, index);
    } else {
        wcscpy(friendlyNameBuffer, unicodeString.Buffer);
    }

 Clean:

    RtlFreeUnicodeString(&unicodeString);

    if (hardwareProfiles!=NULL) {
        ZwClose(hardwareProfiles);
    }

 Exit:

    if (!NT_SUCCESS(status)) {
        //
        // If we failed to assign a counter-based FriendlyName for whatever
        // reason, give the new profile a new (not so) friendly name as a last
        // resort.
        //
        swprintf (friendlyNameBuffer, L"%04d", NewProfileNumber);
        status = STATUS_SUCCESS;
    }

    //
    // Create the unicode string to return to the caller.
    //
    if (!RtlCreateUnicodeString(FriendlyName, (PWSTR)friendlyNameBuffer)) {
        status = STATUS_UNSUCCESSFUL;
    }

    return status;

} // CmpCreateHwProfileFriendlyName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hivesync.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivesync.c

Abstract:

    This module implements procedures to write dirty parts of a hive's
    stable store to backing media.

Author:

    Bryan M. Willman (bryanwi) 28-Mar-92

Environment:


Revision History:

--*/

#include    "cmp.h"

#define ONE_K   1024

extern  BOOLEAN HvShutdownComplete;     // Set to true after shutdown
                                        // to disable any further I/O

extern	BOOLEAN CmpDontGrowLogFile;

extern  PUCHAR      CmpStashBuffer;
extern  ULONG       CmpStashBufferSize;
extern  BOOLEAN     CmpFlushOnLockRelease;
extern  LONG        CmRegistryLogSizeLimit;
extern HIVE_LIST_ENTRY CmpMachineHiveList[];

VOID
CmpFreeCmView (
        PCM_VIEW_OF_FILE  CmView
                             );

VOID
CmpUnmapCmViewSurroundingOffset(
        IN  PCMHIVE             CmHive,
        IN  ULONG               FileOffset
        );

VOID
CmpReferenceHiveView(   IN PCMHIVE          CmHive,
                        IN PCM_VIEW_OF_FILE CmView
                     );
VOID
CmpDereferenceHiveView(   IN PCMHIVE          CmHive,
                        IN PCM_VIEW_OF_FILE CmView
                     );

VOID
CmpReferenceHiveViewWithLock(   IN PCMHIVE          CmHive,
                                IN PCM_VIEW_OF_FILE CmView
                            );

VOID
CmpDereferenceHiveViewWithLock(     IN PCMHIVE          CmHive,
                                    IN PCM_VIEW_OF_FILE CmView
                                );

#if DBG
#ifndef _CM_LDR_
#define DumpDirtyVector(BitMap)                                         \
        {                                                               \
            ULONG BitMapSize;                                           \
            PUCHAR BitBuffer;                                           \
            ULONG i;                                                    \
            UCHAR Byte;                                                 \
                                                                        \
            BitMapSize = ((BitMap)->SizeOfBitMap) / 8;                    \
            BitBuffer = (PUCHAR)((BitMap)->Buffer);                       \
            for (i = 0; i < BitMapSize; i++) {                          \
                if ((i % 8) == 0) {                                     \
                    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"\n\t");                                  \
                }                                                       \
                Byte = BitBuffer[i];                                    \
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"%02x ", Byte);                               \
            }                                                           \
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"\n");                                            \
        }
#endif //_CM_LDR_
#else
#define DumpDirtyVector(BitMap)
#endif

//
// Private prototypes
//

BOOLEAN
HvpFindNextDirtyBlock(
    PHHIVE          Hive,
    PRTL_BITMAP     BitMap,
    PULONG          Current,
    PUCHAR          *Address,
    PULONG          Length,
    PULONG          Offset
    );

/*
VOID
HvpDiscardBins(
    PHHIVE  Hive
    );
*/


VOID
HvpTruncateBins(
    PHHIVE  Hive
    );

VOID
HvRefreshHive(
    PHHIVE  Hive
    );

VOID
HvpFlushMappedData(
    IN PHHIVE           Hive,
    IN OUT PRTL_BITMAP  DirtyVector
    );

VOID
CmpUnmapCmView(
    IN PCMHIVE              CmHive,
    IN PCM_VIEW_OF_FILE     CmView,
    IN BOOLEAN              MapIsValid,
    IN BOOLEAN              MoveToEnd
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvMarkCellDirty)

#if DBG
#pragma alloc_text(PAGE,HvIsCellDirty)
#endif //DBG

#pragma alloc_text(PAGE,HvMarkDirty)
//#pragma alloc_text(PAGE,HvMarkClean)
#pragma alloc_text(PAGE,HvpGrowLog1)
#pragma alloc_text(PAGE,HvpGrowLog2)
#pragma alloc_text(PAGE,HvSyncHive)
#pragma alloc_text(PAGE,HvpDoWriteHive)
#pragma alloc_text(PAGE,HvpWriteLog)
#pragma alloc_text(PAGE,HvpFindNextDirtyBlock)
#pragma alloc_text(PAGE,HvWriteHive)
#pragma alloc_text(PAGE,HvRefreshHive)
//#pragma alloc_text(PAGE,HvpDiscardBins)
#pragma alloc_text(PAGE,HvHiveWillShrink)
#pragma alloc_text(PAGE,HvpTruncateBins)
#pragma alloc_text(PAGE,HvpDropPagedBins)
#pragma alloc_text(PAGE,HvpDropAllPagedBins)
#pragma alloc_text(PAGE,HvpFlushMappedData)

#ifdef WRITE_PROTECTED_REGISTRY_POOL
#pragma alloc_text(PAGE,HvpChangeBinAllocation)
#pragma alloc_text(PAGE,HvpMarkBinReadWrite)
#endif //WRITE_PROTECTED_REGISTRY_POOL


#ifdef CM_ENABLE_WRITE_ONLY_BINS

//
// This code uses MmProtectSpecialPool to protect large paged-pool allocations.
// To do so, the system must be booted with special pool enabled (doesn't have
// to actually get used) *AND* ntos\mm\specpool.c must be compiled with
// _PROTECT_PAGED_POOL defined.
//

#pragma alloc_text(PAGE,HvpMarkAllBinsWriteOnly)
#endif //CM_ENABLE_WRITE_ONLY_BINS

#endif

BOOLEAN
HvMarkCellDirty(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Marks the data for the specified cell dirty.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - hcell_index of cell that is being edited

Return Value:

    TRUE - it worked

    FALSE - could not allocate log space, failure!

--*/
{
    ULONG       Type;
    ULONG       Size;
    PHCELL      pCell;
    PHMAP_ENTRY Me;
    HCELL_INDEX Base;
    PHBIN       Bin;
    PCMHIVE     CmHive;
#if DBG
    ULONG       DirtyCount = RtlNumberOfSetBits(&Hive->DirtyVector);
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvMarkCellDirty:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Cell:%08lx\n", Hive, Cell));

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(DirtyCount == Hive->DirtyCount);

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    //ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    Type = HvGetCellType(Cell);
    CmHive = (PCMHIVE)Hive;

    if ( (Hive->HiveFlags & HIVE_VOLATILE) ||
         (Type == Volatile) )
    {
        return TRUE;
    }

    //
    // this call will make sure the view containing the bin is maped in the system cache
    //
    pCell = HvpGetHCell(Hive,Cell);
    if( pCell == NULL ) {
        //
        // we couldn't map view for this cell
        // we will fail to make the cell dirty.
        //
        return FALSE;
    }
    
    // release the cell here as the reglock is held exclusive
    HvReleaseCell(Hive,Cell);

    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);
#if DBG
    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
    ASSERT(Bin->Signature == HBIN_SIGNATURE);
#endif

    if( Me->BinAddress & HMAP_INVIEW ) {
        //
        // bin is mapped. Pin the view into memory
        //
        ASSERT( Me->CmView != NULL );

        if( IsListEmpty(&(Me->CmView->PinViewList)) == TRUE ) {
            //
            // the view is not already pinned.  pin it
            //
            ASSERT_VIEW_MAPPED( Me->CmView );
            if( !NT_SUCCESS(CmpPinCmView ((PCMHIVE)CmHive,Me->CmView)) ) {
                //
                // couldn't pin view- some obscure error down in CcPinMappedData;
                // this will be treated as STATUS_NO_LOG_SPACE
                //
                return FALSE;
            }
        } else {
            //
            // view is already pinned; do nothing
            //
            ASSERT_VIEW_PINNED( Me->CmView );
        }
    }

    //
    // If it's an old format hive, mark the entire
    // bin dirty, because the Last backpointers are
    // such a pain to deal with in the partial
    // alloc and free-coalescing cases.
    //

    if (USE_OLD_CELL(Hive)) {
        Me = HvpGetCellMap(Hive, Cell);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);
        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
        Base = Bin->FileOffset;
        Size = Bin->Size;
        return HvMarkDirty(Hive, Base, Size,FALSE);
    } else {
        if (pCell->Size < 0) {
            Size = -pCell->Size;
        } else {
            Size = pCell->Size;
        }
        ASSERT(Size < Bin->Size);
        return HvMarkDirty(Hive, Cell-FIELD_OFFSET(HCELL,u.NewCell), Size,FALSE);
    }
}

BOOLEAN
HvMarkDirty(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    ULONG       Length,
    BOOLEAN     DirtyAndPin
    )
/*++

Routine Description:

    Marks the relevent parts of a hive dirty, so that they will
    be flushed to backing store.

    If Hive->Cluster is not 1, then adjacent all logical sectors
    in the given cluster will be forced dirty (and log space
    allocated for them.)  This must be done here rather than in
    HvSyncHive so that we can know how much to grow the log.

    This is a noop for Volatile address range.

    NOTE:   Range will not be marked dirty if operation fails.

    ATTENTION:  This routine assumes that no more than a bin is marked 
                dirty at the time.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Start - supplies a hive virtual address (i.e., an HCELL_INDEX or
             like form address) of the start of the area to mark dirty.

    Length - inclusive length in bytes of area to mark dirty.

    DirtyAndPin - indicates whether we should also pin the bin marked as dirty in memory


Return Value:

    TRUE - it worked

    FALSE - could not allocate log space, failure!

--*/
{
    ULONG       Type;
    PRTL_BITMAP BitMap;
    ULONG       First;
    ULONG       Last;
    ULONG       EndOfFile;
    ULONG       i;
    ULONG       Cluster;
    ULONG       OriginalDirtyCount;
    ULONG       DirtySectors;
    BOOLEAN     Result = TRUE;
    PHMAP_ENTRY Map;
    ULONG       AdjustedFirst;
    ULONG       AdjustedLast;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvMarkDirty:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Start:%08lx Length:%08lx\n", Hive, Start, Length));


    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    Type = HvGetCellType(Start);

    if ( (Hive->HiveFlags & HIVE_VOLATILE) ||
         (Type == Volatile) )
    {
        return TRUE;
    }


    BitMap = &(Hive->DirtyVector);
    OriginalDirtyCount = Hive->DirtyCount;

    if( (DirtyAndPin == TRUE) && (((PCMHIVE)Hive)->FileObject != NULL) ) {
        Map = HvpGetCellMap(Hive, Start);
        VALIDATE_CELL_MAP(__LINE__,Map,Hive,Start);


        if( (Map->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0){
            PCM_VIEW_OF_FILE CmView;
            //
            // bin is neither in paged pool, nor in a mapped view
            //
            if( !NT_SUCCESS (CmpMapCmView((PCMHIVE)Hive,Start,&CmView,TRUE) ) ) {
                return FALSE;
            }
            
#if DBG            
            if(CmView != Map->CmView) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmView = %p Map->CmView = %p\n",CmView,Map->CmView));
            }
#endif
            ASSERT( CmView == Map->CmView );
            
        }

        if( Map->BinAddress & HMAP_INVIEW ) {
            //
            // bin is mapped. Pin the view into memory
            //
            ASSERT( Map->CmView != NULL );

            if( IsListEmpty(&(Map->CmView->PinViewList)) == TRUE ) {
                //
                // the view is not already pinned.  pin it
                //
                ASSERT_VIEW_MAPPED( Map->CmView );
                if( !NT_SUCCESS(CmpPinCmView ((PCMHIVE)Hive,Map->CmView)) ) {
                    //
                    // couldn't pin view- some obscure error down in CcPinMappedData;
                    // this will be treated as STATUS_NO_LOG_SPACE
                    //
                    return FALSE;
                }
            } else {
                //
                // view is already pinned; do nothing
                //
                ASSERT_VIEW_PINNED( Map->CmView );
            }
        }

    }

    AdjustedFirst = First = Start / HSECTOR_SIZE;
    AdjustedLast = Last = (Start + Length - 1) / HSECTOR_SIZE;

    Cluster = Hive->Cluster;
    if (Cluster > 1) {

        //
        // Force Start down to base of cluster
        // Force End up to top of cluster
        //
        AdjustedFirst = AdjustedFirst & ~(Cluster - 1);
        AdjustedLast = ROUND_UP(AdjustedLast+1, Cluster) - 1;
    }

    //
    // we need to mark all page(s) dirty, so we don't conflict with cache manager
    //
    ASSERT( PAGE_SIZE >= HSECTOR_SIZE );
    ASSERT( (PAGE_SIZE % HSECTOR_SIZE) == 0 );
    
    //
    // adjust the range to fit an entire page
    // make sure we account for the first HBLOCK at the beggining of the hive
    //
    AdjustedFirst = (AdjustedFirst + HSECTOR_COUNT) & ~(HSECTOR_PER_PAGE_COUNT - 1);
    AdjustedLast = ROUND_UP(AdjustedLast + HSECTOR_COUNT + 1, HSECTOR_PER_PAGE_COUNT) - 1;
    
    AdjustedLast -= HSECTOR_COUNT;
    if( AdjustedFirst ) {
        AdjustedFirst -= HSECTOR_COUNT;
    }
    //
    // when the PAGE_SIZE > HBLOCK_SIZE and the length of the hive does not round at PAGE_SIZE boundary
    //
    EndOfFile = Hive->Storage[Stable].Length / HSECTOR_SIZE;
    if (AdjustedLast >= EndOfFile) {
        AdjustedLast = EndOfFile-1;
    }

    //
    // make sure that between first and last all bins are valid (either pinned
    // or allocated from paged pool). Case hit on John's IA64 machine on 
    // Feb 18 2000, when at the previous save a bin (at offset 3ff000 and size 0x2000)
    // was dropped, then some new bins were added, and the whole 400000 - 402000 region
    // was marked dirty (PAGE_SIZE == 0x2000), remember?
    //
    ASSERT( First >= AdjustedFirst );
    ASSERT( Last <= AdjustedLast );

    //CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"HvMarkDirty - First = %08lx, Last = %08lx  ",First,Last));
    
    //
    // adjust First and Last at HBLOCK_SIZE boundaries
    //
    First = First & ~(HSECTOR_COUNT - 1);
    Last = ROUND_UP(Last+1, HSECTOR_COUNT) - 1;

    //
    // sanity asserts; these prove we can skip HSECTOR_COUNT at one time bellow 
    //
    ASSERT( First >= AdjustedFirst );
    ASSERT( Last <= AdjustedLast );
    ASSERT( (First % HSECTOR_COUNT) == 0 );
    ASSERT( (AdjustedFirst % HSECTOR_COUNT) == 0 );
    ASSERT( ((Last+1) % HSECTOR_COUNT) == 0 );
    ASSERT( ((AdjustedLast +1) % HSECTOR_COUNT) == 0 );
    ASSERT( ((First - AdjustedFirst) % HSECTOR_COUNT) == 0 );
    ASSERT( ((AdjustedLast - Last) % HSECTOR_COUNT) == 0 );

    //
    // when we exit this loop; First is always a valid bin/sector
    //
    while( First > AdjustedFirst ) {
        //
        // map-in this address, and if is valid, decrement First, else break out of the loop
        //
        First -= HSECTOR_COUNT;
        Map = HvpGetCellMap(Hive, First*HSECTOR_SIZE);
        if( BIN_MAP_ALLOCATION_TYPE(Map) == 0 ) {
            //
            // oops this bin is not valid ! bail out !
            //
            First += HSECTOR_COUNT;
            break;
        }
        if( Map->BinAddress & HMAP_INVIEW ) {
            //
            // previous bin mapped in view ==> view needs to be pinned
            //
            ASSERT( Map->CmView );
            if( IsListEmpty(&(Map->CmView->PinViewList) ) == TRUE ) {
                //
                // oops; bin not pinned; bail out;
                //
                First += HSECTOR_COUNT;
                break;
            }
        }
    }

    //
    // when we exit this loop; Last is always a valid bin/sector
    //
    while( Last < AdjustedLast ) {
        //
        // map-in this address, and if is valid, increment Last, else break out of the loop
        //
        Last += HSECTOR_COUNT;
        Map = HvpGetCellMap(Hive, Last*HSECTOR_SIZE);
        if( BIN_MAP_ALLOCATION_TYPE(Map) == 0 ) {
            //
            // oops this bin is not valid ! bail out !
            //
            Last -= HSECTOR_COUNT;
            break;
        }
        if( Map->BinAddress & HMAP_INVIEW ) {
            //
            // previous bin mapped in view ==> view needs to be pinned
            //
            ASSERT( Map->CmView );
            if( IsListEmpty(&(Map->CmView->PinViewList) ) == TRUE ) {
                //
                // oops; bin not pinned; bail out;
                //
                Last -= HSECTOR_COUNT;
                break;
            }
        }
    }

    //CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL," Adjusted : First = %08lx, Last = %08lx\n",First,Last));

    //
    // Try and grow the log enough to accomodate all the dirty sectors.
    //
    DirtySectors = 0;
    for (i = First; i <= Last; i++) {
        if (RtlCheckBit(BitMap, i)==0) {
            ++DirtySectors;
        }
    }
    if (DirtySectors != 0) {
        if (HvpGrowLog1(Hive, DirtySectors) == FALSE) {
            return(FALSE);
        }
    
        if ((OriginalDirtyCount == 0) && (First != 0)) {
            Result = HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
            if (Result==FALSE) {
                return(FALSE);
            }
        }
    
        //
        // Log has been successfully grown, go ahead
        // and set the dirty bits.
        //
        ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
        ASSERT( First <= Last );
        if( First <= Last ) {
            Hive->DirtyCount += DirtySectors;
            RtlSetBits(BitMap, First, Last-First+1);
        }
    }

#ifdef CM_ENABLE_WRITE_ONLY_BINS
    {
        PHMAP_ENTRY t;
        PHBIN       Bin;
        ULONG       i;
        
        t = HvpGetCellMap(Hive, First*HSECTOR_SIZE);
        VALIDATE_CELL_MAP(__LINE__,t,Hive,First*HSECTOR_SIZE);
        Bin = (PHBIN)HBIN_BASE(t->BinAddress);
        if( t->BinAddress & HMAP_INPAGEDPOOL ) {
                        PFREE_HBIN      FreeBin;
                        BOOLEAN         SetReadWrite = TRUE;
                        
                        // get the free_bin and see if it's still around. if not forget about it.
                        if(t->BinAddress & HMAP_DISCARDABLE) {
                FreeBin = (PFREE_HBIN)t->BlockAddress;
                                //if(! ( FreeBin->Flags & FREE_HBIN_DISCARDABLE ) ) {
                                        SetReadWrite = FALSE;
                                //}
                                
                        }

            //
            // at this point we only work with paged pool bins
            //
            if( SetReadWrite == TRUE ) {
                                for( i=0;i<(Last-First+1)*HSECTOR_SIZE;i += PAGE_SIZE ) {
                                        if( !MmProtectSpecialPool((PUCHAR)Bin + i + First*HSECTOR_SIZE - Bin->FileOffset,PAGE_READWRITE) ) {
                                                DbgPrint("Failed to set PAGE_READWRITE protection on page at %p Bin %p size = %lx\n",Bin+i,Bin,(Last-First+1)*HSECTOR_SIZE);
                                        }
                                }
                        }
/*
            if( !MmSetPageProtection(Bin,DirtySectors*HSECTOR_SIZE,PAGE_READWRITE) ) {
                DbgPrint("Failed to set READWRITE protection on bin at %p, size = %lx\n",Bin,DirtySectors*HSECTOR_SIZE);
            }
*/
        }
    
    }
#endif CM_ENABLE_WRITE_ONLY_BINS

    // mark this bin as writable
    HvpMarkBinReadWrite(Hive,Start);
        
    if (!(Hive->HiveFlags & HIVE_NOLAZYFLUSH)) {
        CmpLazyFlush();
    }

    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
    return(TRUE);
}

BOOLEAN
HvpGrowLog1(
    PHHIVE  Hive,
    ULONG   Count
    )
/*++

Routine Description:

    Adjust the log for growth in the number of sectors of dirty
    data that are desired.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Count - number of additional logical sectors of log space needed

Return Value:

    TRUE - it worked

    FALSE - could not allocate log space, failure!

--*/
{
    ULONG   ClusterSize;
    ULONG   RequiredSize;
    ULONG   tmp;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpGrowLog1:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Count:%08lx\n", Hive, Count));

    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    //
    // If logging is off, tell caller world is OK.
    //
    if( (Hive->Log == FALSE) || CmpDontGrowLogFile) {
        return TRUE;
    }

    ClusterSize = Hive->Cluster * HSECTOR_SIZE;

    tmp = Hive->DirtyVector.SizeOfBitMap / 8;   // bytes
    tmp += sizeof(ULONG);                       // signature

    RequiredSize =
        ClusterSize  +                                  // 1 cluster for header
        ROUND_UP(tmp, ClusterSize) +
        ((Hive->DirtyCount + Count) * HSECTOR_SIZE);

    RequiredSize = ROUND_UP(RequiredSize, HLOG_GROW);

    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
	
    if ( ! (Hive->FileSetSize)(Hive, HFILE_TYPE_LOG, RequiredSize,Hive->LogSize)) {
        return FALSE;
    }

    if( CmRegistryLogSizeLimit > 0 ) {
        //
        // see if log is too big and set flush on lock release
        //
        ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

        if( RequiredSize >= (ULONG)(CmRegistryLogSizeLimit * ONE_K) ) {
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"LogFile for hive %p is %lx; will flush upon lock release\n",Hive,RequiredSize);
            CmpFlushOnLockRelease = TRUE;
        }
    }

    Hive->LogSize = RequiredSize;
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
    return TRUE;
}

VOID
HvRefreshHive(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Undo the last sync.  
    
    The story behind the scene:

    1. remove all discardable bins from FreeBins list. they'll be 
        enlisted afterwards with the right (accurate) values.
    2. read the base block, and eventually free the tail of the hive
    3. unpin and purge all pinned views; also clear the free cell
        hint for mapped bins.
    4. remap views purged at 3 and reenlist the bins inside. this 
        will fix free bins discarded at 1.
    5. iterate through the map; read and reenlist all bins that are 
        in paged-pool (and dirty)

      
    All I/O is done via HFILE_TYPE_PRIMARY.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest.

Return Value:

    NONE. Either works or BugChecks.

Comments:

    In the new implementation, bins are not discarded anymore. Step 1.
    above is not needed anymore.
    
    Discardable bins with FREE_HBIN_DISCARDABLE flag set fall into one 
    of the categories:
    1. new bins (at the end of the hive) which didn't get a chance to 
    be saved yet. HvFreeHivePartial will take care of them.
    2. bins inside the hive allocated from paged pool and discarded.
    This can only happen for bins that are crossing the CM_VIEW_SIZE boundary.
    We will take care of them at step 5

    Discardable bins with FREE_HBIN_DISCARDABLE flag NOT set are free bins
    which came from mapped views. Step 3 will remove them from the FreeBins 
    list and step 4 will reenlist the ones that are still free after remapping

--*/
{
    HCELL_INDEX         RootCell;
    PCM_KEY_NODE        RootNode;
    HCELL_INDEX         LinkCell;
    PLIST_ENTRY         List;
    PFREE_HBIN          FreeBin;
    ULONG               Offset;
    ULONG               FileOffset;
    HCELL_INDEX         TailStart;
    ULONG               Start;
    ULONG               End;
    ULONG               BitLength;
    PCM_VIEW_OF_FILE    CmView;
    PCMHIVE             CmHive;
    ULONG               FileOffsetStart;
    ULONG               FileOffsetEnd;
    PHMAP_ENTRY         Me;
    ULONG               i;
    PHBIN               Bin;
    ULONG               BinSize;
    ULONG               Current;
    PRTL_BITMAP         BitMap;
    PUCHAR              Address;
    BOOLEAN             rc;
    ULONG               ReadLength;
    HCELL_INDEX         p;
    PHMAP_ENTRY         t;
    ULONG               checkstatus;
    ULONG               OldFileLength;
    LIST_ENTRY          PinViewListHead;
    ULONG               Size;
    LARGE_INTEGER       PurgeOffset;
    
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // noop or assert on various uninteresting or bogus conditions
    //
    if (Hive->DirtyCount == 0) {
        return;
    }
    ASSERT(Hive->HiveFlags & HIVE_NOLAZYFLUSH);
    ASSERT(Hive->Storage[Volatile].Length == 0);

    //
    // be sure the hive is not already trash
    //
    checkstatus = HvCheckHive(Hive, NULL);
    if (checkstatus != 0) {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,1,Hive,checkstatus);
    }

    // store it for the shrink/grow at the end.
    OldFileLength = Hive->Storage[Stable].Length + HBLOCK_SIZE;
    //
    // Capture the LinkCell backpointer in the hive's root cell. We need this in case
    // the first bin is overwritten with what was on disk.
    //
    RootCell = Hive->BaseBlock->RootCell;
    RootNode = (PCM_KEY_NODE)HvGetCell(Hive, RootCell);
    if( RootNode == NULL ) {
        //
        // we couldn't map a view for this cell
        // we're low on resources, so we couldn't refresh the hive.
        //
        return;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,RootCell);

    LinkCell = RootNode->Parent;

    Hive->RefreshCount++;    


    // 
    // 1. Remove all discardable bins from FreeBins list
    //    - remove the discardable flag from the ones that 
    //      have not yet been discarded 
    //    - for discarded ones, just remove the marker from 
    //      the FreeBins list            
    //
    //

    // Any bins that have been marked as discardable, but not yet flushed to
    // disk, are going to be overwritten with old data.  Bring them back into
    // memory and remove their FREE_HBIN marker from the list. Other bins are 
    // either discarded, or mapped into views
    //
/*

  DRAGOS: This is not needed anymore (see Comments)

    List = Hive->Storage[Stable].FreeBins.Flink;
    while (List != &Hive->Storage[Stable].FreeBins) {

        FreeBin = CONTAINING_RECORD(List, FREE_HBIN, ListEntry);
        List = List->Flink;

        if (FreeBin->Flags & FREE_HBIN_DISCARDABLE) {
            for (i=0; i<FreeBin->Size; i+=HBLOCK_SIZE) {
                Me = HvpGetCellMap(Hive, FreeBin->FileOffset+i);
                VALIDATE_CELL_MAP(__LINE__,Me,Hive,FreeBin->FileOffset+i);
                Me->BlockAddress = HBIN_BASE(Me->BinAddress)+i;
                Me->BinAddress &= ~HMAP_DISCARDABLE;
            }
            RemoveEntryList(&FreeBin->ListEntry);
            (Hive->Free)(FreeBin, sizeof(FREE_HBIN));
        }
    }
*/
    //
    // 2. read the base block, and eventually free the tail of the hive
    //

    //
    // OverRead base block.
    //
    Offset = 0;
    if ( (Hive->FileRead)(
            Hive,
            HFILE_TYPE_PRIMARY,
            &Offset,
            Hive->BaseBlock,
            HBLOCK_SIZE
            ) != TRUE)
    {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,2,Hive,Offset);
    }
    TailStart = (HCELL_INDEX)(Hive->BaseBlock->Length);

    //
    // Free "tail" memory and maps for it, update hive size pointers
    //
    HvFreeHivePartial(Hive, TailStart, Stable);

    //
    // Clear dirty vector for data past Hive->BaseBlock->Length
    //
    Start = Hive->BaseBlock->Length / HSECTOR_SIZE;
    End = Hive->DirtyVector.SizeOfBitMap;
    BitLength = End - Start;

    RtlClearBits(&(Hive->DirtyVector), Start, BitLength);

    HvpAdjustHiveFreeDisplay(Hive,Hive->Storage[Stable].Length,Stable);
    

    //
    // 3. unpin and purge all pinned views; also clear the free cell
    //  hint for mapped bins.
    //
    CmHive = (PCMHIVE)Hive;

    InitializeListHead(&PinViewListHead);
    //
    // for each pinned view
    //
    while(IsListEmpty(&(CmHive->PinViewListHead)) == FALSE) {
        //
        // Remove the first view from the pin view list
        //
        CmView = (PCM_VIEW_OF_FILE)RemoveHeadList(&(CmHive->PinViewListHead));
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);
        
        //
        // the real file offset starts after the header
        // 
        FileOffsetStart = CmView->FileOffset;
        FileOffsetEnd = FileOffsetStart + CmView->Size;
        
        FileOffsetEnd -= HBLOCK_SIZE;

        if( FileOffsetStart != 0 ) {
            //
            // just at the begining of the file, subtract the header
            //
            FileOffsetStart -= HBLOCK_SIZE;
        } 
        
        FileOffset = FileOffsetStart;
        //
        // now, for every block in this range which is mapped in view
        // clear the dirty bit, and the free cell hint
        //
        while(FileOffset < FileOffsetEnd) {
            Me = HvpGetCellMap(Hive, FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileOffset);
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            //
            // ignore the bins loaded into paged pool; we'll deal with them later on
            //
            if( Me->BinAddress & HMAP_INVIEW ) {
                if( Me->BinAddress & HMAP_DISCARDABLE ) {
                    FreeBin = (PFREE_HBIN)Me->BlockAddress;
                    
                    // free bins comming from mapped views are not discardable
                    ASSERT( (FreeBin->Flags & FREE_HBIN_DISCARDABLE) == 0 );

                    //
                    // go and clear the discardable flag for all blocks of this bin
                    //
                    for( i=FileOffset;i<FileOffset+FreeBin->Size;i+=HBLOCK_SIZE) {
                        Me = HvpGetCellMap(Hive, i);
                        VALIDATE_CELL_MAP(__LINE__,Me,Hive,i);
                        Me->BinAddress &= ~HMAP_DISCARDABLE;
                    }
                    //
                    // get rid of the entry from FreeBins list
                    // it'll be added again after sync is done if bin is still 
                    // discardable
                    //
                    FreeBin = (PFREE_HBIN)Me->BlockAddress;
                    ASSERT(FreeBin->FileOffset == FileOffset);
                    RemoveEntryList(&FreeBin->ListEntry);
                    BinSize = FreeBin->Size;

                    (Hive->Free)(FreeBin, sizeof(FREE_HBIN));
                } else {
                    //
                    // bin is mapped in view. Then, this should be the beggining of the bin
                    //
                    ASSERT(Bin->Signature == HBIN_SIGNATURE);
                    ASSERT(Bin->FileOffset == FileOffset);


                    BinSize = Bin->Size;
                }
                //
                // clear of the dirty bits for this bin
                //
                RtlClearBits(&Hive->DirtyVector,FileOffset/HSECTOR_SIZE,BinSize/HSECTOR_SIZE);

                //
                // now clear the free cell hint for this bin
                //
                for( i=0;i<HHIVE_FREE_DISPLAY_SIZE;i++) {
    
                    RtlClearBits (&(Hive->Storage[Stable].FreeDisplay[i]), FileOffset / HBLOCK_SIZE, BinSize / HBLOCK_SIZE);

                    if( RtlNumberOfSetBits(&(Hive->Storage[Stable].FreeDisplay[i]) ) != 0 ) {
                        //
                        // there are still some other free cells of this size
                        //
                        Hive->Storage[Stable].FreeSummary |= (1 << i);
                    } else {
                        //
                        // entire bitmap is 0 (i.e. no other free cells of this size)
                        //
                        Hive->Storage[Stable].FreeSummary &= (~(1 << i));
                    }
                }
            } else {
                //
                // bin in paged pool
                //
                ASSERT( Me->BinAddress & HMAP_INPAGEDPOOL );
                if( Me->BinAddress & HMAP_DISCARDABLE ) {

                    FreeBin = (PFREE_HBIN)Me->BlockAddress;
                    ASSERT(FreeBin->FileOffset == FileOffset);
                    BinSize = FreeBin->Size;
                } else {
                    //
                    // Then, this should be the beggining of the bin
                    //
                    ASSERT(Bin->Signature == HBIN_SIGNATURE);
                    ASSERT(Bin->FileOffset == FileOffset);

                    BinSize = Bin->Size;
                }
            }

            FileOffset += BinSize;

        }// while (FileOffset<FileOffsetEnd)
        
        //
        // Just unmap the view, without marking the data dirty; We'll flush cache after we finish 
        // unpinning and unmapping all neccessary views
        //
        ASSERT( CmView->UseCount == 0 );

        // store this for later
        FileOffset = CmView->FileOffset;
        Size = CmView->Size;

        CmpUnmapCmView (CmHive,CmView,TRUE,TRUE);

        //
        // we use the PinViewList member of these views to keep track of all pinned 
        // views that need to be remapped after the purge
        //
        InsertTailList(
            &PinViewListHead,
            &(CmView->PinViewList)
            );
        //
        // remove the view from the LRU list
        //
        RemoveEntryList(&(CmView->LRUViewList));
        //
        // store the FileOffset and address so we know what to map afterwards
        //
        CmView->FileOffset = FileOffset;
        CmView->Size = Size;
        //
        // now we need to make sure the 256K window surrounding this offset is not 
        // mapped in any way
        //
        FileOffset = FileOffset & (~(_256K - 1));
        Size = FileOffset + _256K;
        Size = (Size > OldFileLength)?OldFileLength:Size;
        //
        // we are not allowed to purge in shared mode.
        //

        while( FileOffset < Size ) {
            CmpUnmapCmViewSurroundingOffset((PCMHIVE)Hive,FileOffset);
            FileOffset += CM_VIEW_SIZE;
        }

    }// while IsListEmpty(&(CmHive->PinViewListHead))

    //
    // Now we need to purge the the previously pinned views
    //
    PurgeOffset.HighPart = 0;
    CmView = (PCM_VIEW_OF_FILE)PinViewListHead.Flink;
    while( CmHive->PinnedViews ) {
        ASSERT( CmView != (PCM_VIEW_OF_FILE)(&(PinViewListHead)) );

        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);
        //
        // now purge as a private writer
        //
        PurgeOffset.LowPart = CmView->FileOffset;
        CcPurgeCacheSection(CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)(&PurgeOffset)) + 1)/*we are private writers*/,
                                    CmView->Size,FALSE);
        //
        // advance to the next view
        //
        CmView = (PCM_VIEW_OF_FILE)(CmView->PinViewList.Flink);
        CmHive->PinnedViews--;
    }
    
    ASSERT( ((PCMHIVE)CmHive)->PinnedViews == 0 );

    //
    // 4.remap views purged at 3 and reenlist the bins inside. this 
    // will fix free bins discarded at 1.
    //
    while(IsListEmpty(&PinViewListHead) == FALSE) {
        //
        // Remove the first view from the pin view list
        //
        CmView = (PCM_VIEW_OF_FILE)RemoveHeadList(&PinViewListHead);
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);
        
        //
        // the real file offset starts after the header
        // 
        FileOffsetStart = CmView->FileOffset;
        FileOffsetEnd = FileOffsetStart + CmView->Size;
        
        FileOffsetEnd -= HBLOCK_SIZE;

        if( FileOffsetStart != 0 ) {
            //
            // just at the begining of the file, subtract the header
            //
            FileOffsetStart -= HBLOCK_SIZE;
        } 
        if( FileOffsetEnd > Hive->BaseBlock->Length ) {
            FileOffsetEnd = Hive->BaseBlock->Length;
        }
        //
        // be sure to free this view as nobody is using it anymore
        //
#if DBG
        CmView->FileOffset = CmView->Size = 0;
        InitializeListHead(&(CmView->PinViewList));
        InitializeListHead(&(CmView->LRUViewList));
#endif
        CmpFreeCmView (CmView);

        if( FileOffsetStart >= FileOffsetEnd ) {
            continue;
        }
        //
        // remap it with the right data
        //
        if( !NT_SUCCESS(CmpMapCmView(CmHive,FileOffsetStart,&CmView,TRUE) ) ) {
            //
            // this is bad. We have altered the hive and now we have no way of restoring it
            // bugcheck!
            //
            CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,3,CmHive,FileOffsetStart);
        }

        //
        // touch the view
        //
        CmpTouchView((PCMHIVE)Hive,CmView,FileOffsetStart);

        FileOffset = FileOffsetStart;

        while(FileOffset < FileOffsetEnd) {
            Me = HvpGetCellMap(Hive, FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileOffset);
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            
            //
            // ignore paged bins
            //
            if( Me->BinAddress & HMAP_INVIEW ) {
                ASSERT(Bin->Signature == HBIN_SIGNATURE);
                ASSERT(Bin->FileOffset == FileOffset);

                // enlisting freecells will fix the free bins problem too
                if ( ! HvpEnlistFreeCells(Hive, Bin, Bin->FileOffset) ) {
                    CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,4,Bin,Bin->FileOffset);
                }
                FileOffset += Bin->Size;
            } else {
                FileOffset += HBLOCK_SIZE;            
            }
        }

    } // while (IsListEmpty(&PinViewListHead))
    
    // 5. iterate through the map; read and reenlist all bins that are 
    //   in paged-pool (and dirty)

    //
    // Scan dirty blocks.  Read contiguous blocks off disk into hive.
    // Stop when we get to reduced length.
    //
    BitMap = &(Hive->DirtyVector);
    Current = 0;
    while (HvpFindNextDirtyBlock(
                Hive,
                &Hive->DirtyVector,
                &Current, &Address,
                &ReadLength,
                &Offset
                ))
    {
        ASSERT(Offset < (Hive->BaseBlock->Length + sizeof(HBASE_BLOCK)));
        rc = (Hive->FileRead)(
                Hive,
                HFILE_TYPE_PRIMARY,
                &Offset,
                (PVOID)Address,
                ReadLength
                );
        if (rc == FALSE) {
            CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,5,Offset,Address);
        }
    }

    //
    // If we read the start of any HBINs into memory, it is likely
    // their MemAlloc fields are invalid.  Walk through the HBINs
    // and write valid MemAlloc values for any HBINs whose first
    // sector was reread.
    //
    // HvpFindNextDirtyBlock knows how to deal with free bins. If we 
    // reread a free bin, we need to delist it from the list first and 
    // reenlist it again (it may not be free on the disk)
    //

    p=0;
    while (p < Hive->Storage[Stable].Length) {
        t = HvpGetCellMap(Hive, p);
        VALIDATE_CELL_MAP(__LINE__,t,Hive,p);
        Bin = (PHBIN)HBIN_BASE(t->BlockAddress);

        if (RtlCheckBit(&Hive->DirtyVector, p / HSECTOR_SIZE)==1) {
        
            if ((t->BinAddress & HMAP_DISCARDABLE) != 0) {
                //
                // this was a free bin. It may not be a free bin on the disk
                //
                FreeBin = (PFREE_HBIN)t->BlockAddress;

                // free bins comming from paged pool are always discardable
                ASSERT( FreeBin->Flags & FREE_HBIN_DISCARDABLE );

                // if the bin has been discarded since the last save, all bin should be dirty!!!
                ASSERT(FreeBin->FileOffset == p);

                //
                // go and clear the discardable flag for all blocks of this bin
                //
                for( i=0;i<FreeBin->Size;i+=HBLOCK_SIZE) {
                    Me = HvpGetCellMap(Hive, p + i);
                    VALIDATE_CELL_MAP(__LINE__,Me,Hive,p+i);
                    Me->BlockAddress = HBIN_BASE(Me->BinAddress)+i;
                    Me->BinAddress &= ~HMAP_DISCARDABLE;
                }
                Bin = (PHBIN)HBIN_BASE(t->BlockAddress);
                //
                // get rid of the entry from FreeBins list
                // it'll be added again after sync is done if bin is still 
                // discardable
                //
                RemoveEntryList(&FreeBin->ListEntry);
                (Hive->Free)(FreeBin, sizeof(FREE_HBIN));

            }
            //
            // only paged bins should be dirty at this time
            //
            ASSERT( t->BinAddress & HMAP_INPAGEDPOOL );

            //
            // The first sector in the HBIN is dirty.
            //
            // Reset the BinAddress to the Block address to cover
            // the case where a few smaller bins have been coalesced
            // into a larger bin. We want the smaller bins back now.
            //
            t->BinAddress = HBIN_FLAGS(t->BinAddress) | t->BlockAddress;

            // Check the map to see if this is the start
            // of a memory allocation or not.
            //

            if (t->BinAddress & HMAP_NEWALLOC) {
                //
                // Walk through the map to determine the length
                // of the allocation.
                //
                PULONG BinAlloc = &(t->MemAlloc);
                *BinAlloc = 0;

                do {
                    t = HvpGetCellMap(Hive, p + (*BinAlloc) + HBLOCK_SIZE);
                    (*BinAlloc) += HBLOCK_SIZE;
                    if (p + (*BinAlloc) == Hive->Storage[Stable].Length) {
                        //
                        // Reached the end of the hive.
                        //
                        break;
                    }
                    VALIDATE_CELL_MAP(__LINE__,t,Hive,p + (*BinAlloc));
                } while ( (t->BinAddress & HMAP_NEWALLOC) == 0);

                //
                // this will reenlist the bin if free
                //
                if ( ! HvpEnlistFreeCells(Hive, Bin, Bin->FileOffset)) {
                    CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,6,Bin,Bin->FileOffset);
                }
            } else {
                t->MemAlloc = 0;
            }

            RtlClearBits(&Hive->DirtyVector,Bin->FileOffset/HSECTOR_SIZE,Bin->Size/HSECTOR_SIZE);
            p = Bin->FileOffset + Bin->Size;
            
        } else {
            //
            // we do that to avoid touching bins that may not be mapped
            //
            p += HBLOCK_SIZE;
        }

    }

    //
    // be sure we haven't filled memory with trash
    //
    checkstatus = HvCheckHive(Hive, NULL);
    if (checkstatus != 0) {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,7,Hive,checkstatus);
    }

    //
    // Finally we need to rewrite the parent field in the root hcell. This is
    // patched in at hive load time so the correct value could have just been
    // overwritten with whatever happened to be on disk.
    //
    RootNode = (PCM_KEY_NODE)HvGetCell(Hive, RootCell);
    if( RootNode == NULL ) {
        //
        // we couldn't map a view for this cell
        // there is nothing we can do here, other than pray for this not to happen
        //
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,8,Hive,RootCell);
        return;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,RootCell);

    RootNode->Parent = LinkCell;
    RootNode->Flags |= KEY_HIVE_ENTRY | KEY_NO_DELETE;


    //
    // all bits in the dirty vector should be clean by now
    //
    ASSERT( RtlNumberOfSetBits( &(Hive->DirtyVector) ) == 0 );
    Hive->DirtyCount = 0;

#ifdef CM_ENABLE_WRITE_ONLY_BINS
        HvpMarkAllBinsWriteOnly(Hive);
#endif //CM_ENABLE_WRITE_ONLY_BINS

    //
    // Adjust the file size, if this fails, ignore it, since it just
    // means the file is too big. Do it here, where we are sure we have 
    // no pinned data whatsoever.
    //
    (Hive->FileSetSize)(
        Hive,
        HFILE_TYPE_PRIMARY,
        (Hive->BaseBlock->Length + HBLOCK_SIZE),
        OldFileLength
        );

    //
    // be sure the structure of the thing is OK after all this
    //
    checkstatus = CmCheckRegistry((PCMHIVE)Hive, CM_CHECK_REGISTRY_FORCE_CLEAN);
    if (checkstatus != 0) {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,9,Hive,checkstatus);
    }

    //
    // be sure there are no security cells thrown away in the cache
    //
    if( !CmpRebuildSecurityCache((PCMHIVE)Hive) ) {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,10,Hive,0);
    }
    
    return;
}

#ifdef WRITE_PROTECTED_REGISTRY_POOL

VOID
HvpChangeBinAllocation(
    PHBIN       Bin,
    BOOLEAN     ReadOnly
    )
{
    ASSERT(Bin->Signature == HBIN_SIGNATURE);
    //
    // Here to call the code to mark the memory pointed by Bin as Read/Write or ReadOnly, depending on the ReadOnly argument
    //
}

VOID
HvpMarkBinReadWrite(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Marks the memory allocated for the bin containing the specified cell as read/write.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - hcell_index of cell 

Return Value:

    NONE (It should work!)

--*/
{
    ULONG       Type;
    PHMAP_ENTRY Me;
    PHBIN       Bin;

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    Type = HvGetCellType(Cell);

    if ( (Hive->HiveFlags & HIVE_VOLATILE) ||
         (Type == Volatile) )
    {
        // nothing to do on a volatile hive
        return;
    }

    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);
    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
    
    HvpChangeBinAllocation(Bin,FALSE);

}

#endif //WRITE_PROTECTED_REGISTRY_POOL

#if DBG
BOOLEAN
HvIsCellDirty(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )

/*++

Routine Description:

    Given a hive and a cell, checks whether the corresponding sector
    is marked as dirty. 

    NOTE: This function assumes the view containing the bin is 
    mapped into system space.

Arguments:

    Hive - Supplies a pointer to the hive control structure

    Cell - Supplies the HCELL_INDEX of the Cell.

Return Value:

    TRUE - Data is marked as dirty.

    FALSE - Data is NOT marked as dirty.

--*/

{
    ULONG       Type;
    PRTL_BITMAP Bitmap;
    ULONG       Offset;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvIsCellDirty:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Cell:%08lx\n", Hive, Cell));

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);

    Type = HvGetCellType(Cell);

    if ( (Hive->HiveFlags & HIVE_VOLATILE) ||
         (Type == Volatile) )
    {
        //
        // we don't care as we are never going to save this data
        //
        return TRUE;
    }

    Bitmap = &(Hive->DirtyVector);

    Offset = Cell / HSECTOR_SIZE;

    if (RtlCheckBit(Bitmap, Offset)==1) {
        return(TRUE);
    }

    return FALSE;
}
#endif

/*
 !!!not used anymore!!!
  
BOOLEAN
HvMarkClean(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    ULONG       Length
    )
*/
/*++

Routine Description:

    Clears the dirty bits for a given portion of a hive.  This is
    the inverse of HvMarkDirty, although it does not give up any
    file space in the primary or log that HvMarkDirty may have reserved.

    This is a noop for Volatile address range.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Start - supplies a hive virtual address (i.e., an HCELL_INDEX or
             like form address) of the start of the area to mark dirty.

    Length - inclusive length in bytes of area to mark dirty.

Return Value:

    TRUE - it worked

--*/
/*
{
    ULONG       Type;
    PRTL_BITMAP BitMap;
    ULONG       First;
    ULONG       Last;
    ULONG       i;
    ULONG       Cluster;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvMarkClean:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Start:%08lx Length:%08lx\n", Hive, Start, Length));


    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    Type = HvGetCellType(Start);

    if ( (Hive->HiveFlags & HIVE_VOLATILE) ||
         (Type == Volatile) )
    {
        return TRUE;
    }

    BitMap = &(Hive->DirtyVector);

    First = Start / HSECTOR_SIZE;
    Last = (Start + Length - 1) / HSECTOR_SIZE;

    Cluster = Hive->Cluster;
    if (Cluster > 1) {

        //
        // Force Start down to base of cluster
        // Force End up to top of cluster
        //
        First = First & ~(Cluster - 1);
        Last = ROUND_UP(Last+1, Cluster) - 1;
    }

    if (Last >= BitMap->SizeOfBitMap) {
        Last = BitMap->SizeOfBitMap-1;
    }

    //
    // Subtract out the dirty count and
    // and clear the dirty bits.
    //
    for (i=First; i<=Last; i++) {
        if (RtlCheckBit(BitMap,i)==1) {
            --Hive->DirtyCount;
            RtlClearBits(BitMap, i, 1);
        }
    }
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    return(TRUE);
}
*/

BOOLEAN
HvpGrowLog2(
    PHHIVE  Hive,
    ULONG   Size
    )
/*++

Routine Description:

    Adjust the log for growth in the size of the hive, in particular,
    account for the increased space needed for a bigger dirty vector.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Size - proposed growth in size in bytes.

Return Value:

    TRUE - it worked

    FALSE - could not allocate log space, failure!

--*/
{
    ULONG   ClusterSize;
    ULONG   RequiredSize;
    ULONG   DirtyBytes;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpGrowLog2:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Size:%08lx\n", Hive, Size));

    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));


    //
    // If logging is off, tell caller world is OK.
    //
    if (Hive->Log == FALSE) {
        return TRUE;
    }

    ASSERT( (Size % HSECTOR_SIZE) == 0 );

    ClusterSize = Hive->Cluster * HSECTOR_SIZE;

    ASSERT( (((Hive->Storage[Stable].Length + Size) / HSECTOR_SIZE) % 8) == 0);

    DirtyBytes = (Hive->DirtyVector.SizeOfBitMap / 8) +
                    ((Size / HSECTOR_SIZE) / 8) +
                    sizeof(ULONG);                      // signature
    DirtyBytes = ROUND_UP(DirtyBytes, ClusterSize);

    RequiredSize =
        ClusterSize  +                                  // 1 cluster for header
        (Hive->DirtyCount * HSECTOR_SIZE) +
        DirtyBytes;

    RequiredSize = ROUND_UP(RequiredSize, HLOG_GROW);

    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    if ( ! (Hive->FileSetSize)(Hive, HFILE_TYPE_LOG, RequiredSize,Hive->LogSize)) {
        return FALSE;
    }

    if( CmRegistryLogSizeLimit > 0 ) {
        //
        // see if log is too big and set flush on lock release
        //
        ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

        if( RequiredSize >= (ULONG)(CmRegistryLogSizeLimit * ONE_K) ) {
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"LogFile for hive %p is %lx; will flush upon lock release\n",Hive,RequiredSize);
            CmpFlushOnLockRelease = TRUE;;
        }
    }

    Hive->LogSize = RequiredSize;
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
    return TRUE;
}

BOOLEAN
HvSyncHive(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Force backing store to match the memory image of the Stable
    part of the hive's space.

    Logs, primary, and alternate data can be written.  Primary is
    always written.  Normally either a log or an alternate, but
    not both, will also be written.

    It is possible to write only the primary.

    All dirty bits will be set clear.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

Return Value:

    TRUE - it worked

    FALSE - some failure.

--*/
{
    BOOLEAN oldFlag;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvSyncHive:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p\n", Hive));

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);

    //
    // Punt if post shutdown
    //
    if (HvShutdownComplete) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"HvSyncHive:  Attempt to sync AFTER SHUTDOWN\n"));
        return FALSE;
    }

    //
    // If nothing dirty, do nothing
    //
    if (Hive->DirtyCount == 0) {
        return TRUE;
    }

    //
    // Discard the write(s) to system hives if needed
    //
    if (CmpMiniNTBoot) {        
        ULONG Index;
        PCMHIVE CurrentHive = (PCMHIVE)Hive;
        BOOLEAN SkipWrite = FALSE;
        
        for (Index = 0; Index < CM_NUMBER_OF_MACHINE_HIVES; Index++) {
            if ((CmpMachineHiveList[Index].Name != NULL) &&
                ((CmpMachineHiveList[Index].CmHive == CurrentHive) ||
                 (CmpMachineHiveList[Index].CmHive2 == CurrentHive))) {
                SkipWrite = TRUE;                 

                break;
            }
        }

        if (SkipWrite) {
            return TRUE;
        }
    }

    HvpTruncateBins(Hive);

    //
    // If hive is volatile, do nothing
    //
    if (Hive->HiveFlags & HIVE_VOLATILE) {
        return TRUE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tDirtyCount:%08lx\n", Hive->DirtyCount));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tDirtyVector:"));
    //DumpDirtyVector(&(Hive->DirtyVector));

    //
    // disable hard error popups, to avoid self deadlock on bogus devices
    //
    oldFlag = IoSetThreadHardErrorMode(FALSE);

    //
    // Write a log.
    //
    if (Hive->Log == TRUE) {
        if (HvpWriteLog(Hive) == FALSE) {
            IoSetThreadHardErrorMode(oldFlag);
            return FALSE;
        }
    }

    //
    // Write the primary
    //
    if (HvpDoWriteHive(Hive, HFILE_TYPE_PRIMARY) == FALSE) {
        IoSetThreadHardErrorMode(oldFlag);
        return FALSE;
    }

    //
    // restore hard error popups mode
    //
    IoSetThreadHardErrorMode(oldFlag);

    //
    // Hive was successfully written out, discard any bins marked as
    // discardable.
    //
    // We don't need this anymore as the bins are not using paged pool
        //HvpDiscardBins(Hive);

    //
    // Free bins allocated from page-pool at the end of the hive. 
    // These bins were allocated as a temporary till the hive would be saved
    //
    HvpDropPagedBins(Hive
#if DBG
        , TRUE
#endif
        );

    //
    // Clear the dirty map
    //
    RtlClearAllBits(&(Hive->DirtyVector));
    Hive->DirtyCount = 0;

#ifdef CM_ENABLE_WRITE_ONLY_BINS
    HvpMarkAllBinsWriteOnly(Hive);
#endif CM_ENABLE_WRITE_ONLY_BINS

    return TRUE;
}

//
// Code for syncing a hive to backing store
//
VOID
HvpFlushMappedData(
    IN PHHIVE           Hive,
    IN OUT PRTL_BITMAP  DirtyVector
    )
/*++

Routine Description:

    This functions will flush all pinned views for the specified hive.
    It will clean the bits in the DirtyVector for the blocks that are 
    flushed.

    Additionally, it sets the timestamp on the first bin. 

    It iterates through the pinned view list, and unpin all of them.

Arguments:

    Hive - pointer to Hive for which dirty data is to be written.

    DirtyVector - copy of the DirtyVector for the hive

Return Value:

    TRUE - it worked

    FALSE - it failed

--*/
{
    PCMHIVE             CmHive;
    ULONG               FileOffsetStart;
    ULONG               FileOffsetEnd;
    PCM_VIEW_OF_FILE    CmView;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;
    PFREE_HBIN          FreeBin;

    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"[HvpFlushMappedData] (Entry) DirtyVector:"));
    //DumpDirtyVector(DirtyVector);

    CmHive = (PCMHIVE)Hive;

    //
    // for each pinned view
    //
    while(IsListEmpty(&(CmHive->PinViewListHead)) == FALSE) {
        //
        // Remove the first view from the pin view list
        //
        CmView = (PCM_VIEW_OF_FILE)RemoveHeadList(&(CmHive->PinViewListHead));
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);

        //
        // the real file offset starts after the header
        // 
        FileOffsetStart = CmView->FileOffset;
        FileOffsetEnd = FileOffsetStart + CmView->Size;
        
        FileOffsetEnd -= HBLOCK_SIZE;

        if( FileOffsetStart != 0 ) {
            //
            // just at the begining of the file, subtract the header
            //
            FileOffsetStart -= HBLOCK_SIZE;
        } 
        
        if( (FileOffsetEnd / HSECTOR_SIZE) > DirtyVector->SizeOfBitMap ) {
            //
            // Cc has mapped more than its valid
            //
            ASSERT( (FileOffsetEnd % HSECTOR_SIZE) == 0 );
            FileOffsetEnd = DirtyVector->SizeOfBitMap * HSECTOR_SIZE;
        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"[HvpFlushMappedData] CmView %p mapping from %lx to %lx\n",CmView,FileOffsetStart,FileOffsetEnd));

        //
        // now, for every block in this range which is mapped in view
        // clear the dirty bit
        //
        while(FileOffsetStart < FileOffsetEnd) {
            if( FileOffsetStart >= Hive->Storage[Stable].Length ) {
                //
                // This mean the hive has shrunk during the HvpTruncateBins call
                // all we have to do is clear the dirty bits and bail out
                //
                RtlClearBits(DirtyVector,FileOffsetStart/HSECTOR_SIZE,(FileOffsetEnd - FileOffsetStart)/HSECTOR_SIZE);
                break;
            }

            Me = HvpGetCellMap(Hive, FileOffsetStart);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileOffsetStart);
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            
            if( Me->BinAddress & HMAP_DISCARDABLE ) {
                FreeBin = (PFREE_HBIN)Me->BlockAddress;
                //
                // update the file offset
                //
                FileOffsetStart = FreeBin->FileOffset + FreeBin->Size;
                //
                // bin is discardable, or discarded; still, if it was mapped,
                // clear of the dirty bits
                //
                if( Me->BinAddress & HMAP_INVIEW ) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"[HvpFlushMappedData] Clearing DISCARDABLE %lu Bits starting at %lu\n",
                        FreeBin->Size/HSECTOR_SIZE,FreeBin->FileOffset/HSECTOR_SIZE));
                    RtlClearBits(DirtyVector,FreeBin->FileOffset/HSECTOR_SIZE,FreeBin->Size/HSECTOR_SIZE);
                }
            } else {
                if( Me->BinAddress & HMAP_INVIEW ) {
                    //
                    // bin is mapped in view. Then, this should be the beggining of the bin
                    //
                    ASSERT(Bin->Signature == HBIN_SIGNATURE);
                    ASSERT(Bin->FileOffset == FileOffsetStart);

                    //
                    // clear the dirty bits for this bin as dirty blocks will
                    // be saved while unpinning the view
                    //
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"[HvpFlushMappedData] Clearing %lu Bits starting at %lu\n",
                        Bin->Size/HSECTOR_SIZE,Bin->FileOffset/HSECTOR_SIZE));
                    RtlClearBits(DirtyVector,Bin->FileOffset/HSECTOR_SIZE,Bin->Size/HSECTOR_SIZE);
    
                    FileOffsetStart += Bin->Size;
                } else {
                    //
                    // bin is in paged pool. This should be the begining too
                    //
                    
                    //
                    // we could fall into cross boundary problem here; advance carrefully
                    // (two day spent on this problem !!!)
                    //
                    ASSERT(Bin->Signature == HBIN_SIGNATURE);
                    FileOffsetStart += HBLOCK_SIZE;
                }
            }

        }// while (FileOffsetStart<FileOffsetEnd)
        
        //
        // UnPin the view; this will flush all dirty blocks to the backing storage
        //
        CmpUnPinCmView (CmHive,CmView,FALSE,TRUE);
    } // while (IsListEmpty)
    
}

//#define TEST_LOG_SUPPORT
#ifdef TEST_LOG_SUPPORT
ULONG   CmpFailPrimarySave = 0;
#endif //TEST_LOG_SUPPORT

BOOLEAN
HvpDoWriteHive(
    PHHIVE          Hive,
    ULONG           FileType
    )
/*++

Routine Description:

    Write dirty parts of the hive out to either its primary or alternate
    file.  Write the header, flush, write all data, flush, update header,
    flush.  Assume either logging or primary/alternate pairs used.

    NOTE:   TimeStamp is not set, assumption is that HvpWriteLog set
            that.  It is only used for checking if Logs correspond anyway.

Arguments:

    Hive - pointer to Hive for which dirty data is to be written.

    FileType - indicated whether primary or alternate file should be written.

Return Value:

    TRUE - it worked

    FALSE - it failed

--*/
{
    PHBASE_BLOCK        BaseBlock;
    ULONG               Offset;
    PUCHAR              Address;
    ULONG               Length;
    BOOLEAN             rc;
    ULONG               Current;
    PRTL_BITMAP         BitMap;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;
    BOOLEAN             ShrinkHive;
    PCMP_OFFSET_ARRAY   offsetArray;
    CMP_OFFSET_ARRAY    offsetElement;
    ULONG               Count;
    ULONG               SetBitCount;
    PULONG              CopyDirtyVector;
    ULONG               CopyDirtyVectorSize;
    RTL_BITMAP          CopyBitMap;
    LARGE_INTEGER       FileOffset;
    ULONG               OldFileSize;
    BOOLEAN             GrowHive = FALSE;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpDoWriteHive:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p FileType:%08lx\n", Hive, FileType));

    FileOffset.HighPart = FileOffset.LowPart =0;
    //
    // flush first, so that the filesystem structures get written to
    // disk if we have grown the file.
    //
    if ( (((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY] == NULL) || 
        !(Hive->FileFlush)(Hive, FileType,NULL,Hive->Storage[Stable].Length+HBLOCK_SIZE) ) {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[1]: Failed to flush hive %p\n", Hive);
#endif //_CM_LDR_
        return(FALSE);
    }

#ifdef TEST_LOG_SUPPORT
    if(CmpFailPrimarySave == 1) {
        return FALSE;
    }
#endif //TEST_LOG_SUPPORT

    BaseBlock = Hive->BaseBlock;

    //
    // we should never come to this
    //
    ASSERT( Hive->Storage[Stable].Length != 0 );
    ASSERT( Hive->BaseBlock->RootCell != HCELL_NIL );

    OldFileSize = BaseBlock->Length;
    if (BaseBlock->Length > Hive->Storage[Stable].Length) {
        ShrinkHive = TRUE;
    } else {
        ShrinkHive = FALSE;
        if( BaseBlock->Length < Hive->Storage[Stable].Length ) {
            GrowHive = TRUE;
        }
    }

    //
    // --- Write out header first time, flush ---
    //
    ASSERT(BaseBlock->Signature == HBASE_BLOCK_SIGNATURE);
    ASSERT(BaseBlock->Major == HSYS_MAJOR);
    ASSERT(BaseBlock->Format == HBASE_FORMAT_MEMORY);
    ASSERT(Hive->ReadOnly == FALSE);


    if (BaseBlock->Sequence1 != BaseBlock->Sequence2) {

        //
        // Some previous log attempt failed, or this hive needs to
        // be recovered, so punt.
        //
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[2,%s]: Invalid sequence number for hive%p\n", "Primary",Hive);
#endif //_CM_LDR_
        return FALSE;
    }

    BaseBlock->Length = Hive->Storage[Stable].Length;

    BaseBlock->Sequence1++;
    BaseBlock->Type = HFILE_TYPE_PRIMARY;
    BaseBlock->Cluster = Hive->Cluster;
    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
    if( HiveWritesThroughCache(Hive,FileType) == TRUE ) {
        //
        // if we use Cc, do the write with the pin interface
        //
        rc = CmpFileWriteThroughCache(  Hive,
                                        FileType,
                                        &offsetElement,
                                        1);
    } else {
        rc = (Hive->FileWrite)(
                Hive,
                FileType,
                &offsetElement,
                1,
                &Offset
                );
    }


    if (rc == FALSE) {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[3,%s]: Failed to write header for hive%p\n", "Primary",Hive);
#endif //_CM_LDR_
        return FALSE;
    }

    if ( ! (Hive->FileFlush)(Hive, FileType,&FileOffset,offsetElement.DataLength)) {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[4,%s]: Failed to flush header for hive%p\n", "Primary",Hive);
#endif //_CM_LDR_
        return FALSE;
    }
    Offset = ROUND_UP(Offset, HBLOCK_SIZE);

#ifdef TEST_LOG_SUPPORT
    if(CmpFailPrimarySave == 2) {
        return FALSE;
    }
#endif //TEST_LOG_SUPPORT
    //
    // --- Write out dirty data (only if there is any) ---
    //

    if (Hive->DirtyVector.Buffer != NULL) {
        //
        // First sector of first bin will always be dirty, write it out
        // with the TimeStamp value overlaid on its Link field.
        //
        BitMap = &(Hive->DirtyVector);

        //
        // make a copy of the dirty vector; we don't want to alter the 
        // original dirty vector in case things go wrong
        //
        CopyDirtyVectorSize = BitMap->SizeOfBitMap / 8;
        CopyDirtyVector = (Hive->Allocate)(ROUND_UP(CopyDirtyVectorSize,sizeof(ULONG)), FALSE,CM_FIND_LEAK_TAG38);
        if (CopyDirtyVector == NULL) {
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[5,%s]: Failed to allocate CopyDirtyVectorfor hive%p\n", "Primary",Hive);
#endif //_CM_LDR_
            return FALSE;
        }
        RtlCopyMemory(CopyDirtyVector,BitMap->Buffer,CopyDirtyVectorSize);
        RtlInitializeBitMap (&CopyBitMap,CopyDirtyVector,BitMap->SizeOfBitMap);
    
        ASSERT(RtlCheckBit(BitMap, 0) == 1);
        ASSERT(RtlCheckBit(BitMap, (Hive->Cluster - 1)) == 1);
        ASSERT(sizeof(LIST_ENTRY) >= sizeof(LARGE_INTEGER));
        Me = HvpGetCellMap(Hive, 0);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,0);
        if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0 ) {
            //
            // first view is not mapped
            //
            //
            // fatal error: Dirty Data is not pinned !!!!
            //
            CM_BUGCHECK(REGISTRY_ERROR,FATAL_MAPPING_ERROR,3,0,Me);
        }
        Address = (PUCHAR)Me->BlockAddress;
        Bin = (PHBIN)Address;
        Bin->TimeStamp = BaseBlock->TimeStamp;

        //
        // flush first the mapped data
        //
        try {
            HvpFlushMappedData(Hive,&CopyBitMap);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // in-page exception while flushing the mapped data; this is due to the map_no_read scheme.
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive : HvpFlushMappedData has raised :%08lx\n",GetExceptionCode()));
            return FALSE;
        }

#ifdef TEST_LOG_SUPPORT
        if(CmpFailPrimarySave == 3) {
            return FALSE;
        }
#endif //TEST_LOG_SUPPORT

        //
        // Write out the rest of the dirty data
        //
        Current = 0;        

        SetBitCount = RtlNumberOfSetBits(&CopyBitMap);
        if( SetBitCount > 0 ) {
            //
            // we still have some dirty data
            // this must reside in paged-pool bins
            // save it in the old-fashioned way (non-cached)
            //
            offsetArray =(PCMP_OFFSET_ARRAY)ExAllocatePool(PagedPool,sizeof(CMP_OFFSET_ARRAY) * SetBitCount);
            if (offsetArray == NULL) {
                CmpFree(CopyDirtyVector, ROUND_UP(CopyDirtyVectorSize,sizeof(ULONG)));
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[8,%s]: Failed to allocate offsetArray for hive%p\n", "Primary",Hive);
#endif //_CM_LDR_
                return FALSE;
            }
            Count = 0;

            while (HvpFindNextDirtyBlock(
                        Hive,
                        &CopyBitMap,
                        &Current,
                        &Address,
                        &Length,
                        &Offset
                        ) == TRUE)
            {
                // Gather data into array.
                ASSERT(Count < SetBitCount);
                offsetArray[Count].FileOffset = Offset;
                offsetArray[Count].DataBuffer = Address;
                offsetArray[Count].DataLength = Length;
                Offset += Length;
                ASSERT((Offset % (Hive->Cluster * HSECTOR_SIZE)) == 0);
                Count++;
            }

            if( HiveWritesThroughCache(Hive,FileType) == TRUE ) {
                //
                // if we use Cc, do the write with the pin interface
                //
                rc = CmpFileWriteThroughCache(  Hive,
                                                FileType,
                                                offsetArray,
                                                Count);
            } else {
                //
                // for primary file, issue all IOs at the same time.
                //
                rc = (Hive->FileWrite)(
                                        Hive,
                                        FileType,
                                        offsetArray,
                                        Count,
                                        &Offset             // Just an OUT parameter which returns the point
                                                            // in the file after the last write.
                                        );
            }

#ifdef SYNC_HIVE_VALIDATION
            if( rc == TRUE ) {
                ULONG   i;
                for ( i = Current; i < CopyBitMap.SizeOfBitMap; i++) {
                    if(RtlCheckBit(&CopyBitMap, i) == 1) {
                        //
                        // cause of zero-at the end corruption
                        //
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\n\n            HARD CODED BREAKPOINT IN REGISTRY !!! \n");
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive - Zero-at-the-end code bug in HvpFindNextDirtyBlock\n");
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Dirty data at the end residing in paged pool is not saved to the hive\n");
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Hive: %p :: Bitmap = [%p] CopyBitMap = [%p]\n",Hive,BitMap,&CopyBitMap);
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpFindNextDirtyBlock reported Current = %lu, i = %lx, bitmap size = %lx\n",Current,i,CopyBitMap.SizeOfBitMap);
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\nThanks for hitting this! Please send remote to dragoss\n\n");
                        DbgBreakPoint();
                        break;
                    }
                }
            }
#endif //SYNC_HIVE_VALIDATION
            
            ExFreePool(offsetArray);
            if (rc == FALSE) {
                CmpFree(CopyDirtyVector, ROUND_UP(CopyDirtyVectorSize,sizeof(ULONG)));
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[10,%s]: Failed to write dirty run for hive%p\n", "Primary",Hive);
#endif //_CM_LDR_
                return FALSE;
            }
        }
        //
        // first bin header must be saved !
        //
        ASSERT(RtlCheckBit(BitMap, 0) == 1);
        ASSERT(RtlCheckBit(BitMap, (Hive->Cluster - 1)) == 1);

        CmpFree(CopyDirtyVector, ROUND_UP(CopyDirtyVectorSize,sizeof(ULONG)));
    }

#ifdef TEST_LOG_SUPPORT
    if(CmpFailPrimarySave == 4) {
        return FALSE;
    }
#endif //TEST_LOG_SUPPORT

    if ( ! (Hive->FileFlush)(Hive, FileType,NULL,Hive->Storage[Stable].Length+HBLOCK_SIZE)) {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[11,%s]: Failed to flush hive%p\n", "Primary",Hive);
#endif //_CM_LDR_
        return FALSE;
    }

#ifdef TEST_LOG_SUPPORT
    if(CmpFailPrimarySave == 5) {
        return FALSE;
    }
#endif //TEST_LOG_SUPPORT

    if ( GrowHive && HiveWritesThroughCache(Hive,FileType) ) {
        IO_STATUS_BLOCK IoStatus;
        if(!NT_SUCCESS(ZwFlushBuffersFile(((PCMHIVE)Hive)->FileHandles[FileType],&IoStatus))) {
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[12,%s]: CcSetValidDataFailed for hive %p\n", Hive, "Primary");
#endif //_CM_LDR_
            return FALSE;
        }
/*
        // thsi was supposed to be the elegant way to do it.
        //
        // We need to set the size of the file; Tell FS to update it!!!
        //
        FileOffset.LowPart = Hive->Storage[Stable].Length + HBLOCK_SIZE;
        if(!NT_SUCCESS(CcSetValidData(((PCMHIVE)Hive)->FileObject,&FileOffset)) ) {
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[12,%s]: CcSetValidDataFailed for hive %p\n", Hive, "Primary");
        }
*/
    }
#ifdef TEST_LOG_SUPPORT
    if(CmpFailPrimarySave == 6) {
        return FALSE;
    }
#endif //TEST_LOG_SUPPORT

    //
    // --- Write header again to report completion ---
    //
    BaseBlock->Sequence2++;
    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);
    Offset = 0;

    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
    if( HiveWritesThroughCache(Hive,FileType) == TRUE ) {
        //
        // if we use Cc, do the write with the pin interface
        //
        rc = CmpFileWriteThroughCache(  Hive,
                                        FileType,
                                        &offsetElement,
                                        1);
    } else {
        rc = (Hive->FileWrite)(
                    Hive,
                    FileType,
                    &offsetElement,
                    1,
                    &Offset
                    );
    }
    if (rc == FALSE) {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[11,%s]: Failed to write header for hive%p\n", Hive, "Primary");
#endif //_CM_LDR_
        return FALSE;
    }

    if (ShrinkHive) {
        //
        // Hive has shrunk, give up the excess space.
        //
        CmpDoFileSetSize(Hive, FileType, Hive->Storage[Stable].Length + HBLOCK_SIZE,OldFileSize + HBLOCK_SIZE);
    }

#ifdef TEST_LOG_SUPPORT
    if(CmpFailPrimarySave == 7) {
        return FALSE;
    }
#endif //TEST_LOG_SUPPORT
    //
    // if we wrote through cache, we don't need to flush anymore
    //
    if( HiveWritesThroughCache(Hive,FileType) == FALSE ){
        if ( ! (Hive->FileFlush)(Hive, FileType,&FileOffset,offsetElement.DataLength)) {
    #ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[12,%s]: Failed to flush hive%p\n", "Primary",Hive);
    #endif //_CM_LDR_
            return FALSE;
        }
    } 

    if ((Hive->Log) &&
        (Hive->LogSize > HLOG_MINSIZE(Hive))) {
        //
        // Shrink log back down, reserve at least two clusters
        // worth of space so that if all the disk space is
        // consumed, there will still be enough space prereserved
        // to allow a minimum of registry operations so the user
        // can log on.
        //
        CmpDoFileSetSize(Hive, HFILE_TYPE_LOG, HLOG_MINSIZE(Hive),Hive->LogSize);
        Hive->LogSize = HLOG_MINSIZE(Hive);
    }

#if DBG
    {
        NTSTATUS                        Status;
        FILE_END_OF_FILE_INFORMATION    FileInfo;
        IO_STATUS_BLOCK                 IoStatus;

        Status = NtQueryInformationFile(
                    ((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY],
                    &IoStatus,
                    (PVOID)&FileInfo,
                    sizeof(FILE_END_OF_FILE_INFORMATION),
                    FileEndOfFileInformation
                    );

        if (NT_SUCCESS(Status)) {
            ASSERT(IoStatus.Status == Status);
            ASSERT( FileInfo.EndOfFile.LowPart == (Hive->Storage[Stable].Length + HBLOCK_SIZE));
        } 
    }
#endif //DBG

    return TRUE;
}

//
// Code for tracking modifications and ensuring adequate log space
//
BOOLEAN
HvpWriteLog(
    PHHIVE          Hive
    )
/*++

Routine Description:

    Write a header, the DirtyVector, and all the dirty data into
    the log file.  Do flushes at the right places.  Update the header.

Arguments:

    Hive - pointer to Hive for which dirty data is to be logged.

Return Value:

    TRUE - it worked

    FALSE - it failed

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           Offset;
    PUCHAR          Address;
    ULONG           Length;
    BOOLEAN         rc;
    ULONG           Current;
    ULONG           junk;
    ULONG           ClusterSize;
    ULONG           HeaderLength;
    PRTL_BITMAP     BitMap;
    ULONG           DirtyVectorSignature = HLOG_DV_SIGNATURE;
    LARGE_INTEGER   systemtime;
    PCMP_OFFSET_ARRAY offsetArray;
    CMP_OFFSET_ARRAY offsetElement;
    ULONG			Count;
    ULONG			SetBitCount;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpWriteLog:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p\n", Hive));

    ClusterSize = Hive->Cluster * HSECTOR_SIZE;
	//
	// make sure the log size accomodates the dirty data we are about to write.
	//
	{
		ULONG	tmp;
		ULONG	RequiredSize;

		tmp = Hive->DirtyVector.SizeOfBitMap / 8;   // bytes
		tmp += sizeof(ULONG);                       // signature

		RequiredSize =
			ClusterSize  +                                  // 1 cluster for header
			ROUND_UP(tmp, ClusterSize) +
			((Hive->DirtyCount) * HSECTOR_SIZE);

		RequiredSize = ROUND_UP(RequiredSize, HLOG_GROW);

		ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
		
		if( Hive->LogSize >= RequiredSize ) {
			//
			// this is a noop. log is already big enough
			//
			NOTHING;
		} else {
			
			if( !NT_SUCCESS(CmpDoFileSetSize(Hive, HFILE_TYPE_LOG, RequiredSize,Hive->LogSize)) ) {
				return FALSE;
			}
		    Hive->LogSize = RequiredSize;
		}
	}

    BitMap = &Hive->DirtyVector;
    //
    // --- Write out header first time, flush ---
    //
    BaseBlock = Hive->BaseBlock;
    ASSERT(BaseBlock->Signature == HBASE_BLOCK_SIGNATURE);
    ASSERT(BaseBlock->Major == HSYS_MAJOR);
    ASSERT(BaseBlock->Format == HBASE_FORMAT_MEMORY);
    ASSERT(Hive->ReadOnly == FALSE);


    if (BaseBlock->Sequence1 != BaseBlock->Sequence2) {

        //
        // Some previous log attempt failed, or this hive needs to
        // be recovered, so punt.
        //
        return FALSE;
    }

    BaseBlock->Sequence1++;
    KeQuerySystemTime(&systemtime);
    BaseBlock->TimeStamp = systemtime;

    BaseBlock->Type = HFILE_TYPE_LOG;

    HeaderLength = ROUND_UP(HLOG_HEADER_SIZE, ClusterSize);
    BaseBlock->Cluster = Hive->Cluster;

    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
    rc = (Hive->FileWrite)(
            Hive,
            HFILE_TYPE_LOG,
            &offsetElement,
            1,
            &Offset
            );
    if (rc == FALSE) {
        return FALSE;
    }
    Offset = ROUND_UP(Offset, HeaderLength);
    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_LOG,NULL,0)) {
        return FALSE;
    }

    //
    // --- Write out dirty vector ---
    //
    //
    // try to allocate a stash buffer. if we fail. we fail to save the hive
    // only save what is relevant 
    //
    Length = (Hive->Storage[Stable].Length / HSECTOR_SIZE) / 8;

    LOCK_STASH_BUFFER();
    if( CmpStashBufferSize < (Length + sizeof(DirtyVectorSignature)) ) {
        PUCHAR TempBuffer =  ExAllocatePoolWithTag(PagedPool, ROUND_UP((Length + sizeof(DirtyVectorSignature)),PAGE_SIZE),CM_STASHBUFFER_TAG);
        if (TempBuffer == NULL) {
            UNLOCK_STASH_BUFFER();
            return FALSE;
        }
        if( CmpStashBuffer != NULL ) {
            ExFreePool( CmpStashBuffer );
        }
        CmpStashBuffer = TempBuffer;
        CmpStashBufferSize = ROUND_UP((Length + sizeof(DirtyVectorSignature)),PAGE_SIZE);

    }
    
    ASSERT(sizeof(ULONG) == sizeof(DirtyVectorSignature));  // See GrowLog1 above


    //
    // signature
    //
    (*((ULONG *)CmpStashBuffer)) = DirtyVectorSignature;

    //
    // dirty vector content
    //
    Address = (PUCHAR)(Hive->DirtyVector.Buffer);
    RtlCopyMemory(CmpStashBuffer + sizeof(DirtyVectorSignature),Address,Length);
    
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID)CmpStashBuffer;
    offsetElement.DataLength = ROUND_UP((Length + sizeof(DirtyVectorSignature)),ClusterSize);
    rc = (Hive->FileWrite)(
            Hive,
            HFILE_TYPE_LOG,
            &offsetElement,
            1,
            &Offset
            );

    UNLOCK_STASH_BUFFER();

    if (rc == FALSE) {
        return FALSE;
    }

    ASSERT( (Offset % ClusterSize) == 0 );

    //
    // --- Write out body of log ---
    //
    SetBitCount = RtlNumberOfSetBits(BitMap);
    offsetArray =
        (PCMP_OFFSET_ARRAY)
        ExAllocatePool(PagedPool,
                       sizeof(CMP_OFFSET_ARRAY) * SetBitCount);
    if (offsetArray == NULL) {
        return FALSE;
    }
    Count = 0;

    Current = 0;
    while (HvpFindNextDirtyBlock(
                Hive,
                BitMap,
                &Current,
                &Address,
                &Length,
                &junk
                ) == TRUE)
    {
        // Gather data into array.
        ASSERT(Count < SetBitCount);
        offsetArray[Count].FileOffset = Offset;
        offsetArray[Count].DataBuffer = Address;
        offsetArray[Count].DataLength = Length;
        Offset += Length;
        Count++;
        ASSERT((Offset % ClusterSize) == 0);
    }

        rc = (Hive->FileWrite)(
                Hive,
                HFILE_TYPE_LOG,
        offsetArray,
        Count,
        &Offset             // Just an OUT parameter which returns the point
                            // in the file after the last write.
                );
    ExFreePool(offsetArray);
        if (rc == FALSE) {
            return FALSE;
        }

    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_LOG,NULL,0)) {
        return FALSE;
    }

    //
    // --- Write header again to report completion ---
    //

    //
    // -- we need to save the new length, in case the hive was grown.
    //
    Length = BaseBlock->Length;
    if( Length < Hive->Storage[Stable].Length ) {
        BaseBlock->Length = Hive->Storage[Stable].Length;
    }
    BaseBlock->Sequence2++;
    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);
    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
    rc = (Hive->FileWrite)(
            Hive,
            HFILE_TYPE_LOG,
            &offsetElement,
            1,
            &Offset
            );
    //
    // restore the original length
    //
    BaseBlock->Length = Length;
    if (rc == FALSE) {
        return FALSE;
    }
    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_LOG,NULL,0)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
HvpFindNextDirtyBlock(
    PHHIVE          Hive,
    PRTL_BITMAP     BitMap,
    PULONG          Current,
    PUCHAR          *Address,
    PULONG          Length,
    PULONG          Offset
    )
/*++

Routine Description:

    This routine finds and reports the largest run of dirty logical
    sectors in the hive, which are contiguous in memory and on disk.

Arguments:

    Hive - pointer to Hive of interest.

    BitMap - supplies a pointer to a bitmap structure, which
                describes what is dirty.

    Current - supplies a pointer to a varible that tracks position
                in the bitmap.  It is a bitnumber.  It is updated by
                this call.

    Address - supplies a pointer to a variable to receive a pointer
                to the area in memory to be written out.

    Length - supplies a pointer to a variable to receive the length
                of the region to read/write

    Offset - supplies a pointer to a variable to receive the offset
                in the backing file to which the data should be written.
                (not valid for log files)

Return Value:

    TRUE - more to write, ret values good

    FALSE - all data has been written

--*/
{
    ULONG       i;
    ULONG       EndOfBitMap;
    ULONG       Start;
    ULONG       End;
    HCELL_INDEX FileBaseAddress;
    HCELL_INDEX FileEndAddress;
    PHMAP_ENTRY Me;
    PUCHAR      Block;
    PUCHAR      StartBlock;
    PUCHAR      NextBlock;
    ULONG       RunSpan;
    ULONG       RunLength;
    ULONG       FileLength;
    PFREE_HBIN  FreeBin;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpFindNextDirtyBlock:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Current:%08lx\n", Hive, *Current));


    EndOfBitMap = BitMap->SizeOfBitMap;

    if (*Current >= EndOfBitMap) {
        return FALSE;
    }

    //
    // Find next run of set bits
    //
    for (i = *Current; i < EndOfBitMap; i++) {
        if (RtlCheckBit(BitMap, i) == 1) {
            break;
        }
    }
    Start = i;

    for ( ; i < EndOfBitMap; i++) {
        if (RtlCheckBit(BitMap, i) == 0) {
            break;
        }
        if( HvpCheckViewBoundary(Start*HSECTOR_SIZE,i*HSECTOR_SIZE) == FALSE ) {
            break;
        }
    }
    End = i;
    

    //
    // Compute hive virtual addresses, beginning file address, memory address
    //
    FileBaseAddress = Start * HSECTOR_SIZE;
    FileEndAddress = End * HSECTOR_SIZE;
    FileLength = FileEndAddress - FileBaseAddress;
    if (FileLength == 0) {
        *Address = NULL;
        *Current = 0xffffffff;
        *Length = 0;
        return FALSE;
    }
    Me = HvpGetCellMap(Hive, FileBaseAddress);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileBaseAddress);

    if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0 ) {
        //
        // this is really bad, bugcheck!!!
        //
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"FileAddress = %lx, Map = %lx",FileBaseAddress,Me);
#endif //_CM_LDR_
        CM_BUGCHECK(REGISTRY_ERROR,FATAL_MAPPING_ERROR,1,FileBaseAddress,Me);

    }

    ASSERT_BIN_VALID(Me);

    if (Me->BinAddress & HMAP_DISCARDABLE) {
        FreeBin = (PFREE_HBIN)Me->BlockAddress;
        StartBlock = (PUCHAR)(HBIN_BASE(Me->BinAddress) + FileBaseAddress - FreeBin->FileOffset );
    } else {
        StartBlock = (PUCHAR)Me->BlockAddress;
    }

    Block = StartBlock;
    ASSERT(((PHBIN)HBIN_BASE(Me->BinAddress))->Signature == HBIN_SIGNATURE);
    *Address = Block + (FileBaseAddress & HCELL_OFFSET_MASK);

    *Offset = FileBaseAddress + HBLOCK_SIZE;

    //
    // Build up length.  First, account for sectors in first block.
    //
    RunSpan = HSECTOR_COUNT - (Start % HSECTOR_COUNT);

    if ((End - Start) <= RunSpan) {

        //
        // Entire length is in first block, return it
        //
        *Length = FileLength;
        *Current = End;
        return TRUE;

    } else {

        RunLength = RunSpan * HSECTOR_SIZE;
        FileBaseAddress = ROUND_UP(FileBaseAddress+1, HBLOCK_SIZE);

    }

    //
    // Scan forward through blocks, filling up length as we go.
    //
    // NOTE:    This loop grows forward 1 block at time.  If we were
    //          really clever we'd fill forward a bin at time, since
    //          bins are always contiguous.  But most bins will be
    //          one block long anyway, so we won't bother for now.
    //
    while (RunLength < FileLength) {

        Me = HvpGetCellMap(Hive, FileBaseAddress);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileBaseAddress);

        if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0 ) {
            //
            // this is really bad, bugcheck!!!
            //
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"FileAddress = %lx, Map = %lx",FileBaseAddress,Me);
#endif //_CM_LDR_
            CM_BUGCHECK(REGISTRY_ERROR,FATAL_MAPPING_ERROR,2,FileBaseAddress,Me);

        }

        ASSERT(((PHBIN)HBIN_BASE(Me->BinAddress))->Signature == HBIN_SIGNATURE);

        if (Me->BinAddress & HMAP_DISCARDABLE) {
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            NextBlock = (PUCHAR)(HBIN_BASE(Me->BinAddress) + FileBaseAddress - FreeBin->FileOffset );
        } else {
            NextBlock = (PUCHAR)Me->BlockAddress;
        }

        if ( (NextBlock - Block) != HBLOCK_SIZE) {

            //
            // We've hit a discontinuity in memory.  RunLength is
            // as long as it's going to get.
            //
            break;
        }


        if ((FileEndAddress - FileBaseAddress) <= HBLOCK_SIZE) {

            //
            // We've reached the tail block, all is contiguous,
            // fill up to end and return.
            //
            *Length = FileLength;
            *Current = End;
            return TRUE;
        }

        //
        // Just another contiguous block, fill forward
        //
        RunLength += HBLOCK_SIZE;
        RunSpan += HSECTOR_COUNT;
        FileBaseAddress += HBLOCK_SIZE;
        Block = NextBlock;
    }

    //
    // We either hit a discontinuity, OR, we're at the end of the range
    // we're trying to fill.  In either case, return.
    //
    *Length = RunLength;
    *Current = Start + RunSpan;
    return TRUE;
}

/*

!!!we don't need this anymore as the bins are not allocated from paged pool anymore!!!
Big chunks  of discardable registry allocations will just not be mapped.

  
VOID
HvpDiscardBins(
    IN PHHIVE Hive
    )

*/
/*++

Routine Description:

    Walks through the dirty bins in a hive to see if any are marked
    discardable.  If so, they are discarded and the map is updated to
    reflect this.

Arguments:

    Hive - Supplies the hive control structure.

Return Value:

    None.

--*/

/*
{
    PHBIN Bin;
    PHMAP_ENTRY Map;
    PFREE_HBIN FreeBin;
    PLIST_ENTRY List;

    List = Hive->Storage[Stable].FreeBins.Flink;

    while (List != &Hive->Storage[Stable].FreeBins) {
        ASSERT_LISTENTRY(List);
        FreeBin = CONTAINING_RECORD(List, FREE_HBIN, ListEntry);

        if (FreeBin->Flags & FREE_HBIN_DISCARDABLE) {
            Map = HvpGetCellMap(Hive, FreeBin->FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,FreeBin->FileOffset);
            Bin = (PHBIN)HBIN_BASE(Map->BinAddress);
            ASSERT(Map->BinAddress & HMAP_DISCARDABLE);
            //
            // Note we use ExFreePool directly here to avoid
            // giving back the quota for this bin. By charging
            // registry quota for discarded bins, we prevent
            // sparse hives from requiring more quota after
            // a reboot than on a running system.
            //
            ExFreePool(Bin);
            FreeBin->Flags &= ~FREE_HBIN_DISCARDABLE;
        }
        List=List->Flink;
    }

}
*/

BOOLEAN
HvHiveWillShrink(
                    IN PHHIVE Hive
                    )
/*++

Routine Description:

    Applies to stable storage only. Helps determining whether the hive 
    will shrink on first flush

--*/
{
    PHMAP_ENTRY Map;
    ULONG NewLength;
    ULONG OldLength;

    OldLength = Hive->BaseBlock->Length;
    NewLength = Hive->Storage[Stable].Length;
    
    if( OldLength > NewLength ) {
        return TRUE;
    }

    if( NewLength > 0 ) {
        ASSERT( (NewLength % HBLOCK_SIZE) == 0);
        Map = HvpGetCellMap(Hive, (NewLength - HBLOCK_SIZE));
        VALIDATE_CELL_MAP(__LINE__,Map,Hive,(NewLength - HBLOCK_SIZE));
        if (Map->BinAddress & HMAP_DISCARDABLE) {
            return TRUE;
        } 
    }
    return FALSE;
}

VOID
HvpTruncateBins(
    IN PHHIVE Hive
    )

/*++

Routine Description:

    Attempts to shrink the hive by truncating any bins that are discardable at
    the end of the hive.  Applies to both stable and volatile storage.

Arguments:

    Hive - Supplies the hive to be truncated.

Return Value:

    None.

--*/

{
    HSTORAGE_TYPE i;
    PHMAP_ENTRY Map;
    ULONG NewLength;
    PFREE_HBIN FreeBin;

    //
    // stable and volatile
    //
    for (i=0;i<HTYPE_COUNT;i++) {

        //
        // find the last in-use bin in the hive
        //
        NewLength = Hive->Storage[i].Length;

        while (NewLength > 0) {
            Map = HvpGetCellMap(Hive, (NewLength - HBLOCK_SIZE) + (i*HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,(NewLength - HBLOCK_SIZE) + (i*HCELL_TYPE_MASK));
            if (Map->BinAddress & HMAP_DISCARDABLE) {
                FreeBin = (PFREE_HBIN)Map->BlockAddress;
#ifdef  HV_TRACK_FREE_SPACE
                Hive->Storage[i].FreeStorage -= (FreeBin->Size - sizeof(HBIN));
                                ASSERT( (LONG)(Hive->Storage[i].FreeStorage) >= 0 );
#endif
                NewLength = FreeBin->FileOffset;
            } else {
                break;
            }
        }

        if (NewLength < Hive->Storage[i].Length) {
            //
            // There are some free bins to truncate.
            //
            HvFreeHivePartial(Hive, NewLength, i);
        }
    }
}

VOID
HvpDropPagedBins(
    IN PHHIVE   Hive
#if DBG
    ,
    IN BOOLEAN  Check
#endif
    )

/*++

Routine Description:

    Frees all bins allocated from page pool, which are at 
    the end of the hive, then update their map (clears the
    HMAP_INPAGEDPOOL flag). Next attempt to read from those 
    bins will map a view for them. Checks for CM_VIEW_SIZE boundary,
    before freeing a bin.

    It also tags each start of the bin with HMAP_NEWALLOC; This will 
    allow us to use MAP_NO_READ flag in CcMapData (now that we enabled
    MNW feature for registry streams, we know that Mm will fault only one 
    page at the time for these king of streams)

    Applies only to permanent storage.

Arguments:

    Hive - Supplies the hive to operate on..

    Check - debug only, beggining of the bin should already tagged as 
            HMAP_NEWALLOC

Return Value:

    None.

--*/

{
    ULONG_PTR   Address;
    LONG        Length;
    LONG        Offset;
    PHMAP_ENTRY Me;
    PHBIN       Bin;
    PFREE_HBIN  FreeBin;
    BOOLEAN     UnMap = FALSE;

    PAGED_CODE();

    if( (Hive->Storage[Stable].Length == 0) ||  // empty hive
        (((PCMHIVE)Hive)->FileObject == NULL)     // or hive not using the mapped views technique
        ) {
        return;
    }

    CmLockHiveViews((PCMHIVE)Hive);
    
    if( ((PCMHIVE)Hive)->UseCount != 0 ) {
        //
        // this is not a good time to do that
        //
        CmUnlockHiveViews((PCMHIVE)Hive);
        return;
    }
    //
    // start at the end of the hive
    //
    Length = Hive->Storage[Stable].Length - HBLOCK_SIZE;

    while(Length >= 0) {
        //
        // get the bin
        //
        Me = HvpGetCellMap(Hive, Length);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Length);

        if( !(Me->BinAddress & HMAP_INPAGEDPOOL) ) {
            //
            // bail out; we are interested only in bins allocated from paged pool
            //
            break;
        }

        if(Me->BinAddress & HMAP_DISCARDABLE) {
            //
            // bin is discardable, skip it !
            //
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            Length = FreeBin->FileOffset - HBLOCK_SIZE;
            continue;
        }

        Address = HBIN_BASE(Me->BinAddress);
        Bin = (PHBIN)Address;

        // sanity
        ASSERT( Bin->Signature == HBIN_SIGNATURE );

        //
        // advance (backward) to the previous bin
        //
        Length = Bin->FileOffset - HBLOCK_SIZE;

        //
        // finaly, see if we can free it;
        // 
        if( HvpCheckViewBoundary(Bin->FileOffset,Bin->FileOffset + Bin->Size - 1) ) {
            //
            // free its storage and mark the map accordingly;
            // next attempt to read a cell from this bin will map a view.
            //
            Offset = Bin->FileOffset;
            while( Offset < (LONG)(Bin->FileOffset + Bin->Size) ) {
                Me = HvpGetCellMap(Hive, Offset);
                VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);
                ASSERT_BIN_INPAGEDPOOL(Me);
                //
                // clear off the HMAP_INPAGEDPOOL flag
                //
                Me->BinAddress &= ~HMAP_INPAGEDPOOL;
                if( (ULONG)Offset == Bin->FileOffset ) {
#if DBG
                    if( Check == TRUE ) {
                        // should already be tagged
                        ASSERT( Me->BinAddress & HMAP_NEWALLOC );
                    }
#endif
                    //
                    // tag it as a new alloc, so we can rely on this flag in CmpMapCmView
                    //
                    Me->BinAddress |= HMAP_NEWALLOC;
                } else {
                    //
                    // remove the NEWALLOC flag (if any), so we can rely on this flag in CmpMapCmView
                    //
                    Me->BinAddress &= ~HMAP_NEWALLOC;
                }

                // advance to the next HBLOCK_SIZE of this bin
                Offset += HBLOCK_SIZE;
            }
            //
            // free the bin
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Dropping temporary bin (from paged pool) at offset %lx size %lx\n",Bin->FileOffset,Bin->Size));
            if( HvpGetBinMemAlloc(Hive,Bin,Stable) ) {
                CmpFree(Bin, HvpGetBinMemAlloc(Hive,Bin,Stable));
            }
            UnMap = TRUE;

        } else {
            //
            // this bin has a good reason to reside in page-pool (it's crossing the boundaries).
            // leave it like that !
            //
            NOTHING;
        }
    
    }

    if( UnMap == TRUE ) {
        //
        // unmap the last view, to make sure the map will be updated
        //

        ASSERT( Length >= -HBLOCK_SIZE );

        Offset = (Length + HBLOCK_SIZE) & (~(CM_VIEW_SIZE - 1));
        if( Offset != 0 ) {
            //
            // account for the header
            //
            Offset -= HBLOCK_SIZE;
        }
        Length = Hive->Storage[Stable].Length;
        while( Offset < Length ) {
            Me = HvpGetCellMap(Hive, Offset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);

            if( Me->BinAddress & HMAP_INVIEW ) {
                //
                // get this view and unmap it; then bail out.
                //
                CmpUnmapCmView( (PCMHIVE)Hive,Me->CmView,TRUE,TRUE);
                break;
            }

            // next, please ?
            Offset += HBLOCK_SIZE;
        }
    }
    
    CmUnlockHiveViews((PCMHIVE)Hive);
}

VOID
HvpDropAllPagedBins(
    IN PHHIVE   Hive
    )

/*++

Routine Description:

        Works as HvpDropPagedBins, only that it iterates through
        the entire hive. No views are mapped at this point.

Arguments:

    Hive - Supplies the hive to operate on..


Return Value:

    None.

--*/

{
    ULONG_PTR   Address;
    ULONG       Length;
    ULONG       Offset;
    PHMAP_ENTRY Me;
    PHBIN       Bin;
    PFREE_HBIN  FreeBin;

    PAGED_CODE();

    if( (Hive->Storage[Stable].Length == 0) ||  // empty hive
        (((PCMHIVE)Hive)->FileObject == NULL)     // or hive not using the mapped views technique
        ) {
        return;
    }
        ASSERT( (((PCMHIVE)Hive)->MappedViews == 0) && (((PCMHIVE)Hive)->PinnedViews == 0) && (((PCMHIVE)Hive)->UseCount == 0) );

    //
    // start at the end of the hive
    //
    Length = Hive->Storage[Stable].Length - HBLOCK_SIZE;
    Offset = 0;

    while( Offset < Length ) {
        //
        // get the bin
        //
        Me = HvpGetCellMap(Hive, Offset);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);

        ASSERT( Me->BinAddress & HMAP_INPAGEDPOOL );

        if(Me->BinAddress & HMAP_DISCARDABLE) {
            //
            // bin is discardable, skip it !
            //
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
                        ASSERT( Offset == FreeBin->FileOffset );
            Offset += FreeBin->Size;
            continue;
        }

        Address = HBIN_BASE(Me->BinAddress);
        Bin = (PHBIN)Address;

        // sanity
        ASSERT( Bin->Signature == HBIN_SIGNATURE );

        //
        // finaly, see if we can free it;
        // 
        if( HvpCheckViewBoundary(Bin->FileOffset,Bin->FileOffset + Bin->Size - 1) ) {
            //
            // free its storage and mark the map accordingly;
            // next attempt to read a cell from this bin will map a view.
            //
            Offset = Bin->FileOffset;
            while( Offset < (Bin->FileOffset + Bin->Size) ) {
                Me = HvpGetCellMap(Hive, Offset);
                VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);
                ASSERT_BIN_INPAGEDPOOL(Me);
                //
                // clear off the HMAP_INPAGEDPOOL flag
                //
                Me->BinAddress &= ~HMAP_INPAGEDPOOL;
                if( (ULONG)Offset == Bin->FileOffset ) {
                    //
                    // tag it as a new alloc, so we can rely on this flag in CmpMapCmView
                    //
                    Me->BinAddress |= HMAP_NEWALLOC;
                } else {
                    //
                    // remove the NEWALLOC flag (if any), so we can rely on this flag in CmpMapCmView
                    //
                    Me->BinAddress &= ~HMAP_NEWALLOC;
                }

                // advance to the next HBLOCK_SIZE of this bin
                Offset += HBLOCK_SIZE;
            }
            //
            // free the bin
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Dropping temporary bin (from paged pool) at offset %lx size %lx\n",Bin->FileOffset,Bin->Size));
            if( HvpGetBinMemAlloc(Hive,Bin,Stable) ) {
                CmpFree(Bin, HvpGetBinMemAlloc(Hive,Bin,Stable));
            }

        } else {
            //
            // this bin has a good reason to reside in page-pool (it's crossing the boundaries).
            // leave it like that !
            //
                        Offset += Bin->Size;
        }
    }
}

NTSTATUS
HvWriteHive(
    PHHIVE          Hive,
    BOOLEAN         DontGrow,
    BOOLEAN         WriteThroughCache,
    BOOLEAN         CrashSafe
    )
/*++

Routine Description:

    Write the hive out.  Write only to the Primary file, neither
    logs nor alternates will be updated.  The hive will be written
    to the HFILE_TYPE_EXTERNAL handle.

    Intended for use in applications like SaveKey.

    Only Stable storage will be written (as for any hive.)

    Presumption is that layer above has set HFILE_TYPE_EXTERNAL
    handle to point to correct place.

    Applying this call to an active hive will generally hose integrity
    measures.

    HOW IT WORKS:

        Saves the BaseBlock.

        Iterates through the entire hive and save it bin by bin

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest.

        DontGrow - we know that the file is big enough, don't attempt to grow it.

Return Value:

    Status.

--*/
{
    PHBASE_BLOCK    BaseBlock;
    NTSTATUS        status;
    ULONG           Offset;
    PHBIN           Bin = NULL;
    PFREE_HBIN      FreeBin = NULL;
    ULONG           BinSize;
    PVOID           Address;
    ULONG           BinOffset;
    ULONG           Length;
    CMP_OFFSET_ARRAY offsetElement;
    PHMAP_ENTRY     Me;
    PHCELL          FirstCell;
    BOOLEAN         rc;
    PCM_VIEW_OF_FILE CmView = NULL;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvWriteHive: \n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tHive = %p\n"));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);


    //
    // Punt if post shutdown
    //
    if (HvShutdownComplete) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"HvWriteHive: Attempt to write hive AFTER SHUTDOWN\n"));
        return STATUS_REGISTRY_IO_FAILED;
    }

    Length = Hive->Storage[Stable].Length;

    //
    // we should never come to this
    //
    ASSERT( Length != 0 );
    ASSERT( Hive->BaseBlock->RootCell != HCELL_NIL );


    if( !DontGrow ){
                
        //
        // Ensure the file can be made big enough, then do the deed
        //
        status = CmpDoFileSetSize(Hive,
                                  HFILE_TYPE_EXTERNAL,
                                  Length + HBLOCK_SIZE,
                                  0);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
    BaseBlock = Hive->BaseBlock;
    //
    // --- Write out header first time ---
    //
    ASSERT(BaseBlock->Signature == HBASE_BLOCK_SIGNATURE);
    ASSERT(BaseBlock->Major == HSYS_MAJOR);
    ASSERT(BaseBlock->Format == HBASE_FORMAT_MEMORY);
    ASSERT(Hive->ReadOnly == FALSE);


    if (BaseBlock->Sequence1 != BaseBlock->Sequence2) {

        //
        // Some previous log attempt failed, or this hive needs to
        // be recovered, so punt.
        //
        return STATUS_REGISTRY_IO_FAILED;
    }

    if( CrashSafe ) {
        //
        // change sequence numbers, in case we experience a machine crash
        //
        BaseBlock->Sequence1++;
    }
    BaseBlock->Length = Length;
    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;

    if(WriteThroughCache) {
        //
        // if we use Cc, do the write with the pin interface
        //
        rc = CmpFileWriteThroughCache(  Hive,
                                        HFILE_TYPE_EXTERNAL,
                                        &offsetElement,
                                        1);
                Offset += offsetElement.DataLength;
    } else {
        rc = (Hive->FileWrite)( Hive,
                                HFILE_TYPE_EXTERNAL,
                                &offsetElement,
                                1,
                                &Offset );
    }

    if (rc == FALSE) {
        return STATUS_REGISTRY_IO_FAILED;
    }
    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        return STATUS_REGISTRY_IO_FAILED;
    }
    Offset = ROUND_UP(Offset, HBLOCK_SIZE);

    //
    // --- Write out data (ALL !!!) ---
    //
    BinOffset = 0;
    while (BinOffset < Hive->Storage[Stable].Length) {
        //
        // we need to grab the viewlock here to protect against a racing HvGetCell
        //
        CmLockHiveViews ((PCMHIVE)Hive);
        Me = HvpGetCellMap(Hive, BinOffset);
       
        if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0) {
            //
            // view is not mapped, neither in paged pool try to map it.
                        //
            if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,BinOffset,TRUE)) ) {
                CmUnlockHiveViews ((PCMHIVE)Hive);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }
        }
        //
        // reference the view so it doesn't go away from under us;
        // first remove any old ref
        //
        if( Me->BinAddress & HMAP_INVIEW ) {
            CmpDereferenceHiveView((PCMHIVE)Hive,CmView);
            CmpReferenceHiveView((PCMHIVE)Hive,CmView = Me->CmView);
        }
        CmUnlockHiveViews ((PCMHIVE)Hive);

        if( Me->BinAddress & HMAP_DISCARDABLE ) {
            //
            // bin is discardable. If it is not discarded yet, save it as it is
            // else, allocate, initialize and save a fake bin
            //
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            BinSize = FreeBin->Size;
            if( FreeBin->Flags & FREE_HBIN_DISCARDABLE ){ 
                //
                // HBIN still in memory
                //
                Address = (PVOID)HBIN_BASE(Me->BinAddress);
            } else {
                //
                // HBIN discarded, we have to allocate a new bin and mark it as a 
                // BIG free cell
                //
                // don't charge quota for it as we will give it back
                Bin = (PHBIN)ExAllocatePoolWithTag(PagedPool, BinSize, CM_HVBIN_TAG);
                if( Bin == NULL ){
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }
                //
                // Initialize the bin
                //
                Bin->Signature = HBIN_SIGNATURE;
                Bin->FileOffset = BinOffset;
                Bin->Size = BinSize;
                FirstCell = (PHCELL)(Bin+1);
                FirstCell->Size = BinSize - sizeof(HBIN);
                if (USE_OLD_CELL(Hive)) {
                    FirstCell->u.OldCell.Last = (ULONG)HBIN_NIL;
                }
                Address = (PVOID)Bin;
            }
        } else {
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            ASSERT( Bin->Signature == HBIN_SIGNATURE );
            ASSERT( Bin->FileOffset == BinOffset );
            Address = (PVOID)Bin;
            try {
                BinSize = Bin->Size;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // in low-memory scenarios or disk error, touching the bin may throw STATUS_IN_PAGE_ERROR
                //
                status = GetExceptionCode();
                goto ErrorExit;
            }
        }

        //
        // write the bin to the file
        //
        offsetElement.FileOffset = Offset;
        offsetElement.DataBuffer = Address;
        offsetElement.DataLength = BinSize;

        if(WriteThroughCache) {
            
            //
            // if we use Cc, do the write with the pin interface
            // Take extra care not to cross the view boundaries
            //

            if( HvpCheckViewBoundary(Offset - HBLOCK_SIZE,Offset - HBLOCK_SIZE + BinSize - 1) ) {
                rc = CmpFileWriteThroughCache( Hive,
                                               HFILE_TYPE_EXTERNAL,
                                               &offsetElement,
                                               1);
            } else {
                //
                // write one HBLOCK_SIZE at a time.
                //
                ULONG   ToWrite = BinSize;
                offsetElement.DataLength = HBLOCK_SIZE;
                while( ToWrite > 0 ) {
                    rc = CmpFileWriteThroughCache( Hive,
                                                   HFILE_TYPE_EXTERNAL,
                                                   &offsetElement,
                                                   1);
                    if( rc == FALSE ) {
                        status = STATUS_REGISTRY_IO_FAILED;
                        goto ErrorExit;
                    }
                   
                    ToWrite -= HBLOCK_SIZE;
                    offsetElement.DataBuffer = (PUCHAR)offsetElement.DataBuffer + HBLOCK_SIZE;
                    offsetElement.FileOffset += HBLOCK_SIZE;
                }
            }
            Offset += BinSize;
        } else {
            rc = (Hive->FileWrite)( Hive,
                                    HFILE_TYPE_EXTERNAL,
                                    &offsetElement,
                                    1,
                                    &Offset );
        }
        if (rc == FALSE) {
            status = STATUS_REGISTRY_IO_FAILED;
            goto ErrorExit;
        }

        if( Me->BinAddress & HMAP_DISCARDABLE ) {
            if( (FreeBin->Flags & FREE_HBIN_DISCARDABLE) == 0){ 
                ASSERT( FreeBin == (PFREE_HBIN)Me->BlockAddress );
                ASSERT( Bin );
                //
                // give back the paged pool used
                //
                ExFreePool(Bin);
            }
        }

        //
        // advance to the next bin
        //
        BinOffset += BinSize;

    }
    //
    // let go last view referenced (if any)
    //
    CmpDereferenceHiveViewWithLock((PCMHIVE)Hive,CmView);

    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        return STATUS_REGISTRY_IO_FAILED;
    }

    if( CrashSafe ) {
        //
        // change sequence numbers, in case we experience a machine crash
        //
        BaseBlock->Sequence2++;
        BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);

        ASSERT( BaseBlock->Sequence1 == BaseBlock->Sequence2 );

        Offset = 0;
        offsetElement.FileOffset = Offset;
        offsetElement.DataBuffer = (PVOID) BaseBlock;
        offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
        if(WriteThroughCache) {
            //
            // if we use Cc, do the write with the pin interface
            //
            rc = CmpFileWriteThroughCache( Hive,
                                           HFILE_TYPE_EXTERNAL,
                                           &offsetElement,
                                           1);
                    Offset += offsetElement.DataLength;
        } else {
            rc = (Hive->FileWrite)( Hive,
                                    HFILE_TYPE_EXTERNAL,
                                    &offsetElement,
                                    1,
                                    &Offset );
        }

        if (rc == FALSE) {
            return STATUS_REGISTRY_IO_FAILED;
        }
        if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_EXTERNAL,NULL,0)) {
            return STATUS_REGISTRY_IO_FAILED;
        }
        if( DontGrow ){
            //
            // file has shrunk
            //
            CmpDoFileSetSize(Hive,HFILE_TYPE_EXTERNAL,Length + HBLOCK_SIZE,0);
        }
    }

    // it seems like everything went OK
    return STATUS_SUCCESS;
ErrorExit:
    CmpDereferenceHiveViewWithLock((PCMHIVE)Hive,CmView);
    return status;
}

#ifdef CM_ENABLE_WRITE_ONLY_BINS
VOID HvpMarkAllBinsWriteOnly(IN PHHIVE Hive)
{
    HCELL_INDEX p;
    ULONG       Length;
    PHMAP_ENTRY t;
    PHBIN       Bin;
    ULONG               i;
    PFREE_HBIN  FreeBin;

    p = 0;
        PAGED_CODE();

    Length = Hive->Storage[Stable].Length;

    //
    // for each bin in the stable storage
    //
    while (p < Length) {
        t = HvpGetCellMap(Hive, p);
        VALIDATE_CELL_MAP(__LINE__,t,Hive,p);
        if( (t->BinAddress &HMAP_INPAGEDPOOL) == 0) {
            //
            // at this point we only work with paged pool bins
            //
            break;        
        }

        if ((t->BinAddress & HMAP_DISCARDABLE) == 0) {

            Bin = (PHBIN)HBIN_BASE(t->BinAddress);

            for( i=0;i<Bin->Size;i += PAGE_SIZE ) {
                if( !MmProtectSpecialPool((PUCHAR)Bin + i,PAGE_READONLY) ) {
                    DbgPrint("Failed to set READONLY protection on page at %p Bin %p size = %lx\n",Bin+i,Bin,Bin->Size);
                }
            }

/*
            if( !MmSetPageProtection(Bin,Bin->Size,PAGE_READONLY) ) {
                DbgPrint("Failed to set READONLY protection on bin at %p size = %lx\n",Bin,Bin->Size);
            }
*/
            p = (ULONG)p + Bin->Size;

        } else {
            //
            // Bin is not present, skip it and advance to the next one.
            //
            FreeBin = (PFREE_HBIN)t->BlockAddress;
            p+=FreeBin->Size;
        }
    }
}

#endif //CM_ENABLE_WRITE_ONLY_BINS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\ntapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntapi.c

Abstract:

    This module contains the NT level entry points for the registry.

Author:

    Bryan M. Willman (bryanwi) 26-Aug-1991

Revision History:

   Elliot Shmukler (t-ellios) 24-Aug-1998

      Modified NtInitializeRegistry to handle the LKG work that needs
      to be done when a boot is accepted by SC.

--*/

#include "cmp.h"
#include "safeboot.h"
#include <evntrace.h>

extern POBJECT_TYPE ExEventObjectType;

extern POBJECT_TYPE CmpKeyObjectType;

extern BOOLEAN CmFirstTime;
extern BOOLEAN CmBootAcceptFirstTime;
extern BOOLEAN CmpHoldLazyFlush;
extern BOOLEAN CmpCannotWriteConfiguration;

extern BOOLEAN CmpTraceFlag;

extern BOOLEAN HvShutdownComplete;

#ifdef CMP_STATS

extern struct {
    ULONG       CmpMaxKcbNo;
    ULONG       CmpKcbNo;
    ULONG       CmpStatNo;
    ULONG       CmpNtCreateKeyNo;
    ULONG       CmpNtDeleteKeyNo;
    ULONG       CmpNtDeleteValueKeyNo;
    ULONG       CmpNtEnumerateKeyNo;
    ULONG       CmpNtEnumerateValueKeyNo;
    ULONG       CmpNtFlushKeyNo;
    ULONG       CmpNtNotifyChangeMultipleKeysNo;
    ULONG       CmpNtOpenKeyNo;
    ULONG       CmpNtQueryKeyNo;
    ULONG       CmpNtQueryValueKeyNo;
    ULONG       CmpNtQueryMultipleValueKeyNo;
    ULONG       CmpNtRestoreKeyNo;
    ULONG       CmpNtSaveKeyNo;
    ULONG       CmpNtSaveMergedKeysNo;
    ULONG       CmpNtSetValueKeyNo;
    ULONG       CmpNtLoadKeyNo;
    ULONG       CmpNtUnloadKeyNo;
    ULONG       CmpNtSetInformationKeyNo;
    ULONG       CmpNtReplaceKeyNo;
    ULONG       CmpNtQueryOpenSubKeysNo;
} CmpStatsDebug;

ULONG       CmpNtFakeCreate = 0;
BOOLEAN     CmpNtFakeCreateStarted;

#endif

//
// Nt API helper routines
//
NTSTATUS
CmpNameFromAttributes(
    IN POBJECT_ATTRIBUTES Attributes,
    KPROCESSOR_MODE PreviousMode,
    OUT PUNICODE_STRING FullName
    );

ULONG
CmpKeyInfoProbeAlingment(
                             IN KEY_INFORMATION_CLASS KeyInformationClass
                        );


#ifdef POOL_TAGGING

#define ALLOCATE_WITH_QUOTA(a,b,c) ExAllocatePoolWithQuotaTag((a)|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,b,c)

#else

#define ALLOCATE_WITH_QUOTA(a,b,c) ExAllocatePoolWithQuota((a)|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,b)

#endif

#if DBG

ULONG
CmpExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpExceptionFilter)
#endif
#else

#define CmpExceptionFilter(x) EXCEPTION_EXECUTE_HANDLER

#endif

#ifdef  REGISTRY_LOCK_CHECKING
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpCheckLockExceptionFilter)
#endif

ULONG
CmpCheckLockExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
{
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CM: Registry exception %lx, ExceptionPointers = %p\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers));

    CM_BUGCHECK(REGISTRY_ERROR,CHECK_LOCK_EXCEPTION,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord,
        (ULONG_PTR)ExceptionPointers->ContextRecord);

    return EXCEPTION_EXECUTE_HANDLER;
}
#endif //REGISTRY_LOCK_CHECKING

VOID
CmpFlushNotifiesOnKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK   kcb
    );

#if 0
BOOLEAN
CmpEnumKeyObjectCallback(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG HandleCount,
    IN ULONG PointerCount,
    IN PVOID Context
    );

#endif

VOID
CmpDummyApc(
    struct _KAPC *Apc,
    PVOID *SystemArgument1,
    PVOID *SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtCreateKey)
#pragma alloc_text(PAGE,NtDeleteKey)
#pragma alloc_text(PAGE,NtDeleteValueKey)
#pragma alloc_text(PAGE,NtEnumerateKey)
#pragma alloc_text(PAGE,NtEnumerateValueKey)
#pragma alloc_text(PAGE,NtFlushKey)
#pragma alloc_text(PAGE,NtInitializeRegistry)
#pragma alloc_text(PAGE,NtNotifyChangeKey)
#pragma alloc_text(PAGE,NtNotifyChangeMultipleKeys)
#pragma alloc_text(PAGE,NtOpenKey)
#pragma alloc_text(PAGE,NtQueryKey)
#pragma alloc_text(PAGE,NtQueryValueKey)
#pragma alloc_text(PAGE,NtQueryMultipleValueKey)
#pragma alloc_text(PAGE,NtRestoreKey)
#pragma alloc_text(PAGE,NtSaveKey)
#pragma alloc_text(PAGE,NtSaveKeyEx)
#pragma alloc_text(PAGE,NtSaveMergedKeys)
#pragma alloc_text(PAGE,NtSetValueKey)
#pragma alloc_text(PAGE,NtLoadKey)
#pragma alloc_text(PAGE,NtLoadKey2)
#pragma alloc_text(PAGE,NtUnloadKey)

#ifdef NT_UNLOAD_KEY_EX
#pragma alloc_text(PAGE,NtUnloadKeyEx)
#endif

#pragma alloc_text(PAGE,NtSetInformationKey)
#pragma alloc_text(PAGE,NtReplaceKey)

#ifdef NT_RENAME_KEY
#pragma alloc_text(PAGE,NtRenameKey)
#endif

#pragma alloc_text(PAGE,NtQueryOpenSubKeys)

#pragma alloc_text(PAGE,NtLockRegistryKey)

#pragma alloc_text(PAGE,CmpNameFromAttributes)
#pragma alloc_text(PAGE,CmpAllocatePostBlock)
#pragma alloc_text(PAGE,CmpFreePostBlock)
#pragma alloc_text(PAGE,CmpKeyInfoProbeAlingment)

#if 0
#pragma alloc_text(PAGE,CmpEnumKeyObjectCallback)
#endif

#pragma alloc_text(PAGE,NtCompactKeys)
#pragma alloc_text(PAGE,NtCompressKey)
#endif

//
// Nt level registry API calls
//

NTSTATUS
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    KeyHandle - Receives a Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory is
        specified, the name is relative to the root.  The name of the
        object must be within the name space allocated to the Registry,
        that is, all names beginning "\Registry".  RootHandle, if
        present, must be a handle to "\", or "\Registry", or a key
        under "\Registry".

        RootHandle must have been opened for KEY_CREATE_SUB_KEY access
        if a new node is to be created.

        NOTE:   Object manager will capture and probe this argument.

    TitleIndex - Specifies the index of the localized alias for
        the name of the key.  The title index specifies the index of
        the localized alias for the name.  Ignored if the key
        already exists.

    Class - Specifies the object class of the key.  (To the registry
        this is just a string.)  Ignored if NULL.

    CreateOptions - Optional control values:

        REG_OPTION_VOLATILE - Object is not to be stored across boots.

    Disposition - This optional parameter is a pointer to a variable
        that will receive a value indicating whether a new Registry
        key was created or an existing one opened:

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS            status;
    KPROCESSOR_MODE     mode;
    CM_PARSE_CONTEXT    ParseContext;
    PCM_KEY_BODY        KeyBody;
    HANDLE              Handle = 0;
    UNICODE_STRING      CapturedObjectName = {0};

    // Start registry call tracing
    StartWmiCmTrace();

#if !defined(BUILD_WOW6432)
    DesiredAccess &= (~KEY_WOW64_RES); // filter out wow64 specific access
#endif

    PAGED_CODE();

    if( HvShutdownComplete == TRUE ) {
        //
        // It is forbidden to wite to the registry after it has been shutdown
        //
        if(PoCleanShutdownEnabled() & PO_CLEAN_SHUTDOWN_REGISTRY){
            //
            // if in clean shutdown mode all processes should have been killed and all drivers unloaded at this point
            //
            CM_BUGCHECK(REGISTRY_ERROR,INVALID_WRITE_OPERATION,1,ObjectAttributes,0);
        }
#ifndef _CM_LDR_
        {
            PUCHAR  ImageName = PsGetCurrentProcessImageFileName();
            if( !ImageName ) {
                ImageName = "Unknown";
            }
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\n\nProcess.Thread : %p.%p (%s) is trying to create key: \n",
                                                    PsGetCurrentProcessId(), PsGetCurrentThreadId(),ImageName);
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tObjectAttributes = %p\n",ObjectAttributes);
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"The caller should not rely on data written to the registry after shutdown...\n");
        }
#endif //_CM_LDR_
        return STATUS_TOO_LATE;
    }

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtCreateKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtCreateKey\n"));

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tDesiredAccess=%08lx ", DesiredAccess));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tCreateOptions=%08lx\n", CreateOptions));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tObjectAttributes=%p\n", ObjectAttributes));

    mode = KeGetPreviousMode();

    try {

        ParseContext.Class.Length = 0;
        ParseContext.Class.Buffer = NULL;

        if (mode == UserMode) {

            if (ARGUMENT_PRESENT(Class)) {
                ParseContext.Class = ProbeAndReadUnicodeString(Class);
                ProbeForRead(
                    ParseContext.Class.Buffer,
                    ParseContext.Class.Length,
                    sizeof(WCHAR)
                    );
            }
            ProbeAndZeroHandle(KeyHandle);

            if (ARGUMENT_PRESENT(Disposition)) {
                ProbeForWriteUlong(Disposition);
            }

            //
            // probe the ObjectAttributes as we shall use it for tracing
            //
            ProbeForReadSmallStructure( ObjectAttributes,
                                        sizeof(OBJECT_ATTRIBUTES),
                                        PROBE_ALIGNMENT(OBJECT_ATTRIBUTES) );
            CapturedObjectName = ProbeAndReadUnicodeString(ObjectAttributes->ObjectName);
            ProbeForRead(
                CapturedObjectName.Buffer,
                CapturedObjectName.Length,
                sizeof(WCHAR)
                );
        } else {

            if (ARGUMENT_PRESENT(Class)) {
                ParseContext.Class = *Class;
            }
            CapturedObjectName = *(ObjectAttributes->ObjectName);
        }

        //
        // be sure nobody will hurt himself when adding new options
        //
        ASSERT( (REG_LEGAL_OPTION & REG_OPTION_PREDEF_HANDLE) == 0 );

        if ((CreateOptions & (REG_LEGAL_OPTION | REG_OPTION_PREDEF_HANDLE)) != CreateOptions) {

            // End registry call tracing
            EndWmiCmTrace(STATUS_INVALID_PARAMETER,0,&CapturedObjectName,EVENT_TRACE_TYPE_REGCREATE);

            return STATUS_INVALID_PARAMETER;
        }

#ifdef CMP_STATS
        CmpNtFakeCreateStarted = TRUE;
#endif

        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(ObjectAttributes->RootDirectory);

        ParseContext.TitleIndex = 0;
        ParseContext.CreateOptions = CreateOptions;
        ParseContext.Disposition = 0L;
        ParseContext.CreateLink = FALSE;
        ParseContext.PredefinedHandle = NULL;

        status = ObOpenObjectByName(
                    ObjectAttributes,
                    CmpKeyObjectType,
                    mode,
                    NULL,
                    DesiredAccess,
                    (PVOID)&ParseContext,
                    &Handle
                    );

        if (status==STATUS_PREDEFINED_HANDLE) {
            status = ObReferenceObjectByHandle(Handle,
                                               0,
                                               CmpKeyObjectType,
                                               KernelMode,
                                               (PVOID *)(&KeyBody),
                                               NULL);
            if (NT_SUCCESS(status)) {
                HANDLE TempHandle;

                //
                // Make sure we do the dereference and close before accessing
                // user space as the reference might fault.
                //
                TempHandle = (HANDLE)LongToHandle(KeyBody->Type);
                ObDereferenceObject((PVOID)KeyBody);
                NtClose(Handle);
                Handle = *KeyHandle = TempHandle;
                status = STATUS_SUCCESS;
            }
        } else
        if (NT_SUCCESS(status)) {
            *KeyHandle = Handle;
            // need to do this only on clean shutdown
            CmpAddKeyTracker(Handle,mode);
        }

        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = ParseContext.Disposition;
        }

    } except (CmpExceptionFilter(GetExceptionInformation())) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtCreateKey: code:%08lx\n", GetExceptionCode()));
        status = GetExceptionCode();
    }

#ifdef CMP_STATS
    CmpNtFakeCreateStarted = FALSE;
#endif

    // End registry call tracing
    EndWmiCmTrace(status,0,&CapturedObjectName,EVENT_TRACE_TYPE_REGCREATE);

    return  status;
}

extern PCM_KEY_BODY ExpControlKey[2];

//
// WARNING: This should be the same as the one defined in obp.h
//          Remove this one when object manager guys will export
//          this via ob.h
//
#define OBJ_AUDIT_OBJECT_CLOSE 0x00000004L

NTSTATUS
NtDeleteKey(
    IN HANDLE KeyHandle
    )
/*++

Routine Description:

    A registry key may be marked for delete, causing it to be removed
    from the system.  It will remain in the name space until the last
    handle to it is closed.

Arguments:

    KeyHandle - Specifies the handle of the Key to delete, must have
        been opened for DELETE access.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    PCM_KEY_BODY                KeyBody;
    NTSTATUS                    status;
    OBJECT_HANDLE_INFORMATION   HandleInfo;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtDeleteKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtDeleteKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));

    status = ObReferenceObjectByHandle(KeyHandle,
                                       DELETE,
                                       CmpKeyObjectType,
                                       KeGetPreviousMode(),
                                       (PVOID *)(&KeyBody),
                                       &HandleInfo);

    if (NT_SUCCESS(status)) {

        if( CmAreCallbacksRegistered() ) {
            REG_DELETE_KEY_INFORMATION DeleteInfo;
        
            DeleteInfo.Object = KeyBody;
            status = CmpCallCallBacks(RegNtDeleteKey,&DeleteInfo);
            if( !NT_SUCCESS(status) ) {
                ObDereferenceObject((PVOID)KeyBody);
                return status;
            }
        }
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        //
        // Silently fail deletes of setup key and productoptions key
        //
        if ( (ExpControlKey[0] && KeyBody->KeyControlBlock == ExpControlKey[0]->KeyControlBlock) ||
             (ExpControlKey[1] && KeyBody->KeyControlBlock == ExpControlKey[1]->KeyControlBlock) ) {
            ObDereferenceObject((PVOID)KeyBody);

            // End registry call tracing
            EndWmiCmTrace(status,0,NULL,EVENT_TRACE_TYPE_REGDELETE);

            return STATUS_SUCCESS;
        }

        if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ||
            CmIsKcbReadOnly(KeyBody->KeyControlBlock->ParentKcb) ) {
            //
            // key is protected
            //
            status = STATUS_ACCESS_DENIED;
        } else {
            BEGIN_LOCK_CHECKPOINT;
            status = CmDeleteKey(KeyBody);
            END_LOCK_CHECKPOINT;
        }

        if (NT_SUCCESS(status)) {
            //
            // Audit the deletion
            //

            if ( HandleInfo.HandleAttributes & OBJ_AUDIT_OBJECT_CLOSE ) {
                SeDeleteObjectAuditAlarm(KeyBody,
                                         KeyHandle );
            }
        }

        ObDereferenceObject((PVOID)KeyBody);
    }

    // End registry call tracing
    EndWmiCmTrace(status,0,NULL,EVENT_TRACE_TYPE_REGDELETE);

    return status;
}


NTSTATUS
NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    )
/*++

Routine Description:

    One of the value entries of a registry key may be removed with this
    call.  To remove the entire key, call NtDeleteKey.

    The value entry with ValueName matching ValueName is removed from the key.
    If no such entry exists, an error is returned.

Arguments:

    KeyHandle - Specifies the handle of the key containing the value
        entry of interest.  Must have been opend for KEY_SET_VALUE access.

    ValueName - The name of the value to be deleted.  NULL is a legal name.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;
    UNICODE_STRING  LocalValueName;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtDeleteValueKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtDeleteValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tValueName='%wZ'\n", ValueName));

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_SET_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {

        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (mode == UserMode) {
                LocalValueName = ProbeAndReadUnicodeString(ValueName);
                ProbeForRead(
                    LocalValueName.Buffer,
                    LocalValueName.Length,
                    sizeof(WCHAR)
                    );
            } else {
                LocalValueName = *ValueName;
            }

            if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                //
                // key is protected
                //
                status = STATUS_ACCESS_DENIED;
            } else {
                if( CmAreCallbacksRegistered() ) {
                    REG_DELETE_VALUE_KEY_INFORMATION DeleteInfo;
            
                    DeleteInfo.Object = KeyBody;
                    DeleteInfo.ValueName = &LocalValueName;
                    status = CmpCallCallBacks(RegNtDeleteValueKey,&DeleteInfo);
                }

                if( NT_SUCCESS(status) ) {
                    BEGIN_LOCK_CHECKPOINT;
                    status = CmDeleteValueKey(
                                KeyBody->KeyControlBlock,
                                LocalValueName
                                );
                    END_LOCK_CHECKPOINT;
                }
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtDeleteValueKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        ObDereferenceObject((PVOID)KeyBody);
    } else {
        LocalValueName.Buffer = NULL;
        LocalValueName.Length = 0;
    }

    // End registry call tracing
    EndWmiCmTrace(status,0,&LocalValueName,EVENT_TRACE_TYPE_REGDELETEVALUE);

    return status;
}


NTSTATUS
NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The sub keys of an open key may be enumerated with NtEnumerateKey.

    NtEnumerateKey returns the name of the Index'th sub key of the open
    key specified by KeyHandle.  The value STATUS_NO_MORE_ENTRIES will be
    returned if value of Index is larger than the number of sub keys.

    Note that Index is simply a way to select among child keys.  Two calls
    to NtEnumerateKey with the same Index are NOT guaranteed to return
    the same results.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose sub keys are to be enumerated.  Must
        be open for KEY_ENUMERATE_SUB_KEY access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtEnumerateKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtEnumerateKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx Index=%08lx\n", KeyHandle, Index));

    if ((KeyInformationClass != KeyBasicInformation) &&
        (KeyInformationClass != KeyNodeInformation)  &&
        (KeyInformationClass != KeyFullInformation))
    {
        //
        // hook the kcb for WMI
        //
        HookKcbFromHandleForWmiCmTrace(KeyHandle);

        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_PARAMETER,Index,NULL,EVENT_TRACE_TYPE_REGENUMERATEKEY);

        return STATUS_INVALID_PARAMETER;
    }

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_ENUMERATE_SUB_KEYS,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (mode == UserMode) {
                ProbeForWrite(
                    KeyInformation,
                    Length,
                    sizeof(ULONG)
                    );
                ProbeForWriteUlong(ResultLength);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtEnumerateKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        if( NT_SUCCESS(status)) {

            if( CmAreCallbacksRegistered() ) {
                REG_ENUMERATE_KEY_INFORMATION   EnumerateInfo;

                EnumerateInfo.Object = KeyBody;
                EnumerateInfo.Index = Index;
                EnumerateInfo.KeyInformationClass = KeyInformationClass;
                EnumerateInfo.KeyInformation = KeyInformation;
                EnumerateInfo.Length = Length;
                EnumerateInfo.ResultLength = ResultLength;
        
                status = CmpCallCallBacks(RegNtEnumerateKey,&EnumerateInfo);
            }

            if( NT_SUCCESS(status)) {
                //
                // CmEnumerateKey is protected to user mode buffer exceptions
                // all other exceptions are cm internals and should result in a bugcheck
                //
                BEGIN_LOCK_CHECKPOINT;
                status = CmEnumerateKey(
                            KeyBody->KeyControlBlock,
                            Index,
                            KeyInformationClass,
                            KeyInformation,
                            Length,
                            ResultLength
                            );
                END_LOCK_CHECKPOINT;
            }
        }


        ObDereferenceObject((PVOID)KeyBody);
    }

    // End registry call tracing
    EndWmiCmTrace(status,Index,NULL,EVENT_TRACE_TYPE_REGENUMERATEKEY);

    return status;
}


NTSTATUS
NtEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    )
/*++

Routine Description:

    The value entries of an open key may be enumerated
    with NtEnumerateValueKey.

    NtEnumerateValueKey returns the name of the Index'th value
    entry of the open key specified by KeyHandle.  The value
    STATUS_NO_MORE_ENTRIES will be returned if value of Index is
    larger than the number of sub keys.

    Note that Index is simply a way to select among value
    entries.  Two calls to NtEnumerateValueKey with the same Index
    are NOT guaranteed to return the same results.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose value entries are to be enumerated.
        Must have been opened with KEY_QUERY_VALUE access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyValueInformationClass - Specifies the type of information returned
    in Buffer. One of the following types:

        KeyValueBasicInformation - return time of last write,
            title index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write,
            title index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtEnumerateValueKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtEnumerateValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx Index=%08lx\n", KeyHandle, Index));

    if ((KeyValueInformationClass != KeyValueBasicInformation) &&
        (KeyValueInformationClass != KeyValueFullInformation)  &&
        (KeyValueInformationClass != KeyValuePartialInformation))
    {
        //
        // hook the kcb for WMI
        //
        HookKcbFromHandleForWmiCmTrace(KeyHandle);

        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_PARAMETER,Index,NULL,EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY);

        return STATUS_INVALID_PARAMETER;
    }

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_QUERY_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);


        try {
            if (mode == UserMode) {
                ProbeForWrite(
                    KeyValueInformation,
                    Length,
                    sizeof(ULONG)
                    );
                ProbeForWriteUlong(ResultLength);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtEnumerateValueKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        if( NT_SUCCESS(status)) {
            if( CmAreCallbacksRegistered() ) {
                REG_ENUMERATE_VALUE_KEY_INFORMATION   EnumerateValueInfo;
                
                EnumerateValueInfo.Object = KeyBody;
                EnumerateValueInfo.Index = Index;
                EnumerateValueInfo.KeyValueInformationClass = KeyValueInformationClass;
                EnumerateValueInfo.KeyValueInformation = KeyValueInformation;
                EnumerateValueInfo.Length = Length;
                EnumerateValueInfo.ResultLength = ResultLength;
        
                status = CmpCallCallBacks(RegNtEnumerateValueKey,&EnumerateValueInfo);
            }

            if( NT_SUCCESS(status)) {
                //
                // CmEnumerateValueKey is protected to user mode buffer exceptions
                // all other exceptions are cm internals and should result in a bugcheck
                //
                BEGIN_LOCK_CHECKPOINT;
                status = CmEnumerateValueKey(
                            KeyBody->KeyControlBlock,
                            Index,
                            KeyValueInformationClass,
                            KeyValueInformation,
                            Length,
                            ResultLength
                            );
                END_LOCK_CHECKPOINT;
            }
        }

        ObDereferenceObject((PVOID)KeyBody);
    }


    // End registry call tracing
    EndWmiCmTrace(status,Index,NULL,EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY);

    return status;
}


NTSTATUS
NtFlushKey(
    IN HANDLE KeyHandle
    )
/*++

Routine Description:

    Changes made by NtCreateKey or NtSetKey may be flushed to disk with
    NtFlushKey.

    NtFlushKey will not return to its caller until any changed data
    associated with KeyHandle has been written to permanent store.

    WARNING: NtFlushKey will flush the entire registry tree, and thus will
    burn cycles and I/O.

Arguments:

    KeyHandle - Handle of open key to be flushed.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    PCM_KEY_BODY   KeyBody;
    NTSTATUS    status;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtFlushKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtFlushKey\n"));

    status = ObReferenceObjectByHandle(
                KeyHandle,
                0,
                CmpKeyObjectType,
                KeGetPreviousMode(),
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistry();

        if (KeyBody->KeyControlBlock->Delete) {
            status = STATUS_KEY_DELETED;
        } else {
            //
            // call the worker to do the flush
            //
            status = CmFlushKey(KeyBody->KeyControlBlock->KeyHive, KeyBody->KeyControlBlock->KeyCell);
        }

        CmpUnlockRegistry();
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);
    }


    // End registry call tracing
    EndWmiCmTrace(status,0,NULL,EVENT_TRACE_TYPE_REGFLUSH);

    return status;
}


NTSTATUS
NtInitializeRegistry(
    IN USHORT BootCondition
    )
/*++

Routine Description:

    This routine is called in 2 situations:

    1) It is called from SM after autocheck (chkdsk) has
    run and the paging files have been opened.  It's function is
    to bind in memory hives to their files, and to open any other
    files yet to be used.

    2) It is called from SC after the current boot has been accepted
    and the control set used for the boot process should be saved
    as the LKG control set.

    After this routine accomplishes the work of situation #1 and
      #2, further requests for such work will not be carried out.

Arguments:

    BootCondition -

         REG_INIT_BOOT_SM -     The routine has been called from SM
                                in situation #1.

         REG_INIT_BOOT_SETUP -  The routine has been called to perform
                                situation #1 work but has been called
                                from setup and needs to do some special
                                work.

        REG_INIT_BOOT_ACCEPTED_BASE + Num
                        (where 0 < Num < 1000) - The routine has been called
                                                 in situation #2. "Num" is the
                                                 number of the control set
                                                 to which the boot control set
                                                 should be saved.

Return Value:

    NTSTATUS - Result code from call, among the following:

        STATUS_SUCCESS - it worked
        STATUS_ACCESS_DENIED - the routine has already done the work
                               requested and will not do it again.

--*/
{
    BOOLEAN     SetupBoot;
    NTSTATUS    Status;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtInitializeRegistry()\n"));

    //
    // Force previous mode to be KernelMode
    //
    if (KeGetPreviousMode() == UserMode) {
        return ZwInitializeRegistry(BootCondition);
    } else {
        //
        // Check for a valid BootCondition value
        //

        if(BootCondition > REG_INIT_MAX_VALID_CONDITION)
           return STATUS_INVALID_PARAMETER;

        //
        // Check for a Boot acceptance
        //

        if((BootCondition >= REG_INIT_BOOT_ACCEPTED_BASE) &&
           (BootCondition <= REG_INIT_BOOT_ACCEPTED_MAX))
        {
           //
           // Make sure the Boot can be accepted only once
           //

           if(!CmBootAcceptFirstTime)
              return STATUS_ACCESS_DENIED;

           CmBootAcceptFirstTime = FALSE;

           //
           // Calculate the control set we want to save
           // the boot control set to
           //

           BootCondition -= REG_INIT_BOOT_ACCEPTED_BASE;

           if(BootCondition)
           {
                //
                // OK, this is a good boot for the purposes of LKG, and we have
                // a valid control set number passed into us. We save off our
                // control set and then notify everyone who wants to do post
                // WinLogon work.
                //
                // Note that none of this happens during Safe Mode boot!
                //
                Status = CmpSaveBootControlSet(BootCondition);

                //
                // Mark the boot good for the Hal. This lets the Hal do things
                // like optimize reboot performance.
                //
                HalEndOfBoot();

                //
                // Notify prefetcher of boot progress.
                //
                CcPfBeginBootPhase(PfBootAcceptedRegistryInitPhase);

                //
                // inform the user in the event one of the system core hives have been self healed
                //
                CmpRaiseSelfHealWarningForSystemHives();
                //
                // enable lazy flusher 
                //

                CmpHoldLazyFlush = FALSE;
                CmpLazyFlush();

                return Status;

           }
           else
           {
              //
              // 0 passed in as a control set number.
              // That is not valid, fail.
              //

              return STATUS_INVALID_PARAMETER;
           }
        }

        // called from setup?

        SetupBoot = (BootCondition == REG_INIT_BOOT_SETUP ? TRUE : FALSE);

        //
        // Fail if not first time called for situation #1 work.
        //

        if (CmFirstTime != TRUE) {
            return STATUS_ACCESS_DENIED;
        }
        CmFirstTime = FALSE;

        //
        // Notify WMI.
        //
        WmiBootPhase1();

        //
        // Notify prefetcher of boot progress.
        //

        CcPfBeginBootPhase(PfSMRegistryInitPhase);

        //
        // Call the worker to init cm globals
        //

        CmpLockRegistryExclusive();

        CmpCmdInit(SetupBoot);

        CmpSetVersionData();

        CmpUnlockRegistry();
    
        //
        // Notify PO that the volumes are usabled
        //
        PoInitHiberServices(SetupBoot);

        if (!SetupBoot) {
            IopCopyBootLogRegistryToFile();
        }

        return STATUS_SUCCESS;
    }
}


NTSTATUS
NtNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Notification of key creation, deletion, and modification may be
    obtained by calling NtNotifyChangeKey.

    NtNotifyChangeKey monitors changes to a key - if the key or
    subtree specified by KeyHandle are modified, the service notifies
    its caller.  It also returns the name(s) of the key(s) that changed.
    All names are specified relative to the key that the handle represents
    (therefore a NULL name represents that key).  The service completes
    once the key or subtree has been modified based on the supplied
    CompletionFilter.  The service is a "single shot" and therefore
    needs to be reinvoked to watch the key for further changes.

    The operation of this service begins by opening a key for KEY_NOTIFY
    access.  Once the handle is returned, the NtNotifyChangeKey service
    may be invoked to begin watching the values and subkeys of the
    specified key for changes.  The first time the service is invoked,
    the BufferSize parameter supplies not only the size of the user's
    Buffer, but also the size of the buffer that will be used by the
    Registry to store names of keys that have changed.  Likewise, the
    CompletionFilter and WatchTree parameters on the first call indicate
    how notification should operate for all calls using the supplied
    KeyHandle.   These two parameters are ignored on subsequent calls
    to the API with the same instance of KeyHandle.

    Once a modification is made that should be reported, the Registry will
    complete the service.  The names of the files that have changed since
    the last time the service was called will be placed into the caller's
    output Buffer.  The Information field of IoStatusBlock will contain
    the number of bytes placed in Buffer, or zero if too many keys have
    changed since the last time the service was called, in which case
    the application must Query and Enumerate the key and sub keys to
    discover changes.  The Status field of IoStatusBlock will contain
    the actual status of the call.

    If Asynchronous is TRUE, then Event, if specified, will be set to
    the Signaled state.  If no Event parameter was specified, then
    KeyHandle will be set to the Signaled state.  If an ApcRoutine
    was specified, it is invoked with the ApcContext and the address of the
    IoStatusBlock as its arguments.  If Asynchronous is FALSE, Event,
    ApcRoutine, and ApcContext are ignored.

    This service requires KEY_NOTIFY access to the key that was
    actually modified

    The notify "session" is terminated by closing KeyHandle.

Arguments:

    KeyHandle-- Supplies a handle to an open key.  This handle is
        effectively the notify handle, because only one set of
        notify parameters may be set against it.

    Event - An optional handle to an event to be set to the
        Signaled state when the operation completes.

    ApcRoutine - An optional procedure to be invoked once the
        operation completes.  For more information about this
        parameter see the NtReadFile system service description.

        If PreviousMode == Kernel, this parameter is an optional
        pointer to a WORK_QUEUE_ITEM to be queued when the notify
        is signaled.

    ApcContext - A pointer to pass as an argument to the ApcRoutine,
        if one was specified, when the operation completes.  This
        argument is required if an ApcRoutine was specified.

        If PreviousMode == Kernel, this parameter is an optional
        WORK_QUEUE_TYPE describing the queue to be used. This argument
        is required if an ApcRoutine was specified.

    IoStatusBlock - A variable to receive the final completion status.
        For more information about this parameter see the NtCreateFile
        system service description.

    CompletionFilter -- Specifies a set of flags that indicate the
        types of operations on the key or its value that cause the
        call to complete.  The following are valid flags for this parameter:

        REG_NOTIFY_CHANGE_NAME -- Specifies that the call should be
            completed if a subkey is added or deleted.

        REG_NOTIFY_CHANGE_ATTRIBUTES -- Specifies that the call should
            be completed if the attributes (e.g.: ACL) of the key or
            any subkey are changed.

        REG_NOTIFY_CHANGE_LAST_SET -- Specifies that the call should be
            completed if the lastWriteTime of the key or any of its
            subkeys is changed.  (Ie. if the value of the key or any
            subkey is changed).

        REG_NOTIFY_CHANGE_SECURITY -- Specifies that the call should be
            completed if the security information (e.g. ACL) on the key
            or any subkey is changed.

    WatchTree -- A BOOLEAN value that, if TRUE, specifies that all
        changes in the subtree of this key should also be reported.
        If FALSE, only changes to this key, its value, and its immediate
        subkeys (but not their values nor their subkeys) are reported.

    Buffer -- A variable to receive the name(s) of the key(s) that
        changed.  See REG_NOTIFY_INFORMATION.

    BufferSize -- Specifies the length of Buffer.

    Asynchronous  -- If FALSE, call will not return until
        complete (synchronous) if TRUE, call may return STATUS_PENDING.

Obs:
    Since NtNotifyChangeMultipleKeys, this routine is kept only for bacwards compatibility

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtNotifyChangeKey\n"));

    // Just call the wiser routine
    return NtNotifyChangeMultipleKeys(
                                        KeyHandle,
                                        0,
                                        NULL,
                                        Event,
                                        ApcRoutine,
                                        ApcContext,
                                        IoStatusBlock,
                                        CompletionFilter,
                                        WatchTree,
                                        Buffer,
                                        BufferSize,
                                        Asynchronous
                                    );

}

NTSTATUS
NtNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,
    IN ULONG Count,
    IN OBJECT_ATTRIBUTES SlaveObjects[],
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Notificaion of creation, deletion and modification on multiple keys
    may be obtained with NtNotifyChangeMultipleKeys.

    NtNotifyMultipleKeys monitors changes to any of the MasterKeyHandle
    or one of SlaveObjects and/or their subtrees, whichever occurs first.
    When an event on these keys is triggered, the notification is considered
    fulfilled, and has to be "armed" again, in order to watch for further
    changes.

    The mechanism is similar to the one described in NtNotifyChangeKey.

    The MasterKeyHandle key, give the caller control over the lifetime
    of the notification. The notification will live as long as the caller
    keeps the MasterKeyHandle open, or an event is triggered.

    The caller doesn't have to open the SlaveKeys. He will provide the
    routine with an array of OBJECT_ATTRIBUTES, describing the slave objects.
    The routine will open the objects, and ensure keep a reference on them
    untill the back-end side will close them.

    The notify "session" is terminated by closing MasterKeyHandle.

Obs:
    For the time being, the routine supports only one slave object. When more
    than one slave object is provided, the routine will signal an error of
    STATUS_INVALID_PARAMETER.
    However, the interface is designed for future enhancements (taking an
    array of slave objects), that may be provided with future versions(w2001).

    When no slave object is supplied (i.e. Count == 0) we have the identical
    behavior as for NtNotifyChangeKey.

Arguments:

    MasterKeyHandle - Supplies a handle to an open key.  This handle is
        the "master handle". It has control overthe lifetime of the
        notification.

    Count - Number of slave objects. For the time being, this should be 1

    SlaveObjects - Array of slave objects. Only the attributes of the
        objects are provided, so the caller doesn't have to take care
        of them.

    Event,ApcRoutine,ApcContext,IoStatusBlock,CompletionFilter,WatchTree,
    Buffer,BufferSize,Asynchronous - same as for NtNotifyChangeKey

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS            status;
    NTSTATUS            WaitStatus;
    KPROCESSOR_MODE     PreviousMode;
    PCM_KEY_BODY        MasterKeyBody;
    PCM_KEY_BODY        SlaveKeyBody;
    PKEVENT             UserEvent=NULL;
    PCM_POST_BLOCK      MasterPostBlock;
    PCM_POST_BLOCK      SlavePostBlock;
    KIRQL               OldIrql;
    HANDLE              SlaveKeyHandle;
    POST_BLOCK_TYPE     PostType = PostSynchronous;
    BOOLEAN             SlavePresent = FALSE;  // assume that we are in the NtNotifyChangeKey case
#if defined(_WIN64)
    BOOLEAN             UseIosb32=FALSE; // If the caller is a 32bit process on sundown and previous mode
                                            // is user mode, use a 32bit IoSb.
#endif

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtNotifyChangeMultipleKeysNo++;
#endif

    BEGIN_LOCK_CHECKPOINT;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtNotifyChangeMultipleKeys\n"));

    if( HvShutdownComplete == TRUE ) {
        //
        // too late to do registry operations.
        //
        return STATUS_TOO_LATE;
    }

    if(Count > 1) {
        //
        // This version supports only one slave object
        //
        return STATUS_INVALID_PARAMETER;
    }

    if(Count == 1) {
        //
        // We have one slave, so we are in the NtNotifyChangeMultipleKeys case
        //
        SlavePresent = TRUE;
    }

#if DBG
    if (SlavePresent) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"NtNotifyChangeMultipleKeys(%d,slave = %p, Asynchronous = %d)\n",MasterKeyHandle,SlaveObjects,(int)Asynchronous));
    }
#endif

    //
    // Threads that are attached give us real grief, so disallow it.
    //
    if (KeIsAttachedProcess()) {
        CM_BUGCHECK(REGISTRY_ERROR,BAD_NOTIFY_CONTEXT,1,0,0);
    }

    //
    // Probe user buffer parameters.
    //
    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

#if defined(_WIN64)
        // Process is 32bit if Wow64 is not NULL.
        UseIosb32 = (PsGetCurrentProcess()->Wow64Process != NULL);
#endif

        try {

            ProbeForWrite(
                IoStatusBlock,
#if defined(_WIN64)
                UseIosb32 ? sizeof(IO_STATUS_BLOCK32) : sizeof(IO_STATUS_BLOCK),
#else
                sizeof(IO_STATUS_BLOCK),
#endif
                sizeof(ULONG)
                );


            ProbeForWrite(Buffer, BufferSize, sizeof(ULONG));

            //
            // Initialize IOSB
            //

            CmpSetIoStatus(IoStatusBlock, STATUS_PENDING, 0, UseIosb32);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtChangeNotifyMultipleKeys: code:%08lx\n", GetExceptionCode()));
            return GetExceptionCode();
        }
        if (Asynchronous) {
            PostType = PostAsyncUser;
        }
    } else {
        if (Asynchronous) {
            PostType = PostAsyncKernel;
            if( Count > 0 ) {
                //
                // we don't allow multiple asyncronous kernel notifications
                //
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    // Check filter
    //
    if (CompletionFilter != (CompletionFilter & REG_LEGAL_CHANGE_FILTER)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference the Master Key handle
    //
    status = ObReferenceObjectByHandle(
                MasterKeyHandle,
                KEY_NOTIFY,
                CmpKeyObjectType,
                PreviousMode,
                (PVOID *)(&MasterKeyBody),
                NULL
                );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if(SlavePresent) {
        //
        // Open the slave object and add a reference to it.
        //
        try {

            status = ObOpenObjectByName(SlaveObjects,
                                        CmpKeyObjectType,
                                        PreviousMode,
                                        NULL,
                                        KEY_NOTIFY,
                                        NULL,
                                        &SlaveKeyHandle);
            if (NT_SUCCESS(status)) {
                status = ObReferenceObjectByHandle(SlaveKeyHandle,
                                                   KEY_NOTIFY,
                                                   CmpKeyObjectType,
                                                   PreviousMode,
                                                   (PVOID *)&SlaveKeyBody,
                                                   NULL);
                NtClose(SlaveKeyHandle);

            }

        } except (CmpExceptionFilter(GetExceptionInformation())) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtNotifyChangeMultipleKeys: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        if (!NT_SUCCESS(status)) {
            ObDereferenceObject(MasterKeyBody);
            return status;
        }

        //
        // Reject calls setting with keys on the same hive as they could lead to obscure deadlocks
        //
        if( MasterKeyBody->KeyControlBlock->KeyHive == SlaveKeyBody->KeyControlBlock->KeyHive ) {
            ObDereferenceObject(SlaveKeyBody);
            ObDereferenceObject(MasterKeyBody);
            return STATUS_INVALID_PARAMETER;
        }
    }


    //
    // Allocate master and slave post blocks, and init it.  Do NOT put it on the chain,
    // CmNotifyChangeKey will do that while holding a mutex.
    //
    // WARNING: PostBlocks MUST BE ALLOCATED from Pool, since back side
    //          of Notify will free it!
    //

    MasterPostBlock = CmpAllocateMasterPostBlock(PostType);
    if (MasterPostBlock == NULL) {
        if(SlavePresent) {
            ObDereferenceObject(SlaveKeyBody);
        }
        ObDereferenceObject(MasterKeyBody);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
#ifdef CM_NOTIFY_CHANGED_KCB_FULLPATH
    MasterPostBlock->CallerBuffer = Buffer;
    MasterPostBlock->CallerBufferSize = BufferSize;
#endif //CM_NOTIFY_CHANGED_KCB_FULLPATH

#if DBG
    MasterPostBlock->TraceIntoDebugger = TRUE;
#endif

    if(SlavePresent) {
        SlavePostBlock = CmpAllocateSlavePostBlock(PostType,SlaveKeyBody,MasterPostBlock);
        if (SlavePostBlock == NULL) {
            ObDereferenceObject(SlaveKeyBody);
            ObDereferenceObject(MasterKeyBody);
            CmpFreePostBlock(MasterPostBlock);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
#ifdef CM_NOTIFY_CHANGED_KCB_FULLPATH
        SlavePostBlock->CallerBuffer = Buffer;
        SlavePostBlock->CallerBufferSize = BufferSize;
#endif //CM_NOTIFY_CHANGED_KCB_FULLPATH

#if DBG
        SlavePostBlock->TraceIntoDebugger = TRUE;
#endif
    }

    if ((PostType == PostAsyncUser) ||
        (PostType == PostAsyncKernel)) {

        //
        // If event is present, reference it, save its address, and set
        // it to the not signaled state.
        //
        if (ARGUMENT_PRESENT(Event)) {
            status = ObReferenceObjectByHandle(
                            Event,
                            EVENT_MODIFY_STATE,
                            ExEventObjectType,
                            PreviousMode,
                            (PVOID *)(&UserEvent),
                            NULL
                            );
            if (!NT_SUCCESS(status)) {
                if(SlavePresent) {
                    CmpFreePostBlock(SlavePostBlock);
                    // SlaveKeyBody is dereferenced in CmpFreePostBlock(SlavePostBlock)
                }
                CmpFreePostBlock(MasterPostBlock);
                ObDereferenceObject(MasterKeyBody);
                return status;
            } else {
                KeClearEvent(UserEvent);
            }
        }

        if (PostType == PostAsyncUser) {
            KPROCESSOR_MODE     ApcMode;

            MasterPostBlock->u->AsyncUser.IoStatusBlock = IoStatusBlock;
            MasterPostBlock->u->AsyncUser.UserEvent = UserEvent;
            //
            // Initialize APC.  May or may not be a user apc, will always
            // be a kernel apc.
            //
            ApcMode = PreviousMode;
            if( ApcRoutine == NULL ) {
                ApcRoutine = (PIO_APC_ROUTINE)CmpDummyApc;
                ApcMode = KernelMode;
            }
            KeInitializeApc(MasterPostBlock->u->AsyncUser.Apc,
                            KeGetCurrentThread(),
                            CurrentApcEnvironment,
                            (PKKERNEL_ROUTINE)CmpPostApc,
                            (PKRUNDOWN_ROUTINE)CmpPostApcRunDown,
                            (PKNORMAL_ROUTINE)ApcRoutine,
                            ApcMode,
                            ApcContext);
        } else {
            MasterPostBlock->u->AsyncKernel.Event = UserEvent;
            MasterPostBlock->u->AsyncKernel.WorkItem = (PWORK_QUEUE_ITEM)ApcRoutine;
            MasterPostBlock->u->AsyncKernel.QueueType = (WORK_QUEUE_TYPE)((ULONG_PTR)ApcContext);
        }
    }

    //
    // Exclusively lock the registry; We want nobody to mess with it while we are doing the
    // post/notify list manipulation; what else could be safer than that :-)
    //
    CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
    CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

    //
    // Call worker for master
    //
    status = CmpNotifyChangeKey(
                MasterKeyBody,
                MasterPostBlock,
                CompletionFilter,
                WatchTree,
                Buffer,
                BufferSize,
                MasterPostBlock
                );
    if( !NT_SUCCESS(status)) {
        //
        // it didn't work, clean up for error path
        //
        CmpUnlockRegistry();
        if (UserEvent != NULL) {
            ObDereferenceObject(UserEvent);
        }

        if(SlavePresent) {
            CmpFreePostBlock(SlavePostBlock);
            // SlaveKeyBody is dereferenced in CmpFreePostBlock(SlavePostBlock)
        }
        // MasterPostBlock if freed by CmpNotifyChangeKey !!!
        ObDereferenceObject(MasterKeyBody);
        return status;

    }

    ASSERT(status == STATUS_PENDING || status == STATUS_SUCCESS);

    if(SlavePresent) {
        if( status == STATUS_SUCCESS ) {
            //
            // The notify has already been triggered for the master, there is no point to set one for the slave too
            // Clean up the mess we made for the slave object and signal as there is no slave present
            //
            CmpFreePostBlock(SlavePostBlock);
            SlavePresent = FALSE;
        } else {
            //
            // Call worker for slave
            //
            status = CmpNotifyChangeKey(
                        SlaveKeyBody,
                        SlavePostBlock,
                        CompletionFilter,
                        WatchTree,
                        Buffer,
                        BufferSize,
                        MasterPostBlock
                        );
            if(!NT_SUCCESS(status)) {
                //
                // if we are here, the slave key has been deleted in between or there was no memory available to allocate
                // a notify block for the slave key. We do the cleanup here since we already hold the registry lock
                // exclusively and we don't want to give a anybody else a chance to trigger the notification on master post
                // (otherwise we could end up freeing it twice). The master post block and the user event are cleaned later,
                // covering both single and multiple notifications cases
                //

                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(MasterPostBlock->NotifyList));

                KeRaiseIrql(APC_LEVEL, &OldIrql);
                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(MasterPostBlock->ThreadList));
                KeLowerIrql(OldIrql);
            }
        }
    }

    //
    // postblocks are now on various lists, so we can die without losing them
    //
    CmpUnlockRegistry();

    if (NT_SUCCESS(status)) {
        //
        // success.  wait for event if sync.
        // do NOT deref User event, back side of notify will do that.
        //
        ASSERT(status == STATUS_PENDING || status == STATUS_SUCCESS);

        if (PostType == PostSynchronous) {
            WaitStatus = KeWaitForSingleObject(MasterPostBlock->u->Sync.SystemEvent,
                                               Executive,
                                               PreviousMode,
                                               TRUE,
                                               NULL);


            if ((WaitStatus==STATUS_ALERTED) || (WaitStatus == STATUS_USER_APC)) {

                //
                // The wait was aborted, clean up and return.
                //
                // 1. Remove the PostBlocks from the notify list.  This
                //    is normally done by the back end of notify, but
                //    we have to do it here since the back end is not
                //    involved.
                // 2. Delist and free the post blocks
                //
                CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
                CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

                KeRaiseIrql(APC_LEVEL, &OldIrql);
                if(SlavePresent) {
                    if (SlavePostBlock->NotifyList.Flink != NULL) {
                        // Use Cmp variant to protect for multiple deletion of the same object
                        CmpRemoveEntryList(&(SlavePostBlock->NotifyList));
                    }
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(SlavePostBlock->ThreadList));
                }

                if (MasterPostBlock->NotifyList.Flink != NULL) {
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(MasterPostBlock->NotifyList));
                }
                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(MasterPostBlock->ThreadList));
                KeLowerIrql(OldIrql);

                CmpUnlockRegistry();

                if(SlavePresent) {
                    CmpFreePostBlock(SlavePostBlock);
                }
                CmpFreePostBlock(MasterPostBlock);

                status = WaitStatus;

            } else {
                //
                // The wait was satisfied, which means the back end has
                // already removed the postblock from the notify list.
                // We just have to delist and free the post block.
                //

                //
                // Aquire the registry lock exclusive to enter the post block rule prerequisites
                //
                CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
                CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

                KeRaiseIrql(APC_LEVEL, &OldIrql);
                if(SlavePresent) {
                    if (SlavePostBlock->NotifyList.Flink != NULL) {
                        // Use Cmp variant to protect for multiple deletion of the same object
                        CmpRemoveEntryList(&(SlavePostBlock->NotifyList));
                    }
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(SlavePostBlock->ThreadList));

#ifdef CM_NOTIFY_CHANGED_KCB_FULLPATH
                    if( IsMasterPostBlock(SlavePostBlock) ) {
                        //
                        // slave has been promoted to master; it stores the full qualified changed kcb name
                        // in it's private kernel mode buffer; old master has been downgraded to slave
                        //
                        ASSERT( !IsMasterPostBlock(MasterPostBlock) );
                        ASSERT( MasterPostBlock->ChangedKcbFullName == NULL );

                        //
                        // fill the caller buffer (if any) - we are in the same process now.
                        //
                        CmpFillCallerBuffer(SlavePostBlock,SlavePostBlock->ChangedKcbFullName);
                    }
#endif //CM_NOTIFY_CHANGED_KCB_FULLPATH

                }

                if (MasterPostBlock->NotifyList.Flink != NULL) {
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(MasterPostBlock->NotifyList));
                }

#ifdef CM_NOTIFY_CHANGED_KCB_FULLPATH
                if( IsMasterPostBlock(MasterPostBlock) ) {
                    //
                    // fill the caller buffer (if any) - we are in the same process now.
                    //
                    CmpFillCallerBuffer(MasterPostBlock,MasterPostBlock->ChangedKcbFullName);
                }
#endif //CM_NOTIFY_CHANGED_KCB_FULLPATH

                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(MasterPostBlock->ThreadList));
                KeLowerIrql(OldIrql);

                CmpUnlockRegistry();

                status = MasterPostBlock->u->Sync.Status;

                try {
                    CmpSetIoStatus(IoStatusBlock, status, 0, UseIosb32);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode();
                }

                if(SlavePresent) {
                    CmpFreePostBlock(SlavePostBlock);
                }
                CmpFreePostBlock(MasterPostBlock);
            }
        }

    } else {
        CmpFreePostBlock(MasterPostBlock);
        //
        // it didn't work, clean up for error path
        //
        if (UserEvent != NULL) {
            ObDereferenceObject(UserEvent);
        }
    }

    ObDereferenceObject(MasterKeyBody);
    //
    // Don't dereference SlaveKeyBody!!! => Back-end routine will do that !!!
    //

    END_LOCK_CHECKPOINT;

    return status;
}

NTSTATUS
NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    A registry key which already exists may be opened with NtOpenKey.

    Share access is computed from desired access.

Arguments:

    KeyHandle - Receives a  Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory
        is specified, the name is relative to the root.  The name of
        the object must be within the name space allocated to the
        Registry, that is, all names beginning "\Registry".  RootHandle,
        if present, must be a handle to "\", or "\Registry", or a
        key under "\Registry".  If the specified key does not exist, or
        access requested is not allowed, the operation will fail.

        NOTE:   Object manager will capture and probe this argument.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    KPROCESSOR_MODE mode;
    PCM_KEY_BODY    KeyBody;
    HANDLE          Handle =0;
    UNICODE_STRING  CapturedObjectName = {0};

    // Start registry call tracing
    StartWmiCmTrace();

#if !defined(BUILD_WOW6432)
    DesiredAccess &= (~KEY_WOW64_RES); // filter out wow64 specific access
#endif


    PAGED_CODE();

    if( HvShutdownComplete == TRUE ) {
        //
        // it is now too late to do registry operations
        //
        return STATUS_TOO_LATE;
    }

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtOpenKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtOpenKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tDesiredAccess=%08lx ", DesiredAccess));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tObjectAttributes=%p\n", ObjectAttributes));

    mode = KeGetPreviousMode();

    try {

        if (mode == UserMode) {
            ProbeAndZeroHandle(KeyHandle);
            //
            // probe the ObjectAttributes as we shall use it for tracing
            //
            ProbeForReadSmallStructure( ObjectAttributes,
                                        sizeof(OBJECT_ATTRIBUTES),
                                        PROBE_ALIGNMENT(OBJECT_ATTRIBUTES) );
            CapturedObjectName = ProbeAndReadUnicodeString(ObjectAttributes->ObjectName);
            ProbeForRead(
                CapturedObjectName.Buffer,
                CapturedObjectName.Length,
                sizeof(WCHAR)
                );

        } else {
            CapturedObjectName = *(ObjectAttributes->ObjectName);
        }

        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(ObjectAttributes->RootDirectory);

    } except (CmpExceptionFilter(GetExceptionInformation())) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtOpenKey: code:%08lx\n", GetExceptionCode()));
        status = GetExceptionCode();
    }

    if( NT_SUCCESS(status) ) {
        //
        // this should not be inside the try/except as we captured the buffer
        //
        status = ObOpenObjectByName(
                    ObjectAttributes,
                    CmpKeyObjectType,
                    mode,
                    NULL,
                    DesiredAccess,
                    NULL,
                    &Handle
                    );
        //
        // need to protect against attacks to KeyHandle usermode pointer
        //
        try {
            if (status==STATUS_PREDEFINED_HANDLE) {
                status = ObReferenceObjectByHandle( Handle,
                                                    0,
                                                    CmpKeyObjectType,
                                                    KernelMode,
                                                    (PVOID *)(&KeyBody),
                                                    NULL);
                if (NT_SUCCESS(status)) {
                    *KeyHandle = (HANDLE)LongToHandle(KeyBody->Type);
                    ObDereferenceObject((PVOID)KeyBody);
                    //
                    // disallow attempts to return NULL handles
                    //
                    if( *KeyHandle ) {
                        status = STATUS_SUCCESS;
                    } else {
                        status = STATUS_OBJECT_NAME_NOT_FOUND;
                    }
                }
                NtClose(Handle);
                Handle = *KeyHandle;
                
            } else if (NT_SUCCESS(status)) {
                *KeyHandle = Handle;
                // need to do this only on clean shutdown
                CmpAddKeyTracker(Handle,mode);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtOpenKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }
    }

    // End registry call tracing
    EndWmiCmTrace(status,0,&CapturedObjectName,EVENT_TRACE_TYPE_REGOPEN);

    return  status;
}


NTSTATUS
NtQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    )
/*++

Routine Description:

    Data about the class of a key, and the numbers and sizes of its
    children and value entries may be queried with NtQueryKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

    NOTE: The returned lengths are guaranteed to be at least as
          long as the described values, but may be longer in
          some circumstances.

Arguments:

    KeyHandle - Handle of the key to query data for.  Must have been
        opened for KEY_QUERY_KEY access.

    KeyInformationClass - Specifies the type of information
        returned in Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (See KEY_BASIC_INFORMATION)

        KeyNodeInformation - return last write time, title index, name, class.
            (See KEY_NODE_INFORMATION)

        KeyFullInformation - return all data except for name and security.
            (See KEY_FULL_INFORMATION)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtQueryKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryKey\n"));

    if ((KeyInformationClass != KeyBasicInformation) &&
        (KeyInformationClass != KeyNodeInformation)  &&
        (KeyInformationClass != KeyFullInformation)  &&
        (KeyInformationClass != KeyNameInformation) &&
        (KeyInformationClass != KeyCachedInformation) &&
        (KeyInformationClass != KeyFlagsInformation)
        )
    {
        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(KeyHandle);

        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_PARAMETER,KeyInformationClass,NULL,EVENT_TRACE_TYPE_REGQUERY);

        return STATUS_INVALID_PARAMETER;
    }

    mode = KeGetPreviousMode();

    if( KeyInformationClass == KeyNameInformation ){
        //
        // special case: name information is available regardless of the access level
        // you have on the key  (provided that you have some ...)
        //

        OBJECT_HANDLE_INFORMATION HandleInfo;

        // reference with "no access required"
        status = ObReferenceObjectByHandle(
                KeyHandle,
                0,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                &HandleInfo
                );
        if( NT_SUCCESS(status) ) {
            if( HandleInfo.GrantedAccess == 0 ) {
                //
                // no access is granted on the handle; bad luck!
                //
                ObDereferenceObject((PVOID)KeyBody);

                status = STATUS_ACCESS_DENIED;
            }
        }
    } else {
        status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_QUERY_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );
    }

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (mode == UserMode) {
                ProbeForWrite(
                    KeyInformation,
                    Length,
                    CmpKeyInfoProbeAlingment(KeyInformationClass)
                    );
                ProbeForWriteUlong(ResultLength);
            }

			if( NT_SUCCESS(status)) {
                if( CmAreCallbacksRegistered() ) {
                    REG_QUERY_KEY_INFORMATION QueryKeyInfo;
            
                    QueryKeyInfo.Object = KeyBody;
                    QueryKeyInfo.KeyInformationClass = KeyInformationClass;
                    QueryKeyInfo.KeyInformation = KeyInformation;
                    QueryKeyInfo.Length = Length;
                    QueryKeyInfo.ResultLength = ResultLength;

                    status = CmpCallCallBacks(RegNtQueryKey,&QueryKeyInfo);
                }
    			if( NT_SUCCESS(status)) {
				    //
				    // CmQueryKey is writting to user-mode buffer
				    //
				    status = CmQueryKey(
							    KeyBody->KeyControlBlock,
							    KeyInformationClass,
							    KeyInformation,
							    Length,
							    ResultLength
							    );
                }
			}
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        ObDereferenceObject((PVOID)KeyBody);
    }


    // End registry call tracing
    EndWmiCmTrace(status,KeyInformationClass,NULL,EVENT_TRACE_TYPE_REGQUERY);

    return status;
}


NTSTATUS
NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The ValueName, TitleIndex, Type, and Data for any one of a key's
    value entries may be queried with NtQueryValueKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose value entries are to be
        enumerated.  Must be open for KEY_QUERY_VALUE access.

    ValueName  - The name of the value entry to return data for.

    KeyValueInformationClass - Specifies the type of information
        returned in KeyValueInformation.  One of the following types:

        KeyValueBasicInformation - return time of last write, title
            index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write, title
            index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

    TMP: The IopQueryRegsitryValues() routine in the IO system assumes
         STATUS_OBJECT_NAME_NOT_FOUND is returned if the value being queried
         for does not exist.

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;
    UNICODE_STRING LocalValueName;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtQueryValueKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tValueName='%wZ'\n", ValueName));

    if ((KeyValueInformationClass != KeyValueBasicInformation) &&
        (KeyValueInformationClass != KeyValueFullInformation)  &&
        (KeyValueInformationClass != KeyValueFullInformationAlign64)  &&
        (KeyValueInformationClass != KeyValuePartialInformationAlign64)  &&
        (KeyValueInformationClass != KeyValuePartialInformation))
    {
        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(KeyHandle);

        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_PARAMETER,KeyValueInformationClass,NULL,EVENT_TRACE_TYPE_REGQUERYVALUE);

        return STATUS_INVALID_PARAMETER;
    }

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_QUERY_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (mode == UserMode) {
                LocalValueName = ProbeAndReadUnicodeString(ValueName);
                ProbeForRead(LocalValueName.Buffer,
                             LocalValueName.Length,
                             sizeof(WCHAR));

                //
                // We only probe the output buffer for Read to avoid touching
                // all the pages. Some people like to pass in gigantic buffers
                // Just In Case. The actual copy into the buffer is done under
                // an exception handler.
                //

                ProbeForRead(KeyValueInformation,
                             Length,
                             sizeof(ULONG));
                ProbeForWriteUlong(ResultLength);
            } else {
                LocalValueName = *ValueName;
            }
            //
            // do NOT allow trailing NULLs at the end of the ValueName
            //
            while( (LocalValueName.Length > 0) && (LocalValueName.Buffer[LocalValueName.Length/sizeof(WCHAR)-1] == UNICODE_NULL) ) {
                LocalValueName.Length -= sizeof(WCHAR);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryValueKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }
        //
        // CmQueryValueKey is protected to user mode buffer exceptions
        // all other exceptions are cm internals and should result in a bugcheck
        //
        if( NT_SUCCESS(status)) {
            if( CmAreCallbacksRegistered() ) {
                REG_QUERY_VALUE_KEY_INFORMATION QueryValueKeyInfo;
        
                QueryValueKeyInfo.Object = KeyBody;
                QueryValueKeyInfo.ValueName = &LocalValueName;
                QueryValueKeyInfo.KeyValueInformationClass = KeyValueInformationClass;
                QueryValueKeyInfo.KeyValueInformation = KeyValueInformation;
                QueryValueKeyInfo.Length = Length;
                QueryValueKeyInfo.ResultLength = ResultLength;

                status = CmpCallCallBacks(RegNtQueryValueKey,&QueryValueKeyInfo);
            }
            if( NT_SUCCESS(status)) {
                BEGIN_LOCK_CHECKPOINT;
                status = CmQueryValueKey(KeyBody->KeyControlBlock,
                                         LocalValueName,
                                         KeyValueInformationClass,
                                         KeyValueInformation,
                                         Length,
                                         ResultLength);
                END_LOCK_CHECKPOINT;
            }
        }

        ObDereferenceObject((PVOID)KeyBody);
    } else {
        LocalValueName.Buffer = NULL;
        LocalValueName.Length = 0;
    }

    // End registry call tracing
    EndWmiCmTrace(status,KeyValueInformationClass,&LocalValueName,EVENT_TRACE_TYPE_REGQUERYVALUE);

    return status;
}


NTSTATUS
NtRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG Flags
    )
/*++

Routine Description:

    A file in the format created by NtSaveKey may be loaded into
    the system's active registry with NtRestoreKey.  An entire subtree
    is created in the active registry as a result.  All of the
    data for the new sub-tree, including such things as security
    descriptors, will be read from the source file.  The data will
    not be interpreted in any way.

    This call (unlike NtLoadKey, see below) copies the data.  The
    system will NOT be using the source file after the call returns.

    If the flag REG_WHOLE_HIVE_VOLATILE is specified, a new hive
    can be created.  It will be a memory only copy.  The restore
    must be done to the root of a hive (e.g. \registry\user\<name>)

    If the flag is NOT set, then the target of the restore must
    be an existing hive.  The restore can be done to an arbitrary
    location within an existing hive.

    Caller must have SeRestorePrivilege privilege.

    If the flag REG_REFRESH_HIVE is set (must be only flag) then the
    the Hive will be restored to its state as of the last flush.

    The hive must be marked NOLAZY_FLUSH, and the caller must have
    TCB privilege, and the handle must point to the root of the hive.
    If the refresh fails, the hive will be corrupt, and the system
    will bugcheck.  Notifies are flushed.  The hive file will be resized,
    the log will not.  If there is any volatile space in the hive
    being refreshed, STATUS_UNSUCCESSFUL will be returned.  (It's much
    too obscure a failure to warrant a new error code.)

    If the flag REG_FORCE_RESTORE is set, the restore operation is done
    even if the KeyHandle has open subkeys by other applications

Arguments:

    KeyHandle - refers to the Key in the registry which is to be the
                root of the new tree read from the disk.  This key
                will be replaced.

    FileHandle - refers to file to restore from, must have read access.

    Flags   - If REG_WHOLE_HIVE_VOLATILE is set, then the copy will
              exist only in memory, and disappear when the machine
              is rebooted.  No hive file will be created on disk.

              Normally, a hive file will be created on disk.

Return Value:

    NTSTATUS - values TBS.


--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtRestoreKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtRestoreKey\n"));

    mode = KeGetPreviousMode();
    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Force previous mode to be KernelMode so we can call filesystems
    //

    if (mode == UserMode) {
        return ZwRestoreKey(KeyHandle, FileHandle, Flags);
    } else {

        status = ObReferenceObjectByHandle(
                    KeyHandle,
                    0,
                    CmpKeyObjectType,
                    mode,
                    (PVOID *)(&KeyBody),
                    NULL
                    );

        if (NT_SUCCESS(status)) {


            if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                //
                // key is protected
                //
                status = STATUS_ACCESS_DENIED;
            } else {
                BEGIN_LOCK_CHECKPOINT;
                status = CmRestoreKey(
                            KeyBody->KeyControlBlock,
                            FileHandle,
                            Flags
                            );
                END_LOCK_CHECKPOINT;
            }

            ObDereferenceObject((PVOID)KeyBody);
        }
    }


    return status;
}

NTSTATUS
NtSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    )
/*++

Routine Description:

    A subtree of the active registry may be written to a file in a
    format suitable for use with NtRestoreKey.  All of the data in the
    subtree, including such things as security descriptors will be written
    out.

    Caller must have SeBackupPrivilege privilege.

    This function will always save the hive in HSYS_MINOR format. For saving
    in other format (latest - 1.5) NtSaveKeyEx  is provided.

Arguments:

    KeyHandle - refers to the Key in the registry which is the
                root of the tree to be written to disk.  The specified
                node will be included in the data written out.

    FileHandle - a file handle with write access to the target file
                 of interest.

Return Value:

    NTSTATUS - values TBS

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtSaveKeyNo++;
#endif


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSaveKey\n"));

    mode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Force previous mode to be KernelMode
    //

    if (mode == UserMode) {
        return ZwSaveKey(KeyHandle, FileHandle);
    } else {

        status = ObReferenceObjectByHandle(
                    KeyHandle,
                    0,
                    CmpKeyObjectType,
                    mode,
                    (PVOID *)(&KeyBody),
                    NULL
                    );

        if (NT_SUCCESS(status)) {

            BEGIN_LOCK_CHECKPOINT;
			status = CmSaveKey(
                        KeyBody->KeyControlBlock,
                        FileHandle,
                        HSYS_MINOR
                        );
            END_LOCK_CHECKPOINT;
            ObDereferenceObject((PVOID)KeyBody);
        }
    }


    return status;
}

NTSTATUS
NtSaveKeyEx(
    IN HANDLE   KeyHandle,
    IN HANDLE   FileHandle,
    IN ULONG    Format
    )
/*++

Routine Description:

    A subtree of the active registry may be written to a file in a
    format suitable for use with NtRestoreKey.  All of the data in the
    subtree, including such things as security descriptors will be written
    out.

    Caller must have SeBackupPrivilege privilege.

Arguments:

    KeyHandle - refers to the Key in the registry which is the
                root of the tree to be written to disk.  The specified
                node will be included in the data written out.

    FileHandle - a file handle with write access to the target file
                 of interest.

    Format - specifies whether in which the file will be saved
            Can be:
                HIVE_VERSION_STANDARD ==> 1.3
                HIVE_VERSION_LATEST   ==> 1.4

Return Value:

    NTSTATUS - values TBS

--*/
{
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;
    ULONG           HiveVersion;

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtSaveKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSaveKeyEx\n"));

    mode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }
    //
    // param validation
    //
    if( (Format != REG_STANDARD_FORMAT) && (Format != REG_LATEST_FORMAT) && (Format != REG_NO_COMPRESSION) ) {
	    return STATUS_INVALID_PARAMETER;
    }

    //
    // Force previous mode to be KernelMode
    //

    if (mode == UserMode) {
        return ZwSaveKeyEx(KeyHandle, FileHandle,Format);
    } else {

        status = ObReferenceObjectByHandle(
                    KeyHandle,
                    0,
                    CmpKeyObjectType,
                    mode,
                    (PVOID *)(&KeyBody),
                    NULL
                    );

        if (NT_SUCCESS(status)) {

            BEGIN_LOCK_CHECKPOINT;
            if( Format == REG_NO_COMPRESSION ) {
                status = CmDumpKey(
                                    KeyBody->KeyControlBlock,
                                    FileHandle
                );
            } else {
                HiveVersion = HSYS_MINOR;
                if( Format == REG_LATEST_FORMAT ) {
                    HiveVersion = HSYS_WHISTLER;
                }
                status = CmSaveKey(
                                    KeyBody->KeyControlBlock,
                                    FileHandle,
                                    HiveVersion
                );
            } 
            END_LOCK_CHECKPOINT;

            ObDereferenceObject((PVOID)KeyBody);
        }
    }

    return status;
}


NTSTATUS
NtSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    )
/*++

Routine Description:

    Two subtrees of the registry can be merged. The resulting subtree may
    be written to a file in a format suitable for use with NtRestoreKey.
    All of the data in the subtree, including such things as security
    descriptors will be written out.

    Caller must have SeBackupPrivilege privilege.

Arguments:

    HighPrecedenceKeyHandle - refers to the key in the registry which is the
                root of the HighPrecedence tree. I.e., when a key is present in
                both trees headded by the two keys, the key underneath HighPrecedence
                tree will always prevail. The specified
                node will be included in the data written out.

    LowPrecedenceKeyHandle - referrs to the key in the registry which is the
                root of the "second choice" tree. Keys from this trees get saved
                when there is no equivalent key in the tree headded by HighPrecedenceKey

    FileHandle - a file handle with write access to the target file
                 of interest.

Return Value:

    NTSTATUS - values TBS

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   HighKeyBody;
    PCM_KEY_BODY   LowKeyBody;
    KPROCESSOR_MODE mode;

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtSaveMergedKeysNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSaveMergedKeys\n"));

    mode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Force previous mode to be KernelMode
    //

    if (mode == UserMode) {
        return ZwSaveMergedKeys(HighPrecedenceKeyHandle, LowPrecedenceKeyHandle, FileHandle);
    } else {

        status = ObReferenceObjectByHandle(
                    HighPrecedenceKeyHandle,
                    0,
                    CmpKeyObjectType,
                    mode,
                    (PVOID *)(&HighKeyBody),
                    NULL
                    );

        if (NT_SUCCESS(status)) {

            status = ObReferenceObjectByHandle(
                        LowPrecedenceKeyHandle,
                        0,
                        CmpKeyObjectType,
                        mode,
                        (PVOID *)(&LowKeyBody),
                        NULL
                        );

            if (NT_SUCCESS(status)) {

                BEGIN_LOCK_CHECKPOINT;
                status = CmSaveMergedKeys(
                            HighKeyBody->KeyControlBlock,
                            LowKeyBody->KeyControlBlock,
                            FileHandle
                            );
                END_LOCK_CHECKPOINT;

                ObDereferenceObject((PVOID)LowKeyBody);
            }

            ObDereferenceObject((PVOID)HighKeyBody);
        }

    }

    return status;
}


NTSTATUS
NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
/*++

Routine Description:

    A value entry may be created or replaced with NtSetValueKey.

    If a value entry with a Value ID (i.e. name) matching the
    one specified by ValueName exists, it is deleted and replaced
    with the one specified.  If no such value entry exists, a new
    one is created.  NULL is a legal Value ID.  While Value IDs must
    be unique within any given key, the same Value ID may appear
    in many different keys.

Arguments:

    KeyHandle - Handle of the key whose for which a value entry is
        to be set.  Must be opened for KEY_SET_VALUE access.

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    TitleIndex - Supplies the title index for ValueName.  The title
        index specifies the index of the localized alias for the ValueName.

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.


Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;
    UNICODE_STRING LocalValueName;
    PWSTR CapturedName=NULL;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtSetValueKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSetValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tValueName='%wZ'n", ValueName));

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_SET_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        if (mode == UserMode) {
            try {
                LocalValueName = ProbeAndReadUnicodeString(ValueName);
                ProbeForRead(Data,
                             DataSize,
                             sizeof(UCHAR));

                //
                // Sanity check for ValueName length
                //
                if(LocalValueName.Length > REG_MAX_KEY_VALUE_NAME_LENGTH) {
                    status = STATUS_INVALID_PARAMETER;
                    goto Exit;
                }

                //
                // Capture the name buffer. Note that a zero-length name is valid, that is the
                // "Default" value.
                //
                if (LocalValueName.Length > 0) {
                    ProbeForRead(LocalValueName.Buffer,
                                 LocalValueName.Length,
                                 sizeof(WCHAR));
                    CapturedName = ExAllocatePoolWithQuotaTag(PagedPool, LocalValueName.Length, 'nVmC');
                    if (CapturedName == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlCopyMemory(CapturedName, LocalValueName.Buffer, LocalValueName.Length);
                } else {
                    CapturedName = NULL;
                }
                LocalValueName.Buffer = CapturedName;

            } except (CmpExceptionFilter(GetExceptionInformation())) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtSetValueKey: code:%08lx [1]\n", GetExceptionCode()));
                status = GetExceptionCode();
                goto Exit;
            }
        } else {
            LocalValueName = *ValueName;
            CapturedName = NULL;

            //
            // Sanity check for ValueName length
            //
            if(LocalValueName.Length > REG_MAX_KEY_VALUE_NAME_LENGTH) {
                status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
        }

        //
        // do NOT allow trailing NULLs at the end of the ValueName
        //
        try {
            while( (LocalValueName.Length > 0) && (LocalValueName.Buffer[LocalValueName.Length/sizeof(WCHAR)-1] == UNICODE_NULL) ) {
                LocalValueName.Length -= sizeof(WCHAR);
            }
        } except (CmpExceptionFilter(GetExceptionInformation())) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtSetValueKey: code:%08lx [2]\n", GetExceptionCode()));
            status = GetExceptionCode();
            goto Exit;
        }

        if( DataSize > 0x80000000 ) {
            status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
            //
            // key is protected
            //
            status = STATUS_ACCESS_DENIED;
        } else {
            if( CmAreCallbacksRegistered() ) {
                REG_SET_VALUE_KEY_INFORMATION SetValueInfo;
        
                SetValueInfo.Object = KeyBody;
                SetValueInfo.ValueName = &LocalValueName;
                SetValueInfo.TitleIndex = TitleIndex;
                SetValueInfo.Type = Type;
                SetValueInfo.Data = Data;
                SetValueInfo.DataSize = DataSize;
                status = CmpCallCallBacks(RegNtSetValueKey,&SetValueInfo);
            }

            if( NT_SUCCESS(status) ) {
                BEGIN_LOCK_CHECKPOINT;
                status = CmSetValueKey(KeyBody->KeyControlBlock,
                                       &LocalValueName,
                                       Type,
                                       Data,
                                       DataSize);
                END_LOCK_CHECKPOINT;
            }
        }

Exit:
        // End registry call tracing
        EndWmiCmTrace(status,0,&LocalValueName,EVENT_TRACE_TYPE_REGSETVALUE);

        if (CapturedName != NULL) {
            ExFreePool(CapturedName);
        }

        ObDereferenceObject((PVOID)KeyBody);
    }


    return status;
}

NTSTATUS
NtLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

Return Value:

    NTSTATUS - values TBS.

--*/

{
    return(NtLoadKey2(TargetKey, SourceFile, 0));
}


NTSTATUS
NtLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

    Flags - specifies any flags that should be used for the load operation.
            The only valid flag is REG_NO_LAZY_FLUSH.


Return Value:

    NTSTATUS - values TBS.

--*/

{
    OBJECT_ATTRIBUTES   File;
    OBJECT_ATTRIBUTES   Key;
    KPROCESSOR_MODE     PreviousMode;
    UNICODE_STRING      CapturedKeyName;
    UNICODE_STRING      FileName;
    USHORT              Maximum;
    NTSTATUS            Status;
    PWSTR               KeyBuffer;

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtLoadKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtLoadKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey = %p\n", TargetKey));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tSourceFile= %p\n", SourceFile));
    //
    // Check for illegal flags
    //
    if (Flags & ~REG_NO_LAZY_FLUSH) {
        return(STATUS_INVALID_PARAMETER);
    }

    FileName.Buffer = NULL;
    KeyBuffer = NULL;

    //
    // The way we do this is a cronk, but at least it's the same cronk we
    // use for all the registry I/O.
    //
    // The file needs to be opened in the worker thread's context, since
    // the resulting handle must be valid when we poke him to go read/write
    // from.  So we just capture the object attributes for the hive file
    // here, then poke the worker thread to go do the rest of the work.
    //

    PreviousMode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // CmpNameFromAttributes will probe and capture as necessary.
    //
    KeEnterCriticalRegion();
    Status = CmpNameFromAttributes(SourceFile,
                                   PreviousMode,
                                   &FileName);
    if (!NT_SUCCESS(Status)) {
        KeLeaveCriticalRegion();
        return(Status);
    }

    try {

        //
        // Probe the object attributes if necessary.
        //
        if (PreviousMode == UserMode) {
            ProbeForReadSmallStructure(TargetKey,
                                       sizeof(OBJECT_ATTRIBUTES),
                                       sizeof(ULONG));
        }

        //
        // Capture the object attributes.
        //
        Key  = *TargetKey;

        //
        // Capture the object name.
        //

        if (PreviousMode == UserMode) {
            CapturedKeyName = ProbeAndReadUnicodeString(Key.ObjectName);
            ProbeForRead(CapturedKeyName.Buffer,
                         CapturedKeyName.Length,
                         sizeof(WCHAR));
        } else {
            CapturedKeyName = *(TargetKey->ObjectName);
        }

        File.ObjectName = &FileName;
        File.SecurityDescriptor = NULL;

        Maximum = (USHORT)(CapturedKeyName.Length);

        KeyBuffer = ALLOCATE_WITH_QUOTA(PagedPool, Maximum, CM_POOL_TAG);

        if (KeyBuffer == NULL) {
            ExFreePool(FileName.Buffer);
            KeLeaveCriticalRegion();
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory(KeyBuffer, CapturedKeyName.Buffer, Maximum);
        CapturedKeyName.Length = Maximum;
        CapturedKeyName.Buffer = KeyBuffer;

        Key.ObjectName = &CapturedKeyName;
        Key.SecurityDescriptor = NULL;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtLoadKey: code:%08lx\n", GetExceptionCode()));
        Status = GetExceptionCode();

    }

    //
    // Clean up if there was an exception while probing and copying user data
    //
    if (!NT_SUCCESS(Status)) {
        if (FileName.Buffer != NULL) {
            ExFreePool(FileName.Buffer);
        }
        if (KeyBuffer != NULL) {
            ExFreePool(KeyBuffer);
        }
        KeLeaveCriticalRegion();
        return(Status);
    }

    BEGIN_LOCK_CHECKPOINT;
    Status = CmLoadKey(&Key, &File, Flags);
    END_LOCK_CHECKPOINT;

    ExFreePool(FileName.Buffer);
    ExFreePool(KeyBuffer);

    KeLeaveCriticalRegion();

    return(Status);
}


NTSTATUS
NtUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    )
/*++

Routine Description:

    Drop a subtree (hive) out of the registry.

    Will fail if applied to anything other than the root of a hive.

    Cannot be applied to core system hives (HARDWARE, SYSTEM, etc.)

    Can be applied to user hives loaded via NtRestoreKey or NtLoadKey.

    If there are handles open to the hive being dropped, this call
    will fail.  Terminate relevent processes so that handles are
    closed.

    This call will flush the hive being dropped.

    Caller must have SeRestorePrivilege privilege.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS - values TBS.

--*/
{
    HANDLE KeyHandle;
    NTSTATUS Status;
    PCM_KEY_BODY   KeyBody;
    PHHIVE Hive;
    HCELL_INDEX Cell;
    KPROCESSOR_MODE PreviousMode;
    CM_PARSE_CONTEXT ParseContext;

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtUnloadKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtUnloadKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey ='%p'\n", TargetKey));

    PreviousMode = KeGetPreviousMode();

    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    try {

        ParseContext.TitleIndex = 0;
        ParseContext.Class.Length = 0;
        ParseContext.Class.Buffer = NULL;
        ParseContext.CreateOptions = REG_OPTION_BACKUP_RESTORE;
        ParseContext.Disposition = 0L;
        ParseContext.CreateLink = FALSE;
        ParseContext.PredefinedHandle = NULL;

        Status = ObOpenObjectByName(TargetKey,
                                    CmpKeyObjectType,
                                    PreviousMode,
                                    NULL,
                                    KEY_WRITE,
                                    &ParseContext,
                                    &KeyHandle);
        if (NT_SUCCESS(Status)) {
            Status = ObReferenceObjectByHandle(KeyHandle,
                                               KEY_WRITE,
                                               CmpKeyObjectType,
                                               PreviousMode,
                                               (PVOID *)&KeyBody,
                                               NULL);
            NtClose(KeyHandle);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtUnloadKey: code:%08lx\n", Status));
    }

    if (NT_SUCCESS(Status)) {
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        if( KeyBody->KeyControlBlock->Delete ) {
            Status = STATUS_KEY_DELETED;
        } else {

            Hive = KeyBody->KeyControlBlock->KeyHive;
            Cell = KeyBody->KeyControlBlock->KeyCell;

#ifdef NT_UNLOAD_KEY_EX
            if( !IsHiveFrozen((PCMHIVE)Hive) ) {
#endif //NT_UNLOAD_KEY_EX
                //
                // Report the notify here, because the KCB won't be around later.
                //

                CmpReportNotify(KeyBody->KeyControlBlock,
                                Hive,
                                Cell,
                                REG_NOTIFY_CHANGE_LAST_SET);

                //
                // post any waiting notifies
                //
                CmpFlushNotify(KeyBody);

                if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                    //
                    // key is protected
                    //
                    Status = STATUS_ACCESS_DENIED;
                } else {
                    Status = CmUnloadKey(Hive, Cell, KeyBody->KeyControlBlock);
                }

                if (NT_SUCCESS(Status)) {
                    //
                    // Mark this kcb as deleted so that it won't get put on the delayed close list.
                    //
                    KeyBody->KeyControlBlock->Delete = TRUE;
                    //
                    // If the parent has the subkey info or hint cached, free it.
                    //
                    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
                    CmpCleanUpSubKeyInfo(KeyBody->KeyControlBlock->ParentKcb);
                    CmpRemoveKeyControlBlock(KeyBody->KeyControlBlock);
                }
#ifdef NT_UNLOAD_KEY_EX
            } else {
                //
                // don't let them hurt themselves by calling it twice
                //
                Status = STATUS_TOO_LATE;
            }
#endif //NT_UNLOAD_KEY_EX
        }

#ifdef CM_CHECK_FOR_ORPHANED_KCBS
        if( NT_SUCCESS(Status) ) {
            CmpCheckForOrphanedKcbs(Hive);
        }
#endif //CM_CHECK_FOR_ORPHANED_KCBS

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        CmpUnlockRegistry();
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);

    }

    return(Status);
}

#ifdef NT_UNLOAD_KEY_EX
NTSTATUS
NtUnloadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN HANDLE Event OPTIONAL
    )
/*++

Routine Description:

    Drop a subtree (hive) out of the registry.

    Will fail if applied to anything other than the root of a hive.

    Cannot be applied to core system hives (HARDWARE, SYSTEM, etc.)

    Can be applied to user hives loaded via NtRestoreKey or NtLoadKey.

    If there are handles open to the hive being dropped, the hive will be
    frozen and all calls to CmDeleteKey will be watched as when the last handle
    inside this hive is closed, the hive will be unloaded.

    Caller must have SeRestorePrivilege privilege.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    STATUS_SUCCESS - hive successfully unloaded - no late-unloading needed

    STATUS_PENDING - hive has been frozen and the event (if any) will be signaled
                     when the hive unloads

    <other> - an error occured, no action

--*/
{
    HANDLE              KeyHandle;
    NTSTATUS            Status;
    PCM_KEY_BODY        KeyBody;
    PHHIVE              Hive;
    HCELL_INDEX         Cell;
    KPROCESSOR_MODE     PreviousMode;
    CM_PARSE_CONTEXT    ParseContext;
    PKEVENT             UserEvent = NULL;

    PAGED_CODE();


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtUnloadKeyEx\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey = %p \tEvent = %p\n", TargetKey,Event));

    PreviousMode = KeGetPreviousMode();

    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    try {

        ParseContext.TitleIndex = 0;
        ParseContext.Class.Length = 0;
        ParseContext.Class.Buffer = NULL;
        ParseContext.CreateOptions = REG_OPTION_BACKUP_RESTORE;
        ParseContext.Disposition = 0L;
        ParseContext.CreateLink = FALSE;
        ParseContext.PredefinedHandle = NULL;

        Status = ObOpenObjectByName(TargetKey,
                                    CmpKeyObjectType,
                                    PreviousMode,
                                    NULL,
                                    KEY_WRITE,
                                    &ParseContext,
                                    &KeyHandle);
        if (NT_SUCCESS(Status)) {
            Status = ObReferenceObjectByHandle(KeyHandle,
                                               KEY_WRITE,
                                               CmpKeyObjectType,
                                               PreviousMode,
                                               (PVOID *)&KeyBody,
                                               NULL);
            NtClose(KeyHandle);

            if (ARGUMENT_PRESENT(Event)) {
                Status = ObReferenceObjectByHandle(
                                Event,
                                EVENT_MODIFY_STATE,
                                ExEventObjectType,
                                PreviousMode,
                                (PVOID *)(&UserEvent),
                                NULL
                                );
                if (NT_SUCCESS(Status)) {
                    KeClearEvent(UserEvent);
                }
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtUnloadKeyEx: code:%08lx\n", Status));
    }

    if (NT_SUCCESS(Status)) {
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        if( KeyBody->KeyControlBlock->Delete ) {
            Status = STATUS_KEY_DELETED;
        } else {
            Hive = KeyBody->KeyControlBlock->KeyHive;
            Cell = KeyBody->KeyControlBlock->KeyCell;

            //
            // Report the notify here, because the KCB won't be around later.
            //

            CmpReportNotify(KeyBody->KeyControlBlock,
                            Hive,
                            Cell,
                            REG_NOTIFY_CHANGE_LAST_SET);


            //
            // post any waiting notifies
            //
            CmpFlushNotify(KeyBody);

            if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                //
                // key is protected
                //
                Status = STATUS_ACCESS_DENIED;
            } else {
                Status = CmUnloadKeyEx(KeyBody->KeyControlBlock,UserEvent);
            }

            if (Status == STATUS_SUCCESS) {
                //
                // Mark this kcb as deleted so that it won't get put on the delayed close list.
                //
                KeyBody->KeyControlBlock->Delete = TRUE;
                //
                // If the parent has the subkey info or hint cached, free it.
                //
                ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
                CmpCleanUpSubKeyInfo(KeyBody->KeyControlBlock->ParentKcb);
                CmpRemoveKeyControlBlock(KeyBody->KeyControlBlock);

            }
        }

#ifdef CM_CHECK_FOR_ORPHANED_KCBS
        if( Status == STATUS_SUCCESS ) {
            CmpCheckForOrphanedKcbs(Hive);
        }
#endif //CM_CHECK_FOR_ORPHANED_KCBS

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        CmpUnlockRegistry();

        END_LOCK_CHECKPOINT;

        //
        // if hive was successfully unloaded (or something wrong happened,
        // we need to deref user event otherwise the back-end routine will deref it after signaling
        //
        if( (Status != STATUS_PENDING) && (UserEvent != NULL) ) {
            ObDereferenceObject(UserEvent);
        }

        ObDereferenceObject((PVOID)KeyBody);

    }

    return(Status);
}
#endif NT_UNLOAD_KEY_EX

NTSTATUS
NtSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    )
{
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;
    LARGE_INTEGER   LocalWriteTime;
    ULONG           LocalUserFlags;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtSetInformationKeyNo++;
#endif

    BEGIN_LOCK_CHECKPOINT;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSetInformationKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tInfoClass=%08x\n", KeySetInformationClass));

    mode = KeGetPreviousMode();

    //
    // check arg validity and probe
    //
    switch (KeySetInformationClass) {
    case KeyWriteTimeInformation:
        if (KeySetInformationLength != sizeof( KEY_WRITE_TIME_INFORMATION )) {
            // hook it for WMI
            HookKcbFromHandleForWmiCmTrace(KeyHandle);

            // End registry call tracing
            EndWmiCmTrace(STATUS_INFO_LENGTH_MISMATCH,0,NULL,EVENT_TRACE_TYPE_REGSETINFORMATION);

            return STATUS_INFO_LENGTH_MISMATCH;
        }
        try {
            if (mode == UserMode) {
                LocalWriteTime = ProbeAndReadLargeInteger(
                    (PLARGE_INTEGER) KeySetInformation );
            } else {
                LocalWriteTime = *(PLARGE_INTEGER)KeySetInformation;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtSetInformationKey: code:%08lx\n", GetExceptionCode()));
            return GetExceptionCode();
        }
        break;

    case KeyUserFlagsInformation:
        if (KeySetInformationLength != sizeof( KEY_USER_FLAGS_INFORMATION )) {

            // hook it for WMI
            HookKcbFromHandleForWmiCmTrace(KeyHandle);

            // End registry call tracing
            EndWmiCmTrace(STATUS_INFO_LENGTH_MISMATCH,0,NULL,EVENT_TRACE_TYPE_REGSETINFORMATION);

            return STATUS_INFO_LENGTH_MISMATCH;
        }
        try {

            if (mode == UserMode) {
                LocalUserFlags = ProbeAndReadUlong( (PULONG) KeySetInformation );
            } else {
                LocalUserFlags = *(PULONG)KeySetInformation;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtSetInformationKey: code:%08lx\n", GetExceptionCode()));
            return GetExceptionCode();
        }
        break;

    default:

        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(KeyHandle);
        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_INFO_CLASS,0,NULL,EVENT_TRACE_TYPE_REGSETINFORMATION);

        return STATUS_INVALID_INFO_CLASS;
    }

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_SET_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        if( CmAreCallbacksRegistered() ) {
            REG_SET_INFORMATION_KEY_INFORMATION SetInfo;
        
            SetInfo.Object = KeyBody;
            SetInfo.KeySetInformationClass = KeySetInformationClass;
            SetInfo.KeySetInformation = KeySetInformation;
            SetInfo.KeySetInformationLength = KeySetInformationLength;
            status = CmpCallCallBacks(RegNtSetInformationKey,&SetInfo);
            if( !NT_SUCCESS(status) ) {
                return status;
            }
        }

        if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
            //
            // key is protected
            //
            status = STATUS_ACCESS_DENIED;
        } else {
            switch (KeySetInformationClass) {
                case KeyWriteTimeInformation:
                    if( NT_SUCCESS(status)) {
                        //
                        // not in try ... except! we want to bugcheck here if something wrong in the registry
                        //
                        status = CmSetLastWriteTimeKey(
                                    KeyBody->KeyControlBlock,
                                    &LocalWriteTime
                                    );
                    }

                    break;

                case KeyUserFlagsInformation:
                    if( NT_SUCCESS(status)) {
                        //
                        // not in try ... except! we want to bugcheck here if something wrong in the registry
                        //
                        status = CmSetKeyUserFlags(
                                    KeyBody->KeyControlBlock,
                                    LocalUserFlags
                                    );
                    }

                    break;

                default:
                    // we shouldn't go through here
                    ASSERT( FALSE );
            }
        }
        ObDereferenceObject((PVOID)KeyBody);
    }

    END_LOCK_CHECKPOINT;

    // End registry call tracing
    EndWmiCmTrace(status,0,NULL,EVENT_TRACE_TYPE_REGSETINFORMATION);

    return status;
}


NTSTATUS
NtReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    )
/*++

Routine Description:

    A hive file may be "replaced" under a running system, such
    that the new file will be the one actually used at next
    boot, with this call.

    This routine will:

        Open newfile, and verify that it is a valid Hive file.

        Rename the Hive file backing TargetHandle to OldFile.
        All handles will remain open, and the system will continue
        to use the file until rebooted.

        Rename newfile to match the name of the hive file
        backing TargetHandle.

    .log and .alt files are ignored

    The system must be rebooted for any useful effect to be seen.

    Caller must have SeRestorePrivilege.

Arguments:

    NewFile - specifies the new file to use.  must not be just
              a handle, since NtReplaceKey will insist on
              opening the file for exclusive access (which it
              will hold until the system is rebooted.)

    TargetHandle - handle to a registry hive root

    OldFile - name of file to apply to current hive, which will
              become old hive

Return Value:

    NTSTATUS - values TBS.

--*/
{
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING NewHiveName;
    UNICODE_STRING OldFileName;
    NTSTATUS Status;
    PCM_KEY_BODY KeyBody;

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtReplaceKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtReplaceKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tNewFile =%p\n", NewFile));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tOldFile =%p\n", OldFile));

    PreviousMode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    KeEnterCriticalRegion();
    Status = CmpNameFromAttributes(NewFile,
                                   PreviousMode,
                                   &NewHiveName);
    if (!NT_SUCCESS(Status)) {
        KeLeaveCriticalRegion();
        return(Status);
    }

    Status = CmpNameFromAttributes(OldFile,
                                   PreviousMode,
                                   &OldFileName);
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewHiveName.Buffer);
        KeLeaveCriticalRegion();
        return(Status);
    }

    Status = ObReferenceObjectByHandle(TargetHandle,
                                       0,
                                       CmpKeyObjectType,
                                       PreviousMode,
                                       (PVOID *)&KeyBody,
                                       NULL);
    if (NT_SUCCESS(Status)) {

        if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
            //
            // key is protected
            //
            Status = STATUS_ACCESS_DENIED;
        } else {
            BEGIN_LOCK_CHECKPOINT;
            Status = CmReplaceKey(KeyBody->KeyControlBlock->KeyHive,
                                  KeyBody->KeyControlBlock->KeyCell,
                                  &NewHiveName,
                                  &OldFileName);
            END_LOCK_CHECKPOINT;
        }

        ObDereferenceObject((PVOID)KeyBody);
    }

    ExFreePool(OldFileName.Buffer);
    ExFreePool(NewHiveName.Buffer);
    KeLeaveCriticalRegion();

    return(Status);
}


NTSYSAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    )
/*++

Routine Description:

    Multiple values of any key may be queried atomically with
    this api.

Arguments:

    KeyHandle - Supplies the key to be queried.

    ValueNames - Supplies an array of value names to be queried

    ValueEntries - Returns an array of KEY_VALUE_ENTRY structures, one for each value.

    EntryCount - Supplies the number of entries in the ValueNames and ValueEntries arrays

    ValueBuffer - Returns the value data for each value.

    BufferLength - Supplies the length of the ValueBuffer array in bytes.
                   Returns the length of the ValueBuffer array that was filled in.

    RequiredBufferLength - if present, Returns the length in bytes of the ValueBuffer
                    array required to return all the values of this key.

Return Value:

    NTSTATUS

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PCM_KEY_BODY KeyBody;
    ULONG i;
    ULONG LocalBufferLength;

    // Start registry call tracing
    StartWmiCmTrace();

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtQueryMultipleValueKeyNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryMultipleValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(KeyHandle,
                                       KEY_QUERY_VALUE,
                                       CmpKeyObjectType,
                                       PreviousMode,
                                       (PVOID *)(&KeyBody),
                                       NULL);
    if (NT_SUCCESS(Status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (PreviousMode == UserMode) {
                LocalBufferLength = ProbeAndReadUlong(BufferLength);

                //
                // Probe the output buffers
                //
                // Put an arbitrary 64K limit on the number of entries to
                // prevent bogus apps from passing an EntryCount large enough
                // to overflow the EntryCount * sizeof(KEY_VALUE_ENTRY) calculation.
                //
                if (EntryCount > 0x10000) {
                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                }
                ProbeForWrite(ValueEntries,
                              EntryCount * sizeof(KEY_VALUE_ENTRY),
                              sizeof(ULONG));
                if (ARGUMENT_PRESENT(RequiredBufferLength)) {
                    ProbeForWriteUlong(RequiredBufferLength);
                }

                ProbeForWrite(ValueBuffer,
                              LocalBufferLength,
                              sizeof(ULONG));

            } else {
                LocalBufferLength = *BufferLength;
            }

            if( NT_SUCCESS(Status)) {
                if( CmAreCallbacksRegistered() ) {
                    REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION QueryMultipleValueInfo;
            
                    QueryMultipleValueInfo.Object = KeyBody;
                    QueryMultipleValueInfo.ValueEntries = ValueEntries;
                    QueryMultipleValueInfo.EntryCount = EntryCount;
                    QueryMultipleValueInfo.ValueBuffer = ValueBuffer;
                    QueryMultipleValueInfo.BufferLength = BufferLength;
                    QueryMultipleValueInfo.RequiredBufferLength = RequiredBufferLength;

                    Status = CmpCallCallBacks(RegNtQueryMultipleValueKey,&QueryMultipleValueInfo);
                }

                if( NT_SUCCESS(Status)) {
                    // not here because we want to catch user buffer misalignments
                    //BEGIN_LOCK_CHECKPOINT;
                    Status = CmQueryMultipleValueKey(KeyBody->KeyControlBlock,
                                                     ValueEntries,
                                                     EntryCount,
                                                     ValueBuffer,
                                                     &LocalBufferLength,
                                                     RequiredBufferLength);
                    //END_LOCK_CHECKPOINT;
                    // anybody messed with BufferLength in between?
                    *BufferLength = LocalBufferLength;
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryMultipleValueKey: code:%08lx\n",GetExceptionCode()));
            Status = GetExceptionCode();
        }


        ObDereferenceObject((PVOID)KeyBody);
    }

    // End registry call tracing
    EndWmiCmTrace(Status,EntryCount,NULL,EVENT_TRACE_TYPE_REGQUERYMULTIPLEVALUE);

    return(Status);

}

NTSTATUS
CmpNameFromAttributes(
    IN POBJECT_ATTRIBUTES Attributes,
    KPROCESSOR_MODE PreviousMode,
    OUT PUNICODE_STRING FullName
    )

/*++

Routine Description:

    This is a helper routine that converts OBJECT_ATTRIBUTES into a
    full object pathname.  This is needed because we cannot pass handles
    to the worker thread, since it runs in a different process.

    This routine will also probe and capture the attributes based on
    PreviousMode.

    Storage for the string buffer is allocated from paged pool, and should
    be freed by the caller.

Arguments:

    Attributes - Supplies the object attributes to be converted to a pathname

    PreviousMode - Supplies the previous mode.

    Name - Returns the object pathname.

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES CapturedAttributes;
    UNICODE_STRING FileName;
    UNICODE_STRING RootName;
    NTSTATUS Status;
    ULONG ObjectNameLength;
    UCHAR ObjectNameInfo[512];
    POBJECT_NAME_INFORMATION ObjectName;
    PWSTR End;
    PUNICODE_STRING CapturedObjectName;
    ULONG   Length;

    PAGED_CODE();
    FullName->Buffer = NULL;            // so we know whether to free it in our exception handler
    try {

        //
        // Probe the object attributes if necessary.
        //
        if (PreviousMode == UserMode) {
            ProbeForReadSmallStructure(Attributes,
                                       sizeof(OBJECT_ATTRIBUTES),
                                       sizeof(ULONG));
            CapturedObjectName = Attributes->ObjectName;
            FileName = ProbeAndReadUnicodeString(CapturedObjectName);
            ProbeForRead(FileName.Buffer,
                         FileName.Length,
                         sizeof(WCHAR));
        } else {
            FileName = *(Attributes->ObjectName);
        }

        CapturedAttributes = *Attributes;

        if (CapturedAttributes.RootDirectory != NULL) {

            if ((FileName.Buffer != NULL) &&
                (FileName.Length >= sizeof(WCHAR)) &&
                (*(FileName.Buffer) == OBJ_NAME_PATH_SEPARATOR)) {
                return(STATUS_OBJECT_PATH_SYNTAX_BAD);
            }

            //
            // Find the name of the root directory and append the
            // name of the relative object to it.
            //

            Status = ZwQueryObject(CapturedAttributes.RootDirectory,
                                   ObjectNameInformation,
                                   &ObjectNameInfo,
                                   sizeof(ObjectNameInfo),
                                   &ObjectNameLength);

            ObjectName = (POBJECT_NAME_INFORMATION)ObjectNameInfo;
            if (!NT_SUCCESS(Status)) {
                return(Status);
            }
            RootName = ObjectName->Name;

            FullName->Length = 0;
            Length = RootName.Length+FileName.Length+sizeof(WCHAR);
            //
            // Overflow test: If Length overflows the USHRT_MAX value
            //                cleanup and return STATUS_OBJECT_PATH_INVALID
            //
            if( Length>0xFFFF ) {
                return STATUS_OBJECT_PATH_INVALID;
            }

            FullName->MaximumLength = (USHORT)Length;

            FullName->Buffer = ALLOCATE_WITH_QUOTA(PagedPool, FullName->MaximumLength, CM_POOL_TAG);
            if (FullName->Buffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            Status = RtlAppendUnicodeStringToString(FullName, &RootName);
            ASSERT(NT_SUCCESS(Status));

            //
            // Append a trailing separator if necessary.
            //
            if( FullName->Length != 0 ) {
                End = (PWSTR)((PUCHAR)FullName->Buffer + FullName->Length) - 1;
                if (*End != OBJ_NAME_PATH_SEPARATOR) {
                    ++End;
                    *End = OBJ_NAME_PATH_SEPARATOR;
                    FullName->Length += sizeof(WCHAR);
                }
            }

            Status = RtlAppendUnicodeStringToString(FullName, &FileName);
            ASSERT(NT_SUCCESS(Status));

        } else {

            //
            // RootDirectory is NULL, so just use the name.
            //
            FullName->Length = FileName.Length;
            FullName->MaximumLength = FileName.Length;
            FullName->Buffer = ALLOCATE_WITH_QUOTA(PagedPool, FileName.Length, CM_POOL_TAG);
            if (FullName->Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlCopyMemory(FullName->Buffer,
                              FileName.Buffer,
                              FileName.Length);
                Status = STATUS_SUCCESS;
            }
        }


    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpNameFromAttributes: code %08lx\n", Status));
        if (FullName->Buffer != NULL) {
            ExFreePool(FullName->Buffer);
        }
    }

    return(Status);
}

VOID
CmpFreePostBlock(
    IN PCM_POST_BLOCK PostBlock
    )

/*++

Routine Description:

    Frees the various bits of pool that were allocated for a postblock

Arguments:

    None

Return Value:

    None.

--*/

{

#if DBG
    if(PostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"[CM]CmpFreePostBlock: PostBlock:%p\t", PostBlock));
        if( PostBlock->NotifyType&REG_NOTIFY_MASTER_POST) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"--MasterBlock\n"));
        } else {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"--SlaveBlock\n"));
        }
    }
#endif

#ifdef CMP_ENTRYLIST_MANIPULATION
    // check if the post block has been removed from the notify and thread list(s)
    if((PostBlock->NotifyList.Flink != NULL) || (PostBlock->NotifyList.Blink != NULL)) {
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFreePostBlock: Attempt to free post block %08lx not removed from notify list\n",PostBlock);
        DbgBreakPoint();
    }
    if((PostBlock->ThreadList.Flink != NULL) || (PostBlock->ThreadList.Blink != NULL)) {
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFreePostBlock: Attempt to free post block %08lx not removed from thread list\n",PostBlock);
        DbgBreakPoint();
    }

#endif //CMP_ENTRYLIST_MANIPULATION

    // Protect for multiple deletion of the same object
    CmpClearListEntry(&(PostBlock->CancelPostList));

    //
    // Cleanup for objects referenced by NtNotifyMultipleKeys
    //
    if( PostBlock->PostKeyBody) {

        //
        // If we have a PostKeyBody, the attached key body must not be NULL
        //
        ASSERT(PostBlock->PostKeyBody->KeyBody);

        //
        // KeyBodyList must be used only in CmpPostBlock implementation for the delayed dereferencing mechanism.
        //
        ASSERT(IsListEmpty(&(PostBlock->PostKeyBody->KeyBodyList)));

        //
        // dereference the actual keybody
        //
        ObDereferenceObject(PostBlock->PostKeyBody->KeyBody);

        //
        // Free the PostKeyBody structure
        //
        ExFreePool(PostBlock->PostKeyBody);
    }

    if( IsMasterPostBlock(PostBlock) ) {
        //
        // this members are allocated only for master post blocks
        //
        switch (PostBlockType(PostBlock)) {
            case PostSynchronous:
                ExFreePool(PostBlock->u->Sync.SystemEvent);
                break;
            case PostAsyncUser:
                ExFreePool(PostBlock->u->AsyncUser.Apc);
                break;
            case PostAsyncKernel:
                break;
        }
        ExFreePool(PostBlock->u);
    }

#ifdef CM_NOTIFY_CHANGED_KCB_FULLPATH
    //
    // get rid of the kcb name allocated in CmpPostNotify
    //
    if( PostBlock->ChangedKcbFullName != NULL ) {
        ExFreePoolWithTag(PostBlock->ChangedKcbFullName,CM_FIND_LEAK_TAG43);
    }
#endif //CM_NOTIFY_CHANGED_KCB_FULLPATH

#ifdef CMP_ENTRYLIST_MANIPULATION
    RtlZeroMemory((PVOID)PostBlock, sizeof(CM_POST_BLOCK));
#endif //CMP_ENTRYLIST_MANIPULATION

    // and the storage for the Post object
    ExFreePool(PostBlock);
}


PCM_POST_BLOCK
CmpAllocatePostBlock(
    IN POST_BLOCK_TYPE  BlockType,
    IN ULONG            PostFlags,
    IN PCM_KEY_BODY     KeyBody,
    IN PCM_POST_BLOCK   MasterBlock
    )

/*++

Routine Description:

    Allocates a post block from pool.  The non-pagable stuff comes from
    NonPagedPool, the pagable stuff from paged pool.  Quota will be
    charged.

Arguments:

    BlockType  - specifies the type of the post block to be allocated
                i.e. : PostSyncrhronous, PostAsyncUser, PostAsyncKernel

    PostFlags      - specifies the flags to be set on the allocated post block
                vallid flags:
                    - REG_NOTIFY_MASTER_POST - the post block to be allocated
                      is a master post block.
    KeyBody     - The Key object to whom this post block is attached. On master blocks
                  this is NULL. When the post object is freed, the KeyBody object is
                  dereferenced (if not NULL - i.e. for slave blocks). This allow us to
                  perform back-end cleanup for "fake-slave" keys opened by NtNotifyMultipleKeys
    MasterBlock - the post block to be allocated is a slave of this master block.
                  valid only when PostFlags ==  REG_NOTIFY_MASTER_POST


Obs: The Sync.SystemEvent and AsyncUser.Apc members are allocated only for master post blocks

Return Value:

    Pointer to the CM_POST_BLOCK if successful

    NULL if there were not enough resources available.

--*/

{
    PCM_POST_BLOCK PostBlock;

    // protection against outrageous calls
    ASSERT( !PostFlags || (!MasterBlock && !KeyBody) );

    PostBlock = ALLOCATE_WITH_QUOTA(PagedPool, sizeof(CM_POST_BLOCK),CM_POSTBLOCK_TAG);
    if (PostBlock==NULL) {
        return(NULL);
    }

#ifdef CMP_ENTRYLIST_MANIPULATION
    RtlZeroMemory((PVOID)PostBlock, sizeof(CM_POST_BLOCK));
#endif //CMP_ENTRYLIST_MANIPULATION

#if DBG
    PostBlock->TraceIntoDebugger = FALSE;
#endif

    PostBlock->NotifyType = (ULONG)BlockType;
    PostBlock->NotifyType |= PostFlags;

#ifdef CM_NOTIFY_CHANGED_KCB_FULLPATH
    PostBlock->ChangedKcbFullName = NULL;
    PostBlock->CallerBuffer = NULL;
    PostBlock->CallerBufferSize = 0;
#endif //CM_NOTIFY_CHANGED_KCB_FULLPATH

    if(IsMasterPostBlock(PostBlock)) {
        PostBlock->PostKeyBody = NULL;
        //
        // master post block ==> allocate the storage
        //
        PostBlock->u = ALLOCATE_WITH_QUOTA(NonPagedPool,
                                           sizeof(CM_POST_BLOCK_UNION),
                                           CM_FIND_LEAK_TAG44);
        if (PostBlock->u == NULL) {
            ExFreePool(PostBlock);
            return(NULL);
        }

         switch (BlockType) {
            case PostSynchronous:
                PostBlock->u->Sync.SystemEvent = ALLOCATE_WITH_QUOTA(NonPagedPool,
                                                                    sizeof(KEVENT),
                                                                    CM_POSTEVENT_TAG);
                if (PostBlock->u->Sync.SystemEvent == NULL) {
                    ExFreePool(PostBlock->u);
                    ExFreePool(PostBlock);
                    return(NULL);
                }
                KeInitializeEvent(PostBlock->u->Sync.SystemEvent,
                                  SynchronizationEvent,
                                  FALSE);
                break;
            case PostAsyncUser:
                PostBlock->u->AsyncUser.Apc = ALLOCATE_WITH_QUOTA(NonPagedPool,
                                                             sizeof(KAPC),
                                                             CM_POSTAPC_TAG);
                if (PostBlock->u->AsyncUser.Apc==NULL) {
                    ExFreePool(PostBlock->u);
                    ExFreePool(PostBlock);
                    return(NULL);
                }
                break;
            case PostAsyncKernel:
                RtlZeroMemory(&PostBlock->u->AsyncKernel, sizeof(CM_ASYNC_KERNEL_POST_BLOCK));
                break;
        }
    } else {
        //
        // Slave post block ==> copy storage allocated for the master post block
        //
        PostBlock->u = MasterBlock->u;

        //
        // allocate a PostKeyBody which will hold this KeyBody, and initialize the head of its KeyBodyList
        //
        PostBlock->PostKeyBody = ALLOCATE_WITH_QUOTA(PagedPool| POOL_COLD_ALLOCATION, sizeof(CM_POST_KEY_BODY),CM_FIND_LEAK_TAG45);
        if (PostBlock->PostKeyBody == NULL) {
            ExFreePool(PostBlock);
            return(NULL);
        }
        PostBlock->PostKeyBody->KeyBody = KeyBody;
        InitializeListHead(&(PostBlock->PostKeyBody->KeyBodyList));
    }

    return(PostBlock);
}

#if DBG

#ifdef DRAGOSS_PRIVATE_DEBUG
LOGICAL CmpExceptionBreak = TRUE;
#else
LOGICAL CmpExceptionBreak = FALSE;
#endif //DRAGOSS_PRIVATE_DEBUG


ULONG
CmpExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )

/*++

Routine Description:

    Debug code to find registry exceptions that are being swallowed

Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/

{
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CM: Registry exception %lx, ExceptionPointers = %p\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers));

    if (CmpExceptionBreak == TRUE) {

        try {
            DbgBreakPoint();
        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // no debugger enabled, just keep going
            //

        }
    }

    return(EXCEPTION_EXECUTE_HANDLER);
}

#endif

ULONG   CmpOpenSubKeys;

#if 0

BOOLEAN
CmpEnumKeyObjectCallback(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG HandleCount,
    IN ULONG PointerCount,
    IN PVOID Context
    )
{
    PCM_KEY_BODY    KeyBody;
    PHHIVE          Hive;

    KeyBody = (PCM_KEY_BODY)Object;
    Hive = (PHHIVE)Context;

    if( KeyBody->KeyControlBlock->KeyHive == Hive ) {
        //
        // that's and open subkey inside of the hive
        //
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Key %wZ (HandleCount = %lu PointerCount = %lu) is opened by process %lx\n",
                        ObjectName,HandleCount,PointerCount,KeyBody->Process);
#endif //_CM_LDR_

        // count it
        CmpOpenSubKeys++;
    }

    return TRUE;
}

#endif

NTSTATUS
NtQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    )
/*++

Routine Description:

    Dumps all the subkeys of the target key that are kept open by some other
    process; Returns the number of open subkeys


Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS - values TBS.

--*/
{
    HANDLE KeyHandle;
    NTSTATUS Status;
    PCM_KEY_BODY   KeyBody;
    PHHIVE Hive;
    HCELL_INDEX Cell;
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING  HiveName;

    PAGED_CODE();

#ifdef CMP_STATS
    CmpStatsDebug.CmpNtQueryOpenSubKeysNo++;
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryOpenSubKeys\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey =%p\n", TargetKey));

    PreviousMode = KeGetPreviousMode();

    try {

        if (PreviousMode == UserMode) {
            ProbeForWriteUlong(HandleCount);
        }

        Status = ObOpenObjectByName(TargetKey,
                                    CmpKeyObjectType,
                                    PreviousMode,
                                    NULL,
                                    KEY_READ,
                                    NULL,
                                    &KeyHandle);
        if (NT_SUCCESS(Status)) {
            Status = ObReferenceObjectByHandle(KeyHandle,
                                               KEY_READ,
                                               CmpKeyObjectType,
                                               PreviousMode,
                                               (PVOID *)&KeyBody,
                                               NULL);
            NtClose(KeyHandle);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryOpenSubKeys: code:%08lx\n", Status));
    }

    if (NT_SUCCESS(Status)) {
        //
        // lock registry exclusive so nobody messes with it while we're around
        //
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        if( KeyBody->KeyControlBlock->Delete ) {
            CmpUnlockRegistry();
            ObDereferenceObject((PVOID)KeyBody);
            return(STATUS_KEY_DELETED);
        }

        Hive = KeyBody->KeyControlBlock->KeyHive;
        Cell = KeyBody->KeyControlBlock->KeyCell;

        //
        // Make sure the cell passed in is the root cell of the hive.
        //
        if (Cell != Hive->BaseBlock->RootCell) {
            CmpUnlockRegistry();
            ObDereferenceObject((PVOID)KeyBody);
            return(STATUS_INVALID_PARAMETER);
        }

        //
        // Dump the hive name and hive address
        //
        RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\n Subkeys open inside the hive (%p) (%.*S) :\n\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer);
#endif //_CM_LDR_

        //
        // dump open subkeys (if any)
        //
        CmpOpenSubKeys = CmpSearchForOpenSubKeys(KeyBody->KeyControlBlock,SearchAndCount);
#if 0
        //
        // use a global var to count the number of subkeys, as this is the only
        // way interfere with the Enum callback; It is safe to use as this will
        // be the only thread working on this global var (registry is locked exclusively)
        //
        CmpOpenSubKeys = 0;
        ObEnumerateObjectsByType(
            CmpKeyObjectType,
            CmpEnumKeyObjectCallback,
            Hive
            );
#endif

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        CmpUnlockRegistry();

        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);
        try {
            //
            // protect user mode memory
            //
            *HandleCount = CmpOpenSubKeys;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }
    }

    return(Status);
}

#ifdef NT_RENAME_KEY
NTSTATUS
NtRenameKey(
    IN HANDLE           KeyHandle,
    IN PUNICODE_STRING  NewName
    )

/*++

Routine Description:

    Renames the key specified by Handle.

Arguments:

    NewFile - specifies the key to be renamed

    NewName - the new name the key will have if the API succeedes

Return Value:

    NTSTATUS - values TBS.

--*/
{
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING  LocalKeyName;
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;

    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtRenameKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tNewName='%wZ'\n", NewName));

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_WRITE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        try {
            if (mode == UserMode) {
                LocalKeyName = ProbeAndReadUnicodeString(NewName);
                ProbeForRead(
                    LocalKeyName.Buffer,
                    LocalKeyName.Length,
                    sizeof(WCHAR)
                    );
            } else {
                LocalKeyName = *NewName;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtRenameKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        //
        // we really need exclusive access here
        //
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistryExclusive();

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        //
        // flush notifications for all open objects on this key
        //
        CmpFlushNotifiesOnKeyBodyList(KeyBody->KeyControlBlock);

        if( NT_SUCCESS(status) ) {
            if( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                //
                // key is protected
                //
                status = STATUS_ACCESS_DENIED;
            } else {
                if( CmAreCallbacksRegistered() ) {
                    REG_RENAME_KEY_INFORMATION RenameKeyInfo;
            
                    RenameKeyInfo.Object = KeyBody;
                    RenameKeyInfo.NewName = &LocalKeyName;

                    status = CmpCallCallBacks(RegNtRenameKey,&RenameKeyInfo);
                }
                if( NT_SUCCESS(status) ) { 
                    status = CmRenameKey(KeyBody->KeyControlBlock,LocalKeyName);
                }
            }
        }

#ifdef CHECK_REGISTRY_USECOUNT
        CmpCheckRegistryUseCount();
#endif //CHECK_REGISTRY_USECOUNT

        //
        // we need to release just here, after the kcb has been kicked out of cache
        //
        CmpUnlockRegistry();
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);

    } else {
        //
        // just in case we want to add wmi tracing for this API
        //
        LocalKeyName.Buffer = NULL;
        LocalKeyName.Length = 0;
    }

    return status;
}
#endif


ULONG
CmpKeyInfoProbeAlingment(
                             IN KEY_INFORMATION_CLASS KeyInformationClass
                        )
{
    switch(KeyInformationClass)
    {
    case KeyBasicInformation:
        return PROBE_ALIGNMENT(KEY_BASIC_INFORMATION);

    case KeyNodeInformation:
        return PROBE_ALIGNMENT(KEY_NODE_INFORMATION);

    case KeyFullInformation:
        return PROBE_ALIGNMENT(KEY_FULL_INFORMATION);

    case KeyNameInformation:
        return PROBE_ALIGNMENT(KEY_NAME_INFORMATION);

    case KeyCachedInformation:
        return PROBE_ALIGNMENT(KEY_CACHED_INFORMATION);

    case KeyFlagsInformation:
        return PROBE_ALIGNMENT(KEY_FLAGS_INFORMATION);

    default:
        ASSERT(FALSE);
    }

    return PROBE_ALIGNMENT(ULONG);
}

NTSTATUS
NtCompactKeys(
    IN ULONG Count,
    IN HANDLE KeyArray[]
            )
/*++

Routine Description:

    Compacts the keys in the given array together, so they will
    end up in the same bin (or adjacent)

Arguments:

    Count - number of keys in the array

    KeyArray - array of keys to be compacted.

Return Value:

    NTSTATUS - values TBS.

--*/

{
    NTSTATUS        status = STATUS_SUCCESS;
    NTSTATUS        status2;
    PCM_KEY_BODY    *KeyBodyArray = NULL;
    ULONG           i;
    PHHIVE          KeyHive;
    PCMHIVE         CmHive;
    KPROCESSOR_MODE mode;


    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtCompactKeys\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tCount=%08lx\n", Count));


    mode = KeGetPreviousMode();

    if( Count == 0 ) {
        //
        // noop
        //
        return STATUS_SUCCESS;
    }

    if( Count >= (((ULONG)0xFFFFFFFF)/sizeof(PCM_KEY_BODY)) ) {
        return STATUS_INVALID_PARAMETER;
    }

    if (mode == UserMode) {
        try {
            ProbeForRead(KeyArray,
                         Count * sizeof(HANDLE),
                         sizeof(ULONG));
        } except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
            return status;
        }
    }

    KeyBodyArray =  ExAllocatePool(PagedPool,Count * sizeof(PCM_KEY_BODY));

    if( KeyBodyArray == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // reference each handle and make sure they are inside the same hive
    //
    try {

        for(i=0;i<Count;i++) {
            status = ObReferenceObjectByHandle(
                        KeyArray[i],
                        KEY_WRITE,
                        CmpKeyObjectType,
                        mode,
                        (PVOID *)(&(KeyBodyArray[i])),
                        NULL
                        );
            if(!NT_SUCCESS(status)) {
                //
                // cleanup
                //
                for(;i;i--) {
                    ObDereferenceObject((PVOID)(KeyBodyArray[i-1]));
                }
                ExFreePool(KeyBodyArray);
                return status;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        //
        // cleanup
        //
        for(;i;i--) {
            ObDereferenceObject((PVOID)(KeyBodyArray[i-1]));
        }
        ExFreePool(KeyBodyArray);
        return status;

    }

    BEGIN_LOCK_CHECKPOINT;
    CmpLockRegistryExclusive();

    for(i=0;i<Count;i++) {
        if( (KeyBodyArray[i])->KeyControlBlock->Delete ) {
            status = STATUS_KEY_DELETED;
            goto Exit;
        }
        if( i > 0 ) {
            if( KeyHive != (KeyBodyArray[i])->KeyControlBlock->KeyHive ) {
                //
                // Ooops, not same hive
                //
                status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
        } else {
            KeyHive = (KeyBodyArray[i])->KeyControlBlock->KeyHive;
        }

    }
    //
    // set the hive into "Grow Only mode"
    //
    CmHive = (PCMHIVE)CONTAINING_RECORD(KeyHive, CMHIVE, Hive);
    CmHive->GrowOnlyMode = TRUE;
    CmHive->GrowOffset = KeyHive->Storage[Stable].Length;
    //KdPrint(("Length before compaction=%08lx\n", CmHive->GrowOffset));

    //
    // truncate to the CM_VIEW_SIZE segment
    //
    CmHive->GrowOffset += HBLOCK_SIZE;
    CmHive->GrowOffset &= (~(CM_VIEW_SIZE - 1));
    if( CmHive->GrowOffset ) {
        CmHive->GrowOffset -= HBLOCK_SIZE;
    }

    //
    // move each kcb at offset > HiveLength
    //
    for(i=0;i<Count;i++) {
        status2 = CmMoveKey((KeyBodyArray[i])->KeyControlBlock);
        if( !NT_SUCCESS(status2) && NT_SUCCESS(status)) {
            //
            // record the status and go on with the remaining
            //
            status = status2;
        }
    }


    //KdPrint(("Length after compaction=%08lx\n", KeyHive->Storage[Stable].Length));

    //
    // reset the "Grow Only mode" to normal
    //
    CmHive->GrowOnlyMode = FALSE;
    CmHive->GrowOffset = 0;

Exit:
    CmpUnlockRegistry();
    END_LOCK_CHECKPOINT;

    //
    // cleanup
    //
    for(i=0;i<Count;i++) {
        ObDereferenceObject((PVOID)(KeyBodyArray[i]));
    }
    ExFreePool(KeyBodyArray);

    return status;
}


NTSTATUS
NtCompressKey(
    IN HANDLE Key
            )
/*++

Routine Description:

    Compresses the specified key (must be the root of a hive),
    by simulating an "in-place" SaveKey.

Arguments:


    Key - root of the hive to be compressed.

Return Value:

    NTSTATUS - values TBS.

--*/
{
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;


    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtCompressKey\n"));


    mode = KeGetPreviousMode();

    //
    // DRAGOSS: see if we need this
    //
    // Check to see if the caller has the privilege to make this call.
    //
    //if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
    //    return(STATUS_PRIVILEGE_NOT_HELD);
    //}

    status = ObReferenceObjectByHandle(
                Key,
                KEY_WRITE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );
    if(NT_SUCCESS(status)) {
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistryExclusive();
        //
        // no edits, on keys marked for deletion
        //
        if (KeyBody->KeyControlBlock->Delete) {
            status = STATUS_KEY_DELETED;
        } else if( KeyBody->KeyControlBlock->KeyCell != KeyBody->KeyControlBlock->KeyHive->BaseBlock->RootCell ) {
            status = STATUS_INVALID_PARAMETER;
        } else {
            status = CmCompressKey(KeyBody->KeyControlBlock->KeyHive);
        }

        CmpUnlockRegistry();
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);
    }


    return status;
}

NTSTATUS
NtLockRegistryKey(
    IN HANDLE           KeyHandle
    )

/*++

Routine Description:

    Locks the specified registry key for writing

Arguments:

    KeyHandle - Handle of the key to be locked.

Return Value:

    NTSTATUS - values TBS.

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();


    if( (PreviousMode != KernelMode) || 
        !SeSinglePrivilegeCheck(SeLockMemoryPrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_WRITE,
                CmpKeyObjectType,
                PreviousMode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // we only need shared access
        //
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistry();

        status = CmLockKcbForWrite(KeyBody->KeyControlBlock);

        CmpUnlockRegistry();
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\hivemap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivemap.c

Abstract:

    This module implements HvpBuildMap - used to build the initial map for a hive

Author:

    Bryan M. Willman (bryanwi) 28-Mar-92

Environment:


Revision History:
    Dragos C. Sambotin (dragoss) 25-Jan-99
        Implementation of bin-size chunk loading of hives.
--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpBuildMap)
#pragma alloc_text(PAGE,HvpFreeMap)
#pragma alloc_text(PAGE,HvpAllocateMap)
#pragma alloc_text(PAGE,HvpBuildMapAndCopy)
#pragma alloc_text(PAGE,HvpEnlistFreeCells)
#pragma alloc_text(PAGE,HvpInitMap)
#pragma alloc_text(PAGE,HvpCleanMap)
#pragma alloc_text(PAGE,HvpEnlistBinInMap)
#pragma alloc_text(PAGE,HvpGetBinMemAlloc)
#endif

extern struct {
    PHHIVE      Hive;
    ULONG       Status;
    ULONG       Space;
    HCELL_INDEX MapPoint;
    PHBIN       BinPoint;
} HvCheckHiveDebug;

//Dragos: Modified functions
NTSTATUS
HvpBuildMapAndCopy(
    PHHIVE  Hive,
    PVOID   Image
    )
/*++

Routine Description:

    Creates the map for the Stable storage of the hive, and inits
    the map for the volatile storage.

    Following fields in hive must already be filled in:

         Allocate, Free

    Will initialize Storage structure of HHIVE.

    This function is called for the HINIT_MEMORY case. The hive is guaranteed
    to be in paged-pool. More than that, the hive image is contiguous. 
    It'll then copy from that image to the new paged-pool allocations.

Arguments:

    Hive - Pointer to hive control structure to build map for.

    Image - pointer to flat memory image of original hive.

Return Value:

    TRUE - it worked
    FALSE - either hive is corrupt or no memory for map

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           Length;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_TABLE     t = NULL;
    PHMAP_DIRECTORY d = NULL;
    PHBIN           Bin;
    PHBIN           CurrentBin;
    ULONG           Offset;
    ULONG_PTR       Address;
    PHMAP_ENTRY     Me;
    NTSTATUS        Status;
    PULONG          Vector;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpBuildMap:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p",Hive));


    //
    // Compute size of data region to be mapped
    //
    BaseBlock = Hive->BaseBlock;
    Length = BaseBlock->Length;
    if ((Length % HBLOCK_SIZE) != 0 ) {
        Status = STATUS_REGISTRY_CORRUPT;
        goto ErrorExit1;
    }
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    Hive->Storage[Stable].Length = Length;

    //
    // allocate dirty vector if one is not already present (from HvpRecoverData)
    //

    if (Hive->DirtyVector.Buffer == NULL) {
        Vector = (PULONG)((Hive->Allocate)(ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG)), TRUE,CM_FIND_LEAK_TAG22));
        if (Vector == NULL) {
            Status = STATUS_NO_MEMORY;
            goto ErrorExit1;
        }
        RtlZeroMemory(Vector, Length / HSECTOR_SIZE / 8);
        RtlInitializeBitMap(&Hive->DirtyVector, Vector, Length / HSECTOR_SIZE);
        Hive->DirtyAlloc = ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG));
    }

    //
    // allocate and build structure for map
    //
    if (Tables == 0) {

        //
        // Just 1 table, no need for directory
        //
        t = (Hive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG23);
        if (t == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(t, sizeof(HMAP_TABLE));
        Hive->Storage[Stable].Map =
            (PHMAP_DIRECTORY)&(Hive->Storage[Stable].SmallDir);
        Hive->Storage[Stable].SmallDir = t;

    } else {

        //
        // Need directory and multiple tables
        //
        d = (PHMAP_DIRECTORY)(Hive->Allocate)(sizeof(HMAP_DIRECTORY), FALSE,CM_FIND_LEAK_TAG24);
        if (d == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(d, sizeof(HMAP_DIRECTORY));

        //
        // Allocate tables and fill in dir
        //
        if (HvpAllocateMap(Hive, d, 0, Tables) == FALSE) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        Hive->Storage[Stable].Map = d;
        Hive->Storage[Stable].SmallDir = 0;
    }

    //
    // Now we have to allocate the memory for the HBINs and fill in
    // the map appropriately.  We are careful never to allocate less
    // than a page to avoid fragmenting pool.  As long as the page
    // size is a multiple of HBLOCK_SIZE (a fairly good assumption as
    // long as HBLOCK_SIZE is 4k) this strategy will prevent pool
    // fragmentation.
    //
    // If we come across an HBIN that is entirely composed of a freed
    // HCELL, then we do not allocate memory, but mark its HBLOCKs in
    // the map as not present.  HvAllocateCell will allocate memory for
    // the bin when it is needed.
    //
    Offset = 0;
    Bin = (PHBIN)Image;

    while (Bin < (PHBIN)((PUCHAR)(Image) + Length)) {

        if ( (Bin->Size > (Length-Offset))      ||
             (Bin->Signature != HBIN_SIGNATURE) ||
             (Bin->FileOffset != Offset)
           )
        {
            //
            // Bin is bogus
            //
            Status = STATUS_REGISTRY_CORRUPT;
            goto ErrorExit2;
        }

        CurrentBin = (PHBIN)(Hive->Allocate)(Bin->Size, FALSE,CM_FIND_LEAK_TAG25);
        if (CurrentBin==NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;        //fixfix
        }
        RtlCopyMemory(CurrentBin,
                      (PUCHAR)Image+Offset,
                      Bin->Size);

        //
        // create map entries for each block/page in bin
        //
        Address = (ULONG_PTR)CurrentBin;
        do {
            Me = HvpGetCellMap(Hive, Offset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);
            Me->BlockAddress = Address;
            Me->BinAddress = (ULONG_PTR)CurrentBin;

            if (Address == (ULONG_PTR)CurrentBin) {
                Me->BinAddress |= HMAP_NEWALLOC;
                Me->MemAlloc = CurrentBin->Size;
            } else {
                Me->MemAlloc = 0;
            }

            Me->BinAddress |= HMAP_INPAGEDPOOL;
            // we don't need to set this - just for debug purposes
            ASSERT( (Me->CmView = NULL) == NULL );

            Address += HBLOCK_SIZE;
            Offset += HBLOCK_SIZE;
        } while ( Address < ((ULONG_PTR)CurrentBin + CurrentBin->Size ));

        if (Hive->ReadOnly == FALSE) {

            //
            // add free cells in the bin to the appropriate free lists
            //
            if ( ! HvpEnlistFreeCells(Hive,
                                      CurrentBin,
                                      CurrentBin->FileOffset
                                      )) {
                Status = STATUS_REGISTRY_CORRUPT;
                goto ErrorExit2;
            }
        }

        Bin = (PHBIN)((ULONG_PTR)Bin + Bin->Size);
    }

    return STATUS_SUCCESS;


ErrorExit2:
    if (d != NULL) {

        //
        // directory was built and allocated, so clean it up
        //

        HvpFreeMap(Hive, d, 0, Tables);
        (Hive->Free)(d, sizeof(HMAP_DIRECTORY));
    }

ErrorExit1:
    return Status;
}

NTSTATUS
HvpInitMap(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Initialize the map for the Stable Volatile storage of the hive.

    Following fields in hive must already be filled in:

         Allocate, Free

    Will initialize Storage structure of HHIVE.

Arguments:

    Hive - Pointer to hive control structure to build map for.

Return Value:

    STATUS_SUCCESS - it worked
    STATUS_xxx - the errorneous status

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           Length;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_TABLE     t = NULL;
    PHMAP_DIRECTORY d = NULL;
    NTSTATUS        Status;
    PULONG          Vector = NULL;

    
#ifndef _CM_LDR_
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpInitMap:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p",Hive));
#endif //_CM_LDR_

    //
    // Compute size of data region to be mapped
    //
    BaseBlock = Hive->BaseBlock;
    Length = BaseBlock->Length;
    if ((Length % HBLOCK_SIZE) != 0) {
        Status = STATUS_REGISTRY_CORRUPT;
        goto ErrorExit1;
    }
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    Hive->Storage[Stable].Length = Length;

    //
    // allocate dirty vector if one is not already present (from HvpRecoverData)
    //

    if (Hive->DirtyVector.Buffer == NULL) {
        Vector = (PULONG)((Hive->Allocate)(ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG)), TRUE,CM_FIND_LEAK_TAG27));
        if (Vector == NULL) {
            Status = STATUS_NO_MEMORY;
            goto ErrorExit1;
        }
        RtlZeroMemory(Vector, Length / HSECTOR_SIZE / 8);
        RtlInitializeBitMap(&Hive->DirtyVector, Vector, Length / HSECTOR_SIZE);
        Hive->DirtyAlloc = ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG));
    }

    //
    // allocate and build structure for map
    //
    if (Tables == 0) {

        //
        // Just 1 table, no need for directory
        //
        t = (Hive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG26);
        if (t == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(t, sizeof(HMAP_TABLE));
        Hive->Storage[Stable].Map =
            (PHMAP_DIRECTORY)&(Hive->Storage[Stable].SmallDir);
        Hive->Storage[Stable].SmallDir = t;

    } else {

        //
        // Need directory and multiple tables
        //
        d = (PHMAP_DIRECTORY)(Hive->Allocate)(sizeof(HMAP_DIRECTORY), FALSE,CM_FIND_LEAK_TAG28);
        if (d == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(d, sizeof(HMAP_DIRECTORY));

        //
        // Allocate tables and fill in dir
        //
        if (HvpAllocateMap(Hive, d, 0, Tables) == FALSE) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        Hive->Storage[Stable].Map = d;
        Hive->Storage[Stable].SmallDir = 0;
    }

    return STATUS_SUCCESS;

ErrorExit2:
    if (d != NULL) {

        //
        // directory was built and allocated, so clean it up
        //

        HvpFreeMap(Hive, d, 0, Tables);
        (Hive->Free)(d, sizeof(HMAP_DIRECTORY));
    }

ErrorExit1:
    if( Vector ) {
        (Hive->Free)(Vector, ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG)));
        Hive->DirtyVector.Buffer = NULL;
    }
    return Status;
}

NTSTATUS
HvpEnlistBinInMap(
    PHHIVE  Hive,
    ULONG   Length,
    PHBIN   Bin,
    ULONG   Offset,
    PVOID CmView OPTIONAL
    )
/*++

Routine Description:

    Creates map entries and enlist free cells for the specified bin 

Arguments:

    Hive - Pointer to hive control structure containing the target map

    Length - the Length of the hive image

    Bin - the bin to be enlisted

    Offset - the offset within the hive file

    CmView - pointer to the mapped view of the bin. If NULL, the bin resides in paged pool

Return Value:

    STATUS_SUCCESS - it worked
    STATUS_REGISTRY_CORRUPT - the bin is inconsistent
    STATUS_REGISTRY_RECOVERED - if we have fixed the bin on-the-fly (self heal feature).

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           BinOffset;
    ULONG_PTR       Address;
    PHMAP_ENTRY     Me;

#ifndef _CM_LDR_
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpEnlistBinInMap:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p\t Offset=%08lx",Hive,Offset));
#endif //_CM_LDR_

#ifndef _CM_LDR_
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpEnlistBinInMap: BinAddress = 0x%p\t Size = 0x%lx\n", Bin, Bin->Size));
#endif //_CM_LDR_

    //
    // create map entries for each block/page in bin
    //
    BinOffset = Offset;
    for (Address = (ULONG_PTR)Bin;
         Address < ((ULONG_PTR)Bin + Bin->Size);
         Address += HBLOCK_SIZE
        )
    {
        Me = HvpGetCellMap(Hive, Offset);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);
        Me->BlockAddress = Address;
        Me->BinAddress = (ULONG_PTR)Bin;
        if (Offset == BinOffset) {
            Me->BinAddress |= HMAP_NEWALLOC;
            Me->MemAlloc = Bin->Size;
        } else {
            Me->MemAlloc = 0;
        }
        
        //
        // take care here !!!!!
        // 
        if( CmView == NULL ) {
            Me->BinAddress |= HMAP_INPAGEDPOOL;
            // we don't need to set this - just for debug purposes
            ASSERT( (Me->CmView = NULL) == NULL );
        } else {
            Me->BinAddress |= HMAP_INVIEW;
            // this should be already set by now
            //ASSERT( Me->CmView == CmView );
        }
        
        Offset += HBLOCK_SIZE;
    }

    if (Hive->ReadOnly == FALSE) {

        //
        // add free cells in the bin to the apropriate free lists
        //
        if ( ! HvpEnlistFreeCells(Hive, Bin, BinOffset)) {
            HvCheckHiveDebug.Hive = Hive;
            HvCheckHiveDebug.Status = 0xA002;
            HvCheckHiveDebug.Space = Length;
            HvCheckHiveDebug.MapPoint = BinOffset;
            HvCheckHiveDebug.BinPoint = Bin;
            if( CmDoSelfHeal() ) {
                Status = STATUS_REGISTRY_RECOVERED;
            } else {
                Status = STATUS_REGISTRY_CORRUPT;
                goto ErrorExit;
            }
        }

    }

    //
    // logical consistency check
    //
    ASSERT(Offset == (BinOffset + Bin->Size));

ErrorExit:
    return Status;
}

NTSTATUS
HvpBuildMap(
    PHHIVE  Hive,
    PVOID   Image
    )
/*++

Routine Description:

    Creates the map for the Stable storage of the hive, and inits
    the map for the volatile storage.

    Following fields in hive must already be filled in:

         Allocate, Free

    Will initialize Storage structure of HHIVE.

Arguments:

    Hive - Pointer to hive control structure to build map for.

    Image - pointer to in memory image of the hive

Return Value:

    TRUE - it worked
    FALSE - either hive is corrupt or no memory for map

--*/
{
    PHBIN           Bin;
    ULONG           Offset;
    NTSTATUS        Status;
    ULONG           Length;


#ifndef _CM_LDR_
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpBuildMap:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p",Hive));
#endif //_CM_LDR_

    //
    // Init the map
    //
    Status = HvpInitMap(Hive);

    if( !NT_SUCCESS(Status) ) {
        //
        // just return failure; HvpInitMap took care of cleanup
        //
        return Status;
    }

    //
    // Fill in the map
    //
    Offset = 0;
    Bin = (PHBIN)Image;
    Length = Hive->Storage[Stable].Length;

    while (Bin < (PHBIN)((PUCHAR)(Image) + Length)) {

        //
        // Check the validity of the bin header
        //
        if ( (Bin->Size > Length)                       ||
             (Bin->Size < HBLOCK_SIZE)                  ||
             (Bin->Signature != HBIN_SIGNATURE)         ||
             (Bin->FileOffset != Offset)) {
            //
            // Bin is bogus
            //
            HvCheckHiveDebug.Hive = Hive;
            HvCheckHiveDebug.Status = 0xA001;
            HvCheckHiveDebug.Space = Length;
            HvCheckHiveDebug.MapPoint = Offset;
            HvCheckHiveDebug.BinPoint = Bin;
            //
            // for the loader.
            //
            if( CmDoSelfHeal() ) {
                //
                // put the correct signature, fileoffset and binsize in place;
                // HvEnlistBinInMap will take care of the cells consistency.
                //
                Bin->Signature = HBIN_SIGNATURE;
                Bin->FileOffset = Offset;
                if ( ((Offset + Bin->Size) > Length)   ||
                     (Bin->Size < HBLOCK_SIZE)            ||
                     (Bin->Size % HBLOCK_SIZE) ) {
                    Bin->Size = HBLOCK_SIZE;
                }
                //
                // signal back to the caller that we have altered the hive.
                //
                CmMarkSelfHeal(Hive);
            } else {
                Status = STATUS_REGISTRY_CORRUPT;
                goto ErrorExit;
            }
        }

        //
        // enlist this bin
        //
        Status = HvpEnlistBinInMap(Hive, Length, Bin, Offset, NULL);
        //
        // for the loader.
        //
        if( CmDoSelfHeal() && (Status == STATUS_REGISTRY_RECOVERED) ) {
            CmMarkSelfHeal(Hive);
            Status = STATUS_SUCCESS;
        }

        if( !NT_SUCCESS(Status) ) {
            goto ErrorExit;
        }

        //
        // the next bin
        //
        Offset += Bin->Size;

        Bin = (PHBIN)((ULONG_PTR)Bin + Bin->Size);
    }

    return STATUS_SUCCESS;


ErrorExit:
    //
    // Clean up the directory table
    //
#ifndef _CM_LDR_
    HvpCleanMap( Hive );
#endif //_CM_LDR_

    return Status;
}

BOOLEAN
HvpEnlistFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    ULONG   BinOffset
    )
/*++

Routine Description:

    Scan through the cells in the bin, locating the free ones.
    Enlist them in the hive's free list set.

    N.B.    Bin MUST already be mapped when this is called.

Arguments:

    Hive - pointer to hive control structure map is being built for

    Bin - pointer to bin to enlist cells from

    BinOffset - offset of Bin in image

Return Value:

    FALSE - registry is corrupt

    TRUE - it worked

--*/
{
    PHCELL          p;
    ULONG           celloffset;
    ULONG           size;
    HCELL_INDEX     cellindex;
    BOOLEAN         Result = TRUE;

    // PERFNOTE -- Keep this in mind as a possible optimization for NT6.
    // Since now the hive is loaded in chunks of bins, we can drop the 
    // bins that are entirely free!!!!!!
    //

    //
    // Scan all the cells in the bin, total free and allocated, check
    // for impossible pointers.
    //
    celloffset = sizeof(HBIN);
    p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

    while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

        //
        // if free cell, check it out, add it to free list for hive
        //
        if (p->Size >= 0) {

            size = (ULONG)p->Size;

            if ( (size > Bin->Size)               ||
                 ( (PHCELL)(size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) ) ||
                 ((size % HCELL_PAD(Hive)) != 0) ||
                 (size == 0) )
            {
                Result = FALSE;
                if( CmDoSelfHeal() ) {
                    //
                    // self heal mode; enlist the remaining of the bin as free
                    // also zero it out so any references into the tampered area will be
                    // detected and fixed by the logical check later on
                    //
                    p->Size = (LONG)((PUCHAR)((PUCHAR)Bin + Bin->Size) - (PUCHAR)p);
                    RtlZeroMemory((PUCHAR)p + sizeof(ULONG),p->Size - sizeof(ULONG));
                    size = (ULONG)p->Size;
                    CmMarkSelfHeal(Hive);
                } else {
                    goto Exit;
                }
            }


            //
            // cell is free, and is not obviously corrupt, add to free list
            //
            celloffset = (ULONG)((PUCHAR)p - (PUCHAR)Bin);
            cellindex = BinOffset + celloffset;

            //
            // Enlist this free cell, but do not coalesce with the next free cell
            // as we haven't gotten that far yet.
            //
            HvpEnlistFreeCell(Hive, cellindex, size, Stable, FALSE);

        } else {

            size = (ULONG)(p->Size * -1);

            if ( (size > Bin->Size)               ||
                 ( (PHCELL)(size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) ) ||
                 ((size % HCELL_PAD(Hive)) != 0) ||
                 (size == 0) )
            {
                Result = FALSE;
                if( CmDoSelfHeal() ) {
                    //
                    // Self heal mode; we have no other way than to enlist this cell as a free cell
                    //
                    p->Size = (LONG)((PUCHAR)((PUCHAR)Bin + Bin->Size) - (PUCHAR)p);
                    RtlZeroMemory((PUCHAR)p + sizeof(ULONG),p->Size - sizeof(ULONG));
                    size = (ULONG)p->Size;

                    celloffset = (ULONG)((PUCHAR)p - (PUCHAR)Bin);
                    cellindex = BinOffset + celloffset;

                    HvpEnlistFreeCell(Hive, cellindex, size, Stable, FALSE);
                    CmMarkSelfHeal(Hive);
                } else {
                    goto Exit;
                }
            }

        }

        ASSERT( ((LONG)size) >= 0);
        p = (PHCELL)((PUCHAR)p + size);
    }

Exit:
    return Result;
}

VOID
HvpCleanMap(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Cleans all the map allocations for the stable storage

  Arguments:

    Hive - Pointer to hive control structure to build map for.

Return Value:

    None
--*/
{
    ULONG           Length;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_DIRECTORY d = NULL;

    //
    // Compute MapSlots and Tables based on the Length
    //
    Length = Hive->Storage[Stable].Length;
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    if( Hive->Storage[Stable].SmallDir == 0 ) {
        //
        // directory was built and allocated, so clean it up
        //

        d = Hive->Storage[Stable].Map;
        if( d != NULL ) {
            HvpFreeMap(Hive, d, 0, Tables);
            (Hive->Free)(d, sizeof(HMAP_DIRECTORY));
        }
    } else {
        //
        // no directory, just a smalldir
        //
        (Hive->Free)(Hive->Storage[Stable].SmallDir, sizeof(HMAP_TABLE));
    }
    
    Hive->Storage[Stable].SmallDir = NULL;
    Hive->Storage[Stable].Map = NULL;
}

VOID
HvpFreeMap(
    PHHIVE          Hive,
    PHMAP_DIRECTORY Dir,
    ULONG           Start,
    ULONG           End
    )
/*++

Routine Description:

    Sweeps through the directory Dir points to and frees Tables.
    Will free Start-th through End-th entries, INCLUSIVE.

Arguments:

    Hive - supplies pointer to hive control block of interest

    Dir - supplies address of an HMAP_DIRECTORY structure

    Start - index of first map table pointer to clean up

    End - index of last map table pointer to clean up

Return Value:

    NONE.

--*/
{
    ULONG   i;

    if (End >= HDIRECTORY_SLOTS) {
        End = HDIRECTORY_SLOTS - 1;
    }

    for (i = Start; i <= End; i++) {
        if (Dir->Directory[i] != NULL) {
            (Hive->Free)(Dir->Directory[i], sizeof(HMAP_TABLE));
            Dir->Directory[i] = NULL;
        }
    }
    return;
}

BOOLEAN
HvpAllocateMap(
    PHHIVE          Hive,
    PHMAP_DIRECTORY Dir,
    ULONG           Start,
    ULONG           End
    )
/*++

Routine Description:

    Sweeps through the directory Dir points to and allocates Tables.
    Will allocate Start-th through End-th entries, INCLUSIVE.

    Does NOT clean up when out of memory, call HvpFreeMap to do that.
Arguments:

    Hive - supplies pointer to hive control block of interest

    Dir - supplies address of an HMAP_DIRECTORY structure

    Start - index of first map table pointer to allocate for

    End - index of last map table pointer to allocate for

Return Value:

    TRUE - it worked

    FALSE - insufficient memory

--*/
{
    ULONG   i,j;
    PHMAP_TABLE t;

    for (i = Start; i <= End; i++) {
        ASSERT(Dir->Directory[i] == NULL);
        t = (PHMAP_TABLE)((Hive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG29));
        if (t == NULL) {
            return FALSE;
        }
        // the zero memory stuff can be removed
        RtlZeroMemory(t, sizeof(HMAP_TABLE));
        for(j=0;j<HTABLE_SLOTS;j++) {
            //
            // Invalidate the entry
            //

            //
            // ATTENTION : I don't really think we need this !!! <TBD>
            //

            t->Table[j].BinAddress = 0;
            // we don't need to set this - just for debug purposes
            ASSERT( (t->Table[j].CmView = NULL) == NULL );
        }

        Dir->Directory[i] = t;
    }
    return TRUE;
}

ULONG 
HvpGetBinMemAlloc(
                IN PHHIVE           Hive,
                PHBIN               Bin,
                IN HSTORAGE_TYPE    Type
                        )
/*++

Routine Description:

    Returns the bin MemAlloc (formelly kept right in the bin) by looking at
    the map. We need this to avoid touching the bins only to set their MemAlloc.
    
      
Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Bin - The bin in question

    Type - Stable or Volatile

Return Value:

    Pointer to the new BIN if we succeeded, NULL if we failed.

--*/
{
    PHMAP_ENTRY     Map;
    HCELL_INDEX     Cell;

#if DBG
    ULONG           i;
    PHMAP_ENTRY     Me;
#endif

#ifndef _CM_LDR_
    PAGED_CODE();
#endif //_CM_LDR_

    ASSERT( Bin->Signature == HBIN_SIGNATURE );
    
    Cell = Bin->FileOffset + (Type * HCELL_TYPE_MASK);

    Map = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Map,Hive,Cell);

#if DBG
    //
    // some validation code
    //
    for( i=0;i<Bin->Size;i+=HBLOCK_SIZE) {
        Cell = Bin->FileOffset + i + (Type * HCELL_TYPE_MASK);
        Me = HvpGetCellMap(Hive, Cell);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);

        if( i == 0 ) {
            ASSERT( Me->MemAlloc != 0 );
        } else {
            ASSERT( Me->MemAlloc == 0 );
        }
    }
#endif

    return Map->MemAlloc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\amd64\geninst.c ===
#include "cmp.h"
#include "..\i386\geninst.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\amd64\initamd64.c ===
#include "cmp.h"
#include "..\i386\init386.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\amd64\initdat.c ===
#include "cmp.h"
#include "..\i386\initdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=config

TARGETNAME=config
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;..\..\inc;..\..\ke;..\..\mm;\
    $(PROJECT_ROOT)\published\$(O);\
    $(HALKIT_INC_PATH)

SOURCES=..\cmapi.c     \
        ..\cmapi2.c    \
        ..\cmboot.c    \
        ..\cmchek.c    \
        ..\cmchek2.c   \
        ..\cmclose.c   \
        ..\cmconfig.c  \
        ..\cmcontrl.c  \
        ..\cmdat.c     \
        ..\cmdat2.c    \
        ..\cmdat3.c    \
        ..\cmdatini.c  \
        ..\cmdelete.c  \
        ..\cmgquota.c  \
        ..\cmhvlist.c  \
        ..\cmindex.c   \
        ..\cminit.c    \
        ..\cmname.c    \
        ..\cmnotify.c  \
        ..\cmparse.c   \
        ..\cmparse2.c  \
        ..\cmquery.c   \
        ..\cmsavres.c  \
        ..\cmsubs.c    \
        ..\cmsubs2.c   \
        ..\cmsubs3.c   \
        ..\cmse.c      \
        ..\cmsysini.c  \
        ..\cmtrecpy.c  \
        ..\cmtredel.c  \
        ..\cmtree.c    \
        ..\cmworker.c  \
        ..\cmwrapr.c   \
        ..\cmwrapr2.c  \
        ..\cmwmi.c     \
        ..\cmmapvw.c   \
        ..\cmdelay.c   \
        ..\cmvalue.c   \
        ..\cmsecache.c \
        ..\cmdown.c    \
        ..\cmalloc.c   \
        ..\cmhook.c	   \
        ..\hivebin.c   \
        ..\hivecell.c  \
        ..\hivechek.c  \
        ..\hivefree.c  \
        ..\hiveinit.c  \
        ..\hiveload.c  \
        ..\hivemap.c   \
        ..\hivesum.c   \
        ..\hivesync.c  \
        ..\hivehint.c  \
        ..\ntapi.c     \
        ..\hwprofil.c

NTTEST=
UMTYPE=console
UMTEST=

PRECOMPILED_INCLUDE=..\cmp.h
PRECOMPILED_PCH=cmp.pch
PRECOMPILED_OBJ=cmp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\alpha\init.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    init.c

Abstract:

    This module is responsible to build any mips specific entries in
    the hardware tree of registry which the arc environment doesn't
    normally provide for.

Author:

    Ken Reneris (kenr) 04-Aug-1992


Environment:

    Kernel mode.

Revision History:

    Nigel Haslock 10-Oct-1995
        Set up firmware version and possibly date in the registry.

--*/

#include "cmp.h"

#define TITLE_INDEX_VALUE 0

NTSTATUS
CmpInitializeMachineDependentConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine creates alpha specific entries in the registry.

Arguments:

    LoaderBlock - supplies a pointer to the LoaderBlock passed in from the
                  OS Loader.

Returns:

    NTSTATUS code for sucess or reason of failure.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING ValueData;
    ANSI_STRING AnsiString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ParentHandle;

    InitializeObjectAttributes(&ObjectAttributes,
				               &CmRegistryMachineHardwareDescriptionSystemName,
				               OBJ_CASE_INSENSITIVE,
				               NULL,
				               NULL);

    Status = NtOpenKey(&ParentHandle,
		               KEY_READ,
		               &ObjectAttributes);

    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&ValueName,
    			             L"SystemBiosVersion");

        RtlInitAnsiString(&AnsiString,
    		              &LoaderBlock->u.Alpha.FirmwareVersion[0]);

        RtlAnsiStringToUnicodeString(&ValueData,
    				                 &AnsiString,
    				                 TRUE);

        Status = NtSetValueKey(ParentHandle,
    			               &ValueName,
    			               TITLE_INDEX_VALUE,
    			               REG_SZ,
    			               ValueData.Buffer,
    			               ValueData.Length + sizeof(UNICODE_NULL));

        RtlFreeUnicodeString(&ValueData);

        //
        // If the firmware build number is included in the loader block,
        // then store it in the registry.
        //

        if (LoaderBlock->u.Alpha.FirmwareBuildTimeStamp[0] != 0 ) {
            RtlInitUnicodeString(&ValueName,
                                 L"SystemBiosDate");

            RtlInitAnsiString(&AnsiString,
                              &LoaderBlock->u.Alpha.FirmwareBuildTimeStamp[0]);

            RtlAnsiStringToUnicodeString(&ValueData,
        				                 &AnsiString,
        				                 TRUE);

            Status = NtSetValueKey(ParentHandle,
        			               &ValueName,
        			               TITLE_INDEX_VALUE,
        			               REG_SZ,
        			               ValueData.Buffer,
        			               ValueData.Length + sizeof(UNICODE_NULL));

            RtlFreeUnicodeString(&ValueData);
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\amd64\rules.c ===
#include "cmp.h"
#include "..\i386\rules.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\amd64\parseini.c ===
#include "cmp.h"
#include "..\i386\parseini.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\geninst.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    geninst.c

Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "chkreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\init386.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    initi386.c

Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "chkreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\chkreg.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    chkreg.h

Abstract:

    This module contains the private (internal) header file for the
    chkreg utility.

Author:

    Dragos C. Sambotin (dragoss) 30-Dec-98

Revision History:

--*/

#ifndef __CHKREG_H__
#define __CHKREG_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "cmdata.h"

// constants for implementing (kind of) hash table
// these may not be the best values (to be determined)
#define FRAGMENTATION   0x00008000
#define SUBLISTS        0x000000F0

#define     CM_VIEW_SIZE        16L*1024L  //16K

// type definitions
typedef struct _REG_USAGE {
    ULONG   Size;
    ULONG   DataSize;
    ULONG   KeyNodeCount;
    ULONG   KeyValueCount;
    ULONG   KeyIndexCount;
    ULONG   ValueIndexCount;
    ULONG   DataCount;
} REG_USAGE, *PREG_USAGE;

typedef struct _UnknownCell {
    HCELL_INDEX             Cell;
    struct _UnknownCell    *Next;
} UNKNOWN_CELL, *PUNKNOWN_CELL;

// the unknown list is a matrix/hash table combination
// it uses a lot of heap space, but is faster than a linked list
typedef struct _UnknownList {
    ULONG                   Count;
    PUNKNOWN_CELL           List[SUBLISTS];
} UNKNOWN_LIST, *PUNKNOWN_LIST;


// routines for cell manipulation
BOOLEAN IsCellAllocated( HCELL_INDEX Cell );

LONG GetCellSize( HCELL_INDEX Cell );

PCELL_DATA GetCell( HCELL_INDEX Cell );

VOID
FreeCell(
    HCELL_INDEX Cell);

VOID
AllocateCell(
    HCELL_INDEX Cell );

// routines for list manipulation
VOID AddCellToUnknownList(HCELL_INDEX cellindex);

VOID RemoveCellFromUnknownList(HCELL_INDEX cellindex);

VOID FreeUnknownList();

VOID DumpUnknownList();

// phisycal hive check
BOOLEAN ChkPhysicalHive();

BOOLEAN ChkBaseBlock(PHBASE_BLOCK BaseBlock,DWORD dwFileSize);

BOOLEAN
ChkSecurityDescriptors( );

// logical hive check
BOOLEAN DumpChkRegistry(
    ULONG   Level,
    USHORT  ParentLength,
    HCELL_INDEX Cell,
    HCELL_INDEX ParentCell,
    PREG_USAGE PUsage);

// hive compacting
VOID DoCompactHive();

#endif //__CHKREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\initdat.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "chkreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\parseini.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    parseini.c
Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "chkreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\regbin.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regbin.c

Abstract:

    This module contains functions to check bin header and bin body consistency.

Author:

    Dragos C. Sambotin (dragoss) 30-Dec-1998

Revision History:

--*/
#include "chkreg.h"

extern ULONG   TotalKeyNode;
extern ULONG   TotalKeyValue;
extern ULONG   TotalKeyIndex;
extern ULONG   TotalKeySecurity;
extern ULONG   TotalValueIndex;
extern ULONG   TotalUnknown;

extern ULONG   CountKeyNode;
extern ULONG   CountKeyValue;
extern ULONG   CountKeyIndex;
extern ULONG   CountKeySecurity;
extern ULONG   CountValueIndex;
extern ULONG   CountUnknown;

extern ULONG    TotalFree; 
extern ULONG    FreeCount; 
extern ULONG    TotalUsed;

extern PUCHAR  Base;
extern FILE *OutputFile;

extern HCELL_INDEX RootCell;
extern PHBIN   FirstBin;
extern PHBIN   MaxBin;
extern ULONG   HiveLength;

extern LONG    BinIndex;
extern BOOLEAN FixHive;
extern BOOLEAN SpaceUsage;
extern BOOLEAN CompactHive;

ULONG BinFreeDisplaySize[HHIVE_FREE_DISPLAY_SIZE];
ULONG BinFreeDisplayCount[HHIVE_FREE_DISPLAY_SIZE];
ULONG FreeDisplaySize[HHIVE_FREE_DISPLAY_SIZE];
ULONG FreeDisplayCount[HHIVE_FREE_DISPLAY_SIZE];

ULONG BinUsedDisplaySize[HHIVE_FREE_DISPLAY_SIZE];
ULONG BinUsedDisplayCount[HHIVE_FREE_DISPLAY_SIZE];
ULONG UsedDisplaySize[HHIVE_FREE_DISPLAY_SIZE];
ULONG UsedDisplayCount[HHIVE_FREE_DISPLAY_SIZE];

BOOLEAN ChkAllocatedCell(HCELL_INDEX Cell);

CCHAR ChkRegFindFirstSetLeft[256] = {
        0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};

#define ComputeFreeIndex(Index, Size)                                   \
    {                                                                   \
        Index = (Size >> HHIVE_FREE_DISPLAY_SHIFT) - 1;                 \
        if (Index >= HHIVE_LINEAR_INDEX ) {                             \
                                                                        \
            /*                                                          \
            ** Too big for the linear lists, compute the exponential    \
            ** list.                                                    \
            */                                                          \
                                                                        \
            if (Index > 255) {                                          \
                /*                                                      \
                ** Too big for all the lists, use the last index.       \
                */                                                      \
                Index = HHIVE_FREE_DISPLAY_SIZE-1;                      \
            } else {                                                    \
                Index = ChkRegFindFirstSetLeft[Index] +                 \
                        HHIVE_FREE_DISPLAY_BIAS;                        \
            }                                                           \
        }                                                               \
    }

BOOLEAN 
ChkBinHeader(PHBIN Bin, 
             ULONG FileOffset, 
             ULONG Index
             )
/*++

Routine Description:


    Checks the validity of the Bin header.
    The following tests are done:
        1. the Size should not be bigger than the remaining of the file
        2. the Size should not be smaller than HBLOCK_SIZE
        3. the signature should be valid (HBIN_SIGNATURE)
        4. the file offset should match the actual position in the hive file.


Arguments:

    Bin - supplies a pointer to the bin to be checked.

    FileOffset - provides the actual pposition within the file

    Index - the index of the bin within the bin list of the hive

Return Value:

    FALSE - the bin header is corrupted and was not fixed. Either this is a 
            critical corruption, or the /R argument was not present in the 
            command line.
             
    TRUE - The bin header is OK, or it was successfully recovered.

--*/
{
    BOOLEAN bRez = TRUE;
    PHCELL       p;

    p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

    if(Bin->Size > (HiveLength - FileOffset)) {
        bRez = FALSE;
        fprintf(stderr, "Size too big (%lu) in Bin header of Bin (%lu)\n",Bin->Size,Index);
        if(FixHive) {
        // 
        // REPAIR: set the actual size to HiveLength-FileOffset
        //
            Bin->Size = HiveLength-FileOffset;
            p->Size = Bin->Size -sizeof(HBIN);
            bRez = TRUE;
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "Run chkreg /R to fix.\n");
            }
        }
    }

    if((Bin->Size < HBLOCK_SIZE) || ((Bin->Size % HBLOCK_SIZE) != 0)) {
        bRez = FALSE;
        fprintf(stderr, "Size too small (%lu) in Bin header of Bin (%lu)\n",Bin->Size,Index);
        if(FixHive) {
        // 
        // REPAIR: set the actual size to minimmum possible size HBLOCK_SIZE
        //
            Bin->Size = HBLOCK_SIZE;
            p->Size = Bin->Size -sizeof(HBIN);

            bRez = TRUE;
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "Run chkreg /R to fix.\n");
            }
        }
    }

    if(Bin->Signature != HBIN_SIGNATURE) {
        bRez = FALSE;
        fprintf(stderr, "Invalid signature (%lx) in Bin header of Bin (%lu)\n",Bin->Signature,Index);
        if(FixHive) {
        // 
        // REPAIR: reset the bin signature
        //
            Bin->Signature = HBIN_SIGNATURE;
            bRez = TRUE;
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "Run chkreg /R to fix.\n");
            }
        }
    }

    if(Bin->FileOffset != FileOffset) {
        bRez = FALSE;
        fprintf(stderr, "Actual FileOffset [%lx] and Bin FileOffset [%lx]  do not match in Bin (%lu); Size = (%lx)\n",FileOffset,Bin->FileOffset,Index,Bin->Size);
        if(FixHive) {
        // 
        // REPAIR: reset the bin FileOffset
        //
            Bin->FileOffset = FileOffset;
            bRez = TRUE;
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "Run chkreg /R to fix.\n");
            }
        }
    }

    return bRez;
}


BOOLEAN
ChkBin(
    PHBIN   Bin,
    ULONG   IndexBin,
    ULONG   Starting,
    double  *Rate
    )
/*++

Routine Description:

    Steps through all of the cells in the bin.  Make sure that
    they are consistent with each other, and with the bin header.
    Compute the usage rate for the current bin.
    Add all used cells to the unknown list (candidates to lost cells).
    Compute the used space and allocated cells by cell signature.
    Compute the free space size and number of cells.
    Test the cell size for reasonable limits. A cell should be smaller
    than the containing bin and should not exceed the bin boundaries. 
    A cell should fit in only one contiguos bin!!!

Arguments:

    Bin - supplies a pointer to the bin to be checked.

    Index - the index of the bin within the bin list of the hive

    Starting - starting address of the in-memory hive representation.

    Rate - usage rate for this bin

Return Value:

    FALSE - the bin is corrupted and was not fixed. Either this is a 
            critical corruption, or the /R argument was not present in the 
            command line.
             
    TRUE - The bin is OK, or it was successfully recovered.

--*/
{
    ULONG   freespace = 0L;
    ULONG   allocated = 0L;
    BOOLEAN bRez = TRUE;
    HCELL_INDEX cellindex;
    PHCELL       p;
    ULONG        Size;
    ULONG        Index;
    double       TmpRate;

    p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

    while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {
        
        cellindex = (HCELL_INDEX)((PUCHAR)p - Base);
        
        if (p->Size >= 0) {
            //
            // It is a free cell.
            //
            Size = (ULONG)p->Size;

            if ( (Size > Bin->Size)        ||
                 ( (PHCELL)(Size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) )
               ) {
                bRez = FALSE;
                fprintf(stderr, "Impossible cell size in free cell (%lu) in Bin header of Bin (%lu)\n",Size,IndexBin);
                if(FixHive) {
                // 
                // REPAIR: set the cell size to the largest possible hereon (ie. Bin + Bin->Size - p ); reset the Size too!!!
                //
                    bRez = TRUE;
                    p->Size = (ULONG)((PUCHAR)Bin + Bin->Size - (PUCHAR)p);
                } else {
                    if(CompactHive) {
                        // any attempt to compact a corrupted hive will fail
                        CompactHive = FALSE;
                        fprintf(stderr, "Run chkreg /R to fix.\n");
                    }
                }
            }
            freespace += Size;

            TotalFree  += Size;
            FreeCount++;

            if( SpaceUsage ) {
            // only if we are interested in the usage map
                // store the length of this free cell
                ComputeFreeIndex(Index, Size);
                BinFreeDisplaySize[Index] += Size;
                // and increment the count of free cells of this particular size
                BinFreeDisplayCount[Index]++;
            }

        }else{
            //
            // It is used cell.  Check for signature
            //
            UCHAR *C;
            USHORT Sig;
            int i,j;

            // All used cells are leak candidates
            AddCellToUnknownList(cellindex);

            Size = (ULONG)(p->Size * -1);

            if ( (Size > Bin->Size)        ||
                 ( (PHCELL)(Size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) )
               ) {
                bRez = FALSE;
                fprintf(stderr, "Impossible cell size in allocated cell (%lu) in Bin header of Bin (%lu)\n",Size,IndexBin);
                if(FixHive) {
                // 
                // REPAIR: set the cell size to the largest possible hereon (ie. Bin + Bin->Size - p ); reset the Size too!!!
                //
                    bRez = TRUE;
                    p->Size = (LONG)((PUCHAR)Bin + Bin->Size - (PUCHAR)p);
                    // it's a used cell, remember ?
                    p->Size *= -1;
                } else {
                    if(CompactHive) {
                        // any attempt to compact a corrupted hive will fail
                        CompactHive = FALSE;
                        fprintf(stderr, "Run chkreg /R to fix.\n");
                    }
                }
            }

            allocated += Size;

            if( SpaceUsage ) {
            // only if we are interested in the usage map
                // store the length of this used cell
                ComputeFreeIndex(Index, Size);
                BinUsedDisplaySize[Index] += Size;
                // and increment the count of used cells of this particular size
                BinUsedDisplayCount[Index]++;
            }
            
            TotalUsed=TotalUsed+Size;
            C= (UCHAR *) &(p->u.NewCell.u.UserData);
            Sig=(USHORT) p->u.NewCell.u.UserData;

            switch(Sig){
                case CM_LINK_NODE_SIGNATURE:
                    printf("Link Node !\n");
                    TotalKeyNode=TotalKeyNode+Size;
                    CountKeyNode++;
                    break;
                case CM_KEY_NODE_SIGNATURE:
                    {
                        PCM_KEY_NODE    Pcan;
                        TotalKeyNode=TotalKeyNode+Size;
                        CountKeyNode++;

                        Pcan = (PCM_KEY_NODE)C; 

                        if(Pcan->ValueList.Count){
                            PHCELL TmpP;
                            
                            TmpP = (PHCELL) (Starting + Pcan->ValueList.List);
                            TotalValueIndex=TotalValueIndex - TmpP->Size;
                            CountValueIndex++;
                        }

                    }
                    break;
                case CM_KEY_VALUE_SIGNATURE:
                    TotalKeyValue=TotalKeyValue+Size;
                    CountKeyValue++;
                    break;
                case CM_KEY_FAST_LEAF:
                case CM_KEY_HASH_LEAF:
                case CM_KEY_INDEX_LEAF:
                case CM_KEY_INDEX_ROOT:
                    TotalKeyIndex=TotalKeyIndex+Size;
                    CountKeyIndex++;
                    break;
                case CM_KEY_SECURITY_SIGNATURE:
                    TotalKeySecurity=TotalKeySecurity+Size;
                    CountKeySecurity++;
                    break;
                default:
                    //
                    // No signature, it can be data or index cells.
                    // Or there must be some registry leak here.
                    //
                    TotalUnknown=TotalUnknown+Size;
                    CountUnknown++;
                    break;
            }
        }

        p = (PHCELL)((PUCHAR)p + Size);
    }

            
    *Rate = TmpRate = (double)(((double)allocated)/((double)(allocated+freespace)));
    TmpRate *= 100.00;
    fprintf(OutputFile,"Bin [%5lu], usage %.2f%%\r",IndexBin,(float)TmpRate);        
    
    return bRez;
}

BOOLEAN ChkPhysicalHive()
/*++

Routine Description:

    Checks the integrity of the hive by stepping through all of the cells 
    in the hive. Collects and displays statistics, according to the command
    line parameters.

Arguments:

    None.

Return Value:

    FALSE - the hive is corrupted and was not fixed. Either this is a 
            critical corruption, or the /R argument was not present in the 
            command line.
             
    TRUE - The hive is OK, or it was successfully recovered.

--*/
{

    ULONG Starting;
    PHBIN        Bin = FirstBin;
    LONG         Index;
    ULONG        FileOffset;
    double       Rate,RateTotal = 0.0;
    BOOLEAN      bRez = TRUE;

    int i;

    Starting=(ULONG) Bin;
    Index=0;
    FileOffset = 0;

    for(i=0;i<HHIVE_FREE_DISPLAY_SIZE;i++) {
        FreeDisplaySize[i] = 0;
        FreeDisplayCount[i] = 0;
        UsedDisplaySize[i] = 0;
        UsedDisplayCount[i] = 0;
    }

    while(Bin < MaxBin){

        if( SpaceUsage ) {
        // only if we are interested in the usage map
            for(i=0;i<HHIVE_FREE_DISPLAY_SIZE;i++) {
                BinFreeDisplaySize[i] = 0;
                BinFreeDisplayCount[i] = 0;
                BinUsedDisplaySize[i] = 0;
                BinUsedDisplayCount[i] = 0;
            }
        }

        bRez = (bRez && ChkBinHeader(Bin,FileOffset,Index));

        bRez = (bRez && ChkBin(Bin,Index,Starting,&Rate));
        
        RateTotal += Rate;
        
        if( SpaceUsage ) {
        // only if we are interested in the usage map
            if( BinIndex == Index ) {
            // summary wanted for this particular bin
                fprintf(OutputFile,"\nBin[%5lu] Display Map: Free Cells, Free Size\t Used Cells, Used Size\n",(ULONG)Index);
                for(i=0;i<HHIVE_FREE_DISPLAY_SIZE;i++) {
                    fprintf(OutputFile,"Display[%2d]         : %8lu  , %8lu  \t %8lu  , %8lu  \n",i,BinFreeDisplayCount[i],BinFreeDisplaySize[i],BinUsedDisplayCount[i],BinUsedDisplaySize[i]);
                }
            }
            for(i=0;i<HHIVE_FREE_DISPLAY_SIZE;i++) {
                FreeDisplaySize[i] += BinFreeDisplaySize[i];
                FreeDisplayCount[i] += BinFreeDisplayCount[i];
                UsedDisplaySize[i] += BinUsedDisplaySize[i];
                UsedDisplayCount[i] += BinUsedDisplayCount[i];
            }
        }

        if( Bin<MaxBin) {
            FileOffset += Bin->Size;
        }

        Bin = (PHBIN)((ULONG)Bin + Bin->Size);

        Index++;
    }
    
    RateTotal *= 100.00;
    RateTotal /= (double)Index;
    
    fprintf(OutputFile,"Number of Bins in hive: %lu                              \n",Index);        
    fprintf(OutputFile,"Total Hive space usage: %.2f%%                            \n",(float)RateTotal);        
    
    if( SpaceUsage ) {
    // only if we are interested in the usage map
        if( BinIndex == -1 ) {
            // space usage display per entire hive
            fprintf(OutputFile,"\nHive Display Map: Free Cells, Free Size\t\t Used Cells, Used Size\n");
            for(i=0;i<HHIVE_FREE_DISPLAY_SIZE;i++) {
                fprintf(OutputFile,"Display[%2d]     : %8lu  , %8lu  \t %8lu  , %8lu  \n",i,FreeDisplayCount[i],FreeDisplaySize[i],UsedDisplayCount[i],UsedDisplaySize[i]);
            }
        }
    }

    return bRez;
}

ULONG
ComputeHeaderCheckSum(
    PHBASE_BLOCK    BaseBlock
    )
/*++

Routine Description:

    Compute the checksum for a hive disk header.

Arguments:

    BaseBlock - supplies pointer to the header to checksum

Return Value:

    the check sum.

--*/
{
    ULONG   sum;
    ULONG   i;

    sum = 0;
    for (i = 0; i < 127; i++) {
        sum ^= ((PULONG)BaseBlock)[i];
    }
    if (sum == (ULONG)-1) {
        sum = (ULONG)-2;
    }
    if (sum == 0) {
        sum = 1;
    }
    return sum;
}

BOOLEAN
ChkBaseBlock(PHBASE_BLOCK BaseBlock,
             DWORD dwFileSize)
/*++

Routine Description:

    Checks the integrity of the base block of a hive.
    Eventually makes the following corrections:
    1. enforce Sequence1 == Sequence2
    2. recalculate the header checksum

Arguments:

    BaseBlock - the BaseBlock in-memory mapped image.
    
    dwFileSize - the actual size of the hive file

Return Value:

    FALSE - the BaseBlock is corrupted and was not fixed. Either this is a 
            critical corruption, or the /R argument was not present in the 
            command line.
             
    TRUE - The BaseBlock is OK, or it was successfully recovered.

--*/
{
    BOOLEAN bRez = TRUE;
    ULONG CheckSum;
    
    if(BaseBlock->Signature != HBASE_BLOCK_SIGNATURE) {
        fprintf(stderr, "Fatal: Invalid Base Block signature (0x%lx)",BaseBlock->Signature);
        bRez = FALSE;
        if(FixHive) {
        // 
        // REPAIR: reset the signature
        //
            fprintf(stderr, " ... unable to fix");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
            }
        }
        fprintf(stderr, "\n");
    }

    if(BaseBlock->Major != HSYS_MAJOR) {
        bRez = FALSE;
        fprintf(stderr, "Fatal: Invalid hive file Major version (%lu)",BaseBlock->Major);
        if(FixHive) {
        // 
        // Fatal: unable to fix this
        //
            fprintf(stderr, " ... unable to fix");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
            }
        }
        fprintf(stderr, "\n");
    }

    if(BaseBlock->Minor > HSYS_MINOR_SUPPORTED) {
        bRez = FALSE;
        fprintf(stderr, "Fatal: Invalid hive file Minor version (%lu)",BaseBlock->Minor);
        if(FixHive) {
        // 
        // Fatal: unable to fix this
        //
            fprintf(stderr, " ... unable to fix");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
            }
        }
        fprintf(stderr, "\n");
    }

    if(BaseBlock->Format != HBASE_FORMAT_MEMORY) {
        bRez = FALSE;
        fprintf(stderr, "Fatal: Invalid hive memory format (%lu)",BaseBlock->Format);
        if(FixHive) {
        // 
        // Fatal: unable to fix this
        //
            fprintf(stderr, " ... unable to fix");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
            }
        }
        fprintf(stderr, "\n");
    }

    if((BaseBlock->Length + HBLOCK_SIZE) > dwFileSize) {
        fprintf(stderr, "Fatal: Invalid Hive file Length (%lu)",BaseBlock->Length);
        bRez = FALSE;
        if(FixHive) {
        // 
        // REPAIR: unable to fix this
        //
            fprintf(stderr, " ... unable to fix");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
            }
        }
        fprintf(stderr, "\n");
    }

    if(!bRez) {
        //
        // Fatal Base Block corruption; no point to continue.
        //
        return bRez;
    }

    if(BaseBlock->Sequence1 != BaseBlock->Sequence2) {
        fprintf(stderr, "Sequence numbers do not match (%lu,%lu)",BaseBlock->Sequence1,BaseBlock->Sequence2);
        bRez = FALSE;
        if(FixHive) {
        // 
        // REPAIR: enforce Sequence2 to Sequence1
        //
            bRez = TRUE;
            BaseBlock->Sequence2 = BaseBlock->Sequence1;
            fprintf(stderr, " ... fixed");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "\nRun chkreg /R to fix.");
            }
        }
        fprintf(stderr, "\n");
    }

    CheckSum = ComputeHeaderCheckSum(BaseBlock);
    if(BaseBlock->CheckSum != CheckSum) {
        fprintf(stderr, "Invalid Base Block CheckSum (0x%lx)",BaseBlock->CheckSum);
        bRez = FALSE;
        if(FixHive) {
        // 
        // REPAIR: reset the signature
        //
            bRez = TRUE;
            BaseBlock->CheckSum = CheckSum;
            fprintf(stderr, " ... fixed");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "\nRun chkreg /R to fix.");
            }
        }
        fprintf(stderr, "\n");
    }

    return bRez;
}

BOOLEAN
ChkSecurityDescriptors( )
/*++

Routine Description:

    Walks the list of security descriptors present in the hive and passes
    each security descriptor to RtlValidSecurityDescriptor.
    Also checks the validity of the FLink <==> BLink relationship between cells.

Arguments:

 
Return Value:

    TRUE  - All security descriptors are valid
    FALSE - At least one security descriptor is invalid, and/or cannot be fixed

--*/

{
    PCM_KEY_NODE RootNode;
    PCM_KEY_SECURITY SecurityCell;
    HCELL_INDEX ListAnchor;
    HCELL_INDEX NextCell;
    HCELL_INDEX LastCell;
    BOOLEAN bRez = TRUE;

    // check/fix the root cell (is allocated?)
    ChkAllocatedCell(RootCell);

    RootNode = (PCM_KEY_NODE) GetCell(RootCell);
    ListAnchor = NextCell = RootNode->Security;

    do {
        // is the next cell allocated?
        ChkAllocatedCell(NextCell);
        
        SecurityCell = (PCM_KEY_SECURITY) GetCell(NextCell);
        
        if (SecurityCell->Signature != CM_KEY_SECURITY_SIGNATURE) {
            bRez = FALSE;
            fprintf(stderr, "Fatal: Invalid signature (0x%lx) in Security cell 0x%lx ",SecurityCell->Signature,NextCell);
            if(FixHive) {
            // 
            // REPAIR: 
            // FATAL: Mismatched signature cannot be fixed. Unable to fix this. 
            //
                fprintf(stderr, " ... unable to fix");
            } else {
                if(CompactHive) {
                    // any attempt to compact a corrupted hive will fail
                    CompactHive = FALSE;
                }
            }
            fprintf(stderr, "\n");
            return bRez;
        }

        if (NextCell != ListAnchor) {
            //
            // Check to make sure that our Blink points to where we just
            // came from.
            //
            if (SecurityCell->Blink != LastCell) {
                fprintf(stderr, "Invalid backward link in security cell (0x%lx)",NextCell);
                if(FixHive) {
                // 
                // REPAIR: reset the link
                //
                    SecurityCell->Blink = LastCell;
                    fprintf(stderr, " ... fixed");
                } else {
                    bRez = FALSE;
                    if(CompactHive) {
                        // any attempt to compact a corrupted hive will fail
                        CompactHive = FALSE;
                        fprintf(stderr, "\nRun chkreg /R to fix.");
                    }
                }
                fprintf(stderr, "\n");
            }
        }

        if (!RtlValidSecurityDescriptor(&SecurityCell->Descriptor)) {
            bRez = FALSE;
            fprintf(stderr, "Invalid security descriptor in Security cell 0x%lx ",NextCell);
            if(FixHive) {
            // 
            // REPAIR: remove the cell from the list and delete it!
            //
                PCM_KEY_SECURITY Before = (PCM_KEY_SECURITY) GetCell(SecurityCell->Blink);
                PCM_KEY_SECURITY After = (PCM_KEY_SECURITY) GetCell(SecurityCell->Flink);
                if( Before != After ) {
                // make sure the list will not remain empty
                    Before->Flink =  SecurityCell->Flink;
                    After->Blink = SecurityCell->Blink;
                } 
                FreeCell(NextCell);
                NextCell = SecurityCell->Flink;
                fprintf(stderr, " ... deleted");
            } else {
                bRez = FALSE;
                if(CompactHive) {
                    // any attempt to compact a corrupted hive will fail
                    CompactHive = FALSE;
                    fprintf(stderr, "\nRun chkreg /R to fix.");
                }
            }
            fprintf(stderr, "\n");
        } else {
        // validate the next one
            LastCell = NextCell;
            NextCell = SecurityCell->Flink;
        }
    } while ( NextCell != ListAnchor );

    return bRez;
}

BOOLEAN
ChkSecurityCellInList(HCELL_INDEX Security)
/*++

Routine Description:

    Searches the specified cell within the security descriptors list

Arguments:

    Security - Provides the current cell

Return Value:

    TRUE  - the current cell was found in the security list
    FALSE - the current cell is not present in the security list and it couldn't be added.

--*/
{
    PCM_KEY_NODE RootNode;
    PCM_KEY_SECURITY SecurityCell;
    PCM_KEY_SECURITY SecurityCellCurrent;
    PCM_KEY_SECURITY SecurityCellAfter;
    HCELL_INDEX ListAnchor;
    HCELL_INDEX NextCell;
    BOOLEAN bRez = TRUE;

    RootNode = (PCM_KEY_NODE) GetCell(RootCell);
    ListAnchor = NextCell = RootNode->Security;

    do {
      
        if( NextCell == Security) {
        // found it!
            return bRez;
        }

        SecurityCell = (PCM_KEY_SECURITY) GetCell(NextCell);

        NextCell = SecurityCell->Flink;
    } while ( NextCell != ListAnchor );

    // cell not found; try to fix it 
    bRez = FALSE;
    fprintf(stderr, "Security Cell (0x%lx) not in security descriptors list",Security);
    if(FixHive) {
    // 
    // REPAIR: Add the security cell at the begining of the list
    //
        bRez = TRUE;
        SecurityCell = (PCM_KEY_SECURITY) GetCell(ListAnchor);
        SecurityCellCurrent = (PCM_KEY_SECURITY) GetCell(Security);
        SecurityCellAfter = (PCM_KEY_SECURITY) GetCell(SecurityCell->Flink);

        // restore the connections
        SecurityCellCurrent->Flink = SecurityCell->Flink;
        SecurityCellCurrent->Blink = ListAnchor;
        SecurityCell->Flink = Security;
        SecurityCellAfter->Blink = Security;
        fprintf(stderr, " ... security cell added to the list");
    } else {
        if(CompactHive) {
            // any attempt to compact a corrupted hive will fail
            CompactHive = FALSE;
            fprintf(stderr, "\nRun chkreg /R to fix.");
        }
    }
    fprintf(stderr, "\n");

    return bRez;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\regcell.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regcell.c

Abstract:

    This module contains cell manipulation functions.

Author:

    Dragos C. Sambotin (dragoss) 30-Dec-1998

Revision History:

--*/

#include "chkreg.h"

extern PUCHAR Base;

BOOLEAN
IsCellAllocated(
    HCELL_INDEX Cell
)
/*
Routine Description:

    Checks if the cell is allocated (i.e. the size is negative).

Arguments:

    Cell - supplies the cell index of the cell of interest.

Return Value:

    TRUE if Cell is allocated. FALSE otherwise.

*/
{
    PHCELL  pcell;

    pcell = (PHCELL)(Base + Cell);
    
    return (pcell->Size < 0) ? TRUE : FALSE;
}

LONG
GetCellSize(
    HCELL_INDEX Cell
) 
/*
Routine Description:

    Retrieves the size of the specified cell.

Arguments:

    Cell - supplies the cell index of the cell of interest.

Return Value:

    The size of the cell.

*/
{

    LONG    size;
    PHCELL  pcell;

    pcell = (PHCELL)(Base + Cell);
    
    size = pcell->Size * -1;

    return size;
}

VOID
FreeCell(
    HCELL_INDEX Cell
) 
/*
Routine Description:

    Frees a cell.

Arguments:

    Cell - supplies the cell index of the cell of interest.

Return Value:

    NONE.

*/
{
    PHCELL  pcell;

    pcell = (PHCELL)(Base + Cell);
    
    pcell->Size *= -1;

    ASSERT(pcell->Size >= 0 );
}

VOID
AllocateCell(
    HCELL_INDEX Cell
) 
/*
Routine Description:

    Allocates a cell, by ensuring a negative size on it

Arguments:

    Cell - supplies the cell index of the cell of interest.

Return Value:

    NONE.

*/
{
    PHCELL  pcell;

    pcell = (PHCELL)(Base + Cell);
    
    pcell->Size *= -1;



    ASSERT(pcell->Size < 0 );
}

PCELL_DATA
GetCell(
    HCELL_INDEX Cell
)
/*
Routine Description:

    Retrieves the memory address of the cell specified by Cell.

Arguments:

    Cell - supplies the cell index of the cell of interest.

Return Value:

    The memory address of Cell.

*/
{
    PHCELL          pcell;
    
    pcell = (PHCELL)(Base + Cell);

    return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\reglist.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    reglist.c

Abstract:

    This module contains routine for list manipulation

Author:

    Dragos C. Sambotin (dragoss) 30-Dec-1998

Revision History:

--*/
#include "chkreg.h"

extern PUCHAR  Base;
extern FILE *OutputFile;

extern BOOLEAN FixHive;
extern UNKNOWN_LIST LostCells[];
extern BOOLEAN LostSpace;


VOID AddCellToUnknownList(HCELL_INDEX cellindex)
/*
Routine Description:

    Adds a cell to the list (pseudo) of the unknown cells.
    The list of unknown cells is in fact a primitive two-dimensional hash table.
    Always add at the begining. The caller is responsible not to add twice the same cell.

Arguments:

    cellindex - supplies the cell index of the cell assumed as unknown.

Return Value:

    NONE.

*/
{
    if(LostSpace) {
    // only if we are interested in the lost space
        ULONG WhatList = (ULONG)cellindex % FRAGMENTATION;
        ULONG WhatIndex = (ULONG)cellindex % SUBLISTS;
        PUNKNOWN_CELL Tmp;
   
        Tmp = (PUNKNOWN_CELL)malloc(sizeof(UNKNOWN_CELL));
        if(Tmp) {
            Tmp->Cell = cellindex;
            Tmp->Next = LostCells[WhatList].List[WhatIndex];
            LostCells[WhatList].List[WhatIndex] = Tmp;
            LostCells[WhatList].Count++;
        }
    }
}

VOID RemoveCellFromUnknownList(HCELL_INDEX cellindex)
/*
Routine Description:

    Walk through the list and remove the specified cell.
    Free the storage too.

Arguments:

    cellindex - supplies the cell index of the cell assumed as unknown.

Return Value:

    NONE.

*/
{

    if(LostSpace) {
    // only if we are interested in the lost space
        ULONG WhatList = (ULONG)cellindex % FRAGMENTATION;
        ULONG WhatIndex = (ULONG)cellindex % SUBLISTS;
        PUNKNOWN_CELL Prev;
        PUNKNOWN_CELL Tmp;

        Prev = NULL;
        Tmp = LostCells[WhatList].List[WhatIndex];

        fprintf(stdout,"Verifying Cell %8lx \r",cellindex,LostCells[WhatList].Count);

        while(Tmp) {
            if( Tmp->Cell == cellindex ) {
            // found it!
                if(Prev) {
                    ASSERT(Prev->Next == Tmp);
                    Prev->Next = Tmp->Next;
                } else {
                // no predecessor ==> Tmp is the entry ==> update it:
                    LostCells[WhatList].List[WhatIndex] = Tmp->Next;
                }
                LostCells[WhatList].Count--;

                // free the space and break the loop
                free(Tmp);
                break;
            }

            Prev = Tmp;
            Tmp = Tmp->Next;
        }
    }
}

VOID FreeUnknownList()
/*
Routine Description:

    Free the storage for all elements.

Arguments:

    None

Return Value:

    NONE.

*/
{
    if(LostSpace) {
    // only if we are interested in the lost space
        PUNKNOWN_CELL Tmp;
        ULONG i,j;

        for( i=0;i<FRAGMENTATION;i++) {
            for( j=0;j<SUBLISTS;j++) {
                while(LostCells[i].List[j]) {
                    Tmp = LostCells[i].List[j];
                    LostCells[i].List[j] = LostCells[i].List[j]->Next;
                    free(Tmp);
                }
            }
        }
    }
}

VOID DumpUnknownList()
/*
Routine Description:

    Dumps all the elements in the unknown list.
    Free the lost cells. Lost cells are cells that are marked as used,
    but are never referenced within the hive.

Arguments:

    None

Return Value:

    NONE.

*/
{
    if(LostSpace) {
    // only if we are interested in the lost space
        ULONG   Count = 0,i;
        for( i=0;i<FRAGMENTATION;i++) {
            ASSERT((LONG)(LostCells[i].Count) >= 0);

            Count += LostCells[i].Count;
        }
        fprintf(OutputFile,"\nLost Cells Count = %8lu \n",Count);

        if(Count && FixHive) {
            int chFree,j;
            PUNKNOWN_CELL Tmp;
            PHCELL          pcell;
            USHORT          Sig;
            fprintf(stdout,"Do you want to free the lost cells space ?(y/n)");
            fflush(stdin);
            chFree = getchar();
            if( (chFree != 'y') && (chFree != 'Y') ) {
            // the lost cells will remain lost
                return;
            }
            for( i=0;i<FRAGMENTATION;i++) {
                if(LostCells[i].Count > 0) {
                    for( j=0;j<SUBLISTS;j++) {
                        Tmp = LostCells[i].List[j];
                        while(Tmp) {
                            fprintf(stdout,"Marking cell 0x%lx as free ...");
                            
                            // free the cell only if it is not a security cell !
                            pcell = (PHCELL)(Base + Tmp->Cell);
                            Sig=(USHORT) pcell->u.NewCell.u.UserData;
                            // don't mess with security cells !
                            if(Sig != CM_KEY_SECURITY_SIGNATURE) {
                                FreeCell(Tmp->Cell);
                            }
                            fprintf(stdout,"OK\n");
                            Tmp = Tmp->Next;
                        }
                    }
                }
            }
            fprintf(stdout,"\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\regdmp.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regdmp.c

Abstract:

    This module contains routines to check/dump the logical structure of the hive.

Author:

    Dragos C. Sambotin (dragoss) 30-Dec-1998

Revision History:

--*/

#include "chkreg.h"

extern ULONG MaxLevel;
extern UNICODE_STRING  KeyName;
extern WCHAR NameBuffer[];
extern FILE *OutputFile;
extern BOOLEAN FixHive;
extern BOOLEAN CompactHive;
extern  ULONG   CountKeyNodeCompacted;
extern HCELL_INDEX RootCell;


#define     REG_MAX_PLAUSIBLE_KEY_SIZE \
                ((FIELD_OFFSET(CM_KEY_NODE, Name)) + \
                 (sizeof(WCHAR) * REG_MAX_KEY_NAME_LENGTH) + 16)

BOOLEAN ChkSecurityCellInList(HCELL_INDEX Security);

BOOLEAN 
ChkAreCellsInSameVicinity(HCELL_INDEX Cell1,HCELL_INDEX Cell2)
{
    ULONG   Start = Cell1&(~HCELL_TYPE_MASK);
    ULONG   End = Cell2&(~HCELL_TYPE_MASK);
    
    Start += HBLOCK_SIZE;
    End += HBLOCK_SIZE;
    
    //
    // truncate to the CM_VIEW_SIZE segment
    //
    Start &= (~(CM_VIEW_SIZE - 1));
    End &= (~(CM_VIEW_SIZE - 1));

    if( Start != End ){
        return FALSE;
    } 
    
    return TRUE;

}

BOOLEAN 
ChkAllocatedCell(HCELL_INDEX Cell)
/*
Routine Description:

    Checks if the cell is allocated (i.e. the size is negative).

Arguments:

    Cell - supplies the cell index of the cell of interest.

Return Value:

    TRUE if Cell is allocated. FALSE otherwise.

*/
{
    BOOLEAN bRez = TRUE;

    if( Cell == HCELL_NIL ) {
        fprintf(stderr, "Warning : HCELL_NIL referrenced !\n");
        return bRez;
    }
    if( !IsCellAllocated( Cell ) ) {
        bRez = FALSE;
        fprintf(stderr, "Used free cell 0x%lx  ",Cell);
        if(FixHive) {
        // 
        // REPAIR: mark the cell as allocated
        //
            AllocateCell(Cell);
            fprintf(stderr, " ... fixed");
            bRez = TRUE;
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "\nRun chkreg /R to fix.");
            }
        }
        fprintf(stderr, "\n");
    }
    
    return bRez;
}

static CHAR FixKeyNameCount = 0;

BOOLEAN 
ChkKeyNodeCell(HCELL_INDEX KeyNodeCell,
               HCELL_INDEX ParentCell
               )
/*
Routine Description:

    Checks if the cell is is a consistent keynode. Make fixes when neccessary/required.
    The following tests are performed against the keynode cell:
    1. the size should be smaller than the REG_MAX_PLAUSIBLE_KEY_SIZE ==> fatal error
    2. the Name should not exceed the size of the cell
    3. the signature should match CM_KEY_NODE_SIGNATURE
    4. the parent cell in keynode should match the actual parent cell

Arguments:

    KeyNodeCell - supplies the cell index of the key node of interest.

    ParentCell  - the actual parent of the current key node

Return Value:

    TRUE if KeyNodeCell is reffering a consistent key node, or it was successfully recovered.

    FALSE otherwise.

*/
{
    PCM_KEY_NODE KeyNode = (PCM_KEY_NODE) GetCell(KeyNodeCell);
    ULONG   size;
    BOOLEAN bRez = TRUE;
    ULONG   usedlen;
    PUCHAR  pName;

    // this cell should not be considered as lost
    RemoveCellFromUnknownList(KeyNodeCell);

    ChkAllocatedCell(KeyNodeCell);

    // Validate the size of the 
    size = GetCellSize(KeyNodeCell);
    if (size > REG_MAX_PLAUSIBLE_KEY_SIZE) {
        bRez = FALSE;
        fprintf(stderr, "Implausible Key size %lx in cell 0x%lx   ",size,KeyNodeCell);
        if(FixHive) {
        // 
        // REPAIR: unable to fix
        //
            fprintf(stderr, " ... deleting key\n");
            return bRez;
        }
    }
    
    usedlen = FIELD_OFFSET(CM_KEY_NODE, Name) + KeyNode->NameLength;
    if (usedlen > size) {
        bRez = FALSE;
        fprintf(stderr, "Key (size = %lu) is bigger than containing cell 0x%lx (size = %lu) ",usedlen,KeyNodeCell,size);
        if(FixHive) {
        // 
        // REPAIR: set NameLength to fit the cell size (i.e. set it to size - FIELD_OFFSET(CM_KEY_NODE, Name) )
        //

        //
        // WARNING: the name might be truncated!!!
        //
            bRez = TRUE;
            KeyNode->NameLength = (USHORT)(size - FIELD_OFFSET(CM_KEY_NODE, Name));
            fprintf(stderr, " ... fixed");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "\nRun chkreg /R to fix.");
            }
        }
        fprintf(stderr, "\n");
    }

    if( KeyNode->Flags & KEY_COMP_NAME ) {
        pName = (PUCHAR)KeyNode->Name;
        for( usedlen = 0; usedlen < KeyNode->NameLength;usedlen++) {
            if( pName[usedlen] == '\\' ) {
                bRez = FALSE;
                fprintf(stderr, "Invalid key Name for Key (0x%lx) == %s ",KeyNodeCell,pName);
                if(FixHive) {
                    // 
                    // REPAIR: unable to fix
                    //
                    fprintf(stderr, " ... deleting key\n");
                    return bRez;
                } else {
                    if(CompactHive) {
                        // any attempt to compact a corrupted hive will fail
                        CompactHive = FALSE;
                        fprintf(stderr, "\nRun chkreg /R to fix.");
                    }
                }
                fprintf(stderr, "\n");
            }
        }
    }


    if (ParentCell != HCELL_NIL) {
        if (KeyNode->Parent != ParentCell) {
            bRez = FALSE;
            fprintf(stderr, "Parent of Key (0x%lx) does not match with its ParentCell (0x%lx) ",ParentCell,KeyNode->Parent);
            if(FixHive) {
            // 
            // REPAIR: reset the parent
            //
                bRez = TRUE;
                KeyNode->Parent = ParentCell;
                fprintf(stderr, " ... fixed");
            } else {
                if(CompactHive) {
                    // any attempt to compact a corrupted hive will fail
                    CompactHive = FALSE;
                    fprintf(stderr, "\nRun chkreg /R to fix.");
                }
            }
            fprintf(stderr, "\n");
        }
    }

    if (KeyNode->Signature != CM_KEY_NODE_SIGNATURE) {
        bRez = FALSE;
        fprintf(stderr, "Invalid signature (0x%lx) in Key cell 0x%lx ",KeyNode->Signature,KeyNodeCell);
        if(FixHive) {
        // 
        // REPAIR: 
        // FATAL: Mismatched signature cannot be fixed. The key should be deleted! 
        //
            fprintf(stderr, " ... deleting key");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "\nRun chkreg /R to fix.");
            }
        }
        fprintf(stderr, "\n");

    }

    return bRez;
}

BOOLEAN 
ChkClassCell(HCELL_INDEX Class)
/*
Routine Description:

    Checks if the cell is a consistent class cell.
    There is not much to be checked here.

Arguments:

    Class - supplies the cell index of the cell of interest.

Return Value:

    TRUE if Class is a valid cell.

    FALSE otherwise.

*/
{
    // this cell should not be considered as lost
    RemoveCellFromUnknownList(Class);

    return ChkAllocatedCell(Class);
}

BOOLEAN 
ChkSecurityCell(HCELL_INDEX Security)
/*
Routine Description:

    Checks if the cell is a consistent security cell.
    A security cell must be allocated and must have a valid signature.

Arguments:

    Security - supplies the cell index of the cell of interest.

Return Value:

    TRUE if Security is a valid cell.

    FALSE otherwise.

*/
{
    PCM_KEY_SECURITY KeySecurity = (PCM_KEY_SECURITY) GetCell(Security);
    BOOLEAN bRez = TRUE;

    // this cell should not be considered as lost
    RemoveCellFromUnknownList(Security);

    if( !IsCellAllocated( Security ) ) {
    // unalocated security cells are invalid.
    // they are marked as free in the validate security descriptors check!
        if(FixHive) {
        // 
        // REPAIR: 
        // FATAL: Invalid security cells could not be fixed. Containg keys will be deleted.
        //
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
            }
        }
        return FALSE;
    }

    if (KeySecurity->Signature != CM_KEY_SECURITY_SIGNATURE) {
        fprintf(stderr, "Invalid signature (0x%lx) in Security Key cell 0x%lx ",KeySecurity->Signature,Security);
        if(FixHive) {
        // 
        // REPAIR: 
        // FATAL: Mismatched signature cannot be fixed. The key should be deleted! 
        //
            fprintf(stderr, " ... deleting refering key");
        } else {
            bRez = FALSE;
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "\nRun chkreg /R to fix.");
            }
        }
        fprintf(stderr, "\n");
    }

    // check if this security cell is present in the security list.
    if(!ChkSecurityCellInList(Security) ) {
        bRez = FALSE;
    }

    return bRez;
}


BOOLEAN 
ChkKeyValue(HCELL_INDEX KeyValue,
            PREG_USAGE OwnUsage,
            BOOLEAN *KeyCompacted
            )
/*
Routine Description:

    Checks if the cell is a consistent keyvalue cell.
    The following tests are performed:
    1. the cell must be allocated
    2. the cell is tested against HCELL_NIL ==> fatal error
    3. the signature should match CM_KEY_VALUE_SIGNATURE
    4. the name should not exceed the size of the cell
    5. the data cell should be allocated and its size should match DataLength

Arguments:

    KeyValue - supplies the cell index of the cell of interest.

    OwnUsage - used to collect data statistics

Return Value:

    TRUE if KeyCell is a valid cell or it was successfully fixed.

    FALSE otherwise.

*/
{
    PCM_KEY_VALUE   ValueNode;
    ULONG  realsize;
    ULONG   usedlen;
    ULONG   DataLength;
    HCELL_INDEX Data;
    ULONG   size;

    BOOLEAN bRez = TRUE;
    
    if( KeyValue == HCELL_NIL ) {
        bRez = FALSE;
        fprintf(stderr, "NIL Key value encountered; Fatal error!");
        if(FixHive) {
        // 
        // REPAIR: fatal error, the value should be removed from the value list
        //
            fprintf(stderr, " ... deleting empty entry\n");
            return bRez;
        }
    }

    
    ChkAllocatedCell(KeyValue);
    //
    // Value size
    //  
    size = GetCellSize(KeyValue);
    OwnUsage->Size += size;

    // this cell should not be considered as lost
    RemoveCellFromUnknownList(KeyValue);

    ValueNode = (PCM_KEY_VALUE) GetCell(KeyValue);

    //
    // Check out the value entry itself
    //

    usedlen = FIELD_OFFSET(CM_KEY_VALUE, Name) + ValueNode->NameLength;
    if (usedlen > size) {
        bRez = FALSE;
        fprintf(stderr, "Key Value (size = %lu) is bigger than containing cell 0x%lx (size = %lu) ",usedlen,KeyValue,size);
        if(FixHive) {
        // 
        // REPAIR: set the actual size to HiveLength-FileOffset
        //

        //
        // WARNING: the name might be truncated!!!
        //
            bRez = TRUE;
            ValueNode->NameLength = (USHORT)(size - FIELD_OFFSET(CM_KEY_VALUE, Name));
            fprintf(stderr, " ... fixed");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "\nRun chkreg /R to fix.");
            }
        }
        fprintf(stderr, "\n");
    }

    //
    // Check out value entry's data
    //
    DataLength = ValueNode->DataLength;
    if (DataLength < CM_KEY_VALUE_SPECIAL_SIZE) {
        Data = ValueNode->Data;
        if ((DataLength == 0) && (Data != HCELL_NIL)) {
            bRez = FALSE;
            fprintf(stderr, "Data not null in Key Value (0x%lx) ",KeyValue);
            if(FixHive) {
            // 
            // REPAIR: set the actual size to HiveLength-FileOffset
            //

            //
            // WARNING: a cell might get lost here!
            //
                bRez = TRUE;
                ValueNode->Data = HCELL_NIL;
                fprintf(stderr, " ... fixed");
            } else {
                if(CompactHive) {
                    // any attempt to compact a corrupted hive will fail
                    CompactHive = FALSE;
                    fprintf(stderr, "\nRun chkreg /R to fix.");
                }
            }
            fprintf(stderr, "\n");
        }
    }
    
    
    if (!CmpIsHKeyValueSmall(realsize, ValueNode->DataLength)) {
        //
        // Data Size
        //
        OwnUsage->Size += GetCellSize(ValueNode->Data);
        OwnUsage->DataCount++;
        OwnUsage->DataSize += GetCellSize(ValueNode->Data);

        // this cell should not be considered as lost
        RemoveCellFromUnknownList(ValueNode->Data);

        ChkAllocatedCell(ValueNode->Data);
        (*KeyCompacted) = ((*KeyCompacted) && ChkAreCellsInSameVicinity(KeyValue,ValueNode->Data));
    }

    //
    // Now the signature
    //
    if (ValueNode->Signature != CM_KEY_VALUE_SIGNATURE) {
        bRez = FALSE;
        fprintf(stderr, "Invalid signature (0x%lx) in Key Value cell 0x%lx ",ValueNode->Signature,KeyValue);
        if(FixHive) {
        // 
        // REPAIR: 
        // FATAL: Mismatched signature cannot be fixed. The key should be deleted! 
        //
            fprintf(stderr, " ... deleting value.");
        } else {
            if(CompactHive) {
                // any attempt to compact a corrupted hive will fail
                CompactHive = FALSE;
                fprintf(stderr, "\nRun chkreg /R to fix.");
            }
        }
        fprintf(stderr, "\n");
    }
    
    return bRez;
}

ULONG 
DeleteNilCells( ULONG Count,
                HCELL_INDEX List[]
               )
/*
Routine Description:

    steps through a list of HCELL_INDEXes and removes the HCELL_NIL ones

Arguments:

    Count - the number of cells in list

    List - the list to be checked

Return Value:

    The new Count value for the list

*/
{
    ULONG i;
    BOOLEAN bFound = TRUE;
    
    while(bFound) {
    // assume we are done after this iteration 
        bFound = FALSE;
        for( i=0;i<Count;i++) {
            if( List[i] == HCELL_NIL ) {
                for(;i<(Count-1);i++) {
                    List[i] = List[i+1];
                }
                bFound = TRUE;
                Count--;
                break;
            }
        }
    }
    return Count;
}

BOOLEAN 
ChkValueList(   HCELL_INDEX ValueList,
                ULONG *ValueCount,
                PREG_USAGE OwnUsage,
                BOOLEAN *KeyCompacted)
/*
Routine Description:

    Checks the consistency of a ValueList.
    Each value is checked.
    Bogus values are freed and removed.

Arguments:

    ValueList - the list to be checked

    ValueCount - count of the list

    OwnUsage - used to collect data statistics

Return Value:

    TRUE if KeyCell is a valid cell or it was successfully fixed.

    FALSE otherwise.

*/
{
    ULONG  i;
    PCELL_DATA      List;
    BOOLEAN bRez = TRUE;

    //
    // Value Index size
    //
    OwnUsage->Size += GetCellSize(ValueList);
    OwnUsage->ValueIndexCount = 1; 
    
    // this cell should not be considered as lost
    RemoveCellFromUnknownList(ValueList);

    ChkAllocatedCell(ValueList);
    
    List = (PCELL_DATA)GetCell(ValueList);
    for (i=0; i<(*ValueCount); i++) {
        if( !ChkKeyValue(List->u.KeyList[i],OwnUsage,KeyCompacted) ) {
            // we should remove this value
            bRez = FALSE;
            // Warning: this my create generate lost cells
            if(FixHive) {
                if( List->u.KeyList[i] != HCELL_NIL ) {
                    //FreeCell(List->u.KeyList[i]);
                    List->u.KeyList[i] = HCELL_NIL;
                }
            }
        }
        (*KeyCompacted) = ((*KeyCompacted) && ChkAreCellsInSameVicinity(ValueList,List->u.KeyList[i]));
    }
    
    if( FixHive && !bRez) {
        (*ValueCount) = DeleteNilCells( *ValueCount,List->u.KeyList);
        bRez = TRUE;
    }
    
    // for now
    return bRez;
}


BOOLEAN 
DumpChkRegistry(
    ULONG   Level,
    USHORT  ParentLength,
    HCELL_INDEX Cell,
    HCELL_INDEX ParentCell,
    PREG_USAGE PUsage
)
/*
Routine Description:

    Recursively walks through the hive. Performs logical vallidation 
    checks on all cells along the path and fix errors when possible.

Arguments:

    Level - the current depth level within the hive key tree

    ParentLength - the length of the parent name (dump purposes only)

    Cell - current key to be checked

    ParentCell - parent cell, used for parent-son relationship checkings

    OwnUsage - used to collect data statistics

Return Value:

    TRUE if Cell is a consistent key, or it was fixed OK.

    FALSE otherwise.

*/
{
    PCM_KEY_FAST_INDEX FastIndex;
    HCELL_INDEX     LeafCell;
    PCM_KEY_INDEX   Leaf;
    PCM_KEY_INDEX   Index;
    PCM_KEY_NODE    KeyNode;
    REG_USAGE ChildUsage, TotalChildUsage, OwnUsage;
    ULONG  i, j;
    USHORT k;
    WCHAR *w1;
    UCHAR *u1;
    USHORT CurrentLength;
    ULONG  CellCount;
    BOOLEAN         bRez = TRUE;
    BOOLEAN KeyCompacted = TRUE;

    ULONG           ClassLength;
    HCELL_INDEX     Class;
    ULONG           ValueCount;
    HCELL_INDEX     ValueList;
    HCELL_INDEX     Security;

    if( Cell == HCELL_NIL ) {
        // TODO
        // we should return an error code so the caller could deleted this child from the structure
        fprintf(stderr, "HCELL_NIL referrenced as a child key of 0x%lx \n",ParentCell);
        bRez = FALSE;
        return bRez;
    }

    KeyNode = (PCM_KEY_NODE) GetCell(Cell);

    // Verify KeyNode consistency
    if(!ChkKeyNodeCell(Cell,ParentCell)) {
    // 
    // Bad karma ==> this key should be deleted
    //
QuitToParentWithError:

        if(ParentCell == HCELL_NIL) {
        // 
        // Root cell not consistent ==> unable to fix the hive
        //
            fprintf(stderr, "Fatal : Inconsistent Root Key 0x%lx",Cell);
            if(FixHive) {
            // 
            // FATAL: nothing to do
            //
                fprintf(stderr, " ... unable to fix");
            } else {
                if(CompactHive) {
                    // any attempt to compact a corrupted hive will fail
                    CompactHive = FALSE;
                }
            }
            fprintf(stderr, "\n");
        }
        bRez = FALSE;
        return bRez;
    }

    ClassLength = KeyNode->ClassLength;
    Class = KeyNode->Class;
    ValueCount = KeyNode->ValueList.Count;
    ValueList = KeyNode->ValueList.List;
    Security = KeyNode->Security;

    if (ClassLength > 0) {
        if( Class != HCELL_NIL ) {
            ChkClassCell(Class);
            KeyCompacted = (KeyCompacted && ChkAreCellsInSameVicinity(Cell,Class));
        } else {
            bRez = FALSE;
            fprintf(stderr,"ClassLength (=%u) doesn't match NIL values in Class for Key 0x%lx",ClassLength,Cell);
            if(FixHive) {
            // 
            // REPAIR: reset the ClassLength
            //
                bRez = TRUE;
                KeyNode->ClassLength = 0;
                fprintf(stderr, " ... fixed");
            } else {
                if(CompactHive) {
                    // any attempt to compact a corrupted hive will fail
                    CompactHive = FALSE;
                    fprintf(stderr, "\nRun chkreg /R to fix.");
                }
            }
            fprintf(stderr, "\n");
        }
    }

    if (Security != HCELL_NIL) {
        if( !ChkSecurityCell(Security) ) {
        //
        // Fatal : We don't mess up with security cells. We can't recover from invalid security cells. 
        //

        //
        // QUESTION : Is it acceptable to drop a security cell?
        //
            bRez = FALSE;
        }
    } else {
        //
        // Fatal: security cell is not allowed to be NIL
        //
        bRez = FALSE;
        fprintf(stderr,"Security cell is NIL for Key 0x%lx",Cell);
        if(FixHive) {
            // 
            // REPAIR: reset the security to the root security
            //
            PCM_KEY_NODE RootNode;
            PCM_KEY_SECURITY SecurityNode;
            bRez = TRUE;
            RootNode = (PCM_KEY_NODE) GetCell(RootCell);
            KeyNode->Security = RootNode->Security;
            SecurityNode = (PCM_KEY_SECURITY)GetCell(RootNode->Security);
            SecurityNode->ReferenceCount++;
            fprintf(stderr, " ... fixed");
        } 
    }

    //
    // Construct the full path name of the key
    //

    if (Level > 0) {
        KeyName.Length = ParentLength;
        if (KeyNode->Flags & KEY_COMP_NAME) {
            u1 = (UCHAR*) &(KeyNode->Name[0]);
            w1 = &(NameBuffer[KeyName.Length/sizeof(WCHAR)]);
            for (k=0;k<KeyNode->NameLength;k++) {
                // NameBuffer[k] = (UCHAR)(KeyNode->Name[k]);
                // NameBuffer[k] = (WCHAR)(u1[k]);
                *w1 = (WCHAR) *u1;
                w1++;
                u1++;
            }
            KeyName.Length += KeyNode->NameLength*sizeof(WCHAR);
        } else {
            RtlCopyMemory((PVOID)&(NameBuffer[KeyName.Length]), (PVOID)(KeyNode->Name), KeyNode->NameLength);
            KeyName.Length += KeyNode->NameLength;
        }
        NameBuffer[KeyName.Length/sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
        KeyName.Length += sizeof(WCHAR);

    }
    CurrentLength = KeyName.Length;

    //
    // Calculate the count of this key and value
    //
    OwnUsage.KeyNodeCount = 1;
    OwnUsage.KeyValueCount = KeyNode->ValueList.Count;
    OwnUsage.ValueIndexCount = 0;
    OwnUsage.DataCount = 0;
    OwnUsage.DataSize = 0;

    //
    // Calculate the count (including overhead and value) of this key
    //
    // Key node size
    //
    OwnUsage.Size = GetCellSize(Cell);

    if( ValueCount ) {
        if( ValueList == HCELL_NIL ) {
            bRez = FALSE;
            fprintf(stderr,"ValueCount is %lu, but ValueList is NIL for key 0x%lx",ValueCount,Cell);
            if(FixHive) {
            // 
            // REPAIR: adjust the ValueList count
            //
                bRez = TRUE;
                KeyNode->ValueList.Count = 0;
                fprintf(stderr, " ... fixed");
            } else {
                if(CompactHive) {
                    // any attempt to compact a corrupted hive will fail
                    CompactHive = FALSE;
                    fprintf(stderr, "\nRun chkreg /R to fix.");
                }
            }
            fprintf(stderr, "\n");
        } else {
            if(!ChkValueList(ValueList,&(KeyNode->ValueList.Count),&OwnUsage,&KeyCompacted) ) {
            // the ValueList is not consistent or cannot be fixed 
                bRez = FALSE;
                if(FixHive) {
                // 
                // REPAIR: empty the ValueList
                //
                    bRez = TRUE;
                    KeyNode->ValueList.Count = 0;
                    //FreeCell(ValueList);
                    KeyNode->ValueList.List = HCELL_NIL;
                    fprintf(stderr,"ValueList 0x%lx for key 0x%lx dropped!",ValueCount,Cell);
                } else {
                    if(CompactHive) {
                        // any attempt to compact a corrupted hive will fail
                        CompactHive = FALSE;
                        fprintf(stderr, "\nRun chkreg /R to fix.");
                    }
                }
                fprintf(stderr, "\n");
            }
            KeyCompacted = (KeyCompacted && ChkAreCellsInSameVicinity(Cell,ValueList));
        }
    }
  
    //
    // Calculate the size of the children
    //
    TotalChildUsage.KeyNodeCount = 0;
    TotalChildUsage.KeyValueCount = 0;
    TotalChildUsage.ValueIndexCount = 0;
    TotalChildUsage.KeyIndexCount = 0;
    TotalChildUsage.DataCount = 0;
    TotalChildUsage.DataSize = 0;
    TotalChildUsage.Size = 0;

    if (KeyNode->SubKeyCounts[0]) {
        //
        // Size for index cell 
        //
        if( KeyNode->SubKeyLists[0]  == HCELL_NIL ) {
            //
            // We got a problem here: the count says there should be some keys, but the list is NIL
            //
            bRez = FALSE;
            fprintf(stderr,"SubKeyCounts is %lu, but the SubKeyLists is NIL for key 0x%lx",KeyNode->SubKeyCounts[0],Cell);
            if(FixHive) {
            // 
            // REPAIR: adjust the subkeys count
            //
                bRez = TRUE;
                KeyNode->SubKeyCounts[0] = 0;
                fprintf(stderr, " ... fixed");
            } else {
                if(CompactHive) {
                    // any attempt to compact a corrupted hive will fail
                    CompactHive = FALSE;
                    fprintf(stderr, "\nRun chkreg /R to fix.");
                }
            }
            fprintf(stderr, "\n");
            return bRez;
        }
        KeyCompacted = (KeyCompacted && ChkAreCellsInSameVicinity(Cell,KeyNode->SubKeyLists[0]));
        
        TotalChildUsage.Size += GetCellSize(KeyNode->SubKeyLists[0]);
        TotalChildUsage.KeyIndexCount++;

        Index = (PCM_KEY_INDEX)GetCell(KeyNode->SubKeyLists[0]);

        // this cell should not be considered as lost
        RemoveCellFromUnknownList(KeyNode->SubKeyLists[0]);

        ChkAllocatedCell(KeyNode->SubKeyLists[0]);

        if (Index->Signature == CM_KEY_INDEX_ROOT) {
            for (i = 0; i < Index->Count; i++) {
                // 
                // Size of Index Leaf
                //

                LeafCell = Index->List[i];

                TotalChildUsage.Size += GetCellSize(Index->List[i]);
                TotalChildUsage.KeyIndexCount++;

                // this cell should not be considered as lost
                RemoveCellFromUnknownList(LeafCell);

                ChkAllocatedCell(LeafCell);

                Leaf = (PCM_KEY_INDEX)GetCell(LeafCell);
                if ( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                     (Leaf->Signature == CM_KEY_HASH_LEAF) ) {
                    FastIndex = (PCM_KEY_FAST_INDEX)Leaf;
againFastLeaf1:
                    for (j = 0; j < FastIndex->Count; j++) {
                        if(!DumpChkRegistry(Level+1, CurrentLength, FastIndex->List[j].Cell,Cell,&ChildUsage)) {
                        // this child is not consistent or cannot be fixed. Remove it!!!
                            if(FixHive) {
                            // 
                            // REPAIR: drop this child
                            //
                                fprintf(stderr,"Subkey 0x%lx of 0x%lx deleted!\n",FastIndex->List[j].Cell,Cell);
                                for( ;j<(ULONG)(FastIndex->Count-1);j++) {
                                    FastIndex->List[j] = FastIndex->List[j+1];
                                }
                                FastIndex->Count--;
                                KeyNode->SubKeyCounts[0]--;
                                goto againFastLeaf1;
                            } else {
                                bRez = FALSE;
                                if(CompactHive) {
                                    // any attempt to compact a corrupted hive will fail
                                    CompactHive = FALSE;
                                    fprintf(stderr, "\nRun chkreg /R to fix.");
                                }
                            }
                            fprintf(stderr, "\n");
                        }
                        //
                        // Add to total count
                        //
                        TotalChildUsage.KeyNodeCount += ChildUsage.KeyNodeCount;
                        TotalChildUsage.KeyValueCount += ChildUsage.KeyValueCount;
                        TotalChildUsage.ValueIndexCount += ChildUsage.ValueIndexCount;
                        TotalChildUsage.KeyIndexCount += ChildUsage.KeyIndexCount;
                        TotalChildUsage.DataCount += ChildUsage.DataCount;
                        TotalChildUsage.DataSize += ChildUsage.DataSize;
                        TotalChildUsage.Size += ChildUsage.Size;
                    }
                } else if(Leaf->Signature == CM_KEY_INDEX_LEAF) {
againFastLeaf2:
                    for (j = 0; j < Leaf->Count; j++) {
                        if(!DumpChkRegistry(Level+1, CurrentLength, Leaf->List[j],Cell,&ChildUsage)) {
                        // this child is not consistent or cannot be fixed. Remove it!!!
                            if(FixHive) {
                            // 
                            // REPAIR: drop this child
                            //
                                fprintf(stderr,"Subkey 0x%lx of 0x%lx deleted!\n",Leaf->List[j],Cell);
                                for( ;j<(ULONG)(Leaf->Count-1);j++) {
                                    Leaf->List[j] = Leaf->List[j+1];
                                }
                                Leaf->Count--;
                                KeyNode->SubKeyCounts[0]--;
                                goto againFastLeaf2;
                            } else {
                                bRez = FALSE;
                                if(CompactHive) {
                                    // any attempt to compact a corrupted hive will fail
                                    CompactHive = FALSE;
                                    fprintf(stderr, "\nRun chkreg /R to fix.");
                                }
                            }
                            fprintf(stderr, "\n");
                        }
                        //
                        // Add to total count
                        //
                        TotalChildUsage.KeyNodeCount += ChildUsage.KeyNodeCount;
                        TotalChildUsage.KeyValueCount += ChildUsage.KeyValueCount;
                        TotalChildUsage.ValueIndexCount += ChildUsage.ValueIndexCount;
                        TotalChildUsage.KeyIndexCount += ChildUsage.KeyIndexCount;
                        TotalChildUsage.DataCount += ChildUsage.DataCount;
                        TotalChildUsage.DataSize += ChildUsage.DataSize;
                        TotalChildUsage.Size += ChildUsage.Size;
                    }
                } else {
                // invalid index signature: only way to fix it is by dropping the entire key 
                    fprintf(stderr,"Invalid Index signature 0x%lx in key 0x%lx",(ULONG)Leaf->Signature,Cell);
                    if(FixHive) {
                    // 
                    // REPAIR: 
                    // FATAL: Mismatched signature cannot be fixed. The key should be deleted! 
                    //
                        fprintf(stderr, " ... deleting containing key");
                    }
                    fprintf(stderr,"\n");
                    goto QuitToParentWithError;
                }
            }

        } else if(  (Index->Signature == CM_KEY_FAST_LEAF) ||
                    (Index->Signature == CM_KEY_HASH_LEAF) ) {
            FastIndex = (PCM_KEY_FAST_INDEX)Index;

againFastLeaf3:

            for (i = 0; i < FastIndex->Count; i++) {
                if(!DumpChkRegistry(Level+1, CurrentLength, FastIndex->List[i].Cell,Cell,&ChildUsage)) {
                // this child is not consistent or cannot be fixed. Remove it!!!
                    if(FixHive) {
                    // 
                    // REPAIR: drop this child
                    //
                        fprintf(stderr,"Subkey 0x%lx of 0x%lx deleted!\n",FastIndex->List[i].Cell,Cell);
                        for( ;i<(ULONG)(FastIndex->Count-1);i++) {
                            FastIndex->List[i] = FastIndex->List[i+1];
                        }
                        FastIndex->Count--;
                        KeyNode->SubKeyCounts[0]--;
                        goto againFastLeaf3;
                    } else {
                        bRez = FALSE;
                        if(CompactHive) {
                            // any attempt to compact a corrupted hive will fail
                            CompactHive = FALSE;
                            fprintf(stderr, "\nRun chkreg /R to fix.");
                        }
                    }
                    fprintf(stderr, "\n");
                }

                //
                // Add to total count
                //
                TotalChildUsage.KeyNodeCount += ChildUsage.KeyNodeCount;
                TotalChildUsage.KeyValueCount += ChildUsage.KeyValueCount;
                TotalChildUsage.ValueIndexCount += ChildUsage.ValueIndexCount;
                TotalChildUsage.KeyIndexCount += ChildUsage.KeyIndexCount;
                TotalChildUsage.DataCount += ChildUsage.DataCount;
                TotalChildUsage.DataSize += ChildUsage.DataSize;
                TotalChildUsage.Size += ChildUsage.Size;
            }
        } else if(Index->Signature == CM_KEY_INDEX_LEAF) {
            for (i = 0; i < Index->Count; i++) {
againFastLeaf4:
                if(!DumpChkRegistry(Level+1, CurrentLength, Index->List[i],Cell, &ChildUsage)) {
                // this child is not consistent or cannot be fixed. Remove it!!!
                    if(FixHive) {
                    // 
                    // REPAIR: drop this child
                    //
                        fprintf(stderr,"Subkey 0x%lx of 0x%lx deleted!\n",Index->List[i],Cell);
                        for( ;i<(ULONG)(Index->Count-1);i++) {
                            Index->List[i] = Index->List[i+1];
                        }
                        Index->Count--;
                        KeyNode->SubKeyCounts[0]--;
                        goto againFastLeaf4;
                    } else {
                        bRez = FALSE;
                        if(CompactHive) {
                            // any attempt to compact a corrupted hive will fail
                            CompactHive = FALSE;
                            fprintf(stderr, "\nRun chkreg /R to fix.");
                        }
                    }
                    fprintf(stderr, "\n");
                }
                //
                // Add to total count
                //
                TotalChildUsage.KeyNodeCount += ChildUsage.KeyNodeCount;
                TotalChildUsage.KeyValueCount += ChildUsage.KeyValueCount;
                TotalChildUsage.ValueIndexCount += ChildUsage.ValueIndexCount;
                TotalChildUsage.KeyIndexCount += ChildUsage.KeyIndexCount;
                TotalChildUsage.DataCount += ChildUsage.DataCount;
                TotalChildUsage.DataSize += ChildUsage.DataSize;
                TotalChildUsage.Size += ChildUsage.Size;
            }
        } else {
        // invalid index signature: only way to fix it is by dropping the entire key 
            fprintf(stderr,"Invalid Index signature 0x%lx in key 0x%lx",(ULONG)Index->Signature,Cell);
            if(FixHive) {
            // 
            // REPAIR: 
            // FATAL: Mismatched signature cannot be fixed. The key should be deleted! 
            //
                fprintf(stderr, " ... deleting containing key");
            }
            fprintf(stderr,"\n");
            goto QuitToParentWithError;
        }

        KeyName.Length = CurrentLength;
    }

    PUsage->KeyNodeCount = OwnUsage.KeyNodeCount + TotalChildUsage.KeyNodeCount;
    PUsage->KeyValueCount = OwnUsage.KeyValueCount + TotalChildUsage.KeyValueCount;
    PUsage->ValueIndexCount = OwnUsage.ValueIndexCount + TotalChildUsage.ValueIndexCount;
    PUsage->KeyIndexCount = TotalChildUsage.KeyIndexCount;
    PUsage->DataCount = OwnUsage.DataCount + TotalChildUsage.DataCount;
    PUsage->DataSize = OwnUsage.DataSize + TotalChildUsage.DataSize;
    PUsage->Size = OwnUsage.Size + TotalChildUsage.Size;
    if(KeyCompacted) {
        CountKeyNodeCompacted++;
    }

    if ((Level <= MaxLevel) && (Level > 0)) {
        CellCount = PUsage->KeyNodeCount + 
                    PUsage->KeyValueCount + 
                    PUsage->ValueIndexCount + 
                    PUsage->KeyIndexCount + 
                    PUsage->DataCount;

        fprintf(OutputFile,"%6d,%6d,%7d,%10d, %wZ\n", 
                PUsage->KeyNodeCount,
                PUsage->KeyValueCount,
                CellCount,
                PUsage->Size,
                &KeyName);
    }

    return bRez;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\reglog.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    reglog.c

Abstract:

    This module contains functions to check bin header and bin body consistency.

Author:

    Dragos C. Sambotin (dragoss) 17-Feb-2000

Revision History:

--*/
#include "chkreg.h"

VOID
ChkDumpLogFile( PHBASE_BLOCK BaseBlock,ULONG Length )
/*++

Routine Description:


Arguments:

    BaseBlock - the BaseBlock in-memory mapped image.
    
    dwFileSize - the actual size of the hive file

Return Value:

--*/
{
    ULONG           Cluster;                // for logs only
    PULONG          DirtyVector;
    ULONG           DirtSize;
    ULONG           DirtyCount;
    ULONG i;
    ULONG SizeOfBitmap;
    ULONG DirtyBuffer;
    PUCHAR DirtyBufferAddr;
    ULONG Mask;
    ULONG BitsPerULONG;
    ULONG BitsPerBlock;
    char str[HBASE_NAME_ALLOC +1];
    
    fprintf(stderr, "Signature           : ");
    if(BaseBlock->Signature != HBASE_BLOCK_SIGNATURE) {
        fprintf(stderr, "(0x%lx) - Invalid",BaseBlock->Signature);
    } else {
        fprintf(stderr, "HBASE_BLOCK_SIGNATURE - Valid");
    }
    fprintf(stderr, "\n");

    fprintf(stderr, "Sequence1           : %lx\n",BaseBlock->Sequence1);
    fprintf(stderr, "Sequence2           : %lx\n",BaseBlock->Sequence2);
    fprintf(stderr, "TimeStamp(High:Low) : (%lx:%lx)\n",BaseBlock->TimeStamp.HighPart,BaseBlock->TimeStamp.LowPart);

    fprintf(stderr, "Major Version       : %lx\n",BaseBlock->Major);
    fprintf(stderr, "Minor Version       : %lx\n",BaseBlock->Minor);
    fprintf(stderr, "Type                : %lx\n",BaseBlock->Type);
    fprintf(stderr, "Format              : %lx\n",BaseBlock->Format);
    fprintf(stderr, "RootCell            : %lx\n",BaseBlock->RootCell);
    fprintf(stderr, "Length              : %lx\n",BaseBlock->Length);
    Cluster = BaseBlock->Cluster;
    fprintf(stderr, "Cluster             : %lx\n",Cluster);

/*    for(i=0;i<HBASE_NAME_ALLOC;i++) str[i] = BaseBlock->FileName[i];
    str[i] = 0;
    fprintf(stderr, "FileName: %s\n",str);
*/    
    fprintf(stderr, "CheckSum            : %lx\n",BaseBlock->CheckSum);


    DirtyVector = (PULONG)((PCHAR)BaseBlock + Cluster*HSECTOR_SIZE);
    
    fprintf(stderr, "Dirt Signature      : ");
    if(  *DirtyVector == HLOG_DV_SIGNATURE ) {
        fprintf(stderr, "HLOG_DV_SIGNATURE - Valid");
    } else {
        fprintf(stderr, "(0x%lx) - Invalid",*DirtyVector);
    }
    fprintf(stderr, "\n");


    DirtyVector++;
    if( Length == 0 ) Length = BaseBlock->Length;
    DirtSize = Length / HSECTOR_SIZE;

    SizeOfBitmap = DirtSize;
    DirtyBufferAddr = (PUCHAR)DirtyVector;
    BitsPerULONG = 8*sizeof(ULONG);
    BitsPerBlock = HBLOCK_SIZE / HSECTOR_SIZE;
    DirtyCount = 0;

    fprintf(stderr,"\n   Address                       32k                                       32k");
    for(i=0;i<SizeOfBitmap;i++) {
        if( !(i%(2*BitsPerULONG ) ) ){
            fprintf(stderr,"\n 0x%8lx  ",i*HSECTOR_SIZE);
        }

        if( !(i%BitsPerBlock) ) {
            fprintf(stderr," ");
        }
        if( !(i%BitsPerULONG) ) {
            //
            // fetch in a new DWORD
            //
            DirtyBuffer = *(PULONG)DirtyBufferAddr;
            DirtyBufferAddr += sizeof(ULONG);
            fprintf(stderr,"\t");
        }

        Mask = ((DirtyBuffer >> (i%BitsPerULONG)) & 0x1);
        //Mask <<= (BitsPerULONG - (i%BitsPerULONG) - 1);
        //Mask &= DirtyBuffer;
        fprintf(stderr,"%s",Mask?"1":"0");
        if(Mask) DirtyCount++;
    }
    fprintf(stderr,"\n\n");

    fprintf(stderr,"DirtyCount = %lu\n",DirtyCount);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\regmain.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regmain.c

Abstract:

    Main module. Data definitions.

Author:

    Dragos C. Sambotin (dragoss) 30-Dec-1998

Revision History:

--*/

#include "chkreg.h"

// check the hive structure.
BOOLEAN CheckHive = TRUE;

// compact the hive.
BOOLEAN CompactHive = FALSE;

// check for lost space (marked as used but not reffered).
BOOLEAN LostSpace = FALSE;

// repair damaged hives.
BOOLEAN FixHive = FALSE;

// repair damaged hives.
BOOLEAN SpaceUsage = FALSE;

// maximum level to dump 
ULONG   MaxLevel = 0;

// bin to examine space display
LONG    BinIndex = -1;

// the hive file name
TCHAR *Hive = NULL;

// the root of the hive
HCELL_INDEX RootCell;

// Usage string
char *Usage="\
Checks a hive file and perform repairs, compacts or displays a status report.\n\n\
CHKREG /F <filename[.<LOG>]> [/H] [/D [<level>] [/S [<bin>]] [/C] [/L] [/R]\n\n\
    <filename>      FileName of hive to be analyzed\n\
    /H              This manual\n\
    /D [<level>]    Dump subkeys up to level <level>. If level is not\n\
                    specified, dumps the entire hive. No checks are done\n\
                    when dumping.\n\
    /S [<bin>]      Displays space usage for the bin <bin>. When bin is\n\
                    not specified, displays usage for the entire hive.\n\
    /C              Compacts the hive. Bad hives cannot be compacted.\n\
                    The compacted hive will be written to <filename>.BAK\n\
    /L              Lost space detection.\n\
    /R              Repair the hive.\n\
    ";

// Lost Space Warning
char *LostSpaceWarning="\n\
WARNING :  Lost space detection may take a while. Are you sure you want this (y/n)?";

// Starting address of the in-memory maped hive image
PUCHAR Base;

// LostCells list used for lost space detection
UNKNOWN_LIST LostCells[FRAGMENTATION];

// OutputFile : future changes may use it to write the results to a file rather than to stdout
FILE *OutputFile;

#define NAME_BUFFERSIZE 2000

UNICODE_STRING  KeyName;
WCHAR NameBuffer[NAME_BUFFERSIZE];

// Miscelaneous variables used fo data statistics
ULONG   TotalKeyNode=0;
ULONG   TotalKeyValue=0;
ULONG   TotalKeyIndex=0;
ULONG   TotalKeySecurity=0;
ULONG   TotalValueIndex=0;
ULONG   TotalUnknown=0;

ULONG   CountKeyNode=0;
ULONG   CountKeyValue=0;
ULONG   CountKeyIndex=0;
ULONG   CountKeySecurity=0;
ULONG   CountValueIndex=0;
ULONG   CountUnknown=0;

ULONG   CountKeyNodeCompacted=0;

ULONG   TotalFree=0; 
ULONG   FreeCount=0; 
ULONG   TotalUsed=0;

PHBIN   FirstBin;
PHBIN   MaxBin;
ULONG   HiveLength;

#define OPTION_MODE 0
#define FILE_MODE   1
#define LEVEL_MODE  2
#define BIN_MODE    3

VOID
ChkDumpLogFile( PHBASE_BLOCK BaseBlock,ULONG Length );

VOID
ParseArgs (
    int argc,
    char *argv[]
    )
{

    char *p;
    int i;
    
    // specified what should we expect from the command line
    int iMode = OPTION_MODE;
    
    for(i=0;i<argc;i++) {
        p  = argv[i];
        if ( *p == '/' || *p == '-' ) {
            // option mode
            p++;
            iMode = OPTION_MODE;
            while ((*p != '\0') && (*p != ' ')) {
                switch (*p) {
                case 'h':
                case 'H':
                case '?':
                    fprintf(stderr, "%s\n", Usage);
                    ExitProcess(1);
                    break;
                case 'f':
                case 'F':
                    iMode = FILE_MODE;
                    break;
                case 'd':
                case 'D':
                    iMode = LEVEL_MODE;
                    // when not specified, dump at least 100 levels
                    MaxLevel = 100;
                    CheckHive = FALSE;
                    break;
                case 's':
                case 'S':
                    SpaceUsage = TRUE;
                    iMode = BIN_MODE;
                    break;
                case 'c':
                case 'C':
                    p++;
                    CompactHive = TRUE;
                    break;
                case 'l':
                case 'L':
                    p++;
                    LostSpace = TRUE;
                    break;
                case 'r':
                case 'R':
                    p++;
                    FixHive = TRUE;
                    break;
                default:
                    break;
                }
                if( iMode != OPTION_MODE ) {
                    // break the loop; ignore the rest of the current argv
                    break;
                }
            } // while
        } else {
            switch(iMode) {
            case FILE_MODE:
                Hive = argv[i]; 
                break;
            case LEVEL_MODE:
                MaxLevel = (ULONG) atol(argv[i]);
                break;
            case BIN_MODE:
                BinIndex = (LONG) atol(argv[i]);
                break;
            default:
                break;
            }
        }
    }
    
}

__cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG   FileIndex;
    HANDLE myFileHandle, myMMFHandle;
    LPBYTE myMMFViewHandle;
    BYTE lowChar, hiChar, modVal;
    DWORD dwFileSize;
    ULONG   Index,Index2;

    PHBASE_BLOCK PHBaseBlock;
    PHBIN        NewBins;
    ULONG        Offset;
    ULONG        CellCount;
    ULONG        SizeCount;

    REG_USAGE    TotalUsage;
    DWORD dwHiveFileAccess = GENERIC_READ;
    DWORD flHiveViewProtect = PAGE_READONLY;
    DWORD dwHiveViewAccess = FILE_MAP_READ;
    ParseArgs( argc, argv );

    if (!Hive) {
        fprintf(stderr, "\nMust provide a hive name !!!\n\n");
        fprintf(stderr, "%s\n", Usage);
        ExitProcess(-1);
    }

    if(LostSpace) {
    // are you sure you want lost cells detection? It may take a while!
        int chLost;
        fprintf(stdout, "%s",LostSpaceWarning);
        fflush(stdin);
        chLost = getchar();
        if( (chLost != 'y') && (chLost != 'Y') ) {
        // he changed his mind
            LostSpace = FALSE;
        }
        fprintf(stderr, "\n");
    }

    if( FixHive ) {
        dwHiveFileAccess |= GENERIC_WRITE;
        flHiveViewProtect = PAGE_READWRITE;
        dwHiveViewAccess = FILE_MAP_WRITE;
    }
    /* Create temporary file for mapping. */
    if ((myFileHandle = CreateFile (Hive, dwHiveFileAccess,
                                   0 , NULL, OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL))
         == (HANDLE) INVALID_HANDLE_VALUE) /* Bad handle */ {
        fprintf(stderr,"Could not create file %s\n", Hive);
        exit(-1);
    }

    // Get the size of the file.  I am assuming here that the
    // file is smaller than 4 GB.
    dwFileSize = GetFileSize(myFileHandle, NULL);

    /* If we get here, we managed to name and create a temp file. Now we need
       to create a mapping */

    myMMFHandle = CreateFileMapping (myFileHandle, NULL, flHiveViewProtect,
                                     0, dwFileSize, NULL);
    if (myMMFHandle == (HANDLE) INVALID_HANDLE_VALUE) {
        fprintf(stderr,"Could not map file %s\n", Hive);
        exit(-1);
    }

    /* So we've mapped the file. Now try to map a view */

    myMMFViewHandle = (LPBYTE) MapViewOfFile (myMMFHandle, dwHiveViewAccess, 0, 0, dwFileSize);
    if (!myMMFViewHandle) {
        fprintf(stderr,"Could not map view of file %s   error = %lx\n", Hive,(ULONG)GetLastError());
        exit(-1);
    }

    /* Now we have a view. Read through it */

    PHBaseBlock = (PHBASE_BLOCK) myMMFViewHandle;

    if( strstr(Hive,".LOG") != NULL ) {
        // dumping log file 
        ChkDumpLogFile(PHBaseBlock,MaxLevel);
    } else {
/*
        if (PHBaseBlock->Minor < 4) {
            fprintf(stderr,"Hive version %d is too old, must be 3 or later\n", PHBaseBlock->Minor);
            ExitProcess(-1);
        }
*/
        // Initialization stuff
        for(Index =0;Index<FRAGMENTATION;Index++) {
            LostCells[Index].Count = 0;
            for(Index2 = 0;Index2<SUBLISTS;Index2++) {
                LostCells[Index].List[Index2] = NULL;
            }
        }
    
        RootCell = PHBaseBlock->RootCell;
    
        OutputFile = stdout;
        Base = (PUCHAR)(PHBaseBlock) + HBLOCK_SIZE;

        Offset=HBLOCK_SIZE;
        HiveLength = PHBaseBlock->Length;

        MaxBin= (PHBIN) (Base + HiveLength);
        FirstBin = (PHBIN) (Base);

        KeyName.Buffer = NameBuffer;
        KeyName.MaximumLength = NAME_BUFFERSIZE;

        ChkBaseBlock(PHBaseBlock,dwFileSize);
    
        ChkSecurityDescriptors();

        ChkPhysicalHive();

        if (MaxLevel) {
            fprintf(stdout,"%6s,%6s,%7s,%10s, %s\n", 
                    "Keys",
                    "Values",
                    "Cells",
                    "Size",
                    "SubKeys");
        }

        DumpChkRegistry(0, 0, PHBaseBlock->RootCell,HCELL_NIL,&TotalUsage);

        if(LostSpace) {
            // clear the dirt on the screen
            fprintf(OutputFile,"\r                          \n");
        }

        DumpUnknownList();
        FreeUnknownList();

        fprintf(OutputFile,"\nSUMMARY: \n");
        fprintf(OutputFile,"%15s,%15s,     %s\n", 
                    "Cells",
                    "Size",
                    "Category");

        fprintf(OutputFile,"%15lu,%15lu,     Keys\n", 
                CountKeyNode,
                TotalKeyNode
                );
        fprintf(OutputFile,"%15lu,%15lu,     Values\n", 
                CountKeyValue,
                TotalKeyValue
                );
        fprintf(OutputFile,"%15lu,%15lu,     Key Index\n", 
                CountKeyIndex,
                TotalKeyIndex
                );
        fprintf(OutputFile,"%15lu,%15lu,     Value Index\n", 
                CountValueIndex,
                TotalValueIndex
                );
        fprintf(OutputFile,"%15lu,%15lu,     Security\n", 
                CountKeySecurity,
                TotalKeySecurity
                );
        fprintf(OutputFile,"%15lu,%15lu,     Data\n", 
                CountUnknown - CountValueIndex,
                TotalUnknown - TotalValueIndex
                );

        fprintf(OutputFile,"%15lu,%15lu,     Free\n", 
                FreeCount,
                TotalFree
                );

        CellCount = CountKeyNode + 
                    CountKeyValue + 
                    CountKeyIndex + 
                    CountKeySecurity + 
                    CountUnknown +
                    FreeCount;

        SizeCount = TotalKeyNode +
                    TotalKeyValue +
                    TotalKeyIndex +
                    TotalKeySecurity +
                    TotalUnknown +
                    TotalFree;

        fprintf(OutputFile,"%15lu,%15lu,     %s\n", 
                CellCount,
                SizeCount,
                "Total Hive");

        fprintf(OutputFile,"\n%15lu compacted  keys (all related cells in the same view)\n",CountKeyNodeCompacted);
            
    }
        
    UnmapViewOfFile(myMMFViewHandle);
    CloseHandle(myMMFHandle);
    CloseHandle(myFileHandle);

    if(CompactHive) {
        DoCompactHive();
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\rules.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    rules.c
Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "chkreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmkd\geninst.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    geninst.c

Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\chkreg\regsav.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regsav.c

Abstract:

    This module contains routine for compacting the hive file

Author:

    Dragos C. Sambotin (dragoss) 30-Dec-1998

Revision History:

--*/
#include "chkreg.h"

#define TEMP_KEY_NAME       TEXT("chkreg___$$Temp$Hive$$___")

extern TCHAR *Hive;

// to store the name of the compacted hive
TCHAR CompactedHive[MAX_PATH];

VOID 
DoCompactHive()
/*
Routine Description:

    Compacts a hive. It uses the LoadKey/SaveKey/UnloadKey sequence.
    The hive is temporary loaded under the key HKLM\TEMP_KEY_NAME.
    After compacting, the hive is unloaded (cleaning process).

Arguments:

    None.

Return Value:

    NONE.

*/
{
    NTSTATUS Status;
    BOOLEAN  OldPrivState;
    LONG     Err;
    HKEY    hkey;

    // construct the file name for the compacted hive
    if(!lstrcpy(CompactedHive,Hive) ) {
        fprintf(stderr,"Unable to generate new Hive file name\n");
        return;
    }

    if(!lstrcat(CompactedHive,TEXT(".BAK")) ) {
        fprintf(stderr,"Unable to generate new Hive file name\n");
        return;
    }
    
    // Attempt to get restore privilege
    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &OldPrivState);
    if (!NT_SUCCESS(Status)) {
        printf("Could not adjust privilege; status = 0x%lx\n",Status);
        return;
    }

    // Load the hive into registry
    Err = RegLoadKey(HKEY_LOCAL_MACHINE,TEMP_KEY_NAME,Hive);

    if( Err != ERROR_SUCCESS ) {
        fprintf(stderr,"Failed to load the Hive; error 0x%lx \n",Err);
    } else {
        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEMP_KEY_NAME,
                           REG_OPTION_RESERVED,
                           KEY_READ,
                           &hkey);

        if (Err == ERROR_SUCCESS) {

            // Restore old privilege if necessary.

            if (!OldPrivState) {

                RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                   FALSE,
                                   FALSE,
                                   &OldPrivState);
            }


            RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &OldPrivState);

            // Save the key into the new file name.
            // The CmpCopyTree function will take care of compacting also.
            Err = RegSaveKey(hkey,CompactedHive,NULL);
            if( Err != ERROR_SUCCESS ) {
                fprintf(stderr,"Failed to Save the Hive; error 0x%lx \n",Err);
            }
            
            if (!OldPrivState) {

                RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,
                                   FALSE,
                                   FALSE,
                                   &OldPrivState);
            }

            RegCloseKey(hkey);

        }
        
        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &OldPrivState);

        // cleanup the registry machine hive.
        Err = RegUnLoadKey(HKEY_LOCAL_MACHINE,TEMP_KEY_NAME);
        if( Err != ERROR_SUCCESS ) {
            fprintf(stderr,"Failed to unload the Hive; error 0x%lx \n",Err);
        }
        if (!OldPrivState) {

            RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                               FALSE,
                               FALSE,
                               &OldPrivState);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmkd\cmkd.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cmkd.c

Abstract:

    Kernel debugger extensions useful for the registry

    Starting point: regext.c (jvert)

Author:

    Dragos C. Sambotin (dragoss) 5-May-1999

Environment:

    Loaded as a kernel debugger extension

Revision History:

    Dragos C. Sambotin (dragoss) 5-May-1999
        created

    Dragos C. Sambotin (dragoss) 06-March-2000
        moved to cm directory; ported to new windbg format

--*/
#include "cmp.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windef.h>
#include <windows.h>
#include <ntverp.h>
#include <imagehlp.h>

#include <memory.h>

#include <wdbgexts.h>
#include <stdlib.h>
#include <stdio.h>

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;


HIVE_LIST_ENTRY HiveList[8];

ULONG TotalPages;
ULONG TotalPresentPages;

ULONG TotalKcbs;
ULONG TotalKcbName;

BOOLEAN SavePages;
BOOLEAN RestorePages;
FILE *TempFile;

#define ExitIfCtrlC()   if (CheckControlC()) return
#define BreakIfCtrlC()  if (CheckControlC()) break

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( dwReserved );
    
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}


USHORT
GetKcbName(
    ULONG_PTR KcbAddr,
    PWCHAR NameBuffer,
    ULONG  BufferSize
)
/*++

Routine Description:

    Takes a kcb and dump its complete name.

Arguments:

    KcbAddr - Address of key control block.

    NameBuffer - The Name buffer to fill in the name.

    BufferSize - Size of Buffer.
Return Value:

    Size of Name String.

--*/
{
    WCHAR Name[ 256 ];
    CM_KEY_CONTROL_BLOCK TmpKcb;
    ULONG_PTR  TmpKcbAddr;
    CM_NAME_CONTROL_BLOCK NameBlock;
    ULONG_PTR  NameBlockAddr;
    DWORD  BytesRead;
    USHORT Length;
    USHORT TotalLength;
    USHORT size;
    USHORT i;
    USHORT BeginPosition;
    WCHAR *w1, *w2;
    WCHAR *BufferEnd;
    UCHAR *u2;

    //
    // Calculate the total string length.
    //
    TotalLength = 0;
    TmpKcbAddr = KcbAddr;
    while (TmpKcbAddr) {
        ExitIfCtrlC() 0;
        if( !ReadMemory(TmpKcbAddr,
                   &TmpKcb,
                   sizeof(TmpKcb),
                   &BytesRead) ) { 
            dprintf("Could not read KCB: 1\n");
            return (0);
        }

        NameBlockAddr = (ULONG_PTR) TmpKcb.NameBlock;
        if(!ReadMemory(NameBlockAddr,
               &NameBlock,
               sizeof(NameBlock),
               &BytesRead)) {
            dprintf("Could not read NCB: 2\n");
            return (0);
        }

        if (NameBlock.Compressed) {
            Length = NameBlock.NameLength * sizeof(WCHAR);
        } else {
            Length = NameBlock.NameLength;
        }
        TotalLength += Length;

        //
        // Add the sapce for OBJ_NAME_PATH_SEPARATOR;
        //
        TotalLength += sizeof(WCHAR);

        TmpKcbAddr = (ULONG_PTR) TmpKcb.ParentKcb;
    }

    BufferEnd = &(NameBuffer[BufferSize/sizeof(WCHAR) - 1]);
    if (TotalLength < BufferSize) {
        NameBuffer[TotalLength/sizeof(WCHAR)] =  UNICODE_NULL;
    } else {
        *BufferEnd = UNICODE_NULL;
    }

    //
    // Now fill the name into the buffer.
    //
    TmpKcbAddr = KcbAddr;
    BeginPosition = TotalLength;

    while (TmpKcbAddr) {
        ExitIfCtrlC() 0;
        //
        // Read the information.
        //
        if(!ReadMemory(TmpKcbAddr,
                   &TmpKcb,
                   sizeof(TmpKcb),
                   &BytesRead) ) {
            dprintf("Could not read KCB: 3\n");
            return (0);
        }
        NameBlockAddr = (ULONG_PTR) TmpKcb.NameBlock;

        if(!ReadMemory(NameBlockAddr,
               &NameBlock,
               sizeof(NameBlock),
               &BytesRead) ) {
            dprintf("Could not read NCB: 4\n");
            return (0);
        }
        if(!ReadMemory(NameBlockAddr + FIELD_OFFSET(CM_NAME_CONTROL_BLOCK, Name),
                   Name,
                   NameBlock.NameLength,
                   &BytesRead) ) {
            dprintf("Could not read Name BUFFER: 5\n");
            return (0);
        }
        //
        // Calculate the begin position of each subkey. Then fill in the char.
        //
        //
        if (NameBlock.Compressed) {
            BeginPosition -= (NameBlock.NameLength + 1) * sizeof(WCHAR);
            w1 = &(NameBuffer[BeginPosition/sizeof(WCHAR)]);
            if (w1 < BufferEnd) {
                *w1 = OBJ_NAME_PATH_SEPARATOR;
            }
            w1++;
   
            u2 = (UCHAR *) &(Name[0]);
   
            for (i=0; i<NameBlock.NameLength; i++) {
                if (w1 < BufferEnd) {
                    *w1 = (WCHAR)(*u2);
                } else {
                    break;
                }
                w1++;
                u2++;
            }
        } else {
            BeginPosition -= (NameBlock.NameLength + sizeof(WCHAR));
            w1 = &(NameBuffer[BeginPosition/sizeof(WCHAR)]);
            if (w1 < BufferEnd) {
                *w1 = OBJ_NAME_PATH_SEPARATOR;
            }
            w1++;
   
            w2 = Name;
   
            for (i=0; i<NameBlock.NameLength; i=i+sizeof(WCHAR)) {
                if (w1 < BufferEnd) {
                    *w1 = *w2;
                } else {
                    break;
                }
                w1++;
                w2++;
            }
        }
        TmpKcbAddr = (ULONG_PTR) TmpKcb.ParentKcb;
    }
    // dprintf("\n%5d, %ws\n", TotalLength, NameBuffer);
    return (TotalLength);

}

DECLARE_API( childlist )
{
    DWORD           Count;
    ULONG64         RecvAddr;
    ULONG_PTR       Addr;
    DWORD           BytesRead;
    USHORT          u;
    CM_KEY_INDEX    Index;
    USHORT          Signature;              // also type selector
    HCELL_INDEX     Cell;    
    UCHAR           NameHint[5];

    sscanf(args,"%I64lX",&RecvAddr);
    Addr = (ULONG_PTR)RecvAddr;

    if(!ReadMemory(Addr,
               &Index,
               sizeof(Index),
               &BytesRead) ) {
        dprintf("\tCould not read index\n");
        return;
    } else {
        Addr+= 2*sizeof(USHORT);

        Signature   = Index.Signature;
        Count       = Index.Count;
        if(Count > 100) {
            Count = 100;
        }

        if( Signature == CM_KEY_INDEX_ROOT ) {
            dprintf("Index is a CM_KEY_INDEX_ROOT, %u elements\n",Count);
            for( u=0;u<Count;u++) {
                if( !ReadMemory(Addr,
                           &Cell,
                           sizeof(Cell),
                           &BytesRead) ) {
                    dprintf("\tCould not read Index[%u]\n",u);
                } else {
                    dprintf(" Index[%u] = %lx\n",u,(ULONG)Cell);
                }
                Addr += sizeof(Cell);
            }
        } else if( Signature == CM_KEY_FAST_LEAF ) {
            dprintf("Index is a CM_KEY_FAST_LEAF, %u elements\n",Count);
            dprintf("Index[  ] %8s  %s\n","Cell","Hint");
            for( u=0;u<Count;u++) {
                if( !ReadMemory(Addr,
                           &Cell,
                           sizeof(Cell),
                           &BytesRead) ) {
                    dprintf("\tCould not read Index[%u]\n",u);
                } else {
                    dprintf(" Index[%2u] = %8lx",u,(ULONG)Cell);
                    Addr += sizeof(Cell);
                    if( !ReadMemory(Addr,
                               NameHint,
                               4*sizeof(UCHAR),
                               &BytesRead) ) {
                        dprintf("\tCould not read Index[%u]\n",u);
                    } else {
                        NameHint[4] = 0;
                        dprintf(" %s\n",NameHint);
                    }
                }
                Addr += 4*sizeof(UCHAR);
            }
        } else {
            dprintf("Index is a CM_KEY_INDEX_LEAF, %u elements\n",Count);
            dprintf("CM_KEY_INDEX_LEAF not yet implemented\n");
        }
    }
    return;
}


DECLARE_API( kcb )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !regkcb KCB_Address

Arguments:

    args - Supplies the address of the KCB.

Return Value:

    .

--*/

{
    WCHAR KeyName[ 256 ];
    ULONG64     RecvAddr;
    ULONG_PTR KcbAddr;
    CM_KEY_CONTROL_BLOCK Kcb;
    DWORD  BytesRead;
    CM_INDEX_HINT_BLOCK    IndexHint;

    sscanf(args,"%I64lX",&RecvAddr);
    KcbAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(KcbAddr,
               &Kcb,
               sizeof(Kcb),
               &BytesRead) ) {
        dprintf("Could not read Kcb\n");
        return;
    } else {
        if(GetKcbName(KcbAddr, KeyName, sizeof(KeyName))) {
            dprintf("Key              : %ws\n", KeyName);
        } else {
            dprintf("Could not read key name\n");
            return;
        }

        dprintf("RefCount         : %lx\n", Kcb.RefCount);
        dprintf("Attrib           :");
        if (Kcb.ExtFlags & CM_KCB_KEY_NON_EXIST) {
            dprintf(" Fake,");
        }
        if (Kcb.Delete) {
            dprintf(" Deleted,");
        }
        if (Kcb.Flags & KEY_SYM_LINK) {
            dprintf(" Symbolic,");
        }
        if (Kcb.Flags & KEY_VOLATILE) {
            dprintf(" Volatile");
        } else {
            dprintf(" Stable");
        }
        KcbAddr = (ULONG_PTR)Kcb.ParentKcb;
        dprintf("\n");
        dprintf("Parent           : 0x%p\n", KcbAddr);
        dprintf("KeyHive          : 0x%p\n", Kcb.KeyHive);
        dprintf("KeyCell          : 0x%lx [cell index]\n", Kcb.KeyCell);
        dprintf("TotalLevels      : %u\n", Kcb.TotalLevels);
        dprintf("DelayedCloseIndex: %u\n", Kcb.DelayedCloseIndex);
        dprintf("MaxNameLen       : 0x%lx\n", Kcb.KcbMaxNameLen);
        dprintf("MaxValueNameLen  : 0x%lx\n", Kcb.KcbMaxValueNameLen);
        dprintf("MaxValueDataLen  : 0x%lx\n", Kcb.KcbMaxValueDataLen);
        dprintf("LastWriteTime    : 0x%8lx:0x%8lx\n", Kcb.KcbLastWriteTime.HighPart,Kcb.KcbLastWriteTime.LowPart);
        dprintf("KeyBodyListHead  : 0x%p 0x%p\n", Kcb.KeyBodyListHead.Flink, Kcb.KeyBodyListHead.Blink);

        dprintf("SubKeyCount      : ");
        if( !(Kcb.ExtFlags & CM_KCB_INVALID_CACHED_INFO) ) {
            if (Kcb.ExtFlags & CM_KCB_NO_SUBKEY ) {
                dprintf("0");
            } else if (Kcb.ExtFlags & CM_KCB_SUBKEY_ONE ) {
                dprintf("1");
            } else if (Kcb.ExtFlags & CM_KCB_SUBKEY_HINT ) {
                if( !ReadMemory((ULONG_PTR)Kcb.IndexHint,
                           &IndexHint,
                           sizeof(IndexHint),
                           &BytesRead) ) {
                    dprintf("Could not read Kcb\n");
                    return;
                } else {
                    dprintf("%lu",IndexHint.Count);
                }
            } else {
                dprintf("%lu",Kcb.SubKeyCount);
            }
        } else {
            dprintf("hint not valid");
        }
        dprintf("\n");

    }
    return;
}

DECLARE_API( knode )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !knode KNode_Address

Arguments:

    args - Supplies the address of the CM_KEY_NODE.

Return Value:

    .

--*/

{
    char KeyName[ 256 ];
    ULONG64     RecvAddr;
    ULONG_PTR KnAddr;
    CM_KEY_NODE KNode;
    DWORD  BytesRead;

    sscanf(args,"%I64lX",&RecvAddr);
    KnAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(KnAddr,
               &KNode,
               sizeof(KNode),
               &BytesRead) ) {
        dprintf("Could not read KeyNode\n");
        return;
    } else {
        KnAddr += FIELD_OFFSET(CM_KEY_NODE, Name);
        if( KNode.Signature == CM_KEY_NODE_SIGNATURE) {
            dprintf("Signature: CM_KEY_NODE_SIGNATURE (kn)\n");
        } else if(KNode.Signature == CM_LINK_NODE_SIGNATURE) {
            dprintf("Signature: CM_LINK_NODE_SIGNATURE (kl)\n");
        } else {
            dprintf("Invalid Signature %u\n",KNode.Signature);
        }

        ReadMemory(KnAddr,
                   KeyName,
                   KNode.NameLength,
                   &BytesRead);
        KeyName[KNode.NameLength] = '\0';
        dprintf("Name                 : %s\n", KeyName);
        dprintf("ParentCell           : 0x%lx\n", KNode.Parent);
        dprintf("Security             : 0x%lx [cell index]\n", KNode.Security);
        dprintf("Class                : 0x%lx [cell index]\n", KNode.Class);
        dprintf("Flags                : 0x%lx\n", KNode.Flags);
        dprintf("MaxNameLen           : 0x%lx\n", KNode.MaxNameLen);
        dprintf("MaxClassLen          : 0x%lx\n", KNode.MaxClassLen);
        dprintf("MaxValueNameLen      : 0x%lx\n", KNode.MaxValueNameLen);
        dprintf("MaxValueDataLen      : 0x%lx\n", KNode.MaxValueDataLen);
        dprintf("LastWriteTime        : 0x%8lx:0x%8lx\n", KNode.LastWriteTime.HighPart,KNode.LastWriteTime.LowPart);

        if(!(KNode.Flags&KEY_HIVE_ENTRY)) {
            dprintf("SubKeyCount[Stable  ]: 0x%lx\n", KNode.SubKeyCounts[Stable]);
            dprintf("SubKeyLists[Stable  ]: 0x%lx\n", KNode.SubKeyLists[Stable]);
            dprintf("SubKeyCount[Volatile]: 0x%lx\n", KNode.SubKeyCounts[Volatile]);
            dprintf("SubKeyLists[Volatile]: 0x%lx\n", KNode.SubKeyLists[Volatile]);
            dprintf("ValueList.Count      : 0x%lx\n", KNode.ValueList.Count);
            dprintf("ValueList.List       : 0x%lx\n", KNode.ValueList.List);

        }
    }
    return;
}


//
//  Cell Procedures
//
ULONG_PTR
MyHvpGetCellPaged(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for hives with full maps.
    It is the normal version of the routine.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    PHCELL          pcell;
    PHMAP_ENTRY     Map;
    HMAP_TABLE      MapTable;
    HMAP_DIRECTORY     DirMap;
    ULONG Tables;
    ULONG_PTR lRez;
    DWORD  BytesRead;
    ULONG_PTR BlockAddress;
    HCELL   hcell;

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);


    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    ASSERT((Cell - (Type * HCELL_TYPE_MASK)) < Hive->Storage[Type].Length);

    //
    // read in map directory
    //
    ReadMemory((DWORD_PTR)Hive->Storage[Type].Map,
             &DirMap,
             sizeof(DirMap),
             &BytesRead);

    ReadMemory((DWORD_PTR)DirMap.Directory[Table],
                &MapTable,
                sizeof(MapTable),
                &BytesRead);

    Map = &(MapTable.Table[Block]);
    
    BlockAddress = (ULONG_PTR)Map->BlockAddress;

    pcell = (PHCELL)((ULONG_PTR)(BlockAddress) + Offset);
    lRez = (ULONG_PTR)pcell; 
    if (USE_OLD_CELL(Hive)) {
        return lRez + sizeof(LONG) + sizeof(ULONG);
        //return (struct _CELL_DATA *)&(hcell.u.OldCell.u.UserData);
    } else {
        return lRez + sizeof(LONG);
        //return (struct _CELL_DATA *)&(hcell.u.NewCell.u.UserData);
    }
}

ULONG_PTR
MyHvpGetCellFlat(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for read only hives with
    single allocation flat images.  Such hives do not have cell
    maps ("page tables"), instead, we compute addresses by
    arithmetic against the base image address.

    Such hives cannot have volatile cells.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    PUCHAR          base;
    PHCELL          pcell;
    HBASE_BLOCK     BaseBlock;
    ULONG_PTR lRez;
    DWORD  BytesRead;

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == TRUE);
    ASSERT(HvGetCellType(Cell) == Stable);
    ASSERT(Cell >= sizeof(HBIN));


    ReadMemory((DWORD_PTR)Hive->BaseBlock,
             &BaseBlock,
             sizeof(BaseBlock),
             &BytesRead);
    
    ASSERT(Cell < BaseBlock.Length);
    ASSERT((Cell & 0x7)==0);

    //
    // Address is base of Hive image + Cell
    //
    base = (PUCHAR)(Hive->BaseBlock) + HBLOCK_SIZE;
    pcell = (PHCELL)(base + Cell);
    lRez = (ULONG_PTR)pcell;
    if (USE_OLD_CELL(Hive)) {
        return lRez + sizeof(LONG) + sizeof(ULONG);
        //return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return lRez + sizeof(LONG);
        //return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
}



DECLARE_API( cellindex )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !cellindex HiveAddr HCELL_INDEX 

Arguments:

    args - Supplies the address of the HCELL_INDEX.

Return Value:

    .

--*/

{
    ULONG64     RecvAddr;
    DWORD       IdxAddr;
    ULONG_PTR   HiveAddr;
    DWORD  BytesRead;
    HCELL_INDEX cell;
    CMHIVE CmHive;
    ULONG_PTR pcell;

    sscanf(args,"%I64lX %lx",&RecvAddr,&IdxAddr);
    HiveAddr = (ULONG_PTR)RecvAddr;

    cell = IdxAddr;

    if( !ReadMemory(HiveAddr,
                &CmHive,
                sizeof(CmHive),
                &BytesRead) ) {
        dprintf("\tRead %lx bytes from %lx\n",BytesRead,HiveAddr);
        return;
    }
    
    if(CmHive.Hive.Flat) {
        pcell = MyHvpGetCellFlat(&(CmHive.Hive),cell);
    } else {
        pcell = MyHvpGetCellPaged(&(CmHive.Hive),cell);
    }

    dprintf("pcell:  %p\n",pcell);
}


DECLARE_API( kvalue )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !kvalue KValue_Address

Arguments:

    args - Supplies the address of the CM_KEY_NODE.

Return Value:

    .

--*/

{
    char ValName[ 256 ];
    ULONG64     RecvAddr;
    ULONG_PTR ValAddr;
    CM_KEY_VALUE KVal;
    DWORD  BytesRead;

    sscanf(args,"%I64lX",&RecvAddr);
    ValAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(ValAddr,
               &KVal,
               sizeof(KVal),
               &BytesRead) ) {
        dprintf("Could not read KeyValue\n");
        return;
    } else {
        ValAddr += FIELD_OFFSET(CM_KEY_VALUE, Name);
        if( KVal.Signature == CM_KEY_VALUE_SIGNATURE) {
            dprintf("Signature: CM_KEY_VALUE_SIGNATURE (kv)\n");
        } else {
            dprintf("Invalid Signature %lx\n",KVal.Signature);
        }

        if(KVal.Flags & VALUE_COMP_NAME) {
            ReadMemory(ValAddr,
                       ValName,
                       KVal.NameLength,
                       &BytesRead);
            ValName[KVal.NameLength] = '\0';
            dprintf("Name      : %s {compressed}\n", ValName);
        }

        dprintf("DataLength: %lx\n", KVal.DataLength);
        dprintf("Data      : %lx  [cell index]\n", KVal.Data);
        dprintf("Type      : %lx\n", KVal.Type);
    }
    return;
}

DECLARE_API( kbody )
/*++

Routine Description:

    displays a CM_KEY_BODY

    Called as:

        !kbody KBody_Address

Arguments:

    args - Supplies the address of the CM_KEY_BODY.
    
Return Value:

    .

--*/

{
    ULONG64     RecvAddr;
    ULONG_PTR KBodyAddr;
    CM_KEY_BODY KBody;
    DWORD  BytesRead;

    sscanf(args,"%I64lX",&RecvAddr);
    KBodyAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(KBodyAddr,
               &KBody,
               sizeof(KBody),
               &BytesRead) ) {
        dprintf("Could not read KeyBody\n");
        return;
    } else {
        if( KBody.Type == KEY_BODY_TYPE) {
            dprintf("Type        : KEY_BODY_TYPE\n");
        } else {
            dprintf("Invalid Type %lx\n",KBody.Type);
        }

        dprintf("KCB         : %p\n", KBody.KeyControlBlock);
        dprintf("NotifyBlock : %p\n", KBody.NotifyBlock);
        dprintf("Process     : %p\n", KBody.Process);
        dprintf("KeyBodyList : %p %p\n", KBody.KeyBodyList.Flink, KBody.KeyBodyList.Blink);
    }
    return;
}

DECLARE_API( hashindex )
/*++

Routine Description:

    display the index for the convkey

    Called as:

        !hashindex conv_key

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG ConvKey;
    ULONG CmpHashTableSize = 2048;
    ULONG_PTR Address;
    ULONG_PTR CmpCacheTable,CmpNameCacheTable;
    DWORD  BytesRead;

    sscanf(args,"%lx",&ConvKey);

    dprintf("Hash Index[%8lx] : %lx\n",ConvKey,GET_HASH_INDEX(ConvKey));

    Address = GetExpression("CmpCacheTable");
    
    if( !ReadMemory(Address,
               &CmpCacheTable,
               sizeof(CmpCacheTable),
               &BytesRead) ) {
        dprintf("Could not read CmpCacheTable\n");
    } else {
        dprintf("CmpCacheTable        : %p\n",CmpCacheTable);
    }

    Address = GetExpression("CmpNameCacheTable");
    
    if( !ReadMemory(Address,
               &CmpNameCacheTable,
               sizeof(CmpNameCacheTable),
               &BytesRead) ) {
        dprintf("Could not read CmpNameCacheTable\n");
    } else {
        dprintf("CmpNameCacheTable    : %p\n",CmpNameCacheTable);
    }

    return;
}

DECLARE_API( openkeys )
/*++

Routine Description:

    dumps open subkeys for the specified hive

    Called as:

        !openkeys hive

    if hive is 0, dump all KCBs

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG CmpHashTableSize = 2048;
    ULONG_PTR Address;
    ULONG_PTR CmpCacheTable,CmpNameCacheTable;
    DWORD  BytesRead;
    ULONG64     RecvAddr;
    ULONG_PTR HiveAddr;
    ULONG i;
    ULONG_PTR Current;
    ULONG KcbNumber = 0;
    ULONG Offset = FIELD_OFFSET(CM_KEY_CONTROL_BLOCK, KeyHash);
    CM_KEY_HASH KeyHash;
    WCHAR KeyName[ 512 ];

    sscanf(args,"%I64lX",&RecvAddr);
    HiveAddr = (ULONG_PTR)RecvAddr;

    Address = GetExpression("CmpCacheTable");
    
    if( !ReadMemory(Address,
               &CmpCacheTable,
               sizeof(CmpCacheTable),
               &BytesRead) ) {
        dprintf("\nCould not read CmpCacheTable\n");
    } else {
        dprintf("\nCmpCacheTable        : %p\n",CmpCacheTable);
    }

    Address = GetExpression("CmpNameCacheTable");
    
    if( !ReadMemory(Address,
               &CmpNameCacheTable,
               sizeof(CmpNameCacheTable),
               &BytesRead) ) {
        dprintf("Could not read CmpNameCacheTable\n\n");
    } else {
        dprintf("CmpNameCacheTable    : %p\n\n",CmpNameCacheTable);
    }

    dprintf("List of open KCBs:\n\n");
    for (i=0; i<CmpHashTableSize; i++) {
        Address = CmpCacheTable + i* sizeof(PCM_KEY_HASH);

        ReadMemory(Address,
               &Current,
               sizeof(Current),
               &BytesRead);
        
        while (Current) {
            ExitIfCtrlC();
            ReadMemory(Current,
                       &KeyHash,
                       sizeof(KeyHash),
                       &BytesRead);

            if( (HiveAddr == 0) || (HiveAddr == (ULONG_PTR)KeyHash.KeyHive) ) {
                KcbNumber++;
                dprintf("%p",Current-Offset);
                if (BytesRead < sizeof(KeyHash)) {
                    dprintf("Could not read KeyHash at %p\n",Current);
                    break;
                } else {
                    if(GetKcbName(Current-Offset, KeyName, sizeof(KeyName))) {
                        dprintf(" : %ws\n", KeyName);
                    } else {
                        dprintf("Could not read key name\n");
                    }
                }
            }   
            Current = (ULONG_PTR)KeyHash.NextHash;
        }
    
    }
    dprintf("\nTotal of %lu KCBs opened\n",KcbNumber);
    return;
}

DECLARE_API( baseblock )
/*++

Routine Description:

    displays the base block structure

    Called as:

        !baseblock address

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    HBASE_BLOCK BaseBlock;
    ULONG_PTR BaseAddr;
    DWORD  BytesRead;
    PWCHAR  FileName;
    ULONG64     RecvAddr;

    sscanf(args,"%I64lX",&RecvAddr);
    BaseAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(BaseAddr,
                &BaseBlock,
                sizeof(BaseBlock),
                &BytesRead) ) {
        dprintf("\tRead %lx bytes from %p\n",BytesRead,BaseAddr);
        return;
    }
    
    if( BaseBlock.Signature == HBASE_BLOCK_SIGNATURE ) {
        dprintf("Signature:  HBASE_BLOCK_SIGNATURE\n");
    } else {
        dprintf("Signature:  %lx\n",BaseBlock.Signature);
    }

    FileName = (PWCHAR)&(BaseBlock.FileName);
    FileName[HBASE_NAME_ALLOC/sizeof(WCHAR)] = 0;
    dprintf("FileName :  %ws\n",FileName);
    dprintf("Sequence1:  %lx\n",BaseBlock.Sequence1);
    dprintf("Sequence2:  %lx\n",BaseBlock.Sequence2);
    dprintf("TimeStamp:  %lx %lx\n",BaseBlock.TimeStamp.HighPart,BaseBlock.TimeStamp.LowPart);
    dprintf("Major    :  %lx\n",BaseBlock.Major);
    dprintf("Minor    :  %lx\n",BaseBlock.Minor);
    switch(BaseBlock.Type) {
    case HFILE_TYPE_PRIMARY:
        dprintf("Type     :  HFILE_TYPE_PRIMARY\n");
        break;
    case HFILE_TYPE_LOG:
        dprintf("Type     :  HFILE_TYPE_LOG\n");
        break;
    case HFILE_TYPE_EXTERNAL:
        dprintf("Type     :  HFILE_TYPE_EXTERNAL\n");
        break;
    default:
        dprintf("Type     :  %lx\n",BaseBlock.Type);
        break;

    }
    if( BaseBlock.Format == HBASE_FORMAT_MEMORY ) {
        dprintf("Format   :  HBASE_FORMAT_MEMORY\n");
    } else {
        dprintf("Format   :  %lx\n",BaseBlock.Format);
    }
    dprintf("RootCell :  %lx\n",BaseBlock.RootCell);
    dprintf("Length   :  %lx\n",BaseBlock.Length);
    dprintf("Cluster  :  %lx\n",BaseBlock.Cluster);
    dprintf("CheckSum :  %lx\n",BaseBlock.CheckSum);
}

DECLARE_API( findkcb )
/*++

Routine Description:

    finds a kcb given the full path

    Called as:

        !findkcb \REGISTRY\MACHINE\foo

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG CmpHashTableSize = 2048;
    ULONG_PTR Address;
    ULONG_PTR CmpCacheTable,CmpNameCacheTable;
    DWORD  BytesRead;
    ULONG i,j,Count;
    ULONG_PTR Current;
    ULONG Offset = FIELD_OFFSET(CM_KEY_CONTROL_BLOCK, KeyHash);
    CM_KEY_HASH KeyHash;
    WCHAR KeyName[ 512 ];
    UCHAR AnsiFullKeyName[ 512 ];
    WCHAR FullKeyName[ 512 ];
    PWCHAR Dest;
    ULONG ConvKey = 0;

    sscanf(args,"%s",AnsiFullKeyName);

    for( Count=0;AnsiFullKeyName[Count];Count++) {
        FullKeyName[Count] = (WCHAR)AnsiFullKeyName[Count];
        if( FullKeyName[Count] != OBJ_NAME_PATH_SEPARATOR ) {
            ConvKey = 37 * ConvKey + (ULONG) RtlUpcaseUnicodeChar(FullKeyName[Count]);
        }
    }

    FullKeyName[Count] = UNICODE_NULL;

    //dprintf("\nFullKeyName        :%ws %\n",FullKeyName);

    Address = GetExpression("CmpCacheTable");
    
    if( !ReadMemory(Address,
               &CmpCacheTable,
               sizeof(CmpCacheTable),
               &BytesRead) ) {
        dprintf("\nCould not read CmpCacheTable\n");
        return;
    } 

    Address = GetExpression("CmpNameCacheTable");
    
    if( !ReadMemory(Address,
               &CmpNameCacheTable,
               sizeof(CmpNameCacheTable),
               &BytesRead) ) {

        dprintf("Could not read CmpNameCacheTable\n\n");
        return;
    } 

    i = GET_HASH_INDEX(ConvKey);
    //for (i=0; i<CmpHashTableSize; i++) {
        Address = CmpCacheTable + i* sizeof(PCM_KEY_HASH);

        ReadMemory(Address,
               &Current,
               sizeof(Current),
               &BytesRead);
        
        while (Current) {
            ExitIfCtrlC();
            if( !ReadMemory(Current,
                       &KeyHash,
                       sizeof(KeyHash),
                       &BytesRead) ) {

                dprintf("Could not read KeyHash at %lx\n",Current);
                break;
            } else {
                if(GetKcbName(Current-Offset, KeyName, sizeof(KeyName))) {
                    for(j=0;KeyName[j] != UNICODE_NULL;j++);
                    if( (j == Count) && (_wcsnicmp(FullKeyName,KeyName,Count) == 0) ) {
                        dprintf("\nFound KCB = %lx :: %ws\n\n",Current-Offset,KeyName);
                        return;
                    }

                    dprintf("Along the path - KCB = %lx :: %ws\n",Current-Offset,KeyName);

                } else {
                    continue;
                }
            }

            Current = (ULONG_PTR)KeyHash.NextHash;
        }
    
    //}

    dprintf("\nSorry %ws is not cached \n\n",FullKeyName);
    return;
}


DECLARE_API( seccache )
/*++

Routine Description:

    displays the base block structure

    Called as:

        !seccache <HiveAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    CMHIVE CmHive;
    ULONG64     RecvAddr;
    ULONG_PTR HiveAddr;
    DWORD  BytesRead;
    PWCHAR  FileName;
    CM_KEY_SECURITY_CACHE_ENTRY    SecurityCacheEntry;
    ULONG i;
    ULONG Tmp;

    sscanf(args,"%I64lX",&RecvAddr);
    HiveAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(HiveAddr,
                &CmHive,
                sizeof(CmHive),
                &BytesRead) ) {
        dprintf("\tRead %lx bytes from %p\n",BytesRead,HiveAddr);
        return;
    }
    
    if( CmHive.Hive.Signature != HHIVE_SIGNATURE ) {
        dprintf("Invalid Hive signature:  %lx\n",CmHive.Hive.Signature);
        return;
    }

    Tmp = CmHive.SecurityCacheSize;
    dprintf("SecurityCacheSize = :  0x%lx\n",Tmp);
    Tmp = CmHive.SecurityCount;
    dprintf("SecurityCount     = :  0x%lx\n",Tmp);
    Tmp = CmHive.SecurityHitHint;
    dprintf("SecurityHitHint   = :  0x%lx\n",Tmp);
    HiveAddr = (ULONG_PTR)CmHive.SecurityCache;
    dprintf("SecurityCache     = :  0x%p\n\n",HiveAddr);
    dprintf("[Entry No.]  [Security Cell] [Security Cache]\n",CmHive.SecurityHitHint);

    for( i=0;i<CmHive.SecurityCount;i++) {
        ExitIfCtrlC();
        if( !ReadMemory(HiveAddr,
                    &SecurityCacheEntry,
                    sizeof(SecurityCacheEntry),
                    &BytesRead) ) {
            dprintf("\tCould not read entry %lu \n",i);
            continue;
        }
        dprintf("%[%8lu]    0x%8lx       0x%p\n",i,SecurityCacheEntry.Cell,SecurityCacheEntry.CachedSecurity);
        HiveAddr += sizeof(SecurityCacheEntry);
    }

}


DECLARE_API( viewlist )
/*++

Routine Description:

    dumps all the views mapped/pinned for the specified hive

    Called as:

        !viewlist <HiveAddr>

Arguments:

    args - hive.
    
Return Value:

    .

--*/

{
    CMHIVE  CmHive;
    CM_VIEW_OF_FILE CmView;
    ULONG_PTR   HiveAddr;
    DWORD   BytesRead;
    USHORT  Nr;
    ULONG   Offset;
    ULONG_PTR   ViewAddr;
    ULONG_PTR   Tmp;
    ULONG64     RecvAddr;

    sscanf(args,"%I64lX",&RecvAddr);
    HiveAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(HiveAddr,
                &CmHive,
                sizeof(CmHive),
                &BytesRead) ) {
        dprintf("\tRead %lx bytes from %p\n",BytesRead,HiveAddr);
        return;
    }
    
    if( CmHive.Hive.Signature != HHIVE_SIGNATURE ) {
        dprintf("Invalid Hive signature:  %lx\n",CmHive.Hive.Signature);
        return;
    }


    Nr = CmHive.PinnedViews;
    dprintf("%4u  Pinned Views ; PinViewListHead = %p %p\n",Nr,(ULONG_PTR)CmHive.PinViewListHead.Flink,(ULONG_PTR)CmHive.PinViewListHead.Blink);
    if( Nr ) {
        dprintf("--------------------------------------------------------------------------------------------------------------\n");
        dprintf("| ViewAddr |FileOffset|   Size   |ViewAddress|   Bcb    |    LRUViewList     |    PinViewList     | UseCount |\n");
        dprintf("--------------------------------------------------------------------------------------------------------------\n");
        ViewAddr = (ULONG_PTR)CmHive.PinViewListHead.Flink;
        Offset = FIELD_OFFSET(CM_VIEW_OF_FILE, PinViewList);
        for(;Nr;Nr--) {
            ViewAddr -= Offset;
            if( !ReadMemory(ViewAddr,
                        &CmView,
                        sizeof(CmView),
                        &BytesRead) ) {
                dprintf("error reading view at %lx\n",ViewAddr);
                break;
            }
            Tmp = ViewAddr;
            dprintf("| %p ",Tmp);
            dprintf("| %8lx ",CmView.FileOffset);
            dprintf("| %8lx ",CmView.Size);
            Tmp = (ULONG_PTR)CmView.ViewAddress;
            dprintf("| %p  ",Tmp);
            Tmp = (ULONG_PTR)CmView.Bcb;
            dprintf("| %p ",Tmp);
            Tmp = (ULONG_PTR)CmView.LRUViewList.Flink;
            dprintf("| %p",Tmp);
            Tmp = (ULONG_PTR)CmView.LRUViewList.Blink;
            dprintf("  %p ",Tmp);
            Tmp = (ULONG_PTR)CmView.PinViewList.Flink;
            dprintf("| %p",Tmp);
            Tmp = (ULONG_PTR)CmView.PinViewList.Blink;
            dprintf("  %p |",Tmp);
            dprintf(" %8lx |\n",CmView.UseCount);
            ViewAddr = (ULONG_PTR)CmView.PinViewList.Flink;
        }
        dprintf("--------------------------------------------------------------------------------------------------------------\n");
    }

    dprintf("\n");

    Nr = CmHive.MappedViews;
    dprintf("%4u  Mapped Views ; LRUViewListHead = %p %p\n",Nr,(ULONG_PTR)CmHive.LRUViewListHead.Flink,(ULONG_PTR)CmHive.LRUViewListHead.Blink);
    if( Nr ) {
        dprintf("--------------------------------------------------------------------------------------------------------------\n");
        dprintf("| ViewAddr |FileOffset|   Size   |ViewAddress|   Bcb    |    LRUViewList     |    PinViewList     | UseCount |\n");
        dprintf("--------------------------------------------------------------------------------------------------------------\n");
        ViewAddr = (ULONG_PTR)CmHive.LRUViewListHead.Flink;
        Offset = FIELD_OFFSET(CM_VIEW_OF_FILE, LRUViewList);
        for(;Nr;Nr--) {
            ViewAddr -= Offset;
            if( !ReadMemory(ViewAddr,
                        &CmView,
                        sizeof(CmView),
                        &BytesRead) ) {
                dprintf("error reading view at %lx\n",ViewAddr);
                break;
            }
            Tmp = ViewAddr;
            dprintf("| %p ",Tmp);
            dprintf("| %8lx ",CmView.FileOffset);
            dprintf("| %8lx ",CmView.Size);
            Tmp = (ULONG_PTR)CmView.ViewAddress;
            dprintf("| %p  ",Tmp);
            Tmp = (ULONG_PTR)CmView.Bcb;
            dprintf("| %p ",Tmp);
            Tmp = (ULONG_PTR)CmView.LRUViewList.Flink;
            dprintf("| %p",Tmp);
            Tmp = (ULONG_PTR)CmView.LRUViewList.Blink;
            dprintf("  %p ",Tmp);
            Tmp = (ULONG_PTR)CmView.PinViewList.Flink;
            dprintf("| %p",Tmp);
            Tmp = (ULONG_PTR)CmView.PinViewList.Blink;
            dprintf("  %8lx |",Tmp);
            dprintf(" %8lx |\n",CmView.UseCount);
            ViewAddr = (ULONG_PTR)CmView.LRUViewList.Flink;
        }
        dprintf("--------------------------------------------------------------------------------------------------------------\n");
    }
 
    dprintf("\n");

}

DECLARE_API( hivelist )
/*++

Routine Description:

    dumps all the hives in the system

    Called as:

        !hivelist 

Arguments:

Return Value:

    .

--*/

{
    CMHIVE      CmHive;
    ULONG_PTR       HiveAddr;
    ULONG_PTR       AnchorAddr;
    DWORD       BytesRead;
    ULONG       Offset;
    ULONG_PTR       Tmp;
    LIST_ENTRY  CmpHiveListHead;
    HBASE_BLOCK     BaseBlock;
    PWCHAR  FileName;

    AnchorAddr = GetExpression("CmpHiveListHead");
    
    if( !ReadMemory(AnchorAddr,
               &CmpHiveListHead,
               sizeof(CmpHiveListHead),
               &BytesRead)) {
        dprintf("\ncannot read CmpHiveListHead\n");
        return;
    } 

    Offset = FIELD_OFFSET(CMHIVE, HiveList);
    HiveAddr = (ULONG_PTR)CmpHiveListHead.Flink;

    dprintf("-------------------------------------------------------------------------------------------------------------\n");
    dprintf("| HiveAddr |Stable Length|Stable Map|Volatile Length|Volatile Map|MappedViews|PinnedViews|U(Cnt)| BaseBlock | FileName \n");
    dprintf("-------------------------------------------------------------------------------------------------------------\n");
    while( HiveAddr != AnchorAddr ) {
        ExitIfCtrlC();
        HiveAddr -= Offset;
        if( !ReadMemory(HiveAddr,
                    &CmHive,
                    sizeof(CmHive),
                    &BytesRead) ) {
            dprintf("cannot read hive at %lx\n",HiveAddr);
            return;
        }
    
        if( CmHive.Hive.Signature != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",CmHive.Hive.Signature);
            return;
        }

        Tmp = HiveAddr;
        dprintf("| %p ",Tmp);
        dprintf("|   %8lx  ",CmHive.Hive.Storage[0].Length);
        Tmp = (ULONG_PTR)CmHive.Hive.Storage[0].Map;
        dprintf("| %p ",Tmp);
        dprintf("|   %8lx    ",CmHive.Hive.Storage[1].Length);
        Tmp = (ULONG_PTR)CmHive.Hive.Storage[1].Map;
        dprintf("|  %p  ",Tmp);

        dprintf("| %8u  ",CmHive.MappedViews);
        dprintf("| %8u  ",CmHive.PinnedViews);
        dprintf("| %5u",CmHive.UseCount);

        Tmp = (ULONG_PTR)CmHive.Hive.BaseBlock;
        dprintf("| %p  |",Tmp);

        if( !ReadMemory(Tmp,
                 &BaseBlock,
                 sizeof(BaseBlock),
                 &BytesRead) ) {
            dprintf("  could not read baseblock\n");
        } else {
            FileName = (PWCHAR)&(BaseBlock.FileName);
            FileName[HBASE_NAME_ALLOC/sizeof(WCHAR)] = 0;
            dprintf(" %ws\n",FileName);
        }

        HiveAddr = (ULONG_PTR)CmHive.HiveList.Flink;
    }
    dprintf("-------------------------------------------------------------------------------------------------------------\n");
 
    dprintf("\n");

}

DECLARE_API( freebins )
/*++

Routine Description:

    dumps all the free bins for the specified hive

    Called as:

        !freebins <HiveAddr>

Arguments:

    args - hive.
    
Return Value:

    .

--*/

{
    HHIVE       Hive;
    ULONG_PTR       HiveAddr;
    DWORD       BytesRead;
    ULONG       Offset;
    ULONG_PTR       BinAddr;
    ULONG_PTR       AnchorAddr;
    ULONG_PTR       Tmp;
    USHORT      Nr = 0;
    FREE_HBIN   FreeBin;
    ULONG64     RecvAddr;

    sscanf(args,"%I64lX",&RecvAddr);
    HiveAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(HiveAddr,
                &Hive,
                sizeof(Hive),
                &BytesRead) ) {
        dprintf("\tRead %lx bytes from %p\n",BytesRead,HiveAddr);
        return;
    }
    
    if( Hive.Signature != HHIVE_SIGNATURE ) {
        dprintf("Invalid Hive signature:  %lx\n",Hive.Signature);
        return;
    }


    Offset = FIELD_OFFSET(FREE_HBIN, ListEntry);


    
    dprintf("Stable Storage ... \n");

    dprintf("-------------------------------------------------------------------\n");
    dprintf("| Address  |FileOffset|   Size   |   Flags  |   Flink  |   Blink  |\n");
    dprintf("-------------------------------------------------------------------\n");
    Nr = 0;
    AnchorAddr = HiveAddr + FIELD_OFFSET(HHIVE,Storage) + 5*sizeof(ULONG) + HHIVE_FREE_DISPLAY_SIZE*sizeof(RTL_BITMAP);
    BinAddr = (ULONG_PTR)Hive.Storage[0].FreeBins.Flink; 
    while(BinAddr != AnchorAddr ) {
        ExitIfCtrlC();
        BinAddr -= Offset;
        if( !ReadMemory(BinAddr,
                    &FreeBin,
                    sizeof(FreeBin),
                    &BytesRead)) {
            dprintf("error reading FreeBin at %lx\n",BinAddr);
            break;
        }
        Tmp = BinAddr;
        dprintf("| %p ",Tmp);
        dprintf("| %8lx ",FreeBin.FileOffset);
        dprintf("| %8lx ",FreeBin.Size);
        dprintf("| %8lx ",FreeBin.Flags);
        Tmp = (ULONG_PTR)FreeBin.ListEntry.Flink;
        dprintf("| %p ",Tmp);
        Tmp = (ULONG_PTR)FreeBin.ListEntry.Blink;
        dprintf("| %p |\n",Tmp);
        BinAddr = (ULONG_PTR)FreeBin.ListEntry.Flink;
        Nr++;
    }
    dprintf("-------------------------------------------------------------------\n");

    dprintf("%4u  FreeBins\n",Nr);

    dprintf("\n");

    dprintf("Volatile Storage ... \n");

    dprintf("-------------------------------------------------------------------\n");
    dprintf("| Address  |FileOffset|   Size   |   Flags  |   Flink  |   Blink  |\n");
    dprintf("-------------------------------------------------------------------\n");
    Nr = 0;
    AnchorAddr += (7*sizeof(ULONG) + HHIVE_FREE_DISPLAY_SIZE*sizeof(RTL_BITMAP));
    BinAddr = (ULONG_PTR)Hive.Storage[1].FreeBins.Flink;
    while(BinAddr != AnchorAddr ) {
        ExitIfCtrlC();
        BinAddr -= Offset;
        if( !ReadMemory(BinAddr,
                    &FreeBin,
                    sizeof(FreeBin),
                    &BytesRead) ) {
            dprintf("error reading FreeBin at %lx\n",BinAddr);
            break;
        }
        Tmp = BinAddr;
        dprintf("| %p ",Tmp);
        dprintf("| %8lx ",FreeBin.FileOffset);
        dprintf("| %8lx ",FreeBin.Size);
        dprintf("| %8lx ",FreeBin.Flags);
        Tmp = (ULONG_PTR)FreeBin.ListEntry.Flink;
        dprintf("| %p ",Tmp);
        Tmp = (ULONG_PTR)FreeBin.ListEntry.Blink;
        dprintf("| %p |\n",Tmp);
        BinAddr = (ULONG_PTR)FreeBin.ListEntry.Flink;
        Nr++;
    }
    dprintf("-------------------------------------------------------------------\n");

    dprintf("%4u  FreeBins\n",Nr);

    dprintf("\n");
}

DECLARE_API( dirtyvector )
/*++

Routine Description:

    displays the dirty vector of the hive

    Called as:

        !dirtyvector <HiveAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    HHIVE Hive;
    ULONG_PTR HiveAddr;
    DWORD  BytesRead;
    ULONG i;
    ULONG_PTR Tmp;
    ULONG SizeOfBitmap;
    ULONG DirtyBuffer;
    ULONG_PTR DirtyBufferAddr;
    ULONG Mask;
    ULONG BitsPerULONG;
    ULONG BitsPerBlock;
    ULONG64     RecvAddr;

    sscanf(args,"%I64lX",&RecvAddr);
    HiveAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(HiveAddr,
                &Hive,
                sizeof(Hive),
                &BytesRead)) {
        dprintf("\tRead %lx bytes from %lx\n",BytesRead,HiveAddr);
        return;
    }
    
    if( Hive.Signature != HHIVE_SIGNATURE ) {
        dprintf("Invalid Hive signature:  %lx\n",Hive.Signature);
        return;
    }

    dprintf("HSECTOR_SIZE = %lx\n",HSECTOR_SIZE);
    dprintf("HBLOCK_SIZE  = %lx\n",HBLOCK_SIZE);
    dprintf("PAGE_SIZE    = %lx\n",PAGE_SIZE);
    dprintf("\n");

    dprintf("DirtyAlloc      = :  0x%lx\n",Hive.DirtyAlloc);
    dprintf("DirtyCount      = :  0x%lx\n",Hive.DirtyCount);
    Tmp = (ULONG_PTR)Hive.DirtyVector.Buffer;
    dprintf("Buffer          = :  0x%p\n",Tmp);
    dprintf("\n");

    SizeOfBitmap = Hive.DirtyVector.SizeOfBitMap;
    DirtyBufferAddr = (ULONG_PTR)Hive.DirtyVector.Buffer;
    BitsPerULONG = 8*sizeof(ULONG);
    BitsPerBlock = HBLOCK_SIZE / HSECTOR_SIZE;

    dprintf("   Address                       32k                                       32k");
    for(i=0;i<SizeOfBitmap;i++) {
        ExitIfCtrlC();
        if( !(i%(2*BitsPerULONG ) ) ){
            dprintf("\n 0x%8lx  ",i*HSECTOR_SIZE);
        }

        if( !(i%BitsPerBlock) ) {
            dprintf(" ");
        }
        if( !(i%BitsPerULONG) ) {
            //
            // fetch in a new DWORD
            //
            if( !ReadMemory(DirtyBufferAddr,
                        &DirtyBuffer,
                        sizeof(DirtyBuffer),
                        &BytesRead)) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,DirtyBufferAddr);
                return;
            }
            DirtyBufferAddr += sizeof(ULONG);
            dprintf("\t");
        }

        Mask = ((DirtyBuffer >> (i%BitsPerULONG)) & 0x1);
        //Mask <<= (BitsPerULONG - (i%BitsPerULONG) - 1);
        //Mask &= DirtyBuffer;
        dprintf("%s",Mask?"1":"0");
    }
    dprintf("\n\n");
    
}

CCHAR CmKDFindFirstSetLeft[256] = {
        0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};

#define CmKDComputeIndex(Index, Size)                                   \
    {                                                                   \
        Index = (Size >> HHIVE_FREE_DISPLAY_SHIFT) - 1;                 \
        if (Index >= HHIVE_LINEAR_INDEX ) {                             \
                                                                        \
            /*                                                          \
            ** Too big for the linear lists, compute the exponential    \
            ** list.                                                    \
            */                                                          \
                                                                        \
            if (Index > 255) {                                          \
                /*                                                      \
                ** Too big for all the lists, use the last index.       \
                */                                                      \
                Index = HHIVE_FREE_DISPLAY_SIZE-1;                      \
            } else {                                                    \
                Index = CmKDFindFirstSetLeft[Index] +                   \
                        HHIVE_FREE_DISPLAY_BIAS;                        \
            }                                                           \
        }                                                               \
    }


DECLARE_API( freecells )
/*++

Routine Description:

    displays the free cells map in a bin

    Called as:

        !freecells <BinAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG_PTR   BinAddr;
    ULONG   Offset;
    ULONG_PTR   CurrentAddr;
    LONG    Current;
    HBIN    Bin; 
    ULONG   Index;
    ULONG   CurrIndex;
    DWORD   BytesRead;
    ULONG   NrOfCellsPerIndex;
    ULONG   NrOfCellsTotal;
    ULONG   TotalFreeSize;
    ULONG64     RecvAddr;

    sscanf(args,"%I64lX",&RecvAddr);
    BinAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(BinAddr,
                &Bin,
                sizeof(Bin),
                &BytesRead)) {
        dprintf("\tRead %lx bytes from %lx\n",BytesRead,BinAddr);
        return;
    }

    if( Bin.Signature != HBIN_SIGNATURE ) {
        dprintf("\tInvalid Bin signature %lx \n",Bin.Signature);
        return;
    }

    dprintf("Bin Offset = 0x%lx  Size = 0x%lx\n",Bin.FileOffset,Bin.Size);
    
    NrOfCellsTotal = 0;
    TotalFreeSize = 0;

    for(CurrIndex = 0;CurrIndex<HHIVE_FREE_DISPLAY_SIZE;CurrIndex++) {
        dprintf("\n FreeDisplay[%2lu] :: ",CurrIndex);

        NrOfCellsPerIndex = 0;
        Offset = sizeof(Bin);
        while( Offset < Bin.Size ) {
            ExitIfCtrlC();
            CurrentAddr = BinAddr + Offset;
            if( !ReadMemory(CurrentAddr,
                        &Current,
                        sizeof(Current),
                        &BytesRead) ) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,CurrentAddr);
                return;
            }
        
            if(Current>0) {
                //
                // free cell
                //
                CmKDComputeIndex(Index, Current);
                if( Index == CurrIndex ) {
                    //
                    // dum it here as this is the right index
                    //
                    NrOfCellsTotal++;
                    NrOfCellsPerIndex++;
                    TotalFreeSize += Current;
                    dprintf("    %lx [%lx]",Offset,Current);
                    if( !(NrOfCellsPerIndex % 8) && ((Offset + Current) < Bin.Size) ) {
                        dprintf("\n");
                    }
                }
            } else {
                Current *= -1;
            }
            Offset += Current;
        }
    }    

    dprintf("\nTotal: FreeCells = %lu, FreeSpace = 0x%lx BinUsage = %.2f%%\n",NrOfCellsTotal,TotalFreeSize,
                (float)(((float)(Bin.Size-sizeof(Bin)-TotalFreeSize)/(float)(Bin.Size-sizeof(Bin)))*100.00)
             );
}

DECLARE_API( freehints )
/*++

Routine Description:

    displays the freehints information for the hive

    Called as:

        !freehints <HiveAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    HHIVE   Hive;
    ULONG_PTR   HiveAddr;
    DWORD   BytesRead;
    ULONG   i;
    ULONG   DisplayCount;
    ULONG   StorageCount;
    ULONG   SizeOfBitmap;
    ULONG   DirtyBuffer;
    ULONG_PTR  DirtyBufferAddr;
    ULONG   Mask;
    ULONG   BitsPerULONG;
    ULONG   BitsPerBlock;
    ULONG   BitsPerLine;
    ULONG64     RecvAddr;

    sscanf(args,"%I64lX %lu %lu",&RecvAddr,&StorageCount,&DisplayCount);
    HiveAddr = (ULONG_PTR)RecvAddr;

    if( !ReadMemory(HiveAddr,
                &Hive,
                sizeof(Hive),
                &BytesRead) ) {
        dprintf("\tRead %lx bytes from %lx\n",BytesRead,HiveAddr);
        return;
    }
    
    if( Hive.Signature != HHIVE_SIGNATURE ) {
        dprintf("Invalid Hive signature:  %lx\n",Hive.Signature);
        return;
    }

    dprintf("HSECTOR_SIZE = %lx\n",HSECTOR_SIZE);
    dprintf("HBLOCK_SIZE  = %lx\n",HBLOCK_SIZE);
    dprintf("PAGE_SIZE    = %lx\n",PAGE_SIZE);
    dprintf("\n");

    BitsPerULONG = 8*sizeof(ULONG);
    BitsPerBlock = 0x10000 / HBLOCK_SIZE; // 64k blocks
    BitsPerLine  = 0x40000 / HBLOCK_SIZE; // 256k lines (vicinity reasons)

    SizeOfBitmap = Hive.Storage[StorageCount].Length / HBLOCK_SIZE;
    
    DirtyBufferAddr = (ULONG_PTR)Hive.Storage[StorageCount].FreeDisplay[DisplayCount].Buffer;

    dprintf("Storage = %s , FreeDisplay[%lu]: \n",StorageCount?"Volatile":"Stable",DisplayCount);
    
    dprintf("\n%8s    %16s %16s %16s %16s","Address","64K (0x10000)","64K (0x10000)","64K (0x10000)","64K (0x10000)");

    for(i=0;i<SizeOfBitmap;i++) {
        ExitIfCtrlC();
        if( !(i%BitsPerLine) ){
            dprintf("\n 0x%8lx  ",i*HBLOCK_SIZE);
        }

        if( !(i%BitsPerBlock) ) {
            dprintf(" ");
        }
        if( !(i%BitsPerULONG) ) {
            //
            // fetch in a new DWORD
            //
            if( !ReadMemory(DirtyBufferAddr,
                        &DirtyBuffer,
                        sizeof(DirtyBuffer),
                        &BytesRead) ) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,DirtyBufferAddr);
                return;
            }
            DirtyBufferAddr += sizeof(ULONG);
        }

        Mask = ((DirtyBuffer >> (i%BitsPerULONG)) & 0x1);
        //Mask <<= (BitsPerULONG - (i%BitsPerULONG) - 1);
        //Mask &= DirtyBuffer;
        dprintf("%s",Mask?"1":"0");
    }

    dprintf("\n\n");
}

DECLARE_API( help )
/*++

Routine Description:

    Called as:

        !help

Arguments:

    
Return Value:

    .

--*/

{
    dprintf("\nkcb\t\t<kcb_address>\n"); //OK, moved to kdexts
    dprintf("knode\t\t<knode_address>\n");//OK, moved to kdexts
    dprintf("kbody\t\t<kbody_address>\n");//OK, moved to kdexts
    dprintf("kvalue\t\t<kvalue_address>\n");//OK, moved to kdexts
    dprintf("cellindex\t<HiveAddr> <HCELL_INDEX>\n"); //OK, moved to kdexts
    dprintf("childlist\t<address>\n");// not worth moving, never used it
    dprintf("hashindex\t<ConvKey>\n");//OK, moved to kdexts
    dprintf("openkeys\t<HiveAddr|0>\n");//OK, moved to kdexts
    dprintf("baseblock\t<BaseBlockAddr>\n");//OK, moved to kdexts
    dprintf("findkcb\t\t<FullKeyPath>\n");//OK, moved to kdexts
    dprintf("seccache\t<HiveAddr>\n");//OK, moved to kdexts
    dprintf("viewlist\t<HiveAddr>\n");//OK, moved to kdexts
    dprintf("hivelist\n");//OK, moved to kdexts
    dprintf("freebins\t<HiveAddr>\n");//OK, moved to kdexts
    dprintf("dirtyvector\t<HiveAddr>\n");//OK, moved to kdexts
    dprintf("freecells\t<BinAddr>\n");//OK, moved to kdexts
    dprintf("freehints\t<HiveAddr> <Storage> <Display>\n");//OK, moved to kdexts
    dprintf("help\t\tThis screen\n\n");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmkd\init386.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    initi386.c

Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmkd\parseini.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    parseini.c
Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmkd\initdat.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\i386\geninst.c ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    geninst.c

Abstract:

    This modules contains routines to implement GenInstall of an inf section.
    This is based on the code from the setupapi. Currently, it only supports
    a subset of GenInstall functionality i.e AddReg and DelReg and BitReg.

Author:

    Santosh Jodh (santoshj) 08-Aug-1998


Environment:

    Kernel mode.

Revision History:

--*/


#include "cmp.h"
#include "stdlib.h"
#include "parseini.h"
#include "geninst.h"

typedef
BOOLEAN
(* PFN_INFRULE)(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN PVOID RefData
    );

typedef
BOOLEAN
(* PFN_REGLINE)(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    );

BOOLEAN
CmpProcessReg(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN PVOID RefData
    );

NTSTATUS
CmpProcessAddRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    );

NTSTATUS
CmpProcessDelRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    );

NTSTATUS
CmpProcessBitRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    );

NTSTATUS
CmpGetAddRegInfData(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN ULONG ValueType,
    OUT PVOID *Data,
    OUT PULONG DataSize
    );

NTSTATUS
CmpOpenRegKey(
    IN OUT PHANDLE Key,
    IN OUT PULONG Disposition,
    IN PCHAR Root,
    IN PCHAR SubKey,
    IN ULONG DesiredAccess,
    IN BOOLEAN Create
    );

NTSTATUS
CmpAppendStringToMultiSz(
    IN HANDLE Key,
    IN PCHAR ValueName,
    IN OUT PVOID *Data,
    IN OUT PULONG DataSize
    );

//
// Copied from setupapi.h
//
// Flags for AddReg section lines in INF.  The corresponding value
// is <ValueType> in the AddReg line format given below:
//
// <RegRootString>,<SubKey>,<ValueName>,<ValueType>,<Value>...
//
// The low word contains basic flags concerning the general data type
// and AddReg action. The high word contains values that more specifically
// identify the data type of the registry value.  The high word is ignored
// by the 16-bit Windows 95 SETUPX APIs.
//

#define FLG_ADDREG_BINVALUETYPE     ( 0x00000001 )
#define FLG_ADDREG_NOCLOBBER        ( 0x00000002 )
#define FLG_ADDREG_DELVAL           ( 0x00000004 )
#define FLG_ADDREG_APPEND           ( 0x00000008 ) // Currently supported only
                                                   // for REG_MULTI_SZ values.
#define FLG_ADDREG_KEYONLY          ( 0x00000010 ) // Just create the key, ignore value
#define FLG_ADDREG_OVERWRITEONLY    ( 0x00000020 ) // Set only if value already exists

#define FLG_ADDREG_TYPE_MASK        ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_SZ          ( 0x00000000                           )
#define FLG_ADDREG_TYPE_MULTI_SZ    ( 0x00010000                           )
#define FLG_ADDREG_TYPE_EXPAND_SZ   ( 0x00020000                           )
#define FLG_ADDREG_TYPE_BINARY      ( 0x00000000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_DWORD       ( 0x00010000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_NONE        ( 0x00020000 | FLG_ADDREG_BINVALUETYPE )

#define FLG_BITREG_CLEAR            ( 0x00000000 )
#define FLG_BITREG_SET              ( 0x00000001 )
#define FLG_BITREG_TYPE_BINARY      ( 0x00000000 )
#define FLG_BITREG_TYPE_DWORD       ( 0x00000002 )

//
// We currently only support AddReg and DelReg sections.
//

#define NUM_OF_INF_RULES    3

//
// GenInstall methods we support.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
struct {
    PCHAR       Name;
    PFN_INFRULE Action;
    PVOID       RefData;
} const gInfRuleTable[NUM_OF_INF_RULES] =
{
    {"AddReg", CmpProcessReg, CmpProcessAddRegLine},
    {"DelReg", CmpProcessReg, CmpProcessDelRegLine},
    {"BitReg", CmpProcessReg, CmpProcessBitRegLine}
};
static const UNICODE_STRING NullString = {0, 1, L""};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpAppendStringToMultiSz)
#pragma alloc_text(INIT,CmpOpenRegKey)
#pragma alloc_text(INIT,CmpGetAddRegInfData)
#pragma alloc_text(INIT,CmpProcessReg)
#pragma alloc_text(INIT,CmpProcessAddRegLine)
#pragma alloc_text(INIT,CmpProcessDelRegLine)
#pragma alloc_text(INIT,CmpProcessBitRegLine)
#pragma alloc_text(INIT,CmpGenInstall)
#endif

BOOLEAN
CmpGenInstall(
    IN PVOID InfHandle,
    IN PCHAR Section
    )

/*++

    Routine Description:

        This routine does a GenInstall of the section in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

    Return Value:

        TRUE iff the entire section was processed successfully.

--*/

{
    ULONG   ruleNumber;
    ULONG   i;
    PCHAR   ruleName;
    PCHAR   regSection;
    BOOLEAN result = FALSE;

    if (CmpSearchInfSection(InfHandle, Section))
    {
        //
        // Go through all the rules in the section and try to process
        // each of them.
        //

        for (   ruleNumber = 0;
                ruleName = CmpGetKeyName(InfHandle, Section, ruleNumber);
                ruleNumber++)
        {

            //
            // Search for the proceesing function in our table.
            //

            for (   i = 0;
                    i < NUM_OF_INF_RULES &&
                        _stricmp(ruleName, gInfRuleTable[i].Name);
                    i++);

            if (    i >= NUM_OF_INF_RULES ||
                    (regSection = CmpGetSectionLineIndex(   InfHandle,
                                                            Section,
                                                            ruleNumber,
                                                            0)) == NULL ||
                    !CmpSearchInfSection(InfHandle, Section))
            {
                result = FALSE;
                break;
            }

            if (!(*gInfRuleTable[i].Action)(InfHandle, regSection, gInfRuleTable[i].RefData))
            {
                result = FALSE;
            }
        }

        //
        // All inf rules processed.
        //

        if (ruleNumber)
        {
            result = TRUE;
        }
    }

    return (result);
}

BOOLEAN
CmpProcessReg(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN PVOID RefData
    )

/*++

    Routine Description:

        This routine processes a AddReg section in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

    Return Value:

        TRUE iff the entire section was processed successfully.

--*/

{
    ULONG       lineIndex;
    NTSTATUS    status = STATUS_SUCCESS;
    NTSTATUS    temp;

    //
    // Process all the lines in the xxxReg Section.
    //

    for (   lineIndex = 0;
            CmpSearchInfLine(InfHandle, Section, lineIndex);
            lineIndex++)
    {
        temp = (*(PFN_REGLINE)RefData)(InfHandle, Section, lineIndex);
        if (!NT_SUCCESS(temp))
        {
            status = temp;
        }
    }

    if (NT_SUCCESS(status))
    {
        return (TRUE);
    }

    return (FALSE);
}

NTSTATUS
CmpProcessAddRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine processes a AddReg line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PCHAR               rootKeyName;
    PCHAR               subKeyName;
    PCHAR               valueName;
    ULONG               flags;
    ULONG               valueType;
    PCHAR               buffer;
    HANDLE              key;
    ULONG               disposition;
    BOOLEAN             dontSet;
    PVOID               data = 0;
    ULONG               dataSize = 0;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   objectAttributes;

    //
    // Get the root-key name.
    //

    rootKeyName = CmpGetSectionLineIndex(   InfHandle,
                                            Section,
                                            LineIndex,
                                            0);
    if (rootKeyName)
    {
        //
        // Get the optional sub-key name.
        //

        subKeyName = CmpGetSectionLineIndex(    InfHandle,
                                                Section,
                                                LineIndex,
                                                1);

        //
        // Value name is optional. Can be NULL or "".
        //

        valueName = CmpGetSectionLineIndex( InfHandle,
                                            Section,
                                            LineIndex,
                                            2);
        //
        // If we don't have a value name, the type is REG_SZ to force
        // the right behavior in RegSetValueEx. Otherwise get the data type.
        //

        valueType = REG_SZ;

        //
        // Read in the flags.
        //

        if (!CmpGetIntField(    InfHandle,
                                Section,
                                LineIndex,
                                3,
                                &flags))
        {
            flags = 0;
        }

        //
        // Convert the flags to the registry type.
        //

        switch(flags & FLG_ADDREG_TYPE_MASK)
        {

            case FLG_ADDREG_TYPE_SZ:

                valueType = REG_SZ;
                break;

            case FLG_ADDREG_TYPE_MULTI_SZ:

                valueType = REG_MULTI_SZ;
                break;

            case FLG_ADDREG_TYPE_EXPAND_SZ:

                valueType = REG_EXPAND_SZ;
                break;

            case FLG_ADDREG_TYPE_BINARY:

                valueType = REG_BINARY;
                break;

            case FLG_ADDREG_TYPE_DWORD:

                valueType = REG_DWORD;
                break;

            case FLG_ADDREG_TYPE_NONE:

                valueType = REG_NONE;
                break;

            default :

                //
                // If the FLG_ADDREG_BINVALUETYPE is set, then the highword
                // can contain just about any random reg data type ordinal value.
                //

                if(flags & FLG_ADDREG_BINVALUETYPE)
                {
                    //
                    // Disallow the following reg data types:
                    //
                    //    REG_NONE, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ
                    //

                    valueType = HIGHWORD(flags);

                    if(valueType < REG_BINARY || valueType == REG_MULTI_SZ)
                    {
                        return (STATUS_INVALID_PARAMETER);
                    }

                }
                else
                {
                    return (STATUS_INVALID_PARAMETER);
                }
                break;
        }

        //
        // Presently, the append behavior flag is only supported for
        // REG_MULTI_SZ values.
        //

        if((flags & FLG_ADDREG_APPEND) && valueType != REG_MULTI_SZ)
        {
            return (STATUS_INVALID_PARAMETER);
        }

        //
        // W9x compatibility.
        //

        if( (!valueName || *valueName == '\0') && valueType == REG_EXPAND_SZ)
        {
            valueType = REG_SZ;
        }

        //
        // Open the specified key if possible.
        //

        status = CmpOpenRegKey( &key,
                                &disposition,
                                rootKeyName,
                                subKeyName,
                                KEY_QUERY_VALUE | KEY_SET_VALUE,
                                (BOOLEAN)!(flags & FLG_ADDREG_OVERWRITEONLY));

        if (NT_SUCCESS(status))
        {
            //
            // Respect the key only flag.
            //
            if (!(flags & FLG_ADDREG_KEYONLY)) 
            {
                status = CmpGetAddRegInfData(   InfHandle,
                                                Section,
                                                LineIndex,
                                                4,
                                                valueType,
                                                &data,
                                                &dataSize);
                if (NT_SUCCESS(status))
                {
                    //
                    // This variable gets set to TRUE if we dont actually want to set
                    // the value.
                    //

                    dontSet = FALSE;
                    if (flags & FLG_ADDREG_APPEND)
                    {
                        status = CmpAppendStringToMultiSz(  key,
                                                            valueName,
                                                            &data,
                                                            &dataSize);
                    }
                    if (NT_SUCCESS(status))
                    {
                        //
                        // W9x compatibility.
                        //

                        if (disposition == REG_OPENED_EXISTING_KEY)
                        {
                            if (    (flags & FLG_ADDREG_NOCLOBBER) &&
                                    (valueName == NULL || *valueName == '\0'))
                            {
                                status = NtQueryValueKey(   key,
                                                            (PUNICODE_STRING)&NullString,
                                                            KeyValueBasicInformation,
                                                            NULL,
                                                            0,
                                                            &disposition);
                                if (NT_SUCCESS(status) || status == STATUS_BUFFER_TOO_SMALL)
                                {
                                    flags &= ~FLG_ADDREG_NOCLOBBER;
                                }
                                status = STATUS_SUCCESS;
                            }

                            if (flags & FLG_ADDREG_DELVAL)
                            {
                                //
                                // setupx compatibility.
                                //

                                dontSet = TRUE;
                                if (valueName)
                                {
                                    //
                                    // Delete the specified value.
                                    //

                                    RtlInitAnsiString(&ansiString, valueName);
                                    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
                                    if (NT_SUCCESS(status))
                                    {
                                        status = NtDeleteValueKey(key, &unicodeString);
                                        RtlFreeUnicodeString(&unicodeString);
                                    }
                                }
                            }
                        }
                        else
                        {
                            flags &= ~FLG_ADDREG_NOCLOBBER;
                        }

                        if (!dontSet)
                        {
                            //
                            // If no clobber flag is set, make sure that the value does not
                            // already exist.
                            //

                            RtlInitAnsiString(&ansiString, valueName);
                            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
                            if (NT_SUCCESS(status))
                            {
                                NTSTATUS    existStatus;

                                if (flags & FLG_ADDREG_NOCLOBBER)
                                {
                                    existStatus = NtQueryValueKey(  key,
                                                                    &unicodeString,
                                                                    KeyValueBasicInformation,
                                                                    NULL,
                                                                    0,
                                                                    &disposition);
                                    if (NT_SUCCESS(existStatus) || existStatus == STATUS_BUFFER_TOO_SMALL) {
                                        dontSet = TRUE;
                                    }
                                }
                                else
                                {
                                    if (flags & FLG_ADDREG_OVERWRITEONLY)
                                    {
                                        existStatus = NtQueryValueKey(  key,
                                                                        &unicodeString,
                                                                        KeyValueBasicInformation,
                                                                        NULL,
                                                                        0,
                                                                        &disposition);
                                        if (!NT_SUCCESS(existStatus) && existStatus != STATUS_BUFFER_TOO_SMALL) {
                                            dontSet = TRUE;
                                        }
                                    }
                                }

                                if (!dontSet)
                                {
                                    status = NtSetValueKey( key,
                                                            &unicodeString,
                                                            0,
                                                            valueType,
                                                            data,
                                                            dataSize);
                                }

                                RtlFreeUnicodeString(&unicodeString);
                            }
                        }
                    }
                }
            }
            NtClose(key);
        }
        else if (flags & FLG_ADDREG_OVERWRITEONLY)
        {
            status = STATUS_SUCCESS;
        }
    }

    return (status);
}

NTSTATUS
CmpProcessDelRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine processes a DelReg line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PCHAR               rootKeyName;
    PCHAR               subKeyName;
    PCHAR               valueName;
    HANDLE              key;
    ULONG               disposition;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;

    //
    // Read the required fields.
    //

    rootKeyName = CmpGetSectionLineIndex(   InfHandle,
                                            Section,
                                            LineIndex,
                                            0);

    subKeyName = CmpGetSectionLineIndex(    InfHandle,
                                            Section,
                                            LineIndex,
                                            1);

    if (rootKeyName && subKeyName)
    {
        //
        // Read the optional field.
        //

        valueName = CmpGetSectionLineIndex( InfHandle,
                                            Section,
                                            LineIndex,
                                            2);

        //
        // Open the specified registry key.
        //

        status = CmpOpenRegKey( &key,
                                &disposition,
                                rootKeyName,
                                subKeyName,
                                KEY_ALL_ACCESS,
                                FALSE);

        //
        // Proceed if we successfully opened the registry key.
        //

        if (NT_SUCCESS(status))
        {

            //
            // If the key was successfully opened, do the DelReg.
            //

            if (valueName)
            {
                //
                // Delete the specified value.
                //

                RtlInitAnsiString(&ansiString, valueName);
                status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
                if (NT_SUCCESS(status))
                {
                    status = NtDeleteValueKey(key, &unicodeString);
                    RtlFreeUnicodeString(&unicodeString);
                }
            }
            else
            {
                //
                // No value specified. The subkey needs to be deleted.
                //

                status = NtDeleteKey(key);
            }

            //
            // Close the key handle.
            //

            NtClose(key);
        }
    }

    return (status);
}

NTSTATUS
CmpProcessBitRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine processes a BitReg line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS                    status = STATUS_UNSUCCESSFUL;
    PCHAR                       rootKeyName;
    PCHAR                       subKeyName;
    PCHAR                       valueName;
    ULONG                       flags;
    ULONG                       mask;
    ULONG                       field;
    HANDLE                      key;
    ULONG                       disposition;
    ANSI_STRING                 ansiString;
    UNICODE_STRING              unicodeString;
    PCHAR                       buffer;
    ULONG                       size;
    PKEY_VALUE_FULL_INFORMATION valueInfo;

    //
    // Get the root-key name.
    //

    rootKeyName = CmpGetSectionLineIndex(   InfHandle,
                                            Section,
                                            LineIndex,
                                            0);
    if (rootKeyName)
    {
        //
        // Get the optional sub-key name.
        //

        subKeyName = CmpGetSectionLineIndex(    InfHandle,
                                                Section,
                                                LineIndex,
                                                1);

        //
        // Value name is optional. Can be NULL or "".
        //

        valueName = CmpGetSectionLineIndex( InfHandle,
                                            Section,
                                            LineIndex,
                                            2);
        if (valueName && *valueName)
        {
            //
            // Read in the flags.
            //

            if (!CmpGetIntField(    InfHandle,
                                    Section,
                                    LineIndex,
                                    3,
                                    &flags))
            {
                flags = 0;
            }

            if (!CmpGetIntField(    InfHandle,
                                    Section,
                                    LineIndex,
                                    4,
                                    &mask))
            {
                mask = 0;
            }

            if (!(flags & FLG_BITREG_TYPE_DWORD))
            {
                if (!CmpGetIntField(    InfHandle,
                                        Section,
                                        LineIndex,
                                        5,
                                        &field))
                {
                    return (status);
                }
            }

            //
            // Open the specified registry key.
            //

            status = CmpOpenRegKey( &key,
                                    &disposition,
                                    rootKeyName,
                                    subKeyName,
                                    KEY_ALL_ACCESS,
                                    FALSE);
            if (NT_SUCCESS(status))
            {
                //
                // Read the existing data.
                //

                RtlInitAnsiString(&ansiString, valueName);
                status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
                if (NT_SUCCESS(status))
                {
                    size = 0;
                    status = NtQueryValueKey(   key,
                                                &unicodeString,
                                                KeyValueFullInformation,
                                                NULL,
                                                0,
                                                &size);
                    if (size)
                    {
                        status = STATUS_NO_MEMORY;
                        buffer = ExAllocatePoolWithTag(PagedPool, size, CM_GENINST_TAG);
                        if (buffer)
                        {
                            status = NtQueryValueKey(   key,
                                                        &unicodeString,
                                                        KeyValueFullInformation,
                                                        buffer,
                                                        size,
                                                        &size);
                            if (NT_SUCCESS(status))
                            {
                                valueInfo = (PKEY_VALUE_FULL_INFORMATION)buffer;
                                if (flags & FLG_BITREG_TYPE_DWORD)
                                {
                                    if (valueInfo->Type == REG_DWORD && valueInfo->DataLength == sizeof(ULONG))
                                    {
                                        if (flags & FLG_BITREG_SET)
                                        {
                                            *(PULONG)(buffer + valueInfo->DataOffset) |= mask;
                                        }
                                        else
                                        {
                                            *(PULONG)(buffer + valueInfo->DataOffset) &= ~mask;
                                        }
                                    }
                                }
                                else
                                {
                                    if (valueInfo->Type == REG_BINARY && field < valueInfo->DataLength)
                                    {
                                        if (flags & FLG_BITREG_SET)
                                        {
                                            *(PUCHAR)(buffer + valueInfo->DataOffset + field) |= mask;
                                        }
                                        else
                                        {
                                            *(PUCHAR)(buffer + valueInfo->DataOffset + field) &= ~mask;
                                        }
                                    }
                                }
                                status = NtSetValueKey( key,
                                                        &unicodeString,
                                                        0,
                                                        valueInfo->Type,
                                                        buffer + valueInfo->DataOffset,
                                                        valueInfo->DataLength);
                            }
                            else
                            {
#ifndef _CM_LDR_
                                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Value cannot be read for BitReg in %s line %d\n", Section, LineIndex);
#endif //_CM_LDR_
                                ASSERT(NT_SUCCESS(status));
                            }
                            ExFreePool(buffer);
                        }
                        else
                        {
                            ASSERT(buffer);
                            status = STATUS_NO_MEMORY;
                        }
                    }

                    RtlFreeUnicodeString(&unicodeString);
                }
                //
                // Close the key handle.
                //

                NtClose(key);
            }
        }
    }

    return (status);
}

NTSTATUS
CmpGetAddRegInfData(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN ULONG ValueType,
    OUT PVOID *Data,
    OUT PULONG DataSize
    )

/*++

    Routine Description:

        This routine reads AddReg data from the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

        ValueIndex - Index of the value to be read.

        ValueType - Data type to be read.

        Data - Receives pointer to the buffer in which data has been read.

        DataSize - Receives the size of the data buffer.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PCHAR           str;
    ULONG           count;
    ULONG           i;
    ANSI_STRING     ansiString;
    UNICODE_STRING  unicodeString;

    //
    // Validate the required fields.
    //

    ASSERT(Data);
    ASSERT(DataSize);

    switch (ValueType)
    {
        case REG_DWORD:

            *DataSize = sizeof(ULONG);
            *Data = ExAllocatePoolWithTag(PagedPool, *DataSize, CM_GENINST_TAG);
            if (*Data)
            {
                //
                // DWORD data is specified as four bytes in W9x.
                //

                if (CmpGetSectionLineIndexValueCount(   InfHandle,
                                                        Section,
                                                        LineIndex) == 8)
                {
                    if (!CmpGetBinaryField( InfHandle,
                                            Section,
                                            LineIndex,
                                            ValueIndex,
                                            *Data,
                                            *DataSize,
                                            NULL))
                    {
                        *((PULONG)*Data) = 0;
                    }

                    status = STATUS_SUCCESS;
                }
                else
                {
                    //
                    // Get the DWORD value.
                    //

                    if (!CmpGetIntField(    InfHandle,
                                            Section,
                                            LineIndex,
                                            4,
                                            *Data))
                    {
                        *((PULONG)*Data) = 0;
                    }

                    status = STATUS_SUCCESS;
                }
            }
            else
            {
                ASSERT(*Data);
                status = STATUS_NO_MEMORY;
            }

            break;

        case REG_SZ:
        case REG_EXPAND_SZ:

            //
            // Null terminated string. Gets converted to unicode before being
            // added into the registry.
            //

            str = CmpGetSectionLineIndex(   InfHandle,
                                            Section,
                                            LineIndex,
                                            ValueIndex);
            if (str)
            {
                RtlInitAnsiString(&ansiString, str);
                *DataSize = (ansiString.Length << 1) + sizeof(UNICODE_NULL);
                unicodeString.MaximumLength = (USHORT)*DataSize;
                unicodeString.Buffer = ExAllocatePoolWithTag(PagedPool, *DataSize, CM_GENINST_TAG);
                *Data = NULL;
                if (unicodeString.Buffer)
                {
                    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
                    if (NT_SUCCESS(status))
                    {
                        *Data = unicodeString.Buffer;
                        status = STATUS_SUCCESS;
                    }
                }
                else
                {
                    ASSERT(unicodeString.Buffer);
                    status = STATUS_NO_MEMORY;
                }
            }
            else
            {
                ASSERT(str);
                status = STATUS_NO_MEMORY;
            }

            break;

        case REG_MULTI_SZ:

            *DataSize = 0;
            *Data = NULL;

            //
            // Loop to determine the total memory that needs to be allocated.
            //

            count = CmpGetSectionLineIndexValueCount(   InfHandle,
                                                        Section,
                                                        LineIndex);
            if (count > ValueIndex)
            {
                count -= ValueIndex;
                for (i = 0; i < count; i++)
                {
                    str = CmpGetSectionLineIndex(   InfHandle,
                                                    Section,
                                                    LineIndex,
                                                    ValueIndex + i);
                    if (str == NULL)
                    {
                        break;
                    }

                    *DataSize += ((strlen(str) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                }

                if (i == count)
                {
                    //
                    // Account for the terminating NULL.
                    //

                    *DataSize += sizeof(UNICODE_NULL);
                    *Data = ExAllocatePoolWithTag(PagedPool, *DataSize, CM_GENINST_TAG);
                    if (*Data)
                    {
                        for (   i = 0, unicodeString.Buffer = *Data;
                                i < count;
                                i++, (PCHAR)unicodeString.Buffer += unicodeString.MaximumLength)
                        {
                            str = CmpGetSectionLineIndex(   InfHandle,
                                                            Section,
                                                            LineIndex,
                                                            ValueIndex + i);
                            if (str == NULL)
                            {
                                break;
                            }
                            RtlInitAnsiString(&ansiString, str);
                            unicodeString.MaximumLength = (ansiString.Length * sizeof(WCHAR)) + sizeof(UNICODE_NULL);
                            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
                            if (!NT_SUCCESS(status))
                            {
                                break;
                            }
                        }

                        //
                        // Terminate the multi-sz string.
                        //

                        if (i == count)
                        {
                            unicodeString.Buffer[0] = UNICODE_NULL;
                            status = STATUS_SUCCESS;
                        }
                    }
                    else
                    {
                        ASSERT(*Data);
                        status = STATUS_NO_MEMORY;
                    }
                }
            }

            break;

        case REG_BINARY:
        default:

            //
            // Free form binary data.
            //

            if (CmpGetBinaryField(  InfHandle,
                                    Section,
                                    LineIndex,
                                    ValueIndex,
                                    NULL,
                                    0,
                                    DataSize) && *DataSize)
            {
                *Data = ExAllocatePoolWithTag(PagedPool, *DataSize, CM_GENINST_TAG);
                if (*Data)
                {
                    if (CmpGetBinaryField( InfHandle,
                                            Section,
                                            LineIndex,
                                            4,
                                            *Data,
                                            *DataSize,
                                            NULL))
                    {
                        status = STATUS_SUCCESS;
                    }
                }
                else
                {
                    ASSERT(*Data);
                    status = STATUS_NO_MEMORY;
                }
            }
            else
            {
                status = STATUS_UNSUCCESSFUL;
            }

            break;
    }

    return (status);
}

NTSTATUS
CmpOpenRegKey(
    IN OUT PHANDLE Key,
    IN OUT PULONG Disposition,
    IN PCHAR Root,
    IN PCHAR SubKey,
    IN ULONG DesiredAccess,
    IN BOOLEAN Create
    )

/*++

    Routine Description:

        This routine opens\creates a handle to the registry key.

    Input Parameters:

        Key - Receives the handle to the key.

        Disposition - Receives the disposition of the key.

        Root - Abbreviated name of the root key.

        SubKey - Name of the subkey under the root.

        DesiredAccess - Desired access flags for the key.

        Create - TRUE if the key needs to be created instead of opened.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS            status = STATUS_OBJECT_NAME_INVALID;
    ULONG               size;
    PCHAR               str;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   objectAttributes;

    str = NULL;
    size = strlen(SubKey) + 1;

    //
    // Check if we understand the specified root name.
    //

    if (_stricmp(Root, "HKLM") == 0)
    {
        size += (sizeof("\\Registry\\Machine\\") - 1); // Already added one above for NULL
        str = ExAllocatePoolWithTag(PagedPool, size, CM_GENINST_TAG);
        if (str)
        {
            strcpy(str, "\\Registry\\Machine\\");
            strcat(str, SubKey);
        }
        else
        {
            ASSERT(str);
            status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        ASSERT(_stricmp(Root, "HKLM") == 0);
    }

    //
    // Proceed if we have a valid key name.
    //

    if (str)
    {
        RtlInitAnsiString(&ansiString, str);
        status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
        if (NT_SUCCESS(status))
        {
            InitializeObjectAttributes( &objectAttributes,
                                        &unicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL);
            if (Create)
            {
                //
                // Create a new key or open an existing one.
                //

                status = NtCreateKey(   Key,
                                        DesiredAccess,
                                        &objectAttributes,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        Disposition ? Disposition : &size);
            }
            else
            {
                //
                // Open existing key.
                //

                if (Disposition)
                {
                    *Disposition = REG_OPENED_EXISTING_KEY;
                }
                status = NtOpenKey( Key,
                                    DesiredAccess,
                                    &objectAttributes);
            }

            RtlFreeUnicodeString(&unicodeString);
        }
        else
        {
            ASSERT(NT_SUCCESS(status));
        }

        ExFreePool(str);
    }

    return (status);
}

NTSTATUS
CmpAppendStringToMultiSz(
    IN HANDLE Key,
    IN PCHAR ValueName,
    IN OUT PVOID *Data,
    IN OUT PULONG DataSize
    )

/*++

    Routine Description:

        This routine opens\creates a handle to the registry key.

    Input Parameters:

        Key - Receives the handle to the key.

        ValueName - Name of the value to be appended to.

        Data - Buffer containing the multi-sz to be appended.

        DataSize - Size of the data.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS                    status;
    ULONG                       size;
    ANSI_STRING                 ansiString;
    UNICODE_STRING              unicodeString;
    PKEY_VALUE_FULL_INFORMATION valueInfo;
    PVOID                       buffer;
    PVOID                       str;

    ASSERT(DataSize && *DataSize);
    ASSERT(*Data);

    RtlInitAnsiString(&ansiString, ValueName);
    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
    if (NT_SUCCESS(status))
    {
        size = 0;
        status = NtQueryValueKey(   Key,
                                    &unicodeString,
                                    KeyValueFullInformation,
                                    NULL,
                                    0,
                                    &size);
        if (size)
        {
            buffer = ExAllocatePoolWithTag(PagedPool, size, CM_GENINST_TAG);
            if (buffer)
            {
                status = NtQueryValueKey(   Key,
                                            &unicodeString,
                                            KeyValueFullInformation,
                                            buffer,
                                            size,
                                            &size);
                if (NT_SUCCESS(status))
                {
                    valueInfo = (PKEY_VALUE_FULL_INFORMATION)buffer;
                    str = ExAllocatePoolWithTag(    PagedPool,
                                                    valueInfo->DataLength +
                                                        *DataSize - sizeof(UNICODE_NULL),
                                                    CM_GENINST_TAG);
                    if (str)
                    {
                        memcpy( str,
                                (PCHAR)buffer + valueInfo->DataOffset,
                                valueInfo->DataLength);
                        memcpy( (PCHAR)str + valueInfo->DataLength - sizeof(UNICODE_NULL),
                                *Data,
                                *DataSize);
                        ExFreePool(*Data);
                        *Data = str;
                        *DataSize += valueInfo->DataLength - sizeof(UNICODE_NULL);
                    }
                    else
                    {
#ifndef _CM_LDR_
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpAppendStringToMultiSz: Failed to allocate memory!\n");
#endif //_CM_LDR_
                        ASSERT(str);
                        status = STATUS_NO_MEMORY;
                    }
                }
                ExFreePool(buffer);
            }
            else
            {
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpAppendStringToMultiSz: Failed to allocate memory!\n");
#endif //_CM_LDR_
                ASSERT(buffer);
                status = STATUS_NO_MEMORY;
            }
        }
        RtlFreeUnicodeString(&unicodeString);
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\cmkd\rules.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    rules.c
Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\i386\geninst.h ===
//depot/Lab01_N/Base/ntos/config/i386/geninst.h#1 - branch change 3 (text)
BOOLEAN
CmpGenInstall(
    IN PVOID InfHandle,
    IN PCHAR Section
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\i386\initdat.c ===
//depot/Lab01_N/Base/ntos/config/i386/initdat.c#3 - edit change 11365 (text)
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

Author:

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"

//
// ***** INIT *****
//

//
// Data for CmGetSystemControlValues
//
//
// ----- CmControlVector -----
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#pragma const_seg("INITCONST")
#endif

const PCHAR  SearchStrings[] = {
      "Ver", "Rev", "Rel", "v0", "v1", "v2", "v3", "v4", "v5",
      "v6", "v7", "v8", "v9", "v 0", "v 1", "v 2", "v 3", "v 4",
      "v 5", "v 6", "v 7", "v 8", "v 9", NULL };

PCHAR BiosBegin = { 0 };
PCHAR Start = { 0 };
PCHAR End = { 0 };

const UCHAR CmpID1[] = "80%u86-%c%x";
const UCHAR CmpID2[] = "x86 Family %u Model %u Stepping %u";
const WCHAR CmpVendorID[] = L"VendorIdentifier";
const WCHAR CmpProcessorNameString[] = L"ProcessorNameString";
const WCHAR CmpFeatureBits[] = L"FeatureSet";
const WCHAR CmpMHz[] = L"~MHz";
const WCHAR CmpUpdateSignature[] = L"Update Signature";
const WCHAR CmDisabledFloatingPointProcessor[] = L"DisabledFloatingPointProcessor";
const WCHAR CmPhysicalAddressExtension[] = L"PhysicalAddressExtension";

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGE")
#pragma  const_seg("PAGECONST")
#endif

const UCHAR CmpCyrixID[]     = "CyrixInstead";
const UCHAR CmpIntelID[]     = "GenuineIntel";
const UCHAR CmpAmdID[]       = "AuthenticAMD";
const UCHAR CmpTransmetaID[] = "GenuineTMx86";
const UCHAR CmpCentaurID[]   = "CentaurHauls";

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#pragma  const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\i386\init386.c ===
//depot/Lab01_N/base/ntos/config/i386/init386.c#4 - edit change 6794 (text)
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    init386.c

Abstract:

    This module is responsible to build any x86 specific entries in
    the hardware tree of registry.

Author:

    Ken Reneris (kenr) 04-Aug-1992


Environment:

    Kernel mode.

Revision History:

    shielint - add BIOS date and version detection.

--*/

#include "cmp.h"
#include "stdio.h"
#include "acpitabl.h"
#include "ntacpi.h"
#include "rules.h"

#ifdef _WANT_MACHINE_IDENTIFICATION
#include "string.h"
#include "stdlib.h"
#include "ntverp.h"
#endif


typedef struct _ACPI_BIOS_INFORMATION {
    ULONG BootArchitecture;
    ULONG PreferredProfile;
    ULONG Capabilities;
} ACPI_BIOS_INFORMATION, *PACPI_BIOS_INFORMATION;
//
// Title Index is set to 0.
// (from ..\cmconfig.c)
//

#define TITLE_INDEX_VALUE 0

extern const PCHAR SearchStrings[];
extern PCHAR BiosBegin;
extern PCHAR Start;
extern PCHAR End;
extern const UCHAR CmpID1[];
extern const UCHAR CmpID2[];
extern const WCHAR CmpVendorID[];
extern const WCHAR CmpProcessorNameString[];
extern const WCHAR CmpFeatureBits[];
extern const WCHAR CmpMHz[];
extern const WCHAR CmpUpdateSignature[];
extern const WCHAR CmPhysicalAddressExtension[];

#if !defined(_AMD64_)
extern const UCHAR CmpCyrixID[];
#endif

extern const UCHAR CmpIntelID[];
extern const UCHAR CmpAmdID[];

//
// Bios date and version definitions
//

#define BIOS_DATE_LENGTH 11
#define MAXIMUM_BIOS_VERSION_LENGTH 128
#define SYSTEM_BIOS_START 0xF0000
#define SYSTEM_BIOS_LENGTH 0x10000
#define INT10_VECTOR 0x10
#define VIDEO_BIOS_START 0xC0000
#define VIDEO_BIOS_LENGTH 0x8000
#define VERSION_DATA_LENGTH PAGE_SIZE

//
// Extended CPUID function definitions
//

#define CPUID_PROCESSOR_NAME_STRING_SZ  49
#define CPUID_EXTFN_BASE                0x80000000
#define CPUID_EXTFN_PROCESSOR_NAME      0x80000002

//
// CPU Stepping mismatch.
//

UCHAR CmProcessorMismatch;

#define CM_PROCESSOR_MISMATCH_VENDOR    0x01
#define CM_PROCESSOR_MISMATCH_STEPPING  0x02
#define CM_PROCESSOR_MISMATCH_L2        0x04


extern ULONG CmpConfigurationAreaSize;
extern PCM_FULL_RESOURCE_DESCRIPTOR CmpConfigurationData;


BOOLEAN
CmpGetBiosVersion (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR VersionString
    );

BOOLEAN
CmpGetAcpiBiosVersion(
    PCHAR VersionString
    );

BOOLEAN
CmpGetBiosDate (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR DateString,
    BOOLEAN SystemBiosDate
    );

BOOLEAN
CmpGetAcpiBiosInformation(
    PACPI_BIOS_INFORMATION AcpiBiosInformation
    );

ULONG
Ke386CyrixId (
    VOID
    );

#ifdef _WANT_MACHINE_IDENTIFICATION

VOID
CmpPerformMachineIdentification(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpGetBiosDate)
#pragma alloc_text(INIT,CmpGetBiosVersion)
#pragma alloc_text(INIT,CmpGetAcpiBiosVersion)
#pragma alloc_text(INIT,CmpGetAcpiBiosInformation)
#pragma alloc_text(INIT,CmpInitializeMachineDependentConfiguration)

#ifdef _WANT_MACHINE_IDENTIFICATION
#pragma alloc_text(INIT,CmpPerformMachineIdentification)
#endif

#endif

#if defined(_AMD64_)

#define KeI386NpxPresent TRUE

VOID
__inline
CPUID (
    ULONG InEax,
    PULONG OutEax,
    PULONG OutEbx,
    PULONG OutEcx,
    PULONG OutEdx
    )
{
    CPU_INFO cpuInfo;

    KiCpuId (InEax, &cpuInfo);

    *OutEax = cpuInfo.Eax;
    *OutEbx = cpuInfo.Ebx;
    *OutEcx = cpuInfo.Ecx;
    *OutEdx = cpuInfo.Edx;
}

#endif


BOOLEAN
CmpGetBiosDate (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR DateString,
    BOOLEAN SystemBiosDate
    )

/*++

Routine Description:

    This routine finds the most recent date in the computer/video
    card's ROM.  When GetRomDate encounters a datae, it checks the
    previously found date to see if the new date is more recent.

Arguments:

    SearchArea - the area to search for a date.

    SearchLength - Length of search.

    DateString - Supplies a pointer to a fixed length memory to receive
                 the date string.

Return Value:

    NT_SUCCESS if a date is found.

--*/

{
    CHAR    prevDate[BIOS_DATE_LENGTH]; // Newest date found so far (CCYY/MM/DD)
    CHAR    currDate[BIOS_DATE_LENGTH]; // Date currently being examined (CCYY/MM/DD)
    PCHAR   start;                      // Start of the current search area.
    PCHAR   end;                        // End of the search area.
    ULONG   year;                       // YY
    ULONG   month;                      // MM
    ULONG   day;                        // DD
    ULONG   count;

#define IS_DIGIT(c) ((c) >= '0' && (c) <= '9')

    //
    // Initialize previous date
    //

    RtlZeroMemory(prevDate, BIOS_DATE_LENGTH);

    //
    // We need to look ahead 5 characters to determine the
    // validity of the date pattern.
    //

    start = SearchArea + 2;
    end = SearchArea + SearchLength - 5;

    //
    // Process the entire search area.
    //

    while (start < end) {

        //
        // We consider the following byte pattern as a potential date.
        // We are assuming the following date pattern Month/Day/Year.
        // "n/nn/nn" where n is any digit. We allow month to be single
        // digit only.
        //

        if (    start[0] == '/' && start[3] == '/' &&
                IS_DIGIT(*(start - 1)) &&
                IS_DIGIT(start[1]) && IS_DIGIT(start[2]) &&
                IS_DIGIT(start[4]) && IS_DIGIT(start[5])) {

            //
            // Copy MM/DD part into the currDate.
            //

            RtlMoveMemory(&currDate[5], start - 2, 5);

            //
            // Handle single digit month correctly.
            //

            if (!IS_DIGIT(currDate[5])) {
                currDate[5] = '0';
            }

            //
            // Copy the year YY into currDate
            //

            currDate[2] = start[4];
            currDate[3] = start[5];
            currDate[4] = currDate[7] = currDate[10] = '\0';

            //
            // Do basic validation for the date.
            // Only one field (YY) can be 0.
            // Only one field (YY) can be greater than 31.
            // We assume the ROM date to be in the format MM/DD/YY.
            //

            year = strtoul(&currDate[2], NULL, 16);
            month = strtoul(&currDate[5], NULL, 16);
            day = strtoul(&currDate[8], NULL, 16);

            //
            // Count the number of fields that are 0.
            //

            count = ((day == 0)? 1 : 0) + ((month == 0)? 1 : 0) + ((year == 0)? 1 : 0);
            if (count <= 1) {

                //
                // Count number of field that are greater than 31.
                //

                count = ((day > 0x31)? 1 : 0) + ((month > 0x31)? 1 : 0) + ((year > 0x31)? 1 : 0);
                if (count <= 1) {

                    //
                    // See if the ROM already has a 4 digit date. We do this only for System ROM
                    // since they have a consistent date format.
                    //

                    if (SystemBiosDate && IS_DIGIT(start[6]) && IS_DIGIT(start[7]) &&
                        (memcmp(&start[4], "19", 2) == 0 || memcmp(&start[4], "20", 2) == 0)) {

                        currDate[0] = start[4];
                        currDate[1] = start[5];
                        currDate[2] = start[6];
                        currDate[3] = start[7];

                    } else {

                        //
                        // Internally, we treat year as a 4 digit quantity
                        // for comparison to determine the newest date.
                        // We treat year YY < 80 as 20YY, otherwise 19YY.
                        //

                        if (year < 0x80) {
                            currDate[0] = '2';
                            currDate[1] = '0';
                        } else {
                            currDate[0] = '1';
                            currDate[1] = '9';
                        }
                    }

                    //
                    // Add the '/' delimiters into the date.
                    //

                    currDate[4] = currDate[7] = '/';

                    //
                    // Compare the dates, and save the newer one.
                    //

                    if (memcmp (prevDate, currDate, BIOS_DATE_LENGTH - 1) < 0) {
                        RtlMoveMemory(prevDate, currDate, BIOS_DATE_LENGTH - 1);
                    }

                    //
                    // Next search should start at the second '/'.
                    //

                    start += 2;
                }
            }
        }
        start++;
    }

    if (prevDate[0] != '\0') {

        //
        // Convert from the internal CCYY/MM/DD format to
        // return MM/DD//YY format.
        //

        RtlMoveMemory(DateString, &prevDate[5], 5);
        DateString[5] = '/';
        DateString[6] = prevDate[2];
        DateString[7] = prevDate[3];
        DateString[8] = '\0';

        return (TRUE);
    }

    //
    // If we did not find a date, return an empty string.
    //

    DateString[0] = '\0';
    return (FALSE);
}

BOOLEAN
CmpGetBiosVersion (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR VersionString
    )

/*++

Routine Description:

    This routine finds the version number stored in ROM, if any.

Arguments:

    SearchArea - the area to search for the version.

    SearchLength - Length of search

    VersionString - Supplies a pointer to a fixed length memory to receive
                 the version string.

Return Value:

    TRUE if a version number is found.  Else a value of FALSE is returned.

--*/
{
    PCHAR String;
    USHORT Length;
    USHORT i;
    CHAR Buffer[MAXIMUM_BIOS_VERSION_LENGTH];
    PCHAR BufferPointer;

        if (SearchArea != NULL) {

        //
        // If caller does not specify the search area, we will search
        // the area left from previous search.
        //

        BiosBegin = SearchArea;
        Start = SearchArea + 1;
        End = SearchArea + SearchLength - 2;
    }

    while (1) {

         //
         // Search for a period with a digit on either side
         //

         String = NULL;
         while (Start <= End) {
             if (*Start == '.' && *(Start+1) >= '0' && *(Start+1) <= '9' &&
                 *(Start-1) >= '0' && *(Start-1) <= '9') {
                 String = Start;
                 break;
             } else {
                 Start++;
             }
         }

         if (Start > End) {
             return(FALSE);
         } else {
             Start += 2;
         }

         Length = 0;
         Buffer[MAXIMUM_BIOS_VERSION_LENGTH - 1] = '\0';
         BufferPointer = &Buffer[MAXIMUM_BIOS_VERSION_LENGTH - 1];

         //
         // Search for the beginning of the string
         //

         String--;
         while (Length < MAXIMUM_BIOS_VERSION_LENGTH - 8 &&
                String >= BiosBegin &&
                *String >= ' ' && *String <= 127 &&
                *String != '$') {
             --BufferPointer;
             *BufferPointer = *String;
             --String, ++Length;
         }
         ++String;

         //
         // Can one of the search strings be found
         //

         for (i = 0; SearchStrings[i]; i++) {
             if (strstr(BufferPointer, SearchStrings[i])) {
                 goto Found;
             }
         }
    }

Found:

    //
    // Skip leading white space
    //

    for (; *String == ' '; ++String)
      ;

    //
    // Copy the string to user supplied buffer
    //

    for (i = 0; i < MAXIMUM_BIOS_VERSION_LENGTH - 1 &&
         String <= (End + 1) &&
         *String >= ' ' && *String <= 127 && *String != '$';
         ++i, ++String) {
         VersionString[i] = *String;
    }
    VersionString[i] = '\0';
    return (TRUE);
}

BOOLEAN
CmpGetAcpiBiosVersion(
    PCHAR VersionString
    )
{
    ULONG               length;
    PDESCRIPTION_HEADER header;
    ULONG               i;

    header = CmpFindACPITable(RSDT_SIGNATURE, &length);
    if (header) {

        for (i = 0; i < 6 && header->OEMID[i]; i++) {

            *VersionString++ = header->OEMID[i];
        }
        sprintf(VersionString, " - %x", header->OEMRevision);

        //
        // Unmap the table
        //
        MmUnmapIoSpace(header, length );

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
CmpGetAcpiBiosInformation(
    PACPI_BIOS_INFORMATION AcpiBiosInformation
    )
{
    ULONG               length;
    PFADT               fadt;
    BOOLEAN             result;

    AcpiBiosInformation->BootArchitecture = 0;
    AcpiBiosInformation->Capabilities = 0;
    AcpiBiosInformation->PreferredProfile = 0;
    fadt = (PFADT)CmpFindACPITable(FADT_SIGNATURE, &length);
    if (fadt) {

        //
        // Information is valid only for ACPI version > 1.0
        //

        if (fadt->Header.Revision > 1) {

            AcpiBiosInformation->BootArchitecture = fadt->boot_arch;
            AcpiBiosInformation->Capabilities = fadt->flags;
            AcpiBiosInformation->PreferredProfile = fadt->pm_profile;
        }

        result = (fadt->Header.Revision > 1)? TRUE : FALSE;

        //
        // Unmap the table
        //

        MmUnmapIoSpace(fadt, length);

        return result;
    }

    return FALSE;
}

NTSTATUS
CmpInitializeMachineDependentConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine creates x86 specific entries in the registry.

Arguments:

    LoaderBlock - supplies a pointer to the LoaderBlock passed in from the
                  OS Loader.

Returns:

    NTSTATUS code for sucess or reason of failure.

--*/
{
    NTSTATUS Status;
    ULONG VideoBiosStart;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING ValueData;
    ANSI_STRING AnsiString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;
    HANDLE ParentHandle;
    HANDLE BaseHandle, NpxHandle;
    HANDLE CurrentControlSet;
    CONFIGURATION_COMPONENT_DATA CurrentEntry;
    UCHAR const* VendorID;
    UCHAR  Buffer[MAXIMUM_BIOS_VERSION_LENGTH];
    PKPRCB Prcb;
    ULONG  i, Junk;
    ULONG VersionsLength = 0, Length;
    PCHAR VersionStrings, VersionPointer;
    UNICODE_STRING SectionName;
    SIZE_T ViewSize;
    LARGE_INTEGER ViewBase;
    PVOID BaseAddress;
    HANDLE SectionHandle;
    USHORT DeviceIndexTable[NUMBER_TYPES];
    ULONG CpuIdFunction;
    ULONG MaxExtFn;
    PULONG NameString = NULL;
    ULONG   P0L2Size = 0;
    ULONG   ThisProcessorL2Size;
    struct {
        union {
            UCHAR   Bytes[CPUID_PROCESSOR_NAME_STRING_SZ];
            ULONG   DWords[1];
        } u;
    } ProcessorNameString;
    ULONG VersionPass;
    ACPI_BIOS_INFORMATION AcpiBiosInformation;

#ifdef _WANT_MACHINE_IDENTIFICATION
    HANDLE  BiosInfo;
#endif


    for (i = 0; i < NUMBER_TYPES; i++) {
        DeviceIndexTable[i] = 0;
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                &CmRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagement,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                               );

    Status = NtOpenKey( &BaseHandle,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes
                      );

    if (NT_SUCCESS(Status)) {

        ULONG paeEnabled;

        if (SharedUserData->ProcessorFeatures[PF_PAE_ENABLED] == FALSE) {
            paeEnabled = 0;
        } else {
            paeEnabled = 1;
        }

        RtlInitUnicodeString( &ValueName,
                              CmPhysicalAddressExtension );


        NtSetValueKey( BaseHandle,
                       &ValueName,
                       TITLE_INDEX_VALUE,
                       REG_DWORD,
                       &paeEnabled,
                       sizeof(paeEnabled) );

        NtClose( BaseHandle );
   }





    InitializeObjectAttributes( &ObjectAttributes,
                                &CmRegistryMachineHardwareDescriptionSystemName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtCreateKey( &ParentHandle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          NULL,
                          0,
                          NULL);

    if (!NT_SUCCESS(Status)) {
        // Something is really wrong...
        return Status;
    }

#ifdef _WANT_MACHINE_IDENTIFICATION

    InitializeObjectAttributes( &ObjectAttributes,
                                &CmRegistryMachineSystemCurrentControlSetControlBiosInfo,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtCreateKey(   &BiosInfo,
                            KEY_ALL_ACCESS,
                            &ObjectAttributes,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            &Disposition
                        );

    if (!NT_SUCCESS(Status)) {
        // Something is really wrong...
        return Status;
    }

#endif

    //
    // On an ARC machine the processor(s) are included in the hardware
    // configuration passed in from bootup.  Since there's no standard
    // way to get all the ARC information for each processor in an MP
    // machine via pc-ROMs the information will be added here (if it's
    // not already present).
    //

    RtlInitUnicodeString( &KeyName,
                          L"CentralProcessor"
                        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        ParentHandle,
        NULL
        );

    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtCreateKey(
                &BaseHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                0,
                NULL,
                0,
                &Disposition
                );

    NtClose (BaseHandle);

    if (Disposition == REG_CREATED_NEW_KEY) {

        //
        // The ARC rom didn't add the processor(s) into the registry.
        // Do it now.
        //

        CmpConfigurationData = (PCM_FULL_RESOURCE_DESCRIPTOR)ExAllocatePool(
                                            PagedPool,
                                            CmpConfigurationAreaSize
                                            );

        //
        // if (CmpConfigurationData == 0) {
        //     <do something useful>
        //     Note: we don't actually use it so it doesn't matter for now
        //     since it isn't used until the free.  go figure.
        // }
        //

        for (i=0; i < (ULONG)KeNumberProcessors; i++) {
            Prcb = KiProcessorBlock[i];

            RtlZeroMemory (&CurrentEntry, sizeof CurrentEntry);
            CurrentEntry.ComponentEntry.Class = ProcessorClass;
            CurrentEntry.ComponentEntry.Type = CentralProcessor;
            CurrentEntry.ComponentEntry.Key = i;
            CurrentEntry.ComponentEntry.AffinityMask = AFFINITY_MASK(i);

            CurrentEntry.ComponentEntry.Identifier = Buffer;
            if (Prcb->CpuID == 0) {

                //
                // Old style stepping format
                //

                sprintf (Buffer, CmpID1,
                    Prcb->CpuType,
                    (Prcb->CpuStep >> 8) + 'A',
                    Prcb->CpuStep & 0xff
                    );

            } else {

                //
                // New style stepping format
                //

                sprintf (Buffer, CmpID2,
                    Prcb->CpuType,
                    (Prcb->CpuStep >> 8),
                    Prcb->CpuStep & 0xff
                    );
            }

            CurrentEntry.ComponentEntry.IdentifierLength =
                strlen (Buffer) + 1;

            Status = CmpInitializeRegistryNode(
                &CurrentEntry,
                ParentHandle,
                &BaseHandle,
                -1,
                (ULONG)-1,
                DeviceIndexTable
                );

            if (!NT_SUCCESS(Status)) {
                return(Status);
            }


            if (KeI386NpxPresent) {
                RtlZeroMemory (&CurrentEntry, sizeof CurrentEntry);
                CurrentEntry.ComponentEntry.Class = ProcessorClass;
                CurrentEntry.ComponentEntry.Type = FloatingPointProcessor;
                CurrentEntry.ComponentEntry.Key = i;
                CurrentEntry.ComponentEntry.AffinityMask = AFFINITY_MASK(i);

                CurrentEntry.ComponentEntry.Identifier = Buffer;

                if (Prcb->CpuType == 3) {

                    //
                    // 386 processors have 387's installed, else
                    // use processor identifier as the NPX identifier
                    //

                    strcpy (Buffer, "80387");
                }

                CurrentEntry.ComponentEntry.IdentifierLength =
                    strlen (Buffer) + 1;

                Status = CmpInitializeRegistryNode(
                    &CurrentEntry,
                    ParentHandle,
                    &NpxHandle,
                    -1,
                    (ULONG)-1,
                    DeviceIndexTable
                    );

                if (!NT_SUCCESS(Status)) {
                    NtClose(BaseHandle);
                    return(Status);
                }

                NtClose(NpxHandle);
            }

            //
            // If processor supports Cpu Indentification then
            // go obtain that information for the registry
            //

            VendorID = Prcb->CpuID ? Prcb->VendorString : NULL;

            //
            // Move to target processor and get other related
            // processor information for the registery
            //

            KeSetSystemAffinityThread(Prcb->SetMember);

#if !defined(_AMD64_)
            if (!Prcb->CpuID) {

                //
                // Test for Cyrix processor
                //

                if (Ke386CyrixId ()) {
                    VendorID = CmpCyrixID;
                }
            } else
#endif
            {

                //
                // If this processor has extended CPUID functions, get
                // the ProcessorNameString.  Although the Intel books
                // say that for CpuID functions > than the valued
                // returned for function 0 will return undefined results,
                // we have a guarantee from Intel that that result will
                // never have the highest order bit set.  This enables
                // us to determine if the extended functions are supported
                // by issuing CpuID function 0x80000000.
                //
                // Note:  It is not known that this is true for all x86
                // clones.  If/when we find exceptions we will support
                // them.  In the mean time we are asking the clone makers
                // to guarantee this behavior.
                //

                CPUID(CPUID_EXTFN_BASE, &MaxExtFn, &Junk, &Junk, &Junk);

                if (MaxExtFn >= (CPUID_EXTFN_PROCESSOR_NAME + 2)) {

                    //
                    // This processor supports extended CPUID functions
                    // up to and (at least) including processor name string.
                    //
                    // Each CPUID call for the processor name string will
                    // return 16 bytes, 48 bytes in all, zero terminated.
                    //

                    NameString = &ProcessorNameString.u.DWords[0];

                    for (CpuIdFunction = CPUID_EXTFN_PROCESSOR_NAME;
                         CpuIdFunction <= (CPUID_EXTFN_PROCESSOR_NAME+2);
                         CpuIdFunction++) {

                        CPUID(CpuIdFunction,
                              NameString,
                              NameString + 1,
                              NameString + 2,
                              NameString + 3);
                        NameString += 4;
                    }

                    //
                    // Enforce 0 byte terminator.
                    //

                    ProcessorNameString.u.Bytes[CPUID_PROCESSOR_NAME_STRING_SZ-1] = 0;
                }
            }

            ThisProcessorL2Size = KeGetPcr()->SecondLevelCacheSize;

            //
            // Restore thread's affinity to all processors
            //

            KeRevertToUserAffinityThread();

            if (NameString) {

                //
                // Add Processor Name String to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpProcessorNameString
                    );

                RtlInitAnsiString(
                    &AnsiString,
                    ProcessorNameString.u.Bytes
                    );

                RtlAnsiStringToUnicodeString(
                    &ValueData,
                    &AnsiString,
                    TRUE
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            ValueData.Buffer,
                            ValueData.Length + sizeof( UNICODE_NULL )
                            );

                RtlFreeUnicodeString(&ValueData);
            }

            if (VendorID) {

                //
                // Add Vendor Indentifier to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpVendorID
                    );

                RtlInitAnsiString(
                    &AnsiString,
                    VendorID
                    );

                RtlAnsiStringToUnicodeString(
                    &ValueData,
                    &AnsiString,
                    TRUE
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            ValueData.Buffer,
                            ValueData.Length + sizeof( UNICODE_NULL )
                            );

                RtlFreeUnicodeString(&ValueData);
            }

            if (Prcb->FeatureBits) {
                //
                // Add processor feature bits to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpFeatureBits
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_DWORD,
                            &Prcb->FeatureBits,
                            sizeof (Prcb->FeatureBits)
                            );
            }

            if (Prcb->MHz) {
                //
                // Add processor MHz to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpMHz
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_DWORD,
                            &Prcb->MHz,
                            sizeof (Prcb->MHz)
                            );
            }

            if (Prcb->UpdateSignature.QuadPart) {
                //
                // Add processor MHz to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpUpdateSignature
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_BINARY,
                            &Prcb->UpdateSignature,
                            sizeof (Prcb->UpdateSignature)
                            );
            }

            NtClose(BaseHandle);

            //
            // Check processor steppings.
            //

            if (i == 0) {

                P0L2Size = ThisProcessorL2Size;

            } else {

                //
                // Check all processors against processor 0. Compare
                //     CPUID supported,
                //     Vendor ID String
                //     Family and Stepping
                //     L2 cache size.
                //

                if (Prcb->CpuID) {
                    if (strcmp(Prcb->VendorString,
                               KiProcessorBlock[0]->VendorString)) {
                        CmProcessorMismatch |= CM_PROCESSOR_MISMATCH_VENDOR;
                    }
                    if (ThisProcessorL2Size != P0L2Size) {
                        CmProcessorMismatch |= CM_PROCESSOR_MISMATCH_L2;
                    }
                    if ((Prcb->CpuType != KiProcessorBlock[0]->CpuType) ||
                        (Prcb->CpuStep != KiProcessorBlock[0]->CpuStep)) {
                        CmProcessorMismatch |= CM_PROCESSOR_MISMATCH_STEPPING;
                    }
                } else {

                    //
                    // If this processor doesn't support CPUID, P0
                    // shouldn't support it either.
                    //

                    if (KiProcessorBlock[0]->CpuID) {
                        CmProcessorMismatch |= CM_PROCESSOR_MISMATCH_STEPPING;
                    }
                }
            }
        }

        if (0 != CmpConfigurationData) {
            ExFreePool((PVOID)CmpConfigurationData);
        }
    }

    //
    // Next we try to collect System BIOS date and version strings.
    //

    //
    // Open a physical memory section to map in physical memory.
    //

    RtlInitUnicodeString(
        &SectionName,
        L"\\Device\\PhysicalMemory"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SectionName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    Status = ZwOpenSection(
        &SectionHandle,
        SECTION_ALL_ACCESS,
        &ObjectAttributes
        );

    if (!NT_SUCCESS(Status)) {

        //
        // If fail, forget the bios data and version
        //

        goto AllDone;
    }

    //
    // Examine the first page of physical memory for int 10 segment
    // address.
    //

    BaseAddress = 0;
    ViewSize = 0x1000;
    ViewBase.LowPart = 0;
    ViewBase.HighPart = 0;

    Status =ZwMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &ViewBase,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(Status)) {
        VideoBiosStart = VIDEO_BIOS_START;
    } else {
        VideoBiosStart = (*((PULONG)BaseAddress + INT10_VECTOR) & 0xFFFF0000) >> 12;
        VideoBiosStart += (*((PULONG)BaseAddress + INT10_VECTOR) & 0x0000FFFF);
        VideoBiosStart &= 0xffff8000;
        if (VideoBiosStart < VIDEO_BIOS_START) {
            VideoBiosStart = VIDEO_BIOS_START;
        }
        Status = ZwUnmapViewOfSection(
            NtCurrentProcess(),
            BaseAddress
            );
    }

    VersionStrings = ExAllocatePool(PagedPool, VERSION_DATA_LENGTH);
    BaseAddress = 0;
    ViewSize = SYSTEM_BIOS_LENGTH;
    ViewBase.LowPart = SYSTEM_BIOS_START;
    ViewBase.HighPart = 0;

    Status =ZwMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &ViewBase,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_READWRITE
        );

    if (NT_SUCCESS(Status)) {
        if (CmpGetBiosDate(BaseAddress, SYSTEM_BIOS_LENGTH, Buffer, TRUE)) {

            //
            // Convert ascii date string to unicode string and
            // store it in registry.
            //

            RtlInitUnicodeString(
                &ValueName,
                L"SystemBiosDate"
                );

            RtlInitAnsiString(
                &AnsiString,
                Buffer
                );

            RtlAnsiStringToUnicodeString(
                &ValueData,
                &AnsiString,
                TRUE
                );

            Status = NtSetValueKey(
                        ParentHandle,
                        &ValueName,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        ValueData.Buffer,
                        ValueData.Length + sizeof( UNICODE_NULL )
                        );

            RtlFreeUnicodeString(&ValueData);

#ifdef _WANT_MACHINE_IDENTIFICATION

            memcpy(Buffer, (PCHAR)BaseAddress + 0xFFF5, 8);
            Buffer[8] = '\0';

            RtlInitAnsiString(
                &AnsiString,
                Buffer
                );

            Status = RtlAnsiStringToUnicodeString(
                        &ValueData,
                        &AnsiString,
                        TRUE
                        );

            if (NT_SUCCESS(Status)) {

                Status = NtSetValueKey(
                            BiosInfo,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            ValueData.Buffer,
                            ValueData.Length + sizeof( UNICODE_NULL )
                            );

                RtlFreeUnicodeString(&ValueData);
            }

            NtClose (BiosInfo);

#endif

        }

        if ((VersionPointer = VersionStrings) != NULL) {

            //
            // Try to detect ALL the possible BIOS version strings.
            //

            for (VersionPass = 0; ; VersionPass++) {

                if (VersionPass == 0) {

                    //
                    // First try to get the version from ACPI tables.
                    //

                    if (!CmpGetAcpiBiosVersion(Buffer)) {

                        //
                        // This is a non-ACPI system.
                        //
                        continue;
                    }
                } else {

                    if (!CmpGetBiosVersion((VersionPass == 1)?  BaseAddress : NULL, (VersionPass == 1)? SYSTEM_BIOS_LENGTH : 0, Buffer)) {

                        break;
                    }
                }

                //
                // Convert to unicode strings and copy them to our
                // VersionStrings buffer.
                //

                RtlInitAnsiString(
                    &AnsiString,
                    Buffer
                    );

                RtlAnsiStringToUnicodeString(
                    &ValueData,
                    &AnsiString,
                    TRUE
                    );

                Length = ValueData.Length + sizeof(UNICODE_NULL);
                RtlCopyMemory(VersionPointer,
                              ValueData.Buffer,
                              Length
                              );
                VersionsLength += Length;
                RtlFreeUnicodeString(&ValueData);
                if (VersionsLength + (MAXIMUM_BIOS_VERSION_LENGTH +
                    sizeof(UNICODE_NULL)) * 2 > PAGE_SIZE) {
                    break;
                }
                VersionPointer += Length;
            }

            //
            // If we found any version string, write it to the registry.
            //

            if (VersionsLength != 0) {

                //
                // Append a UNICODE_NULL to the end of VersionStrings
                //

                *(PWSTR)VersionPointer = UNICODE_NULL;
                VersionsLength += sizeof(UNICODE_NULL);

                //
                // If any version string is found, we set up a ValueName and
                // initialize its value to the string(s) we found.
                //

                RtlInitUnicodeString(
                    &ValueName,
                    L"SystemBiosVersion"
                    );

                Status = NtSetValueKey(
                            ParentHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_MULTI_SZ,
                            VersionStrings,
                            VersionsLength
                            );
            }
        }
        ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
    }

    //
    // Get system information like SealedCaseSystem, LegacyFreeSystem etc from
    // the BIOS.
    //
    if (CmpGetAcpiBiosInformation(&AcpiBiosInformation)) {

        RtlInitUnicodeString(
            &ValueName,
            L"BootArchitecture"
            );

        NtSetValueKey(
            ParentHandle,
            &ValueName,
            TITLE_INDEX_VALUE,
            REG_DWORD,
            &AcpiBiosInformation.BootArchitecture,
            sizeof(ULONG)
            );

        RtlInitUnicodeString(
            &ValueName,
            L"PreferredProfile"
            );

        NtSetValueKey(
            ParentHandle,
            &ValueName,
            TITLE_INDEX_VALUE,
            REG_DWORD,
            &AcpiBiosInformation.PreferredProfile,
            sizeof(ULONG)
            );

        RtlInitUnicodeString(
            &ValueName,
            L"Capabilities"
            );

        NtSetValueKey(
            ParentHandle,
            &ValueName,
            TITLE_INDEX_VALUE,
            REG_DWORD,
            &AcpiBiosInformation.Capabilities,
            sizeof(ULONG)
            );
    }

    //
    // Next we try to collect Video BIOS date and version strings.
    //

    BaseAddress = 0;
    ViewSize = VIDEO_BIOS_LENGTH;
    ViewBase.LowPart = VideoBiosStart;
    ViewBase.HighPart = 0;

    Status =ZwMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &ViewBase,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_READWRITE
        );

    if (NT_SUCCESS(Status)) {
        if (CmpGetBiosDate(BaseAddress, VIDEO_BIOS_LENGTH, Buffer, FALSE)) {

            RtlInitUnicodeString(
                &ValueName,
                L"VideoBiosDate"
                );

            RtlInitAnsiString(
                &AnsiString,
                Buffer
                );

            RtlAnsiStringToUnicodeString(
                &ValueData,
                &AnsiString,
                TRUE
                );

            Status = NtSetValueKey(
                        ParentHandle,
                        &ValueName,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        ValueData.Buffer,
                        ValueData.Length + sizeof( UNICODE_NULL )
                        );

            RtlFreeUnicodeString(&ValueData);
        }

        if (VersionStrings && CmpGetBiosVersion(BaseAddress, VIDEO_BIOS_LENGTH, Buffer)) {
            VersionPointer = VersionStrings;
            do {

                //
                // Try to detect ALL the possible BIOS version strings.
                // Convert them to unicode strings and copy them to our
                // VersionStrings buffer.
                //

                RtlInitAnsiString(
                    &AnsiString,
                    Buffer
                    );

                RtlAnsiStringToUnicodeString(
                    &ValueData,
                    &AnsiString,
                    TRUE
                    );

                Length = ValueData.Length + sizeof(UNICODE_NULL);
                RtlCopyMemory(VersionPointer,
                              ValueData.Buffer,
                              Length
                              );
                VersionsLength += Length;
                RtlFreeUnicodeString(&ValueData);
                if (VersionsLength + (MAXIMUM_BIOS_VERSION_LENGTH +
                    sizeof(UNICODE_NULL)) * 2 > PAGE_SIZE) {
                    break;
                }
                VersionPointer += Length;
            } while (CmpGetBiosVersion(NULL, 0, Buffer));

            if (VersionsLength != 0) {

                //
                // Append a UNICODE_NULL to the end of VersionStrings
                //

                *(PWSTR)VersionPointer = UNICODE_NULL;
                VersionsLength += sizeof(UNICODE_NULL);

                RtlInitUnicodeString(
                    &ValueName,
                    L"VideoBiosVersion"
                    );

                Status = NtSetValueKey(
                            ParentHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_MULTI_SZ,
                            VersionStrings,
                            VersionsLength
                            );
            }
        }
        ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
    }
    ZwClose(SectionHandle);
    if (VersionStrings) {
        ExFreePool((PVOID)VersionStrings);
    }

AllDone:

    NtClose (ParentHandle);

    //
    // Add any other x86 specific code here...
    //

#ifdef _WANT_MACHINE_IDENTIFICATION

    //
    // Do machine identification.
    //

    CmpPerformMachineIdentification(LoaderBlock);

#endif

    return STATUS_SUCCESS;
}

#ifdef _WANT_MACHINE_IDENTIFICATION

VOID
CmpPerformMachineIdentification(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    ULONG   majorVersion;
    ULONG   minorVersion;
    CHAR    versionBuffer[64];
    PCHAR   major;
    PCHAR   minor;
    ULONG   minSize;

    major = strcpy(versionBuffer, VER_PRODUCTVERSION_STR);
    minor = strchr(major, '.');
    majorVersion = atoi(major);
    if( minor != NULL ) {
        *minor++ = '\0';
        minorVersion = atoi(minor);
    } else {
        minorVersion = 0;
    }
    if (    LoaderBlock->Extension->MajorVersion > majorVersion ||
            (LoaderBlock->Extension->MajorVersion == majorVersion &&
                LoaderBlock->Extension->MinorVersion >= minorVersion)) {

        minSize = FIELD_OFFSET(LOADER_PARAMETER_EXTENSION, InfFileSize) + sizeof(ULONG);
        if (LoaderBlock->Extension && LoaderBlock->Extension->Size >= minSize) {

            if (LoaderBlock->Extension->InfFileImage && LoaderBlock->Extension->InfFileSize) {

                CmpMatchInfList(
                    LoaderBlock->Extension->InfFileImage,
                    LoaderBlock->Extension->InfFileSize,
                    "MachineDescription"
                    );
            }
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\i386\rules.h ===
//depot/Lab01_N/Base/ntos/config/i386/rules.h#1 - branch change 3 (text)
//
// Maximum data that can be specified (either as string or binary) in the 
// machine identification rules.
//

#define MAX_DESCRIPTION_LEN 256

BOOLEAN
CmpMatchInfList(
    IN PVOID InfImage,
    IN ULONG ImageSize,
    IN PCHAR Section
    );

PDESCRIPTION_HEADER
CmpFindACPITable(
    IN ULONG        Signature,
    IN OUT PULONG   Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\i386\rules.c ===
//depot/Lab01_N/base/ntos/config/i386/rules.c#7 - edit change 11499 (text)
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    rules.c

Abstract:

    This module contains routines to implement rules used to describe a machine.
    This is based on the detection code from W9x.

Author:

    Santosh Jodh (santoshj) 08-Aug-1998

Environment:

    Kernel mode.

Revision History:

--*/

#include "cmp.h"
#include "stdlib.h"
#include "parseini.h"
#include "geninst.h"
#include "acpitabl.h"
#include "ntacpi.h"
#include "rules.h"

#define TABLE_ENTRIES_FROM_RSDT_POINTER(p)  (((p)->Header.Length-min((p)->Header.Length, sizeof(DESCRIPTION_HEADER))) / 4)


//
// Size of the ROM BIOS segment.
//

#define SYSTEM_BIOS_LENGTH 0x10000

//
// PnP BIOS structure signature.
//

#define PNPBIOS_SIGNATURE   'PnP$'

typedef
BOOLEAN
(* PFN_RULE)(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

typedef struct _PNP_BIOS_TABLE PNP_BIOS_TABLE, *PPNP_BIOS_TABLE;

#pragma pack(push, 1)

struct _PNP_BIOS_TABLE
{
    ULONG   Signature;
    UCHAR   Version;
    UCHAR   Length;
    USHORT  ControlField;
    UCHAR   CheckSum;
    ULONG   EventNotification;
    USHORT  RMOffset;
    USHORT  RMSegment;
    USHORT  PMOffset;
    ULONG   PMSegment;
    ULONG   Oem;
    USHORT  RMData;
    ULONG   PMData;
};

#pragma pack(pop)

ULONG
CmpComputeChecksum(
    IN PCHAR    Address,
    IN ULONG    Size
    );

NTSTATUS
CmpFindRSDTTable(
    OUT PACPI_BIOS_MULTI_NODE   *Rsdt
    );

NTSTATUS
CmpGetRegistryValue(
    IN  HANDLE                          KeyName,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION  *Information
    );

BOOLEAN
CmpCheckOperator(
    IN PCHAR Operator,
    IN ULONG Lhs,
    IN ULONG Rhs
    );

PVOID
CmpMapPhysicalAddress(
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR Address,
    IN ULONG Size
    );

BOOLEAN
CmpGetInfData(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG KeyIndex,
    IN ULONG LineIndex,
    IN OUT PCHAR Buffer,
    IN OUT PULONG BufferSize
    );

PVOID
CmpFindPattern(
    IN PCHAR Buffer,
    IN ULONG BufSize,
    IN PCHAR Pattern,
    IN ULONG PatSize,
    IN BOOLEAN IgnoreCase,
    IN ULONG Step
    );

 ULONG
 CmpGetPnPBIOSTableAddress(
    VOID
    );

BOOLEAN
CmpMatchDescription(
    IN PVOID InfHandle,
    IN PCHAR Description
    );

BOOLEAN
CmpMatchDateRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchMemoryRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchSearchRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchNextMatchRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchPointerRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchOemIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchPModeRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchRmPmSameRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchInstallRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchAcpiOemIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchAcpiOemTableIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchAcpiOemRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchAcpiRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

BOOLEAN
CmpMatchAcpiCreatorRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

//
// Number of rules currently implemented.
//

#define NUM_OF_RULES    14

//
// Rule table.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#pragma const_seg("INITCONST")
#endif
struct {
    PCHAR       Name;
    PFN_RULE    Action;
} const gRuleTable[NUM_OF_RULES] =
{
    {"Date", CmpMatchDateRule},
    {"Memory", CmpMatchMemoryRule},
    {"Search", CmpMatchSearchRule},
    {"NextMatch", CmpMatchNextMatchRule},
    {"Pointer", CmpMatchPointerRule},
    {"OemId", CmpMatchOemIdRule},
    {"PMode", CmpMatchPModeRule},
    {"RmPmSame", CmpMatchRmPmSameRule},
    {"Install", CmpMatchInstallRule},
    {"ACPIOemId", CmpMatchAcpiOemIdRule},
    {"ACPIOemTableId", CmpMatchAcpiOemTableIdRule},
    {"ACPIOemRevision", CmpMatchAcpiOemRevisionRule},
    {"ACPIRevision", CmpMatchAcpiRevisionRule},
    {"ACPICreatorRevision", CmpMatchAcpiCreatorRevisionRule}
};

PVOID   gSearchAddress = NULL;

static const WCHAR rgzMultiFunctionAdapter[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
static const WCHAR rgzAcpiConfigurationData[] = L"Configuration Data";
static const WCHAR rgzAcpiIdentifier[] = L"Identifier";
static const WCHAR rgzBIOSIdentifier[] = L"ACPI BIOS";

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpGetRegistryValue)
#pragma alloc_text(INIT,CmpFindACPITable)
#pragma alloc_text(INIT,CmpFindRSDTTable)
#pragma alloc_text(INIT,CmpComputeChecksum)
#pragma alloc_text(INIT,CmpCheckOperator)
#pragma alloc_text(INIT,CmpMapPhysicalAddress)
#pragma alloc_text(INIT,CmpGetInfData)
#pragma alloc_text(INIT,CmpFindPattern)
#pragma alloc_text(INIT,CmpGetPnPBIOSTableAddress)
#pragma alloc_text(INIT,CmpMatchInfList)
#pragma alloc_text(INIT,CmpMatchDescription)
#pragma alloc_text(INIT,CmpMatchDateRule)
#pragma alloc_text(INIT,CmpMatchMemoryRule)
#pragma alloc_text(INIT,CmpMatchSearchRule)
#pragma alloc_text(INIT,CmpMatchNextMatchRule)
#pragma alloc_text(INIT,CmpMatchPointerRule)
#pragma alloc_text(INIT,CmpMatchOemIdRule)
#pragma alloc_text(INIT,CmpMatchPModeRule)
#pragma alloc_text(INIT,CmpMatchRmPmSameRule)
#pragma alloc_text(INIT,CmpMatchInstallRule)
#pragma alloc_text(INIT,CmpMatchAcpiOemIdRule)
#pragma alloc_text(INIT,CmpMatchAcpiOemTableIdRule)
#pragma alloc_text(INIT,CmpMatchAcpiOemRevisionRule)
#pragma alloc_text(INIT,CmpMatchAcpiRevisionRule)
#pragma alloc_text(INIT,CmpMatchAcpiCreatorRevisionRule)
#endif


BOOLEAN
CmpMatchInfList(
    IN PVOID InfImage,
    IN ULONG ImageSize,
    IN PCHAR Section
    )

/*++

    Routine Description:

    Input Parameters:

        InfImage - Pointer to the inf image in memory.

        ImageSize - Size of the inf image.

        Section - Section name containing the descriptions.

        Description -

    Return Value:

        TRUE if the machine matches any one of the descriptions in the inf.

--*/

{
    PCHAR   computerName;
    ULONG   i = 0;
    PVOID   infHandle;
    BOOLEAN result = FALSE;

    infHandle = CmpOpenInfFile(InfImage, ImageSize);

    if (infHandle)
    {
        //
        // Do any clean-up specified in the inf.
        //

        CmpGenInstall(infHandle, "Cleanup");

        //
        // Go through each description in this section and try to match
        // this machine to it.
        //

        while ((computerName = CmpGetSectionLineIndex(infHandle, Section, i++, 0)))
        {
            //
            // Reset search result from previous description.
            //

            gSearchAddress = NULL;

            //
            // We will process ALL sections even if one or more match.
            //

            if (CmpMatchDescription(infHandle, computerName))
            {
                CmKdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL, "CmpMatchInfList: Machine matches %s description!\n", computerName));
                result = TRUE;
            }
        }

        CmpCloseInfFile(infHandle);
    }

    //
    // None of the descriptions match.
    //

    return (result);
}

BOOLEAN
CmpMatchDescription(
    IN PVOID InfHandle,
    IN PCHAR Description
    )

/*++

    Routine Description:

        This routine processes all the rules in the specified description.

    Input Parameters:

        InfHandle - Handle to the inf containing the description.

        Description - Section name containing the rules.

    Return Value:

        TRUE iff all the rules in the description succeed.

--*/

{
    ULONG   ruleNumber;
    ULONG   i;
    PCHAR   ruleName;

    //
    // Proceed only if the section does exist.
    //

    if (CmpSearchInfSection(InfHandle, Description))
    {
        //
        // Go through all the rules in the description and try to match
        // each of them.
        //

        ruleNumber = 0;
        while ((ruleName = CmpGetKeyName(InfHandle, Description, ruleNumber)))
        {
            //
            // Search for the rule in our table.
            //

            for (   i = 0;
                    i < NUM_OF_RULES &&
                        _stricmp(ruleName, gRuleTable[i].Name);
                    i++);

            //
            // If we did not find the rule or the rule failed,
            // return failure.
            //

            if (    i >= NUM_OF_RULES ||
                    !(*gRuleTable[i].Action)(InfHandle, Description, ruleNumber++))
            {
                return (FALSE);
            }
        }

        //
        // Description matches if we found at least one rule and all rules
        // succeeded.
        //

        if (ruleNumber)
        {
            return (TRUE);
        }
    }

    //
    // Description did not match.
    //

    return (FALSE);
}

BOOLEAN
CmpMatchDateRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )

/*++

    Routine Description:

        This routine checks if the machine satisfies the DATE rule. The BIOS date
        is stored in a standard location in the BIOS ROM at FFFF:5.

        Syntax -

        DATE=operator,month,day,year
            where operator [=, ==, !=, <>, <, <=, =<, >, >=, =>]

        Examples -

        date="<=",2,1,95
            is TRUE if the BIOS date on this machine is less than or equal to
            02/01/95.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Description - Name of the section containing the rule info.

        RuleIndex - Line number for the rule in the description section.

    Return Value:

        TRUE if the BIOS on this machine has the specified relation with the
        date specified in the rule.

--*/

{
    PCHAR   op;
    PCHAR   month;
    PCHAR   day;
    PCHAR   year;
    ULONG   infDate;
    ULONG   yr;
    ULONG   biosDate;
    CHAR    temp[3];
    PVOID   baseAddress;
    PCHAR   address;

    op = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    month = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);
    day = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 2);
    year = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 3);

    if (op && month && day && year)
    {
        yr = strtoul(year, NULL, 16);
        infDate = ((yr < 0x80) ? 0x20000000 : 0x19000000) +
                    (yr << 16) +
                    (strtoul(month, NULL, 16) << 8) +
                    (strtoul(day, NULL, 16));

        address = CmpMapPhysicalAddress(&baseAddress, 0xFFFF5, 8);
        if (address)
        {
            temp[2] = '\0';

            RtlCopyBytes(temp, address + 6, 2);
            yr = strtoul(temp, NULL, 16);
            biosDate = ((yr < 0x80) ? 0x20000000 : 0x19000000) +
                        (yr << 16);

            RtlCopyBytes(temp, address, 2);
            biosDate |= (strtoul(temp, NULL, 16) << 8);

            RtlCopyBytes(temp, address + 3, 2);
            biosDate |= strtoul(temp, NULL, 16);

            ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);

            if (CmpCheckOperator(op, biosDate, infDate))
            {
                return (TRUE);
            }
        }
    }

    return (FALSE);
}

BOOLEAN
CmpMatchMemoryRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )

/*++

    Routine Description:

        This routine checks if the machine satisfies the MEMORY rule.

        Syntax -

        MEMORY=segment,offset,type,data
            where type ["S", "B"]

        Examples -

        memory=f000,e000,S,"TOSHIBA"
            is TRUE if the memory in this machine at physical address f000:e000
            has the string "TOSHIBA".

        memory=ffff,5,B,01,02
            is TRUE if the memory in this machine at physical memory ffff:5
            has the bytes 0x01 and 0x02.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Description - Name of the section containing the rule info.

        RuleIndex - Line number for the rule in the description section.

    Return Value:

        TRUE iff the MEMORY in this machine at the specified address
        contains the specified data.

--*/

{
    BOOLEAN             match = FALSE;
    PCHAR               segment;
    PCHAR               offset;
    CHAR                data[MAX_DESCRIPTION_LEN + 1];
    ULONG               cbData;
    PVOID               baseAddress;
    PCHAR               address;
    ULONG               memory;

    //
    // Read in the segment and offset of the address specified.
    //

    segment = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    offset = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);

    if (segment && offset)
    {
        //
        // Get the data specified in the inf.
        //

        cbData = sizeof(data);
        if (CmpGetInfData(InfHandle, Description, RuleIndex, 2, data, &cbData))
        {
            memory = (strtoul(segment, NULL, 16) << 4) + strtoul(offset, NULL, 16);

            //
            // Map in the physical address.
            //

            address = CmpMapPhysicalAddress(&baseAddress, memory, cbData);
            if (address)
            {

                //
                // Check if the inf data matches data in memory.
                //

                match = (RtlCompareMemory(address, data, cbData) == cbData);

                //
                // Unmap the physical address.
                //

                ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
            }
        }
    }

    return (match);
}

BOOLEAN
CmpMatchSearchRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )

/*++

    Routine Description:

        This routine checks to see if the machine matches the SEARCH rule.

        Syntax -

        SEARCH=segment,offset,length,type,data
            where type ["S", "B"]

        Examples -

        search=f000,e000,7f,S,"SurePath"
            is TRUE if the string "SurePath" is somewhere in memory range
            F000:E000 to F000:E07F (inclusive).

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Description - Name of the section containing the rule info.

        RuleIndex - Line number for the rule in the description section.

    Return Value:

        TRUE iff the specified pattern is found within the specified address
        range.

--*/

{
    BOOLEAN match = FALSE;
    PCHAR   segment;
    PCHAR   offset;
    PCHAR   size;
    CHAR    data[MAX_DESCRIPTION_LEN + 1];
    ULONG   cbData;
    ULONG   memory;
    ULONG   length;
    PVOID   baseAddress;
    PCHAR   address;

    segment = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    offset = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);
    size = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 2);

    if (segment && offset && size)
    {
        //
        // Get the data specified in the inf.
        //

        cbData = sizeof(data);
        if (CmpGetInfData(InfHandle, Description, RuleIndex, 3, data, &cbData))
        {
            memory = (strtoul(segment, NULL, 16) << 4) + strtoul(offset, NULL, 16);

            //
            // Map in the physical address.
            //

            length = strtoul(size, NULL, 16);
            address = CmpMapPhysicalAddress(&baseAddress, memory, length);
            if (address)
            {
                gSearchAddress = CmpFindPattern(address, length, data, cbData, FALSE, 0);
                if (gSearchAddress)
                {
                    //
                    // If we found the pattern, compute the actual address for it.
                    //

                    (PCHAR)gSearchAddress -= (ULONG_PTR)address;
                    (PCHAR)gSearchAddress += memory;
                    match = TRUE;
                }

                //
                // Unmap the physical address.
                //

                ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
            }
        }
    }

    return (match);
}

BOOLEAN
CmpMatchNextMatchRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )

/*++

    Routine Description:

        This routine checks to see if the machine matches the NEXTMATCH rule.

        Syntax -

        NEXTMATCH=offset,type,data
            where type ["S", "B"]

        Examples -

        nextmatch=f0,S,"Atlanta"
            is TRUE if the string "Atlanta" is at offset 0xF0 from the previous
            successful SEARCH or NEXTMATCH rule.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Description - Name of the section containing the rule info.

        RuleIndex - Line number for the rule in the description section.

    Return Value:

        TRUE iff the specified pattern is found at the specified offset
        from the previous successful SEARCH or NEXTMATCH.

--*/

{
    BOOLEAN match = FALSE;
    PCHAR   offset;
    CHAR    data[MAX_DESCRIPTION_LEN + 1];
    ULONG   cbData;
    PVOID   baseAddress;
    PCHAR   address;

    if (gSearchAddress)
    {
        offset = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
        if (offset)
        {
            //
            // Get the data specified in the inf.
            //

            cbData = sizeof(data);

            if (CmpGetInfData(InfHandle, Description, RuleIndex, 1, data, &cbData))
            {
                (PCHAR)gSearchAddress += strtoul(offset, NULL, 16);

                //
                // Map in the physical address.
                //

                address = CmpMapPhysicalAddress(&baseAddress, (ULONG_PTR)gSearchAddress, cbData);
                if (address)
                {

                    //
                    // Check if the inf data matches data in memory.
                    //

                    match = (RtlCompareMemory(address, data, cbData) == cbData);

                    //
                    // Unmap the physical address.
                    //

                    ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                }
            }
        }
    }

    return (match);
}

BOOLEAN
CmpMatchPointerRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    BOOLEAN match = FALSE;
    PCHAR   segment1;
    PCHAR   offset1;
    PCHAR   segment2;
    PCHAR   offset2;
    PCHAR   index;
    PCHAR   op;
    CHAR    data[MAX_DESCRIPTION_LEN + 1];
    ULONG   cbData;
    ULONG   memory;
    ULONG   pointer;
    PVOID   baseAddress;
    PCHAR   address;

    segment1 = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    offset1 = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);
    segment2 = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 2);
    offset2 = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 3);
    index = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 4);
    op = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 5);

    if (    segment1 && offset1 &&
            segment2 && offset2 &&
            index && op)
    {
        //
        // Get the data specified in the inf.
        //

        cbData = sizeof(data);

        if (CmpGetInfData(InfHandle, Description, RuleIndex, 6, data, &cbData))
        {
            if (strlen(offset2) == 0)
            {
                memory = strtoul(segment2, NULL, 16) << 4;
            }
            else
            {
                memory = (strtoul(segment2, NULL, 16) << 4) + strtoul(offset2, NULL, 16);
            }

            address = CmpMapPhysicalAddress(&baseAddress, memory, 4);
            if (address)
            {
                pointer = *((PUSHORT)address);

                //
                // Unmap the physical address.
                //

                ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);

                if (strlen(offset1) == 0)
                {
                    memory = (strtoul(segment1, NULL, 16) << 4) + pointer;
                }
                else
                {
                    memory = (strtoul(segment1, NULL, 16) << 4) + strtoul(offset1, NULL, 16);
                    address = CmpMapPhysicalAddress(&baseAddress, memory, 2);
                    if (address)
                    {
                        memory = ((*(PUSHORT)address) << 4) + pointer;

                        //
                        // Unmap the physical address.
                        //

                        ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                    }
                }

                memory += strtoul(index, NULL, 16);

                //
                // Map in the physical address.
                //

                address = CmpMapPhysicalAddress(&baseAddress, memory, cbData);
                if (address)
                {
                    match = CmpCheckOperator(op, (ULONG)RtlCompareMemory(address, data, cbData), cbData);

                    //
                    // Unmap the physical address.
                    //

                    ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                }
            }
        }
    }

    return (match);
}

BOOLEAN
CmpMatchOemIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    BOOLEAN         match = FALSE;
    ULONG           address;
    PCHAR           op;
    PCHAR           oemIdStr;
    ULONG           oemId;
    PCHAR           baseAddress;
    PPNP_BIOS_TABLE biosTable;

    //
    // Search for the PnPBIOS structure in the BIOS ROM.
    //

    address = CmpGetPnPBIOSTableAddress();

    //
    // Proceed if we found the PnP BIOS structure.
    //

    if (address)
    {
        op = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
        oemIdStr = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);
        if (op && oemIdStr)
        {

            if (    strlen(oemIdStr) == 7 &&
                    isalpha(oemIdStr[0]) &&
                    isalpha(oemIdStr[1]) &&
                    isalpha(oemIdStr[2]) &&
                    isxdigit(oemIdStr[3]) &&
                    isxdigit(oemIdStr[4]) &&
                    isxdigit(oemIdStr[5]) &&
                    isxdigit(oemIdStr[6]))
            {

                biosTable = (PPNP_BIOS_TABLE)CmpMapPhysicalAddress(&baseAddress, address, sizeof(PNP_BIOS_TABLE));
                if (biosTable)
                {
                    oemId = ((ULONG)(oemIdStr[0] & 0x1F) << 26) +
                            ((ULONG)(oemIdStr[1] & 0x1F) << 21) +
                            ((ULONG)(oemIdStr[2] & 0x1F) << 16) +
                            strtoul(&oemIdStr[3], NULL, 16);

                    //
                    // We only support EQUAL and NOT EQUAL operators.
                    //

                    if (strcmp(op, "=") == 0 || strcmp(op, "==") == 0)
                    {
                        match = (oemId == biosTable->Oem);
                    }
                    else if(    strcmp(op, "<>") == 0 ||
                                strcmp(op, "!=") == 0 ||
                                strcmp(op, "=!") == 0)
                    {
                        match = (oemId != biosTable->Oem);
                    }

                    //
                    // Unmap the physical address.
                    //

                    ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                }
            }
        }
    }

    return (match);
}

BOOLEAN
CmpMatchPModeRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    BOOLEAN         match = FALSE;
    ULONG           address;
    CHAR            data[MAX_DESCRIPTION_LEN + 1];
    ULONG           cbData;
    PVOID           baseAddress;
    PPNP_BIOS_TABLE biosTable;
    ULONG           pmAddress;
    PCHAR           pmodeEntry;

    //
    // Search for the PnPBIOS structure in the BIOS ROM.
    //

    address = CmpGetPnPBIOSTableAddress();

    //
    // Proceed if we found the PnP BIOS structure.
    //

    if (address)
    {
        //
        // Get the data specified in the inf.
        //

        cbData = sizeof(data);
        if (CmpGetInfData(InfHandle, Description, RuleIndex, 0, data, &cbData))
        {
            biosTable = (PPNP_BIOS_TABLE)CmpMapPhysicalAddress(&baseAddress, address, sizeof(PNP_BIOS_TABLE));
            if (biosTable)
            {
                pmAddress = (biosTable->PMSegment << 4) + biosTable->PMOffset;

                //
                // Unmap the physical address.
                //

                ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);

                pmodeEntry = CmpMapPhysicalAddress(&baseAddress, pmAddress, SYSTEM_BIOS_LENGTH);
                if (pmodeEntry)
                {
                    if (*pmodeEntry == 0xE9)
                    {
                        pmodeEntry += (3 + (*((PUSHORT)&pmodeEntry[1])));
                    }

                    match = (RtlCompareMemory(pmodeEntry, data, cbData) == cbData);

                    //
                    // Unmap the physical address.
                    //

                    ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                }
            }
        }
    }

    return (match);
}

BOOLEAN
CmpMatchRmPmSameRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    BOOLEAN match = FALSE;
    ULONG           address;
    PCHAR           baseAddress;
    PPNP_BIOS_TABLE biosTable;

    //
    // Search for the PnPBIOS structure in the BIOS ROM.
    //

    address = CmpGetPnPBIOSTableAddress();

    //
    // Proceed if we found the PnP BIOS structure.
    //

    if (address)
    {
        biosTable = CmpMapPhysicalAddress(&baseAddress, address, sizeof(PNP_BIOS_TABLE));
        if (biosTable)
        {
            match = (   biosTable->RMSegment == biosTable->PMSegment &&
                        biosTable->RMOffset == biosTable->PMOffset);

            //
            // Unmap the physical address.
            //

            ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
        }
    }

    return (match);
}

BOOLEAN
CmpMatchInstallRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    BOOLEAN match = FALSE;
    PCHAR   install;

    install = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    if (install)
    {
        if (CmpGenInstall(InfHandle, install))
        {
            //
            // Successfully installed the specified section.
            //

            match = TRUE;
        }
    }

    return (match);
}

BOOLEAN
CmpMatchAcpiOemIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI OEM ID rule from an INF file

    Examples:

        AcpiOemId="RSDT", "123456"

    is true if the RSDT has the OEM ID of 123456.

        AcpiOemId="DSDT", "768000"

    is true if the DSDT has the OEM ID of 768000.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    BOOLEAN             anyCase = FALSE;
    BOOLEAN             match = FALSE;
    PCHAR               tableName;
    PCHAR               oemId;
    PCHAR               optionalArgs;
    ULONG               length;
    PDESCRIPTION_HEADER header;
    CHAR                tableOemId[7];
    STRING              acpiString;
    STRING              tableString;

    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    oemId = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    if (tableName && oemId) {

        //
        // See if we have to do a case insensitive match
        //
        optionalArgs = CmpGetSectionLineIndex(
            InfHandle,
            Description,
            RuleIndex,
            2
            );
        if (optionalArgs) {

            if (_stricmp(optionalArgs,"any") == 0) {

                anyCase = TRUE;

            }

        }

        //
        // Find the specified table in the BIOS ROM.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            //
            // Build the OEM id from the table
            //
            RtlZeroMemory(tableOemId, sizeof(tableOemId));
            RtlCopyMemory(tableOemId, header->OEMID, sizeof(header->OEMID));
            RtlInitString( &tableString, tableOemId );

            //
            // And one from the string in the file
            //
            RtlInitString( &acpiString, oemId );

            //
            // Now see if they are equal
            //
            match = RtlEqualString( &acpiString, &tableString, anyCase );

            //
            // Unmap the table
            //
            MmUnmapIoSpace(header, length );

        }

    }
    return (match);
}

BOOLEAN
CmpMatchAcpiOemTableIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI OEM Table ID rule from an INF file.

    Examples:

    AcpiOemTableId="RSDT", "12345678"

        is true if the RSDT has the Oem Table ID of 12345678.

    AcpiOemTableId="DSDT", "87654321"

        is true if the DSDT has the Oem Table ID of 87654321.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM Table ID.

    FALSE - the computer does not have the specified ACPI OEM Table ID.

--*/

{
    BOOLEAN             match = FALSE;
    PCHAR               tableName;
    PCHAR               oemTableId;
    ULONG               length;
    PDESCRIPTION_HEADER header;
    ULONG               idLength;
    CHAR                acpiOemTableId[8];

    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    oemTableId = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    if (tableName && oemTableId) {

        //
        // Find the specified table in the BIOS ROM.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            RtlZeroMemory(acpiOemTableId, sizeof(acpiOemTableId));
            idLength = strlen(oemTableId);
            if (idLength > sizeof(acpiOemTableId)) {

                idLength = sizeof(acpiOemTableId);

            }
            RtlCopyMemory(acpiOemTableId, oemTableId, idLength);
            match = RtlEqualMemory(acpiOemTableId, header->OEMTableID, sizeof(header->OEMTableID));
            MmUnmapIoSpace( header, length );

        }

    }
    return (match);
}

BOOLEAN
CmpMatchAcpiOemRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI Oem Revision rule from an INF file.

    Examples:

    AcpiOemRevision="=","RSDT", 1234

        is true if the RSDT has the Oem Revision EQUAL to 1234.

    AcpiOemRevision=">","DSDT", 4321

        is true if the DSDT has the Oem Revision GREATER than 4321.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI Oem Revision.

    FALSE - the computer does not have the specified ACPI Oem Revision.

--*/

{
    BOOLEAN             match = FALSE;
    PCHAR               op;
    PCHAR               tableName;
    PCHAR               oemRevisionStr;
    ULONG               oemRevision;
    ULONG               length;
    PDESCRIPTION_HEADER header;

    op = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    oemRevisionStr = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        2
        );
    if (op && tableName && oemRevisionStr) {

        //
        // Find the specified table.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            RtlCharToInteger(oemRevisionStr, 16, &oemRevision);
            match = CmpCheckOperator(op, header->OEMRevision, oemRevision);
            MmUnmapIoSpace(header, length);

        }

    }
    return(match);

}

BOOLEAN
CmpMatchAcpiRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI Revision rule from an INF file.

    Examples:

        AcpiRevision="=", "RSDT", 1234

    is true if the RSDT ACPI Revision is EQUAL to 1234.

        AcpiRevision=">", "DSDT", 4321

    is true if the DSDT ACPI Revision is GREATER than 4321.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI Revision.

    FALSE - the computer does not have the specified ACPI Revision.

--*/

{
    BOOLEAN             match = FALSE;
    PCHAR               op;
    PCHAR               tableName;
    PCHAR               revisionStr;
    ULONG               revision;
    ULONG               length;
    PDESCRIPTION_HEADER header;

    op = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    revisionStr = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        2
        );
    if (op && tableName && revisionStr){

        //
        // Find the specified table.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            RtlCharToInteger(revisionStr, 16, &revision);
            match = CmpCheckOperator(op, header->Revision, revision);
            MmUnmapIoSpace(header, length);

        }

    }
    return(match);

}

BOOLEAN
CmpMatchAcpiCreatorRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI Creator Revision rule from an INF file.

    Examples:

        AcpiCreatorRevision="=", "RSDT", 1234

    is true if the RSDT ACPI Creator Revision is EQUAL to 1234.

        AcpiCreatorRevision=">", "DSDT", 4321

    is true if the DSDT ACPI Creator Revision is GREATER than 4321.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI Creator Revision.

    FALSE - the computer does not have the specified ACPI Creator Revision.

--*/

{
    BOOLEAN             match = FALSE;
    PCHAR               op;
    PCHAR               tableName;
    PCHAR               creatorRevisionStr;
    ULONG               creatorRevision;
    ULONG               length;
    PDESCRIPTION_HEADER header;

    op = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    creatorRevisionStr = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        2
        );
    if (op && tableName && creatorRevisionStr) {

        //
        // Find the specified table.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header){

            RtlCharToInteger(creatorRevisionStr, 16, &creatorRevision);
            match = CmpCheckOperator(op, header->CreatorRev, creatorRevision);
            MmUnmapIoSpace( header, length );

        }

    }
    return(match);
}

BOOLEAN
CmpMatchAcpiCreatorIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI Creator ID rule from an INF file.

    Examples:

        AcpiCreatorId="RSDT", "MSFT"

    is true if the RSDT has the Creator ID of MSFT.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI Creator ID.

    FALSE - the computer does not have the specified ACPI Creator ID.

--*/

{
    BOOLEAN             match = FALSE;
    PCHAR               tableName;
    PCHAR               creatorId;
    ULONG               length;
    PDESCRIPTION_HEADER header;
    ULONG               idLength;
    CHAR                acpiCreatorId[6];

    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    creatorId = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    if (tableName && creatorId) {

        //
        // Find the specified table.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            RtlZeroMemory(acpiCreatorId, sizeof(acpiCreatorId));
            idLength = strlen(creatorId);
            if (idLength > sizeof(acpiCreatorId)) {

                idLength = sizeof(acpiCreatorId);

            }
            RtlCopyMemory(acpiCreatorId, creatorId, idLength);
            match = RtlEqualMemory(acpiCreatorId, header->CreatorID, sizeof(header->CreatorID));
            MmUnmapIoSpace( header, length );

        }

    }
    return(match);
}

BOOLEAN
CmpGetInfData(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PCHAR Buffer,
    IN OUT PULONG BufferSize
    )

/*++

    Routine Description:

        This routine reads and parses data from the inf. It understands
        two kinds of data 1. String 2. Binary.

        Examples-

        B,02 - byte 0x02
        B,72,0D,FF,0F - sequence of bytes 0x72 0x0D 0xFF 0x0F or the DWORD 0x0FFF0D72
        S,COMPAQ - ASCII string "COMPAQ"

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Section name to be read.

        LineIndex - Index of the line in the Section to be read.

        ValueIndex - First value to be read on the LineIndex.

        Buffer - Parsed data gets returned in this buffer.

        BufferSize - On entry, contains the size of Buffer.
        The number of bytes parsed in gets returned in this
        variable.

    Return Value:

        TRUE iff data was parsed in successfully. Else FALSE.

--*/

{
    BOOLEAN result = FALSE;
    ULONG   cbData;
    PCHAR   data;
    ULONG   remainingBytes;

    //
    // Validate input parameters.
    //

    if (Buffer && BufferSize && *BufferSize)
    {
        //
        // Read in the data type "S" or "B".
        //

        PCHAR type = CmpGetSectionLineIndex(InfHandle, Section, LineIndex, ValueIndex++);
        if (type)
        {
            //
            // Initialize local data.
            //

            remainingBytes = *BufferSize;

            //
            // Process Binary data.
            //

            if (_stricmp(type, "B") == 0)
            {

                //
                // Parse data as long as there is more data and the buffer is not full.
                //

                for (result = TRUE; result == TRUE && remainingBytes; remainingBytes--)
                {
                    CHAR    value;

                    //
                    // Read in the data.
                    //

                    data = CmpGetSectionLineIndex(InfHandle, Section, LineIndex, ValueIndex++);
                    if (data)
                    {
                        //
                        // Convert the data read in and validate that is indeed a HEX value.
                        //

                        value = (CHAR)strtoul(data, NULL, 16);
                        if (value == 0 && strcmp(data, "00") && strcmp(data, "0"))
                        {
                            result = FALSE;
                        }
                        else
                        {
                            *Buffer++ = value;
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                //
                // Return the number of bytes parsed in.
                //

                *BufferSize -= remainingBytes;
            }

            //
            // Process String data.
            //

            else if(_stricmp(type, "S") == 0)
            {
                //
                // Read in the string.
                //

                data = CmpGetSectionLineIndex(InfHandle, Section, LineIndex, ValueIndex);

                //
                // Only copy as much data as the buffer can hold.
                //

                cbData = min(remainingBytes, strlen(data));
                RtlCopyBytes(Buffer, data, cbData);

                //
                // Return the number of bytes actually copied.
                //

                *BufferSize = cbData;
                result = TRUE;
            }
        }
    }

    return (result);
}

PVOID
CmpMapPhysicalAddress(
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR Address,
    IN ULONG Size
    )

/*++

    Routine Description:

        This routine maps the specified physical segment into the process
        virtual memory.

    Input Parameters:

        Segment - Segment to be mapped.

        Size - Segment size to be mapped.

    Return Value:

        Virtual address for the mapped segment.

--*/

{
    UNICODE_STRING      sectionName;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              sectionHandle;
    NTSTATUS            status;
    PVOID               baseAddress;
    SIZE_T              viewSize;
    LARGE_INTEGER       viewBase;
    PVOID               ptr = NULL;

    *BaseAddress = NULL;

    RtlInitUnicodeString(&sectionName, L"\\Device\\PhysicalMemory");
    InitializeObjectAttributes( &objectAttributes,
                                &sectionName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                (PSECURITY_DESCRIPTOR)NULL);
    status = ZwOpenSection( &sectionHandle,
                            SECTION_MAP_READ,
                            &objectAttributes);
    if (NT_SUCCESS(status))
    {
        baseAddress = NULL;
        viewSize = Size;
        viewBase.QuadPart = Address & ~(0xFFF);
        status = ZwMapViewOfSection(    sectionHandle,
                                        NtCurrentProcess(),
                                        &baseAddress,
                                        0,
                                        viewSize,
                                        &viewBase,
                                        &viewSize,
                                        ViewUnmap,
                                        MEM_DOS_LIM,
                                        PAGE_READWRITE);
        if (NT_SUCCESS(status))
        {
            ptr = (PVOID)((PCHAR)baseAddress + (Address & 0xFFF));
            *BaseAddress = baseAddress;
        }
    }

    return (ptr);
}

    BOOLEAN
CmpCheckOperator(
    IN PCHAR Operator,
    IN ULONG Lhs,
    IN ULONG Rhs
    )

/*++

    Routine Description:

        This routine tests condition specified by the operator by
        applying it to the specified LHS and RHS arguments.

    Input Parameters:

        Operator - Is the operator to be tested.

        Lhs - Left Hand Side argument for the Operator.

        Rhs - Right Hand Side argument for the Operator.

    Return Value:

        True iff the condition Lhs Operator Rhs is satisfied.

--*/

{
    BOOLEAN result = FALSE;

    //
    // We are pretty lenient about which operators we support.
    //

    //
    // "=" or "==" for EQUAL.
    //

    if (strcmp(Operator, "=") == 0 || strcmp(Operator, "==") == 0)
    {
        result = (Lhs == Rhs);
    }

    //
    // "!=" or "=!" or "<>" for NOT EQUAL.
    //

    else if(    strcmp(Operator, "!=") == 0 ||
                strcmp(Operator, "<>") == 0 ||
                strcmp(Operator, "=!") == 0)
    {
        result = (Lhs != Rhs);
    }

    //
    // "<" for LESS THAN.
    //

    else if(strcmp(Operator, "<") == 0)
    {
        result = (Lhs < Rhs);
    }

    //
    // "<=" or "=<" for LESS THAN or EQUAL.
    //

    else if(strcmp(Operator, "<=") == 0 || strcmp(Operator, "=<") == 0)
    {
        result = (Lhs <= Rhs);
    }

    //
    // ">" for GREATER THAN.
    //

    else if(strcmp(Operator, ">") == 0)
    {
        result = (Lhs > Rhs);
    }

    //
    // ">=" or "=>" for GREATER THAN or EQUAL.
    //

    else if(strcmp(Operator, ">=") == 0 || strcmp(Operator, "=>") == 0)
    {
        result = (Lhs >= Rhs);
    }
    else
    {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Invalid operator %s used!\n", Operator);
#endif //_CM_LDR_
    }

    return (result);
}

PVOID
CmpFindPattern(
    IN PCHAR Buffer,
    IN ULONG BufSize,
    IN PCHAR Pattern,
    IN ULONG PatSize,
    IN BOOLEAN IgnoreCase,
    IN ULONG Step
    )

/*++

    Routine Description:

        This routine searches the buffer for the specified pattern of data.

    Input Parameters:

        Buffer - Buffer to be searched.

        BufSize - Size of this buffer.

        Pattern - Pattern to be searched.

        PatSize - Size of the pattern.

        IgnoreCase - TRUE if the search is to be case insensitive.

    Return Value:

        Returns the pointer into the buffer where the pattern is first found.

--*/

{
    PCHAR   bufEnd;

    if (PatSize > BufSize)
    {
        return (NULL);
    }

    if (PatSize == 0)
    {
        PatSize = strlen(Pattern);
    }

    if (Step == 0)
    {
        Step = 1;
    }

    for (   bufEnd = Buffer + BufSize;
            Buffer + PatSize < bufEnd;
            Buffer += Step)
    {
        if (IgnoreCase)
        {
            if (_strnicmp(Buffer, Pattern, PatSize) == 0)
            {
                return (Buffer);
            }
        }
        else
        {
            if (strncmp(Buffer, Pattern, PatSize) == 0)
            {
                return (Buffer);
            }
        }
    }

    return (NULL);
 }

 ULONG
 CmpGetPnPBIOSTableAddress(
    VOID
    )

/*++

    Routine Description:

        This routine searches the BIOS ROM for the PnP BIOS installation
        structure.

    Input Parameters:

        None.

    Return Value:

        Returns the physical address in the ROM BIOS where the PnP
        BIOS structure is located.

--*/

{
    static ULONG    tableAddress = (ULONG)-1;
    PVOID           baseAddress;
    PPNP_BIOS_TABLE address;
    PPNP_BIOS_TABLE lastAddress;
    ULONG           i;
    ULONG           checksum;

    if (tableAddress == (ULONG)-1)
    {
        //
        // Search for the PnPBIOS structure in the BIOS ROM.
        //

        address = (PPNP_BIOS_TABLE)CmpMapPhysicalAddress(&baseAddress, 0xF0000, SYSTEM_BIOS_LENGTH);
        if (address)
        {
            for (   lastAddress = (PPNP_BIOS_TABLE)((PCHAR)address + SYSTEM_BIOS_LENGTH - 0x10);
                    address < lastAddress;
                    (PCHAR)address += 0x10)
            {
                if (address->Signature == PNPBIOS_SIGNATURE)
                {
                    for (   i = 0, checksum = 0;
                            i < address->Length;
                            i++)
                    {
                        checksum += ((PUCHAR)address)[i];
                    }

                    if (    (checksum & 0xFF) == 0 &&
                            address->Length >= 0x21)
                    {
                        tableAddress = 0xF0000 + (SYSTEM_BIOS_LENGTH - 10) - (ULONG)((PCHAR)lastAddress - (PCHAR)address);
                        break;
                    }
                }
            }

            //
            // Unmap the physical address.
            //

            ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
        }
    }

    return (tableAddress);
}

PDESCRIPTION_HEADER
CmpFindACPITable(
    IN ULONG        Signature,
    IN OUT PULONG   Length
    )
{
    PDESCRIPTION_HEADER     header      = NULL;
    PDESCRIPTION_HEADER     tempHeader  = NULL;
    static PHYSICAL_ADDRESS rsdtAddress = { -1, -1 };
    ULONG                   length      = 0;

    //
    // Use the cached location of RSDT address if available.
    //
    if (rsdtAddress.QuadPart == -1) {

        NTSTATUS                status;
        PACPI_BIOS_MULTI_NODE   rsdpMulti;

        rsdtAddress.QuadPart = 0;
        //
        // Get the multinode
        //
        status = CmpFindRSDTTable( &rsdpMulti );
        if (!NT_SUCCESS(status)) {

            return NULL;

        }

        //
        // Map the address
        //
        rsdtAddress.LowPart = rsdpMulti->RsdtAddress.LowPart;
        rsdtAddress.HighPart = rsdpMulti->RsdtAddress.HighPart;

        //
        // Done with the multinode
        //
        ExFreePool( rsdpMulti );

    }

    //
    // If we have an address
    //
    if (rsdtAddress.QuadPart) {

        //
        // Map in the the rsdt table
        //
        tempHeader = MmMapIoSpace(
            rsdtAddress,
            sizeof(DESCRIPTION_HEADER),
            MmCached
            );
        if (tempHeader == NULL) {

#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFindACPITable: Cannot map RSDT at %I64x\n", rsdtAddress.QuadPart);
#endif //_CM_LDR_
            return NULL;

        }

        //
        // If what we are looking for is the RSDT, then we are done
        //
        if (Signature == RSDT_SIGNATURE) {

            header = tempHeader;
            length = sizeof(DESCRIPTION_HEADER);

        } else if (Signature == DSDT_SIGNATURE) {

            PFADT               fadt;
            PHYSICAL_ADDRESS    dsdtAddress;
            ULONG               tempLength;

            fadt = (PFADT) CmpFindACPITable( FADT_SIGNATURE, &length );
            if (fadt) {

                dsdtAddress.HighPart = 0;
                dsdtAddress.LowPart = fadt->dsdt;

                //
                // Done with the FADT
                //
                MmUnmapIoSpace( fadt, length );

                //
                // Map in the dsdt table
                //
                header = MmMapIoSpace(
                    dsdtAddress,
                    sizeof(DESCRIPTION_HEADER),
                    MmCached
                    );
                if (header == NULL) {

#ifndef _CM_LDR_
                    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,
                        "CmpFindACPITable: Cannot map DSDT at %I64x\n",
                        dsdtAddress.QuadPart
                        );
#endif //_CM_LDR_
                    MmUnmapIoSpace( tempHeader, sizeof(DESCRIPTION_HEADER) );
                    return NULL;

                }
                length = sizeof(DESCRIPTION_HEADER);

            } else {

#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFindACPITable: Cannot find FADT\n");
#endif //_CM_LDR_
                MmUnmapIoSpace( tempHeader, sizeof(DESCRIPTION_HEADER) );
                return NULL;

            }

        } else {

            PHYSICAL_ADDRESS    tableAddress;
            PRSDT               rsdt;
            ULONG               i;
            ULONG               num;
            ULONG               rsdtLength;

            //
            // Map in the entire RSDT
            //
            rsdtLength = tempHeader->Length;
            rsdt = (PRSDT) MmMapIoSpace( rsdtAddress, rsdtLength, MmCached );
            if (rsdt == NULL) {

#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,
                    "CmpFindACPITable: Cannot map RSDT at %I64x\n",
                    rsdtAddress.QuadPart
                    );
#endif //_CM_LDR_
                MmUnmapIoSpace( tempHeader, sizeof(DESCRIPTION_HEADER) );
                return NULL;

            }

            //
            // Done with the temp header
            //
            MmUnmapIoSpace( tempHeader, sizeof(DESCRIPTION_HEADER) );

            //
            // Look at all the table entries for the header that we care about
            //
            num = TABLE_ENTRIES_FROM_RSDT_POINTER( rsdt );
            for (i = 0; i < num ; i ++) {

                //
                // Get the address of the table
                //
                tableAddress.HighPart = 0;
                tableAddress.LowPart = rsdt->Tables[i];

                //
                // Map in the header
                //
                tempHeader = MmMapIoSpace(
                    tableAddress,
                    sizeof(DESCRIPTION_HEADER),
                    MmCached
                    );
                if (!tempHeader) {

#ifndef _CM_LDR_
                    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,
                        "CmpFindACPITable: Cannot map header at %I64x\n",
                        tableAddress.QuadPart
                        );
#endif //_CM_LDR_
                    MmUnmapIoSpace( rsdt, rsdtLength );
                    return NULL;

                }

                //
                // Signature check
                //
                if (tempHeader->Signature != Signature) {

                    MmUnmapIoSpace( tempHeader, sizeof(DESCRIPTION_HEADER) );
                    continue;

                }

                //
                // Are we looking at the FADT?
                //
                if (Signature == FADT_SIGNATURE) {

                    //
                    // Map the entire table for this one
                    //
                    length = tempHeader->Length;
                    header = MmMapIoSpace( tableAddress, length, MmCached );

                    //
                    // Unmap the old table
                    //
                    MmUnmapIoSpace( tempHeader, sizeof(DESCRIPTION_HEADER) );

                    //
                    // Did we successfully map the header?
                    //
                    if (header == NULL ) {

#ifndef _CM_LDR_
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,
                            "CmpFindACPITable: Cannot map FADT at %I64x\n",
                            tableAddress.QuadPart
                            );
#endif //_CM_LDR_
                        MmUnmapIoSpace( rsdt, rsdtLength );
                        return NULL;

                    }

                } else {

                    //
                    // Remember where the table and length are stored
                    //
                    length = sizeof(DESCRIPTION_HEADER);
                    header = tempHeader;

                }

            } // for

            //
            // Done with the rsdt
            //
            MmUnmapIoSpace( rsdt, rsdtLength );

        }

        //
        // If we found the table, return its length.
        //
        if (Length) {

            if (header) {

                *Length = length;

            } else {

                *Length = 0;

            }

        }

    }

    return (header);
}

NTSTATUS
CmpFindRSDTTable(
    OUT PACPI_BIOS_MULTI_NODE   *Rsdt
    )
/*++

Routine Description:

    This function looks into the registry to find the ACPI RSDT,
    which was stored there by ntdetect.com

Arguments:

    RsdtPtr - Pointer to a buffer that contains the ACPI
              Root System Description Pointer Structure.
              The caller is responsible for freeing this
              buffer.  Note:  This is returned in non-paged
              pool.

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    BOOLEAN                         same;
    HANDLE                          hMFunc;
    HANDLE                          hBus;
    NTSTATUS                        status;
    OBJECT_ATTRIBUTES               objectAttributes;
    PACPI_BIOS_MULTI_NODE           multiNode;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PCM_PARTIAL_RESOURCE_LIST       prl;
    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo;
    PWSTR                           p;
    ULONG                           i;
    ULONG                           length;
    ULONG                           multiNodeSize;
    UNICODE_STRING                  unicodeString;
    UNICODE_STRING                  unicodeValueName;
    UNICODE_STRING                  biosId;
    WCHAR                           wbuffer[10];

    PAGED_CODE();

    //
    // Look in the registry for the "ACPI BIOS bus" data
    //
    RtlInitUnicodeString( &unicodeString, rgzMultiFunctionAdapter );
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );
    status = ZwOpenKey( &hMFunc, KEY_READ, &objectAttributes );
    if (!NT_SUCCESS(status)) {

#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_WARNING_LEVEL,"CmpFindRSDTTable: Cannot open MultifunctionAdapter registry key.\n");
#endif //_CM_LDR_
        return status;

    }

    //
    // We will need to make a unicode string that we can use to enumerate
    // the subkeys of the MFA key
    //
    unicodeString.Buffer = wbuffer;
    unicodeString.MaximumLength = sizeof(wbuffer);
    RtlInitUnicodeString( &biosId, rgzBIOSIdentifier );

    //
    // Loop over all subkeys
    //
    for (i = 0; TRUE; i++) {

        //
        // Turn the number into a key name
        //
        RtlIntegerToUnicodeString( i, 10, &unicodeString);
        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL
            );

        //
        // Open the named subkey
        //
        status = ZwOpenKey( &hBus, KEY_READ, &objectAttributes );
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_WARNING_LEVEL,"CmpFindRSDTTable: ACPI BIOS MultifunctionAdapter registry key not found.\n");
#endif //_CM_LDR_
            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;

        }

        //
        // Check the Indentifier to see if this is an ACPI BIOS entry
        //
        status = CmpGetRegistryValue( hBus, (PWCHAR)rgzAcpiIdentifier, &valueInfo );
        if (!NT_SUCCESS (status)) {

            ZwClose( hBus );
            continue;

        }

        p = (PWSTR) ((PUCHAR) valueInfo->Data);
        unicodeValueName.Buffer = p;
        unicodeValueName.MaximumLength = (USHORT)valueInfo->DataLength;
        length = valueInfo->DataLength;

        //
        // Determine the real length of the ID string
        //
        while (length) {

            if (p[length / sizeof(WCHAR) - 1] == UNICODE_NULL) {

                length -= 2;

            } else {

                break;
            }

        }

        //
        // Do we have a match the "ACPI BIOS" identifier?
        //
        unicodeValueName.Length = (USHORT)length;
        same = RtlEqualUnicodeString( &biosId, &unicodeValueName, TRUE );
        ExFreePool( valueInfo );
        if (!same) {

            ZwClose( hBus );
            continue;

        }

        //
        // We do, so get the configuration data
        //
        status = CmpGetRegistryValue(
            hBus,
            (PWCHAR)rgzAcpiConfigurationData,
            &valueInfo
            );
        ZwClose( hBus );
        if (!NT_SUCCESS(status)) {

            continue ;

        }

        //
        // The data that we want is at the end of the PARTIAL_RESOURCE_LIST
        // descriptor
        //
        prl = (PCM_PARTIAL_RESOURCE_LIST)(valueInfo->Data);
        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)
            ( (PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST) );
        break;

    }

    //
    // Calculate the size of the data so that we can make a copy
    //
    multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
        ( (ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY) );
    *Rsdt = (PACPI_BIOS_MULTI_NODE) ExAllocatePoolWithTag(
        NonPagedPool,
        multiNodeSize,
        'IPCA'
        );
    if (*Rsdt == NULL) {

        ExFreePool( valueInfo );
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlCopyMemory(*Rsdt, multiNode, multiNodeSize);

    //
    // Done with the key memory
    //
    ExFreePool(valueInfo);

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
CmpGetRegistryValue(
    IN  HANDLE                          KeyHandle,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION  *Information
    )
/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    NTSTATUS                        status;
    PKEY_VALUE_PARTIAL_INFORMATION  infoBuffer;
    ULONG                           keyValueLength;
    UNICODE_STRING                  unicodeString;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //
    status = ZwQueryValueKey(
        KeyHandle,
        &unicodeString,
        KeyValuePartialInformation,
        (PVOID) NULL,
        0,
        &keyValueLength
        );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {

        return status;

    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //
    infoBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        keyValueLength,
        'IPCA'
        );
    if (!infoBuffer) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Query the data for the key value.
    //
    status = ZwQueryValueKey(
        KeyHandle,
        &unicodeString,
        KeyValuePartialInformation,
        infoBuffer,
        keyValueLength,
        &keyValueLength
        );
    if (!NT_SUCCESS( status )) {

        ExFreePool( infoBuffer );

        return status;

    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //
    *Information = infoBuffer;
    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\i386\parseini.c ===
//depot/Lab01_N/base/ntos/config/i386/parseini.c#4 - edit change 6451 (text)
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    parseini.c

Abstract:

    This modules contains routines to parse an inf file. This is based on
    the code from the osloader. All indices are zero based.

Author:

    Santosh Jodh (santoshj) 08-Aug-1998


Environment:

    Kernel mode.

Revision History:

--*/

#include "cmp.h"
#include "string.h"
#include "ctype.h"
#include "stdlib.h"
#include "parseini.h"

typedef struct _value   VALUE,      *PVALUE;
typedef struct _line    LINE,       *PLINE;
typedef struct _section SECTION,    *PSECTION;
typedef struct _inf     INF,        *PINF;
typedef struct _cm_token   CM_TOKEN,*PCM_TOKEN;
typedef enum _tokentype TOKENTYPE,  *PTOKENTTYPE;
typedef enum _stringsSectionType    STRINGSSECTIONTYPE;;

struct _value
{
    PVALUE  pNext;
    PCHAR   pName;
    BOOLEAN Allocated;
};

struct _line
{
    PLINE   pNext;
    PCHAR   pName;
    PVALUE  pValue;
    BOOLEAN Allocated;
};

struct _section
{
    PSECTION    pNext;
    PCHAR       pName;
    PLINE       pLine;
    BOOLEAN     Allocated;
};

struct _inf
{
    PSECTION            pSection;
    PSECTION            pSectionRecord;
    PLINE               pLineRecord;
    PVALUE              pValueRecord;
    STRINGSSECTIONTYPE  StringsSectionType;
    PSECTION            StringsSection;
};

//
// [Strings] section types.
//
enum _stringsSectionType
{
    StringsSectionNone,
    StringsSectionPlain,
    StringsSectionLoosePrimaryMatch,
    StringsSectionExactPrimaryMatch,
    StringsSectionExactMatch
};

enum _tokentype
{
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
};

struct _cm_token
{
    TOKENTYPE   Type;
    PCHAR       pValue;
    BOOLEAN     Allocated;
};

VOID
CmpFreeValueList(
    IN PVALUE pValue
    );

VOID
CmpFreeLineList(
    IN PLINE pLine
    );

VOID
CmpFreeSectionList(
    IN PSECTION pSection
    );

PCHAR
CmpProcessForSimpleStringSub(
    IN PINF pInf,
    IN PCHAR String
    );

BOOLEAN
CmpAppendSection(
    IN PINF  pInf,
    IN PCHAR pSectionName,
    IN BOOLEAN Allocated
    );

BOOLEAN
CmpAppendLine(
    IN PINF pInf,
    IN PCHAR pLineKey,
    IN BOOLEAN Allocated
    );

BOOLEAN
CmpAppendValue(
    IN PINF pInf,
    IN PCHAR pValueString,
    IN BOOLEAN Allocated
    );

VOID
CmpGetToken(
    IN OUT PCHAR *Stream,
    IN PCHAR MaxStream,
    IN OUT PULONG LineNumber,
    IN OUT PCM_TOKEN Token
    );

PINF
CmpParseInfBuffer(
    IN PCHAR Buffer,
    IN ULONG Size,
    IN OUT PULONG ErrorLine
    );

PVALUE
CmpSearchValueInLine(
    IN PLINE pLine,
    IN ULONG ValueIndex
    );

PLINE
CmpSearchLineInSectionByIndex(
    IN PSECTION pSection,
    IN ULONG    LineIndex
    );

PSECTION
CmpSearchSectionByName(
    IN PINF  pInf,
    IN PCHAR SectionName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpFreeValueList)
#pragma alloc_text(INIT,CmpFreeLineList)
#pragma alloc_text(INIT,CmpFreeSectionList)
#pragma alloc_text(INIT,CmpProcessForSimpleStringSub)
#pragma alloc_text(INIT,CmpAppendSection)
#pragma alloc_text(INIT,CmpAppendLine)
#pragma alloc_text(INIT,CmpAppendValue)
#pragma alloc_text(INIT,CmpGetToken)
#pragma alloc_text(INIT,CmpParseInfBuffer)
#pragma alloc_text(INIT,CmpSearchValueInLine)
#pragma alloc_text(INIT,CmpSearchLineInSectionByIndex)
#pragma alloc_text(INIT,CmpSearchSectionByName)
#pragma alloc_text(INIT,CmpSearchInfLine)
#pragma alloc_text(INIT,CmpOpenInfFile)
#pragma alloc_text(INIT,CmpCloseInfFile)
#pragma alloc_text(INIT,CmpGetKeyName)
#pragma alloc_text(INIT,CmpSearchInfSection)
#pragma alloc_text(INIT,CmpGetSectionLineIndex)
#pragma alloc_text(INIT,CmpGetSectionLineIndexValueCount)
#pragma alloc_text(INIT,CmpGetIntField)
#pragma alloc_text(INIT,CmpGetBinaryField)
#endif


//
// Globals used by the token parser.
// String terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const CHAR  StringTerminators[] = "[]=,\t \"\n\f\v\r";
CHAR const* const QStringTerminators = StringTerminators + 6;
const CHAR EmptyValue[] = "";
const CHAR  DblSpaceSection[] = "DBLSPACE_SECTION";

BOOLEAN
CmpAppendSection(
    IN PINF  pInf,
    IN PCHAR pSectionName,
    IN BOOLEAN Allocated
    )

/*++

    Routine Description:

        This routine creates a new section or merges with an existing section in the inf.

    Input Parameters:

        pInf - Pointer to the inf to be processed.

        pSectionName - Name of the section.

        Allocated - TRUE if memory was allocated for the section name.

    Return Value:

        TRUE iff successful.

--*/

{
    PSECTION            pNewSection;
    PLINE               pLineRecord;
    STRINGSSECTIONTYPE  type;
    USHORT              id;
    USHORT              threadLang;
    PCHAR               p;

    //
    // Check to see if INF initialised and the parameters passed in is valid
    //

    if (    pInf == (PINF)NULL ||
            pSectionName == (PCHAR)NULL)
    {
        return (FALSE);
    }

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //

    for(    pNewSection = pInf->pSection;
            pNewSection;
            pNewSection = pNewSection->pNext)
    {
        if(pNewSection->pName && _stricmp(pNewSection->pName,pSectionName) == 0)
        {
            break;
        }
    }

    if(pNewSection)
    {
        //
        // Set pLineRecord to point to the last line currently in the section.
        //

        for(    pLineRecord = pNewSection->pLine;
                pLineRecord && pLineRecord->pNext;
                pLineRecord = pLineRecord->pNext);

        pInf->pLineRecord = pLineRecord;
    }
    else
    {
        //
        // Allocate memory for the new section
        //

        pNewSection = (PSECTION)ExAllocatePoolWithTag(PagedPool, sizeof(SECTION), CM_PARSEINI_TAG);

        if (pNewSection == (PSECTION)NULL)
        {
            ASSERT(pNewSection);
            return (FALSE);
        }

        //
        // Initialize the new section.
        //

        pNewSection->pNext = NULL;
        pNewSection->pLine = NULL;
        pNewSection->pName = pSectionName;
        pNewSection->Allocated = Allocated;

        //
        // Link it in.
        //

        pNewSection->pNext = pInf->pSection;
        pInf->pSection = pNewSection;

        if(_strnicmp(pSectionName, "Strings", 7) == 0)
        {
            type = StringsSectionNone;

            if(pSectionName[7] == '.')
            {
                //
                // The langid part must be in the form of 4 hex digits.
                //

                id = (USHORT)strtoul(pSectionName + 8, &p, 16);
                if(p == (pSectionName + 8 + 5) && *p == '\0')
                {
                    threadLang = LANGIDFROMLCID(NtCurrentTeb()->CurrentLocale);

                    if(threadLang == id)
                    {
                        type = StringsSectionExactMatch;
                    }
                    else
                    {
                        if(id == PRIMARYLANGID(threadLang))
                        {
                            type = StringsSectionExactPrimaryMatch;
                        }
                        else
                        {
                            if(PRIMARYLANGID(id) == PRIMARYLANGID(threadLang))
                            {
                                type = StringsSectionLoosePrimaryMatch;
                            }
                        }
                    }
                }
            }
            else
            {
                if(!pSectionName[7])
                {
                    type = StringsSectionPlain;
                }
            }

            if(type > pInf->StringsSectionType)
            {
                pInf->StringsSection = pNewSection;
            }
        }

        //
        // Reset the current line record.
        //

        pInf->pLineRecord = NULL;
    }

    pInf->pSectionRecord = pNewSection;
    pInf->pValueRecord = NULL;

    return (TRUE);
}

BOOLEAN
CmpAppendLine(
    IN PINF pInf,
    IN PCHAR pLineKey,
    IN BOOLEAN Allocated
    )

/*++

    Routine Description:

        This routine creates a new line and appends it to the end of the line list.

    Input Parameters:

        pInf - Pointer to the inf to be processed.

        pLineKey - Name of the line.

        Allocated - TRUE if memory was allocated for the line name.

    Return Value:

        TRUE iff successful.

--*/

{
    PLINE pNewLine;

    //
    // Check to see if current section initialized.
    //

    if (pInf->pSectionRecord == (PSECTION)NULL)
    {
        return (FALSE);
    }

    //
    // Allocate memory for the new Line.
    //

    pNewLine = (PLINE)ExAllocatePoolWithTag(PagedPool, sizeof(LINE), CM_PARSEINI_TAG);
    if (pNewLine == (PLINE)NULL)
    {
        ASSERT(pNewLine);
        return (FALSE);
    }

    //
    // Link it in.
    //

    pNewLine->pNext  = (PLINE)NULL;
    pNewLine->pValue = (PVALUE)NULL;
    pNewLine->pName  = pLineKey;
    pNewLine->Allocated = Allocated;

    if (pInf->pLineRecord == (PLINE)NULL)
    {
        pInf->pSectionRecord->pLine = pNewLine;
    }
    else
    {
        pInf->pLineRecord->pNext = pNewLine;
    }

    pInf->pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pInf->pValueRecord = (PVALUE)NULL;

    return (TRUE);
}

BOOLEAN
CmpAppendValue(
    IN PINF pInf,
    IN PCHAR pValueString,
    IN BOOLEAN Allocated
    )

/*++

    Routine Description:

        This routine creates a new value and appends it to the end of the value list.

    Input Parameters:

        pInf - Pointer to the inf to be processed.

        pValueString - Name of the value.

        Allocated - TRUE if memory was allocated for the value name.

    Return Value:

        TRUE iff successful.

--*/

{
    PVALUE pNewValue;

    //
    // Check to see if current line record has been initialised and
    // the parameter passed in is valid.
    //

    if (    pInf->pLineRecord == (PLINE)NULL ||
            pValueString == (PCHAR)NULL)
    {
        return (FALSE);
    }

    //
    // Allocate memory for the new value record.
    //

    pNewValue = (PVALUE)ExAllocatePoolWithTag(PagedPool, sizeof(VALUE), CM_PARSEINI_TAG);

    if (pNewValue == (PVALUE)NULL)
    {
        ASSERT(pNewValue);
        return (FALSE);
    }

    //
    // Link it in.
    //

    pNewValue->pNext  = (PVALUE)NULL;
    pNewValue->pName  = pValueString;
    pNewValue->Allocated = Allocated;

    if (pInf->pValueRecord == (PVALUE)NULL)
    {
        pInf->pLineRecord->pValue = pNewValue;
    }
    else
    {
        pInf->pValueRecord->pNext = pNewValue;
    }

    pInf->pValueRecord = pNewValue;

    return (TRUE);
}

VOID
CmpGetToken(
    IN OUT PCHAR *Stream,
    IN PCHAR MaxStream,
    IN OUT PULONG LineNumber,
    IN OUT PCM_TOKEN Token
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    None.

--*/

{

    PCHAR   pch;
    PCHAR   pchStart;
    PCHAR   pchNew;
    ULONG   length;
    BOOLEAN done;

    Token->Allocated = FALSE;
    Token->pValue = NULL;

    do
    {
        done = TRUE;

        //
        //  Skip whitespace (except for EOL).
        //

        for (   pch = *Stream;
                pch < MaxStream && *pch != '\n' && isspace(*pch);
                pch++);

        //
        // Check for comments and remove them.
        //

        if (    pch < MaxStream &&
                (*pch == '#' || *pch == ';'))
        {
            while (pch < MaxStream && *pch != '\n')
            {
                pch++;
            }
        }

        //
        // Check to see if EOF has been reached, set the token to the right
        // value.
        //

        if (pch >= MaxStream || *pch == 26)
        {
            *Stream = pch;
            Token->Type  = TOK_EOF;
            Token->pValue = NULL;

            return;
        }

        switch (*pch)
        {
            case '[':

                pch++;
                Token->Type  = TOK_LBRACE;
                break;

            case ']':

                pch++;
                Token->Type  = TOK_RBRACE;
                break;

            case '=':

                pch++;
                Token->Type  = TOK_EQUAL;
                break;

            case ',':

                pch++;
                Token->Type  = TOK_COMMA;
                break;

            case '\n':

                pch++;
                Token->Type  = TOK_EOL;
                break;

            case '\"':

                pch++;

                //
                // Determine quoted string.
                //

                for (   pchStart = pch;
                        pch < MaxStream && (strchr(QStringTerminators, *pch) == NULL);
                        pch++);

                if (pch >= MaxStream || *pch != '\"')
                {
                    Token->Type   = TOK_ERRPARSE;
                }
                else
                {

                    //
                    // We require a quoted string to end with a double-quote.
                    // (If the string ended with anything else, the if() above
                    // would not have let us into the else clause.) The quote
                    // character is irrelevent, however, and can be overwritten.
                    // So we'll save some heap and use the string in-place.
                    // No need to make a copy.
                    //
                    // Note that this alters the image of txtsetup.sif we pass
                    // to setupdd.sys. Thus the inf parser in setupdd.sys must
                    // be able to treat a nul character as if it were a terminating
                    // double quote.
                    //

                    *pch++ = '\0';
                    Token->Type = TOK_STRING;
                    Token->pValue = pchStart;
                }
                break;

            case '\\':

                for (   pchNew = ++pch;
                        pchNew < MaxStream &&
                            *pchNew != '\n' && isspace(*pchNew);
                        pchNew++);

                if (*pchNew == '\n')
                {
                    pch = pchNew + 1;
                    done = FALSE;
                    break;
                }

            default:

                //
                // Determine regular string.
                //

                for (   pchStart = pch;
                        pch < MaxStream && (strchr(StringTerminators, *pch) == NULL);
                        pch++);

                if (pch == pchStart)
                {
                    pch++;
                    Token->Type  = TOK_ERRPARSE;
                }
                else
                {
                    length = (ULONG)(pch - pchStart);
                    pchNew = ExAllocatePoolWithTag(PagedPool, length + 1, CM_PARSEINI_TAG);
                    if (pchNew == NULL)
                    {
                        ASSERT(pchNew);
                        Token->Type = TOK_ERRNOMEM;
                    }
                    else
                    {
                        strncpy(pchNew, pchStart, length);
                        pchNew[length] = 0;
                        Token->Type = TOK_STRING;
                        Token->pValue = pchNew;
                        Token->Allocated = TRUE;
                    }
                }
                break;
        }

        *Stream = pch;
    }
    while (!done);

    return;
}

PINF
CmpParseInfBuffer(
    IN PCHAR Buffer,
    IN ULONG Size,
    IN OUT PULONG ErrorLine
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer.

   ErrorLine - if a parse error occurs, this variable receives the line
        number of the line containing the error.


Return Value:

   PVOID - INF handle ptr to be used in subsequent INF calls.

--*/

{
    PINF        pInf;
    ULONG       state;
    PCHAR       stream;
    PCHAR       maxStream;
    PCHAR       pchSectionName;
    PCHAR       pchValue;
    CM_TOKEN    token;
    BOOLEAN     done;
    BOOLEAN     error;
    ULONG       infLine;
    BOOLEAN     allocated;

    //
    // Allocate memory for the INF record.
    //

    pInf = (PINF)ExAllocatePoolWithTag(PagedPool, sizeof(INF), CM_PARSEINI_TAG);

    if (pInf == NULL)
    {
        ASSERT(pInf);
        return (pInf);
    }

    pInf->pSection = NULL;
    pInf->pSectionRecord = NULL;
    pInf->pLineRecord = NULL;
    pInf->pValueRecord = NULL;
    pInf->StringsSectionType = StringsSectionNone;
    pInf->StringsSection = NULL;

    //
    // Set initial state.
    //

    state     = 1;
    stream    = Buffer;
    maxStream = Buffer + Size;
    pchSectionName = NULL;
    pchValue = NULL;
    done      = FALSE;
    error     = FALSE;
    infLine = 1;

    //
    // Enter token processing loop.
    //

    while (!done)
    {

       CmpGetToken(&stream, maxStream, &infLine, &token);

        switch (state)
        {
            //
            // STATE1: Start of file, this state remains till first
            //         section is found
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
            //               TOK_STRING when reading Dblspace.inf
            //

            case 1:

                switch (token.Type)
                {
                    case TOK_EOL:

                        break;

                    case TOK_EOF:

                        done = TRUE;

                        break;

                    case TOK_LBRACE:

                        state = 2;

                        break;

                    case TOK_STRING:

                        pchSectionName = ExAllocatePoolWithTag(PagedPool, sizeof(DblSpaceSection), CM_PARSEINI_TAG);
                        if (pchSectionName)
                        {
                            strcpy(pchSectionName, DblSpaceSection);
                            pchValue = token.pValue;
                            allocated = TRUE;
                            token.Allocated = TRUE;
                            if (CmpAppendSection(pInf, pchSectionName, TRUE))
                            {
                                pchSectionName = NULL;
                                state = 6;
                            }
                            else
                            {
                                error = done = TRUE;
                            }
                        }
                        else
                        {
                            ASSERT(pchSectionName);
                            error = done = TRUE;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 2: Section LBRACE has been received, expecting STRING
            //
            // Valid Tokens: TOK_STRING, TOK_RBRACE
            //

            case 2:

                switch (token.Type)
                {
                    case TOK_STRING:

                        state = 3;
                        pchSectionName = token.pValue;
                        allocated = token.Allocated;

                        break;

                    case TOK_RBRACE:

                        token.pValue = (PCHAR)EmptyValue;
                        token.Allocated = FALSE;
                        allocated = FALSE;
                        state = 4;

                        break;

                    default:

                        error = done = TRUE;

                        break;

                }

                break;

            //
            // STATE 3: Section Name received, expecting RBRACE
            //
            // Valid Tokens: TOK_RBRACE
            //

            case 3:

                switch (token.Type)
                {
                    case TOK_RBRACE:

                        state = 4;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 4: Section Definition Complete, expecting EOL
            //
            // Valid Tokens: TOK_EOL, TOK_EOF
            //

            case 4:

                switch (token.Type)
                {

                    case TOK_EOL:

                        if (!CmpAppendSection(pInf, pchSectionName, allocated))
                        {

                            error = done = TRUE;
                        }
                        else
                        {
                            pchSectionName = NULL;
                            state = 5;
                        }

                        break;

                    case TOK_EOF:

                        if (!CmpAppendSection(pInf, pchSectionName, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchSectionName = NULL;
                            done = TRUE;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 5: Expecting Section Lines
            //
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
            //

            case 5:

                switch (token.Type)
                {
                    case TOK_EOL:

                        break;

                    case TOK_EOF:

                        done = TRUE;

                        break;

                    case TOK_STRING:

                        pchValue = token.pValue;
                        allocated = token.Allocated;
                        state = 6;

                        break;

                    case TOK_LBRACE:

                        state = 2;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 6: String returned, not sure whether it is key or value
            //
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
            //

            case 6:

                switch (token.Type)
                {

                    case TOK_EOL:

                        if (    !CmpAppendLine(pInf, NULL, FALSE) ||
                                !CmpAppendValue(pInf, pchValue, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchValue = NULL;
                            state = 5;
                        }

                        break;

                    case TOK_EOF:

                        if (    !CmpAppendLine(pInf, NULL, FALSE) ||
                                !CmpAppendValue(pInf, pchValue, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchValue = NULL;
                            done = TRUE;
                        }

                        break;

                    case TOK_COMMA:

                        if (    !CmpAppendLine(pInf, NULL, FALSE) ||
                                !CmpAppendValue(pInf, pchValue, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchValue = NULL;
                            state = 7;
                        }

                        break;

                    case TOK_EQUAL:

                        if (!CmpAppendLine(pInf, pchValue, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchValue = NULL;
                            state = 8;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 7: Comma received, Expecting another string
            //
            // Valid Tokens: TOK_STRING TOK_COMMA
            //   A comma means we have an empty value.
            //

            case 7:

                switch (token.Type)
                {

                    case TOK_COMMA:

                        token.pValue = (PCHAR)EmptyValue;
                        token.Allocated = FALSE;
                        allocated = FALSE;
                        if (!CmpAppendValue(pInf, token.pValue, FALSE))
                        {
                            error = done = TRUE;
                        }

                        //
                        // State stays at 7 because we are expecting a string
                        //

                        break;

                    case TOK_STRING:

                        if (!CmpAppendValue(pInf, token.pValue, token.Allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            state = 9;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 8: Equal received, Expecting another string
            //          If none, assume there is a single empty string on the RHS
            //
            // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF
            //

            case 8:

                switch (token.Type)
                {
                    case TOK_EOF:

                        token.pValue = (PCHAR)EmptyValue;
                        token.Allocated = FALSE;
                        allocated = FALSE;
                        if(!CmpAppendValue(pInf, token.pValue, FALSE))
                        {
                            error = TRUE;
                        }

                        done = TRUE;

                        break;

                    case TOK_EOL:

                        token.pValue = (PCHAR)EmptyValue;
                        token.Allocated = FALSE;
                        allocated = FALSE;
                        if(!CmpAppendValue(pInf, token.pValue, FALSE))
                        {
                            error = TRUE;
                            done = TRUE;
                        }
                        else
                        {
                            state = 5;
                        }

                        break;

                    case TOK_STRING:

                        if (!CmpAppendValue(pInf, token.pValue, FALSE))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            state = 9;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 9: String received after equal, value string
            //
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
            //

            case 9:

                switch (token.Type)
                {
                    case TOK_EOL:

                        state = 5;

                        break;

                    case TOK_EOF:

                        done = TRUE;

                        break;

                    case TOK_COMMA:

                        state = 7;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 10: Value string definitely received
            //
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
            //

            case 10:

                switch (token.Type)
                {
                    case TOK_EOL:

                        state =5;

                        break;

                    case TOK_EOF:

                        done = TRUE;

                        break;

                    case TOK_COMMA:

                        state = 7;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            default:

                error = done = TRUE;

                break;

        } // END switch(state)


        if (error)
        {
            *ErrorLine = infLine;
            if (pchSectionName != (PCHAR)NULL && allocated)
            {
                ExFreePool(pchSectionName);
            }

            if (pchValue != (PCHAR)NULL && allocated)
            {
                ExFreePool(pchValue);
            }

            ExFreePool(pInf);

            pInf = (PINF)NULL;
        }
        else
        {
            //
            // Keep track of line numbers for error reporting.
            //

            if (token.Type == TOK_EOL)
            {
                infLine++;
            }
        }

    } // END while

    if (pInf)
    {
        pInf->pSectionRecord = NULL;
    }

    return(pInf);
}

PCHAR
CmpProcessForSimpleStringSub(
    IN PINF pInf,
    IN PCHAR String
    )

/*++

    Routine Description:

        This routine substitutes reference to string in the STRINGS section of the inf.

    Input Parameters:

        pInf - Pointer to the inf to be processed.

        String - String to be substituted.

    Return Value:

        None.

--*/

{
    ULONG       len;
    PCHAR       returnString;
    PSECTION    pSection;
    PLINE       pLine;

    //
    // Assume no substitution necessary.
    //

    returnString = String;
    len = strlen(String);
    pSection = pInf->StringsSection;

    //
    // If it starts and end with % then look it up in the
    // strings section. Note the initial check before doing a
    // wcslen, to preserve performance in the 99% case where
    // there is no substitution.
    //

    if( String[0] == '%' &&
        len > 2 &&
        String[len - 1] == '%' &&
        pSection)
    {

        for(pLine = pSection->pLine; pLine; pLine = pLine->pNext)
        {
            if( pLine->pName &&
                _strnicmp(pLine->pName, String + 1, len - 2) == 0 &&
                pLine->pName[len - 2] == '\0')
            {
                break;
            }
        }

        if(pLine && pLine->pValue && pLine->pValue->pName)
        {
            returnString = pLine->pValue->pName;
        }
    }

    return(returnString);
}

VOID
CmpFreeValueList(
    IN PVALUE pValue
    )

/*++

    Routine Description:

        This routine releases memory for the list of values.

    Input Parameters:

        pValue - Pointer to the value list to be freed.

    Return Value:

        None.

--*/

{
    PVALUE pNext;

    while (pValue)
    {
        //
        // Save the next pointer so we dont access memory after it has
        // been freed.
        //

        pNext = pValue->pNext;

        //
        // Free any data inside this value.
        //

        if (pValue->Allocated && pValue->pName)
        {
            ExFreePool((PVOID)pValue->pName);
        }

        //
        // Free memory for this value.
        //

        ExFreePool(pValue);

        //
        // Go to the next value.
        //

        pValue = pNext;
    }
}

VOID
CmpFreeLineList(
    IN PLINE pLine
    )

/*++

    Routine Description:

        This routine releases memory for the list of lines and
        values under it.

    Input Parameters:

        pLine - Pointer to the line list to be freed.

    Return Value:

        None.

--*/

{
    PLINE pNext;

    while (pLine)
    {
        //
        // Save the next pointer so we dont access memory after it has
        // been freed.
        //

        pNext = pLine->pNext;

        //
        // Free any data inside this Line.
        //

        if (pLine->Allocated && pLine->pName)
        {
            ExFreePool((PVOID)pLine->pName);
        }

        //
        // Free the list of values inside this Line.
        //

        CmpFreeValueList(pLine->pValue);

        //
        // Free memory for this line itself.
        //

        ExFreePool((PVOID)pLine);

        //
        // Go to the next line.
        //

        pLine = pNext;
    }
}

VOID
CmpFreeSectionList(
    IN PSECTION pSection
    )

/*++

    Routine Description:

        This routine releases memory for the list of sections and
        lines under it.

    Input Parameters:

        pSection - Pointer to the section list to be freed.

    Return Value:

        None.

--*/

{
    PSECTION pNext;

    while (pSection)
    {
        //
        // Save the next pointer so we dont access memory after it has
        // been freed.
        //

        pNext = pSection->pNext;

        //
        // Free any data inside this Line.
        //

        if (pSection->Allocated && pSection->pName)
        {
            ExFreePool((PVOID)pSection->pName);
        }

        //
        // Free the list of values inside this Line.
        //

        CmpFreeLineList(pSection->pLine);

        //
        // Free memory for this line itself.
        //

        ExFreePool((PVOID)pSection);

        //
        // Go to the next line.
        //

        pSection = pNext;
    }

}

PVALUE
CmpSearchValueInLine(
    IN PLINE pLine,
    IN ULONG ValueIndex
    )

/*++

    Routine Description:

        This routine searches for the specified value in the inf.

    Input Parameters:

        pLine - Pointer to the line to be searched.

        ValueIndex - Index of the value to be searched.

    Return Value:

        Pointer to the value iff found. Else NULL.

--*/

{
    ULONG   i;
    PVALUE  pValue = NULL;

    if (pLine)
    {
        for (   i = 0, pValue = pLine->pValue;
                i < ValueIndex && pValue;
                i++, pValue = pValue->pNext);
    }

    return (pValue);
}


PSECTION
CmpSearchSectionByName(
    IN PINF  pInf,
    IN PCHAR SectionName
    )

/*++

    Routine Description:

        This routine searches for the specified section in the inf.

    Input Parameters:

        pInf - Pointer to the inf to be searched.

        SectionName - Name of the section to be searched.

    Return Value:

        Pointer to the section iff found. Else NULL.

--*/

{
    PSECTION    pSection = NULL;
    PSECTION    pFirstSearchedSection;

    //
    // Validate the parameters passed in.
    //

    if (pInf && SectionName)
    {
        //
        // Traverse down the section list searching each section for the
        // section name mentioned.
        //

        for (   pSection = pFirstSearchedSection = pInf->pSectionRecord;
                pSection && _stricmp(pSection->pName, SectionName);
                pSection = pSection->pNext);

        //
        // If we did not find the section, search from the beginning.
        //

        if (pSection == NULL)
        {
            for (   pSection = pInf->pSection;
                    pSection && pSection != pFirstSearchedSection;
                    pSection = pSection->pNext)
            {
                if (pSection->pName && _stricmp(pSection->pName, SectionName) == 0)
                {
                    break;
                }
            }

            if (pSection == pFirstSearchedSection)
            {
                pSection = NULL;
            }
        }

        if (pSection)
        {
            pInf->pSectionRecord = pSection;
        }
    }

    //
    // Return the section at which we stopped.
    //

    return (pSection);
}

PLINE
CmpSearchLineInSectionByIndex(
    IN PSECTION pSection,
    IN ULONG    LineIndex
    )

/*++

    Routine Description:

        This routine searches for the specified line in the inf.

    Input Parameters:

        pSection - Pointer to the section to be searched.

        LineIndex - Index of the line to be searched.

    Return Value:

        Pointer to the line iff found. Else NULL.

--*/

{
    PLINE   pLine = NULL;
    ULONG   i;

    //
    // Validate the parameters passed in.
    //

    if (pSection)
    {

        //
        // Traverse down the current line list to the LineIndex line.
        //

        for(    i = 0, pLine = pSection->pLine;
                i < LineIndex && pLine;
                i++, pLine = pLine->pNext);
    }

    //
    // Return the Line found
    //

    return (pLine);
}

PVOID
CmpOpenInfFile(
    IN  PVOID   InfImage,
    IN  ULONG   ImageSize
   )

/*++

    Routine Description:

        This routine opens an handle to the inf.

    Input Parameters:

        InfImage - Pointer to the inf image read into memory.

        ImageSize - Image size.

    Return Value:

        Returns handle to the inf iff successful. Else NULL.

--*/

{
    PINF    infHandle;
    ULONG   errorLine = 0;

    //
    // Parse the inf buffer.
    //

    infHandle = CmpParseInfBuffer(InfImage, ImageSize, &errorLine);

    if (infHandle == NULL)
    {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Error on line %d in CmpOpenInfFile!\n", errorLine);
#endif //_CM_LDR_
    }

    return (infHandle);
}

VOID
CmpCloseInfFile(
    PVOID   InfHandle
    )

/*++

    Routine Description:

        This routine closes the inf handle by releasing any
        memory allocated for it during parsing.

    Input Parameters:

        InfHandle - Handle to the inf to be closed.

    Return Value:

        None.

--*/

{
    if (InfHandle)
    {
        CmpFreeSectionList(((PINF)InfHandle)->pSection);
        ExFreePool(InfHandle);
    }
}

BOOLEAN
CmpSearchInfSection(
    IN PINF  pInf,
    IN PCHAR Section
    )

/*++

    Routine Description:

        This routine searches for the specified section in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

    Return Value:

        TRUE iff section is found in the inf.

--*/

{
    return (CmpSearchSectionByName(pInf, Section) != NULL);
}

PCHAR
CmpGetKeyName(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine returns the name of the specified line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Pointer to the name of line in the inf iff successful. Else NULL.

--*/

{
    PSECTION    pSection;
    PLINE       pLine;

    //
    // First search the section.
    //

    pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
    if(pSection)
    {
        //
        // Get the line in the section.
        //

        pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
        if(pLine)
        {
            return(pLine->pName);
        }
    }

    return (NULL);
}

BOOLEAN
CmpSearchInfLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine searches for the specified line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        TRUE iff line is found in the section in the inf.

--*/

{
    PSECTION    pSection;
    PLINE       pLine = NULL;

    //
    // First search the section.
    //

    pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
    if(pSection)
    {
        //
        // Search the line in the section.
        //

        pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
    }

    return (pLine != NULL);
}


PCHAR
CmpGetSectionLineIndex (
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex
    )

/*++

    Routine Description:

        This routine returns the value at the specified location in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

        ValueIndex - Index of the value to be read.

    Return Value:

        Pointer to the value iff successful. Else NULL.

--*/

{
    PSECTION pSection;
    PLINE    pLine;
    PVALUE   pValue;

    //
    // Search the section in the inf.
    //

    pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
    if(pSection)
    {
        //
        // Search the line in the section.
        //

        pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
        if(pLine)
        {
            //
            // Search the value in the line.
            //

            pValue = CmpSearchValueInLine(pLine, ValueIndex);
            if(pValue)
            {
                //
                // The value may need to be replaced by one of the strings
                // from the string section.
                //

                return(CmpProcessForSimpleStringSub(InfHandle, pValue->pName));
            }
        }
    }

    return(NULL);
}

ULONG
CmpGetSectionLineIndexValueCount(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine returns the number of values in the inf line.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Number of values in the inf line.

--*/

{
    PSECTION    pSection;
    PLINE       pLine;
    PVALUE      pValue;
    ULONG       count = 0;

    //
    // Search the section in the inf.
    //

    pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
    if(pSection)
    {
        //
        // Search the line in the section.
        //

        pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
        if (pLine)
        {
            //
            // Count the number of values in this line.
            //

            for(    pValue = pLine->pValue;
                    pValue;
                    pValue = pValue->pNext, count++);
        }
    }

    return (count);
}

BOOLEAN
CmpGetIntField(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PULONG Data
    )

/*++

    Routine Description:

        This routine reads integer data from the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

        ValueIndex - Index of the value to be read.

        Data - Receives the integer data.

    Return Value:

        TRUE iff successful.

--*/

{
    PCHAR   valueStr;

    //
    // Get the specified value.
    //

    valueStr = CmpGetSectionLineIndex(  InfHandle,
                                        Section,
                                        LineIndex,
                                        ValueIndex);
    //
    // If valid value is found, convert it to an integer.
    //

    if (valueStr && *valueStr)
    {
        *Data = strtoul(valueStr, NULL, 16);
        return (TRUE);
    }

    return (FALSE);
}

BOOLEAN
CmpGetBinaryField(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN OUT PULONG ActualSize
    )

/*++

    Routine Description:

        This routine reads binary data from the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

        ValueIndex - Index of the value to be read.

        Buffer - Receives the binary data read.

        BufferSize - Size of the buffer.

        ActualSize - Receives the size of the data buffer required.

    Return Value:

        TRUE iff successful.

--*/

{
    BOOLEAN     result = FALSE;
    ULONG       requiredSize;
    PSECTION    pSection;
    PLINE       pLine;
    PVALUE      pValue;
    ULONG       count;
    PCHAR       valueStr;

    //
    // Compute the size of buffer required to read in the binary data.
    //

    requiredSize = (CmpGetSectionLineIndexValueCount(   InfHandle,
                                                        Section,
                                                        LineIndex) - ValueIndex) * sizeof(UCHAR);
    //
    // Validate input parameters.
    //

    if (Buffer && BufferSize >= requiredSize)
    {
        //
        // Search the section in the inf.
        //

        pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
        if(pSection)
        {
            //
            // Search the line in this section.
            //

            pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
            if (pLine)
            {
                //
                // Go to the specified value.
                //

                for(    pValue = pLine->pValue, count = 0;
                        pValue && count < ValueIndex;
                        pValue = pValue->pNext, count++);

                //
                // Read in and convert the binary data.
                //

                for (   ;
                        pValue;
                        pValue = pValue->pNext)
                {
                    valueStr = CmpGetSectionLineIndex(  InfHandle,
                                                        Section,
                                                        LineIndex,
                                                        ValueIndex++);
                    if (valueStr == NULL)
                    {
                        break;
                    }
                    *((PUCHAR)Buffer)++ = (UCHAR)strtoul(valueStr, NULL, 16);
                }
                if (valueStr)
                {
                    result = TRUE;
                }
            }
        }
    }

    //
    // The caller wants to know the buffer size required.
    //

    if (ActualSize)
    {
        *ActualSize = requiredSize;
        result = TRUE;
    }

    return (result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\ia64\initdat.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

Author:

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"

//
// ***** INIT *****
//

//
// Data for CmGetSystemControlValues
//
//
// ----- CmControlVector -----
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

PCHAR  SearchStrings[] = {
      "Ver", "Rev", "Rel", "v0", "v1", "v2", "v3", "v4", "v5",
      "v6", "v7", "v8", "v9", "v 0", "v 1", "v 2", "v 3", "v 4",
      "v 5", "v 6", "v 7", "v 8", "v 9", NULL };

PCHAR BiosBegin = { 0 };
PCHAR Start = { 0 };
PCHAR End = { 0 };

UCHAR CmpID[] = "ia64 Family %u Model %u Stepping %u";
WCHAR CmpVendorID[] = L"VendorIdentifier";
WCHAR CmpProcessorNameString[] = L"ProcessorNameString";
WCHAR CmpFeatureBits[] = L"FeatureSet";
WCHAR CmpMHz[] = L"~MHz";
WCHAR CmpUpdateSignature[] = L"Update Signature";

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGE")
#endif

UCHAR CmpIntelID[] = "GenuineIntel";

UCHAR CmpItanium [] = "Itanium";
UCHAR CmpMcKinley[] = "McKinley";
UCHAR CmpIA64Proc[] = "IA64";

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\i386\parseini.h ===
//depot/Lab01_N/Base/ntos/config/i386/parseini.h#1 - branch change 3 (text)
PVOID
CmpOpenInfFile(
    IN  PVOID   InfImage,
    IN  ULONG   ImageSize
   );
   
VOID
CmpCloseInfFile(
    PVOID   InfHandle
    );   

PCHAR
CmpGetKeyName(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );
    
BOOLEAN
CmpSearchInfSection(
    IN PVOID InfHandle,
    IN PCHAR SectionName
    );
    
BOOLEAN
CmpSearchInfLine(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );
    
PCHAR
CmpGetSectionLineIndex (
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex,
    IN ULONG ValueIndex
    );

ULONG
CmpGetSectionLineIndexValueCount(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );

BOOLEAN
CmpGetIntField(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PULONG Data
    );

BOOLEAN
CmpGetBinaryField(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN OUT PULONG ActualSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\init386.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    init386.c

Abstract:

    This module is here to fool build

Author:

    John Vert (jvert) 29-Aug-1994

Environment:

    Kernel mode.

Revision History:

--*/


void dummy(void) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\chkreg.c ===
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include "windows.h"

#define MSG_ERROR_VALUE_INCORRECT_SIZE        "\tERROR: Value entry data has incorrect size \n\t\tValueName = %ls \n\t\tNameSize  = %d \n\t\tValueType = %s \n\t\tValueSize = %d\n"
#define MSG_ERROR_VALUE_NOT_NUL_TERMINATED    "\tERROR: Value entry data is not NUL terminated \n\t\tValueName = %ls \n\t\tNameSize  = %d \n\t\tValueType = %s\n"
#define MSG_ERROR_VALUE_UNKNOWN_DATA          "\tERROR: Value entry contains unknown data \n\t\tValueName = %ls \n\t\tNameSize  = %d \n\t\tValueType = %#x \n\t\tValueSize = %d\n"
#define MSG_ERROR_REG_ENUM_VALUE              "\tERROR: RegEnumValue() failed, iValue = %d, Status = %d \n"
#define MSG_ERROR_REG_OPEN_KEY_EX             "\tERROR: RegOpenKeyEx() failed, Status = %d \n"
#define MSG_ERROR_REG_QUERY_INFO_KEY          "\tERROR: RegQueryInfoKey() failed, Status = %d \n"
#define MSG_ERROR_REG_ENUM_KEY_EX             "ERROR: RegEnumKeyEx() failed, \n\t Status = %d \n\t, SubKey = %d"
#define MSG_ERROR_REG_CONNECT_REGISTRY        "ERROR: Unable to connect to %s, Status = %d \n"
#define MSG_COMPLETE_KEY_NAME                 "%ls\\%ls \n"

VOID
ExamineValueEntries( IN HKEY    Key,
                     IN LPCWSTR CompleteKeyName,
                     IN DWORD   cchMaxValueName,
                     IN DWORD   cbMaxValueData,
                     IN DWORD   cValues,
                     IN LPCWSTR PredefinedKeyName )


{
    LONG    Status;
    DWORD   iValue;
    LPWSTR  lpszValue;
    DWORD   cchValue;
    DWORD   dwType;
    PBYTE   lpbData;
    DWORD   cbData;
    BOOLEAN KeyNameAlreadyPrinted;

    //
    //  Allocate the buffers for the value name and value data
    //

    lpszValue = ( LPWSTR )malloc( (cchMaxValueName + 1)*sizeof( WCHAR ) );
    lpbData = ( LPBYTE )malloc( cbMaxValueData );
    if( ( lpszValue == NULL ) ||
        ( lpbData == NULL ) ) {
        printf( "ERROR: Unable to allocate memory, cchMaxValueName = %d, cbMaxValuedata = %d \n",
                 cchMaxValueName, cbMaxValueData );
        if( lpszValue != NULL ) {
            free( lpszValue );
        }
        if( lpbData != NULL ) {
            free( lpbData );
        }
        return;
    }

    //
    //  Examine all value entries
    //

    KeyNameAlreadyPrinted = FALSE;
    for( iValue = 0; iValue < cValues; iValue++ ) {
        cchValue = cchMaxValueName + 1;
        cbData = cbMaxValueData;
        Status = RegEnumValueW( Key,
                                iValue,
                                lpszValue,
                                &cchValue,
                                0,
                                &dwType,
                                lpbData,
                                &cbData );

        if( Status != ERROR_SUCCESS ) {
            if( !KeyNameAlreadyPrinted ) {
                KeyNameAlreadyPrinted = TRUE;
                printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
            }
            printf( MSG_ERROR_REG_ENUM_VALUE, iValue, Status );
            continue;
        }

//
//      For debugging only
//
//        printf( "\tValueName = %ls \n", lpszValue );
//

        switch( dwType ) {

            case REG_BINARY:

                if( cbData == 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_BINARY", cbData );
                }
                break;

            case REG_DWORD:

                if( cbData != sizeof( DWORD ) ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_DWORD", cbData );
                }
                break;

            case REG_DWORD_BIG_ENDIAN:

                if( cbData != sizeof( DWORD ) ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_DWORD_BIG_ENDIAN", cbData );
                }
                break;

            case REG_EXPAND_SZ:

                if( ( cbData != 0 )  && ( ( cbData % sizeof( WCHAR ) ) == 0 )) {
                    if( *( ( PWCHAR )( lpbData + cbData - sizeof( WCHAR ) ) ) != ( WCHAR )'\0' ) {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_NOT_NUL_TERMINATED,
                                lpszValue, cchValue, "REG_EXPAND_SZ" );
                    }
                } else {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                                lpszValue, cchValue, "REG_EXPAND_SZ", cbData );
                }
                break;

            case REG_LINK:

                if( cbData == 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_LINK", cbData );
                }
                break;

            case REG_MULTI_SZ:

                if( ( cbData != 0 )  && ( ( cbData % sizeof( WCHAR ) ) == 0 )) {
                    if( *( ( PWCHAR )( lpbData + cbData - sizeof( WCHAR ) ) ) != ( WCHAR )'\0' ) {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_NOT_NUL_TERMINATED,
                                lpszValue, cchValue, "REG_MULTI_SZ" );
                    }
                } else {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                                lpszValue, cchValue, "REG_MULTI_SZ", cbData );
                }
                break;

            case REG_NONE:

                if( cbData != 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_NONE", cbData );
                }
                break;

            case REG_RESOURCE_LIST:

                if( cbData == 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_RESOURCE_LIST", cbData );
                }
                break;


            case REG_SZ:

                if( ( cbData != 0 ) && ( ( cbData % sizeof( WCHAR ) ) == 0 ) ) {
                    if( *( ( PWCHAR )( lpbData + cbData - sizeof( WCHAR ) ) ) != ( WCHAR )'\0' ) {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_NOT_NUL_TERMINATED,
                                lpszValue, cchValue, "REG_SZ" );
                    }
                } else {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                                lpszValue, cchValue, "REG_SZ", cbData );
                }
                break;

            case REG_FULL_RESOURCE_DESCRIPTOR:

                if( cbData == 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_FULL_RESOURCE_DESCRIPTOR", cbData );
                }
                break;

            default:

                if( !KeyNameAlreadyPrinted ) {
                    KeyNameAlreadyPrinted = TRUE;
                    printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                }
                printf( MSG_ERROR_VALUE_UNKNOWN_DATA,
                        lpszValue, cchValue, dwType, cbData );
                break;

        }
    }

    //
    //  Free buffers for value name and value data
    //
    free( lpszValue );
    free( lpbData );
}





VOID
ExamineKey(
    IN  HKEY    PredefinedKey,
    IN  LPCWSTR ParentName,
    IN  LPCWSTR KeyName,
    IN  LPCWSTR PredefinedKeyName
    )

{
    LPWSTR      CompleteKeyName;

    HKEY        Key;

    LONG        Status;

    WCHAR       szClass[ MAX_PATH + 1 ];
    DWORD       cchClass;
    DWORD       cSubKeys;
    DWORD       cchMaxSubKey;
    DWORD       cchMaxClass;
    DWORD       cValues;
    DWORD       cchMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;

    WCHAR       szSubKeyName[ MAX_PATH + 1 ];
    DWORD       cchSubKeyNameLength;

    DWORD       iSubKey;
    BOOLEAN     KeyNameAlreadyPrinted;


    //
    //  Build the complete key name
    //

    if( wcslen( ParentName ) == 0 ) {
        CompleteKeyName = wcsdup( KeyName );
        if( CompleteKeyName == NULL ) {
            printf( "ERROR: wcsdup( KeyName ) failed \n" );
            return;
        }
    } else {
        CompleteKeyName = wcsdup( ParentName );
        if( CompleteKeyName == NULL ) {
            printf( "ERROR: wcsdup( ParentName ) failed \n" );
            return;
        }
        if( wcslen( KeyName ) != 0 ) {
            CompleteKeyName = realloc( CompleteKeyName,
                                       ( wcslen( CompleteKeyName ) +
                                         wcslen( L"\\" ) +
                                         wcslen( KeyName ) + 1 )*sizeof( WCHAR ) );
            wcscat( CompleteKeyName, L"\\" );
            wcscat( CompleteKeyName, KeyName );
        }
    }

//
//  For debugging only
//
//    printf( "%ls\\%ls \n", PredefinedKeyName, CompleteKeyName );
//

    //
    //  Open the key
    //

    Status = RegOpenKeyExW( PredefinedKey,
                           CompleteKeyName,
                           0,
                           MAXIMUM_ALLOWED,
                           &Key );


    if( Status != ERROR_SUCCESS ) {
        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
        printf( MSG_ERROR_REG_OPEN_KEY_EX, Status );
        free( CompleteKeyName );
        return;
    }

    //
    //  Determine the number of value entries, the maximum length of a value
    //  entry name, the maximum data size, and the number of subkeys
    //

    cchClass = sizeof( szClass ) / sizeof( WCHAR );
    Status = RegQueryInfoKeyW( Key,
                               szClass,
                               &cchClass,
                               0,
                               &cSubKeys,
                               &cchMaxSubKey,
                               &cchMaxClass,
                               &cValues,
                               &cchMaxValueName,
                               &cbMaxValueData,
                               &cbSecurityDescriptor,
                               &ftLastWriteTime );

    if( Status != ERROR_SUCCESS ) {
        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
        printf( MSG_ERROR_REG_QUERY_INFO_KEY, Status );
        free( CompleteKeyName );
        RegCloseKey( Key );
        return;
    }


    if( cValues != 0 ) {

        //
        // Examine the value entries
        //

        ExamineValueEntries( Key,
                            CompleteKeyName,
                            cchMaxValueName,
                            cbMaxValueData,
                            cValues,
                            PredefinedKeyName );

    }

    //
    //  Traverse each subkey
    //
    if( cSubKeys != 0 ) {
        KeyNameAlreadyPrinted = FALSE;
        for( iSubKey = 0; iSubKey < cSubKeys; iSubKey++ ) {
            cchSubKeyNameLength = sizeof( szSubKeyName )/sizeof( WCHAR );
            cchClass = sizeof( szClass ) / sizeof( WCHAR );
            Status = RegEnumKeyExW( Key,
                                    iSubKey,
                                    szSubKeyName,
                                    &cchSubKeyNameLength,
                                    0,
                                    NULL,
                                    NULL,
                                    &ftLastWriteTime );

            if( Status != ERROR_SUCCESS ) {
                if( !KeyNameAlreadyPrinted ) {
                    KeyNameAlreadyPrinted = TRUE;
                    printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                }
                printf( MSG_ERROR_REG_ENUM_KEY_EX, Status, iSubKey );
                continue;
            }
            ExamineKey( PredefinedKey,
                        CompleteKeyName,
                        szSubKeyName,
                        PredefinedKeyName );
        }
    }
    RegCloseKey( Key );

    free( CompleteKeyName );
}




main( int argc, char* argv[] )
{
    DWORD   i;
    HKEY    RemoteUsers;
    HKEY    RemoteLocalMachine;
    LONG    Status;

    if( argc <= 1 ) {
        printf( "\n******* Examining HKEY_LOCAL_MACHINE on local machine\n\n" );
        ExamineKey( HKEY_LOCAL_MACHINE,
                    L"",
                    L"",
                    L"HKEY_LOCAL_MACHINE" );

        printf( "\n******* Examining HKEY_USERS on local machine\n\n" );
        ExamineKey( HKEY_USERS,
                    L"",
                    L"",
                    L"HKEY_USERS" );

        printf( "\n******* Examining HKEY_CLASSES_ROOT on local machine\n\n" );
        ExamineKey( HKEY_CLASSES_ROOT,
                    L"",
                    L"",
                    L"HKEY_CLASSES_ROOT" );

        printf( "\n******* Examining HKEY_CURRENT_USER on local machine\n\n" );
        ExamineKey( HKEY_CURRENT_USER,
                    L"",
                    L"",
                    L"HKEY_CURRENT_USER" );
    } else {
        for( i = 1; i < argc; i++ ) {
            //
            // printf( "Machine name = %s \n", argv[ i ] );
            //

            Status = RegConnectRegistry( argv[ i ],
                                         HKEY_LOCAL_MACHINE,
                                         &RemoteLocalMachine );

            if( Status != ERROR_SUCCESS ) {
                printf( MSG_ERROR_REG_CONNECT_REGISTRY, argv[i], Status );
                continue;
            }

            Status = RegConnectRegistry( argv[ i ],
                                         HKEY_USERS,
                                         &RemoteUsers );

            if( Status != ERROR_SUCCESS ) {
                RegCloseKey( RemoteLocalMachine );
                printf( MSG_ERROR_REG_CONNECT_REGISTRY, argv[i], Status );
                continue;
            }

            printf( "\n******* Examining HKEY_LOCAL_MACHINE on %s \n\n", argv[i] );
            ExamineKey( RemoteLocalMachine,
                        L"",
                        L"",
                        L"HKEY_LOCAL_MACHINE" );

            printf( "\n******* Examining HKEY_USERS on %s \n\n", argv[i] );
            ExamineKey( RemoteUsers,
                        L"",
                        L"",
                        L"HKEY_USERS" );

            RegCloseKey( RemoteLocalMachine );
            RegCloseKey( RemoteUsers );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\editreg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    editreg.c

Abstract:

    This program acts as an interactive shell allowing a user to view
    and manipulate the configuration registry.  Also, it has some specific
    commands for support of the NTFT component of the registry.

Author:

    Mike Glass
    Bob Rinne

Environment:

    User process.

Notes:

    The commands "disk", "fix", "restore" are commands that know where
    the configuration information is for the NTFT component of the NT
    system.

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "ntdskreg.h"
#include "ntddft.h"

//
// Tempory stuff to get types and values to print in help.
//

PUCHAR TypeNames[] =
{
    "REG_NONE",
    "REG_SZ",
    "REG_BINARY",
    "REG_DWORD",
    "REG_DWORD_LITTLE_ENDIAN",
    "REG_DWORD_BIG_ENDIAN",
    "REG_LINK",
    "REG_MULTI_SZ",
    "REG_RESOURCE_LIST",
    NULL
};

ULONG TypeNumbers[] =
{
    REG_NONE,
    REG_SZ,
    REG_BINARY,
    REG_DWORD,
    REG_DWORD_LITTLE_ENDIAN,
    REG_DWORD_BIG_ENDIAN,
    REG_LINK,
    REG_MULTI_SZ,
    REG_RESOURCE_LIST
};

//
// Special support for the driver load lists in the registry.
//

PUCHAR StartDescription[] =
{
    "Boot loader",
    "System",
    "2",
    "3",
    
    //
    // Anything above 3 is not loaded.
    //

    NULL
};

PUCHAR TypeDescription[] =
{
    "System driver",
    "File system",
    "Service",
    NULL
};


//
// Constants and defines.
//

#define WORK_BUFFER_SIZE 4096

//
// Amount to fudge when mallocing for strings.
//

#define FUDGE 8

//
// Registry base.
//

#define REGISTRY_BASE "\\REGISTRY\\MACHINE"

//
// Default type value when key value set.
//

#define DEFAULT_TYPE REG_SZ

//
// Base location for component descriptions of FT elements.
//

#define FT_REGISTRY_ROOT "\\REGISTRY\\MACHINE\\SYSTEM\\NTFT"

//
// Subkey name located in the FT_REGISTRY_ROOT for stripes.
//

#define FT_STRIPE_BASE   "Stripe%d"

//
// Subkey name located in the FT_REGISTRY_ROOT for mirrors.
//

#define FT_MIRROR_BASE   "Mirror%d"

//
// Subkey name located in the FT_REGISTRY_ROOT for volume sets.
//

#define FT_VOLSET_BASE   "VolSet%d"


//
// Constants for the command values.
//

#define INVALID   -1
#define DIR       0
#define CREATE    1
#define LIST      2
#define CHDIR     3
#define HELP      4
#define QUIT      5
#define DDEBUG    6
#define SETVALUE  7
#define DELKEY    8
#define DELVALUE  9
#define DIRLONG  10
#define INLONG   11
#define INSHORT  12
#define INBYTE   13
#define DUMP     14
#define DISKREG  15
#define FIXDISK  16
#define RESTORE  17
#define DRIVERS  18
#define ORPHAN   19
#define REGEN    20
#define INIT     21
#define MAKEFT   22

#define CTRL_C 0x03

//
// Table of recognized commands.
//

PUCHAR Commands[] = {
    "dir",
    "keys",
    "lc",
    "ls",
    "create",
    "set",
    "unset",
    "erase",
    "delete",
    "rm",
    "list",
    "values",
    "display",
    "cd",
    "chdir",
    "help",
    "?",
    "quit",
    "exit",
    "debug",
    "longs",
    "shorts",
    "bytes",
    "dump",
    "disks",
    "fix",
    "restore",
    "drivers",
    "orphan",
    "regenerate",
    "initialize",
    "makeft",
    NULL
};

//
// Using the index from the match on the commands in Commands[], this
// table gives the proper command value to be executed.  This allows
// for multiple entries in Commands[] for the same command code.
//

int CommandMap[] = {

    DIRLONG,
    DIR,
    DIR,
    DIR,
    CREATE,
    SETVALUE,
    DELVALUE,
    DELVALUE,
    DELKEY,
    DELKEY,
    LIST,
    LIST,
    LIST,
    CHDIR,
    CHDIR,
    HELP,
    HELP,
    QUIT,
    QUIT,
    DDEBUG,
    INLONG,
    INSHORT,
    INBYTE,
    DUMP,
    DISKREG,
    FIXDISK,
    RESTORE,
    DRIVERS,
    ORPHAN,
    REGEN,
    INIT,
    MAKEFT
};

//
// CommandHelp is an array of help strings for each of the commands.
// The array is indexed by the result of CommandMap[i] for the Commands[]
// array.  This way the same help message will print for each of the
// commands aliases.
//

PUCHAR   CommandHelp[] = {

    "Displays keys.",
    "Create a new key.",
    "Displays values withing a key.",
    "Change current location in registry.",
    "This help information.",
    "Exit the program.",
    "Set internal debug on for this program.",
    "Set a new value within a key.",
    "Delete a key.",
    "Unset (erase) a key value.",
    "Unset (erase) a key value.",
    "Change dump format to Longs (default).",
    "Change dump format to Shorts.",
    "Change dump format to Bytes.",
    "Toggle dump mode (force hex dump for all value types).",
    "Display the disk registry.",
    "Set disk signatures in registry.",
    "Restore an FT orphan to working state.",
    "List the information on the drivers from the registry.",
    "Orphan a member of an FT set.",
    "Mark a FT set member for regeneration on next boot.",
    "Mark a stripe with parity for initialization on next boot.",
    "Construct an FT set from existing partitions",
    NULL

};

//
// Space for working location string in registry.
//

UCHAR WorkingDirectory[512];

//
// Space for current location string in registry.
//

UCHAR CurrentDirectory[512];

//
// Space for command input.
//

UCHAR CommandLine[512];

//
// Prompt strings for getting definition for an FT_COPY request.
//

PUCHAR SetPrompts[] = {

    "Name => ",
    "Value => ",
    "Index => ",
    NULL
};

//
// Version indicator.  Should be changed every time a major edit occurs.
//

PUCHAR Version = "Version 1.30";

//
// Debug print level.
//

ULONG Debug = 0;

//
// Dump control values.
//

typedef enum _DUMP_CONTROL {

    InBytes,
    InShorts,
    InLongs

} DUMP_CONTROL, *PDUMP_CONTROL;

ULONG ForceDump = 0;

DUMP_CONTROL DumpControl = InLongs;

NTSTATUS
FtOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS          status;
    STRING            keyString;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    unicodeKeyName;

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       (BOOLEAN) TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenKey(HandlePtr,
                       MAXIMUM_ALLOWED,
                       &objectAttributes);

    RtlFreeUnicodeString(&unicodeKeyName);

    if (Debug == 1) {
        if (!NT_SUCCESS(status)) {
            printf("Failed NtOpenKey for %s => %x\n",
                   KeyName,
                   status);
        }
    }

    return status;
}


NTSTATUS
FtDeleteKey(
    PUCHAR KeyName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS status;
    HANDLE   keyToDelete;

    status = FtOpenKey(&keyToDelete,
                       KeyName);

    if (!NT_SUCCESS(status)) {
        printf("Key %s not found (0x%x).\n", KeyName, status);
        return status;
    }

    status = NtDeleteKey(keyToDelete);

    if (Debug == 1) {
        if (!NT_SUCCESS(status)) {
            printf("Could not delete key %s => %x\n",
                   KeyName,
                   status);
        }
    }

    NtClose(keyToDelete);
    return status;
}


NTSTATUS
FtCreateKey(
    PUCHAR KeyName,
    PUCHAR KeyClass,
    ULONG  Index
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS          status;
    STRING            keyString;
    UNICODE_STRING    unicodeKeyName;
    STRING            classString;
    UNICODE_STRING    unicodeClassName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG             disposition;
    HANDLE            tempHandle;

#if DBG
    if ((KeyName == NULL) ||
        (KeyClass == NULL)) {
        printf("FtCreateKey: Invalid parameter 0x%x, 0x%x\n",
               KeyName,
               KeyClass);
        ASSERT(0);
    }
#endif

    //
    // Initialize the object for the key.
    //

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       (BOOLEAN) TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Setup the unicode class value.
    //

    RtlInitString(&classString,
                  KeyClass);
    (VOID)RtlAnsiStringToUnicodeString(&unicodeClassName,
                                       &classString,
                                       (BOOLEAN) TRUE);

    //
    // Create the key.
    //

    status = NtCreateKey(&tempHandle,
                         MAXIMUM_ALLOWED,
                         &objectAttributes,
                         Index,
                         &unicodeClassName,
                         REG_OPTION_NON_VOLATILE,
                         &disposition);

    if (NT_SUCCESS(status)) {
        switch (disposition)
        {
        case REG_CREATED_NEW_KEY:
            break;

        case REG_OPENED_EXISTING_KEY:
            printf("Warning: Creation was for an existing key!\n");
            break;

        default:
            printf("New disposition returned == 0x%x\n", disposition);
            break;
        }
    }

    //
    // Free all allocated space.
    //

    RtlFreeUnicodeString(&unicodeKeyName);
    RtlFreeUnicodeString(&unicodeClassName);
    NtClose(tempHandle);
    return status;
}


NTSTATUS
FtDeleteValue(
    HANDLE KeyHandle,
    PUCHAR ValueName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS       status;
    STRING         valueString;
    UNICODE_STRING unicodeValueName;

    RtlInitString(&valueString,
                  ValueName);
    status = RtlAnsiStringToUnicodeString(&unicodeValueName,
                                          &valueString,
                                          (BOOLEAN) TRUE);
    if (!NT_SUCCESS(status)) {
        printf("FtDeleteValue: internal conversion error 0x%x\n", status);
        return status;
    }

    status = NtDeleteValueKey(KeyHandle,
                              &unicodeValueName);
    if (Debug == 1) {
        if (!NT_SUCCESS(status)) {
            printf("Could not delete value %s => %x\n",
                   ValueName,
                   status);
        }
    }

    RtlFreeUnicodeString(&unicodeValueName);
    return status;
}

NTSTATUS
FtSetValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PVOID  DataBuffer,
    ULONG  DataLength,
    ULONG  Type
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS          status;
    STRING            valueString;
    UNICODE_STRING    unicodeValueName;

    RtlInitString(&valueString,
                  ValueName);
    RtlAnsiStringToUnicodeString(&unicodeValueName,
                                 &valueString,
                                 (BOOLEAN) TRUE);
    status = NtSetValueKey(KeyHandle,
                           &unicodeValueName,
                           0,
                           Type,
                           DataBuffer,
                           DataLength);
    if (Debug == 1) {
        if (!NT_SUCCESS(status)) {
            printf("Could not set value %s => %x\n",
                   ValueName,
                   status);
        }
    }

    RtlFreeUnicodeString(&unicodeValueName);
    return status;
}


PUCHAR
FindTypeString(
    ULONG Type
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    int i;

    for (i = 0; TypeNames[i] != NULL; i++) {

        if (TypeNumbers[i] == Type) {
            return TypeNames[i];
        }
    }
    return "(Unknown)";
}


BOOLEAN
ProcessHex(
    PUCHAR String,
    PULONG Value
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG  workValue;
    int    i;
    PUCHAR cp;

    if (String == NULL) {
        return FALSE;
    }

    cp = String;

    //
    // 'i' is an index value.  It contains the maximum index into the String.
    // Therefore it is initialized to -1.
    //

    i = -1;
    while ((*cp) && (*cp != '\n')) {
        i++;
        cp++;
    }

    if (i >= 8) {

        //
        // String to long for a long.
        //

        return FALSE;
    }

    workValue = 0;
    cp = String;
    while (*cp) {
        *cp = (UCHAR) tolower(*cp);

        switch (*cp) {

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            workValue |= (((*cp) - '0') << (i * 4));
            break;

        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
            workValue |= ((((*cp) - 'a') + 10) << (i * 4));
            break;

        default:

            //
            // Illegal value, just punt.
            //

            return FALSE;
            break;
        }
        cp++;
        i--;
    }

    *Value = workValue;
    return TRUE;
}


VOID
Dump(
    PVOID Buffer,
    ULONG Length
    )

/*++

Routine Description:

    Dump the value data from a buffer in the format specified.

Arguments:

    Buffer - pointer to the data.
    Length - length of the data.

Return Value:

    None.

--*/
{
    PUCHAR location;
    PUCHAR internalBuffer;
    int    i;
    int    j;
    int    numberLines;
    UCHAR  outHexLine[128];
    UCHAR  outPrintable[64];

    numberLines = (Length + 15) / 16;

    //
    // Since the amount of data displayed has been rounded up, this
    // routine mallocs enough space and copies the data in.  This way
    // it won't fault if the data is at the end of memory.
    //

    internalBuffer = (PUCHAR) malloc(numberLines * 16);
    RtlMoveMemory(internalBuffer, Buffer, Length);
    location = (PUCHAR) internalBuffer;

    for (i = 0; i < numberLines; i++) {

        sprintf(outHexLine, "%8x: ", (i * 16));
        sprintf(outPrintable, "*");
        switch (DumpControl) {

        case InBytes:

            for (j = 0; j < 16; j++) {
                sprintf(outHexLine, "%s%2X ", outHexLine, *location);
                sprintf(outPrintable, "%s%c", outPrintable,
                        (isprint(location[0])) ? location[0] : '.');
                location++;
            }
            break;

        case InShorts:

            for (j = 0; j < 8; j++) {
                sprintf(outHexLine, "%s%4X ", outHexLine,
                        *((PUSHORT)location));
                sprintf(outPrintable, "%s%c%c", outPrintable,
                        (isprint(location[0])) ? location[0] : '.',
                        (isprint(location[1])) ? location[1] : '.');
                location += 2;
            }
            break;

        default:
        case InLongs:

            for (j = 0; j < 4; j++) {
                sprintf(outHexLine, "%s%8X ", outHexLine,
                        *((PULONG)location));
                sprintf(outPrintable, "%s%c%c%c%c", outPrintable,
                        (isprint(location[0])) ? location[0] : '.',
                        (isprint(location[1])) ? location[1] : '.',
                        (isprint(location[2])) ? location[2] : '.',
                        (isprint(location[3])) ? location[3] : '.');
                location += 4;
            }
            break;
        }

        printf("%s   %s*\n", outHexLine, outPrintable);
    }
    printf("\n");
    free(internalBuffer);
}


void
UnicodePrint(
    PUNICODE_STRING  UnicodeString
    )

/*++

Routine Description:

    Print a unicode string.

Arguments:

    UnicodeString - pointer to the string.

Return Value:

    None.

--*/
{
    ANSI_STRING ansiString;
    PUCHAR      tempbuffer = (PUCHAR) malloc(WORK_BUFFER_SIZE);

    ansiString.MaximumLength = WORK_BUFFER_SIZE;
    ansiString.Length = 0L;
    ansiString.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&ansiString,
                                 UnicodeString,
                                 (BOOLEAN) FALSE);
    printf("%s", ansiString.Buffer);
    free(tempbuffer);
    return;
}


NTSTATUS
Directory(
    HANDLE  KeyHandle,
    BOOLEAN LongListing
    )

/*++


Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS        status;
    ULONG           index;
    ULONG           resultLength;
    UNICODE_STRING  unicodeValueName;
    PKEY_BASIC_INFORMATION keyInformation;

    keyInformation = (PKEY_BASIC_INFORMATION) malloc(WORK_BUFFER_SIZE);

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(keyInformation, WORK_BUFFER_SIZE);

        status = NtEnumerateKey(KeyHandle,
                                index,
                                KeyBasicInformation,
                                keyInformation,
                                WORK_BUFFER_SIZE,
                                &resultLength);

        if (status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(status)) {

            printf("readreg: Error on Enumerate status = %x\n", status);
            break;

        }

        unicodeValueName.Length = (USHORT)keyInformation->NameLength;
        unicodeValueName.MaximumLength = (USHORT)keyInformation->NameLength;
        unicodeValueName.Buffer = (PWSTR)&keyInformation->Name[0];
        UnicodePrint(&unicodeValueName);
        printf("\n");

        if (LongListing) {
        }
    }

    free(keyInformation);
    return status;
}


NTSTATUS
List(
    HANDLE KeyHandle,
    PUCHAR ItemName
    )

/*++


Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS       status;
    ULONG          index;
    ULONG          resultLength;
    ULONG          type;
    PUCHAR         typeString;
    UNICODE_STRING unicodeValueName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    UNREFERENCED_PARAMETER(ItemName);

    resultLength = WORK_BUFFER_SIZE;
    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)malloc(WORK_BUFFER_SIZE);

    for (index = 0; TRUE; index++) {

        while (1) {

            RtlZeroMemory(keyValueInformation, resultLength);
            status = NtEnumerateValueKey(KeyHandle,
                                         index,
                                         KeyValueFullInformation,
                                         keyValueInformation,
                                         resultLength,
                                         &resultLength);

            if (status == STATUS_BUFFER_OVERFLOW) {
                free(keyValueInformation);
                keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                           malloc(resultLength + 10);
            } else {
                break;
            }
        }

        if (status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(status)) {

            printf("readreg: Cannot list (%x)\n", status);
            break;

        }

        type = keyValueInformation->Type;
        typeString = FindTypeString(type);
        unicodeValueName.Length = (USHORT)keyValueInformation->NameLength;
        unicodeValueName.MaximumLength =(USHORT)keyValueInformation->NameLength;
        unicodeValueName.Buffer = (PWSTR)&keyValueInformation->Name[0];
        printf("Name-> """);
        UnicodePrint(&unicodeValueName);
        printf("""\n");
        printf("\ttype = %s (%d)\ttitle index = %d\tdata length = %d\n",
               typeString,
               type,
               keyValueInformation->TitleIndex,
               keyValueInformation->DataLength);
        printf("\tData:\n");

        if (ForceDump) {
            type = REG_BINARY;
        }

        switch (type) {

        case REG_DWORD:
        // case REG_DWORD_LITTLE_ENDIAN:
            printf("\tDWORD value == %d, (0x%x)\n",
               *((PULONG)((PUCHAR)keyValueInformation +
                                  keyValueInformation->DataOffset)),
               *((PULONG)((PUCHAR)keyValueInformation +
                                  keyValueInformation->DataOffset)));
            break;

        case REG_SZ:

            unicodeValueName.Length = (USHORT)keyValueInformation->DataLength;
            unicodeValueName.MaximumLength = (USHORT)
                                                keyValueInformation->DataLength;
            unicodeValueName.Buffer = (PWSTR) ((PUCHAR) keyValueInformation +
                                               keyValueInformation->DataOffset);
            UnicodePrint(&unicodeValueName);
            break;

        case REG_BINARY:
        default:
            Dump(((PUCHAR)keyValueInformation +keyValueInformation->DataOffset),
                 keyValueInformation->DataLength);
        }
        printf("\n");
    }

    free(keyValueInformation);
    return status;
}


UCHAR
GetCharacter(
    BOOLEAN Batch
    )

/*++

Routine Description:

    This routine returns a single character from the input stream.
    It discards leading blanks if the input is not from the console.

Arguments:

    Batch - a boolean indicating if the input it coming from the console.

Return Value:

    A character

--*/

{
    UCHAR c;

    if (Batch) {

        while ((c = (UCHAR) getchar()) == ' ')
            ;

    } else {

        c = (UCHAR) getchar();
    }

    return c;
} // GetCharacter


PUCHAR
GetArgumentString(
    BOOLEAN Batch,
    PUCHAR  Prompt,
    BOOLEAN ConvertToLower
    )

/*++

Routine Description:

    This routine prints the prompt if the input is coming from the console,
    then proceeds to collect the user input until a carraige return is typed.

Arguments:

    Batch  - a boolean indicating if the input is coming from the console.
    Prompt - String to prompt with.

Return Value:

    A pointer to the input string.
    NULL if the user escaped.

--*/

{
    //
    // The command line data area is used to store the argument string.
    //

    PUCHAR argument = CommandLine;
    int    i;
    UCHAR  c;

    if (!Batch) {

        printf("%s", Prompt);
    }

    while ((c = GetCharacter(Batch)) == ' ') {

        //
        // Ignore leading spaces.
        //
    }

    i = 0;
    while (c) {

        putchar(c);

        if (c == CTRL_C) {

            return NULL;
        }

        if ((c == '\n') || (c == '\r')) {

            putchar('\n');

            if (i == 0) {
                return NULL;
            } else {
                break;
            }
        }

        if (c == '\b') {

            if (i > 0) {

                //
                // blank over last char
                //

                putchar(' ');
                putchar('\b');
                i--;

            } else {

                //
                // space forward to keep prompt in the same place.
                //

                putchar(' ');
            }

        } else {

            //
            // Collect the argument.
            //

            if (ConvertToLower == TRUE) {
                argument[i] = (UCHAR) tolower(c);
            } else {
                argument[i] = (UCHAR) c;
            }
            i++;

        }

        c = GetCharacter(Batch);
    }

    argument[i] = '\0';
    return CommandLine;

} // GetArgumentString


ULONG
ParseArgumentNumeric(
    PUCHAR  *ArgumentPtr
    )

/*++

Routine Description:

    This routine prints the prompt if the input is coming from the console.

Arguments:

    Batch - a boolean indicating if the input is coming from the console.

Return Value:

    None

--*/

{
    UCHAR   c;
    ULONG   number;
    int     i;
    BOOLEAN complete = FALSE;
    PUCHAR  argument = *ArgumentPtr;

    while (*argument == ' ') {

        //
        // skip spaces.
        //

        argument++;
    }

    //
    // Assume there is only one option to parse until proven
    // otherwise.
    //

    *ArgumentPtr = NULL;

    i = 0;

    while (complete == FALSE) {

        c = argument[i];

        switch (c) {

        case '\n':
        case '\r':
        case '\t':
        case ' ':

            //
            // Update the caller argument pointer to the remaining string.
            //

            *ArgumentPtr = &argument[i + 1];

            //
            // fall through.
            //

        case '\0':

            argument[i] = '\0';
            complete = TRUE;
            break;

        default:

            i++;
            break;
        }

    }

    if (i > 0) {
        number = (ULONG) atoi(argument);
    } else {
        number = (ULONG) -1;
    }

    return number;

} // ParseArgumentNumeric


VOID
PromptUser(
    BOOLEAN Batch
    )

/*++

Routine Description:

    This routine prints the prompt if the input is coming from the console.

Arguments:

    Batch - a boolean indicating if the input is coming from the console.

Return Value:

    None

--*/

{
    if (!Batch) {

        printf("\n%s> ", CurrentDirectory);
    }

} // PromptUser


int
GetCommand(
    BOOLEAN Batch,
    PUCHAR *ArgumentPtr
    )
/*++

Routine Description:

    This routine processes the user input and returns the code for the
    command entered.  If the command has an argument, either the default
    value for the argument (if none is given) or the value provided by the
    user is returned.

Arguments:

    Batch - a boolean indicating if the input it coming from the console.

Return Value:

    A command code

--*/

{
    int    i;
    int    commandIndex;
    int    commandCode;
    UCHAR  c;
    PUCHAR commandPtr;
    PUCHAR command = CommandLine;
    int    argumentIndex = -1;
    PUCHAR argument = NULL;

    PromptUser(Batch);

    while ((c = GetCharacter(Batch)) == ' ') {

        //
        // Ignore leading spaces.
        //
    }

    i = 0;
    while (c) {

        putchar(c);

        if ((c == '\n') || (c == '\r')) {
            putchar('\n');
            if (i == 0) {
                PromptUser(Batch);
                c = GetCharacter(Batch);
                continue;
            }
            break;
        }

        if (c == '\b') {

            if (i > 0) {

                //
                // blank over last char
                //

                putchar(' ');
                putchar('\b');
                i--;

                if (argumentIndex == i) {
                    argumentIndex = -1;
                    argument = NULL;
                }
            } else {

                //
                // space forward to keep prompt in the same place.
                //

                putchar(' ');
            }
        } else {

            //
            // Collect the command.
            //

            command[i] = (UCHAR)tolower(c);
            i++;
        }

        if ((c == ' ') && (argument == NULL)) {

            argument = &command[i];
            argumentIndex = i;
            command[i - 1] = '\0';
        }

        c = GetCharacter(Batch);
    }

    //
    // add end of string.
    //

    command[i] = '\0';

    if (Debug) {
        printf("command => %s$\n", command);
    }

    //
    // Identify the command and return its code.
    //

    commandIndex = 0;

    for (commandPtr = Commands[commandIndex];
         commandPtr != NULL;
         commandPtr = Commands[commandIndex]) {

        if (Debug) {
            printf("Testing => %s$ ... ", commandPtr);
        }

        i = 0;
        while (commandPtr[i] == command[i]) {
            if (command[i] == '\0') {
                break;
            }
            i++;
        }

        if (Debug) {
            printf(" i == %d, command[i] == 0x%x\n", i, command[i]);
        }

        if (command[i]) {

            //
            // Not complete there was a mismatch on the command.
            //

            commandIndex++;
            continue;
        }

        //
        // Have a match on the command.
        //

        if (Debug) {
            printf("Command match %d, argument %s\n",
                   commandIndex,
                   (argument == NULL) ? "(none)" : argument);
        }

        commandCode = CommandMap[commandIndex];
        *ArgumentPtr = argument;
        return commandCode;
    }

    printf("Command was invalid\n");
    return INVALID;
} // GetCommand


VOID
NotImplemented()

/*++

--*/

{
    printf("Sorry, function not implemented yet.\n");
}

NTSTATUS
FtReturnValue(
    IN HANDLE Handle,
    IN PUCHAR ValueName,
    IN PUCHAR Buffer,
    IN ULONG  BufferLength
    )

/*++

Routine Description:

    Formatted display of the disk registry information.

Arguments:

    None.

Return Values:

    None.

--*/

{
    NTSTATUS       status;
    ULONG          resultLength;
    ULONG          length;
    STRING         valueString;
    UNICODE_STRING unicodeValueName;
    PUCHAR         internalBuffer;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)malloc(WORK_BUFFER_SIZE);
    if (keyValueInformation == NULL) {
        printf("FtReturnValue: cannot allocate memory.\n");
        return STATUS_NO_MEMORY;
    }

    RtlInitString(&valueString,
                  ValueName);
    RtlAnsiStringToUnicodeString(&unicodeValueName,
                                 &valueString,
                                 (BOOLEAN) TRUE);
    status = NtQueryValueKey(Handle,
                             &unicodeValueName,
                             KeyValueFullInformation,
                             keyValueInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);
    RtlFreeUnicodeString(&unicodeValueName);

    if (NT_SUCCESS(status)) {
        length = (resultLength > BufferLength) ? BufferLength : resultLength;
        internalBuffer =
           ((PUCHAR)keyValueInformation + keyValueInformation->DataOffset);

        RtlMoveMemory(Buffer, internalBuffer, length);
    }
    free(keyValueInformation);
    return status;
}

VOID
DiskDump()

/*++

Routine Description:

    Formatted display of the disk registry information.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ULONG               outerLoop;
    ULONG               innerLoop;
    HANDLE              handle;
    NTSTATUS            status;
    PDISK_CONFIG_HEADER configHeader;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    PDISK_PARTITION     diskPartition;
    PFT_REGISTRY        ftRegistry;
    PFT_DESCRIPTION     ftDescription;
    PFT_MEMBER_DESCRIPTION ftMember;

    status = FtOpenKey(&handle,
                       DISK_REGISTRY_KEY);

    if (!NT_SUCCESS(status)) {
        printf("Currently there is no key in the registry"
               " for the disk information.\n");
        return;
    }

    configHeader = (PDISK_CONFIG_HEADER) malloc(WORK_BUFFER_SIZE);
    if (configHeader == NULL) {
        printf("Unable to allocate memory for the disk registy information.\n");
        return;
    }

    RtlZeroMemory(configHeader, WORK_BUFFER_SIZE);

    status = FtReturnValue(handle,
                           (PUCHAR) DISK_REGISTRY_VALUE,
                           (PUCHAR) configHeader,
                           WORK_BUFFER_SIZE);
    NtClose(handle);

    if (!NT_SUCCESS(status)) {
        printf("There is no disk registry information (%x)\n", status);
        free(configHeader);
        return;
    }

    //
    // Print the header.
    //

    printf("Registry header information:\n");
    printf("\tVersion = 0x%x, Checksum = 0x%x\n",
           configHeader->Version,
           configHeader->CheckSum);
    printf("\tDisk info Offset = 0x%x, Size = 0x%x\n",
           configHeader->DiskInformationOffset,
           configHeader->DiskInformationSize);
    printf("\tFT info Offset = 0x%x, Size = 0x%x\n",
           configHeader->FtInformationOffset,
           configHeader->FtInformationSize);

    //
    // Print the information on disks.
    //

    diskRegistry = (PDISK_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->DiskInformationOffset);
    printf("\nDisk information for %d disks:\n",
           diskRegistry->NumberOfDisks);

    diskDescription = &diskRegistry->Disks[0];
    for (outerLoop = 0;
         outerLoop < diskRegistry->NumberOfDisks;
         outerLoop++) {

        printf("\nDisk %d signature 0x%08x has %d partitions:\n",
               outerLoop,
               diskDescription->Signature,
               diskDescription->NumberOfPartitions);

        printf("       Ln Type  Start              Length             FtGrp  Member\n");
        for (innerLoop = 0;
             innerLoop < diskDescription->NumberOfPartitions;
             innerLoop++) {
            diskPartition = &diskDescription->Partitions[innerLoop];
            printf("  %c: %c %1d   %3d  %08x:%08x  %08x:%08x  %5d  %4d  %s\n",
                   (diskPartition->DriveLetter != '\0') ?
                                               diskPartition->DriveLetter : ' ',
                   (diskPartition->AssignDriveLetter) ? 'A' : ' ',
                   diskPartition->LogicalNumber,
                   diskPartition->FtType,
                   diskPartition->StartingOffset.HighPart,
                   diskPartition->StartingOffset.LowPart,
                   diskPartition->Length.HighPart,
                   diskPartition->Length.LowPart,
                   diskPartition->FtGroup,
                   diskPartition->FtMember,
                   (diskPartition->FtState == Orphaned) ? "Orphan" :
                     (diskPartition->FtState == Regenerating) ? "Regen" :
                     (diskPartition->FtState == Initializing) ? "Init" : "");

        }

        diskDescription = (PDISK_DESCRIPTION)
          &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    //
    // Print the information for FT.
    //

    if (configHeader->FtInformationSize == 0) {
        printf("There is no FT configuration.\n");
        free(configHeader);
        return;
    }

    ftRegistry = (PFT_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->FtInformationOffset);

    printf("\nNumber of FT components = %d\n",
           ftRegistry->NumberOfComponents);

    ftDescription = &ftRegistry->FtDescription[0];
    for (outerLoop = 0;
         outerLoop < ftRegistry->NumberOfComponents;
         outerLoop++) {

        printf("Component %d has %d members and is type %d\n",
               outerLoop,
               ftDescription->NumberOfMembers,
               ftDescription->Type);

        printf("      State Signature Start              Length            #\n");
        for (innerLoop = 0;
             innerLoop < ftDescription->NumberOfMembers;
             innerLoop++) {
            ftMember = &ftDescription->FtMemberDescription[innerLoop];

            diskPartition = (PDISK_PARTITION)
                 ((PUCHAR) configHeader + ftMember->OffsetToPartitionInfo);
            
            printf("%5x    %2x %08x  %08x:%08x  %08x:%08x %d\n",
                   ftMember->OffsetToPartitionInfo,
                   ftMember->State,
                   ftMember->Signature,
                   diskPartition->StartingOffset.HighPart,
                   diskPartition->StartingOffset.LowPart,
                   diskPartition->Length.HighPart,
                   diskPartition->Length.LowPart,
                   ftMember->LogicalNumber);
        }

        ftDescription = (PFT_DESCRIPTION)
         &ftDescription->FtMemberDescription[ftDescription->NumberOfMembers];
    }
}


VOID
ChangeMemberState(
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member,
    IN FT_PARTITION_STATE NewState
    )

/*++

Routine Description:

    Set the FT state for a partition.

Arguments:

    Type   - the FT type.
    Group  - the FT Group number for that type.
    Member - the member number within the group.

Return Values:

    None.

--*/

{
    BOOLEAN             writeBackRegistry = FALSE;
    HANDLE              handle;
    ULONG               outerLoop;
    ULONG               innerLoop;
    NTSTATUS            status;
    PDISK_CONFIG_HEADER configHeader;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    PDISK_PARTITION     partitionDescription;

    status = FtOpenKey(&handle,
                       DISK_REGISTRY_KEY);

    if (!NT_SUCCESS(status)) {
        printf("Currently there is no key in the registry"
               " for the disk information.\n");
        return;
    }

    configHeader = (PDISK_CONFIG_HEADER) malloc(WORK_BUFFER_SIZE);
    if (configHeader == NULL) {
        printf("Unable to allocate memory for the disk registy information.\n");
        NtClose(handle);
        return;
    }

    RtlZeroMemory(configHeader, WORK_BUFFER_SIZE);

    status = FtReturnValue(handle,
                           (PUCHAR) DISK_REGISTRY_VALUE,
                           (PUCHAR) configHeader,
                           WORK_BUFFER_SIZE);

    if (!NT_SUCCESS(status)) {
        printf("There is no disk registry information (%x)\n", status);
        free(configHeader);
        NtClose(handle);
        return;
    }

    diskRegistry = (PDISK_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->DiskInformationOffset);

    diskDescription = &diskRegistry->Disks[0];
    for (outerLoop = 0;
         outerLoop < diskRegistry->NumberOfDisks;
         outerLoop++) {

        for (innerLoop = 0;
             innerLoop < diskDescription->NumberOfPartitions;
             innerLoop++) {

            partitionDescription = &diskDescription->Partitions[innerLoop];

            if ((partitionDescription->FtType == (FT_TYPE) Type) &&
                (partitionDescription->FtGroup == (USHORT) Group) &&
                (partitionDescription->FtMember == (USHORT) Member)) {

                partitionDescription->FtState = NewState;
                writeBackRegistry = TRUE;
                break;
            }
        }

        if (writeBackRegistry == TRUE) {
            ULONG size;

            if (configHeader->FtInformationSize == 0) {
                printf("Seems a little odd to be setting FT state " // no comma
                       "with no FT information...\n");
                size = configHeader->DiskInformationOffset +
                       configHeader->DiskInformationSize;
            } else {
                size = configHeader->FtInformationOffset +
                       configHeader->FtInformationSize;
            }

            (VOID) FtSetValue(handle,
                              (PUCHAR) DISK_REGISTRY_VALUE,
                              (PUCHAR) configHeader,
                              size,
                              REG_BINARY);
            break;
        }
        diskDescription = (PDISK_DESCRIPTION)
              &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    NtClose(handle);
    free(configHeader);
}


VOID
RestoreOrphan(
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member
    )

/*++

Routine Description:

    Set the FT state for a partition back to Healthy.

Arguments:

    Type   - the FT type.
    Group  - the FT Group number for that type.
    Member - the member number within the group.

Return Values:

    None.

--*/

{
    ChangeMemberState(Type,
                      Group,
                      Member,
                      Healthy);
}


VOID
OrphanMember(
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member
    )

/*++

Routine Description:

    Set the FT state for a partition to Orphaned.

Arguments:

    Type   - the FT type.
    Group  - the FT Group number for that type.
    Member - the member number within the group.

Return Values:

    None.

--*/

{
    ChangeMemberState(Type,
                      Group,
                      Member,
                      Orphaned);
}


VOID
RegenerateMember(
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member
    )

/*++

Routine Description:

    Set the FT state for a partition to regenerate.

Arguments:

    Type   - the FT type.
    Group  - the FT Group number for that type.
    Member - the member number within the group.

Return Values:

    None.

--*/

{
    ChangeMemberState(Type,
                      Group,
                      Member,
                      Regenerating);
}


VOID
FixDisk()

/*++

Routine Description:

    Fix the disk signatures in the registry.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ULONG               outerLoop;
    ULONG               innerLoop;
    ULONG               length;
    HANDLE              handle;
    NTSTATUS            status;
    PDISK_CONFIG_HEADER configHeader;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    PFT_REGISTRY        ftRegistry;
    PFT_DESCRIPTION     ftDescription;
    PFT_MEMBER_DESCRIPTION ftMember;
    UCHAR               prompt[128];
    PUCHAR              hexString;
    BOOLEAN             changed = FALSE;

    status = FtOpenKey(&handle,
                       DISK_REGISTRY_KEY);

    if (!NT_SUCCESS(status)) {
        printf("Currently there is no key in the registry"
               " for the disk information.\n");
        return;
    }

    configHeader = (PDISK_CONFIG_HEADER) malloc(WORK_BUFFER_SIZE);
    if (configHeader == NULL) {
        printf("Unable to allocate memory for the disk registy information.\n");
        NtClose(handle);
        return;
    }

    RtlZeroMemory(configHeader, WORK_BUFFER_SIZE);

    status = FtReturnValue(handle,
                           (PUCHAR) DISK_REGISTRY_VALUE,
                           (PUCHAR) configHeader,
                           WORK_BUFFER_SIZE);

    if (!NT_SUCCESS(status)) {
        printf("There is no disk registry information (%x)\n", status);
        free(configHeader);
        NtClose(handle);
        return;
    }

    diskRegistry = (PDISK_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->DiskInformationOffset);
    printf("\nDisk information for %d disks:\n",
           diskRegistry->NumberOfDisks);

    diskDescription = &diskRegistry->Disks[0];
    for (outerLoop = 0;
         outerLoop < diskRegistry->NumberOfDisks;
         outerLoop++) {

        sprintf(prompt,
               "\nDisk %d signature 0x%08x = ",
               outerLoop,
               diskDescription->Signature);

        hexString = GetArgumentString((BOOLEAN) FALSE,
                                      prompt,
                                      (BOOLEAN) TRUE);

        if (hexString != NULL) {

            changed = ProcessHex(hexString, &diskDescription->Signature);
        }

        diskDescription = (PDISK_DESCRIPTION)
          &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    //
    // Print the information for FT.
    //

    if (configHeader->FtInformationSize == 0) {
        printf("There is no FT configuration.\n");
        free(configHeader);
        NtClose(handle);
        return;
    }

    ftRegistry = (PFT_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->FtInformationOffset);

    printf("\nNumber of FT components = %d\n",
           ftRegistry->NumberOfComponents);

    ftDescription = &ftRegistry->FtDescription[0];
    for (outerLoop = 0;
         outerLoop < ftRegistry->NumberOfComponents;
         outerLoop++) {

        printf("Component %d has %d members and is type %d\n",
               outerLoop,
               ftDescription->NumberOfMembers,
               ftDescription->Type);

        for (innerLoop = 0;
             innerLoop < ftDescription->NumberOfMembers;
             innerLoop++) {
            ftMember = &ftDescription->FtMemberDescription[innerLoop];

            sprintf(prompt,
                    "FT Member Signature 0x%x = ",
                    ftMember->Signature);

            hexString = GetArgumentString((BOOLEAN) FALSE,
                                          prompt,
                                          (BOOLEAN) TRUE);

            if (hexString != NULL) {

                changed = ProcessHex(hexString, &ftMember->Signature);
            }
        }

        ftDescription = (PFT_DESCRIPTION)
         &ftDescription->FtMemberDescription[ftDescription->NumberOfMembers];
    }

    if (changed == TRUE) {

        printf("Attempting to update registry information.\n");

        //
        // Delete the current registry value and write the new one.
        //

        status = FtDeleteValue(handle,
                               DISK_REGISTRY_VALUE);

        if (!NT_SUCCESS(status)) {
            printf("Could not delete value (0x%x).\n", status);
        } else {

            length = (ULONG) ((PCHAR)ftDescription - (PUCHAR)configHeader);
            status = FtSetValue(handle,
                                DISK_REGISTRY_VALUE,
                                configHeader,
                                length,
                                REG_BINARY);
            if (!NT_SUCCESS(status)) {
                printf("Could not write value (0x%x)\n.", status);
            }
        }
    }

    NtClose(handle);
}

PDISK_CONFIG_HEADER
GetDiskInfo()

/*++

--*/

{
    HANDLE              handle;
    ULONG               length;
    NTSTATUS            status;
    PDISK_CONFIG_HEADER configHeader;

    status = FtOpenKey(&handle,
                       DISK_REGISTRY_KEY);

    if (!NT_SUCCESS(status)) {
        printf("Currently there is no key in the registry"
               " for the disk information.\n");
        return NULL;
    }

    configHeader = (PDISK_CONFIG_HEADER) malloc(WORK_BUFFER_SIZE);
    if (configHeader == NULL) {
        printf("Unable to allocate memory for the disk registy information.\n");
        NtClose(handle);
        return NULL;
    }

    RtlZeroMemory(configHeader, WORK_BUFFER_SIZE);

    status = FtReturnValue(handle,
                           (PUCHAR) DISK_REGISTRY_VALUE,
                           (PUCHAR) configHeader,
                           WORK_BUFFER_SIZE);
    NtClose(handle);

    if (!NT_SUCCESS(status)) {
        printf("There is no disk registry information (%x)\n", status);
        free(configHeader);
        return NULL;
    }

    return configHeader;
}


BOOLEAN
CreateFtMember(
    IN PDISK_CONFIG_HEADER ConfigHeader,
    IN ULONG Disk,
    IN ULONG Partition,
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member
    )

/*++

--*/

{
    ULONG               innerLoop;
    ULONG               outerLoop;
    ULONG               length;
    NTSTATUS            status;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    PDISK_PARTITION     diskPartition;

    diskRegistry = (PDISK_REGISTRY)
                 ((PUCHAR) ConfigHeader + ConfigHeader->DiskInformationOffset);
    diskDescription = &diskRegistry->Disks[0];

    //
    // Have to walk the disk information by hand to find a match on
    // disk number and partition
    //

    for (outerLoop = 0;
         outerLoop < diskRegistry->NumberOfDisks;
         outerLoop++) {

        if (outerLoop == Disk) {
            for (innerLoop = 0;
                 innerLoop < diskDescription->NumberOfPartitions;
                 innerLoop++) {
                diskPartition = &diskDescription->Partitions[innerLoop];
    
                if (diskPartition->LogicalNumber == Partition) {
    
                    //
                    // Found a match.
                    //

                    diskPartition->FtType = Type;
                    diskPartition->FtMember = Member;
                    diskPartition->FtGroup = Group;
                    diskPartition->FtState = Healthy;
                    diskPartition->AssignDriveLetter = FALSE;
                    return TRUE;
                }
            }
        }

        diskDescription = (PDISK_DESCRIPTION)
          &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    //
    // Didn't find it.
    //

    return FALSE;
}


#define DRIVER_KEY "\\REGISTRY\\MACHINE\\System\\CurrentControlSet\\Services"

#define TYPE_KEY     "Type"
#define START_KEY    "Start"
#define GROUP_KEY    "Group"
#define DEPENDENCIES "DependOnGroup"

#if 0
VOID
DisplayLoadInformation(
    IN PUNICODE_STRING DriverKey
    )

/*++

Routine Description:


Arguments:

    DriverKey - a Unicode string pointer for the driver key name.

Return Value:

    None.

--*/

{
    HANDLE         keyHandle;
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeValueName;
    ULONG          resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    resultLength = WORK_BUFFER_SIZE;
    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)malloc(WORK_BUFFER_SIZE);

    //
    // Type
    //

    //
    // Start
    //

    //
    // Group
    //

    //
    // DependOnGroup
    //

    while (1) {

        RtlZeroMemory(keyValueInformation, resultLength);
        status = NtEnumerateValueKey(KeyHandle,
                                     0,
                                     KeyValueFullInformation,
                                     keyValueInformation,
                                     resultLength,
                                     &resultLength);

        if (status == STATUS_BUFFER_OVERFLOW) {
            free(keyValueInformation);
            keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                       malloc(resultLength + 10);
        } else {
            break;
        }
    }

    free(keyValueInformation);
    NtClose(keyHandle);
}
#else
VOID
DisplayLoadInformation(
    IN PUCHAR DriverKey
    )
{
    UNREFERENCED_PARAMETER(DriverKey);
}
#endif



#define TEMP_BUFFER_SIZE 256
VOID
ListDrivers()

/*++

Routine Description:

    Got to the load list for the drivers, interpret and display what is there.

Arguments:

    None.

Return Value:

    NONE

--*/

{
    int            index;
    NTSTATUS       status;
    HANDLE         keyHandle;
    ULONG          resultLength;
    UCHAR          tempBuffer[TEMP_BUFFER_SIZE];
    ANSI_STRING    ansiString;
    UNICODE_STRING unicodeValueName;
    PKEY_BASIC_INFORMATION keyInformation;

    keyInformation = (PKEY_BASIC_INFORMATION)malloc(WORK_BUFFER_SIZE);

    status = FtOpenKey(&keyHandle, DRIVER_KEY);

    if (!NT_SUCCESS(status)) {

        printf("Could not open Services key (0x%x).\n", status);
        return;
    }

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(keyInformation, WORK_BUFFER_SIZE);

        status = NtEnumerateKey(keyHandle,
                                index,
                                KeyBasicInformation,
                                keyInformation,
                                WORK_BUFFER_SIZE,
                                &resultLength);

        if (status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(status)) {

            printf("readreg: Error on Enumerate status = %x\n", status);
            break;

        }

        unicodeValueName.Length = (USHORT)keyInformation->NameLength;
        unicodeValueName.MaximumLength = (USHORT)keyInformation->NameLength;
        unicodeValueName.Buffer = (PWSTR)&keyInformation->Name[0];

        ansiString.MaximumLength = TEMP_BUFFER_SIZE;
        ansiString.Length = 0L;
        ansiString.Buffer = &tempBuffer[0];

        RtlUnicodeStringToAnsiString(&ansiString,
                                     &unicodeValueName,
                                     (BOOLEAN) FALSE);

        //
        // Now have the key name for the driver - concatenate it and
        // call the routine to display what is in the key.
        //

        sprintf(WorkingDirectory,
                "%s\\%s",
                DRIVER_KEY,
                tempBuffer);

        DisplayLoadInformation(WorkingDirectory);
    }

    free(keyInformation);
    NtClose(keyHandle);
}


VOID
main()

/*++

Routine Description:

    The main entry point for the user process.
    This process will prompt the user for the action desired.  This
    includes starting performance, stopping performance, and retreiving
    performance data collected by the FT driver.

Arguments:

    Command line:
        No options.

Return Value:

    NONE

--*/

{
    NTSTATUS status;
    BOOLEAN  batch;
    PUCHAR   argumentString;
    int      commandCode;
    HANDLE   keyHandle;


    status = FtOpenKey(&keyHandle, REGISTRY_BASE);

    if (!NT_SUCCESS(status)) {

        printf("readreg: Unable to open registry base (0x%x)\n", status);
        exit(1);
    }

    sprintf(CurrentDirectory,
            REGISTRY_BASE);

    //
    // See if we are connected to CON
    //

    batch = FALSE;
//  batch = (BOOLEAN)(!isatty(0));

    if (!batch) {
        printf("FT registry edit utility.  %s:\n", Version);
    }

    while(1) {
        while ((commandCode = GetCommand(batch,
                                         &argumentString)) == INVALID) {

            //
            // Continue until we get a valid command.
            //

        }

        if (Debug) {
            printf("Command code == %d, argumentString = %s\n",
                   commandCode,
                   (argumentString == NULL) ? "(none)" : argumentString);
        }

        switch (commandCode) {

        case DIRLONG:

            Directory(keyHandle, (BOOLEAN) TRUE);
            break;

        case DIR:

            Directory(keyHandle, (BOOLEAN) FALSE);
            break;

        case CREATE:
        {
            ULONG   index;
            PUCHAR  keyClass;
            BOOLEAN classAllocated = FALSE;

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "Key Name = ", 
                                                   (BOOLEAN) FALSE);
            }

            if (argumentString == NULL) {
                break;
            }

            sprintf(WorkingDirectory,
                    "%s\\%s",
                    CurrentDirectory,
                    argumentString);

            argumentString = GetArgumentString(batch,
                                               "Key Class = ",
                                               (BOOLEAN) FALSE);

            if (argumentString == NULL) {
                keyClass = "Default Class";
            } else {
                keyClass = (PUCHAR) malloc(strlen(argumentString) + FUDGE);
                classAllocated = TRUE;

                sprintf(keyClass,
                        "%s",
                        argumentString);
            }

            argumentString = GetArgumentString(batch,
                                               "Index = ",
                                               (BOOLEAN) TRUE);

            if (argumentString == NULL) {
                index = 1;
            } else {
                index = ParseArgumentNumeric(&argumentString);
            }

            if (Debug) {
                printf("Creating key %s, index %d with class %s\n",
                       WorkingDirectory,
                       index,
                       keyClass);
            }

            status = FtCreateKey(WorkingDirectory,
                                 keyClass,
                                 index);

            if (!NT_SUCCESS(status)) {

                printf("Could not create key %s (0x%x).\n",
                       WorkingDirectory,
                       status);
            }

            if (classAllocated == TRUE) {
                free(keyClass);
            }

            break;
        }

        case LIST:

            List(keyHandle,
                 argumentString);
            break;

        case CHDIR:

            NtClose(keyHandle);

            if (argumentString == NULL) {

                argumentString = GetArgumentString(batch,
                                                   "New location = ",
                                                   (BOOLEAN) TRUE);
            }

            if (argumentString != NULL) {

                if (*argumentString == '\\') {

                    //
                    // Root relative string.
                    // Use text provided (i.e. %s is to avoid user crashing
                    // by putting %s in the string).
                    //

                    sprintf(WorkingDirectory,
                            "%s",
                            argumentString);

                } else {

                    while ((*argumentString == '.') &&
                           (*(argumentString + 1) == '.')) {

                        if ((*(argumentString + 2) == '\\') ||
                            (*(argumentString + 2) == '\0')) {

                            PUCHAR cptr = CurrentDirectory;

                            //
                            // move argumentString past ".."
                            //

                            argumentString += 2;

                            //
                            // Find end of current directory.
                            //

                            while (*cptr != '\0') {
                                cptr++;
                            }

                            //
                            // Backup to last component.
                            //

                            while (*cptr != '\\') {
                                cptr--;
                            }

                            if (cptr == CurrentDirectory) {

                                //
                                // Cannot backup anymore.  Continue parsing
                                // argument.
                                //

                                continue;
                            }

                            //
                            // Remove component from path.
                            //

                            *cptr = '\0';

                            if (*argumentString == '\0') {

                                //
                                // All done with argument.
                                //

                                break;
                            }

                            //
                            // Step around backslash.
                            //

                            argumentString++;

                        } else {

                            //
                            // Assume it is a real name.
                            //

                            break;
                        }
                    }

                    if (*argumentString != '\0') {
                        sprintf(WorkingDirectory,
                                "%s\\%s",
                                CurrentDirectory,
                                argumentString);
                    } else {
                        sprintf(WorkingDirectory,
                                "%s",
                                CurrentDirectory);
                    }
                }

                status = FtOpenKey(&keyHandle,
                                   WorkingDirectory);

                if (NT_SUCCESS(status)) {

                    sprintf(CurrentDirectory,
                            "%s",
                            WorkingDirectory);
                } else {

                    (VOID) FtOpenKey(&keyHandle,
                                     CurrentDirectory);

                    //
                    // No error checks because this was opened once before.
                    //
                }

            }

            break;

        case HELP:
        {
            int i;

            printf("Valid commands are:\n");

            for (i = 0; Commands[i] != NULL; i++) {
                printf("  %10s  - %s\n",
                       Commands[i],
                       CommandHelp[CommandMap[i]]);
            }
            break;
        }

        case QUIT:

            exit(0);
            break;

        case DDEBUG:

            if (argumentString == NULL) {

                if (Debug) {

                    printf("Debug turned off.\n");
                    Debug = 0;
                } else {

                    Debug = 1;
                }
            } else {

                Debug = atoi(argumentString);
                printf("Debug set to %d\n", Debug);
            }
            break;

        case SETVALUE:
        {
            int    i;
            BOOLEAN convertToUnicode = FALSE;
            PUCHAR valueName;
            PUCHAR valueData;
            ULONG  valueLength;
            ULONG  valueWord;
            PVOID  valuePtr;
            ULONG  type = DEFAULT_TYPE;
            STRING         valueString;
            UNICODE_STRING unicodeValue;
            BOOLEAN dataAllocated = FALSE;
            BOOLEAN unicodeAllocated = FALSE;

            if (argumentString == NULL) {

                argumentString = GetArgumentString(batch,
                                                   "Value Name = ",
                                                   (BOOLEAN) FALSE);
            }

            if (argumentString == NULL) {

                break;
            }

            valueName = (PUCHAR) malloc(strlen(argumentString) + FUDGE);

            sprintf(valueName,
                    "%s",
                    argumentString);

            //
            // print a help banner on type and get the type.
            //

            for (i = 0; TypeNames[i] != NULL; i++) {

                printf("%d - %s\n", TypeNumbers[i], TypeNames[i]);
            }
            printf("# - Other numbers are user defined\n");
            argumentString = GetArgumentString(batch,
                                               "Numeric value for type = ",
                                               (BOOLEAN) TRUE);

            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            }

            switch(type)
            {
            default:
            case REG_SZ:
                if (type == REG_SZ) {
                    convertToUnicode = TRUE;
                    printf("Typed in string will be converted to unicode...\n");
                    argumentString = GetArgumentString(batch,
                                                       "Value Data = ",
                                                       (BOOLEAN) FALSE);
                } else {
                    printf("For now the data must be typed in...\n");
                    argumentString = GetArgumentString(batch,
                                                       "Value Data = ",
                                                       (BOOLEAN) FALSE);
                }

                if (argumentString == NULL) {
                    valueData = "Default Data";
                    valueLength = strlen(valueData);
                } else {
                    valueData = (PUCHAR) malloc(strlen(argumentString) + FUDGE);
                    dataAllocated = TRUE;
                    sprintf(valueData,
                            "%s",
                            argumentString);
                    if (convertToUnicode == TRUE) {
                        RtlInitString(&valueString,
                                      valueData);
                        RtlAnsiStringToUnicodeString(&unicodeValue,
                                                     &valueString,
                                                     (BOOLEAN) TRUE);
                        unicodeAllocated = TRUE;
                        valueLength = unicodeValue.Length + 2;
                    } else {
                        valueLength = strlen(valueData);
                    }
                }

                break;

            case REG_DWORD:
                argumentString = GetArgumentString(batch,
                                                   "Value Data Word = ",
                                                   (BOOLEAN) TRUE);
                if (argumentString == NULL) {
                    valueWord = 0;
                } else {
                    valueWord = ParseArgumentNumeric(&argumentString);
                }

                valueLength = sizeof(ULONG);
                break;
            }

            switch (type) {

            case REG_DWORD:
                valuePtr = (PVOID) &valueWord;
                break;

            case REG_SZ:
                valuePtr = (PVOID) unicodeValue.Buffer;
                break;

            default:
                valuePtr = (PVOID) valueData;
                break;
            }
            status = FtSetValue(keyHandle,
                                valueName,
                                valuePtr,
                                valueLength,
                                type);

            if (!NT_SUCCESS(status)) {
                printf("Could not set value %s (0x%x).\n", valueName, status);
            }

            free(valueName);
            if (dataAllocated == TRUE) {
                free(valueData);
            }
            if (unicodeAllocated == TRUE) {
                RtlFreeUnicodeString(&unicodeValue);
            }
            break;
        }

        case DELKEY:
        {
            if (argumentString == NULL) {

                argumentString = GetArgumentString(batch,
                                                   "Key Name = ",
                                                   (BOOLEAN) TRUE);
            }

            if (argumentString == NULL) {

                break;
            }

            sprintf(WorkingDirectory,
                    "%s\\%s",
                    CurrentDirectory,
                    argumentString);

            status = FtDeleteKey(WorkingDirectory);

            if (!NT_SUCCESS(status)) {
                printf("Unable to delete key %s (0x%x)\n",
                       WorkingDirectory,
                       status);
            }

            break;
        }

        case DELVALUE:
        {
            if (argumentString == NULL) {

                argumentString = GetArgumentString(batch,
                                                   "Key Name = ",
                                                   (BOOLEAN) TRUE);
            }

            if (argumentString == NULL) {

                break;
            }

            status = FtDeleteValue(keyHandle,
                                   argumentString);

            if (!NT_SUCCESS(status)) {

                printf("Unable to delete value %s (0x%x)\n",
                       argumentString,
                       status);
            }
            break;
        }

        case INLONG:
            DumpControl = InLongs;
            break;

        case INSHORT:
            DumpControl = InShorts;
            break;

        case INBYTE:
            DumpControl = InBytes;
            break;

        case DUMP:

            if (ForceDump) {
                ForceDump = 0;
            } else {
                ForceDump++;
            }
            break;

        case DISKREG:
            DiskDump();
            break;

        case FIXDISK:
            FixDisk();
            break;

        case RESTORE:
        {
            ULONG type;
            ULONG group;
            ULONG member;

            printf("FT types that can be restored are:\n");
            printf("\t%d - for Mirrors\n", Mirror);
            printf("\t%d - for Stripes with parity\n", StripeWithParity);

            //
            // Get the type
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT volume type = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the group
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT group number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the member
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT member number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                member = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            RestoreOrphan(type, group, member);
            break;
        }

        case DRIVERS:
            NotImplemented();
            // ListDrivers();
            break;

        case ORPHAN:
        {
            ULONG type;
            ULONG group;
            ULONG member;

            printf("FT types that can be orphaned are:\n");
            printf("\t%d - for Mirrors\n", Mirror);
            printf("\t%d - for Stripes with parity\n", StripeWithParity);

            //
            // Get the type
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT volume type = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the group
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT group number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the member
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT member number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                member = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            OrphanMember(type, group, member);
            break;
        }

        case REGEN:
        {
            ULONG type;
            ULONG group;
            ULONG member;

            printf("FT types that can be regenerated are:\n");
            printf("\t%d - for Mirrors\n", Mirror);
            printf("\t%d - for Stripes with parity\n", StripeWithParity);

            //
            // Get the type
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT volume type = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the group
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT group number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the member
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT member number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                member = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            RegenerateMember(type, group, member);
            break;
        }

        case INIT:
        {
            ULONG type;
            ULONG group;
            ULONG member;

            printf("Only stripes with parity are initialized.\n");

            //
            // Get the group
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                               "Parity stripe group number = ",
                                               (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            ChangeMemberState(StripeWithParity,
                              group,
                              0,
                              Initializing);
            break;
        }

        case MAKEFT:
        {
            ULONG type;
            ULONG group;
            ULONG member;
            ULONG disk;
            ULONG partition;
            PDISK_CONFIG_HEADER configHeader;
            BOOLEAN doUpdate = TRUE;

            configHeader = GetDiskInfo();
            if (configHeader == NULL) {
                break;
            }
            printf("\t%d for Mirrors\n", Mirror);
            printf("\t%d for Stripe Set\n", Stripe);
            printf("\t%d for Stripe with parity\n", StripeWithParity);
            printf("\t%d for Volume Set\n", VolumeSet);

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "Which FT set to create? ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "Please give an FT group # - ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            for (member = 0; TRUE; member++) {
                printf("Information for member %d\n", member);

                if (argumentString == NULL) {
                    argumentString = GetArgumentString(batch,
                                                       "Disk Number = ",
                                                       (BOOLEAN) TRUE);
                }

                if (argumentString != NULL) {
                    disk = ParseArgumentNumeric(&argumentString);
                } else {
                    break;
                }

                if (argumentString == NULL) {
                    argumentString = GetArgumentString(batch,
                                                       "Partition Number = ",
                                                       (BOOLEAN) TRUE);
                }

                if (argumentString != NULL) {
                    partition = ParseArgumentNumeric(&argumentString);
                } else {
                    break;
                }

                if (CreateFtMember(configHeader, disk, partition, type, group, member) == FALSE) {
                    printf("Failed to change member state\n");
                    printf("No update will be made\n");
                    doUpdate = FALSE;
                    break;
                }
            }
            if (doUpdate == TRUE) {
                PDISK_REGISTRY diskRegistry;
                diskRegistry = (PDISK_REGISTRY)
                             ((PUCHAR) configHeader + configHeader->DiskInformationOffset);
                DiskRegistrySet(diskRegistry);
            }
            free(configHeader);
            break;
        }

        default:

            printf("WDF homer?!?\n");
            break;
        }
    }
} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\ia64\initia64.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    init386.c

Abstract:

    This module is responsible to build any x86 specific entries in
    the hardware tree of registry.

Author:

    Ken Reneris (kenr) 04-Aug-1992


Environment:

    Kernel mode.

Revision History:

    shielint - add BIOS date and version detection.

--*/

#include "cmp.h"
#include "stdio.h"
#include "smbios.h"


//
// Title Index is set to 0.
// (from ..\cmconfig.c)
//

#define TITLE_INDEX_VALUE 0

extern PCHAR SearchStrings[];
extern PCHAR BiosBegin;
extern PCHAR Start;
extern PCHAR End;
extern UCHAR CmpID[];
extern WCHAR CmpVendorID[];
extern WCHAR CmpProcessorNameString[];
extern WCHAR CmpFeatureBits[];
extern WCHAR CmpMHz[];
extern WCHAR CmpUpdateSignature[];
extern UCHAR CmpIntelID[];
extern UCHAR CmpItanium[];
extern UCHAR CmpMcKinley[];
extern UCHAR CmpIA64Proc[];

//
// Bios date and version definitions
//

#define BIOS_DATE_LENGTH 64
#define MAXIMUM_BIOS_VERSION_LENGTH 128

WCHAR   SystemBIOSDateString[BIOS_DATE_LENGTH];
WCHAR   SystemBIOSVersionString[MAXIMUM_BIOS_VERSION_LENGTH];
WCHAR   VideoBIOSDateString[BIOS_DATE_LENGTH];
WCHAR   VideoBIOSVersionString[MAXIMUM_BIOS_VERSION_LENGTH];

//
// Extended CPUID function definitions
//

#define CPUID_PROCESSOR_NAME_STRING_SZ  65
#define CPUID_EXTFN_BASE                0x80000000
#define CPUID_EXTFN_PROCESSOR_NAME      0x80000002


extern ULONG CmpConfigurationAreaSize;
extern PCM_FULL_RESOURCE_DESCRIPTOR CmpConfigurationData;


BOOLEAN
CmpGetBiosVersion (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR VersionString
    );

BOOLEAN
CmpGetBiosDate (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR DateString
    );

ULONG
Ke386CyrixId (
    VOID
    );

VOID
InitializeProcessorInformationFromSMBIOS(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpInitializeMachineDependentConfiguration)
#pragma alloc_text(INIT,InitializeProcessorInformationFromSMBIOS)
#endif


#if 0
//
// Use SMBIOS to gather this information.
//

BOOLEAN
CmpGetBiosDate (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR DateString
    )

/*++

Routine Description:

    This routine finds the most recent date in the computer/video
    card's ROM.  When GetRomDate encounters a datae, it checks the
    previously found date to see if the new date is more recent.

Arguments:

    SearchArea - the area to search for a date.

    SearchLength - Length of search.

    DateString - Supplies a pointer to a fixed length memory to receive
                 the date string.

Return Value:

    NT_SUCCESS if a date is found.

--*/

{
    BOOLEAN FoundFlag = TRUE;        // Set to TRUE if the item was found
    CHAR PrevDate[BIOS_DATE_LENGTH]; // Date currently being examined
    CHAR CurrDate[BIOS_DATE_LENGTH]; // Date currently being examined
    PCHAR String;
    USHORT i;                        // Looping variable
    USHORT Length;                   // Number of characters to move
    PCHAR Start = SearchArea + 2;
    PCHAR End = SearchArea + SearchLength - 5;

    //
    // Clear out the previous date
    //

    RtlZeroMemory(PrevDate, BIOS_DATE_LENGTH);

    while (FoundFlag) {

        String = NULL;

        //
        // Search for '/' with a digit on either side and another
        // '/' 3 character away.
        //

        while (Start < End) {
            if (*Start == '/' && *(Start+3) == '/' &&
                (*(Start+1) <= '9' && *(Start+1) >= '0') &&
                (*(Start-1) <= '9' && *(Start-1) >= '0') &&
                (*(Start+5) <= '9' && *(Start+5) >= '0') &&
                (*(Start+4) <= '9' && *(Start+4) >= '0') &&
                (*(Start+2) <= '9' && *(Start+2) >= '0')) {

                String = Start;
                break;
            } else {
                Start++;
            }
        }

        if (String) {
            Start = String + 3;
            String -= 2;                 // Move String to the beginning of
                                         //   date.
            //
            // Copy the year into CurrDate
            //

            CurrDate[0] = String[6];
            CurrDate[1] = String[7];
            CurrDate[2] = '/';           // The 1st "/" for YY/MM/DD

            //
            // Copy the month & day into CurrDate
            //   (Process properly if this is a one digit month)
            //

            if (*String > '9' || *String < '0') {
                CurrDate[3] = '0';
                String++;
                i = 4;
                Length = 4;
            } else {
                i = 3;
                Length = 5;
            }

            RtlMoveMemory(&CurrDate[i], String, Length);

            //
            // Compare the dates, to see which is more recent
            //

            if (memcmp (PrevDate, CurrDate, BIOS_DATE_LENGTH - 1) < 0) {
                RtlMoveMemory(PrevDate, CurrDate, BIOS_DATE_LENGTH - 1);
            }
        } else {
            FoundFlag = FALSE;
        }
    }

    //
    // If we did not find a date
    //

    if (PrevDate[0] == '\0') {
        DateString[0] = '\0';
        return (FALSE);
    }

    //
    // Put the date from chPrevDate's YY/MM/DD format
    //   into pchDateString's MM/DD/YY format

    DateString[5] = '/';
    DateString[6] = PrevDate[0];
    DateString[7] = PrevDate[1];
    RtlMoveMemory(DateString, &PrevDate[3], 5);
    DateString[8] = '\0';

    return (TRUE);
}

BOOLEAN
CmpGetBiosVersion (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR VersionString
    )

/*++

Routine Description:

    This routine finds the version number stored in ROM, if any.

Arguments:

    SearchArea - the area to search for the version.

    SearchLength - Length of search

    VersionString - Supplies a pointer to a fixed length memory to receive
                 the version string.

Return Value:

    TRUE if a version number is found.  Else a value of FALSE is returned.

--*/
{
    PCHAR String;
    USHORT Length;
    USHORT i;
    CHAR Buffer[MAXIMUM_BIOS_VERSION_LENGTH];
    PCHAR BufferPointer;

        if (SearchArea != NULL) {

        //
        // If caller does not specify the search area, we will search
        // the area left from previous search.
        //

        BiosBegin = SearchArea;
        Start = SearchArea + 1;
        End = SearchArea + SearchLength - 2;
    }

    while (1) {

         //
         // Search for a period with a digit on either side
         //

         String = NULL;
         while (Start <= End) {
             if (*Start == '.' && *(Start+1) >= '0' && *(Start+1) <= '9' &&
                 *(Start-1) >= '0' && *(Start-1) <= '9') {
                 String = Start;
                 break;
             } else {
                 Start++;
             }
         }

         if (Start > End) {
             return(FALSE);
         } else {
             Start += 2;
         }

         Length = 0;
         Buffer[MAXIMUM_BIOS_VERSION_LENGTH - 1] = '\0';
         BufferPointer = &Buffer[MAXIMUM_BIOS_VERSION_LENGTH - 1];

         //
         // Search for the beginning of the string
         //

         String--;
         while (Length < MAXIMUM_BIOS_VERSION_LENGTH - 8 &&
                String >= BiosBegin &&
                *String >= ' ' && *String <= 127 &&
                *String != '$') {
             --BufferPointer;
             *BufferPointer = *String;
             --String, ++Length;
         }
         ++String;

         //
         // Can one of the search strings be found
         //

         for (i = 0; SearchStrings[i]; i++) {
             if (strstr(BufferPointer, SearchStrings[i])) {
                 goto Found;
             }
         }
    }

Found:

    //
    // Skip leading white space
    //

    for (; *String == ' '; ++String)
      ;

    //
    // Copy the string to user supplied buffer
    //

    for (i = 0; i < MAXIMUM_BIOS_VERSION_LENGTH - 1 &&
         String <= (End + 1) &&
         *String >= ' ' && *String <= 127 && *String != '$';
         ++i, ++String) {
         VersionString[i] = *String;
    }
    VersionString[i] = '\0';
    return (TRUE);
}

#endif  // #if 0





NTSTATUS
CmpInitializeMachineDependentConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine creates IA64 specific entries in the registry.

Arguments:

    LoaderBlock - supplies a pointer to the LoaderBlock passed in from the
                  OS Loader.

Returns:

    NTSTATUS code for sucess or reason of failure.

--*/
{
    NTSTATUS Status;
    ULONG VideoBiosStart;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING ValueData;
    ANSI_STRING AnsiString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;
    HANDLE ParentHandle;
    HANDLE BaseHandle, NpxHandle;
    HANDLE CurrentControlSet;
    CONFIGURATION_COMPONENT_DATA CurrentEntry;
    PUCHAR VendorID;
    UCHAR  Buffer[MAXIMUM_BIOS_VERSION_LENGTH];
    PKPRCB Prcb;
    ULONG  i, Junk;
    ULONG VersionsLength = 0, Length;
    PCHAR VersionStrings, VersionPointer;
    UNICODE_STRING SectionName;
    ULONG ViewSize;
    LARGE_INTEGER ViewBase;
    PVOID BaseAddress;
    USHORT DeviceIndexTable[NUMBER_TYPES];
    ULONG CpuIdFunction;
    ULONG MaxExtFn;
    PULONG NameString = NULL;
    ULONG ReturnedLength;
    struct {
        union {
            UCHAR   Bytes[CPUID_PROCESSOR_NAME_STRING_SZ];
            ULONG   DWords[1];
        } u;
    } ProcessorNameString;

    for (i = 0; i < NUMBER_TYPES; i++) {
        DeviceIndexTable[i] = 0;
    }


    //
    // Go get a bunch of information out of SMBIOS
    //
    InitializeProcessorInformationFromSMBIOS(LoaderBlock);



    InitializeObjectAttributes( &ObjectAttributes,
                                &CmRegistryMachineHardwareDescriptionSystemName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtOpenKey( &ParentHandle,
                        KEY_READ,
                        &ObjectAttributes
                      );

    if (!NT_SUCCESS(Status)) {
        // Something is really wrong...
        return Status;
    }


    //
    // On an ARC machine the processor(s) are included in the hardware
    // configuration passed in from bootup.  Since there's no standard
    // way to get all the ARC information for each processor in an MP
    // machine via pc-ROMs the information will be added here (if it's
    // not already present).
    //

    RtlInitUnicodeString( &KeyName,
                          L"CentralProcessor"
                        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        ParentHandle,
        NULL
        );

    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtCreateKey(
                &BaseHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                TITLE_INDEX_VALUE,
                &CmClassName[ProcessorClass],
                0,
                &Disposition
                );

    NtClose (BaseHandle);

    if (Disposition == REG_CREATED_NEW_KEY) {

        //
        // The ARC rom didn't add the processor(s) into the registry.
        // Do it now.
        //

        CmpConfigurationData = (PCM_FULL_RESOURCE_DESCRIPTOR)ExAllocatePool(
                                            PagedPool,
                                            CmpConfigurationAreaSize
                                            );

        if (CmpConfigurationData == NULL) {
            // bail out
            NtClose (ParentHandle);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        for (i=0; i < (ULONG)KeNumberProcessors; i++) {
            Prcb = KiProcessorBlock[i];

            RtlZeroMemory (&CurrentEntry, sizeof CurrentEntry);
            CurrentEntry.ComponentEntry.Class = ProcessorClass;
            CurrentEntry.ComponentEntry.Type = CentralProcessor;
            CurrentEntry.ComponentEntry.Key = i;
            CurrentEntry.ComponentEntry.AffinityMask = AFFINITY_MASK(i);

            CurrentEntry.ComponentEntry.Identifier = Buffer;

            sprintf( Buffer, CmpID,
                     Prcb->ProcessorFamily,
                     Prcb->ProcessorModel,
                     Prcb->ProcessorRevision
                   );

            CurrentEntry.ComponentEntry.IdentifierLength =
                strlen (Buffer) + 1;

            Status = CmpInitializeRegistryNode(
                &CurrentEntry,
                ParentHandle,
                &BaseHandle,
                -1,
                (ULONG)-1,
                DeviceIndexTable
                );

            if (!NT_SUCCESS(Status)) {
                return(Status);
            }

            VendorID = Prcb->ProcessorVendorString;
            if ( *VendorID == '\0' ) {
               VendorID = NULL;
            }

            if (VendorID) {

                //
                // Add Vendor Indentifier to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpVendorID
                    );

                RtlInitAnsiString(
                    &AnsiString,
                    VendorID
                    );

                RtlAnsiStringToUnicodeString(
                    &ValueData,
                    &AnsiString,
                    TRUE
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            ValueData.Buffer,
                            ValueData.Length + sizeof( UNICODE_NULL )
                            );

                RtlFreeUnicodeString(&ValueData);
            }

            if ( VendorID && !strcmp( VendorID, CmpIntelID ) )   {

                ULONG processorModel;
                PUCHAR processorNameString = CmpItanium;

                //
                // Add Processor Name String to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpProcessorNameString
                    );

                //
                // ISSUE-2000/02/10-v-thief - Pseudo cases to be updated when known.
                //

                processorModel = Prcb->ProcessorModel;
                switch( processorModel )  {
                   case 1: // Pseudo-Itanium:
                      break;

                   case 2: // Pseudo-McKinley:
                      processorNameString = CmpMcKinley;
                      break;

                   default:
                      processorNameString = CmpIA64Proc;
                      break;
                }

                RtlInitAnsiString(
                    &AnsiString,
                    processorNameString
                    );

                RtlAnsiStringToUnicodeString(
                    &ValueData,
                    &AnsiString,
                    TRUE
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            ValueData.Buffer,
                            ValueData.Length + sizeof( UNICODE_NULL )
                            );

                RtlFreeUnicodeString(&ValueData);

            }


//
// If more processor IDs have to be restored or initialized,
// check non-IA64 implementations of this function.
//


            if ( Prcb->ProcessorFeatureBits ) {

                //
                // Add processor feature bits to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpFeatureBits
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_QWORD,
                            &Prcb->ProcessorFeatureBits,
                            sizeof( Prcb->ProcessorFeatureBits )
                            );
            }


            if (Prcb->MHz) {
                //
                // Add processor MHz to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpMHz
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_DWORD,
                            &Prcb->MHz,
                            sizeof (Prcb->MHz)
                            );
            }


#if 0

//
// ISSUE-2000/02/01-v-thief
//

            if ( Prcb->ProcessorUpdateSignature ) {

                //
                // Add processor Update Signature to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpUpdateSignature
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_BINARY,
                            &Prcb->ProcessorUpdateSignature,
                            sizeof( Prcb->ProcessorUpdateSignature )
                            );
            }

#endif // 0
            //
            // Add ia32 floating point enties for iVE.
            //
            RtlZeroMemory (&CurrentEntry, sizeof CurrentEntry);
            CurrentEntry.ComponentEntry.Class = ProcessorClass;
            CurrentEntry.ComponentEntry.Type = FloatingPointProcessor;
            CurrentEntry.ComponentEntry.Key = i;
            CurrentEntry.ComponentEntry.AffinityMask = AFFINITY_MASK(i);

            CurrentEntry.ComponentEntry.Identifier = Buffer;

            //
            // The iVE is defined to look like the Pentium III FP
            // This is the value returned by the ia32 CPUID instruction
            // on Merced (Itanium)
            //
            strcpy (Buffer, "x86 Family 7 Model 0 Stepping 0");

            CurrentEntry.ComponentEntry.IdentifierLength =
                strlen (Buffer) + 1;

            Status = CmpInitializeRegistryNode(
                &CurrentEntry,
                ParentHandle,
                &NpxHandle,
                -1,
                (ULONG)-1,
                DeviceIndexTable
                );


            //
            // How odd. Some calls check the status return value
            // and others don't. Is this based on required vs. optional
            // keys? For the moment, since it was checked on the i386
            // then do the check here too...
            //
            if (!NT_SUCCESS(Status)) {
                NtClose(BaseHandle);
                return(Status);
            }

            //
            // Only need to close the handle if we succeeded
            //
            NtClose(NpxHandle);

            NtClose(BaseHandle);
        }

        ExFreePool((PVOID)CmpConfigurationData);
    }


    //
    // Next we try to collect System BIOS date and version strings.
    //
    if( SystemBIOSDateString[0] != 0 ) {

        RtlInitUnicodeString(
            &ValueName,
            L"SystemBiosDate"
            );

        Status = NtSetValueKey(
                    ParentHandle,
                    &ValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    SystemBIOSDateString,
                    (wcslen(SystemBIOSDateString)+1) * sizeof( WCHAR )
                    );

    }

    if( SystemBIOSVersionString[0] != 0 ) {

        RtlInitUnicodeString(
            &ValueName,
            L"SystemBiosVersion"
            );

        Status = NtSetValueKey(
                    ParentHandle,
                    &ValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    SystemBIOSVersionString,
                    (wcslen(SystemBIOSVersionString)+1) * sizeof( WCHAR )
                    );

    }


    //
    // Next we try to collect Video BIOS date and version strings.
    //
    if( VideoBIOSDateString[0] != 0 ) {

        RtlInitUnicodeString(
            &ValueName,
            L"VideoBiosDate"
            );

        Status = NtSetValueKey(
                    ParentHandle,
                    &ValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    VideoBIOSDateString,
                    (wcslen(VideoBIOSDateString)+1) * sizeof( WCHAR )
                    );

    }

    if( VideoBIOSVersionString[0] != 0 ) {

        RtlInitUnicodeString(
            &ValueName,
            L"VideoBiosVersion"
            );

        Status = NtSetValueKey(
                    ParentHandle,
                    &ValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    VideoBIOSVersionString,
                    (wcslen(VideoBIOSVersionString)+1) * sizeof( WCHAR )
                    );

    }


    NtClose (ParentHandle);

    //
    // Add any other x86 specific code here...
    //

    return STATUS_SUCCESS;
}



VOID
InitializeProcessorInformationFromSMBIOS(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function attempts to load processor-specific information
    out of the SMBIOS table.  If present, that information will be
    used to initialize specific global variables.

Arguments:

    LoaderBlock : Pointer to the loaderblock as sent in from the loader.

Return Value:

    NONE.

--*/
{
    PLOADER_PARAMETER_EXTENSION     LoaderExtension;
    NTSTATUS                        Status = STATUS_SUCCESS;
    PSMBIOS_EPS_HEADER              SMBiosEPSHeader;
    PDMIBIOS_EPS_HEADER             DMIBiosEPSHeader;
    BOOLEAN                         Found = FALSE;
    PHYSICAL_ADDRESS                SMBiosTablePhysicalAddress = {0};
    PUCHAR                          StartPtr = NULL;
    PUCHAR                          EndPtr = NULL;
    PUCHAR                          SMBiosDataVirtualAddress = NULL;
    PSMBIOS_STRUCT_HEADER           Header = NULL;
    ULONG                           i = 0;
    PKPRCB                          Prcb;
    UCHAR                           Checksum;


    PAGED_CODE();


    LoaderExtension = LoaderBlock->Extension;

    if (LoaderExtension->Size >= sizeof(LOADER_PARAMETER_EXTENSION)) {


        if (LoaderExtension->SMBiosEPSHeader != NULL) {

            //
            // Load the SMBIOS table address and checksum it just to make sure.
            //
            SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)LoaderExtension->SMBiosEPSHeader;
            DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader->Signature2[0];

            SMBiosTablePhysicalAddress.HighPart = 0;
            SMBiosTablePhysicalAddress.LowPart = DMIBiosEPSHeader->StructureTableAddress;

            StartPtr = (PUCHAR)SMBiosEPSHeader;
            Checksum = 0;
            for( i = 0; i < SMBiosEPSHeader->Length; i++ ) {
                Checksum += StartPtr[i];
            }
            if( Checksum != 0 ) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"InitializeProcessorInformationFromSMBIOS: _SM_ table has an incorrect checksum.\n"));
                return;
            }



            //
            // Map the table into a virtual address and search it.
            //
            SMBiosDataVirtualAddress = MmMapIoSpace( SMBiosTablePhysicalAddress,
                                                     DMIBiosEPSHeader->StructureTableLength,
                                                     MmCached );

            if( SMBiosDataVirtualAddress != NULL ) {

                //
                // Search...
                //
                StartPtr = SMBiosDataVirtualAddress;
                EndPtr = StartPtr + DMIBiosEPSHeader->StructureTableLength;
                Found = FALSE;
                while( (StartPtr < EndPtr) ) {

                    Header = (PSMBIOS_STRUCT_HEADER)StartPtr;


                    if( Header->Type == SMBIOS_BIOS_INFORMATION_TYPE ) {

                        PSMBIOS_BIOS_INFORMATION_STRUCT InfoHeader = (PSMBIOS_BIOS_INFORMATION_STRUCT)StartPtr;
                        PUCHAR      StringPtr = NULL;

                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: SMBIOS_BIOS_INFORMATION\n"));

                        //
                        // Load the System BIOS Version information.
                        //


                        // Now jump to the BiosInfoHeader->BIOSVersion-th string which
                        // is appended onto the end of the formatted section of the table.

                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the version string is at offset: %d\n", (ULONG)InfoHeader->Version));
                        if( (ULONG)InfoHeader->Version > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->Version-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }

                            // StringPtr should be sitting at the BIOSVersion string.  Convert him to
                            // Unicode and save it off.
                            if( StringPtr < EndPtr ) {
                                UNICODE_STRING  UnicodeString;
                                ANSI_STRING     AnsiString;

                                KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I'm about to load the Version string %s\n", StringPtr));
                                UnicodeString.Buffer = SystemBIOSVersionString;
                                UnicodeString.MaximumLength = MAXIMUM_BIOS_VERSION_LENGTH;
                                RtlInitAnsiString(
                                    &AnsiString,
                                    StringPtr
                                    );

                                RtlAnsiStringToUnicodeString(
                                    &UnicodeString,
                                    &AnsiString,
                                    FALSE
                                    );

                            }
                        }



                        //
                        // Load the System BIOS Date information
                        //

                        // Now jump to the BiosInfoHeader->BIOSDate-th string which
                        // is appended onto the end of the formatted section of the table.
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the ReleaseDate string is at offset: %d\n", (ULONG)InfoHeader->ReleaseDate));
                        if( (ULONG)InfoHeader->ReleaseDate > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->ReleaseDate-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }

                            // StringPtr should be sitting at the BIOSDate string.  Convert him to
                            // Unicode and save it off.
                            if( StringPtr < EndPtr ) {
                                UNICODE_STRING  UnicodeString;
                                ANSI_STRING     AnsiString;


                                KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I'm about to load the Date string %s\n", StringPtr));
                                UnicodeString.Buffer = SystemBIOSDateString;
                                UnicodeString.MaximumLength = BIOS_DATE_LENGTH;
                                RtlInitAnsiString(
                                    &AnsiString,
                                    StringPtr
                                    );

                                RtlAnsiStringToUnicodeString(
                                    &UnicodeString,
                                    &AnsiString,
                                    FALSE
                                    );

                            }
                        }


                    } else if( Header->Type == SMBIOS_BASE_BOARD_INFORMATION_TYPE ) {
                        PSMBIOS_BASE_BOARD_INFORMATION_STRUCT InfoHeader = (PSMBIOS_BASE_BOARD_INFORMATION_STRUCT)StartPtr;
                        PUCHAR      StringPtr = NULL;

                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: SMBIOS_BASE_BOARD_INFORMATION\n"));

#if 0
//
// We aren't using any of this information right now.
// -matth 4/2001
//

                        // Manufacturer
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the Manufacturer string is at offset: %d\n", (ULONG)InfoHeader->Manufacturer));
                        if( (ULONG)InfoHeader->Manufacturer > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->Manufacturer-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }
                            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    Manufacturer: %s\n", StringPtr));
                        }


                        // Product
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the Product string is at offset: %d\n", (ULONG)InfoHeader->Product));
                        if( (ULONG)InfoHeader->Product > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->Product-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }
                            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    Product: %s\n", StringPtr));
                        }


                        // Version
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the Version string is at offset: %d\n", (ULONG)InfoHeader->Version));
                        if( (ULONG)InfoHeader->Version > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->Version-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }
                            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    Version: %s\n", StringPtr));
                        }


                        // SerialNumber
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the SerialNumber string is at offset: %d\n", (ULONG)InfoHeader->SerialNumber));
                        if( (ULONG)InfoHeader->SerialNumber > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->SerialNumber-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }
                            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"     SerialNumber: %s\n", StringPtr));
                        }
#endif


                    } else if( Header->Type == SMBIOS_SYSTEM_CHASIS_INFORMATION_TYPE ) {

                        PSMBIOS_SYSTEM_CHASIS_INFORMATION_STRUCT InfoHeader = (PSMBIOS_SYSTEM_CHASIS_INFORMATION_STRUCT)StartPtr;
                        PUCHAR      StringPtr = NULL;

                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: SMBIOS_SYSTEM_CHASIS_INFORMATION\n"));

#if 0
//
// We aren't using any of this information right now.
// -matth 4/2001
//


                        // Manufacturer
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the Manufacturer string is at offset: %d\n", (ULONG)InfoHeader->Manufacturer));
                        if( (ULONG)InfoHeader->Manufacturer > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->Manufacturer-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }
                            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    Manufacturer: %s\n", StringPtr));
                        }


                        // Product
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the Manufacturer string is at offset: %d\n", (ULONG)InfoHeader->ChasisType));
                        if( (ULONG)InfoHeader->ChasisType > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->ChasisType-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }
                            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    ChasisType: %s\n", StringPtr));
                        }


                        // Version
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the Version string is at offset: %d\n", (ULONG)InfoHeader->Version));
                        if( (ULONG)InfoHeader->Version > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->Version-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }
                            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    Version: %s\n", StringPtr));
                        }


                        // SerialNumber
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the SerialNumber string is at offset: %d\n", (ULONG)InfoHeader->SerialNumber));
                        if( (ULONG)InfoHeader->SerialNumber > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->SerialNumber-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }
                            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"     SerialNumber: %s\n", StringPtr));
                        }

#endif

                    }


                    //
                    // Go to the next table.
                    //
                    KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: Haven't found the ProcessorInformation block yet.  Just looked at a block of type: %d.\n", Header->Type));

                    StartPtr +=  Header->Length;

                    // jump over any trailing string-list too.
                    while ( (*((USHORT UNALIGNED *)StartPtr) != 0)  &&
                            (StartPtr < EndPtr) )
                    {
                        StartPtr++;
                    }
                    StartPtr += 2;

                }


                MmUnmapIoSpace(SMBiosDataVirtualAddress, DMIBiosEPSHeader->StructureTableLength);

            } else {
                KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: Failed to map the SMBIOS physical address.\n"));
            }

        } else {
            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: The SMBiosEPSHeader is NULL in the extension block.\n"));
        }

    } else {
        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: LoaderBlock extension is out of sync with the kernel.\n"));

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\perform.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <wchar.h>
#include "windows.h"
#include "winreg.h"

#define TEST_STRING     "Test String"
#define TEST_STRING_W   L"Test String"



BOOLEAN
AdjustPrivilege(
    PSTR    SecurityNameString
    )
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;
//    PSTR                SecurityNameString;

    TOKEN_PRIVILEGES    TokenPrivileges;
    TOKEN_PRIVILEGES    PreviousTokenPrivileges;
    DWORD               ReturnLength;

    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        printf( "OpenProcessToken failed \n" );
        return( FALSE );
    }

//    SecurityNameString = SE_RESTORE_NAME; // SE_SECURITY_NAME;

    if( !LookupPrivilegeValue( NULL,
                               SecurityNameString,
                               &( LuidAndAttributes.Luid ) ) ) {
        printf( "LookupPrivilegeValue failed, Error = %#x \n", GetLastError() );
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        printf( "AdjustTokenPrivileges failed, Error = %#x \n", GetLastError() );
        return( FALSE );
    }


    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }

    return( TRUE );
}



#define ENVIRONMENT_NAME    L"Environment"
#define TESTKEY_NAME        L"TestKey"
#define TESTKEY_FULL_NAME   L"Environment\\TestKey"
#define KEY1_NAME           L"Key1"
#define KEY1_FULL_NAME      L"Environment\\TestKey\\Key1"
#define KEY2_NAME           L"Key2"
#define KEY2_FULL_NAME      L"Environment\\TestKey\\Key2"
#define VALUE_NAME          L"123"
#define VALUE_DATA          L"This is a string"



INT __cdecl
main()
{
    DWORD       Status;

    HKEY        TestKeyHandle;
    HKEY        Key1Handle;
    HKEY        Key2Handle;
    HKEY        EnvironmentHandle;

    WCHAR       ValueData[] = VALUE_DATA;

    WCHAR       BufferForKeyName[100];
    WCHAR       BufferForKeyClass[100];
    WCHAR       BufferForValueEntryName[100];
    BYTE        BufferForValueEntryData[100];


    DWORD       DataType;
    DWORD       DataSize;
    DWORD       NameSize;
    DWORD       ClassSize;


    DWORD       cSubKeys;
    DWORD       cbMaxSubkey;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       vbMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;


    BYTE        BufferForSecurityDescriptor[2048];

    HANDLE      NotificationEvent;

    PWSTR       File1 = L"d:\\File1";
    PWSTR       File2 = L"d:\\File2";
    DWORD       Disposition;



/*
    Key = NULL;
    Status = RegOpenKeyExW( HKEY_CURRENT_USER,
                            L"",
                            0,
                            MAXIMUM_ALLOWED,
                            &Key );
*/








//    AdjustPrivilege( SE_BACKUP_NAME );
//    AdjustPrivilege( SE_RESTORE_NAME );


    NotificationEvent = CreateEvent( NULL,
                                     FALSE,
                                     FALSE,
                                     NULL );

    if( NotificationEvent == NULL ) {
        printf( "CreateEvent failed, ErrorCode = %d \n", GetLastError() );
    }



    Status = RegOpenKeyExW( HKEY_CURRENT_USER,
                            TESTKEY_FULL_NAME,
                            0,
                            MAXIMUM_ALLOWED,
                            &TestKeyHandle );

    if( Status != 0 ) {
        printf( "RegOpenKeyExW failed, Status = %d \n", Status );
    } else {
        printf( "RegOpenKeyExW succeeded \n" );
    }


    Status = RegOpenKeyW( HKEY_CURRENT_USER,
                          ENVIRONMENT_NAME,
                          &EnvironmentHandle );

    if( Status != 0 ) {
        printf( "RegOpenKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegOpenKeyW succeeded \n" );
    }






    Status = RegCreateKeyExW( TestKeyHandle,
                              KEY1_NAME,
                              NULL,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              MAXIMUM_ALLOWED,
                              NULL,
                              &Key1Handle,
                              &Disposition );

    if( Status != 0 ) {
        printf( "RegCreateKeyExW failed, Status = %d \n", Status );
    } else {
        printf( "RegCreateKeyExW succeeded \n" );
    }



    Status = RegCreateKeyW( TestKeyHandle,
                            KEY2_NAME,
                            &Key2Handle );


    if( Status != 0 ) {
        printf( "RegCreateKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegCreateKeyW succeeded \n" );
    }


    Status = RegSetValueExW( Key1Handle,
                             VALUE_NAME,
                             NULL,
                             REG_SZ,
                             ValueData,
                             sizeof( ValueData ) );

    if( Status != 0 ) {
        printf( "RegSetValueExW failed, Status = %d \n", Status );
    } else {
        printf( "RegSetValueExW succeeded \n" );
    }


    Status = RegSetValueW( Key1Handle,
                             NULL,
                             REG_SZ,
                             ValueData,
                             sizeof( ValueData ) );

    if( Status != 0 ) {
        printf( "RegSetValueW failed, Status = %d \n", Status );
    } else {
        printf( "RegSetValueW succeeded \n" );
    }



    Status = RegFlushKey( Key1Handle );
    if( Status != 0 ) {
        printf( "RegFlushKey failed, Status = %d \n", Status );
    } else {
        printf( "RegFlushKey succeeded \n" );
    }




    DataSize = sizeof( BufferForValueEntryData );
    memset( BufferForValueEntryData, '\0', DataSize );
    Status = RegQueryValueExW( Key1Handle,
                               VALUE_NAME,
                               NULL,
                               &DataType,
                               BufferForValueEntryData,
                               &DataSize );

    if( Status != 0 ) {
        printf( "RegQueryValueExW failed, Status = %d \n", Status );
    } else {
        printf( "RegQueryValueExW succeeded \n" );
    }



    DataSize = sizeof( BufferForValueEntryData );
    memset( BufferForValueEntryData, '\0', DataSize );
    Status = RegQueryValueW( Key1Handle,
                             NULL,
                             BufferForValueEntryData,
                             &DataSize );


    if( Status != 0 ) {
        printf( "RegQueryValueW failed, Status = %d \n", Status );
    } else {
        printf( "RegQueryValueW succeeded \n" );
    }


    DataSize = sizeof( BufferForValueEntryData );
    memset( BufferForValueEntryData, 'X', DataSize );
    NameSize = sizeof( BufferForValueEntryName );
    memset( BufferForValueEntryName, 'X', NameSize );

    Status = RegEnumValueW( Key1Handle,
                            0,
                            BufferForValueEntryName,
                            &NameSize,
                            NULL,
                            &DataType,
                            BufferForValueEntryData,
                            &DataSize );


    if( Status != 0 ) {
        printf( "RegEnumValueW failed, Status = %d \n", Status );
    } else {
        printf( "RegEnumValueW succeeded \n" );
    }


    NameSize = sizeof( BufferForKeyName );
    ClassSize = sizeof( BufferForKeyClass );
    Status = RegEnumKeyExW( TestKeyHandle,
                            0,
                            BufferForKeyName,
                            &NameSize,
                            NULL,
                            BufferForKeyClass,
                            &ClassSize,
                            &ftLastWriteTime );

    if( Status != 0 ) {
        printf( "RegEnumKeyExW failed, Status = %d \n", Status );
    } else {
        printf( "RegEnumKeyExW succeeded \n" );
    }


    NameSize = sizeof( BufferForKeyName );
    Status = RegEnumKeyW( TestKeyHandle,
                          0,
                          BufferForKeyName,
                          &NameSize );

    if( Status != 0 ) {
	printf( "RegEnumKeyW failed, Status = %d \n", Status );
    } else {
	printf( "RegEnumKeyW succeeded \n" );
    }


    ClassSize = sizeof( BufferForKeyClass );
    Status = RegQueryInfoKeyW( Key1Handle,
                               BufferForKeyClass,
                               &ClassSize,
                               NULL,
                               &cSubKeys,
                               &cbMaxSubkey,
                               &cbMaxClass,
                               &cValues,
                               &vbMaxValueName,
                               &cbMaxValueData,
                               &cbSecurityDescriptor,
                               &ftLastWriteTime );



    if( Status != 0 ) {
        printf( "RegQueryInfoKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegQueryInfoKeyW succeeded \n" );
    }


    Status = RegGetKeySecurity( Key1Handle,
                                DACL_SECURITY_INFORMATION,
                                ( PSECURITY_DESCRIPTOR )BufferForSecurityDescriptor,
                                &cbSecurityDescriptor );

    if( Status != 0 ) {
        printf( "RegGetKeySecurity failed, Status = %d \n", Status );
    } else {
        printf( "RegGetKeySecurity succeeded \n" );
    }



    Status = RegSetKeySecurity( Key1Handle,
                                DACL_SECURITY_INFORMATION,
                                ( PSECURITY_DESCRIPTOR )BufferForSecurityDescriptor );

    if( Status != 0 ) {
        printf( "RegSetKeySecurity failed, Status = %d \n", Status );
    } else {
        printf( "RegSetKeySecurity succeeded \n" );
    }

/*
    Status = RegSaveKeyW( Key1Handle,
                          File1,
                          NULL );


    if( Status != 0 ) {
        printf( "RegSaveKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegSaveKeyW succeeded \n" );
    }



    Status = RegRestoreKeyW( Key2Handle,
                             File1,
                             0 );


    if( Status != 0 ) {
        printf( "RegRestoreKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegRestoreKeyW succeeded \n" );
    }
*/

    Status = RegDeleteValueW( Key1Handle,
                              VALUE_NAME );


    if( Status != 0 ) {
        printf( "RegDeleteValueW failed, Status = %d \n", Status );
    } else {
        printf( "RegDeleteValueW succeeded \n" );
    }


    Status = RegCloseKey( Key1Handle );

    if( Status != 0 ) {
        printf( "RegCloseKey failed, Status = %d \n", Status );
    } else {
        printf( "RegCloseKey succeeded \n" );
    }

    Status = RegDeleteKeyW( TestKeyHandle,
                            KEY1_NAME );

    if( Status != 0 ) {
        printf( "RegCloseKey failed, Status = %d \n", Status );
    } else {
        printf( "RegCloseKey succeeded \n" );
    }


    Status = RegNotifyChangeKeyValue( HKEY_CURRENT_USER,
                                      TRUE,
                                      REG_NOTIFY_CHANGE_NAME |
                                      REG_NOTIFY_CHANGE_ATTRIBUTES |
                                      REG_NOTIFY_CHANGE_LAST_SET |
                                      REG_NOTIFY_CHANGE_SECURITY,
                                      NotificationEvent,
                                      TRUE );

    if( Status != 0 ) {
        printf( "RegNotifyChangeKeyValue failed, Status = %d \n", Status );
    } else {
        printf( "RegNotifyChangeKeyValue succeeded \n" );
    }


    //
    //  Cleanup
    //

    CloseHandle( NotificationEvent );
//    DeleteFileW( File1 );
    RegCloseKey( Key2Handle );
    RegDeleteKeyW( TestKeyHandle,
                   KEY2_NAME );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\initdat.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

    This module is here to fool build

Author:

    John Vert (jvert) 29-Aug-1994

Environment:

    Kernel mode.

Revision History:

--*/


void dummy2(void) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtbatcr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtbatcr.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Do a batch create.

    rtbatcr    <KeyPath> <KeyName> <basename> <#children> <#values>

    Will attempt to create key <KeyName> as child of <KeyPath>  If
    <#children> and <#values> are 0, this is all it does.  If <KeyName>
    already exists, it will simply be used.

    Will create <#children> child cells, with names of the form
    <base>0  <base>1, etc.  Will create <#values> value entries,
    with similar names, for each created child key.  Data of
    values will be a constant string including their name.

    Example:

        rtbatcr    \REGISTRY\MACHINE\TEST bigkey runa_ 100 100
        rtbatcr    \REGISTRY\MACHINE\TEST\bigkey runa_1 runb_ 100 100

        Will create bigkey, give it 100 values calls runa_1 through
        runa_100, create 100 subkeys called runa_1 through runa_100
        for each of those children.

        It will then open bigkey\runa_1, and create 100 subkeys and
        100 values each for that.

Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

ULONG           failure = 0;

UNICODE_STRING  KeyPath;
UNICODE_STRING  KeyName;
ULONG           NumberChildren;
ULONG           NumberValues;
UCHAR           BaseName[WORK_SIZE];
UCHAR           formatbuffer[WORK_SIZE];
STRING          format;
BOOLEAN         CreateVolatile = FALSE;

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    HANDLE          WorkHandle;
    ULONG           Disposition;
    UNICODE_STRING  ClassName;
    ULONG           i;
    ULONG           j;
    PUCHAR  p;
    ULONG           CreateOption;

    //
    // Process args
    //

    processargs(argc, argv);


    //
    // Set up and create/open KeyPath|KeyName
    //

    printf("rtbatcr: starting\n");

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    RtlCopyString((PSTRING)&WorkName, (PSTRING)&KeyPath);

    p = WorkName.Buffer;
    p += WorkName.Length;
    *p = '\\';
    p++;
    *p = '\0';
    WorkName.Length += 2;

    RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&KeyName);

    RtlInitUnicodeString(
        &ClassName,
        L"Test Class Name"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    if (CreateVolatile) {
        CreateOption = REG_OPTION_VOLATILE;
    } else {
        CreateOption = 0;
    }

    status = NtCreateKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                0,
                &ClassName,
                CreateOption,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtbatcr: t0: %08lx\n", status);
        failure++;
        goto punt;
    }


    //
    // Create NumberChildren subkeys
    //

    for (i = 0; i < NumberChildren; i++) {

        sprintf(formatbuffer, "%s%d", BaseName, i);
        RtlInitString(&format, formatbuffer);
        RtlAnsiStringToUnicodeString(&WorkName, &format, FALSE);


        InitializeObjectAttributes(
            &ObjectAttributes,
            &WorkName,
            0,
            BaseHandle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtCreateKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes,
                    0,
                    &ClassName,
                    CreateOption,
                    &Disposition
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtbatcr: t1: status = %08lx i = %d\n", status, i);
            failure++;
        }

        //
        // Create NumberValues value entries for each (current) key
        //

        for (j = 0; j < NumberValues; j++) {

            sprintf(formatbuffer, "%s%d", BaseName, j);
            RtlInitString(&format, formatbuffer);
            RtlAnsiStringToUnicodeString(&WorkName, &format, FALSE);

            sprintf(
                formatbuffer, "This is a rtbatcr value for %s%d", BaseName, j
                );

            status = NtSetValueKey(
                        WorkHandle,
                        &WorkName,
                        j,
                        j,
                        formatbuffer,
                        strlen(formatbuffer)+1
                        );
            if (!NT_SUCCESS(status)) {
                printf("rtbatcr: t2: status = %08lx j = %d\n", status, j);
                failure++;
            }
        }
        NtClose(WorkHandle);
    }

punt:
    printf("rtbatcr: %d failures\n", failure);
    exit(failure);
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc < 3) || (argc > 7) )
    {
        printf("Usage: %s [volatile] <KeyPath> <KeyName> [<basename> <#children> <#values>]\n",
                argv[0]);
        exit(1);
    }

    if (_stricmp(argv[1],"volatile")==0) {
        CreateVolatile = TRUE;
        ++argv;
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &KeyName,
        &temp,
        TRUE
        );

    if (argc < 6) {

        NumberChildren = 0;
        NumberValues = 0;

    } else {

        strcpy(BaseName, argv[3]);
        NumberChildren = atoi(argv[4]);
        NumberValues = atoi(argv[5]);

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\regext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regext.c

Abstract:

    Kernel debugger extensions useful for the registry

Author:

    John Vert (jvert) 7-Sep-1993

Environment:

    Loaded as a kernel debugger extension

Revision History:

    John Vert (jvert) 7-Sep-1993
        created

--*/
#include "cmp.h"
#include <windef.h>
#include <ntkdexts.h>
#include <stdlib.h>
#include <stdio.h>

HIVE_LIST_ENTRY HiveList[8];

ULONG TotalPages;
ULONG TotalPresentPages;

ULONG TotalKcbs;
ULONG TotalKcbName;

BOOLEAN SavePages;
BOOLEAN RestorePages;
FILE *TempFile;

PNTKD_OUTPUT_ROUTINE lpPrint;
PNTKD_GET_EXPRESSION lpGetExpressionRoutine;
PNTKD_GET_SYMBOL lpGetSymbolRoutine;
PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
PNTKD_READ_VIRTUAL_MEMORY lpReadMem;

void
poolDumpHive(
    IN PCMHIVE Hive
    );

VOID
poolDumpMap(
    IN ULONG Length,
    IN PHMAP_DIRECTORY Map
    );

void
dumpHiveFromFile(
    IN FILE *File
    );

VOID
kcbWorker(
    IN PCM_KEY_CONTROL_BLOCK pKcb
    );

VOID
pool(
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )

/*++

Routine Description:

    Goes through all the paged pool allocated to registry space and
    determines which pages are present and which are not.

    Called as:

        !regext.pool [s|r]

        s Save list of registry pages to temporary file
        r Restore list of registry pages from temp. file

Arguments:

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.

Return Value:

    None.

--*/

{
    PLIST_ENTRY pCmpHiveListHead;
    PLIST_ENTRY pNextHiveList;
    HIVE_LIST_ENTRY *pHiveListEntry;
    ULONG BytesRead;
    PCMHIVE CmHive;

    lpPrint = lpExtensionApis->lpOutputRoutine;
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine;
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;
    lpReadMem = lpExtensionApis->lpReadVirtualMemRoutine;

    if (toupper(lpArgumentString[0])=='S') {
        SavePages = TRUE;
    } else {
        SavePages = FALSE;
    }
    if (toupper(lpArgumentString[0])=='R') {
        RestorePages = TRUE;
    } else {
        RestorePages = FALSE;
    }

    //
    // Go get the hivelist.
    //
    memset(HiveList,0,sizeof(HiveList));
    pHiveListEntry = (PHIVE_LIST_ENTRY)(lpGetExpressionRoutine)("CmpMachineHiveList");
    if (pHiveListEntry != NULL) {
        (lpReadMem)(pHiveListEntry,
                    HiveList,
                    sizeof(HiveList),
                    &BytesRead);
    }

    //
    // First go and get the hivelisthead
    //
    pCmpHiveListHead = (PLIST_ENTRY)(lpGetExpressionRoutine)("CmpHiveListHead");
    if (pCmpHiveListHead==NULL) {
        (lpPrint)("CmpHiveListHead couldn't be read\n");
        return;
    }

    (lpReadMem)(&pCmpHiveListHead->Flink,
                &pNextHiveList,
                sizeof(pNextHiveList),
                &BytesRead);
    if (BytesRead != sizeof(pNextHiveList)) {
        (lpPrint)("Couldn't read first Flink (%lx) of CmpHiveList\n",
                  &pCmpHiveListHead->Flink);
        return;
    }

    TotalPages = TotalPresentPages = 0;

    if (SavePages) {
        TempFile = fopen("regext.dat","w+");
        if (TempFile==NULL) {
            (lpPrint)("Couldn't create regext.dat for write\n");
            return;
        }
    } else if (RestorePages) {
        TempFile = fopen("regext.dat","r");
        if (TempFile==NULL) {
            (lpPrint)("Couldn't open regext.dat for read\n");
            return;
        }
    }

    if (RestorePages) {
        dumpHiveFromFile(TempFile);
    } else {
        while (pNextHiveList != pCmpHiveListHead) {
            CmHive = CONTAINING_RECORD(pNextHiveList, CMHIVE, HiveList);
            poolDumpHive(CmHive);

            (lpReadMem)(&pNextHiveList->Flink,
                        &pNextHiveList,
                        sizeof(pNextHiveList),
                        &BytesRead);
            if (BytesRead != sizeof(pNextHiveList)) {
                (lpPrint)("Couldn't read Flink (%lx) of %lx\n",
                          &pCmpHiveListHead->Flink,pNextHiveList);
                break;
            }

        }
    }

    (lpPrint)("Total pages present = %d / %d\n",
              TotalPresentPages,
              TotalPages);

    if (SavePages || RestorePages) {
        fclose(TempFile);
    }
}

void
poolDumpHive(
    IN PCMHIVE pHive
    )
{
    CMHIVE CmHive;
    ULONG BytesRead;
    WCHAR FileName[HBASE_NAME_ALLOC/2 + 1];
    ULONG i;

    (lpPrint)("\ndumping hive at %lx ",pHive);
    (lpReadMem)(pHive,
                &CmHive,
                sizeof(CmHive),
                &BytesRead);

    if (BytesRead < sizeof(CmHive)) {
        (lpPrint)("\tRead %lx bytes from %lx\n",BytesRead,pHive);
        return;
    }

    (lpReadMem)(&CmHive.Hive.BaseBlock->FileName,
                FileName,
                sizeof(FileName),
                &BytesRead);

    if (BytesRead < sizeof(FileName)) {
        wcscpy(FileName, L"UNKNOWN");
    } else {
        if (FileName[0]==L'\0') {
            wcscpy(FileName, L"NONAME");
        } else {
            FileName[HBASE_NAME_ALLOC/2]=L'\0';
        }
    }

    (lpPrint)("(%ws)\n",FileName);

    (lpPrint)("  %d KCBs open\n",CmHive.KcbCount);
    (lpPrint)("  Stable Length = %lx\n",CmHive.Hive.Storage[Stable].Length);
    if (SavePages) {
        fprintf(TempFile,
                "%ws %d %d\n",
                FileName,
                CmHive.Hive.Storage[Stable].Length,
                CmHive.Hive.Storage[Volatile].Length);
    }
    poolDumpMap(CmHive.Hive.Storage[Stable].Length,
                CmHive.Hive.Storage[Stable].Map);

    (lpPrint)("  Volatile Length = %lx\n",CmHive.Hive.Storage[Volatile].Length);
    poolDumpMap(CmHive.Hive.Storage[Volatile].Length,
                CmHive.Hive.Storage[Volatile].Map);

}

VOID
poolDumpMap(
    IN ULONG Length,
    IN PHMAP_DIRECTORY Map
    )
{
    ULONG Tables;
    ULONG MapSlots;
    ULONG i;
    ULONG BytesRead;
    HMAP_DIRECTORY MapDirectory;
    PHMAP_TABLE MapTable;
    HMAP_ENTRY MapEntry;
    ULONG Garbage;
    ULONG Present=0;

    if (Length==0) {
        return;
    }

    MapSlots = Length / HBLOCK_SIZE;
    Tables = 1+ ((MapSlots-1) / HTABLE_SLOTS);

    //
    // read in map directory
    //
    (lpReadMem)(Map,
             &MapDirectory,
             Tables * sizeof(PHMAP_TABLE),
             &BytesRead);
    if (BytesRead < (Tables * sizeof(PHMAP_TABLE))) {
        (lpPrint)("Only read %lx/%lx bytes from %lx\n",
                  BytesRead,
                  Tables * sizeof(PHMAP_TABLE),
                  Map);
        return;

    }

    //
    // check out each map entry
    //
    for (i=0; i<MapSlots; i++) {

        MapTable = MapDirectory.Directory[i/HTABLE_SLOTS];

        (lpReadMem)(&(MapTable->Table[i%HTABLE_SLOTS]),
                    &MapEntry,
                    sizeof(HMAP_ENTRY),
                    &BytesRead);
        if (BytesRead < sizeof(HMAP_ENTRY)) {
            (lpPrint)("  can't read HMAP_ENTRY at %lx\n",
                      &(MapTable->Table[i%HTABLE_SLOTS]));
        }

        if (SavePages) {
            fprintf(TempFile, "%lx\n",MapEntry.BlockAddress);

        }

        //
        // probe the HBLOCK
        //
        (lpReadMem)(MapEntry.BlockAddress,
                    &Garbage,
                    sizeof(ULONG),
                    &BytesRead);
        if (BytesRead > 0) {
            ++Present;
        }
    }
    (lpPrint)("  %d/%d pages present\n",
              Present,
              MapSlots);

    TotalPages += MapSlots;
    TotalPresentPages += Present;

}

void
dumpHiveFromFile(
    IN FILE *File
    )

/*++

Routine Description:

    Takes a list of the registry hives and pages from a file and
    checks to see how many of the pages are in memory.

    The format of the file is as follows
       hivename stablelength volatilelength
       stable page address
       stable page address
            .
            .
            .
       volatile page address
       volatile page address
            .
            .
            .
       hivename stablelength volatilelength
            .
            .
            .


Arguments:

    File - Supplies a file.

Return Value:

    None.

--*/

{
    CHAR Hivename[33];
    ULONG StableLength;
    ULONG VolatileLength;
    ULONG Page;
    ULONG i;
    ULONG NumFields;
    ULONG Garbage;
    ULONG Present;
    ULONG Total;
    ULONG BytesRead;

    while (!feof(File)) {
        NumFields = fscanf(File,"%s %d %d\n",
                            Hivename,
                            &StableLength,
                            &VolatileLength);
        if (NumFields != 3) {
            (lpPrint)("fscanf returned %d\n",NumFields);
            return;
        }

        (lpPrint)("\ndumping hive %s\n",Hivename);
        (lpPrint)("  Stable Length = %lx\n",StableLength);
        Present = 0;
        Total = 0;
        while (StableLength > 0) {
            fscanf(File, "%lx\n",&Page);
            (lpReadMem)(Page,
                        &Garbage,
                        sizeof(ULONG),
                        &BytesRead);
            if (BytesRead > 0) {
                ++Present;
            }
            ++Total;
            StableLength -= HBLOCK_SIZE;
        }
        if (Total > 0) {
            (lpPrint)("  %d/%d stable pages present\n",
                      Present,Total);
        }
        TotalPages += Total;
        TotalPresentPages += Present;

        (lpPrint)("  Volatile Length = %lx\n",VolatileLength);
        Present = 0;
        Total = 0;
        while (VolatileLength > 0) {
            fscanf(File, "%lx\n",&Page);
            (lpReadMem)(Page,
                        &Garbage,
                        sizeof(ULONG),
                        &BytesRead);
            if (BytesRead > 0) {
                ++Present;
            }
            ++Total;
            VolatileLength -= HBLOCK_SIZE;
        }
        if (Total > 0) {
            (lpPrint)("  %d/%d volatile pages present\n",
                      Present,Total);
        }

        TotalPages += Total;
        TotalPresentPages += Present;
    }

}

void
kcb(
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )

/*++

Routine Description:

    Walks the kcb tree and prints the names of keys which have
    outstanding kcbs

    Called as:

        !regext.kcb

Arguments:

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.

Return Value:

    None.

--*/

{
    PCM_KEY_CONTROL_BLOCK pKCB;
    PCM_KEY_CONTROL_BLOCK Root;
    ULONG BytesRead;

    lpPrint = lpExtensionApis->lpOutputRoutine;
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine;
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;
    lpReadMem = lpExtensionApis->lpReadVirtualMemRoutine;

    Root = (PCM_KEY_CONTROL_BLOCK)(lpGetExpressionRoutine)("CmpKeyControlBlockRoot");
    if (Root == NULL) {
        (lpPrint)("Couldn't find address of CmpKeyControlBlockRoot\n");
        return;
    }
    (lpReadMem)(Root,
                &pKCB,
                sizeof(pKCB),
                &BytesRead);

    if (BytesRead < sizeof(pKCB)) {
        (lpPrint)("Couldn't get pKCB from CmpKeyControlBlockRoot\n");
    }

    TotalKcbs = 0;
    TotalKcbName = 0;
    kcbWorker(pKCB);

    (lpPrint)("%d KCBs\n",TotalKcbs);
    (lpPrint)("%d total bytes of FullNames\n",TotalKcbName);

}

VOID
kcbWorker(
    IN PCM_KEY_CONTROL_BLOCK pKcb
    )

/*++

Routine Description:

    recursive worker for walking the kcb tree.

Arguments:

    pKcb - Supplies pointer to kcb.

Return Value:

    None.

--*/

{
    CM_KEY_CONTROL_BLOCK kcb;
    ULONG BytesRead;
    WCHAR *Buffer;

    ++TotalKcbs;
    (lpReadMem)(pKcb,
                &kcb,
                sizeof(kcb),
                &BytesRead);
    if (BytesRead < sizeof(kcb)) {
        (lpPrint)("Can't read kcb at %lx\n",pKcb);
        return;
    }
    TotalKcbName += kcb.FullName.Length;

    if (kcb.Left != NULL) {
        kcbWorker(kcb.Left);
    }

    (lpPrint)("%d - ",kcb.RefCount);

    Buffer = malloc(kcb.FullName.Length);
    if (Buffer != NULL) {
        (lpReadMem)(kcb.FullName.Buffer,
                    Buffer,
                    kcb.FullName.Length,
                    &BytesRead);

        kcb.FullName.Length = BytesRead;
        kcb.FullName.Buffer = Buffer;

        (lpPrint)(" %wZ\n",&kcb.FullName);
        free(Buffer);

    } else {
        (lpPrint)(" ??? \n");
    }

    if (kcb.Right != NULL) {
        kcbWorker(kcb.Right);
    }


}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtdelkey.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdelkey.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Delete a key.

    rtdelkey <KeyPath>

    Example:

        rtdelkey \REGISTRY\MACHINE\TEST\bigkey

Author:

    Bryan Willman (bryanwi)  10-Jan-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int,char *);
void processargs();

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdelkey: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                DELETE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdelkey: t0: %08lx\n", status);
        exit(1);
    }

    status = NtDeleteKey(BaseHandle);
    if (!NT_SUCCESS(status)) {
        printf("rtdelkey: t1: %08lx\n", status);
        exit(1);
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtdeltre.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdeltre.c

Abstract:

    NT level registry api test program #4, basic non-error paths.

    Sub-tree delete for the registry.

    rtdeltre <KeyPath>

    Will ennumerate and delete the subkeys and values of KeyPath,
    and each of their subkeys, and so on.

    Example:

        rtdeltre \REGISTRY\MACHINE\TEST\bigkey

Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int argc, char *);
void processargs();

void print(PUNICODE_STRING);

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("regtest3: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                DELETE | KEY_ENUMERATE_SUB_KEYS,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("regtest3: t0: %08lx\n", status);
        exit(1);
    }

    Delete(BaseHandle);
}


void
Delete(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  WorkHandle;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    NamePos = WorkName.Length;

    //
    // Enumerate node's children and apply ourselves to each one
    //

    index = 0;
    do {

        RtlZeroMemory(KeyInformation, WORK_SIZE);
        status = NtEnumerateKey(
                    Handle,
                    index,
                    KeyBasicInformation,
                    KeyInformation,
                    WORK_SIZE,
                    &ResultLength
                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            WorkName.Length = NamePos;
            break;

        } else if (!NT_SUCCESS(status)) {

            printf("regtest3: dump1: status = %08lx\n", status);
            exit(1);

        }

        enumname.Buffer = &(KeyInformation->Name[0]);
        enumname.Length = KeyInformation->NameLength;
        enumname.MaximumLength = KeyInformation->NameLength;

        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&enumname);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &enumname,
            OBJ_CASE_INSENSITIVE,
            Handle,
            NULL
            );

        status = NtOpenKey(
                    &WorkHandle,
                    DELETE | KEY_ENUMERATE_SUB_KEYS,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(status)) {
            printf("regtest3: couldn't delete %wZ: %08lx\n", &enumname,status);
            index++;
        } else {
            Delete(WorkHandle);
            NtClose(WorkHandle);
        }

        WorkName.Length = NamePos;

    } while (TRUE);

    //
    // If we're here, then we have delt with all children, so deal with
    // the node we were applied to
    //

    NtDeleteKey(Handle);
    NtClose(Handle);        // Force it to actually go away
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtdmpb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdmp.c

Abstract:

    NT level registry api test program #3, basic non-error paths.

    Dump out a sub-tree of the registry.

    rtdmp <KeyPath>

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    It assumes data values are null terminated strings.

    Example:

        rtdmp \REGISTRY\MACHINE\TEST\bigkey


        \REGISTRY\MACHINE\TEST\bigkey::

            ValueTest1_01 type=0 ti=1
            "This is a test string"

            ValueTest1_01 type=0 ti=2
            "This is a test string"

        \REGISTRY\MACHCINE\TEST\bigkey\child_key_1::

            ValueTest1_01 type=0 ti=1
            "This is a test string"

            ValueTest1_01 type=0 ti=2
            "This is a test string"
Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE 16384

void __cdecl main(int, char *);
void processargs();

void print(PUNICODE_STRING);

void
DumpValues(
    HANDLE  Handle
    );

void
Dump(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdmp: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdmp: t0: %08lx\n", status);
        exit(1);
    }

    Dump(BaseHandle);
}


void
Dump(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  WorkHandle;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];
    PUCHAR  p;

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    NamePos = WorkName.Length;

    //
    // Print name of node we are about to dump out
    //
    print(&WorkName);
    printf("::\n\n");

    //
    // Print out node's values
    //
    DumpValues(Handle);

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyInformation, WORK_SIZE);
        status = NtEnumerateKey(
                    Handle,
                    index,
                    KeyBasicInformation,
                    KeyInformation,
                    WORK_SIZE,
                    &ResultLength
                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            WorkName.Length = NamePos;
            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmp: dump1: status = %08lx\n", status);
            exit(1);

        }

        enumname.Buffer = &(KeyInformation->Name[0]);
        enumname.Length = KeyInformation->NameLength;
        enumname.MaximumLength = KeyInformation->NameLength;

        p = WorkName.Buffer;
        p += WorkName.Length;
        *p = '\\';
        p++;
        *p = '\0';
        WorkName.Length += 2;

        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&enumname);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &enumname,
            0,
            Handle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtOpenKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtdmp: dump2: %08lx\n", status);
            exit(1);
        }

        Dump(WorkHandle);
        NtClose(WorkHandle);
        WorkName.Length = NamePos;
    }
}


void
DumpValues(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    static  char        tempbuffer[WORK_SIZE];
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG   index;
    ULONG   ResultLength;
    PULONG  p;
    ULONG i;
    UNICODE_STRING valname;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)tempbuffer;

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyValueInformation, WORK_SIZE);
        status = NtEnumerateValueKey(
                    Handle,
                    index,
                    KeyValueFullInformation,
                    KeyValueInformation,
                    WORK_SIZE,
                    &ResultLength
                    );
        if (status == STATUS_NO_MORE_ENTRIES) {

            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmp: dumpvalues: status = %08lx\n", status);
            exit(1);

        }

        printf("\t");
        valname.Length = KeyValueInformation->NameLength;
        valname.MaximumLength = KeyValueInformation->NameLength;
        valname.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
        printf("'");
        print(&valname);
        printf("'\n");
        printf(
            "\ttitle index = %d\ttype = ",
            KeyValueInformation->TitleIndex
            );
        printf("REG_BINARY\n\tValue = (%lx)\n", KeyValueInformation->DataLength);
        p = (PULONG)KeyValueInformation + KeyValueInformation->DataOffset;
        i = 1;
        while (i <= KeyValueInformation->DataLength) {
            printf( "  %08lx", *p++ );
            if ((i % 8) == 0) {
                printf( "\n" );
            }
            i += sizeof( ULONG );
        }
        printf("\n\n");
    }
}


void
print(
    PUNICODE_STRING  String
    )
{
    static  ANSI_STRING temp;
    static  char        tempbuffer[WORK_SIZE];

    temp.MaximumLength = WORK_SIZE;
    temp.Length = 0L;
    temp.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&temp, String, FALSE);
    printf("%s", temp.Buffer);
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        FALSE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtdmpsec.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdmpsec.c

Abstract:

    NT level registry security test program #1, basic non-error paths.

    Dump out the security descriptors of a sub-tree of the registry.

    rtdmpsec <KeyPath>

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    It assumes data values are null terminated strings.

    Example:

        rtdmpsec \REGISTRY\MACHINE\TEST\bigkey

Author:

    John Vert (jvert) 24-Jan-92

        based on rtdmp.c by

    Bryan Willman (bryanwi)  10-Dec-91

        and getdacl.c by RobertRe

Revision History:

    Richard Ward (richardw)  14 April 1992   Changed ACE_HEADER

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

//
//  Get a pointer to the first ace in an acl
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Get a pointer to the following ace
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

//
// Generic ACE structure, to be used for casting ACE's of known types
//

typedef struct _KNOWN_ACE {
   ACE_HEADER Header;
   ACCESS_MASK Mask;
   ULONG SidStart;
   } KNOWN_ACE, *PKNOWN_ACE;



VOID
InitVars();

VOID
PrintAcl (
    IN PACL Acl
    );

VOID
PrintAccessMask(
    IN ACCESS_MASK AccessMask
    );

void __cdecl main(int, char *);
void processargs();

void print(PUNICODE_STRING);

void
DumpSecurity(
    HANDLE  Handle
    );

void
Dump(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

//
// Universal well known SIDs
//

PSID  NullSid;
PSID  WorldSid;
PSID  LocalSid;
PSID  CreatorOwnerSid;

//
// Sids defined by NT
//

PSID NtAuthoritySid;

PSID DialupSid;
PSID NetworkSid;
PSID BatchSid;
PSID InteractiveSid;
PSID LocalSystemSid;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    InitVars();

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdmpsec: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdmpsec: t0: %08lx\n", status);
        exit(1);
    }

    Dump(BaseHandle);
}


void
Dump(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  WorkHandle;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];
    PUCHAR  p;

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    NamePos = WorkName.Length;

    //
    // Print name of node we are about to dump out
    //
    printf("\n");
    print(&WorkName);
    printf("::\n");

    //
    // Print out node's values
    //
    DumpSecurity(Handle);

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyInformation, WORK_SIZE);
        status = NtEnumerateKey(
                    Handle,
                    index,
                    KeyBasicInformation,
                    KeyInformation,
                    WORK_SIZE,
                    &ResultLength
                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            WorkName.Length = NamePos;
            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmpsec: dump1: status = %08lx\n", status);
            exit(1);

        }

        enumname.Buffer = &(KeyInformation->Name[0]);
        enumname.Length = KeyInformation->NameLength;
        enumname.MaximumLength = KeyInformation->NameLength;

        p = WorkName.Buffer;
        p += WorkName.Length;
        *p = '\\';
        p++;
        *p = '\0';
        WorkName.Length += 2;

        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&enumname);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &enumname,
            0,
            Handle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtOpenKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(status)) {
            if (status == STATUS_ACCESS_DENIED) {
                printf("\n");
                print(&WorkName);
                printf("::\n\tAccess denied!\n");
            } else {
                printf("rtdmpsec: dump2: %08lx\n", status);
                exit(1);
            }
        } else {
            Dump(WorkHandle);
            NtClose(WorkHandle);
        }

        WorkName.Length = NamePos;
    }
}


void
DumpSecurity(
    HANDLE  Handle
    )
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    NTSTATUS Status;
    ULONG Length;
    PACL Dacl;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    Status = NtQuerySecurityObject( Handle,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &Length );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        printf("DumpSecurity t0: NtQuerySecurityObject failed %lx\n",Status);
        exit(1);
    }

    SecurityDescriptor = malloc(Length);
    if (SecurityDescriptor == NULL) {
        printf("DumpSecurity: couldn't malloc buffer\n");
        exit(1);
    }

    Status = NtQuerySecurityObject( Handle,
                                    DACL_SECURITY_INFORMATION,
                                    SecurityDescriptor,
                                    Length,
                                    &Length );

    if (!NT_SUCCESS(Status)) {
        printf("DumpSecurity t1: NtQuerySecurityObject failed %lx\n",Status);
        exit(1);
    }

    Dacl = NULL;

    Status = RtlGetDaclSecurityDescriptor( SecurityDescriptor,
                                           &DaclPresent,
                                           &Dacl,
                                           &DaclDefaulted );
    if (!NT_SUCCESS(Status)) {
        printf("DumpSecurity t2: RtlGetDaclSecurityDescriptor failed %lx\n",Status);
    }

    if (DaclPresent) {
        PrintAcl(Dacl);
    } else {
        printf("\tAcl not present\n");
    }

}


void
print(
    PUNICODE_STRING  String
    )
{
    static  ANSI_STRING temp;
    static  char        tempbuffer[WORK_SIZE];

    temp.MaximumLength = WORK_SIZE;
    temp.Length = 0L;
    temp.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&temp, String, FALSE);
    printf("%s", temp.Buffer);
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        FALSE
        );

    return;
}


BOOLEAN
SidTranslation(
    PSID Sid,
    PSTRING AccountName
    )
// AccountName is expected to have a large maximum length

{
    if (RtlEqualSid(Sid, WorldSid)) {
        RtlInitString( AccountName, "WORLD");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, LocalSid)) {
        RtlInitString( AccountName, "LOCAL");

        return(TRUE);
    }

    if (RtlEqualSid(Sid, NetworkSid)) {
        RtlInitString( AccountName, "NETWORK");

        return(TRUE);
    }

    if (RtlEqualSid(Sid, BatchSid)) {
        RtlInitString( AccountName, "BATCH");

        return(TRUE);
    }

    if (RtlEqualSid(Sid, InteractiveSid)) {
        RtlInitString( AccountName, "INTERACTIVE");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, LocalSystemSid)) {
        RtlInitString( AccountName, "SYSTEM");
        return(TRUE);
    }

//
//    if (RtlEqualSid(Sid, LocalManagerSid)) {
//      RtlInitString( AccountName, "LOCAL MANAGER");
//      return(TRUE);
//  }

//  if (RtlEqualSid(Sid, LocalAdminSid)) {
//      RtlInitString( AccountName, "LOCAL ADMIN");
//      return(TRUE);
//  }

    return(FALSE);

}


VOID
DisplayAccountSid(
    PSID Sid
    )
{
    UCHAR Buffer[128];
    STRING AccountName;
    UCHAR i;
    ULONG Tmp;
    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    UCHAR SubAuthorityCount;

    Buffer[0] = 0;

    AccountName.MaximumLength = 127;
    AccountName.Length = 0;
    AccountName.Buffer = (PVOID)&Buffer[0];



    if (SidTranslation( (PSID)Sid, &AccountName) ) {

        printf("%s\n", AccountName.Buffer );

    } else {
        IdentifierAuthority = RtlIdentifierAuthoritySid(Sid);

        //
        // HACK! HACK!
        // The next line prints the revision of the SID.  Since there is no
        // rtl routine which gives us the SID revision, we must make due.
        // luckily, the revision field is the first field in the SID, so we
        // can just cast the pointer.
        //

        printf("S-%u-", (USHORT) *((PUCHAR) Sid) );

        if (  (IdentifierAuthority->Value[0] != 0)  ||
              (IdentifierAuthority->Value[1] != 0)     ){
            printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                        IdentifierAuthority->Value[0],
                        IdentifierAuthority->Value[1],
                        IdentifierAuthority->Value[2],
                        IdentifierAuthority->Value[3],
                        IdentifierAuthority->Value[4],
                        IdentifierAuthority->Value[5] );
        } else {
            Tmp = IdentifierAuthority->Value[5]          +
                  (IdentifierAuthority->Value[4] <<  8)  +
                  (IdentifierAuthority->Value[3] << 16)  +
                  (IdentifierAuthority->Value[2] << 24);
            printf("%lu", Tmp);
        }

        SubAuthorityCount = *RtlSubAuthorityCountSid(Sid);
        for (i=0;i<SubAuthorityCount ;i++ ) {
            printf("-%lu", (*RtlSubAuthoritySid(Sid, i)));
        }
        printf("\n");

    }

}

VOID
InitVars()
{
    ULONG SidWithZeroSubAuthorities;
    ULONG SidWithOneSubAuthority;
    ULONG SidWithThreeSubAuthorities;
    ULONG SidWithFourSubAuthorities;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;


    //
    //  The following SID sizes need to be allocated
    //

    SidWithZeroSubAuthorities  = RtlLengthRequiredSid( 0 );
    SidWithOneSubAuthority     = RtlLengthRequiredSid( 1 );
    SidWithThreeSubAuthorities = RtlLengthRequiredSid( 3 );
    SidWithFourSubAuthorities  = RtlLengthRequiredSid( 4 );

    //
    //  Allocate and initialize the universal SIDs
    //

    NullSid         = (PSID)malloc(SidWithOneSubAuthority);
    WorldSid        = (PSID)malloc(SidWithOneSubAuthority);
    LocalSid        = (PSID)malloc(SidWithOneSubAuthority);
    CreatorOwnerSid = (PSID)malloc(SidWithOneSubAuthority);

    RtlInitializeSid( NullSid,    &NullSidAuthority, 1 );
    RtlInitializeSid( WorldSid,   &WorldSidAuthority, 1 );
    RtlInitializeSid( LocalSid,   &LocalSidAuthority, 1 );
    RtlInitializeSid( CreatorOwnerSid, &CreatorSidAuthority, 1 );

    *(RtlSubAuthoritySid( NullSid, 0 ))         = SECURITY_NULL_RID;
    *(RtlSubAuthoritySid( WorldSid, 0 ))        = SECURITY_WORLD_RID;
    *(RtlSubAuthoritySid( LocalSid, 0 ))        = SECURITY_LOCAL_RID;
    *(RtlSubAuthoritySid( CreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //

    NtAuthoritySid  = (PSID)malloc(SidWithZeroSubAuthorities);
    DialupSid       = (PSID)malloc(SidWithOneSubAuthority);
    NetworkSid      = (PSID)malloc(SidWithOneSubAuthority);
    BatchSid        = (PSID)malloc(SidWithOneSubAuthority);
    InteractiveSid  = (PSID)malloc(SidWithOneSubAuthority);
    LocalSystemSid  = (PSID)malloc(SidWithOneSubAuthority);

    RtlInitializeSid( NtAuthoritySid,   &NtAuthority, 0 );
    RtlInitializeSid( DialupSid,        &NtAuthority, 1 );
    RtlInitializeSid( NetworkSid,       &NtAuthority, 1 );
    RtlInitializeSid( BatchSid,         &NtAuthority, 1 );
    RtlInitializeSid( InteractiveSid,   &NtAuthority, 1 );
    RtlInitializeSid( LocalSystemSid,   &NtAuthority, 1 );

    *(RtlSubAuthoritySid( DialupSid,       0 )) = SECURITY_DIALUP_RID;
    *(RtlSubAuthoritySid( NetworkSid,      0 )) = SECURITY_NETWORK_RID;
    *(RtlSubAuthoritySid( BatchSid,        0 )) = SECURITY_BATCH_RID;
    *(RtlSubAuthoritySid( InteractiveSid,  0 )) = SECURITY_INTERACTIVE_RID;
    *(RtlSubAuthoritySid( LocalSystemSid,  0 )) = SECURITY_LOCAL_SYSTEM_RID;

    return;

}



VOID
PrintAcl (
    IN PACL Acl
    )

/*++

Routine Description:

    This routine dumps an Acl for debug purposes (via printf).  It is
    specialized to dump standard aces.

Arguments:

    Acl - Supplies the Acl to dump

Return Value:

    None

--*/


{
    ULONG i;
    PKNOWN_ACE Ace;
    BOOLEAN KnownType;
    PCHAR AceTypes[] = { "Access Allowed",
                         "Access Denied ",
                         "System Audit  ",
                         "System Alarm  "
                       };

    if (Acl == NULL) {

        printf("\tAcl == ALL ACCESS GRANTED!\n");
        return;

    }

    //
    //  Dump the Acl header
    //

    printf("\tRevision: %02x", Acl->AclRevision);
    printf(" Size: %04x", Acl->AclSize);
    printf(" AceCount: %04x\n", Acl->AceCount);

    //
    //  Now for each Ace we want do dump it
    //

    for (i = 0, Ace = FirstAce(Acl);
         i < Acl->AceCount;
         i++, Ace = NextAce(Ace) ) {

        //
        //  print out the ace header
        //

        printf("\n\tAceHeader: %08lx ", *(PULONG)Ace);

        //
        //  special case on the standard ace types
        //

        if ((Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
            (Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) ||
            (Ace->Header.AceType == SYSTEM_AUDIT_ACE_TYPE) ||
            (Ace->Header.AceType == SYSTEM_ALARM_ACE_TYPE)) {

            //
            //  The following array is indexed by ace types and must
            //  follow the allowed, denied, audit, alarm seqeuence
            //

            PCHAR AceTypes[] = { "Access Allowed",
                                 "Access Denied ",
                                 "System Audit  ",
                                 "System Alarm  "
                               };

            printf(AceTypes[Ace->Header.AceType]);
            PrintAccessMask(Ace->Mask);
            KnownType = TRUE;

        } else {

            KnownType = FALSE;
            printf(" Unknown Ace Type\n");

        }

        printf("\n");

        printf("\tAceSize = %d\n",Ace->Header.AceSize);

        printf("\tAce Flags = ");
        if (Ace->Header.AceFlags & OBJECT_INHERIT_ACE) {
            printf("OBJECT_INHERIT_ACE\n");
            printf("                   ");
        }

        if (Ace->Header.AceFlags & CONTAINER_INHERIT_ACE) {
            printf("CONTAINER_INHERIT_ACE\n");
            printf("                   ");
        }

        if (Ace->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE) {
            printf("NO_PROPAGATE_INHERIT_ACE\n");
            printf("                   ");
        }

        if (Ace->Header.AceFlags & INHERIT_ONLY_ACE) {
            printf("INHERIT_ONLY_ACE\n");
            printf("                   ");
        }

        if (Ace->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
            printf("SUCCESSFUL_ACCESS_ACE_FLAG\n");
            printf("            ");
        }

        if (Ace->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) {
            printf("FAILED_ACCESS_ACE_FLAG\n");
            printf("            ");
        }

        printf("\n");

        printf("\tSid = ");
        DisplayAccountSid(&Ace->SidStart);
    }

}


VOID
PrintAccessMask(
    IN ACCESS_MASK AccessMask
    )
{
    printf("\n\tAccess Mask: ");

    if (AccessMask == KEY_ALL_ACCESS) {
        printf("KEY_ALL_ACCESS\n\t             ");
        return;
    }
    if (AccessMask == KEY_READ) {
        printf("KEY_READ\n\t             ");
        return;
    }
    if (AccessMask == KEY_WRITE) {
        printf("KEY_WRITE\n\t             ");
        return;
    }

    if (AccessMask & KEY_QUERY_VALUE) {
        printf("KEY_QUERY_VALUE\n\t             ");
    }
    if (AccessMask & KEY_SET_VALUE) {
        printf("KEY_SET_VALUE\n\t             ");
    }
    if (AccessMask & KEY_CREATE_SUB_KEY) {
        printf("KEY_CREATE_SUB_KEY\n\t             ");
    }
    if (AccessMask & KEY_ENUMERATE_SUB_KEYS) {
        printf("KEY_ENUMERATE_SUB_KEYS\n\t             ");
    }
    if (AccessMask & KEY_NOTIFY) {
        printf("KEY_NOTIFY\n\t             ");
    }
    if (AccessMask & KEY_CREATE_LINK) {
        printf("KEY_CREATE_LINK\n\t             ");
    }
    if (AccessMask & GENERIC_ALL) {
        printf("GENERIC_ALL\n\t             ");
    }
    if (AccessMask & GENERIC_EXECUTE) {
        printf("GENERIC_EXECUTE\n\t             ");
    }
    if (AccessMask & GENERIC_WRITE) {
        printf("GENERIC_WRITE\n\t             ");
    }
    if (AccessMask & GENERIC_READ) {
        printf("GENERIC_READ\n\t             ");
    }
    if (AccessMask & GENERIC_READ) {
        printf("GENERIC_READ\n\t             ");
    }
    if (AccessMask & MAXIMUM_ALLOWED) {
        printf("MAXIMUM_ALLOWED\n\t             ");
    }
    if (AccessMask & ACCESS_SYSTEM_SECURITY) {
        printf("ACCESS_SYSTEM_SECURITY\n\t             ");
    }
    if (AccessMask & WRITE_OWNER) {
        printf("WRITE_OWNER\n\t             ");
    }
    if (AccessMask & WRITE_DAC) {
        printf("WRITE_DAC\n\t             ");
    }
    if (AccessMask & READ_CONTROL) {
        printf("READ_CONTROL\n\t             ");
    }
    if (AccessMask & DELETE) {
        printf("DELETE\n\t             ");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtdelval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdelval.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Delete a key's value entry (field)

    rtdelval <KeyPath> <value entry name>

    Example:

        rtdelval \REGISTRY\MACHINE\TEST\bigkey first_value_field

Author:

    Bryan Willman (bryanwi)  10-Jan-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

UNICODE_STRING  ValueName;
WCHAR           valuebuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);


    ValueName.MaximumLength = WORK_SIZE;
    ValueName.Length = 0L;
    ValueName.Buffer = &(valuebuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdelval: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_SET_VALUE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdelval: t0: %08lx\n", status);
        exit(1);
    }

    status = NtDeleteValueKey(BaseHandle, &ValueName);
    if (!NT_SUCCESS(status)) {
        printf("rtdelval: t1: %08lx\n", status);
        exit(1);
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 3) )
    {
        printf("Usage: %s <KeyPath> <value entry name>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &ValueName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtdmp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdmp.c

Abstract:

    NT level registry api test program #3, basic non-error paths.

    Dump out a sub-tree of the registry.

    rtdmp <KeyPath>

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    It assumes data values are null terminated strings.

    Example:

        rtdmp \REGISTRY\MACHINE\TEST\bigkey


        \REGISTRY\MACHINE\TEST\bigkey::

            ValueTest1_01 type=0 ti=1
            "This is a test string"

            ValueTest1_01 type=0 ti=2
            "This is a test string"

        \REGISTRY\MACHCINE\TEST\bigkey\child_key_1::

            ValueTest1_01 type=0 ti=1
            "This is a test string"

            ValueTest1_01 type=0 ti=2
            "This is a test string"
Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE 16384

void __cdecl main(int, char *);
void processargs();

void print(PUNICODE_STRING);

void
DumpValues(
    HANDLE  Handle
    );

void
Dump(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open Ke