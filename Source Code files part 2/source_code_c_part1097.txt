
        //

        links = IopHardError.WorkQueue.Flink;

        while (links != &IopHardError.WorkQueue) {

            PIOP_HARD_ERROR_PACKET queueHardErrorPacket;

            queueHardErrorPacket = CONTAINING_RECORD( links,
                                                      IOP_HARD_ERROR_PACKET,
                                                      WorkQueueLinks );

            if (ArePacketsEquivalent( hardErrorPacket,
                                      queueHardErrorPacket )) {

                ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );

                if ( hardErrorPacket->String.Buffer ) {
                    ExFreePool( hardErrorPacket->String.Buffer );
                }
                ExFreePool( hardErrorPacket );
                return FALSE;
            }

            links = links->Flink;
        }

        //
        //  Enqueue this packet.
        //

        InsertTailList( &IopHardError.WorkQueue,
                        &hardErrorPacket->WorkQueueLinks );

        //
        //  Bump the count on the semaphore so that the hard error thread
        //  will know that an entry has been placed in the queue.
        //

        (VOID) KeReleaseSemaphore( &IopHardError.WorkQueueSemaphore,
                                   0,
                                   1L,
                                   FALSE );

        //
        //  If we are not currently running in an ExWorkerThread, queue
        //  a work item.
        //

        if ( !IopHardError.ThreadStarted ) {
            IopHardError.ThreadStarted = TRUE;
            ExQueueWorkItem( &IopHardError.ExWorkItem, DelayedWorkQueue );
        }

        //
        //  Finally, release the spinlockevent, allowing access to the work queue again.
        //  The combination of releasing both the event and the semaphore will
        //  enable the thread to wake up and obtain the entry.
        //

        ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );
    }

    return TRUE;
}

VOID
IoRegisterBootDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked by boot drivers during their initialization or
    during their reinitialization to register with the I/O system to be
    called again once all devices have been enumerated and started.
    Note that it  is possible for this to occur during a normally running
    system, if the  driver is loaded dynamically, so all references to the
    reinitialization queue must be synchronized.

Arguments:

    DriverObject - Pointer to the driver's driver object.

    DriverReinitializationRoutine - The address of the reinitialization
        routine that is to be invoked.

    Context - Pointer to the context that is passed to the driver's
        reinitialization routine.

Return Value:

    None.

--*/

{
    PREINIT_PACKET reinitEntry;

    PAGED_CODE();

    //
    // Allocate a reinitialization entry to be inserted onto the list.  Note
    // that if the entry cannot be allocated, then the request is simply
    // dropped on the floor.
    //

    reinitEntry = ExAllocatePoolWithTag( NonPagedPool,
                                         sizeof( REINIT_PACKET ),
                                         'iRoI' );
    if (!reinitEntry) {
        return;
    }

    DriverObject->Flags |= DRVO_BOOTREINIT_REGISTERED;
    reinitEntry->DriverObject = DriverObject;
    reinitEntry->DriverReinitializationRoutine = DriverReinitializationRoutine;
    reinitEntry->Context = Context;

    IopInterlockedInsertTailList( &IopBootDriverReinitializeQueueHead,
                                  &reinitEntry->ListEntry );
}

VOID
IoRegisterDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked by drivers during their initialization or during
    their reinitialization to register with the I/O system to be called again
    before I/O system initialization is complete.  Note that it is possible
    for this to occur during a normally running system, if the driver is
    loaded dynamically, so all references to the reinitialization queue must
    be synchronized.

Arguments:

    DriverObject - Pointer to the driver's driver object.

    DriverReinitializationRoutine - The address of the reinitialization
        routine that is to be invoked.

    Context - Pointer to the context that is passed to the driver's
        reinitialization routine.

Return Value:

    None.

--*/

{
    PREINIT_PACKET reinitEntry;

    PAGED_CODE();

    //
    // Allocate a reinitialization entry to be inserted onto the list.  Note
    // that if the entry cannot be allocated, then the request is simply
    // dropped on the floor.
    //

    reinitEntry = ExAllocatePoolWithTag( NonPagedPool,
                                         sizeof( REINIT_PACKET ),
                                         'iRoI' );
    if (!reinitEntry) {
        return;
    }

    DriverObject->Flags |= DRVO_REINIT_REGISTERED;
    reinitEntry->DriverObject = DriverObject;
    reinitEntry->DriverReinitializationRoutine = DriverReinitializationRoutine;
    reinitEntry->Context = Context;

    IopInterlockedInsertTailList( &IopDriverReinitializeQueueHead,
                                  &reinitEntry->ListEntry );
}

VOID
IoRegisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine inserts the device object for the file system which the device
    object represents into the list of file systems in the system.

Arguments:

    DeviceObject - Pointer to device object for the file system.

Return Value:

    None.


--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY listHead = NULL;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Allocate the I/O database resource for a write operation.
    //

    (VOID) ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Insert the device object into the appropriate file system queue based on
    // the driver type in the device object.  Notice that if the device type is
    // unrecognized, the file system is simply not registered.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM) {
        listHead = &IopNetworkFileSystemQueueHead;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_CD_ROM_FILE_SYSTEM) {
        listHead = &IopCdRomFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
        listHead = &IopDiskFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_TAPE_FILE_SYSTEM) {
        listHead = &IopTapeFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    }

    //
    //  Low priority filesystems are inserted one-from-back on the queue (ahead of
    //  raw, behind everything else), as opposed to on the front.
    //

    if (listHead != NULL) {
        if (DeviceObject->Flags & DO_LOW_PRIORITY_FILESYSTEM ) {
            InsertTailList( listHead->Blink,
                            &DeviceObject->Queue.ListEntry );
        } else {
            InsertHeadList( listHead,
                            &DeviceObject->Queue.ListEntry );
        }
    }

    IopFsRegistrationOps++;

    //
    // Ensure that this file system's device is operable.
    //

    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Notify all of the registered drivers that this file system has been
    // registered as an active file system of some type.
    //

    entry = IopFsNotifyChangeQueueHead.Flink;
    while (entry != &IopFsNotifyChangeQueueHead) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        entry = entry->Flink;
        nPacket->NotificationRoutine( DeviceObject, TRUE );
    }

    //
    // Release the I/O database resource.
    //

    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Increment the number of reasons that this driver cannot be unloaded.
    //

    IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );
}

VOID
IopNotifyAlreadyRegisteredFileSystems(
    IN PLIST_ENTRY  ListHead,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine,
    IN BOOLEAN SkipRaw
    )
/*++

Routine Description:

    This routine calls the driver notification routine for filesystems
    that have already been registered at the time of the call.

Arguments:

    ListHead - Pointer to the filesystem registration list head.
    DriverNotificationRoutine - Pointer to the routine that has to be called.

Return Value:

    None.

--*/
{
    PLIST_ENTRY entry;
    PDEVICE_OBJECT fsDeviceObject;

    entry = ListHead->Flink;
    while (entry != ListHead) {

        //
        // Skip raw filesystem notification
        //
        if ((entry->Flink == ListHead) && (SkipRaw)) {
            break;
        }

        fsDeviceObject = CONTAINING_RECORD( entry, DEVICE_OBJECT, Queue.ListEntry );
        entry = entry->Flink;
        DriverNotificationRoutine( fsDeviceObject, TRUE );
    }
}

NTSTATUS
IoRegisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    )

/*++

Routine Description:

    This routine registers the specified driver's notification routine to be
    invoked whenever a file system registers or unregisters itself as an active
    file system in the system.

Arguments:

    DriverObject - Pointer to the driver object for the driver.

    DriverNotificationRoutine - Address of routine to invoke when a file system
        registers or unregisters itself.

Return Value:

    The return status is the final value of the function.

--*/

{
    PNOTIFICATION_PACKET nPacket;

    PAGED_CODE();

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    nPacket = ExAllocatePoolWithTag( PagedPool|POOL_COLD_ALLOCATION,
                                     sizeof( NOTIFICATION_PACKET ),
                                     'sFoI' );
    if (!nPacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the notification packet and insert it onto the tail of the
    // list.
    //

    nPacket->DriverObject = DriverObject;
    nPacket->NotificationRoutine = DriverNotificationRoutine;

    ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );
    InsertTailList( &IopFsNotifyChangeQueueHead, &nPacket->ListEntry );

    IopNotifyAlreadyRegisteredFileSystems(&IopNetworkFileSystemQueueHead, DriverNotificationRoutine, FALSE);
    IopNotifyAlreadyRegisteredFileSystems(&IopCdRomFileSystemQueueHead, DriverNotificationRoutine, TRUE);
    IopNotifyAlreadyRegisteredFileSystems(&IopDiskFileSystemQueueHead, DriverNotificationRoutine, TRUE);
    IopNotifyAlreadyRegisteredFileSystems(&IopTapeFileSystemQueueHead, DriverNotificationRoutine, TRUE);

    //
    // Notify this driver about all already notified filesystems
    // registered as an active file system of some type.
    //


    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Increment the number of reasons that this driver cannot be unloaded.
    //

    ObReferenceObject( DriverObject );

    return STATUS_SUCCESS;
}



NTSTATUS
IoRegisterLastChanceShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine allows a driver to register that it would like to have its
    shutdown routine invoked at very late in system shutdown.  This gives
    the driver an opportunity to get control just before the system is fully
    shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PSHUTDOWN_PACKET shutdown;

    PAGED_CODE();

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    shutdown = ExAllocatePoolWithTag( NonPagedPool,
                                      sizeof( SHUTDOWN_PACKET ),
                                      'hSoI' );
    if (!shutdown) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the shutdown packet and insert it onto the head of the list.
    // Note that this is done because some drivers have dependencies on LIFO
    // notification ordering.
    //

    ObReferenceObject(DeviceObject);    // Ensure that the driver remains
    shutdown->DeviceObject = DeviceObject;

    IopInterlockedInsertHeadList( &IopNotifyLastChanceShutdownQueueHead,
                                  &shutdown->ListEntry );

    //
    // Do the bookkeeping to indicate that this driver has successfully
    // registered a shutdown notification routine.
    //

    DeviceObject->Flags |= DO_SHUTDOWN_REGISTERED;

    return STATUS_SUCCESS;
}

NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine allows a driver to register that it would like to have its
    shutdown routine invoked when the system is being shutdown.  This gives
    the driver an opportunity to get control just before the system is fully
    shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PSHUTDOWN_PACKET shutdown;

    PAGED_CODE();

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    shutdown = ExAllocatePoolWithTag( NonPagedPool,
                                      sizeof( SHUTDOWN_PACKET ),
                                      'hSoI' );
    if (!shutdown) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the shutdown packet and insert it onto the head of the list.
    // Note that this is done because some drivers have dependencies on LIFO
    // notification ordering.
    //

    shutdown->DeviceObject = DeviceObject;
    ObReferenceObject(DeviceObject);    // Ensure that the driver remains

    IopInterlockedInsertHeadList( &IopNotifyShutdownQueueHead,
                                  &shutdown->ListEntry );

    //
    // Do the bookkeeping to indicate that this driver has successfully
    // registered a shutdown notification routine.
    //

    DeviceObject->Flags |= DO_SHUTDOWN_REGISTERED;

    return STATUS_SUCCESS;
}

VOID
IoReleaseCancelSpinLock(
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to release the cancel spin lock.  This spin lock
    must be acquired before setting the address of a cancel routine in an
    IRP and released after the cancel routine has been set.

Arguments:

    Irql - Supplies the IRQL value returned from acquiring the spin lock.

Return Value:

    None.

--*/

{
    //
    // Simply release the cancel spin lock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoCancelLock, Irql );
}

VOID
IoReleaseVpbSpinLock(
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to release the Volume Parameter Block (VPB) spin
    lock.  This spin lock must be acquired before accessing the mount flag,
    reference count, and device object fields of a VPB.

Arguments:

    Irql - Supplies the IRQL value returned from acquiring the spin lock.

Return Value:

    None.

--*/

{
    //
    // Simply release the VPB spin lock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, Irql );
}

VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to remove the access and share access information
    in a file system Share Access structure for a given open instance.

Arguments:

    FileObject - Pointer to the file object of the current access being closed.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // If this accessor wanted some type of access other than READ_ or
    // WRITE_ATTRIBUTES, then account for the fact that he has closed the
    // file.  Otherwise, he hasn't been accounted for in the first place
    // so don't do anything.
    //

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {
            return;
        }
    }

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Decrement the number of opens in the Share Access structure.
        //

        ShareAccess->OpenCount--;

        //
        // For each access type, decrement the appropriate count in the Share
        // Access structure.
        //

        if (FileObject->ReadAccess) {
            ShareAccess->Readers--;
        }

        if (FileObject->WriteAccess) {
            ShareAccess->Writers--;
        }

        if (FileObject->DeleteAccess) {
            ShareAccess->Deleters--;
        }

        //
        // For each shared access type, decrement the appropriate count in the
        // Share Access structure.
        //

        if (FileObject->SharedRead) {
            ShareAccess->SharedRead--;
        }

        if (FileObject->SharedWrite) {
            ShareAccess->SharedWrite--;
        }

        if (FileObject->SharedDelete) {
            ShareAccess->SharedDelete--;
        }
    }
}

VOID
IoSetDeviceToVerify(
    IN PETHREAD Thread,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine sets the device to verify field in the thread object.  This
    function is invoked by file systems to NULL this field, or to set it to
    predefined values.

Arguments:

    Thread - Pointer to the thread whose field is to be set.

    DeviceObject - Pointer to the device to be verified, or NULL, or ...

Return Value:

    None.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply set the device to be verified in the specified thread.
    //

    Thread->DeviceToVerify = DeviceObject;
}

VOID
IoSetHardErrorOrVerifyDevice(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked when a driver realizes that the media
    has possibly changed on a device, and it must be verified before
    continuing, or a hard error has occured.  The device is stored
    in the thread local storage of the Irp's originating thread.

Arguments:

    Irp - Pointer to an I/O Request Packet to get the thread.

    DeviceObject - This is the device that needs to be verified.

Return Value:

    None.

--*/

{
    //
    // If the cancel flag is set in the IRP and thread is NULL
    // ignore the verification. This is because its possible for the IO
    // manager to dequeue the IRP from the thread list.
    //

    if (!(Irp->Tail.Overlay.Thread)) {
        return;
    }

    //
    // Store the address of the device object that needs verification in
    // the appropriate field of the thread pointed to by the specified I/O
    // Request Packet.
    //


    ASSERT( Irp->Tail.Overlay.Thread != NULL );

    Irp->Tail.Overlay.Thread->DeviceToVerify = DeviceObject;
}

NTSTATUS
IoSetInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN PVOID FileInformation
    )

/*++

Routine Description:

    This routine sets the requested information for the specified file.
    The information that is set is determined by the FileInformationClass
    paramter, and the information itself is passed in the FileInformation
    buffer.

Arguments:

    FileObject - Supplies a pointer to the file object for the file that
        is to be changed.

    FileInformationClass - Specifies the type of information that should
        be set on the file.

    Length - Supplies the length of the FileInformation buffer in bytes.

    FileInformation - A buffer containing the file information to set.  This
        buffer must not be pageable and must reside in system space.

Return Value:

    The status returned is the final completion status of the operation.


--*/

{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    HANDLE targetHandle = NULL;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //

    ObReferenceObject( FileObject );

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then initialize the local event.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( FileObject )) {
            status = IopAcquireFileObjectLock( FileObject,
                                               KernelMode,
                                               (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( FileObject );
                return status;
            }
        }
        KeClearEvent( &FileObject->Event );
        synchronousIo = TRUE;
    } else {
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case there is
    // not enough memory to satisfy the request.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( FileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
    } else {
        irp->UserEvent = &event;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->UserIosb = &localIoStatus;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = FileInformation;
    irp->Flags |= IRP_BUFFERED_IO;

    //
    // Copy the caller's parameters to the service-specific portion of the IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants to
    // set is device independent (I/O system dependent).  If this is the case,
    // then the request can be satisfied here without having to have all of
    // the drivers implement the same code.  Note that having the IRP is still
    // necessary since the I/O completion code requires it.
    //

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = FileInformation;

        //
        // Set or clear the appropriate flags in the file object.
        //

        if (!(FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)) {
            if (modeBuffer->Mode & FILE_WRITE_THROUGH) {
                FileObject->Flags |= FO_WRITE_THROUGH;
            } else {
                FileObject->Flags &= ~FO_WRITE_THROUGH;
            }
        }

        if (modeBuffer->Mode & FILE_SEQUENTIAL_ONLY) {
            FileObject->Flags |= FO_SEQUENTIAL_ONLY;
        } else {
            FileObject->Flags &= ~FO_SEQUENTIAL_ONLY;
        }

        if (modeBuffer->Mode & FO_SYNCHRONOUS_IO) {
            if (modeBuffer->Mode & FILE_SYNCHRONOUS_IO_ALERT) {
                FileObject->Flags |= FO_ALERTABLE_IO;
            } else {
                FileObject->Flags &= ~FO_ALERTABLE_IO;
            }
        }

        status = STATUS_SUCCESS;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

        IoSetNextIrpStackLocation( irp );
        IoCompleteRequest( irp, 0 );

    } else if (FileInformationClass == FileRenameInformation ||
               FileInformationClass == FileLinkInformation ||
               FileInformationClass == FileMoveClusterInformation) {

        //
        // Note that the following code assumes that a rename information
        // and a set link information structure look exactly the same.
        //

        PFILE_RENAME_INFORMATION renameBuffer = FileInformation;

        //
        // Copy the value of the replace BOOLEAN (or the ClusterCount field)
        // from the caller's buffer to the I/O stack location parameter
        // field where it is expected by file systems.
        //

        if (FileInformationClass == FileMoveClusterInformation) {
            irpSp->Parameters.SetFile.ClusterCount =
                ((FILE_MOVE_CLUSTER_INFORMATION *) renameBuffer)->ClusterCount;
        } else {
            irpSp->Parameters.SetFile.ReplaceIfExists = renameBuffer->ReplaceIfExists;
        }

        //
        // Check to see whether or not a fully qualified pathname was supplied.
        // If so, then more processing is required.
        //

        if (renameBuffer->FileName[0] == (UCHAR) OBJ_NAME_PATH_SEPARATOR ||
            renameBuffer->RootDirectory != NULL) {

            //
            // A fully qualified file name was specified as the target of the
            // rename operation.  Attempt to open the target file and ensure
            // that the replacement policy for the file is consistent with the
            // caller's request, and ensure that the file is on the same volume.
            //

            status = IopOpenLinkOrRenameTarget( &targetHandle,
                                                irp,
                                                renameBuffer,
                                                FileObject );
            if (!NT_SUCCESS( status )) {
                IoSetNextIrpStackLocation( irp );
                IoCompleteRequest( irp, 2 );

            } else {

                //
                // The fully qualified file name specifies a file on the same
                // volume and if it exists, then the caller specified that it
                // should be replaced.
                //

                status = IoCallDriver( deviceObject, irp );

            }

        } else {

            //
            // This is a simple rename operation, so call the driver and let
            // it perform the rename operation within the same directory as
            // the source file.
            //

            status = IoCallDriver( deviceObject, irp );

        }

    } else {

        //
        // This is not a request that can be performed here, so invoke the
        // driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );

    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (synchronousIo) {
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject( &FileObject->Event,
                                            Executive,
                                            KernelMode,
                                            (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );
            if (status == STATUS_ALERTED) {
                IopCancelAlertedRequest( &FileObject->Event, irp );
            }
            status = localIoStatus.Status;
        }
        IopReleaseFileObjectLock( FileObject );

    } else {

        //
        // This is a normal synchronous I/O operation, as opposed to a
        // serialized synchronous I/O operation.  For this case, wait for
        // the local event and copy the final status information back to
        // the caller.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = localIoStatus.Status;
        }
    }

    //
    // If a target handle was created because of a rename operation, close
    // the handle now.
    //

    if (targetHandle != (HANDLE) NULL) {
        NtClose( targetHandle );
    }

    return status;
}

VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to set the access and share access information
    in a file system Share Access structure for the first open.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    BOOLEAN update = TRUE;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {

            //
            //  This fileobject is marked to ignore share access checks
            //  so we also don't want to affect the file/directory's
            //  ShareAccess structure counts.
            //

            update = FALSE;
        }
    }

    //
    // Check to see whether the current file opener would like to read,
    // write, or delete the file.  If so, account for it in the share access
    // structure; otherwise, skip it.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Only update the share modes if the user wants to read, write or
        // delete the file.
        //

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        if (update) {

            //
            // Set the Share Access structure open count.
            //

            ShareAccess->OpenCount = 1;

            //
            // Set the number of readers, writers, and deleters in the Share Access
            // structure.
            //

            ShareAccess->Readers = FileObject->ReadAccess;
            ShareAccess->Writers = FileObject->WriteAccess;
            ShareAccess->Deleters = FileObject->DeleteAccess;

            //
            // Set the number of shared readers, writers, and deleters in the Share
            // Access structure.
            //

            ShareAccess->SharedRead = FileObject->SharedRead;
            ShareAccess->SharedWrite = FileObject->SharedWrite;
            ShareAccess->SharedDelete = FileObject->SharedDelete;
        }

    } else {

        //
        // No read, write, or delete access has been requested.  Simply zero
        // the appropriate fields in the structure so that the next accessor
        // sees a consistent state.
        //

        if (update) {

            ShareAccess->OpenCount = 0;
            ShareAccess->Readers = 0;
            ShareAccess->Writers = 0;
            ShareAccess->Deleters = 0;
            ShareAccess->SharedRead = 0;
            ShareAccess->SharedWrite = 0;
            ShareAccess->SharedDelete = 0;
        }
    }
}

BOOLEAN
IoSetThreadHardErrorMode(
    IN BOOLEAN EnableHardErrors
    )

/*++

Routine Description:

    This routine either enables or disables hard errors for the current
    thread and returns the old state of the flag.

Arguments:

    EnableHardErrors - Supplies a BOOLEAN value indicating whether or not
        hard errors are to be enabled for the current thread.

Return Value:

    The final function value is the previous state of whether or not hard
    errors were enabled.

--*/

{
    PETHREAD thread;
    BOOLEAN oldFlag;

    //
    // Get a pointer to the current thread, capture the current state of
    // hard errors, and set the new state.
    //

    thread = PsGetCurrentThread();
    oldFlag = ((thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) == 0);
    if (EnableHardErrors) {
        PS_CLEAR_BITS (&thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    } else {
        PS_SET_BITS (&thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    }

    return oldFlag;
}

VOID
IoSetTopLevelIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the top level IRP field in the current thread's thread
    object.  This function is invoked by file systems to either set this field
    to the address of an I/O Request Packet (IRP) or to null it.

Arguments:

    Irp - Pointer to the IRP to be stored in the top level IRP field.

Return Value:

    None.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply set the top level IRP field in the current thread's thread
    // object.
    //

    (PIRP) (PsGetCurrentThread())->TopLevelIrp = Irp;
    return;
}

VOID
IoShutdownSystem (
    IN ULONG Phase
    )

/*++

Routine Description:

    This routine shuts down the I/O portion of the system in preparation
    for a power-off or reboot.

Arguments:

    RebootPending - Indicates whether a reboot is imminently pending.

    Phase - Indicates which phase of shutdown is being performed.

Return Value:

    None

--*/

{
    PSHUTDOWN_PACKET shutdown;
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PLIST_ENTRY entry;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PVOID unlockHandle;

    PAGED_CODE();

    //
    // Initialize the event used to synchronize the complete of all of the
    // shutdown routines.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    if (Phase == 0) {

        ZwClose(IopLinkTrackingServiceEventHandle);

        IoShutdownPnpDevices();

        //
        // Walk the list of the drivers in the system that have registered
        // themselves as wanting to know when the system is about to be
        // shutdown and invoke each.
        //

        while ((entry = IopInterlockedRemoveHeadList( &IopNotifyShutdownQueueHead )) != NULL) {
            shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );

            //
            // Another driver has been found that has indicated that it requires
            // shutdown notification.  Invoke the driver's shutdown entry point.
            //

            deviceObject = IoGetAttachedDeviceReference( shutdown->DeviceObject );

            irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                deviceObject,
                                                (PVOID) NULL,
                                                0,
                                                (PLARGE_INTEGER) NULL,
                                                &event,
                                                &ioStatus );

            if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
#if DBG
                PUNICODE_STRING DeviceName = ObGetObjectName( shutdown->DeviceObject );

                DbgPrint( "IO: Waiting for shutdown of device object (%x) - %wZ\n",
                          shutdown->DeviceObject,
                          DeviceName
                        );
#endif // DBG
                (VOID) KeWaitForSingleObject( &event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
            }

            ObDereferenceObject(deviceObject);
            ObDereferenceObject(shutdown->DeviceObject);
            ExFreePool( shutdown );
            KeClearEvent( &event );
        }

        IOV_UNLOAD_DRIVERS();

    } else if (Phase == 1) {

#if defined(REMOTE_BOOT)
        //
        // If this is a remote boot client then allow the cache to close the database and
        // mark it clean.
        //

        IopShutdownCsc();
#endif // defined(REMOTE_BOOT)

        // Gain access to the file system header queues by acquiring the
        // database resource for shared access.
        //

        ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

        IopShutdownBaseFileSystems(&IopDiskFileSystemQueueHead);

        IopShutdownBaseFileSystems(&IopCdRomFileSystemQueueHead);

        IopShutdownBaseFileSystems(&IopTapeFileSystemQueueHead);


        //
        // Walk the list of the drivers in the system that have registered
        // themselves as wanting to know at the last chance when the system
        // is about to be shutdown and invoke each.
        //

        while ((entry = IopInterlockedRemoveHeadList( &IopNotifyLastChanceShutdownQueueHead )) != NULL) {
            shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );

            //
            // Another driver has been found that has indicated that it requires
            // shutdown notification.  Invoke the driver's shutdown entry point.
            //

            deviceObject = IoGetAttachedDevice( shutdown->DeviceObject );

            irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                deviceObject,
                                                (PVOID) NULL,
                                                0,
                                                (PLARGE_INTEGER) NULL,
                                                &event,
                                                &ioStatus );

            if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
#if DBG
                PUNICODE_STRING DeviceName = ObGetObjectName( shutdown->DeviceObject );

                DbgPrint( "IO: Waiting for last chance shutdown of device object (%x) - %wZ\n",
                          shutdown->DeviceObject,
                          DeviceName
                        );
#endif // DBG
                (VOID) KeWaitForSingleObject( &event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
            }

            ObDereferenceObject(deviceObject);
            ObDereferenceObject(shutdown->DeviceObject);

            ExFreePool( shutdown );
            KeClearEvent( &event );
        }

        //
        // N.B. The system has stopped.  The IopDatabaseResource lock is
        // not released so that no other mount operations can take place.
        //
        // ExReleaseResourceLite( &IopDatabaseResource );
        //
    }

    return ;
}

VOID
IopShutdownBaseFileSystems(
    IN PLIST_ENTRY  ListHead
    )
{
    PLIST_ENTRY entry;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PDEVICE_OBJECT baseDeviceObject;
    PDEVICE_OBJECT deviceObject;
    PIRP    irp;

    //
    // Loop through each of the disk file systems, invoking each to shutdown
    // each of their mounted volumes.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    entry = RemoveHeadList(ListHead);

    while (entry != ListHead) {

        baseDeviceObject = CONTAINING_RECORD( entry, DEVICE_OBJECT, Queue.ListEntry );

        //
        // We have removed the entry. If the filesystem in this thread calls IoUnregisterFileSystem
        // then we won't remove the entry from the list as the Flink == NULL.
        //


        baseDeviceObject->Queue.ListEntry.Flink = NULL;
        baseDeviceObject->Queue.ListEntry.Blink = NULL;

        //
        // Prevent the driver from getting unloaded while shutdown handler is in progress.
        // Also prevent the base device object from going away as we need to decrement the
        // reasons for unload count later.
        //

        ObReferenceObject(baseDeviceObject);
        IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                      &baseDeviceObject->ReferenceCount );

        deviceObject = baseDeviceObject;
        if (baseDeviceObject->AttachedDevice) {
            deviceObject = IoGetAttachedDevice( baseDeviceObject );
        }

        //
        // Another file system has been found.  Invoke this file system at
        // its shutdown entry point.
        //

        irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                            deviceObject,
                                            (PVOID) NULL,
                                            0,
                                            (PLARGE_INTEGER) NULL,
                                            &event,
                                            &ioStatus );
        //
        // Its possible that the drivers are unloaded before this call returns but IoCallDriver
        // takes a reference to the device object before calling the driver. So the image will not
        // get unloaded.
        //

        if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }
        entry = RemoveHeadList(ListHead);

        KeClearEvent( &event );

        IopDecrementDeviceObjectRef(baseDeviceObject, FALSE, TRUE);
        ObDereferenceObject(baseDeviceObject);
    }
}


VOID
IopStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.  If the Cancelable paramter is TRUE, then the update of
    current IRP is synchronized using the cancel spinlock.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

Return Value:

    None.

--*/

{
    KIRQL cancelIrql;
    PIRP irp;
    PKDEVICE_QUEUE_ENTRY packet;

    //
    // Begin by checking to see whether or not this driver's requests are
    // to be considered cancelable.  If so, then acquire the cancel spinlock.
    //

    if (Cancelable) {
        IoAcquireCancelSpinLock( &cancelIrql );
    }

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Remove the next packet from the head of the queue.  If a packet was
    // found, then process it.
    //

    packet = KeRemoveDeviceQueue( &DeviceObject->DeviceQueue );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was located so make it the current packet for this
        // device.
        //

        DeviceObject->CurrentIrp = irp;
        if (Cancelable) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                irp->CancelRoutine = NULL;
            }

           IoReleaseCancelSpinLock( cancelIrql );
        }

        //
        // Invoke the driver's start I/O routine for this packet.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );
    } else {

        //
        // No packet was found, so simply release the cancel spinlock if
        // it was acquired.
        //

        if (Cancelable) {
           IoReleaseCancelSpinLock( cancelIrql );
        }
    }
}

VOID
IopStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG Key
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue by key and invoke the device driver's start
    I/O routine for it.  If the Cancelable paramter is TRUE, then the
    update of current IRP is synchronized using the cancel spinlock.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/

{
    KIRQL                cancelIrql;
    PIRP                 irp;
    PKDEVICE_QUEUE_ENTRY packet;

    //
    // Begin by determining whether or not requests for this device are to
    // be considered cancelable.  If so, then acquire the cancel spinlock.
    //

    if (Cancelable) {
        IoAcquireCancelSpinLock( &cancelIrql );
    }

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Attempt to remove the indicated packet according to the key from the
    // device queue.  If one is found, then process it.
    //

    packet = KeRemoveByKeyDeviceQueue( &DeviceObject->DeviceQueue, Key );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was successfully located.  Make it the current packet
        // and invoke the driver's start I/O routine for it.
        //

        DeviceObject->CurrentIrp = irp;

        if (Cancelable) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                irp->CancelRoutine = NULL;
            }

           IoReleaseCancelSpinLock( cancelIrql );
        }

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );

    } else {

        //
        // No packet was found, so release the cancel spinlock if it was
        // acquired.
        //

        if (Cancelable) {
           IoReleaseCancelSpinLock( cancelIrql );
        }
    }
}

VOID
IopStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to start the specified packet request (IRP) on the
    specified device.  If the device is already busy, then the packet is
    simply queued to the device queue. If a non-NULL CancelFunction is
    supplied, it will be put in the IRP.  If the IRP has been canceled, the
    CancelFunction will be called after the IRP has been inserted into the
    queue or made the current packet.

Arguments:

    DeviceObject - Pointer to device object itself.

    Irp - I/O Request Packet which should be started on the device.

    Key - Key to be used in inserting packet into device queue;  optional
        (if not specified, then packet is inserted at the tail).

    CancelFunction - Pointer to an optional cancel routine.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    KIRQL cancelIrql;
    BOOLEAN i;

    //
    // Raise the IRQL of the processor to dispatch level for synchronization.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    //
    // If the driver has indicated that packets are cancelable, then acquire
    // the cancel spinlock and set the address of the cancel function to
    // indicate that the packet is not only cancelable, but indicates what
    // routine to invoke should it be cancelled.
    //

    if (CancelFunction) {
        IoAcquireCancelSpinLock( &cancelIrql );
        Irp->CancelRoutine = CancelFunction;
    }

    //
    // If a key parameter was specified, then insert the request into the
    // work queue according to the key;  otherwise, simply insert it at the
    // tail.
    //

    if (Key) {
        i = KeInsertByKeyDeviceQueue( &DeviceObject->DeviceQueue,
                                      &Irp->Tail.Overlay.DeviceQueueEntry,
                                      *Key );
    } else {
        i = KeInsertDeviceQueue( &DeviceObject->DeviceQueue,
                                 &Irp->Tail.Overlay.DeviceQueueEntry );
    }

    //
    // If the packet was not inserted into the queue, then this request is
    // now the current packet for this device.  Indicate so by storing its
    // address in the current IRP field, and begin processing the request.
    //

    if (!i) {

        DeviceObject->CurrentIrp = Irp;

        if (CancelFunction) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                Irp->CancelRoutine = NULL;
            }

            IoReleaseCancelSpinLock( cancelIrql );
        }

        //
        // Invoke the driver's start I/O routine to get the request going on the device.
        // The StartIo routine should handle the cancellation.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, Irp );

    } else {

        //
        // The packet was successfully inserted into the device's work queue.
        // Make one last check to determine whether or not the packet has
        // already been marked cancelled.  If it has, then invoke the
        // driver's cancel routine now.  Note that because the cancel
        // spinlock is currently being held, an attempt to cancel the request
        // from another processor at this point will simply wait until this
        // routine is finished, and then get it cancelled.
        //

        if (CancelFunction) {
            if (Irp->Cancel) {
                Irp->CancelIrql = cancelIrql;
                Irp->CancelRoutine = (PDRIVER_CANCEL) NULL;
                CancelFunction( DeviceObject, Irp );
            } else {
                IoReleaseCancelSpinLock( cancelIrql );
            }
        }
    }

    //
    // Restore the IRQL back to its value upon entry to this function before
    // returning to the caller.
    //

    KeLowerIrql( oldIrql );
}

VOID
IopStartNextPacketByKeyEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG   Key,
    IN int     Flags)
/*++

Routine Description:

    This routine ensures that if the IoStartPacket* routines are called from inside StartIo then
    it defers calling the startio until after the StartIo call returns. It does this by keeping a count.
    It also keeps track of whether its cancelable or has a key by storing the value in the
    device object extension. They are updated without a lock because its incorrect to have two parallel
    calls to IoStartNextPacket or IoStartNextPacketByKey.

Arguments:

    DeviceObject - Pointer to device object itself.

    Key - Specifics the Key used to remove the entry from the queue.

    Flags - Specifies if the deferred call has a key or is cancelable.

Return Value:

    None.

--*/
{
    IN BOOLEAN Cancelable;
    int doAnotherIteration;

    do {
            doAnotherIteration = 0;
            if (InterlockedIncrement(&(DeviceObject->DeviceObjectExtension->StartIoCount)) > 1) {
                DeviceObject->DeviceObjectExtension->StartIoFlags |= Flags;
                DeviceObject->DeviceObjectExtension->StartIoKey = Key;
            } else {
                Cancelable = Flags & DOE_STARTIO_CANCELABLE;
                DeviceObject->DeviceObjectExtension->StartIoFlags &=
                    ~(DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY|DOE_STARTIO_CANCELABLE);
                DeviceObject->DeviceObjectExtension->StartIoKey = 0;
                if (Flags & DOE_STARTIO_REQUESTED_BYKEY) {
                    IopStartNextPacketByKey(DeviceObject, Cancelable, Key);
                }else if (Flags &DOE_STARTIO_REQUESTED){
                    IopStartNextPacket(DeviceObject, Cancelable);
                }
            }
            if (InterlockedDecrement(&(DeviceObject->DeviceObjectExtension->StartIoCount)) == 0) {
                Flags = DeviceObject->DeviceObjectExtension->StartIoFlags &
                    (DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY|DOE_STARTIO_CANCELABLE);
                Key = DeviceObject->DeviceObjectExtension->StartIoKey;
                if (Flags & (DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY)) {
                    doAnotherIteration++;
                }
            }
    } while (doAnotherIteration);
}


VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable)
/*++

Routine Description:

    This routine checks the DOE flags to see if StartIO has to be deferred.
    If so it calls the appropriate function.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

Return Value:

    None.

--*/
{
    if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_DEFERRED) {
        IopStartNextPacketByKeyEx(DeviceObject, 0, DOE_STARTIO_REQUESTED|(Cancelable ? DOE_STARTIO_CANCELABLE : 0));
    } else {
        IopStartNextPacket(DeviceObject, Cancelable);
    }
}

VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG   Key)
/*++

Routine Description:

    This routine checks the DOE flags to see if StartIO has to be deferred.
    If so it calls the appropriate function.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/
{
    if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_DEFERRED) {
        IopStartNextPacketByKeyEx(DeviceObject, Key, DOE_STARTIO_REQUESTED_BYKEY|(Cancelable ? DOE_STARTIO_CANCELABLE : 0));
    } else {
        IopStartNextPacketByKey(DeviceObject, Cancelable, Key);
    }
}

VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    )
/*++

Routine Description:

    This routine checks the DOE flags to see if StartIO has to be deferred.
    If so it calls the appropriate function.

Arguments:

    DeviceObject - Pointer to device object itself.

    Irp - I/O Request Packet which should be started on the device.

    Key - Key to be used in inserting packet into device queue;  optional
        (if not specified, then packet is inserted at the tail).

    CancelFunction - Pointer to an optional cancel routine.

Return Value:

    None.

--*/
{
    int Flags;
    KIRQL oldIrql;

    if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_DEFERRED) {
        InterlockedIncrement(&DeviceObject->DeviceObjectExtension->StartIoCount);
        IopStartPacket(DeviceObject, Irp, Key, CancelFunction);
        if (InterlockedDecrement(&(DeviceObject->DeviceObjectExtension->StartIoCount)) == 0) {
            Flags = DeviceObject->DeviceObjectExtension->StartIoFlags &
                                (DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY|DOE_STARTIO_CANCELABLE);
            if (Flags & (DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY)) {
                KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
                IopStartNextPacketByKeyEx(DeviceObject,
                                          DeviceObject->DeviceObjectExtension->StartIoKey,
                                          Flags);
                KeLowerIrql( oldIrql );
            }
        }
    } else {
        IopStartPacket(DeviceObject, Irp, Key, CancelFunction);
    }
}

VOID
IoSetStartIoAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeferredStartIo,
    IN BOOLEAN NonCancelable
    )
/*++

Routine Description:

    This routine sets the StartIo attributes so that drivers can change the
    behaviour of when StartIo can be called.

Arguments:

    DeviceObject - Pointer to device object itself.

    NonCancelable - If TRUE that IRP passed to StartIo is not in the cancelable state.

    DeferredStartIo - If TRUE startIo is not called recursively and is deferred until the previous
                      StartIo call returns to the IO manager.

Return Value:

    None.

--*/
{
    if (DeferredStartIo) {
          DeviceObject->DeviceObjectExtension->StartIoFlags |= DOE_STARTIO_DEFERRED;
    }

    if (NonCancelable) {
        DeviceObject->DeviceObjectExtension->StartIoFlags |= DOE_STARTIO_NO_CANCEL;
    }
}


VOID
IoStartTimer(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine starts the timer associated with the specified device object.

Arguments:

    DeviceObject - Device object associated with the timer to be started.

Return Value:

    None.

--*/

{
    PIO_TIMER timer;
    KIRQL irql;

    //
    // Get the address of the timer.
    //

    timer = DeviceObject->Timer;

    //
    // If the driver is not being unloaded, then it is okay to start timers.
    //

    if (!(DeviceObject->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED))) {

        //
        // Likewise, check to see whether or not the timer is already
        // enabled.  If so, then simply exit.  Otherwise, enable the timer
        // by placing it into the I/O system timer queue.
        //

        ExAcquireFastLock( &IopTimerLock, &irql );
        if (!timer->TimerFlag) {
            timer->TimerFlag = TRUE;
            IopTimerCount++;
        }
        ExReleaseFastLock( &IopTimerLock, irql );
    }
}

VOID
IoStopTimer(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routines stops the timer associated with the specified device object
    from invoking being invoked.

Arguments:

    DeviceObject - Device object associated with the timer to be stopped.

Return Value:

    None.

--*/

{
    KIRQL irql;
    PIO_TIMER timer;

    //
    // Obtain the I/O system timer queue lock, and disable the specified
    // timer.
    //

    timer = DeviceObject->Timer;

    ExAcquireFastLock( &IopTimerLock, &irql );
    if (timer->TimerFlag) {
        timer->TimerFlag = FALSE;
        IopTimerCount--;
    }
    ExReleaseFastLock( &IopTimerLock, irql );
}

NTSTATUS
IoSynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine provides a special, fast interface for the Modified Page Writer
    (MPW) to write pages to the disk quickly and with very little overhead.  All
    of the special handling for this request is recognized by setting the
    IRP_PAGING_IO flag in the IRP flags word.

Arguments:

    FileObject - A pointer to a referenced file object describing which file
        the write should be performed on.

    MemoryDescriptorList - An MDL which describes the physical pages that the
        pages should be written to the disk.  All of the pages have been locked
        in memory.  The MDL also describes the length of the write operation.

    StartingOffset - Pointer to the offset in the file from which the write
        should take place.

    Event - A pointer to a kernel event structure to be used for synchronization
        purposes.  The event will be set to the Signlaged state once the pages
        have been written.

    IoStatusBlock - A pointer to the I/O status block in which the final status
        and information should be stored.

Return Value:

    The function value is the final status of the queue request to the I/O
    system subcomponents.


--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    //
    // Increment performance counters
    //

    if (CcIsFileCached(FileObject)) {
        CcDataFlushes += 1;
        CcDataPages += (MemoryDescriptorList->ByteCount + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // Begin by getting a pointer to the device object that the file resides
    // on.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate an I/O Request Packet (IRP) for this out-page operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get a pointer to the first stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP according to this request.
    //

    irp->MdlAddress = MemoryDescriptorList;
    irp->Flags = IRP_PAGING_IO | IRP_NOCACHE | IRP_SYNCHRONOUS_PAGING_IO;

    irp->RequestorMode = KernelMode;
    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;
    irp->UserBuffer = (PVOID) ((PCHAR) MemoryDescriptorList->StartVa + MemoryDescriptorList->ByteOffset);
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the normal write parameters.
    //

    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->Parameters.Write.Length = MemoryDescriptorList->ByteCount;
    irpSp->Parameters.Write.ByteOffset = *StartingOffset;
    irpSp->FileObject = FileObject;

    //
    // Queue the packet to the appropriate driver based on whether or not there
    // is a VPB associated with the device.
    //

    return IoCallDriver( deviceObject, irp );
}

PEPROCESS
IoThreadToProcess(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns a pointer to the process for the specified thread.

Arguments:

    Thread - Thread whose process is to be returned.

Return Value:

    A pointer to the thread's process.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.


--*/

{
    //
    // Simply return the thread's process.
    //

    return THREAD_TO_PROCESS( Thread );
}

VOID
IoUnregisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine removes the device object for the file system from the active
    list of file systems in the system.

Arguments:

    DeviceObject - Pointer to device object for the file system.

Return Value:

    None.


--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Acquire the I/O database resource for a write operation.
    //

    (VOID)ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Remove the device object from whatever queue it happens to be in at the
    // moment.  There is no need to check here to determine if the device queue
    // is in a queue since it is assumed that the caller registered it as a
    // valid file system.
    //

    if (DeviceObject->Queue.ListEntry.Flink != NULL) {
        RemoveEntryList( &DeviceObject->Queue.ListEntry );
    }

    //
    // Notify all of the registered drivers that this file system has been
    // unregistered as an active file system of some type.
    //

    entry = IopFsNotifyChangeQueueHead.Flink;
    while (entry != &IopFsNotifyChangeQueueHead) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        entry = entry->Flink;
        nPacket->NotificationRoutine( DeviceObject, FALSE );
    }

    IopFsRegistrationOps++;

    //
    // Release the I/O database resource.
    //

    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Decrement the number of reasons that this driver cannot be unloaded.
    //

    IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );
}

VOID
IoUnregisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    )

/*++

Routine Description:

    This routine unregisters the specified driver's notification routine from
    begin invoked whenever a file system registers or unregisters itself as an
    active file system in the system.

Arguments:

    DriverObject - Pointer to the driver object for the driver.

    DriverNotificationRoutine - Address of routine to unregister.

Return Value:

    None.

--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Begin by acquiring the database resource exclusively.
    //

    ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Walk the list of registered notification routines and unregister the
    // specified routine.
    //

    for (entry = IopFsNotifyChangeQueueHead.Flink;
        entry != &IopFsNotifyChangeQueueHead;
        entry = entry->Flink) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        if (nPacket->DriverObject == DriverObject &&
            nPacket->NotificationRoutine == DriverNotificationRoutine) {
            RemoveEntryList( entry );
            ExFreePool( nPacket );
            break;
        }
    }

    ExReleaseResourceLite( &IopDatabaseResource );

    ObDereferenceObject( DriverObject );

}

VOID
IoUnregisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine removes a registered driver from the shutdown notification
    queue.  Henceforth, the driver will not be notified when the system is
    being shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY entry;
    PSHUTDOWN_PACKET shutdown;
    KIRQL irql;

    PAGED_CODE();

    //
    // Lock this code into memory for the duration of this function's execution.
    //

    ASSERT(ExPageLockHandle);
    MmLockPagableSectionByHandle( ExPageLockHandle );

    //
    // Acquire the spinlock that protects the shutdown notification queue, and
    // walk the queue looking for the caller's entry.  Once found, remove it
    // from the queue.  It is an error to not find it, but it is ignored here.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (entry = IopNotifyShutdownQueueHead.Flink;
         entry != &IopNotifyShutdownQueueHead;
         entry = entry->Flink) {

        //
        // An entry has been located.  If it is the one that is being searched
        // for, simply remove it from the list and deallocate it.
        //

        shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );
        if (shutdown->DeviceObject == DeviceObject) {
            RemoveEntryList( entry );
            entry = entry->Blink;
            ObDereferenceObject(DeviceObject);
            ExFreePool( shutdown );
        }
    }

    for (entry = IopNotifyLastChanceShutdownQueueHead.Flink;
         entry != &IopNotifyLastChanceShutdownQueueHead;
         entry = entry->Flink) {

        //
        // An entry has been located.  If it is the one that is being searched
        // for, simply remove it from the list and deallocate it.
        //

        shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );
        if (shutdown->DeviceObject == DeviceObject) {
            RemoveEntryList( entry );
            entry = entry->Blink;
            ObDereferenceObject(DeviceObject);
            ExFreePool( shutdown );
        }
    }

    //
    // Release the spinlock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    MmUnlockPagableImageSection( ExPageLockHandle );

    DeviceObject->Flags &= ~DO_SHUTDOWN_REGISTERED;

}

VOID
IoUpdateShareAccess(
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine updates the share access context for a file according to
    the desired access and share access by the current open requestor.  The
    IoCheckShareAccess routine must already have been invoked and succeeded
    in order to invoke this routine.  Note that when the former routine was
    invoked the Update parameter must have been FALSE.

Arguments:

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes how
        the file is currently being accessed.

Return Value:

    None.

--*/

{
    BOOLEAN update = TRUE;

    PAGED_CODE();

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {

            //
            //  This fileobject is marked to ignore share access checks
            //  so we also don't want to affect the file/directory's
            //  ShareAccess structure counts.
            //

            update = FALSE;
        }
    }

    //
    // Check to see whether or not the desired accesses need read, write,
    // or delete access to the file.
    //

    if ((FileObject->ReadAccess ||
         FileObject->WriteAccess ||
         FileObject->DeleteAccess) &&
        update) {

        //
        // The open request requires read, write, or delete access so update
        // the share access context for the file.
        //

        ShareAccess->OpenCount++;

        ShareAccess->Readers += FileObject->ReadAccess;
        ShareAccess->Writers += FileObject->WriteAccess;
        ShareAccess->Deleters += FileObject->DeleteAccess;

        ShareAccess->SharedRead += FileObject->SharedRead;
        ShareAccess->SharedWrite += FileObject->SharedWrite;
        ShareAccess->SharedDelete += FileObject->SharedDelete;
    }
}


NTSTATUS
IoVerifyVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount
    )

/*++

Routine Description:

    This routine is invoked to check a mounted volume on the specified device
    when it appears as if the media may have changed since it was last
    accessed.  If the volume is not the same volume, and a new mount is not
    to be attempted, return the error.

    If the verify fails, this routine is used to perform a new mount operation
    on the device.  In this case, a "clean" VPB is allocated and a new mount
    operation is attempted.  If no mount operation succeeds, then again the
    error handling described above occurs.

Arguments:

    DeviceObject - Pointer to device object on which the volume is to be
        mounted.

    AllowRawMount - Indicates that this verify is on behalf of a DASD open
        request, thus we want to allow a raw mount if the verify fails.

Return Value:

    The function value is a successful status code if a volume was successfully
    mounted on the device.  Otherwise, an error code is returned.


--*/

{
    NTSTATUS status;
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN verifySkipped = FALSE;
    PDEVICE_OBJECT fsDeviceObject;
    PVPB    mountVpb;

    PAGED_CODE();

    //
    //  Acquire the DeviceObject lock.  Nothing in this routine can raise
    //  so no try {} finally {} is required.
    //

    status = KeWaitForSingleObject( &DeviceObject->DeviceLock,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER) NULL );

    ASSERT( status == STATUS_SUCCESS );

    //
    // If this volume is not mounted by anyone, skip the verify operation,
    // but do the mount.
    //

    if (!(DeviceObject->Vpb->Flags & VPB_MOUNTED)) {

        verifySkipped = TRUE;

        status = STATUS_SUCCESS;

    } else {

        //
        // This volume needs to be verified.  Initialize the event to be
        // used while waiting for the operation to complete.
        //

        KeInitializeEvent( &event, NotificationEvent, FALSE );
        status = STATUS_UNSUCCESSFUL;

        //
        // Allocate and initialize an IRP for this verify operation.  Notice
        // that the flags for this operation appear the same as a page read
        // operation.  This is because the completion code for both of the
        // operations is exactly the same logic.
        //

        fsDeviceObject = DeviceObject->Vpb->DeviceObject;
        while (fsDeviceObject->AttachedDevice) {
            fsDeviceObject = fsDeviceObject->AttachedDevice;
        }
        irp = IoAllocateIrp( fsDeviceObject->StackSize, FALSE );
        if (!irp) {

            KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irp->Flags = IRP_MOUNT_COMPLETION | IRP_SYNCHRONOUS_PAGING_IO;
        irp->RequestorMode = KernelMode;
        irp->UserEvent = &event;
        irp->UserIosb = &ioStatus;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = IRP_MN_VERIFY_VOLUME;
        irpSp->Flags = AllowRawMount ? SL_ALLOW_RAW_MOUNT : 0;
        irpSp->Parameters.VerifyVolume.Vpb = DeviceObject->Vpb;
        irpSp->Parameters.VerifyVolume.DeviceObject = DeviceObject->Vpb->DeviceObject;

        status = IoCallDriver( fsDeviceObject, irp );

        //          IopLoadFileSystemDriver
        // Wait for the I/O operation to complete.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = ioStatus.Status;
        }
    }

    //
    // If the verify operation was skipped or unsuccessful perform a mount
    // operation.
    //

    if ((status == STATUS_WRONG_VOLUME) || verifySkipped) {

        //
        // A mount operation is to be attempted.  Allocate a new VPB
        // for this device and attempt to mount it.  Note that at this
        // point, allowing allocation of the VPB to fail is simply too
        // difficult to deal with, so if one cannot be allocated normally,
        // allocate one specifying that it must succeed.
        //

        if (NT_SUCCESS(IopCreateVpb (DeviceObject))) {

            PoVolumeDevice (DeviceObject);

            //
            // Now mount the volume.
            //

            mountVpb = NULL;
            if (!NT_SUCCESS( IopMountVolume( DeviceObject, AllowRawMount, TRUE, FALSE, &mountVpb ) )) {
                DeviceObject->Flags &= ~DO_VERIFY_VOLUME;
            } else {
                if (mountVpb) {

                    //
                    // Decrement  the reference allocated in IopMountVolume.
                    //

                    IopInterlockedDecrementUlong( LockQueueIoVpbLock,
                                                  &mountVpb->ReferenceCount );
                }
            }
        } else {
            DeviceObject->Flags &= ~DO_VERIFY_VOLUME;
        }
    }

    //
    //  Release the device lock.
    //

    KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );

    //
    // Return the status from the verify operation as the final status of
    // this function.
    //

    return status;
}

VOID
IoWriteErrorLogEntry(
    IN OUT PVOID ElEntry
    )

/*++

Routine Description:

    This routine places the error log entry specified by the input argument
    onto the queue of buffers to be written to the error log process's port.
    The error log thread will then actually send it.

Arguments:

    ElEntry Pointer to the error log entry.

Return Value:

    None.

--*/

{
    PERROR_LOG_ENTRY entry;
    KIRQL oldIrql;

    //
    // Get the address of the error log entry header, acquire the spin lock,
    // insert the entry onto the queue, if there are no pending requests
    // then queue a worker thread request and release the spin lock.
    //

    entry = ((PERROR_LOG_ENTRY) ElEntry) - 1;

    if (IopErrorLogDisabledThisBoot) {
        //
        // Do nothing, drop the reference.
        //

        if (entry->DeviceObject != NULL) {
            //
            // IopErrorLogThread tests for NULL before derefing.
            // So do the same here.
            //
            ObDereferenceObject (entry->DeviceObject);
        }
        if (entry->DriverObject != NULL) {
            ObDereferenceObject (entry->DriverObject);
        }

        InterlockedExchangeAdd( &IopErrorLogAllocation,
                               -((LONG) (entry->Size )));
        ExFreePool (entry);
        return;

    }

    //
    // Set the time that the entry was logged.
    //

    KeQuerySystemTime( (PVOID) &entry->TimeStamp );

    ExAcquireSpinLock( &IopErrorLogLock, &oldIrql );

    //
    // Queue the request to the error log queue.
    //

    InsertTailList( &IopErrorLogListHead, &entry->ListEntry );

    //
    // If there is no pending work, then queue a request to a worker thread.
    //

    if (!IopErrorLogPortPending) {

        IopErrorLogPortPending = TRUE;

        ExInitializeWorkItem( &IopErrorLogWorkItem, IopErrorLogThread, NULL );
        ExQueueWorkItem( &IopErrorLogWorkItem, DelayedWorkQueue );

    }

    ExReleaseSpinLock(&IopErrorLogLock, oldIrql);
}

NTSTATUS
IoGetBootDiskInformation(
    IN OUT PBOOTDISK_INFORMATION BootDiskInformation,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine provides the caller with the signature and offset of
    the boot disk and system disk. This information is obtained from the
    loader block. The callers have to be boot drivers which have registered
    for a callback once all disk devices have been started
Arguments:

    BootDiskInformation - Supplies a pointer to the structure allocated by the
    caller for requested information.
    Size - Size of the BootDiskInformation structure.

Return Value:

    STATUS_SUCCESS - successful.
    STATUS_TOO_LATE - indicates that the Loader Block has already been freed
    STATUS_INVALID_PARAMETER - size allocated for boot disk information
    is insufficient.

--*/

{
    PLOADER_PARAMETER_BLOCK LoaderBlock = NULL;
    STRING arcBootDeviceString;
    UCHAR deviceNameBuffer[128];
    STRING deviceNameString;
    UNICODE_STRING deviceNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    UCHAR arcNameBuffer[128];
    STRING arcNameString;
    UNICODE_STRING arcNameUnicodeString;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    DISK_GEOMETRY diskGeometry;
    PDRIVE_LAYOUT_INFORMATION_EX driveLayout;
    PLIST_ENTRY listEntry;
    PARC_DISK_SIGNATURE diskBlock;
    ULONG diskNumber;
    ULONG partitionNumber;
    PCHAR arcName;
    PULONG buffer;
    PIRP irp;
    KEVENT event;
    LARGE_INTEGER offset;
    ULONG checkSum;
    ULONG i;
    BOOLEAN singleBiosDiskFound;
    PARC_DISK_INFORMATION arcInformation;
    ULONG totalDriverDisksFound = IoGetConfigurationInformation()->DiskCount;
    STRING arcSystemDeviceString;
    STRING osLoaderPathString;
    UNICODE_STRING osLoaderPathUnicodeString;
    PARTITION_INFORMATION_EX PartitionInfo;
    PBOOTDISK_INFORMATION_EX    bootDiskInformationEx;
    ULONG diskSignature = 0;
    PULONG  sectorBuffer;

    PAGED_CODE();

    if (IopLoaderBlock == NULL) {
        return STATUS_TOO_LATE;
    }

    if (Size < sizeof(BOOTDISK_INFORMATION)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Size < sizeof(BOOTDISK_INFORMATION_EX)) {
        bootDiskInformationEx = NULL;
    } else {
        bootDiskInformationEx = (PBOOTDISK_INFORMATION_EX)BootDiskInformation;
    }

    LoaderBlock = (PLOADER_PARAMETER_BLOCK)IopLoaderBlock;
    arcInformation = LoaderBlock->ArcDiskInformation;

    //
    // If a single bios disk was found if there is only a
    // single entry on the disk signature list.
    //
    singleBiosDiskFound = (arcInformation->DiskSignatures.Flink->Flink ==
                           &arcInformation->DiskSignatures) ? (TRUE) : (FALSE);

    //
    // Get ARC boot device name from loader block.
    //

    RtlInitAnsiString( &arcBootDeviceString,
                       LoaderBlock->ArcBootDeviceName );
    //
    // Get ARC system device name from loader block.
    //

    RtlInitAnsiString( &arcSystemDeviceString,
                       LoaderBlock->ArcHalDeviceName );
    //
    // For each disk, get its drive layout and check to see if the
    // signature is among the list of signatures in the loader block.
    // If yes, check to see if the disk contains the boot or system
    // partitions. If yes, fill up the requested structure.
    //

    for (diskNumber = 0;
         diskNumber < totalDriverDisksFound;
         diskNumber++) {

        //
        // Construct the NT name for a disk and obtain a reference.
        //

        sprintf( deviceNameBuffer,
                 "\\Device\\Harddisk%d\\Partition0",
                 diskNumber );
        RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
        status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                               &deviceNameString,
                                               TRUE );
        if (!NT_SUCCESS( status )) {
            continue;
        }

        status = IoGetDeviceObjectPointer( &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );
        RtlFreeUnicodeString( &deviceNameUnicodeString );

        if (!NT_SUCCESS( status )) {
            continue;
        }

        //
        // Create IRP for get drive geometry device control.
        //

        irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &diskGeometry,
                                             sizeof(DISK_GEOMETRY),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
        if (!irp) {
            ObDereferenceObject( fileObject );
            continue;
        }

        KeInitializeEvent( &event,
                           NotificationEvent,
                           FALSE );
        status = IoCallDriver( deviceObject,
                               irp );

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &event,
                                   Suspended,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            status = ioStatusBlock.Status;
        }

        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            continue;
        }

        //
        // Get partition information for this disk.
        //

        status = IoReadPartitionTableEx( deviceObject,
                                       &driveLayout );


        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            continue;
        }

        //
        // Make sure sector size is at least 512 bytes.
        //

        if (diskGeometry.BytesPerSector < 512) {
            diskGeometry.BytesPerSector = 512;
        }



        ObDereferenceObject( fileObject );

        //
        // For each ARC disk information record in the loader block
        // match the disk signature and checksum to determine its ARC
        // name and construct the NT ARC names symbolic links.
        //

        for (listEntry = arcInformation->DiskSignatures.Flink;
             listEntry != &arcInformation->DiskSignatures;
             listEntry = listEntry->Flink) {

            //
            // Get next record and compare disk signatures.
            //

            diskBlock = CONTAINING_RECORD( listEntry,
                                           ARC_DISK_SIGNATURE,
                                           ListEntry );

            //
            // Compare disk signatures.
            //
            // Or if there is only a single disk drive from
            // both the bios and driver viewpoints then
            // assign an arc name to that drive.
            //

            if ((singleBiosDiskFound &&
                 (totalDriverDisksFound == 1) &&
                 (driveLayout->PartitionStyle == PARTITION_STYLE_MBR)) ||
                IopVerifyDiskSignature(driveLayout, diskBlock, &diskSignature)) {

                //
                // Create unicode device name for physical disk.
                //

                sprintf( deviceNameBuffer,
                         "\\Device\\Harddisk%d\\Partition0",
                         diskNumber );
                RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
                status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                                       &deviceNameString,
                                                       TRUE );
                if (!NT_SUCCESS( status )) {
                    continue;
                }

                //
                // Create unicode ARC name for this partition.
                //

                arcName = diskBlock->ArcName;
                sprintf( arcNameBuffer,
                         "\\ArcName\\%s",
                         arcName );
                RtlInitAnsiString( &arcNameString, arcNameBuffer );
                status = RtlAnsiStringToUnicodeString( &arcNameUnicodeString,
                                                       &arcNameString,
                                                       TRUE );
                if (!NT_SUCCESS( status )) {
                    continue;
                }

                //
                // Create an ARC name for every partition on this disk.
                //

                for (partitionNumber = 0;
                     partitionNumber < driveLayout->PartitionCount;
                     partitionNumber++) {

                    //
                    // Create unicode NT device name.
                    //

                    sprintf( deviceNameBuffer,
                             "\\Device\\Harddisk%d\\Partition%d",
                             diskNumber,
                             partitionNumber+1 );
                    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
                    status = RtlAnsiStringToUnicodeString(
                                                           &deviceNameUnicodeString,
                                                           &deviceNameString,
                                                           TRUE );
                    if (!NT_SUCCESS( status )) {
                        continue;
                    }

                    //
                    // If we came through the single disk case.
                    //

                    if (diskSignature == 0) {
                        diskSignature = driveLayout->Mbr.Signature;
                    }

                    //
                    // Create unicode ARC name for this partition and
                    // check to see if this is the boot disk.
                    //

                    sprintf( arcNameBuffer,
                             "%spartition(%d)",
                             arcName,
                             partitionNumber+1 );
                    RtlInitAnsiString( &arcNameString, arcNameBuffer );
                    if (RtlEqualString( &arcNameString,
                                        &arcBootDeviceString,
                                        TRUE )) {


                        BootDiskInformation->BootDeviceSignature = diskSignature;

                        //
                        // Get Partition Information for the offset of the
                        // partition within the disk
                        //
                        status = IoGetDeviceObjectPointer(
                                           &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );
                        RtlFreeUnicodeString( &deviceNameUnicodeString );

                        if (!NT_SUCCESS( status )) {
                            continue;
                        }

                        //
                        // Create IRP for get drive geometry device control.
                        //

                        irp = IoBuildDeviceIoControlRequest(
                                             IOCTL_DISK_GET_PARTITION_INFO_EX,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &PartitionInfo,
                                             sizeof(PARTITION_INFORMATION_EX),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
                        if (!irp) {
                            ObDereferenceObject( fileObject );
                            continue;
                        }

                        KeInitializeEvent( &event,
                                           NotificationEvent,
                                           FALSE );
                        status = IoCallDriver( deviceObject,
                                               irp );

                        if (status == STATUS_PENDING) {
                            KeWaitForSingleObject( &event,
                                                   Suspended,
                                                   KernelMode,
                                                   FALSE,
                                                   NULL );
                            status = ioStatusBlock.Status;
                        }

                        if (!NT_SUCCESS( status )) {
                            ObDereferenceObject( fileObject );
                            continue;
                        }
                        BootDiskInformation->BootPartitionOffset =
                                        PartitionInfo.StartingOffset.QuadPart;

                        if (driveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->BootDeviceIsGpt = TRUE;

                                //
                                // Structure copy.
                                //

                                bootDiskInformationEx->BootDeviceGuid = driveLayout->Gpt.DiskId;
                            }
                        } else {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->BootDeviceIsGpt = FALSE;
                            }
                        }

                        ObDereferenceObject( fileObject );
                    }

                    //
                    // See if this is the system partition.
                    //
                    if (RtlEqualString( &arcNameString,
                                        &arcSystemDeviceString,
                                        TRUE )) {
                        BootDiskInformation->SystemDeviceSignature = diskSignature;
                        //
                        // Get Partition Information for the offset of the
                        // partition within the disk
                        //
                        status = IoGetDeviceObjectPointer(
                                           &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );
                        RtlFreeUnicodeString( &deviceNameUnicodeString );

                        if (!NT_SUCCESS( status )) {
                            continue;
                        }

                        //
                        // Create IRP for get drive geometry device control.
                        //

                        irp = IoBuildDeviceIoControlRequest(
                                             IOCTL_DISK_GET_PARTITION_INFO_EX,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &PartitionInfo,
                                             sizeof(PARTITION_INFORMATION_EX),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
                        if (!irp) {
                            ObDereferenceObject( fileObject );
                            continue;
                        }

                        KeInitializeEvent( &event,
                                           NotificationEvent,
                                           FALSE );
                        status = IoCallDriver( deviceObject,
                                               irp );

                        if (status == STATUS_PENDING) {
                            KeWaitForSingleObject( &event,
                                                   Suspended,
                                                   KernelMode,
                                                   FALSE,
                                                   NULL );
                            status = ioStatusBlock.Status;
                        }

                        if (!NT_SUCCESS( status )) {
                            ObDereferenceObject( fileObject );
                            continue;
                        }
                        BootDiskInformation->SystemPartitionOffset =
                                        PartitionInfo.StartingOffset.QuadPart;

                        if (driveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->SystemDeviceIsGpt = TRUE;

                                //
                                // Structure copy.
                                //

                                bootDiskInformationEx->SystemDeviceGuid = driveLayout->Gpt.DiskId;
                            }
                        } else {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->SystemDeviceIsGpt = FALSE;
                            }
                        }

                        ObDereferenceObject( fileObject );
                    }
                }
            }
        }
        ExFreePool( driveLayout );
    }
    return STATUS_SUCCESS;
}

//
// Thunks to support standard call callers
//

#ifdef IoCallDriver
#undef IoCallDriver
#endif

NTSTATUS
IoCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    return IofCallDriver (DeviceObject, Irp);
}



#ifdef IoCompleteRequest
#undef IoCompleteRequest
#endif

VOID
IoCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{
    IofCompleteRequest (Irp, PriorityBoost);
}


PSECURITY_DESCRIPTOR
IopCreateDefaultDeviceSecurityDescriptor(
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN DeviceHasName,
    IN PUCHAR Buffer,
    OUT PACL *AllocatedAcl,
    OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
    )
{
    PSECURITY_DESCRIPTOR descriptor = (PSECURITY_DESCRIPTOR) Buffer;

    NTSTATUS status;

    PAGED_CODE();

    if(ARGUMENT_PRESENT(SecurityInformation)) {
        (*SecurityInformation) = 0;
    }

    *AllocatedAcl = NULL;

    switch ( DeviceType ) {

        case FILE_DEVICE_DISK_FILE_SYSTEM:
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
        case FILE_DEVICE_FILE_SYSTEM:
        case FILE_DEVICE_TAPE_FILE_SYSTEM: {

            //
            // Use the standard public default protection for these types of devices.
            //

            RtlCreateSecurityDescriptor(descriptor,
                                        SECURITY_DESCRIPTOR_REVISION );

            RtlSetDaclSecurityDescriptor(descriptor,
                                         TRUE,
                                         SePublicDefaultUnrestrictedDacl,
                                         FALSE );

            if(ARGUMENT_PRESENT(SecurityInformation)) {
                (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
            }

            break;
        }

        case FILE_DEVICE_CD_ROM:
        case FILE_DEVICE_MASS_STORAGE:
        case FILE_DEVICE_DISK:
        case FILE_DEVICE_VIRTUAL_DISK:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
        case FILE_DEVICE_DFS_FILE_SYSTEM:
        case FILE_DEVICE_NETWORK: {

            if ((DeviceHasName) &&
                ((DeviceCharacteristics & FILE_FLOPPY_DISKETTE) != 0)) {

                status = RtlCreateSecurityDescriptor(
                            descriptor,
                            SECURITY_DESCRIPTOR_REVISION );

                ASSERT( NT_SUCCESS( status ) );

                status = RtlSetDaclSecurityDescriptor(
                            descriptor,
                            TRUE,
                            SePublicOpenUnrestrictedDacl,
                            FALSE );

                ASSERT( NT_SUCCESS( status ) );

                if(ARGUMENT_PRESENT(SecurityInformation)) {
                    (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
                }

            } else {

                UCHAR i;
                PACL acl;
                BOOLEAN aceFound;
                BOOLEAN aceFoundForCDROM;
                PACCESS_ALLOWED_ACE ace;

                //
                // Protect the device so that an administrator can run chkdsk
                // on it. This is done by making a copy of the default public
                // ACL and changing the accesses granted to the administrators
                // alias.
                //
                // The logic here is:
                //
                //      - Copy the public default dacl into another buffer
                //
                //      - Find the ACE granting ADMINISTRATORS access
                //
                //      - Change the granted access mask of that ACE to give
                //        administrators write access.
                //
                //

                acl = ExAllocatePoolWithTag(
                        PagedPool,
                        SePublicDefaultUnrestrictedDacl->AclSize,
                        'eSoI' );

                if (!acl) {
                    return NULL;
                }

                RtlCopyMemory( acl,
                               SePublicDefaultUnrestrictedDacl,
                               SePublicDefaultUnrestrictedDacl->AclSize );

                //
                // Find the Administrators ACE
                //

                aceFound = FALSE;
                aceFoundForCDROM = FALSE;

                for ( i = 0, status = RtlGetAce(acl, 0, &ace);
                      NT_SUCCESS(status);
                      i++, status = RtlGetAce(acl, i, &ace)) {

                    PSID sid;

                    sid = &(ace->SidStart);
                    if (RtlEqualSid( SeAliasAdminsSid, sid )) {
                        PACCESS_MASK mask;

                        ace->Mask |= ( GENERIC_READ |
                                       GENERIC_WRITE |
                                       GENERIC_EXECUTE );

                        aceFound = TRUE;
                    }

                    if (DeviceType == FILE_DEVICE_CD_ROM) {

                         if (RtlEqualSid( SeWorldSid, sid )) {
                             ace->Mask |= GENERIC_READ;
                             aceFoundForCDROM = TRUE;
                         }
                     }
                }

                //
                // If the ACE wasn't found, then the public default ACL has been
                // changed.  For this case, this code needs to be updated to match
                // the new public default DACL.
                //

                ASSERT(aceFound == TRUE);

                if (DeviceType == FILE_DEVICE_CD_ROM) {
                    ASSERT(aceFoundForCDROM == TRUE);
                }

                //
                // Finally, build a full security descriptor from the above DACL.
                //

                RtlCreateSecurityDescriptor( descriptor,
                                             SECURITY_DESCRIPTOR_REVISION );

                RtlSetDaclSecurityDescriptor( descriptor,
                                              TRUE,
                                              acl,
                                              FALSE );

                if(ARGUMENT_PRESENT(SecurityInformation)) {
                    (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
                }

                *AllocatedAcl = acl;
            }

            break;
        }

        default: {

            status = RtlCreateSecurityDescriptor( descriptor,
                                                  SECURITY_DESCRIPTOR_REVISION );
            ASSERT( NT_SUCCESS( status ) );

            status = RtlSetDaclSecurityDescriptor( descriptor,
                                                   TRUE,
                                                   SePublicOpenUnrestrictedDacl,
                                                   FALSE );

            if(ARGUMENT_PRESENT(SecurityInformation)) {
                (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
            }

            break;
        }
    }

    return descriptor;
}


NTSTATUS
IoGetRequestorSessionId(
    IN PIRP Irp,
    OUT PULONG pSessionId
    )

/*++

Routine Description:

    This routine returns the session ID for process that originally
    requested the specified I/O operation.

Arguments:

    Irp - Pointer to the I/O Request Packet.

    pSessionId - Pointer to the session Id which is set upon successful return.

Return Value:

    Returns STATUS_SUCCESS if the session ID was available, otherwise
    STATUS_UNSUCCESSFUL.

--*/

{
    PEPROCESS Process;

    //
    // Get the address of the process that requested the I/O operation.
    //

    if (Irp->Tail.Overlay.Thread) {
        Process = THREAD_TO_PROCESS( Irp->Tail.Overlay.Thread );
        *pSessionId = MmGetSessionId(Process);
        return(STATUS_SUCCESS);
    }

    *pSessionId = (ULONG) -1;
    return(STATUS_UNSUCCESSFUL);
}


VOID
IopUpdateOtherOperationCount(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to update the operation count for the current
    process to indicate that an I/O service other than a read or write
    has been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        IoOtherOperationCount += 1;
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->OtherOperationCount, 1);
    }
}


VOID
IopUpdateReadOperationCount(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to update the read operation count for the
    current process to indicate that the NtReadFile system service has
    been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        IoReadOperationCount += 1;
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->ReadOperationCount, 1);
    }
}


VOID
IopUpdateWriteOperationCount(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to update the write operation count for the
    current process to indicate that the NtWriteFile service other has
    been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        IoWriteOperationCount += 1;
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->WriteOperationCount, 1);
    }
}

VOID
IopUpdateOtherTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the transfer count for the current
    process for an operation other than a read or write system service.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        ExInterlockedAddLargeStatistic( &IoOtherTransferCount, TransferCount );
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->OtherTransferCount, TransferCount);
    }
}


VOID
IopUpdateReadTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the read transfer count for the
    current process.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        ExInterlockedAddLargeStatistic( &IoReadTransferCount, TransferCount );
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->ReadTransferCount, TransferCount);
    }
}

VOID
IopUpdateWriteTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the write transfer count for the
    current process.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        ExInterlockedAddLargeStatistic( &IoWriteTransferCount, TransferCount );
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->WriteTransferCount, TransferCount);
    }
}

VOID
IoCancelFileOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine is invoked by a filter driver to send a close to the
    next filesystem driver below. It's needed as part of the file open
    process. The filter driver forwards the open to the FSD and the FSD
    returns success. The filter driver then examines some stuff and
    decides that the open has to be failed. In this case it has to send
    a close to the FSD.

    We can safely assume a thread context because it has to be called only
    in the context of file open. If the file object already has a handle
    then the owner of the handle can then simply close the handle to the
    file object and we will close the file.

    This code is extracted from IopCloseFile and IopDeleteFile. So it is
    duplication of code but it prevents duplication elsewhere in other FSDs.

Arguments:

    FileObject - Points to the file that needs to be closed.

    DeviceObject - Points to the device object of the filesystem driver below
        the filter driver.

Return Value:

    None

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    KEVENT event;
    KIRQL irql;
    IO_STATUS_BLOCK ioStatusBlock;
    PVPB vpb;
    BOOLEAN referenceCountDecremented;


    //
    // Cannot call this function if a handle has already been created
    // for this file.
    //
    ASSERT(!(FileObject->Flags & FO_HANDLE_CREATED));

    if (ObReferenceObject(FileObject) > 2 || (FileObject->Flags & FO_HANDLE_CREATED)) {
        KeBugCheckEx( INVALID_CANCEL_OF_FILE_OPEN, (ULONG_PTR) FileObject, (ULONG_PTR)DeviceObject, 0, 0 );
        return;
    }

    ObDereferenceObject(FileObject);

    //
    // Initialize the local event that will be used to synchronize access
    // to the driver completing this I/O operation.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Reset the event in the file object.
    //

    KeClearEvent( &FileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this
    // operation.
    //

    irp = IopAllocateIrpMustSucceed( DeviceObject->StackSize );
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = &event;
    irp->UserIosb = &irp->IoStatus;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Flags = IRP_SYNCHRONOUS_API | IRP_CLOSE_OPERATION;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.  No
    // function-specific parameters are required for this operation.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_CLEANUP;
    irpSp->FileObject = FileObject;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Invoke the driver at its appropriate dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, irp );

    //
    // If no error was incurred, wait for the I/O operation to complete.
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      UserRequest,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
    }

    //
    // The following code tears down the IRP by hand since it may not
    // be possible for it to be completed (either because this code was
    // invoked as APC_LEVEL in the first place - or because the reference
    // count on the object cannot be incremented due to this routine
    // being invoked by the delete file procedure below).  Cleanup IRPs
    // therefore use close semantics (the close operation flag is set
    // in the IRP) so that the I/O complete request routine itself sets
    // the event to the Signaled state.
    //

    KeRaiseIrql( APC_LEVEL, &irql );
    IopDequeueThreadIrp( irp );
    KeLowerIrql( irql );

    //
    // Reuse the IRP for the next operation.
    //

    IoReuseIrp( irp , STATUS_SUCCESS);

    //
    // Reset the event in the file object.
    //

    KeClearEvent( &FileObject->Event );
    KeClearEvent(&event);

    //
    // Get a pointer to the stack location for the first driver.  This is
    // where the function codes and parameters are placed.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP, indicating that this file object is being deleted.
    //

    irpSp->MajorFunction = IRP_MJ_CLOSE;
    irpSp->FileObject = FileObject;
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = &event;
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->Flags = IRP_CLOSE_OPERATION | IRP_SYNCHRONOUS_API;

    //
    // Place this packet in the thread's I/O pending queue.
    //

    IopQueueThreadIrp( irp );

    //
    // Decrement the reference count on the VPB, if necessary.  We
    // have to do this BEFORE handing the Irp to the file system
    // because of a trick the file systems play with close, and
    // believe me, you really don't want to know what it is.
    //
    // Since there is not a error path here (close cannot fail),
    // and the file system is the only ome who can actually synchronize
    // with the actual completion of close processing, the file system
    // is the one responsible for Vpb deletion.
    //

    vpb = FileObject->Vpb;

    if (vpb && !(FileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        IopInterlockedDecrementUlong( LockQueueIoVpbLock,
                                      &vpb->ReferenceCount );

        FileObject->Flags |= FO_FILE_OPEN_CANCELLED;
    }

    //
    // Give the device driver the packet.  If this request does not work,
    // there is nothing that can be done about it.  This is unfortunate
    // because the driver may have had problems that it was about to
    // report about other operations (e.g., write behind failures, etc.)
    // that it can no longer report.  The reason is that this routine
    // is really initially invoked by NtClose, which has already closed
    // the caller's handle, and that's what the return status from close
    // indicates:  the handle has successfully been closed.
    //

    status = IoCallDriver( DeviceObject, irp );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
    }

    //
    // Perform any completion operations that need to be performed on
    // the IRP that was used for this request.  This is done here as
    // as opposed to in normal completion code because there is a race
    // condition between when this routine executes if it was invoked
    // from a special kernel APC (e.g., some IRP was just completed and
    // dereferenced this file object for the last time), and when the
    // special kernel APC because of this packet's completion executing.
    //
    // This problem is solved by not having to queue a special kernel
    // APC routine for completion of this packet.  Rather, it is treated
    // much like a synchronous paging I/O operation, except that the
    // packet is not even freed during I/O completion.  This is because
    // the packet is still in this thread's queue, and there is no way
    // to get it out except at APC_LEVEL.  Unfortunately, the part of
    // I/O completion that needs to dequeue the packet is running at
    // DISPATCH_LEVEL.
    //
    // Hence, the packet must be removed from the queue (synchronized,
    // of course), and then it must be freed.
    //

    KeRaiseIrql( APC_LEVEL, &irql );
    IopDequeueThreadIrp( irp );
    KeLowerIrql( irql );

    IoFreeIrp( irp );

}

VOID
IoRetryIrpCompletions(
    VOID
    )
/*++

Routine Description:

    This routine is called from Mm when a page fault has completed. It's
    called on the special occasion when a thread faults a page and then when
    it's waiting for the inpage to complete, an IopCompleteRequest APC fires
    and we fault the same page again (say if the user buffer falls on the
    same page).  Note the fault during the APC may be referencing the same or
    a different user virtual address but this is irrelevant - the problem lies
    in the fact that both virtual address references are to the same physical
    page and thus result in a collided fault in the Mm.

    Mm detects this case (to avoid deadlock) and returns STATUS_FAULT_COLLISION
    and the I/O manager bails out the APC after marking the Irp with the flag
    IRP_RETRY_IO_COMPLETION. Later on when Mm has decided the fault has
    progressed far enough to avoid deadlock, it calls back into this routine
    which calls IopCompleteRequest again.  The code in IopCompleteRequest is
    written in a reentrant way so that the retry knows the completion is only
    partially processed so far. We can fault in two places in IopCompleteRequest
    and in both cases if we call IopCompleteRequest again they will now work.

    This call must be called in the context of the thread that is faulting.
    This function should be called at APC_LEVEL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    KIRQL irql;
    PETHREAD thread;
    PIRP irp;
    PVOID saveAuxiliaryPointer = NULL;
    PFILE_OBJECT fileObject;


    thread = PsGetCurrentThread();

    ASSERT(KeGetCurrentIrql() == APC_LEVEL);

    //
    // Raise the IRQL so that the IrpList cannot be modified by a completion
    // APC.
    //

    header = &thread->IrpList;
    entry = thread->IrpList.Flink;

    //
    // Walk the list of pending IRPs, completing each of them.
    //

    while (header != entry) {

        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        entry = entry->Flink;

        if (irp->Flags & IRP_RETRY_IO_COMPLETION) {

            ASSERT(!(irp->Flags & IRP_CREATE_OPERATION));

            irp->Flags &= ~IRP_RETRY_IO_COMPLETION;
            fileObject = irp->Tail.Overlay.OriginalFileObject;
            IopCompleteRequest(
                    &irp->Tail.Apc,
                    NULL,
                    NULL,
                    &fileObject,
                    &saveAuxiliaryPointer);
        }
    }
}

#if defined(_WIN64)
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp OPTIONAL
    )
/*+++

Routine Description:

   This API returns TRUE if the process that originated the IRP is running a 32 bit x86
   application. If there is no IRP then a NULL can be passed to the API and that implies
   that the current process context is used to test if its running a 32 bit x86 application.
   Its assumed a NULL will be passed by drivers executing in the fast io path.

Arguments:

    IRP  OPTIONAL.

Return Value:

    None.

--*/
{
    if (Irp) {
        if (Irp->RequestorMode == UserMode) {
            PEPROCESS Process;
            Process = IoGetRequestorProcess(Irp);
            if (Process && PsGetProcessWow64Process(Process)) {
                return TRUE;
            }
        }
    } else {
        return ((ExGetPreviousMode() == UserMode) &&
                (PsGetProcessWow64Process(PsGetCurrentProcess())));
    }
    return FALSE;
}
#endif

NTSTATUS
IoAsynchronousPageRead(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
{
    return IopPageReadInternal(FileObject,
                        MemoryDescriptorList,
                        StartingOffset,
                        Event,
                        IoStatusBlock,
                        TRUE
                        );
}

NTSTATUS
IoQueryFileDosDeviceName(
    IN PFILE_OBJECT FileObject,
    OUT POBJECT_NAME_INFORMATION *ObjectNameInformation
    )

/*++

Routine Description:

    Thin shell around IopQueryNameInternal that returns a dos device name
    for a file e.g c:\foo

Arguments:

    FileObject - Points to the file that needs to be closed.

    ObjectNameInformation - structure to return name in note this will be a flat
      unicode string where the buffer is adjancent to the string

    RetLength - returned length of structure

Return Value:

    None

--*/

{
    ULONG ObjectNameInfoLength;
    POBJECT_NAME_INFORMATION ObjectNameInfo;
    NTSTATUS Status;

    //
    //  Allocate an initial buffer to query the filename, query, then
    //  retry if needed with the correct length.
    //

    ObjectNameInfoLength = 96*sizeof(WCHAR) + sizeof(UNICODE_STRING);

    while (TRUE) {

        ObjectNameInfo = ExAllocatePoolWithTag( PagedPool, ObjectNameInfoLength, 'nDoI');

        if (ObjectNameInfo == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        Status = IopQueryNameInternal( FileObject,
                                       TRUE,
                                       TRUE,
                                       ObjectNameInfo,
                                       ObjectNameInfoLength,
                                       &ObjectNameInfoLength );

        if (Status == STATUS_SUCCESS) {
            *ObjectNameInformation = ObjectNameInfo;
            break;
        }

        ExFreePool( ObjectNameInfo );

        if (Status != STATUS_BUFFER_OVERFLOW) {
            break;
        }
    }

    return Status;
}


NTSTATUS
IopUnloadSafeCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_UNLOAD_SAFE_COMPLETION_CONTEXT Usc = Context;
    NTSTATUS Status;

    ObReferenceObject (Usc->DeviceObject);

    Status = Usc->CompletionRoutine (DeviceObject, Irp, Usc->Context);

    ObDereferenceObject (Usc->DeviceObject);
    ExFreePool (Usc);
    return Status;
}


NTSTATUS
IoSetCompletionRoutineEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN InvokeOnSuccess,
    IN BOOLEAN InvokeOnError,
    IN BOOLEAN InvokeOnCancel
    )
//++
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver. This routine obtains a reference count to the specified device object
//     to protect the completion routine from unload problems.
//
// Arguments:
//
//     DeviceObject - Device object to take references on.
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--
{
    PIO_UNLOAD_SAFE_COMPLETION_CONTEXT Usc;

    Usc = ExAllocatePoolWithTag (NonPagedPool, sizeof (*Usc), 'sUoI');
    if (Usc == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Usc->DeviceObject      = DeviceObject;
    Usc->CompletionRoutine = CompletionRoutine;
    Usc->Context           = Context;
    IoSetCompletionRoutine (Irp, IopUnloadSafeCompletion, Usc, InvokeOnSuccess, InvokeOnError, InvokeOnCancel);
    return STATUS_SUCCESS;
}

NTSTATUS
IoCreateDriver(
    IN PUNICODE_STRING DriverName    OPTIONAL,
    IN PDRIVER_INITIALIZE InitializationFunction
    )
/*++

Routine Description:

    This routine creates a driver object for a kernel component that
    was not loaded as a driver.  If the creation of the driver object
    succeeds, Initialization function is invoked with the same parameters
    as passed to DriverEntry.

Parameters:

    DriverName - Supplies the name of the driver for which a driver object
                 is to be created.

    InitializationFunction - Equivalent to DriverEntry().

ReturnValue:

    Status code that indicates whether or not the function was successful.

Notes:

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    PDRIVER_OBJECT driverObject;
    HANDLE driverHandle;
    ULONG objectSize;
    USHORT length;
    UNICODE_STRING driverName, serviceName;
    WCHAR buffer[60];
    ULONG i;

    PAGED_CODE();

    if (DriverName == NULL) {

        //
        // Madeup a name for the driver object.
        //

        length = (USHORT) _snwprintf(buffer, sizeof(buffer) / sizeof(WCHAR), L"\\Driver\\%08u", KeTickCount);
        driverName.Length = length * sizeof(WCHAR);
        driverName.MaximumLength = driverName.Length + sizeof(UNICODE_NULL);
        driverName.Buffer = buffer;                                                           \
    } else {
        driverName = *DriverName;
    }

    //
    // Attempt to create the driver object
    //

    InitializeObjectAttributes( &objectAttributes,
                                &driverName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    objectSize = sizeof( DRIVER_OBJECT ) + sizeof( DRIVER_EXTENSION );
    status = ObCreateObject( KernelMode,
                             IoDriverObjectType,
                             &objectAttributes,
                             KernelMode,
                             NULL,
                             objectSize,
                             0,
                             0,
                             &driverObject );

    if( !NT_SUCCESS( status )){

        //
        // Driver object creation failed
        //

        return status;
    }

    //
    // We've created a driver object, initialize it.
    //

    RtlZeroMemory( driverObject, objectSize );
    driverObject->DriverExtension = (PDRIVER_EXTENSION)(driverObject + 1);
    driverObject->DriverExtension->DriverObject = driverObject;
    driverObject->Type = IO_TYPE_DRIVER;
    driverObject->Size = sizeof( DRIVER_OBJECT );
    driverObject->Flags = DRVO_BUILTIN_DRIVER;
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
        driverObject->MajorFunction[i] = IopInvalidDeviceRequest;
    driverObject->DriverInit = InitializationFunction;

    serviceName.Buffer = (PWSTR)ExAllocatePool(PagedPool, driverName.Length + sizeof(WCHAR));
    if (serviceName.Buffer) {
        serviceName.MaximumLength = driverName.Length + sizeof(WCHAR);
        serviceName.Length = driverName.Length;
        RtlCopyMemory(serviceName.Buffer, driverName.Buffer, driverName.Length);
        serviceName.Buffer[serviceName.Length / sizeof(WCHAR)] = UNICODE_NULL;
        driverObject->DriverExtension->ServiceKeyName = serviceName;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto errorFreeDriverObject;
    }

    //
    // Insert it into the object table.
    //

    status = ObInsertObject( driverObject,
                             NULL,
                             FILE_READ_DATA,
                             0,
                             NULL,
                             &driverHandle );

    if( !NT_SUCCESS( status )){

        //
        // Couldn't insert the driver object into the table.
        // The object got dereferenced by the object manager. Just exit
        //

        goto errorReturn;
    }

    //
    // Reference the handle and obtain a pointer to the driver object so that
    // the handle can be deleted without the object going away.
    //

    status = ObReferenceObjectByHandle( driverHandle,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode,
                                        (PVOID *) &driverObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );
    if( !NT_SUCCESS( status )) {
       //
       // Backout here is probably bogus. If the ref didn't work then the handle is probably bad
       // Do this right though just in case there are other common error returns for ObRef...
       //
       ZwMakeTemporaryObject( driverHandle ); // Cause handle close to free the object
       ZwClose( driverHandle ); // Close the handle.
       goto errorReturn;
    }

    ZwClose( driverHandle );

    //
    // Store the name of the device driver in the driver object so that it
    // can be easily found by the error log thread.
    //

    driverObject->DriverName.Buffer = ExAllocatePool( PagedPool,
                                                      driverName.MaximumLength );
    if (driverObject->DriverName.Buffer) {
        driverObject->DriverName.MaximumLength = driverName.MaximumLength;
        driverObject->DriverName.Length = driverName.Length;

        RtlCopyMemory( driverObject->DriverName.Buffer,
                       driverName.Buffer,
                       driverName.MaximumLength );
    }

    //
    // Call the driver initialization routine
    //

    status = (*InitializationFunction)(driverObject, NULL);

    if( !NT_SUCCESS( status )){

errorFreeDriverObject:

        //
        // If we were unsuccessful, we need to get rid of the driverObject
        // that we created.
        //

        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
    }
errorReturn:
    return status;
}

VOID
IoDeleteDriver(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine deletes a driver object created explicitly through
    IoCreateDriver.

Parameters:

    DriverObject - Supplies a pointer to the driver object to be deleted.

ReturnValue:

    Status code that indicates whether or not the function was successful.

Notes:

--*/
{

    ObDereferenceObject(DriverObject);
}

PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This routine gets the next lower device object on the device stack.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose next device object needs
                    to be obtained.

ReturnValue:

    NULL if driver is unloaded or marked for unload or if there is no attached deviceobject.
    Otherwise a referenced pointer to the deviceobject is returned.

Notes:

--*/
{
    KIRQL   irql;
    PDEVICE_OBJECT  targetDeviceObject;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if ((DeviceObject->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED))) {

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
        return NULL;
    }

    targetDeviceObject = NULL;
    if (DeviceObject->DeviceObjectExtension->AttachedTo) {
        targetDeviceObject = DeviceObject->DeviceObjectExtension->AttachedTo;
        ObReferenceObject(targetDeviceObject);
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return targetDeviceObject;
}

NTSTATUS
IoEnumerateDeviceObjectList(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  *DeviceObjectList,
    IN  ULONG           DeviceObjectListSize,
    OUT PULONG          ActualNumberDeviceObjects
    )
/*++

Routine Description:

    This routine gets the next lower device object on the device stack.

Parameters:

    DriverObject - Driver Object whose device objects have to be enumerated.

    DeviceObjectList - Pointer to an array where device object lists will be stored.

    DeviceObjectListSize - Size in bytes of the DeviceObjectList array

    ActualNumberDeviceObjects - The actual number of device objects in a driver object.

ReturnValue:

    If size is not sufficient it will return STATUS_BUFFER_TOO_SMALL.

Notes:

--*/
{
    KIRQL   irql;
    PDEVICE_OBJECT  deviceObject;
    ULONG   numListEntries;
    ULONG   numDeviceObjects = 0;
    NTSTATUS status = STATUS_SUCCESS;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    deviceObject = DriverObject->DeviceObject;

    numListEntries = DeviceObjectListSize / sizeof(PDEVICE_OBJECT);

    while (deviceObject) {
        numDeviceObjects++;
        deviceObject = deviceObject->NextDevice;
    }

    *ActualNumberDeviceObjects = numDeviceObjects;

    if (numDeviceObjects > numListEntries) {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    deviceObject = DriverObject->DeviceObject;

    while ((numListEntries > 0) && deviceObject) {
        ObReferenceObject(deviceObject);
        *DeviceObjectList = deviceObject;
        DeviceObjectList++;
        deviceObject = deviceObject->NextDevice;
        numListEntries--;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return status;
}

PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine returns the lowest level device object associated with
    the specified device.

Arguments:

    DeviceObject - Supplies a pointer to the device for which the bottom of
        attachment chain is to be found.

Return Value:

    The function value is a reference to the lowest level device attached
    to the specified device.  If the supplied device object is that device
    object, then a pointer to it is returned.

    A reference is taken on the returned device object.  It is the
    responsibility of the caller to release it.

--*/

{
    PDEVICE_OBJECT baseDeviceObject;
    KIRQL irql;

    //
    // Any examination of attachment chain linkage must be done with
    // IopDatabaseLock taken.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    //
    // Find the base of the attachment chain.
    //

    baseDeviceObject = IopGetDeviceAttachmentBase( DeviceObject );

    //
    // Reference the device object before releasing the database lock.
    //

    ObReferenceObject( baseDeviceObject );
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return baseDeviceObject;
}

NTSTATUS
IoGetDiskDeviceObject(
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    )
/*++

Routine Description:

    This routine returns the disk device object associated with a filesystem
    volume device object. The disk device object need not be an actual disk but
    in general associated with storage.

Arguments:

    FileSystemDeviceObject - Supplies a pointer to the device for which the bottom of
        attachment chain is to be found.
    DiskDeviceObject     - Supplies storage for the return value.

Return Value:

    The function returns the disk device object associated with a filesystem
    device object. Returns a referenced device object. If the VPB reference count
    is zero we cannot rely on the device object pointer.

--*/
{
    KIRQL   irql;
    PVPB    vpb;

    //
    // Filesystem deviceobject's VPB field should be NULL
    //

    if (FileSystemDeviceObject->Vpb) {
        return STATUS_INVALID_PARAMETER;
    }

    IoAcquireVpbSpinLock(&irql);

    vpb = FileSystemDeviceObject->DeviceObjectExtension->Vpb;

    if (!vpb) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_INVALID_PARAMETER;
    }

    if (vpb->ReferenceCount == 0) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_VOLUME_DISMOUNTED;
    }

    if (!(vpb->Flags & VPB_MOUNTED)) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_VOLUME_DISMOUNTED;
    }

    *DiskDeviceObject = vpb->RealDevice;
    ObReferenceObject( *DiskDeviceObject);
    IoReleaseVpbSpinLock(irql);

    return STATUS_SUCCESS;
}

NTSTATUS
IoSetSystemPartition(
    PUNICODE_STRING VolumeNameString
    )
/*++

Routine Description:

    This routine sets system partition regisry key to the volume name string. Used
    by the mount manager in case volume name changes.

Arguments:

    VolumeNameString - Name of the volume that is the system partition.

Return Value:

    NTSTATUS

--*/
{
    HANDLE systemHandle, setupHandle;
    UNICODE_STRING nameString, volumeNameString, machineSystemName;
    NTSTATUS    status;

    //
    // Declare a unicode buffer big enough to contain the longest string we'll be using.
    // (ANSI string in 'sizeof()' below on purpose--we want the number of chars here.)
    //
    WCHAR nameBuffer[sizeof("SystemPartition")];

    //
    // Open HKLM\SYSTEM key.
    //

    RtlInitUnicodeString(&machineSystemName, L"\\REGISTRY\\MACHINE\\SYSTEM");
    status = IopOpenRegistryKeyEx( &systemHandle,
                                   NULL,
                                   &machineSystemName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Now open/create the setup subkey.
    //

    ASSERT( sizeof(L"Setup") <= sizeof(nameBuffer) );

    nameBuffer[0] = L'S';
    nameBuffer[1] = L'e';
    nameBuffer[2] = L't';
    nameBuffer[3] = L'u';
    nameBuffer[4] = L'p';
    nameBuffer[5] = L'\0';

    nameString.MaximumLength = sizeof(L"Setup");
    nameString.Length        = sizeof(L"Setup") - sizeof(WCHAR);
    nameString.Buffer        = nameBuffer;

    status = IopCreateRegistryKeyEx( &setupHandle,
                                     systemHandle,
                                     &nameString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    NtClose(systemHandle);  // Don't need the handle to the HKLM\System key anymore.

    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT( sizeof(L"SystemPartition") <= sizeof(nameBuffer) );

    nameBuffer[0]  = L'S';
    nameBuffer[1]  = L'y';
    nameBuffer[2]  = L's';
    nameBuffer[3]  = L't';
    nameBuffer[4]  = L'e';
    nameBuffer[5]  = L'm';
    nameBuffer[6]  = L'P';
    nameBuffer[7]  = L'a';
    nameBuffer[8]  = L'r';
    nameBuffer[9]  = L't';
    nameBuffer[10] = L'i';
    nameBuffer[11] = L't';
    nameBuffer[12] = L'i';
    nameBuffer[13] = L'o';
    nameBuffer[14] = L'n';
    nameBuffer[15] = L'\0';

    nameString.MaximumLength = sizeof(L"SystemPartition");
    nameString.Length        = sizeof(L"SystemPartition") - sizeof(WCHAR);



    status = ZwSetValueKey(setupHandle,
                            &nameString,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            VolumeNameString->Buffer,
                            VolumeNameString->Length + sizeof(WCHAR)
                           );


    return status;
}


BOOLEAN
IoIsFileOriginRemote(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns the origin of the original create request for the
    specified file.  That is, was it created locally on this machine or remotely
    on another machine via a network provider.

Arguments:

    FileObject - Supplies the file object that is to be checked.

Return Value:

    TRUE - Means the create request originated on a remote machine.

    FALSE - Means the create request originated on the local machine.

--*/

{
    BOOLEAN Remote;


    //
    //  Check the origin flag and return the appropriate result.
    //

    if (FileObject->Flags & FO_REMOTE_ORIGIN) {

        Remote = TRUE;

    } else {

        Remote = FALSE;
    }

    return Remote;
}

NTSTATUS
IoSetFileOrigin(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Remote
    )

/*++

Routine Description:

    This routine sets the origin of the original create request for the
    specified file.  That is, was it created locally on this machine or remotely
    on another machine via a network provider.  By default file objects are
    considered to have a local origin.  Network providers should call this
    function in their server for any file objects that were created to satisfy
    a create request from their client.

Arguments:

    FileObject - Supplies the file object that is to be set.

    Remote - Supplies whether the file object is for a remote create request or not.

Return Value:

    Returns STATUS_SUCCESS unless the origin is already set to what the caller is requesting.

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER_MIX;


    //
    //  Set or clear the origin flag per the callers request.
    //

    if (Remote) {

        if ((FileObject->Flags & FO_REMOTE_ORIGIN) == 0) {

            FileObject->Flags |= FO_REMOTE_ORIGIN;
            Status = STATUS_SUCCESS;
        }

    } else {

        if (FileObject->Flags & FO_REMOTE_ORIGIN) {

            FileObject->Flags &= ~FO_REMOTE_ORIGIN;
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}


PVOID
IoGetFileObjectFilterContext(
    IN  PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    This routine returns the filter context associated with a fileobject that has an extension.

Arguments:

    FileObject  - FileObject for which the filter context is retrieved

Return Value:

    NTSTATUS

--*/
{
    PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);
        return (fileObjectExtension->FilterContext);
    }
    return NULL;
}


NTSTATUS
IoChangeFileObjectFilterContext(
    IN  PFILE_OBJECT    FileObject,
    IN  PVOID           FilterContext,
    IN  BOOLEAN         Set
    )
/*++

Routine Description:

    This routine set or clear fileobject filter context. It can be set only once.

Arguments:

    FileObject  - FileObject for which the filter context is retrieved
    FilterContext - New Filter context to be set in the fileobject extension
    Set - If TRUE allows FilterContext to be set in the fileobject only if the old value is NULL
          If FALSE allows fileObject field to be cleared only if FileContext is the old value in the fileobject.

Return Value:

    Returns NTSTATUS

--*/
{
    PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);
        if (Set) {
            if (InterlockedCompareExchangePointer(&fileObjectExtension->FilterContext, FilterContext, NULL) != NULL)
                return STATUS_ALREADY_COMMITTED;
            return STATUS_SUCCESS;
        } else {
            if (InterlockedCompareExchangePointer(&fileObjectExtension->FilterContext, NULL, FilterContext) != FilterContext)
                return STATUS_ALREADY_COMMITTED;
            return STATUS_SUCCESS;
        }
    }
    return STATUS_INVALID_PARAMETER;
}


BOOLEAN
IoIsDeviceEjectable(
    IN  PDEVICE_OBJECT DeviceObject
    )
{
    if ((FILE_FLOPPY_DISKETTE & DeviceObject->Characteristics)
            || (InitWinPEModeType & INIT_WINPEMODE_INRAM)) {

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
IoValidateDeviceIoControlAccess(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    )
/*++

Routine Description:

    This routine validates ioctl access bits based on granted access information passed in the IRP.
    This routine is called by a driver to validate IOCTL access bits for IOCTLs that were originally
    defined as FILE_ANY_ACCESS and cannot be changed for compatibility reasons but really has to be 
    validated for read/write access.
   

Arguments:

    IRP  - IRP for the device control
    RequiredAccess - Is the expected access required by the driver. Should be FILE_READ_ACCESS, FILE_WRITE_ACCESS
    or both.

Return Value:

    Returns NTSTATUS

--*/
{
    ACCESS_MASK         grantedAccess;
    PIO_STACK_LOCATION  irpSp;

    //
    // Validate RequiredAccess.
    //

    if (RequiredAccess & (FILE_READ_ACCESS|FILE_WRITE_ACCESS)){

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // If the driver passes the wrong IRP fail the API.
        //

        if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) &&
            (irpSp->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL)) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Kernel mode IRPs always succeed.
        //

        if (Irp->RequestorMode == KernelMode) {
            return STATUS_SUCCESS;
        }

        //
        // Get the granted access bits from the IRP.
        //

        grantedAccess = (irpSp->Flags & SL_READ_ACCESS_GRANTED) ? FILE_READ_DATA : 0;
        grantedAccess |= (irpSp->Flags & SL_WRITE_ACCESS_GRANTED) ? FILE_WRITE_DATA : 0;

        if (SeComputeGrantedAccesses ( grantedAccess, RequiredAccess ) != RequiredAccess ) {
            return STATUS_ACCESS_DENIED;
        } else {
            return STATUS_SUCCESS;
        }

    } else {
        return STATUS_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\ioverifier.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

   ioverifier.c

Abstract:

    This module contains the routines to verify suspect drivers.

Author:

    Narayanan Ganapathy (narg) 8-Jan-1999

Revision History:

    Adrian J. Oney (AdriaO) 28-Feb-1999
        - merge in special irp code.

--*/

#include "iomgr.h"
#include "malloc.h"
#include "..\verifier\vfdeadlock.h"

#if (( defined(_X86_) ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif


#define IO_FREE_IRP_TYPE_INVALID                1
#define IO_FREE_IRP_NOT_ASSOCIATED_WITH_THREAD  2
#define IO_CALL_DRIVER_IRP_TYPE_INVALID         3
#define IO_CALL_DRIVER_INVALID_DEVICE_OBJECT    4
#define IO_CALL_DRIVER_IRQL_NOT_EQUAL           5
#define IO_COMPLETE_REQUEST_INVALID_STATUS      6
#define IO_COMPLETE_REQUEST_CANCEL_ROUTINE_SET  7
#define IO_BUILD_FSD_REQUEST_EXCEPTION          8
#define IO_BUILD_IOCTL_REQUEST_EXCEPTION        9
#define IO_REINITIALIZING_TIMER_OBJECT          10
#define IO_INVALID_HANDLE                       11
#define IO_INVALID_STACK_IOSB                   12
#define IO_INVALID_STACK_EVENT                  13
#define IO_COMPLETE_REQUEST_INVALID_IRQL        14

//
// 0x200 and up are defined in ioassert.c
//


#ifdef  IOV_KD_PRINT
#define IovpKdPrint(x)  KdPrint(x)
#else
#define IovpKdPrint(x)
#endif

BOOLEAN
IovpValidateDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );
VOID
IovFreeIrpPrivate(
    IN  PIRP    Irp
    );

NTSTATUS
IovpUnloadDriver(
    PDRIVER_OBJECT  DriverObject
    );

BOOLEAN
IovpBuildDriverObjectList(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG HandleCount,
    IN ULONG PointerCount,
    IN PVOID Parameter
    );

NTSTATUS
IovpLocalCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


typedef struct _IOV_COMPLETION_CONTEXT {
    PIO_STACK_LOCATION StackPointer;
    PVOID               IrpContext;
    PVOID               GlobalContext;
    PIO_COMPLETION_ROUTINE CompletionRoutine;
    IO_STACK_LOCATION  OldStackContents;
} IOV_COMPLETION_CONTEXT, *PIOV_COMPLETION_CONTEXT;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IoVerifierInit)
#pragma alloc_text(PAGEVRFY,IovAllocateIrp)
#pragma alloc_text(PAGEVRFY,IovFreeIrp)
#pragma alloc_text(PAGEVRFY,IovCallDriver)
#pragma alloc_text(PAGEVRFY,IovCompleteRequest)
#pragma alloc_text(PAGEVRFY,IovpValidateDeviceObject)
#pragma alloc_text(PAGEVRFY,IovFreeIrpPrivate)
#pragma alloc_text(PAGEVRFY,IovUnloadDrivers)
#pragma alloc_text(PAGEVRFY,IovpUnloadDriver)
#pragma alloc_text(PAGEVRFY,IovBuildDeviceIoControlRequest)
#pragma alloc_text(PAGEVRFY,IovBuildAsynchronousFsdRequest)
#pragma alloc_text(PAGEVRFY,IovpCompleteRequest)
#pragma alloc_text(PAGEVRFY,IovpBuildDriverObjectList)
#pragma alloc_text(PAGEVRFY,IovInitializeIrp)
#pragma alloc_text(PAGEVRFY,IovCancelIrp)
#pragma alloc_text(PAGEVRFY,IovAttachDeviceToDeviceStack)
#pragma alloc_text(PAGEVRFY,IovInitializeTimer)
#pragma alloc_text(PAGEVRFY,IovDetachDevice)
#pragma alloc_text(PAGEVRFY,IovDeleteDevice)
#pragma alloc_text(PAGEVRFY,IovpLocalCompletionRoutine)
#endif

BOOLEAN         IopVerifierOn = FALSE;
ULONG           IovpVerifierLevel = (ULONG)0;
LONG            IovpInitCalled = 0;
ULONG           IovpVerifierFlags = 0;               // Stashes the verifier flags passed at init.

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif
BOOLEAN         IoVerifierOnByDefault = TRUE;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

VOID
IoVerifierInit(
    IN ULONG VerifierFlags
    )
{
    IovpVerifierLevel = 2;

    if (IoVerifierOnByDefault) {
        VerifierFlags |= DRIVER_VERIFIER_IO_CHECKING;
    }

    VfInitVerifier(VerifierFlags);

    if (!VerifierFlags) {
        return;
    }

    pIoAllocateIrp = IovAllocateIrp;

    if (!(VerifierFlags & DRIVER_VERIFIER_IO_CHECKING)) {

        if (!(VerifierFlags & DRIVER_VERIFIER_DEADLOCK_DETECTION) &&
            !(VerifierFlags & DRIVER_VERIFIER_DMA_VERIFIER)) {

            return;

        } else {

            //
            // If deadlock or DMA verifier are on we need to let the function
            // continue to install the hooks but we will set the
            // I/O verifier level to minimal checks.
            //
            IovpVerifierLevel = 0;
        }
    }

    //
    // Enable and hook in the verifier.
    //
    IopVerifierOn = TRUE;
    IovpInitCalled = 1;
    IovpVerifierFlags = VerifierFlags;

    //
    // Initialize the special IRP code as appropriate.
    //
    InterlockedExchangePointer((PVOID *)&pIofCallDriver, (PVOID) IovCallDriver);
    InterlockedExchangePointer((PVOID *)&pIofCompleteRequest, (PVOID) IovCompleteRequest);
    InterlockedExchangePointer((PVOID *)&pIoFreeIrp, (PVOID) IovFreeIrpPrivate);

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);
}


BOOLEAN
IovpValidateDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    if ((DeviceObject->Type != IO_TYPE_DEVICE) ||
        (DeviceObject->DriverObject == NULL) ||
        (DeviceObject->ReferenceCount < 0 )) {
        return FALSE;
    } else {
        return TRUE;
    }
}

VOID
IovFreeIrp(
    IN  PIRP    Irp
    )
{
    IovFreeIrpPrivate(Irp);
}

VOID
IovFreeIrpPrivate(
    IN  PIRP    Irp
    )
{
    BOOLEAN freeHandled ;

    if (IopVerifierOn) {
        if (Irp->Type != IO_TYPE_IRP) {
            KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                         IO_FREE_IRP_TYPE_INVALID,
                         (ULONG_PTR)Irp,
                         0,
                         0);
        }
        if (!IsListEmpty(&(Irp)->ThreadListEntry)) {
            KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                         IO_FREE_IRP_NOT_ASSOCIATED_WITH_THREAD,
                         (ULONG_PTR)Irp,
                         0,
                         0);
        }
    }

    VerifierIoFreeIrp(Irp, &freeHandled);

    if (freeHandled) {

       return;
    }

    IopFreeIrp(Irp);
}

NTSTATUS
FASTCALL
IovCallDriver(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )
{
    KIRQL    saveIrql;
    NTSTATUS status;
    PIOFCALLDRIVER_STACKDATA iofCallDriverStackData;
    BOOLEAN pagingIrp;

    if (!IopVerifierOn) {

        return IopfCallDriver(DeviceObject, Irp);
    }

    if (Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_CALL_DRIVER_IRP_TYPE_INVALID,
                     (ULONG_PTR)Irp,
                     0,
                     0);
    }
    if (!IovpValidateDeviceObject(DeviceObject)) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_CALL_DRIVER_INVALID_DEVICE_OBJECT,
                     (ULONG_PTR)DeviceObject,
                     0,
                     0);
    }

    saveIrql = KeGetCurrentIrql();

    //
    // Deadlock verifier functions are called before and after the
    // real IoCallDriver() call. If deadlock verifier is not enabled
    // this functions will return immediately.
    //
    pagingIrp = VfDeadlockBeforeCallDriver(DeviceObject, Irp);

    //
    // VfIrpCallDriverPreprocess is a macro function that may do an alloca as
    // part of it's operation. As such callers must be careful not to use
    // variable lengthed arrays in a scope that encompasses
    // VfIrpCallDriverPreProcess but not VfIrpCallDriverPostProcess.
    //
    VfIrpCallDriverPreProcess(DeviceObject, &Irp, &iofCallDriverStackData);

    VfStackSeedStack(0xFFFFFFFF);

    status = IopfCallDriver(DeviceObject, Irp);

    VfIrpCallDriverPostProcess(DeviceObject, &status, iofCallDriverStackData);

    VfDeadlockAfterCallDriver(DeviceObject, Irp, pagingIrp);

    if (saveIrql != KeGetCurrentIrql()) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_CALL_DRIVER_IRQL_NOT_EQUAL,
                     (ULONG_PTR)DeviceObject,
                     saveIrql,
                     KeGetCurrentIrql());

    }

    return status;
}




//
// Wrapper for IovAllocateIrp. Use special pool to allocate the IRP.
// This is directly called from IoAllocateIrp.
//
PIRP
IovAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    )
{
    USHORT allocateSize;
    UCHAR fixedSize;
    PIRP irp;
    USHORT packetSize;

    //
    // Should we override normal lookaside caching so that we may catch
    // more bugs?
    //
    VerifierIoAllocateIrp1(StackSize, ChargeQuota, &irp);

    if (irp) {

       return irp;
    }

    //
    // If special pool is not turned on lets just call the standard
    // irp allocator.
    //

    if (!(IovpVerifierFlags & DRIVER_VERIFIER_SPECIAL_POOLING )) {
        irp = IopAllocateIrpPrivate(StackSize, ChargeQuota);
        return irp;
    }


    irp = NULL;
    fixedSize = 0;
    packetSize = IoSizeOfIrp(StackSize);
    allocateSize = packetSize;

    //
    // There are no free packets on the lookaside list, or the packet is
    // too large to be allocated from one of the lists, so it must be
    // allocated from nonpaged pool. If quota is to be charged, charge it
    // against the current process. Otherwise, allocate the pool normally.
    //

    if (ChargeQuota) {
        try {
            irp = ExAllocatePoolWithTagPriority(
                    NonPagedPool,
                    allocateSize,
                    ' prI',
                    HighPoolPrioritySpecialPoolOverrun);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }

    } else {

        //
        // Attempt to allocate the pool from non-paged pool.  If this
        // fails, and the caller's previous mode was kernel then allocate
        // the pool as must succeed.
        //

        irp = ExAllocatePoolWithTagPriority(
                NonPagedPool,
                allocateSize,
                ' prI',
                HighPoolPrioritySpecialPoolOverrun);
    }

    if (!irp) {
        return NULL;
    }

    //
    // Initialize the packet.
    //

    IopInitializeIrp(irp, packetSize, StackSize);
    if (ChargeQuota) {
        irp->AllocationFlags |= IRP_QUOTA_CHARGED;
    }

    VerifierIoAllocateIrp2(irp);
    return irp;
}

PIRP
IovBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    )
{
    PIRP    Irp;

    try {
        Irp = IoBuildAsynchronousFsdRequest(
            MajorFunction,
            DeviceObject,
            Buffer,
            Length,
            StartingOffset,
            IoStatusBlock
            );
    } except(EXCEPTION_EXECUTE_HANDLER) {
         KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                      IO_BUILD_FSD_REQUEST_EXCEPTION,
                      (ULONG_PTR)DeviceObject,
                      (ULONG_PTR)MajorFunction,
                      GetExceptionCode());
    }
    return (Irp);
}

PIRP
IovBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
{
    PIRP    Irp;

    try {
        Irp = IoBuildDeviceIoControlRequest(
            IoControlCode,
            DeviceObject,
            InputBuffer,
            InputBufferLength,
            OutputBuffer,
            OutputBufferLength,
            InternalDeviceIoControl,
            Event,
            IoStatusBlock
            );
    } except(EXCEPTION_EXECUTE_HANDLER) {
         KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                      IO_BUILD_IOCTL_REQUEST_EXCEPTION,
                      (ULONG_PTR)DeviceObject,
                      (ULONG_PTR)IoControlCode,
                      GetExceptionCode());
    }

    return (Irp);
}

NTSTATUS
IovInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    )
{
   if (DeviceObject->Timer) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_REINITIALIZING_TIMER_OBJECT,
                     (ULONG_PTR)DeviceObject,
                     0,
                     0);
   }
   return (IoInitializeTimer(DeviceObject, TimerRoutine, Context));
}


VOID
IovpCompleteRequest(
    IN PKAPC Apc,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
{
    PIRP    irp;
    PUCHAR addr;
    ULONG   BestStackOffset;

    irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc );

#if defined(_X86_)


    addr = (PUCHAR)irp->UserIosb;
    if ((addr > (PUCHAR)KeGetCurrentThread()->StackLimit) &&
        (addr <= (PUCHAR)&BestStackOffset)) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_INVALID_STACK_IOSB,
                     (ULONG_PTR)addr,
                     0,
                     0);

    }

    addr = (PUCHAR)irp->UserEvent;
    if ((addr > (PUCHAR)KeGetCurrentThread()->StackLimit) &&
        (addr <= (PUCHAR)&BestStackOffset)) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_INVALID_STACK_EVENT,
                     (ULONG_PTR)addr,
                     0,
                     0);

    }
#endif
}


/*-------------------------- SPECIALIRP HOOKS -------------------------------*/

VOID
FASTCALL
IovCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{
    ULONG                    stackContextIndex = 0;
    IOV_COMPLETION_CONTEXT  StackContext;
    PIOV_COMPLETION_CONTEXT  pStackContext;
    IOFCOMPLETEREQUEST_STACKDATA completionPacket;
    LONG   currentLocation;
    PIO_STACK_LOCATION  stackPointer;


    if (!IopVerifierOn) {
        IopfCompleteRequest(Irp, PriorityBoost);
        return;
    }

    if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1) ||
        Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS,
                      (ULONG_PTR) Irp,
                      __LINE__,
                      0,
                      0);
    }

    if (Irp->CancelRoutine) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_COMPLETE_REQUEST_CANCEL_ROUTINE_SET,
                     (ULONG_PTR)Irp->CancelRoutine,
                     (ULONG_PTR)Irp,
                     0);
    }

    if (Irp->IoStatus.Status == STATUS_PENDING || Irp->IoStatus.Status == 0xffffffff) {
         KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                      IO_COMPLETE_REQUEST_INVALID_STATUS,
                      Irp->IoStatus.Status,
                      (ULONG_PTR)Irp,
                      0);
    }

    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_COMPLETE_REQUEST_INVALID_IRQL,
                     KeGetCurrentIrql(),
                     (ULONG_PTR)Irp,
                     0);

    }

    if (IovpVerifierLevel <= 1) {

        IopfCompleteRequest(Irp, PriorityBoost);
        return;
    }

    SPECIALIRP_IOF_COMPLETE_1(Irp, PriorityBoost, &completionPacket);

    if ((Irp->CurrentLocation) > (CCHAR) (Irp->StackCount)) {
        IopfCompleteRequest(Irp, PriorityBoost);
        return;
    }

    currentLocation = Irp->CurrentLocation;
    pStackContext = &StackContext;
    stackPointer = IoGetCurrentIrpStackLocation(Irp);

    //
    // Replace the completion routines with verifier completion routines so that
    // verifier gets control.
    //

    IovpKdPrint(("Hook:Irp 0x%x StackCount %d currentlocation %d stackpointer 0%x\n",
             Irp,
             Irp->StackCount,
             currentLocation,
             IoGetCurrentIrpStackLocation(Irp)));


    pStackContext->CompletionRoutine = NULL;
    pStackContext->GlobalContext = &completionPacket;
    pStackContext->IrpContext = stackPointer->Context;
    pStackContext->StackPointer = stackPointer;
    pStackContext->OldStackContents = *(stackPointer); // Save the stack contents

    IovpKdPrint(("Seeding completion Rtn 0x%x currentLocation %d stackpointer 0x%x pStackContext 0x%x \n",
             stackPointer->CompletionRoutine,
             currentLocation,
             stackPointer,
             pStackContext
             ));

    if ( (NT_SUCCESS( Irp->IoStatus.Status ) &&
         stackPointer->Control & SL_INVOKE_ON_SUCCESS) ||
         (!NT_SUCCESS( Irp->IoStatus.Status ) &&
         stackPointer->Control & SL_INVOKE_ON_ERROR) ||
         (Irp->Cancel &&
         stackPointer->Control & SL_INVOKE_ON_CANCEL)
       ) {

        pStackContext->CompletionRoutine = stackPointer->CompletionRoutine;
        pStackContext->IrpContext = stackPointer->Context;
    } else {

        //
        // Force the completion routine to be called.
        // Store the old control flag value.
        //

        stackPointer->Control |= SL_INVOKE_ON_SUCCESS|SL_INVOKE_ON_ERROR;

    }

    stackPointer->CompletionRoutine = IovpLocalCompletionRoutine;
    stackPointer->Context = pStackContext;


    IopfCompleteRequest(Irp, PriorityBoost);

}

#define ZeroAndDopeIrpStackLocation( IrpSp ) {  \
    (IrpSp)->MinorFunction = 0;                 \
    (IrpSp)->Flags = 0;                         \
    (IrpSp)->Control = SL_NOTCOPIED;            \
    (IrpSp)->Parameters.Others.Argument1 = 0;   \
    (IrpSp)->Parameters.Others.Argument2 = 0;   \
    (IrpSp)->Parameters.Others.Argument3 = 0;   \
    (IrpSp)->Parameters.Others.Argument4 = 0;   \
    (IrpSp)->FileObject = (PFILE_OBJECT) NULL; }


NTSTATUS
IovpLocalCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIOV_COMPLETION_CONTEXT  pStackContext = Context;
    NTSTATUS status;
    PIO_STACK_LOCATION stackPointer = pStackContext->StackPointer;
    BOOLEAN lastStackLocation = FALSE;

    //
    // Copy back all parameters that were zeroed out.
    //
    //
    stackPointer->MinorFunction = pStackContext->OldStackContents.MinorFunction;
    stackPointer->Flags = pStackContext->OldStackContents.Flags;
    stackPointer->Control = pStackContext->OldStackContents.Control;
    stackPointer->Parameters.Others.Argument1 = pStackContext->OldStackContents.Parameters.Others.Argument1;
    stackPointer->Parameters.Others.Argument2 = pStackContext->OldStackContents.Parameters.Others.Argument2;
    stackPointer->Parameters.Others.Argument3 = pStackContext->OldStackContents.Parameters.Others.Argument3;
    stackPointer->Parameters.Others.Argument4 = pStackContext->OldStackContents.Parameters.Others.Argument4;
    stackPointer->FileObject = pStackContext->OldStackContents.FileObject;

    //
    // Put these back too.
    //
    stackPointer->CompletionRoutine = pStackContext->CompletionRoutine;
    stackPointer->Context = pStackContext->IrpContext;

    //
    // Get this before the IRP is freed.
    //
    lastStackLocation = (Irp->CurrentLocation == (CCHAR) (Irp->StackCount + 1));

    //
    // Simulated completion routine.
    //
    SPECIALIRP_IOF_COMPLETE_2(Irp, pStackContext->GlobalContext);
    ZeroAndDopeIrpStackLocation( stackPointer );

    if (!stackPointer->CompletionRoutine) {

        IovpKdPrint(("Local completion routine null stackpointer 0x%x \n", stackPointer));

        //
        // Handle things as if no completion routine existed.
        //
        if (Irp->PendingReturned && Irp->CurrentLocation <= Irp->StackCount) {
            IoMarkIrpPending( Irp );
        }

        status = STATUS_SUCCESS;

    } else {

        IovpKdPrint(("Local completion routine 0x%x stackpointer 0x%x \n", routine, stackPointer));

        //
        // A completion routine exists, call it now.
        //
        SPECIALIRP_IOF_COMPLETE_3(Irp, stackPointer->CompletionRoutine, pStackContext->GlobalContext);
        status = stackPointer->CompletionRoutine(DeviceObject, Irp, stackPointer->Context);
        SPECIALIRP_IOF_COMPLETE_4(Irp, status, pStackContext->GlobalContext);
    }

    SPECIALIRP_IOF_COMPLETE_5(Irp, pStackContext->GlobalContext);

    if (status != STATUS_MORE_PROCESSING_REQUIRED && !lastStackLocation) {

        //
        // Seed the next location. We can touch the stack as the IRP is still valid
        //

        stackPointer++;

        pStackContext->StackPointer = stackPointer;
        pStackContext->CompletionRoutine = NULL;
        pStackContext->IrpContext = stackPointer->Context;
        pStackContext->StackPointer = stackPointer;
        pStackContext->OldStackContents = *(stackPointer); // Save the stack contents

        if ( (NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_SUCCESS) ||
             (!NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_ERROR) ||
             (Irp->Cancel &&
             stackPointer->Control & SL_INVOKE_ON_CANCEL)
           ) {

            pStackContext->CompletionRoutine = stackPointer->CompletionRoutine;
            pStackContext->IrpContext = stackPointer->Context;

        } else {

            //
            // Force the completion routine to be called.
            // Store the old control flag value.
            //

            stackPointer->Control |= SL_INVOKE_ON_SUCCESS|SL_INVOKE_ON_ERROR;

        }

        stackPointer->CompletionRoutine = IovpLocalCompletionRoutine;
        stackPointer->Context = pStackContext;

        IovpKdPrint(("Seeding completion Rtn 0x%x currentLocation %d stackpointer 0x%x pStackContext 0x%x \n",
                 stackPointer->CompletionRoutine,
                 Irp->CurrentLocation,
                 stackPointer,
                 pStackContext
                 ));
    }

    return status;
}


VOID
IovInitializeIrp(
    PIRP    Irp,
    USHORT  PacketSize,
    CCHAR   StackSize
    )
{
    BOOLEAN initializeHandled ;

    if (IovpVerifierLevel < 2) {
        return;
    }

    VerifierIoInitializeIrp(Irp, PacketSize, StackSize, &initializeHandled);
}

VOID
IovAttachDeviceToDeviceStack(
    PDEVICE_OBJECT  SourceDevice,
    PDEVICE_OBJECT  TargetDevice
    )
{
    if (IovpVerifierLevel < 2) {
        return;
    }

    VerifierIoAttachDeviceToDeviceStack(SourceDevice, TargetDevice);
}

VOID
IovDeleteDevice(
    PDEVICE_OBJECT  DeleteDevice
    )
{
    if (IovpVerifierFlags & DRIVER_VERIFIER_DMA_VERIFIER) {
       VfHalDeleteDevice(DeleteDevice);
    }

    if (IovpVerifierLevel < 2) {
        return;
    }

    VerifierIoDeleteDevice(DeleteDevice);
}

VOID
IovDetachDevice(
    PDEVICE_OBJECT  TargetDevice
    )
{
    if (IovpVerifierLevel < 2) {
        return;
    }

    VerifierIoDetachDevice(TargetDevice);
}

BOOLEAN
IovCancelIrp(
    PIRP    Irp,
    BOOLEAN *returnValue
    )
{
    BOOLEAN cancelHandled;

    SPECIALIRP_IO_CANCEL_IRP(Irp, &cancelHandled, returnValue) ;

    return cancelHandled;
}

typedef struct  _IOV_DRIVER_LIST_ENTRY {
    SINGLE_LIST_ENTRY   listEntry;
    PDRIVER_OBJECT      DriverObject;
} IOV_DRIVER_LIST_ENTRY, *PIOV_DRIVER_LIST_ENTRY;

SINGLE_LIST_ENTRY   IovDriverListHead;



BOOLEAN
IovpBuildDriverObjectList(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG HandleCount,
    IN ULONG PointerCount,
    IN PVOID Parameter
    )
{
    PIOV_DRIVER_LIST_ENTRY driverListEntry;
    PDRIVER_OBJECT         driverObject;

    driverObject = (PDRIVER_OBJECT)Object;

    if (IopIsLegacyDriver(driverObject)) {
        driverListEntry = ExAllocatePoolWithTag(
                                    NonPagedPool,
                                    sizeof(IOV_DRIVER_LIST_ENTRY),
                                    'ovI'
                                    );
        if (!driverListEntry) {
            return FALSE;
        }

        if (ObReferenceObjectSafe(driverObject)) {
           driverListEntry->DriverObject = driverObject;
           PushEntryList(&IovDriverListHead, &driverListEntry->listEntry);
        } else {
           ExFreePool (driverListEntry);
        }
    } else {
        IovpKdPrint (("Rejected non-legacy driver %wZ (%p)\n", &driverObject->DriverName, driverObject));
    }

    return TRUE;
}

NTSTATUS
IovpUnloadDriver(
    PDRIVER_OBJECT  DriverObject
    )
{
    NTSTATUS status;
    BOOLEAN unloadDriver;

    //
    // Check to see whether or not this driver implements unload.
    //

    if (DriverObject->DriverUnload == (PDRIVER_UNLOAD) NULL) {
        IovpKdPrint (("No unload routine for driver %wZ (%p)\n", &DriverObject->DriverName, DriverObject));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Check to see whether the driver has already been marked for an unload
    // operation by anyone in the past.
    //

    ObReferenceObject (DriverObject);

    status = IopCheckUnloadDriver(DriverObject,&unloadDriver);

    if ( NT_SUCCESS(status) ) {
        return STATUS_PENDING;
    }

    ObDereferenceObject (DriverObject);


    if (unloadDriver) {


        //
        // If the current thread is not executing in the context of the system
        // process, which is required in order to invoke the driver's unload
        // routine.  Queue a worker item to one of the worker threads to
        // get into the appropriate process context and then invoke the
        // routine.
        //
        if (PsGetCurrentProcess() == PsInitialSystemProcess) {
            //
            // The current thread is alrady executing in the context of the
            // system process, so simply invoke the driver's unload routine.
            //
            IovpKdPrint (("Calling unload for driver %wZ (%p)\n",
                     &DriverObject->DriverName, DriverObject));
            DriverObject->DriverUnload( DriverObject );
            IovpKdPrint (("Unload returned for driver %wZ (%p)\n",
                     &DriverObject->DriverName, DriverObject));

        } else {
            LOAD_PACKET loadPacket;

            KeInitializeEvent( &loadPacket.Event, NotificationEvent, FALSE );
            loadPacket.DriverObject = DriverObject;
            ExInitializeWorkItem( &loadPacket.WorkQueueItem,
                                  IopLoadUnloadDriver,
                                  &loadPacket );
            ExQueueWorkItem( &loadPacket.WorkQueueItem, DelayedWorkQueue );
            (VOID) KeWaitForSingleObject( &loadPacket.Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }
        ObMakeTemporaryObject( DriverObject );
        ObDereferenceObject( DriverObject );
        return STATUS_SUCCESS;
    } else {
        return STATUS_PENDING;
    }

}

NTSTATUS
IovUnloadDrivers(
    VOID
    )
{
    NTSTATUS status;
    PSINGLE_LIST_ENTRY listEntry;
    PIOV_DRIVER_LIST_ENTRY driverListEntry;
    SINGLE_LIST_ENTRY NonUnloadedDrivers, NonUnloadedDriversTmp;
    BOOLEAN DoneSomething, NeedWait, Break;

    if (!PoCleanShutdownEnabled ())
        return STATUS_UNSUCCESSFUL;

    IovDriverListHead.Next = NULL;
    NonUnloadedDrivers.Next = NULL;

    //
    // Prepare a list of all driver objects.
    //

    status = ObEnumerateObjectsByType(
                IoDriverObjectType,
                IovpBuildDriverObjectList,
                NULL
                );

    //
    // Walk through the list and unload each driver.
    //
    while (TRUE) {
        listEntry = PopEntryList(&IovDriverListHead);
        if (listEntry == NULL) {
            break;
        }
        driverListEntry = CONTAINING_RECORD(listEntry, IOV_DRIVER_LIST_ENTRY, listEntry);
        IovpKdPrint (("Trying to unload %wZ (%p)\n",
                  &driverListEntry->DriverObject->DriverName, driverListEntry->DriverObject));
        if (IovpUnloadDriver(driverListEntry->DriverObject) != STATUS_PENDING) {
            ObDereferenceObject(driverListEntry->DriverObject);
            ExFreePool(driverListEntry);
        } else {
            IovpKdPrint (("Unload of driver %wZ (%p) pended\n",
                      &driverListEntry->DriverObject->DriverName, driverListEntry->DriverObject));
            PushEntryList(&NonUnloadedDrivers, &driverListEntry->listEntry);
        }
    }

    //
    // Walk the drivers that didn't unload straight away and see if any have had their unloads called yet
    //
    do {
        NeedWait = DoneSomething = FALSE;
        NonUnloadedDriversTmp.Next = NULL;

        while (TRUE) {

            listEntry = PopEntryList(&NonUnloadedDrivers);

            if (listEntry == NULL) {
                break;
            }

            driverListEntry = CONTAINING_RECORD(listEntry, IOV_DRIVER_LIST_ENTRY, listEntry);

            //
            // If driver unload is queued to be invoked then
            //

            if (driverListEntry->DriverObject->Flags & DRVO_UNLOAD_INVOKED) {

                IovpKdPrint (("Pending unload of driver %wZ (%p) is being invoked\n",
                         &driverListEntry->DriverObject->DriverName, driverListEntry->DriverObject));
                ObDereferenceObject(driverListEntry->DriverObject);
                ExFreePool(driverListEntry);
                NeedWait = TRUE;

            } else {

                PushEntryList(&NonUnloadedDriversTmp, &driverListEntry->listEntry);
            }
        }

        if (NeedWait) {
            LARGE_INTEGER tmo = {(ULONG)(-10 * 1000 * 1000 * 10), -1};
            ZwDelayExecution (FALSE, &tmo);
            DoneSomething = TRUE;
        }

        NonUnloadedDrivers = NonUnloadedDriversTmp;

    } while (DoneSomething == TRUE && NonUnloadedDrivers.Next != NULL);

    //
    // All the drivers left didn't have unload called becuase they had files open etc
    //

    Break = FALSE;

    while (TRUE) {

        listEntry = PopEntryList(&NonUnloadedDrivers);

        if (listEntry == NULL) {
            break;
        }

        driverListEntry = CONTAINING_RECORD(listEntry, IOV_DRIVER_LIST_ENTRY, listEntry);

        IovpKdPrint (("Unload never got called for driver %wZ (%p)\n",
                 &driverListEntry->DriverObject->DriverName, driverListEntry->DriverObject));

        ObDereferenceObject(driverListEntry->DriverObject);
        ExFreePool(driverListEntry);

        Break = TRUE;
    }
    if (Break == TRUE) {
//      DbgBreakPoint ();
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\open.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    open.c

Abstract:

    This module contains the code to implement the NtOpenFile system
    service.

Author:

    Darryl E. Havens (darrylh) 25-Oct-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtOpenFile)
#endif

NTSTATUS
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )

/*++

Routine Description:

    This service opens a file or a device.  It is used to establish a file
    handle to the open device/file that can then be used in subsequent
    operations to perform I/O operations on.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    OpenOptions - Caller options for how to perform the open.

Return Value:

    The function value is the final completion status of the open/create
    operation.

--*/

{
    //
    // Simply invoke the common I/O file creation routine to perform the work.
    //

    PAGED_CODE();

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         ShareAccess,
                         FILE_OPEN,
                         OpenOptions,
                         (PVOID) NULL,
                         0L,
                         CreateFileTypeNone,
                         (PVOID) NULL,
                         0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\lock.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    lock.c

Abstract:

    This module contains the code to implement the NtLockFile and the
    NtUnlockFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 29-Nov-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtLockFile)
#pragma alloc_text(PAGE, NtUnlockFile)
#endif

NTSTATUS
NtLockFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    )

/*++

Routine Description:

    This service locks a specified range of bytes on the file specified by
    the FileHandle parameter.  The lock may either be an exclusive lock or
    a shared lock.  Furthermore, the caller has the option of specifying
    whether or not the service should return immediately if the lock cannot
    be acquired without waiting.

Arguments:

    FileHandle - Supplies a handle to an open file.

    Event - Supplies an optional event to be set to the Signaled state when
        the operation is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    ByteOffset - Specifies the starting byte offset of the range to lock.

    Length - Specifies the length of the byte range to be locked.

    Key - Specifies the key to be associated with the lock.

    FailImmediately - Specifies that if the lock cannot immediately be
        acquired that the service should return to the caller.

    ExclusiveLock - Specifies, if TRUE, that the lock should be an exclusive
        lock;  otherwise the lock is a shared lock.

Return Value:

    The status returned is success if the operation was properly queued to
    the I/O system.  Once the operation completes, the status can be
    determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT eventObject = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER fileOffset;
    LARGE_INTEGER length;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers
    // in user mode.  Note that if the handle does not refer to a file
    // object, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either READ or WRITE access to
        // the file.  If not, cleanup and return an error.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // The ByteOffset parameter must be readable by the caller.  Probe
            // and capture it.
            //

            ProbeForReadSmallStructure( ByteOffset,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            fileOffset = *ByteOffset;

            //
            // Likewise, the Length parameter must also be readable by the
            // caller.  Probe and capture it as well.
            //

            ProbeForReadSmallStructure( Length,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            length = *Length;

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred attempting to probe the caller's
            // parameters.  Dereference the file object and return an
            // appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return GetExceptionCode();
        }

    } else {

        //
        // The caller's mode was kernel.  Get the ByteOffset and Length
        // parameter 's to the expected locations.
        //

        fileOffset = *ByteOffset;
        length = *Length;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.  Since certain legacy
    // applications rely on an old bug in Win32's LockFileEx, we must
    // tolerate bad event handles.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ASSERT( !eventObject );
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the target device object and the fast Io dispatch
    // structure.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Turbo lock support.  If the fast Io Dispatch specifies a fast lock
    // routine then we'll first try and calling it with the specified lock
    // parameters.
    //

    if (fastIoDispatch && fastIoDispatch->FastIoLock) {

        IO_STATUS_BLOCK localIoStatus;

        if (fastIoDispatch->FastIoLock( fileObject,
                                        &fileOffset,
                                        &length,
                                        PsGetCurrentProcessByThread(CurrentThread),
                                        Key,
                                        FailImmediately,
                                        ExclusiveLock,
                                        &localIoStatus,
                                        deviceObject )) {

            //
            // Carefully return the I/O status.
            //

            try {
#if defined(_WIN64)
                //
                // If this is a32-bit thread, and the IO request is 
                // asynchronous, then the IOSB is 32-bit. Wow64 always sends
                // the 32-bit IOSB when the I/O is asynchronous.
                //
                if (IopIsIosb32(ApcRoutine)) {
                    PIO_STATUS_BLOCK32 UserIosb32 = (PIO_STATUS_BLOCK32)IoStatusBlock;
                    
                    UserIosb32->Information = (ULONG)localIoStatus.Information;
                    UserIosb32->Status = (NTSTATUS)localIoStatus.Status;
                } else {
                    *IoStatusBlock = localIoStatus;
                }
#else
                *IoStatusBlock = localIoStatus;
#endif
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                localIoStatus.Status = GetExceptionCode();
                localIoStatus.Information = 0;
            }

            //
            // If a valid event was specified, set it.
            //

            if (eventObject) {
                KeSetEvent( eventObject, 0, FALSE );
                ObDereferenceObject( eventObject );
            }

            //
            // Note that the file object event need not be set to the
            // Signaled state, as it is already set.
            //

            //
            // If this file object has a completion port associated with it
            // and this request has a non-NULL APC context then a completion
            // message needs to be queued.
            //

            if (fileObject->CompletionContext && ARGUMENT_PRESENT( ApcContext )) {
                if (!NT_SUCCESS(IoSetIoCompletion( fileObject->CompletionContext->Port,
                                                   fileObject->CompletionContext->Key,
                                                   ApcContext,
                                                   localIoStatus.Status,
                                                   localIoStatus.Information,
                                                   TRUE ))) {
                    localIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            //
            // Cleanup and return.
            //

            fileObject->LockOperation = TRUE;
            ObDereferenceObject( fileObject );
            return localIoStatus.Status;
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state and mark it as having had
    // a lock operation performed on it.
    //

    KeClearEvent( &fileObject->Event );
    fileObject->LockOperation = TRUE;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_LOCK;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Flags = 0;
    if (FailImmediately) {
        irpSp->Flags = SL_FAIL_IMMEDIATELY;
    }
    if (ExclusiveLock) {
        irpSp->Flags |= SL_EXCLUSIVE_LOCK;
    }
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = fileOffset;

    try {
        PLARGE_INTEGER lengthBuffer;

        //
        // Attempt to allocate an intermediary buffer to hold the length of
        // this lock operation.  If it fails, either because there is no
        // more quota, or because there are no more resources, then the
        // exception handler will be invoked to cleanup and exit.
        //

        lengthBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                sizeof( LARGE_INTEGER ) );

        *lengthBuffer = length;
        irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR) lengthBuffer;
        irpSp->Parameters.LockControl.Length = lengthBuffer;
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred.  Simply clean everything up and
        // return an appropriate error status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             eventObject,
                             (PKEVENT) NULL );

        return GetExceptionCode();
    }

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    return IopSynchronousServiceTail( deviceObject,
                                      irp,
                                      fileObject,
                                      FALSE,
                                      requestorMode,
                                      synchronousIo,
                                      OtherTransfer );
}

NTSTATUS
NtUnlockFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key
    )

/*++

Routine Description:

    This service releases the lock associated with the specified byte range
    for the file specified by the FileHandle parameter.

Arguments:

    FileHandle - Supplies a handle to an open file.

    IoStatusBlock - Address of the caller's I/O status block.

    ByteOffset - Specifies the byte offset of the range to unlock.

    Length - Specifies the length of the byte range to unlock.

    Key - Specifies the key associated with the locked range.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT event;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    LARGE_INTEGER fileOffset;
    LARGE_INTEGER length;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers
    // in user mode.  Note that if the handle does not refer to a file
    // object, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either READ or WRITE access
        // to the file.  If not, cleanup and return an error.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The ByteOffset parameter must be readable by the caller.  Probe
            // and capture it.
            //

            ProbeForReadSmallStructure( ByteOffset,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            fileOffset = *ByteOffset;

            //
            // Likewise, the Length parameter must also be readable by the
            // caller.  Probe and capture it as well.
            //

            ProbeForReadSmallStructure( Length,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            length = *Length;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was kernel.  Get the ByteOffset and Length
        // parameter 's to the expected locations.
        //

        fileOffset = *ByteOffset;
        length = *Length;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.  Also get the fast I/O dispatch address.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Turbo lock support.  If the fast Io Dispatch specifies a fast lock
    // routine then we'll first try and calling it with the specified lock
    // parameters.
    //

    if (fastIoDispatch && fastIoDispatch->FastIoUnlockSingle) {

        IO_STATUS_BLOCK localIoStatus;

        if (fastIoDispatch->FastIoUnlockSingle( fileObject,
                                                &fileOffset,
                                                &length,
                                                PsGetCurrentProcessByThread(CurrentThread),
                                                Key,
                                                &localIoStatus,
                                                deviceObject )) {

            //
            // Carefully return the I/O status.
            //

            try {
                *IoStatusBlock = localIoStatus;
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                localIoStatus.Status = GetExceptionCode();
                localIoStatus.Information = 0;
            }

            //
            // Cleanup and return.
            //

            ObDereferenceObject( fileObject );
            return localIoStatus.Status;
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_UNLOCK_SINGLE;
    irpSp->FileObject = fileObject;

    try {
        PLARGE_INTEGER lengthBuffer;

        //
        // Attempt to allocate an intermediary buffer to hold the length of
        // this lock operation.  If it fails, either because there is no
        // more quota, or because there are no more resources, then the
        // exception handler will be invoked to cleanup and exit.
        //

        lengthBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                sizeof( LARGE_INTEGER ) );

        *lengthBuffer = length;
        irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR) lengthBuffer;
        irpSp->Parameters.LockControl.Length = lengthBuffer;
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred.  Simply clean everything up and
        // return an appropriate error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }
  
        IopExceptionCleanup( fileObject,
                             irp,
                             NULL,
                             (PKEVENT) NULL );

        return GetExceptionCode();
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\objsup.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    objsup.c

Abstract:

    This module contains the object support routine for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 30-May-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

NTSTATUS
IopSetDeviceSecurityDescriptors(
    IN PDEVICE_OBJECT           OriginalDeviceObject,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    );

NTSTATUS
IopSetDeviceSecurityDescriptor(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopCloseFile)
#pragma alloc_text(PAGE, IopDeleteFile)
#pragma alloc_text(PAGE, IopDeleteDevice)
#pragma alloc_text(PAGE, IopDeleteDriver)
#pragma alloc_text(PAGE, IopGetSetSecurityObject)
#pragma alloc_text(PAGE, IopSetDeviceSecurityDescriptors)
#pragma alloc_text(PAGE, IopSetDeviceSecurityDescriptor)
#endif

VOID
IopCloseFile(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ULONG GrantedAccess,
    IN ULONG ProcessHandleCount,
    IN ULONG SystemHandleCount
    )

/*++

Routine Description:

    This routine is invoked whenever a handle to a file is deleted.  If the
    handle being deleted is the last handle to the file (the ProcessHandleCount
    parameter is one), then all locks for the file owned by the specified
    process must be released.

    Likewise, if the SystemHandleCount is one then this is the last handle
    for this for file object across all processes.  For this case, the file
    system is notified so that it can perform any necessary cleanup on the
    file.

Arguments:

    Process - A pointer to the process that closed the handle.

    Object - A pointer to the file object that the handle referenced.

    GrantedAccess - Access that was granted to the object through the handle.

    ProcessHandleCount - Count of handles outstanding to the object for the
        process specified by the Process argument.  If the count is one
        then this is the last handle to this file by that process.

    SystemHandleCount - Count of handles outstanding to the object for the
        entire system.  If the count is one then this is the last handle
        to this file in the system.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    KEVENT event;
    PFILE_OBJECT fileObject;
    KIRQL irql;

    UNREFERENCED_PARAMETER( Process );
    UNREFERENCED_PARAMETER( GrantedAccess );

    PAGED_CODE();

    //
    // If the handle count is not one then this is not the last close of
    // this file for the specified process so there is nothing to do.
    //

    if (ProcessHandleCount != 1) {
        return;
    }

    fileObject = (PFILE_OBJECT) Object;

    if (fileObject->LockOperation && SystemHandleCount != 1) {

        IO_STATUS_BLOCK localIoStatus;

        //
        // This is the last handle for the specified process and the process
        // called the NtLockFile or NtUnlockFile system services at least once.
        // Also, this is not the last handle for this file object system-wide
        // so unlock all of the pending locks for this process.  Note that
        // this check causes an optimization so that if this is the last
        // system-wide handle to this file object the cleanup code will take
        // care of releasing any locks on the file rather than having to
        // send the file system two different packets to get them shut down.

        //
        // Get the address of the target device object and the Fast I/O dispatch
        //

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now. The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                (VOID) IopAcquireFileObjectLock( fileObject,
                                                 KernelMode,
                                                 FALSE,
                                                 &interrupted );
            }
        }

        //
        // Turbo unlock support.  If the fast Io Dispatch specifies a fast lock
        // routine then we'll first try and calling it with the specified lock
        // parameters.  If this is all successful then we do not need to do
        // the Irp based unlock all call.
        //

        if (fastIoDispatch &&
            fastIoDispatch->FastIoUnlockAll &&
            fastIoDispatch->FastIoUnlockAll( fileObject,
                                             PsGetCurrentProcess(),
                                             &localIoStatus,
                                             deviceObject )) {

            NOTHING;

        } else {

            //
            // Initialize the local event that will be used to synchronize access
            // to the driver completing this I/O operation.
            //

            KeInitializeEvent( &event, SynchronizationEvent, FALSE );

            //
            // Reset the event in the file object.
            //

            KeClearEvent( &fileObject->Event );

            //
            // Allocate and initialize the I/O Request Packet (IRP) for this
            // operation.
            //

            irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
            irp->Tail.Overlay.OriginalFileObject = fileObject;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->RequestorMode = KernelMode;

            //
            // Fill in the service independent parameters in the IRP.
            //

            irp->UserEvent = &event;
            irp->UserIosb = &irp->IoStatus;
            irp->Flags = IRP_SYNCHRONOUS_API;
            irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

            //
            // Get a pointer to the stack location for the first driver.  This will
            // be used to pass the original function codes and parameters.  No
            // function-specific parameters are required for this operation.
            //

            irpSp = IoGetNextIrpStackLocation( irp );
            irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
            irpSp->MinorFunction = IRP_MN_UNLOCK_ALL;
            irpSp->FileObject = fileObject;

            //
            //  Reference the fileobject again for the IRP (cleared on completion)
            //

            ObReferenceObject( fileObject );

            //
            // Insert the packet at the head of the IRP list for the thread.
            //

            IopQueueThreadIrp( irp );

            //
            // Invoke the driver at its appropriate dispatch entry with the IRP.
            //

            status = IoCallDriver( deviceObject, irp );

            //
            // If no error was incurred, wait for the I/O operation to complete.
            //

            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              UserRequest,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
            }
        }

        //
        // If this operation was a synchronous I/O operation, release the
        // semaphore so that the file can be used by other threads.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    if (SystemHandleCount == 1) {

        //
        // The last handle to this file object for all of the processes in the
        // system has just been closed, so invoke the driver's "cleanup" handler
        // for this file.  This is the file system's opportunity to remove any
        // share access information for the file, to indicate that if the file
        // is opened for a caching operation and this is the last file object
        // to the file, then it can do whatever it needs with memory management
        // to cleanup any information.
        //
        // Begin by getting the address of the target device object.
        //

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }

        //
        // Ensure that the I/O system believes that this file has a handle
        // associated with it in case it doesn't actually get one from the
        // Object Manager.  This is done because sometimes the Object Manager
        // actually creates a handle, but the I/O system never finds out
        // about it so it attempts to send two cleanups for the same file.
        //

        fileObject->Flags |= FO_HANDLE_CREATED;

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now. The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                (VOID) IopAcquireFileObjectLock( fileObject,
                                                 KernelMode,
                                                 FALSE,
                                                 &interrupted );
            }
        }

        //
        // Initialize the local event that will be used to synchronize access
        // to the driver completing this I/O operation.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.
        //

        irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->RequestorMode = KernelMode;

        //
        // Fill in the service independent parameters in the IRP.
        //

        irp->UserEvent = &event;
        irp->UserIosb = &irp->IoStatus;
        irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
        irp->Flags = IRP_SYNCHRONOUS_API | IRP_CLOSE_OPERATION;

        //
        // Get a pointer to the stack location for the first driver.  This will
        // be used to pass the original function codes and parameters.  No
        // function-specific parameters are required for this operation.
        //

        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_CLEANUP;
        irpSp->FileObject = fileObject;

        //
        // Insert the packet at the head of the IRP list for the thread.
        //

        IopQueueThreadIrp( irp );

        //
        // Update the operation count statistic for the current process for
        // operations other than read and write.
        //

        IopUpdateOtherOperationCount();

        //
        // Invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );

        //
        // If no error was incurred, wait for the I/O operation to complete.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          UserRequest,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // The following code tears down the IRP by hand since it may not
        // either be possible to it to be completed (because this code was
        // invoked as APC_LEVEL in the first place - or because the reference
        // count on the object cannot be incremented due to this routine
        // being invoked by the delete file procedure below).  Cleanup IRPs
        // therefore use close sematics (the close operation flag is set
        // in the IRP) so that the I/O complete request routine itself sets
        // the event to the Signaled state.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        //
        // Also, free the IRP.
        //

        IoFreeIrp( irp );

        //
        // If this operation was a synchronous I/O operation, release the
        // semaphore so that the file can be used by other threads.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return;
}

VOID
IopDeleteFile(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the last handle to a specific file handle is
    being closed and the file object is going away.  It is the responsibility
    of this routine to perform the following functions:

        o  Notify the device driver that the file object is open on that the
           file is being closed.

        o  Dereference the user's error port for the file object, if there
           is one associated with the file object.

        o  Decrement the device object reference count.

Arguments:

    Object - Pointer to the file object being deleted.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT fsDevice = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL irql;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    KEVENT event;
    PVPB vpb;
    BOOLEAN referenceCountDecremented;

    //
    // Obtain a pointer to the file object.
    //

    fileObject = (PFILE_OBJECT) Object;

    //
    // Get a pointer to the first device driver which should be notified that
    // this file is going away.  If the device driver field is NULL, then this
    // file is being shut down due to an error attempting to get it open in the
    // first place, so do not do any further processing.
    //

    if (fileObject->DeviceObject) {
        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }

        //
        // If this file has never had a file handle created for it, and yet
        // it exists, invoke the close file procedure so that the file system
        // gets the cleanup IRP it is expecting before sending the close IRP.
        //

        if (!(fileObject->Flags & FO_HANDLE_CREATED)) {
            IopCloseFile( (PEPROCESS) NULL,
                          Object,
                          0,
                          1,
                          1 );
        }

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now.  The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                (VOID) IopAcquireFileObjectLock( fileObject,
                                                 KernelMode,
                                                 FALSE,
                                                 &interrupted );
            }
        }

        //
        // Reset a local event that can be used to wait for the device driver
        // to close the file.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate an I/O Request Packet (IRP) to be used in communicating with
        // the appropriate device driver that the file is being closed.  Notice
        // that the allocation of this packet is done without charging quota so
        // that the operation will not fail.  This is done because there is no
        // way to return an error to the caller at this point.
        //

        irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
        if (!irp) {
            irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
        }

        //
        // Get a pointer to the stack location for the first driver.  This is
        // where the function codes and parameters are placed.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Fill in the IRP, indicating that this file object is being deleted.
        //

        irpSp->MajorFunction = IRP_MJ_CLOSE;
        irpSp->FileObject = fileObject;
        irp->UserIosb = &ioStatusBlock;
        irp->UserEvent = &event;
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
        irp->Flags = IRP_CLOSE_OPERATION | IRP_SYNCHRONOUS_API;

        //
        // Place this packet in the thread's I/O pending queue.
        //

        IopQueueThreadIrp( irp );

        //
        // Decrement the reference count on the VPB, if necessary.  We
        // have to do this BEFORE handing the Irp to the file system
        // because of a trick the file systems play with close, and
        // believe me, you really don't want to know what it is.
        //
        // Since there is not a error path here (close cannot fail),
        // and the file system is the only ome who can actually synchronize
        // with the actual completion of close processing, the file system
        // is the one responsible for Vpb deletion.
        //

        vpb = fileObject->Vpb;


        if (vpb && !(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            IopInterlockedDecrementUlong( LockQueueIoVpbLock,
                                          &vpb->ReferenceCount );

            //
            // Bump the handle count of the filesystem volume device object.
            // This will prevent the filesystem filter stack from being torn down
            // until after the close IRP completes.
            //

            fsDevice = vpb->DeviceObject;
            if (fsDevice) {
                IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                              &fsDevice->ReferenceCount );
            }
        }

        //
        // If this device object has stated for a fact that it knows it will
        // never have the final non-zero reference count among the other
        // device objects associated with our driver object, then decrement
        // our reference count here BEFORE calling the file system.  This
        // is required because for a special class of device objects, the
        // file system may delete them.
        //

        if (fileObject->DeviceObject->Flags & DO_NEVER_LAST_DEVICE) {
            IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                          &fileObject->DeviceObject->ReferenceCount );

            referenceCountDecremented = TRUE;
        } else {
            referenceCountDecremented = FALSE;
        }

        //
        // Give the device driver the packet.  If this request does not work,
        // there is nothing that can be done about it.  This is unfortunate
        // because the driver may have had problems that it was about to
        // report about other operations (e.g., write behind failures, etc.)
        // that it can no longer report.  The reason is that this routine
        // is really initially invoked by NtClose, which has already closed
        // the caller's handle, and that's what the return status from close
        // indicates:  the handle has successfully been closed.
        //

        status = IoCallDriver( deviceObject, irp );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // Perform any completion operations that need to be performed on
        // the IRP that was used for this request.  This is done here as
        // as opposed to in normal completion code because there is a race
        // condition between when this routine executes if it was invoked
        // from a special kernel APC (e.g., some IRP was just completed and
        // dereferenced this file object for the last time), and when the
        // special kernel APC because of this packet's completion executing.
        //
        // This problem is solved by not having to queue a special kernel
        // APC routine for completion of this packet.  Rather, it is treated
        // much like a synchronous paging I/O operation, except that the
        // packet is not even freed during I/O completion.  This is because
        // the packet is still in this thread's queue, and there is no way
        // to get it out except at APC_LEVEL.  Unfortunately, the part of
        // I/O completion that needs to dequeue the packet is running at
        // DISPATCH_LEVEL.
        //
        // Hence, the packet must be removed from the queue (synchronized,
        // of course), and then it must be freed.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        IoFreeIrp( irp );

        //
        // Free the file name string buffer if there was one.
        //

        if (fileObject->FileName.Length != 0) {
            ExFreePool( fileObject->FileName.Buffer );
        }

        //
        // If there was an completion port associated w/this file object, dereference
        // it now, and deallocate the completion context pool.
        //

        if (fileObject->CompletionContext) {
            ObDereferenceObject( fileObject->CompletionContext->Port );
            ExFreePool( fileObject->CompletionContext );
        }

        //
        // Free the file context control structure if it exists.
        //

        if (fileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
            FsRtlPTeardownPerFileObjectContexts(fileObject);
        }

        //
        // Get a pointer to the real device object so its reference count
        // can be decremented.
        //

        deviceObject = fileObject->DeviceObject;

        //
        // Decrement the reference count on the device object.  Note that
        // if the driver has been marked for an unload operation, and the
        // reference count goes to zero, then the driver may need to be
        // unloaded at this point.
        //
        // Note: only do this if the reference count was not already done
        // above.  The device object may be gone in this case.
        //

        if (!referenceCountDecremented) {

            IopDecrementDeviceObjectRef(
                deviceObject,
                FALSE,
                !ObIsObjectDeletionInline(Object)
                );
        }

        //
        // Decrement the filesystem's volume device object handle count
        // so that deletes can proceed.
        //

        if (fsDevice && vpb) {
            IopDecrementDeviceObjectRef(fsDevice,
                                         FALSE,
                                         !ObIsObjectDeletionInline(Object)
                                         );
        }
    }
}

VOID
IopDeleteDriver(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the reference count for a driver object
    becomes zero.  That is, the last reference for the driver has gone away.
    This routine ensures that the object is cleaned up and the driver
    unloaded.

Arguments:

    Object - Pointer to the driver object whose reference count has gone
        to zero.

Return value:

    None.

--*/

{
    PDRIVER_OBJECT driverObject = (PDRIVER_OBJECT) Object;
    PIO_CLIENT_EXTENSION extension;
    PIO_CLIENT_EXTENSION nextExtension;

    PAGED_CODE();

    ASSERT( !driverObject->DeviceObject );

    //
    // Free any client driver object extensions.
    //

    extension = driverObject->DriverExtension->ClientDriverExtension;
    while (extension != NULL) {

        nextExtension = extension->NextExtension;
        ExFreePool( extension );
        extension = nextExtension;
    }

    //
    // If there is a driver section then unload the driver.
    //

    if (driverObject->DriverSection != NULL) {
        //
        // Make sure any DPC's that may be running inside the driver have completed
        //
#if !defined(NT_UP)
        KeFlushQueuedDpcs ();
#endif
        MmUnloadSystemImage( driverObject->DriverSection );
    }

    //
    // Free the pool associated with the name of the driver.
    //

    if (driverObject->DriverName.Buffer) {
        ExFreePool( driverObject->DriverName.Buffer );
    }

    //
    // Free the pool associated with the service key name of the driver.
    //

    if (driverObject->DriverExtension->ServiceKeyName.Buffer) {
        ExFreePool( driverObject->DriverExtension->ServiceKeyName.Buffer );
    }

    //
    // Free the pool associated with the FsFilterCallbacks structure.
    //

    if (driverObject->DriverExtension->FsFilterCallbacks) {
        ExFreePool( driverObject->DriverExtension->FsFilterCallbacks );
    }
}

VOID
IopDeleteDevice(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the reference count for a device object
    becomes zero.  That is, the last reference for the device has gone away.
    This routine ensures that the object is cleaned up and the driver object
    is dereferenced.

Arguments:

    Object - Pointer to the driver object whose reference count has gone
        to zero.

Return value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject = (PDEVICE_OBJECT) Object;
    PVPB vpb = NULL;

    PAGED_CODE();

    IopDestroyDeviceNode(deviceObject->DeviceObjectExtension->DeviceNode);

    //
    // If there's still a VPB attached then free it.
    //

    vpb = InterlockedExchangePointer(&(deviceObject->Vpb), vpb);

    if(vpb != NULL) {

        ASSERTMSG("Unreferenced device object to be deleted is still in use",
                  ((vpb->Flags & (VPB_MOUNTED | VPB_LOCKED)) == 0));

        ASSERT(vpb->ReferenceCount == 0);
        ExFreePool(vpb);
    }
    if (deviceObject->DriverObject != NULL) {
        ObDereferenceObject( deviceObject->DriverObject );
    }
}


PDEVICE_OBJECT
IopGetDevicePDO(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Call this routine to obtain the Base PDO for a device object

Arguments:

    DeviceObject - pointer to device object to get PDO for

ReturnValue:

    PDO if DeviceObject is attached to a PDO, otherwise NULL
    The returned PDO is reference-counted

--*/
{
    PDEVICE_OBJECT deviceBaseObject;
    KIRQL irql;

    ASSERT(DeviceObject);

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    deviceBaseObject = IopGetDeviceAttachmentBase(DeviceObject);
    if ((deviceBaseObject->Flags & DO_BUS_ENUMERATED_DEVICE) != 0) {
        //
        // we have determined that this is attached to a PDO
        //
        ObReferenceObject( deviceBaseObject );

    } else {
        //
        // not a PDO
        //
        deviceBaseObject = NULL;
    }
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return deviceBaseObject;
}


NTSTATUS
IopSetDeviceSecurityDescriptor(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    )
/*++

Routine Description:

    This routine sets the security descriptor on a single device object

Arguments:

    DeviceObject - pointer to base device object

    SecurityInformation - Fields of SD to change
    SecurityDescriptor  - New security descriptor
    PoolType            - Pool type for alloctions
    GenericMapping      - Generic mapping for this object

ReturnValue:

    success, or error while setting the descriptor for the device object.

--*/
{

    PSECURITY_DESCRIPTOR OldDescriptor;
    PSECURITY_DESCRIPTOR NewDescriptor;
    PSECURITY_DESCRIPTOR CachedDescriptor;
    NTSTATUS Status;
    PKTHREAD CurrentThread;

    PAGED_CODE();

    //
    // In order to preserve some protected fields in the SD (like the SACL) we need to make sure that only one
    // thread updates it at any one time. If we didn't do this another modification could wipe out a SACL
    // an administrator was adding.
    //
    CurrentThread = KeGetCurrentThread ();
    while (1) {

        //
        // Reference the security descriptor
        //

        KeEnterCriticalRegionThread(CurrentThread);
        ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

        OldDescriptor = DeviceObject->SecurityDescriptor;
        if (OldDescriptor != NULL) {
            ObReferenceSecurityDescriptor( OldDescriptor, 1 );
        }

        ExReleaseResourceLite( &IopSecurityResource );
        KeLeaveCriticalRegionThread(CurrentThread);

        NewDescriptor = OldDescriptor;

        Status = SeSetSecurityDescriptorInfo( NULL,
                                              SecurityInformation,
                                              SecurityDescriptor,
                                              &NewDescriptor,
                                              PoolType,
                                              GenericMapping );
        //
        //  If we successfully set the new security descriptor then we
        //  need to log it in our database and get yet another pointer
        //  to the finaly security descriptor
        //
        if ( NT_SUCCESS( Status )) {
            Status = ObLogSecurityDescriptor( NewDescriptor,
                                              &CachedDescriptor,
                                              1 );
            ExFreePool( NewDescriptor );
            if ( NT_SUCCESS( Status )) {
                //
                // Now we need to see if anyone else update this security descriptor inside the
                // gap where we didn't hold the lock. If they did then we just try it all again.
                //
                KeEnterCriticalRegionThread(CurrentThread);
                ExAcquireResourceExclusiveLite( &IopSecurityResource, TRUE );

                if (DeviceObject->SecurityDescriptor == OldDescriptor) {
                    //
                    // Do the swap
                    //
                    DeviceObject->SecurityDescriptor = CachedDescriptor;

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(CurrentThread);

                    //
                    // If there was an original object then we need to work out how many
                    // cached references there were (if any) and return them.
                    //
                    ObDereferenceSecurityDescriptor( OldDescriptor, 2 );
                    break;
                } else {

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(CurrentThread);

                    ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
                    ObDereferenceSecurityDescriptor( CachedDescriptor, 1);
                }

            } else {

                //
                //  Dereference old SecurityDescriptor
                //

                ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
                break;
            }
        } else {

            //
            //  Dereference old SecurityDescriptor
            //
            if (OldDescriptor != NULL) {
                ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
            }
            break;
        }
    }

    //
    //  And return to our caller
    //

    return( Status );
}


NTSTATUS
IopSetDeviceSecurityDescriptors(
    IN PDEVICE_OBJECT           OriginalDeviceObject,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    )
/*++

Routine Description:

    This routine sets the security descriptor on all the devices on the
    device stack for a PNP device. Ideally when the object manager asks the
    IO manager to set the security descriptor of a device object the IO manager
    should set the descriptor only on that device object. This is the classical
    behaviour.
    Unfortunately for PNP devices there may be multiple devices on a device
    stack with names.
    If the descriptor is applied to only one of the devices on the stack its
    opens up a security hole as there may be other devices with name on the
    stack which can be opened by a random program.
    To protect against this the descriptor is applied to all device objects on
    the stack.
    Its important that to protect compatibility we need to return the same
    status as what would have been returned if only the requested device
    object's descriptor was set.

Arguments:

    OriginalDeviceObject - Pointer to the device object passed by the object manager
    DeviceObject - pointer to base device object (first one to set)
    SecurityInformation )_ passed directly from IopGetSetSecurityObject
    SecurityDescriptor  )
    PoolType            )
    GenericMapping      )

ReturnValue:

    success, or error while setting the descriptor for the original device object.

--*/
{
    PDEVICE_OBJECT NewDeviceObject = NULL;
    PSECURITY_DESCRIPTOR OldSecurityDescriptor, NewSecurityDescriptor, CachedSecurityDescriptor;
    KIRQL irql;
    NTSTATUS status;
    NTSTATUS returnStatus = STATUS_SUCCESS;

    ASSERT(DeviceObject);

    PAGED_CODE();

    //
    // pre-reference this object to match the dereference later
    //

    ObReferenceObject( DeviceObject );

    do {

        //
        // Reference the existing security descriptor so it can't be reused.
        // We will only do the final security change if nobody else changes
        // the security while we don't hold the lock. Doing this prevents
        // privileged information being lost like the SACL.
        //

        //
        // Save away and return the device status only for the main device object
        // For example if OldSecurityDescriptor is NULL the IO manager should
        // return STATUS_NO_SECURITY_ON_OBJECT.
        //

        status = IopSetDeviceSecurityDescriptor( DeviceObject,
                                                 SecurityInformation,
                                                 SecurityDescriptor,
                                                 PoolType,
                                                 GenericMapping );


        if (DeviceObject == OriginalDeviceObject) {
            returnStatus = status;
        }


        //
        // We don't need to acquire the database lock because
        // we have a handle to this device stack.
        //

        NewDeviceObject = DeviceObject->AttachedDevice;
        if ( NewDeviceObject != NULL ) {
            ObReferenceObject( NewDeviceObject );
        }

        ObDereferenceObject( DeviceObject );
        DeviceObject = NewDeviceObject;

    } while (NewDeviceObject);

    return returnStatus;
}


NTSTATUS
IopGetSetSecurityObject(
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine is invoked to either query or set the security descriptor
    for a file, directory, volume, or device.  It implements these functions
    by either performing an in-line check if the file is a device or a
    volume, or an I/O Request Packet (IRP) is generated and given to the
    driver to perform the operation.

Arguments:

    Object - Pointer to the file or device object representing the open object.

    SecurityInformation - Information about what is being done to or obtained
        from the object's security descriptor.

    SecurityDescriptor - Supplies the base security descriptor and returns
        the final security descriptor.  Note that if this buffer is coming
        from user space, it has already been probed by the object manager
        to length "CapturedLength", otherwise it points to kernel space and
        should not be probed.  It must, however, be referenced in a try
        clause.

    CapturedLength - For a query operation this specifies the size, in
        bytes, of the output security descriptor buffer and on return
        contains the number of bytes needed to store the complete security
        descriptor.  If the length needed is greater than the length
        supplied the operation will fail.  This parameter is ignored for
        the set and delete operations.  It is expected to point into
        system space, ie, it need not be probed and it will not change.

    ObjectsSecurityDescriptor - Supplies and returns the object's security
        descriptor.

    PoolType - Specifies from which type of pool memory is to be allocated.

    GenericMapping - Supplies the generic mapping for the object type.

Return Value:

    The final status of the operation is returned as the function value.

--*/

{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT devicePDO = NULL;
    BOOLEAN synchronousIo;
    PSECURITY_DESCRIPTOR oldSecurityDescriptor, CachedSecurityDescriptor;
    PETHREAD CurrentThread;

    UNREFERENCED_PARAMETER( ObjectsSecurityDescriptor );
    UNREFERENCED_PARAMETER( PoolType );

    PAGED_CODE();


    //
    // Begin by determining whether the security operation is to be performed
    // in this routine or by the driver.  This is based upon whether the
    // object represents a device object, or it represents a file object
    // to a device, or a file on the device. If the open is a direct device
    // open then use the device object.
    //

    if (((PDEVICE_OBJECT) (Object))->Type == IO_TYPE_DEVICE) {
        deviceObject = (PDEVICE_OBJECT) Object;
        fileObject = (PFILE_OBJECT) NULL;
    } else {
        fileObject = (PFILE_OBJECT) Object;
        deviceObject = fileObject->DeviceObject;
    }

    if (!fileObject ||
        (!fileObject->FileName.Length && !fileObject->RelatedFileObject) ||
        (fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {

        //
        // This security operation is for the device itself, either through
        // a file object, or directly to the device object.  For the latter
        // case, assignment operations are also possible.  Also note that
        // this may be a stream file object, which do not have security.
        // The security for a stream file is actually represented by the
        // security descriptor on the file itself, or the volume, or the
        // device.
        //

        if (OperationCode == AssignSecurityDescriptor) {

            //
            // Simply assign the security descriptor to the device object,
            // if this is a device object.
            //

            status = STATUS_SUCCESS;

            if (fileObject == NULL || !(fileObject->Flags & FO_STREAM_FILE)) {

                status = ObLogSecurityDescriptor( SecurityDescriptor,
                                                  &CachedSecurityDescriptor,
                                                  1 );
                ExFreePool (SecurityDescriptor);
                if (NT_SUCCESS( status )) {

                    CurrentThread = PsGetCurrentThread ();
                    KeEnterCriticalRegionThread(&CurrentThread->Tcb);
                    ExAcquireResourceExclusiveLite( &IopSecurityResource, TRUE );

                    deviceObject->SecurityDescriptor = CachedSecurityDescriptor;

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(&CurrentThread->Tcb);
                }
            }

        } else if (OperationCode == SetSecurityDescriptor) {

            //
            // This is a set operation.  The SecurityInformation parameter
            // determines what part of the SecurityDescriptor is going to
            // be applied to the ObjectsSecurityDescriptor.
            //

            //
            // if this deviceObject is attached to a PDO then we want
            // to modify the security on the PDO and apply it up the
            // device chain. This applies to PNP device objects only. See
            // comment in IopSetDeviceSecurityDescriptors
            //
            devicePDO = IopGetDevicePDO(deviceObject);

            if (devicePDO) {

                //
                // set PDO and all attached device objects
                //

                status = IopSetDeviceSecurityDescriptors(
                                deviceObject,
                                devicePDO,
                                SecurityInformation,
                                SecurityDescriptor,
                                PoolType,
                                GenericMapping );

                ObDereferenceObject( devicePDO );

            } else {

                //
                // set this device object only
                //

                status = IopSetDeviceSecurityDescriptor( deviceObject,
                                                         SecurityInformation,
                                                         SecurityDescriptor,
                                                         PoolType,
                                                         GenericMapping );

            }

        } else if (OperationCode == QuerySecurityDescriptor) {

            //
            // This is a get operation.  The SecurityInformation parameter
            // determines what part of the SecurityDescriptor is going to
            // be returned from the ObjectsSecurityDescriptor.
            //

            CurrentThread = PsGetCurrentThread ();
            KeEnterCriticalRegionThread(&CurrentThread->Tcb);
            ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

            oldSecurityDescriptor = deviceObject->SecurityDescriptor;
            if (oldSecurityDescriptor != NULL) {
                ObReferenceSecurityDescriptor( oldSecurityDescriptor, 1 );
            }

            ExReleaseResourceLite( &IopSecurityResource );
            KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

            status = SeQuerySecurityDescriptorInfo( SecurityInformation,
                                                    SecurityDescriptor,
                                                    CapturedLength,
                                                    &oldSecurityDescriptor );

            if (oldSecurityDescriptor != NULL) {
                ObDereferenceSecurityDescriptor( oldSecurityDescriptor, 1 );
            }

        } else {

            //
            // This is a delete operation.  Simply indicate that everything
            // worked just fine.
            //

            status = STATUS_SUCCESS;

        }

    } else if (OperationCode == DeleteSecurityDescriptor) {

        //
        // This is a delete operation for the security descriptor on a file
        // object.  This function will be performed by the file system once
        // the FCB itself is deleted.  Simply indicate that the operation
        // was successful.
        //

        status = STATUS_SUCCESS;

    } else {

        PIRP irp;
        IO_STATUS_BLOCK localIoStatus;
        KEVENT event;
        PIO_STACK_LOCATION irpSp;
        KPROCESSOR_MODE requestorMode;

        //
        // This file object does not refer to the device itself.  Rather, it
        // refers to either a file or a directory on the device.  This means
        // that the request must be passed to the file system for processing.
        // Note that the only requests that are passed through in this manner
        // are SET or QUERY security operations.  DELETE operations have
        // already been taken care of above since the file system which just
        // drop the storage on the floor when it really needs to, and ASSIGN
        // operations are irrelevant to file systems since they never
        // generate one because they never assign the security descriptor
        // to the object in the first place, they just assign it to the FCB.
        //

        CurrentThread = PsGetCurrentThread ();
        requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

        //
        // Begin by referencing the object by pointer.   Note that the object
        // handle has already been checked for the appropriate access by the
        // object system caller.  This reference must be performed because
        // standard I/O completion will dereference the object.
        //

        ObReferenceObject( fileObject );

        //
        // Make a special check here to determine whether this is a synchronous
        // I/O operation.  If it is, then wait here until the file is owned by
        // the current thread.  If this is not a (serialized) synchronous I/O
        // operation, then initialize the local event.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                status = IopAcquireFileObjectLock( fileObject,
                                                   requestorMode,
                                                   (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                                   &interrupted );
                if (interrupted) {
                    ObDereferenceObject( fileObject );
                    return status;
                }
            }
            synchronousIo = TRUE;
        } else {
            KeInitializeEvent( &event, SynchronizationEvent, FALSE );
            synchronousIo = FALSE;
        }

        //
        // Set the file object to the Not-Signaled state.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Get the address of the target device object.
        //

        deviceObject = IoGetRelatedDeviceObject( fileObject );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.  The allocation is performed with an exception handler
        // in case the caller does not have enough quota to allocate the packet.

        irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
        if (!irp) {

            //
            // An IRP could not be allocated.  Cleanup and return an
            // appropriate error status code.
            //

            IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = CurrentThread;
        irp->RequestorMode = requestorMode;

        //
        // Fill in the service independent parameters in the IRP.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            irp->UserEvent = (PKEVENT) NULL;
        } else {
            irp->UserEvent = &event;
            irp->Flags = IRP_SYNCHRONOUS_API;
        }
        irp->UserIosb = &localIoStatus;
        irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

        //
        // Get a pointer to the stack location for the first driver.  This will
        // be used to pass the original function codes and parameters.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Now determine whether this is a set or a query operation.
        //

        if (OperationCode == QuerySecurityDescriptor) {

            //
            // This is a query operation.  Fill in the appropriate fields in
            // the stack location for the packet, as well as the fixed part
            // of the packet.  Note that each of these parameters has been
            // captured as well, so there is no need to perform any probing.
            // The only exception is the UserBuffer memory may change, but
            // that is the file system's responsibility to check.  Note that
            // it has already been probed, so the pointer is at least not
            // in an address space that the caller should not be accessing
            // because of mode.
            //

            irpSp->MajorFunction = IRP_MJ_QUERY_SECURITY;
            irpSp->Parameters.QuerySecurity.SecurityInformation = *SecurityInformation;
            irpSp->Parameters.QuerySecurity.Length = *CapturedLength;
            irp->UserBuffer = SecurityDescriptor;

        } else {

            //
            // This is a set operation.  Fill in the appropriate fields in
            // the stack location for the packet.  Note that access to the
            // SecurityInformation parameter is safe, as the parameter was
            // captured by the caller.  Likewise, the SecurityDescriptor
            // refers to a captured copy of the descriptor.
            //

            irpSp->MajorFunction = IRP_MJ_SET_SECURITY;
            irpSp->Parameters.SetSecurity.SecurityInformation = *SecurityInformation;
            irpSp->Parameters.SetSecurity.SecurityDescriptor = SecurityDescriptor;

        }

        irpSp->FileObject = fileObject;

        //
        // Insert the packet at the head of the IRP list for the thread.
        //

        IopQueueThreadIrp( irp );

        //
        // Update the operation count statistic for the current process for
        // operations other than read and write.
        //

        IopUpdateOtherOperationCount();

        //
        // Everything has been properly set up, so simply invoke the driver.
        //

        status = IoCallDriver( deviceObject, irp );

        //
        // If this operation was a synchronous I/O operation, check the return
        // status to determine whether or not to wait on the file object.  If
        // the file object is to be waited on, wait for the operation to be
        // completed and obtain the final status from the file object itself.
        //

        if (synchronousIo) {
            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &fileObject->Event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
                status = fileObject->FinalStatus;
            }
            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait
            // for the local event and return the final status information
            // back to the caller.
            //

            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
                status = localIoStatus.Status;
            }
        }

        //
        // If this operation was just attempted on a file system or a device
        // driver of some kind that does not implement security, then return
        // a normal null security descriptor.
        //

        if (status == STATUS_INVALID_DEVICE_REQUEST) {

            //
            // The file system does not implement a security policy.  Determine
            // what type of operation this was and implement the correct
            // semantics for the file system.
            //

            if (OperationCode == QuerySecurityDescriptor) {

                //
                // The operation is a query.  If the caller's buffer is too
                // small, then indicate that this is the case and let him know
                // what size buffer is required.  Otherwise, attempt to return
                // a null security descriptor.
                //

               try {
                    status = SeAssignWorldSecurityDescriptor(
                                 SecurityDescriptor,
                                 CapturedLength,
                                 SecurityInformation
                                 );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    //
                    // An exception was incurred while attempting to
                    // access the caller's buffer.  Clean everything
                    // up and return an appropriate status code.
                    //

                    status = GetExceptionCode();
                }

            } else {

                //
                // This was an operation other than a query.  Simply indicate
                // that the operation was successful.
                //

                status = STATUS_SUCCESS;
            }

        } else if (OperationCode == QuerySecurityDescriptor) {

            //
            // The final return status from the file system was something
            // other than invalid device request.  This means that the file
            // system actually implemented the query.  Copy the size of the
            // returned data, or the size of the buffer required in order
            // to query the security descriptor.  Note that once again the
            // assignment is performed inside of an exception handler in case
            // the caller's buffer is inaccessible.  Also note that in order
            // for the Information field of the I/O status block to be set,
            // the file system must return a warning status.  Return the
            // status that the caller expects if the buffer really is too
            // small.
            //

            if (status == STATUS_BUFFER_OVERFLOW) {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            try {

                *CapturedLength = (ULONG) localIoStatus.Information;

            } except( EXCEPTION_EXECUTE_HANDLER ) {
                status = GetExceptionCode();
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\loadunld.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    loadunld.c

Abstract:

    This module contains the code to implement the NtLoadDriver and
    NtUnLoadDriver system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 5-Apr-1992

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtLoadDriver)
#pragma alloc_text(PAGE, NtUnloadDriver)
#endif

NTSTATUS
NtLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    )

/*++

Routine Description:

    This service dynamically loads a device or file system driver into
    the currently running system.  It requires that the caller have the
    appropriate privilege to execute this service.

Arguments:

    DriverServiceName - Specifies the name of the node in the registry
        associated with the driver to be loaded.

Return Value:

    The status returned is the final completion status of the load operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    UNICODE_STRING driverServiceName;
    PWCHAR nameBuffer = (PWCHAR) NULL;
    LOAD_PACKET loadPacket;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so check to ensure that
        // the caller has the privilege to load a driver and probe and
        // capture the name of the driver service entry.
        //

        if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, requestorMode )) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        //
        // The caller has the appropriate privilege to load and unload
        // drivers, so capture the driver service name string so that it
        // can be used to locate the driver from the registry node.
        //

        try {

            driverServiceName = ProbeAndReadUnicodeString( DriverServiceName );

            if (!driverServiceName.Length) {
                return STATUS_INVALID_PARAMETER;
            }

            ProbeForRead( driverServiceName.Buffer,
                          driverServiceName.Length,
                          sizeof( WCHAR ) );

            nameBuffer = ExAllocatePoolWithQuota( PagedPool,
                                                  driverServiceName.Length );

            RtlCopyMemory( nameBuffer,
                           driverServiceName.Buffer,
                           driverServiceName.Length );

            driverServiceName.Buffer = nameBuffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to capture the
            // input name string or while attempting to allocate the name
            // string buffer.  Simply clean everything up and return an
            // appropriate error status code.
            //

            if (nameBuffer) {
                ExFreePool( nameBuffer );
            }
            return GetExceptionCode();
        }
    } else {
        driverServiceName = *DriverServiceName;
    }

    //
    // Because drivers may wish to create a system thread and execute in
    // its context, the remainder of this service must be executed in the
    // context of the primary system process.  This is accomplished by
    // queueing a request to one of the EX worker threads and having it
    // invoke the I/O system routine to complete this work.
    //
    // Fill in a request packet and queue it to the worker thread then, so
    // that it can actually do the load.
    //

    KeInitializeEvent( &loadPacket.Event, NotificationEvent, FALSE );
    loadPacket.DriverObject = (PDRIVER_OBJECT) NULL;
    loadPacket.DriverServiceName = &driverServiceName;

    if (PsGetCurrentProcessByThread(CurrentThread) == PsInitialSystemProcess) {

        //
        // If we are already in the system process, just use this thread.
        //

        IopLoadUnloadDriver(&loadPacket);

    } else {

        ExInitializeWorkItem( &loadPacket.WorkQueueItem,
                              IopLoadUnloadDriver,
                              &loadPacket );

        ExQueueWorkItem( &loadPacket.WorkQueueItem, DelayedWorkQueue );

        KeWaitForSingleObject( &loadPacket.Event,
                               UserRequest,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER) NULL );

    }

    //
    // The load operation is now complete.  If a name buffer was allocated,
    // deallocate it now, and return the final status of the load operation.
    //

    if (nameBuffer) {
         ExFreePool( nameBuffer );
    }

    return loadPacket.FinalStatus;
}

NTSTATUS
IopCheckUnloadDriver(
    IN PDRIVER_OBJECT driverObject,
    OUT PBOOLEAN unloadDriver
    )
{
    PDEVICE_OBJECT deviceObject;
    KIRQL irql;

    //
    // Check to see whether the driver has already been marked for an unload
    // operation by anyone in the past.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if ((driverObject->DeviceObject == NULL &&
        (driverObject->Flags & DRVO_UNLOAD_INVOKED)) ||
        (!(driverObject->Flags & DRVO_BASE_FILESYSTEM_DRIVER) && driverObject->DeviceObject &&
        driverObject->DeviceObject->DeviceObjectExtension->ExtensionFlags
        & DOE_UNLOAD_PENDING)) {

        //
        // The driver has already been marked for unload or is being
        // unloaded.  Simply return a successful completion status since
        // the driver is on its way out and therefore has been "marked for
        // unload".
        //

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

        ObDereferenceObject( driverObject );
        return STATUS_SUCCESS;
    }

    //
    // The driver exists, and it implements unload, and it has not, so far,
    // been marked for an unload operation.  Simply mark all of the devices
    // that the driver owns as being marked for unload.  While this is going
    // on, count the references for each of the devices.  If all of the
    // devices have a zero reference count, then tell the driver that it
    // should unload itself.
    //

    deviceObject = driverObject->DeviceObject;
    *unloadDriver = TRUE;

    while (deviceObject) {
        deviceObject->DeviceObjectExtension->ExtensionFlags |= DOE_UNLOAD_PENDING;
        if (deviceObject->ReferenceCount || deviceObject->AttachedDevice) {
	    *unloadDriver = FALSE;
        }
        deviceObject = deviceObject->NextDevice;
    }

    //
    // If this is a base filesystem driver then delay the unload until all its device objects
    // are deleted.
    // 

    if (driverObject->Flags & DRVO_BASE_FILESYSTEM_DRIVER && driverObject->DeviceObject) {
	    *unloadDriver = FALSE;
    }

    if (*unloadDriver) {
        driverObject->Flags |= DRVO_UNLOAD_INVOKED;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
NtUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    )
{
    return (IopUnloadDriver(DriverServiceName, FALSE));
}

NTSTATUS
IopUnloadDriver(
    IN PUNICODE_STRING DriverServiceName,
    IN BOOLEAN InvokedByPnpMgr
    )
/*++

Routine Description:

    This service dynamically unloads a device or file system driver from
    the currently running system.  It requires that the caller have the
    appropriate privilege to execute this service.

Arguments:

    DriverServiceName - Specifies the name of the node in the registry
        associated with the driver to be unloaded.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    UNICODE_STRING driverServiceName;
    PWCHAR nameBuffer = (PWCHAR) NULL;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE keyHandle;
    UNICODE_STRING driverName;
    HANDLE driverHandle;
    PDRIVER_OBJECT driverObject;
    BOOLEAN unloadDriver;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    if ((requestorMode != KernelMode) && (InvokedByPnpMgr == FALSE)) {

        //
        // The caller's access mode is not kernel so check to ensure that
        // the caller has the privilege to unload a driver and probe and
        // capture the name of the driver service entry.
        //

        if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, requestorMode )) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        //
        // The caller has the appropriate privilege to load and unload
        // drivers, so capture the driver service name string so that it
        // can be used to locate the driver from the registry node.
        //

        try {

            driverServiceName = ProbeAndReadUnicodeString( DriverServiceName );

            if (!driverServiceName.Length) {
                return STATUS_INVALID_PARAMETER;
            }

            ProbeForRead( driverServiceName.Buffer,
                          driverServiceName.Length,
                          sizeof( WCHAR ) );

            nameBuffer = ExAllocatePoolWithQuota( PagedPool,
                                                  driverServiceName.Length );

            RtlCopyMemory( nameBuffer,
                           driverServiceName.Buffer,
                           driverServiceName.Length );

            driverServiceName.Buffer = nameBuffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to capture the
            // input name string or while attempting to allocate the name
            // string buffer.  Simply clean everything up and return an
            // appropriate error status code.
            //

            if (nameBuffer) {
                ExFreePool( nameBuffer );
            }
            return GetExceptionCode();
        }

        //
        // Now that the caller's parameters have been captured and everything
        // appears to have checked out, actually attempt to unload the driver.
        // This is done with a previous mode of kernel so that drivers will
        // not fail to unload because the caller didn't happen to have access
        // to some resource that the driver needs in order to complete its
        // unload operation.
        //

        status = ZwUnloadDriver( &driverServiceName );
        ExFreePool( nameBuffer );
        return status;
    }

    //
    // The caller's mode is now kernel mode.  Attempt to actually unload the
    // driver specified by the indicated registry node.  Begin by opening
    // the registry node for this driver.
    //

    status = IopOpenRegistryKey( &keyHandle,
                                 (HANDLE) NULL,
                                 DriverServiceName,
                                 KEY_READ,
                                 FALSE );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the optional object name for this driver from the value for this
    // key.  If one exists, then its name overrides the default name of the
    // driver.
    //

    status = IopGetDriverNameFromKeyNode( keyHandle,
                                          &driverName );
    NtClose( keyHandle );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Now attempt to open the driver object for the specified driver.
    //

    InitializeObjectAttributes( &objectAttributes,
                                &driverName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ObOpenObjectByName( &objectAttributes,
                                 IoDriverObjectType,
                                 KernelMode,
                                 NULL,
                                 FILE_READ_DATA,
                                 (PVOID) NULL,
                                 &driverHandle );

    //
    // Perform some common cleanup by getting rid of buffers that have been
    // allocated up to this point so that error conditions do not have as
    // much work to do on each exit path.
    //

    ExFreePool( driverName.Buffer );

    //
    // If the driver object could not be located in the first place, then
    // return now before attempting to do anything else.
    //

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // The driver object was located, so convert the handle into a pointer
    // so that the driver object itself can be examined.
    //

    status = ObReferenceObjectByHandle( driverHandle,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode,
                                        (PVOID *) &driverObject,
                                        NULL );
    NtClose( driverHandle );

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Check to see whether or not this driver implements unload.  Also,
    // if the driver has no section associated with it, then it was loaded
    // be the OS loader and therefore cannot be unloaded.  If either is true,
    // return an appropriate error status code.
    //

    if (driverObject->DriverUnload == (PDRIVER_UNLOAD) NULL ||
        !driverObject->DriverSection) {
        ObDereferenceObject( driverObject );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (!InvokedByPnpMgr && !IopIsLegacyDriver(driverObject)) {

        ObDereferenceObject( driverObject );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Check to see whether the driver has already been marked for an unload
    // operation by anyone in the past.
    //

    status = IopCheckUnloadDriver(driverObject,&unloadDriver);

    if ( NT_SUCCESS(status) ) {
        return status;
    }

    if (unloadDriver) {

        if (PsGetCurrentProcess() == PsInitialSystemProcess) {

            //
            // The current thread is alrady executing in the context of the
            // system process, so simply invoke the driver's unload routine.
            //

            driverObject->DriverUnload( driverObject );

        } else {

            //
            // The current thread is not executing in the context of the system
            // process, which is required in order to invoke the driver's unload
            // routine.  Queue a worker item to one of the worker threads to
            // get into the appropriate process context and then invoke the
            // routine.
            //

            LOAD_PACKET loadPacket;

            KeInitializeEvent( &loadPacket.Event, NotificationEvent, FALSE );
            loadPacket.DriverObject = driverObject;
            ExInitializeWorkItem( &loadPacket.WorkQueueItem,
                                  IopLoadUnloadDriver,
                                  &loadPacket );
            ExQueueWorkItem( &loadPacket.WorkQueueItem, DelayedWorkQueue );
            (VOID) KeWaitForSingleObject( &loadPacket.Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }
        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
    }

    //
    // The driver has either been unloaded, or it has successfully been
    // marked for an unload operation.  Simply dereference the pointer to
    // the object and return success.
    //

    ObDereferenceObject( driverObject );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\misc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the code to implement the NtFlushBuffersFile,
    NtSetNewSizeFile, IoQueueWorkItem, and NtCancelIoFile system services
    for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 22-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

//
// Local function prototypes follow
//

VOID
IopProcessWorkItem(
    IN PVOID Parameter
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtCancelIoFile)
#pragma alloc_text(PAGE, NtDeleteFile)
#pragma alloc_text(PAGE, NtFlushBuffersFile)
#pragma alloc_text(PAGE, NtQueryAttributesFile)
#pragma alloc_text(PAGE, NtQueryFullAttributesFile)
#pragma alloc_text(PAGE, IopProcessWorkItem)
#endif


NTSTATUS
NtCancelIoFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This service causes all pending I/O operations for the specified file to be
    marked as canceled.  Most types of operations can be canceled immediately,
    while others may continue toward completion before they are actually
    canceled and the caller is notified.

    Only those pending operations that were issued by the current thread using
    the specified handle are canceled.  Any operations issued for the file by
    any other thread or any other process continues normally.

Arguments:

    FileHandle - Supplies a handle to the file whose operations are to be
        canceled.

    IoStatusBlock - Address of the caller's I/O status block.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    KPROCESSOR_MODE requestorMode;
    PETHREAD thread;
    BOOLEAN found = FALSE;
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    KIRQL irql;

    PAGED_CODE();


    //
    // Get the address of the current thread.  The thread contains a list of
    // the pending operations for this file.
    //

    thread = PsGetCurrentThread();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousModeByThread(&thread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred attempting to probe the caller'
            // I/O status block.  Simply return an appropriate error status
            // code.
            //

            return GetExceptionCode();
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return(status);
    }

    //
    // Note that here the I/O system would normally make a check to determine
    // whether or not the file was opened for synchronous I/O.  If it was, then
    // it would attempt to exclusively acquire the file object lock.  However,
    // since this service is attempting to cancel all of the I/O for the file,
    // it does not make much sense to wait until it has all completed before
    // attempting to cancel it.
    //


    //
    // Update the operation count statistic for the current process for
    // operations other than read and write.
    //

    IopUpdateOtherOperationCount();

    //
    // Walk the list of IRPs on the thread's pending I/O queue looking for IRPs
    // which specify the same file as the FileHandle refers to.  For each IRP
    // found, set its cancel flag.  If no IRPs are found, simply complete the
    // I/O here.  The only synchronization needed here is to block out all APCs
    // for this thread so that no I/O can complete and remove packets from the
    // queue.  No considerations need be made for multi-processing since this
    // thread can only be running on one processor at a time and this routine
    // has control of the thread for now.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    header = &thread->IrpList;
    entry = thread->IrpList.Flink;

    while (header != entry) {

        //
        // An IRP has been found for this thread.  If the IRP refers to the
        // appropriate file object, set its cancel flag and remember that it
        // was found;  otherwise, simply continue the loop.
        //

        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        if (irp->Tail.Overlay.OriginalFileObject == fileObject) {
            found = TRUE;
            IoCancelIrp( irp );
        }

        entry = entry->Flink;
    }

    //
    // Lower the IRQL back down to what it was on entry to this procedure.
    //

    KeLowerIrql( irql );

    if (found) {

        LARGE_INTEGER interval;

        //
        // Delay execution for a time and let the request
        // finish.  The delay time is 10ms.
        //

        interval.QuadPart = -10 * 1000 * 10;

        //
        // Wait for a while so the canceled requests can complete.
        //

        while (found) {

            (VOID) KeDelayExecutionThread( KernelMode, FALSE, &interval );

            found = FALSE;

            //
            // Raise the IRQL to prevent modification to the IRP list by the
            // thread's APC routine.
            //

            KeRaiseIrql( APC_LEVEL, &irql );

            //
            // Check the IRP list for requests which refer to the specified
            // file object.
            //

            entry = thread->IrpList.Flink;

            while (header != entry) {

                //
                // An IRP has been found for this thread.  If the IRP refers
                // to the appropriate file object,  remember that it
                // was found;  otherwise, simply continue the loop.
                //

                irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
                if (irp->Tail.Overlay.OriginalFileObject == fileObject) {
                    found = TRUE;
                    break;
                }

                entry = entry->Flink;
            }

            //
            // Lower the IRQL back down to what it was on entry to this procedure.
            //

            KeLowerIrql( irql );

        }
    }

    try {

        //
        // Write the status back to the user.
        //

        IoStatusBlock->Status = STATUS_SUCCESS;
        IoStatusBlock->Information = 0L;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred attempting to write the caller's
        // I/O status block; however, the service completed sucessfully so
        // just return sucess.
        //

    }

    //
    // Dereference the file object.
    //

    ObDereferenceObject( fileObject );

    return STATUS_SUCCESS;
}

NTSTATUS
NtDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This service deletes the specified file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    HANDLE handle;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    //
    // Build a parse open packet that tells the parse method to open the file
    // for open for delete access w/the delete bit set, and then close it.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.CreateOptions = FILE_DELETE_ON_CLOSE;
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.DeleteOnly = TRUE;
    openPacket.TraversedMountPoint = FALSE;
    openPacket.LocalFileObject = &localFileObject;

    //
    // Update the open count for this process.
    //

    IopUpdateOtherOperationCount();

    //
    // Open the object by its name.  Because of the special DeleteOnly flag
    // set in the open packet, the parse routine will open the file, and
    // then realize that it is only deleting the file, and will therefore
    // immediately dereference the file.  This will cause the cleanup and
    // the close to be sent to the file system, thus causing the file to
    // be deleted.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 requestorMode,
                                 NULL,
                                 DELETE,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        return status;
    } else {
        return openPacket.FinalStatus;
    }
}

NTSTATUS
NtFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This service causes all buffered data to the file to be written.

Arguments:

    FileHandle - Supplies a handle to the file whose buffers should be flushed.

    IoStatusBlock - Address of the caller's I/O status block.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    OBJECT_HANDLE_INFORMATION objectHandleInformation;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred attempting to probe the caller's
            // I/O status block.  Simply return an appropriate error status
            // code.
            //

            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &objectHandleInformation );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Ensure that the caller has either WRITE or APPEND access to the file
    // before allowing this call to continue.  This is especially important
    // if the caller opened a volume, where a flush operation may flush more
    // than what this opener has written to buffers.  Note however that if
    // this is a pipe, then the APPEND access cannot be made since this
    // access code is overlaid with the CREATE_PIPE_INSTANCE access.
    //

    if (SeComputeGrantedAccesses( objectHandleInformation.GrantedAccess,
                                  (!(fileObject->Flags & FO_NAMED_PIPE) ?
                                  FILE_APPEND_DATA : 0) |
                                  FILE_WRITE_DATA ) == 0) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An exception was incurred while attempting to allocate the IRP.
        // Cleanup and return an appropriate error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This is used
    // to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    irpSp->FileObject = fileObject;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtQueryAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    )

/*++

Routine Description:

    This service queries the basic attributes information for a specified file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    FileInformation - Supplies an output buffer to receive the returned file
        attributes information.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    FILE_NETWORK_OPEN_INFORMATION networkInformation;
    HANDLE handle;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {

        try {

            //
            // The caller's mode is not kernel, so probe the output buffer.
            //

            ProbeForWriteSmallStructure( FileInformation,
                                         sizeof( FILE_BASIC_INFORMATION ),
                                         sizeof( ULONG_PTR ));

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();
        }
    }

    //
    // Build a parse open packet that tells the parse method to open the file,
    // query the file's basic attributes, and close the file.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.CreateOptions = FILE_OPEN_REPARSE_POINT|FILE_OPEN_FOR_BACKUP_INTENT;
    openPacket.BasicInformation = FileInformation;
    openPacket.NetworkInformation = &networkInformation;
    openPacket.QueryOnly = TRUE;
    openPacket.TraversedMountPoint = FALSE;
    openPacket.LocalFileObject = &localFileObject;

    //
    // Update the open count for this process.
    //

    IopUpdateOtherOperationCount();

    //
    // Open the object by its name.  Because of the special QueryOnly flag set
    // in the open packet, the parse routine will open the file, and then
    // realize that it is only performing a query.  It will therefore perform
    // the query, and immediately close the file.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 requestorMode,
                                 NULL,
                                 FILE_READ_ATTRIBUTES,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        return status;
    } else {
        return openPacket.FinalStatus;
    }
}

NTSTATUS
NtQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    )

/*++

Routine Description:

    This service queries the network attributes information for a specified
    file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    FileInformation - Supplies an output buffer to receive the returned file
        attributes information.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    FILE_NETWORK_OPEN_INFORMATION networkInformation;
    HANDLE handle;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {

        try {

            //
            // The caller's mode is not kernel, so probe the output buffer.
            //

            ProbeForWriteSmallStructure( FileInformation,
                                         sizeof( FILE_NETWORK_OPEN_INFORMATION ),
#if defined(_X86_)
                                         sizeof( LONG ));
#else
                                         sizeof( LONGLONG ));
#endif // defined(_X86_)

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();
        }
    }

    //
    // Build a parse open packet that tells the parse method to open the file,
    // query the file's full attributes, and close the file.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.CreateOptions = FILE_OPEN_REPARSE_POINT|FILE_OPEN_FOR_BACKUP_INTENT;
    openPacket.QueryOnly = TRUE;
    openPacket.FullAttributes = TRUE;
    openPacket.TraversedMountPoint = FALSE;
    openPacket.LocalFileObject = &localFileObject;
    if (requestorMode != KernelMode) {
        openPacket.NetworkInformation = &networkInformation;
    } else {
        openPacket.NetworkInformation = FileInformation;
    }

    //
    // Update the open count for this process.
    //

    IopUpdateOtherOperationCount();

    //
    // Open the object by its name.  Because of the special QueryOnly flag set
    // in the open packet, the parse routine will open the file, and then
    // realize that it is only performing a query.  It will therefore perform
    // the query, and immediately close the file.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 requestorMode,
                                 NULL,
                                 FILE_READ_ATTRIBUTES,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        return status;
    } else {
        status = openPacket.FinalStatus;
    }

    if (NT_SUCCESS( status )) {
        if (requestorMode != KernelMode) {
            try {

                //
                // The query worked, so copy the returned information to the
                // caller's output buffer.
                //

                RtlCopyMemory( FileInformation,
                               &networkInformation,
                               sizeof( FILE_NETWORK_OPEN_INFORMATION ) );

            } except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }
        }
    }

    return status;
}

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    )
{
    PIO_WORKITEM ioWorkItem;
    PWORK_QUEUE_ITEM exWorkItem;

    //
    // Allocate a new workitem structure.
    // 

    ioWorkItem = ExAllocatePool( NonPagedPool, sizeof( IO_WORKITEM ));
    if (ioWorkItem != NULL) {

        //
        // Initialize the invariant portions of both ioWorkItem and
        // exWorkItem.
        //

#if DBG
        ioWorkItem->Size = sizeof( IO_WORKITEM );
#endif

        ioWorkItem->DeviceObject = DeviceObject;

        exWorkItem = &ioWorkItem->WorkItem;
        ExInitializeWorkItem( exWorkItem, IopProcessWorkItem, ioWorkItem );
    }

    return ioWorkItem;
}

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    )

/*++

Routine Description:

    This function is the "wrapper" routine for IoQueueWorkItem.  It calls
    the original worker function, then dereferences the device object to
    (possibly) allow the driver object to go away.

Arguments:

    Parameter - Supplies a pointer to an IO_WORKITEM for us to process.

Return Value:

    None

--*/

{
    ASSERT( IoWorkItem->Size == sizeof( IO_WORKITEM ));

    ExFreePool( IoWorkItem );
}

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    )
/*++

Routine Description:

    This function inserts a work item into a work queue that is processed
    by a worker thread of the corresponding type.  It effectively
    "wraps" ExQueueWorkItem, ensuring that the device object is referenced
    for the duration of the call.

Arguments:

    IoWorkItem - Supplies a pointer to the work item to add the the queue.
        This structure must have been allocated via IoAllocateWorkItem().

    WorkerRoutine - Supplies a pointer to the routine that is to be called
        in system thread context.

    QueueType - Specifies the type of work queue that the work item
        should be placed in.

    Context - Supplies the context parameter for the callback routine.

Return Value:

    None

--*/

{
    PWORK_QUEUE_ITEM exWorkItem;

    ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );
    ASSERT( IoWorkItem->Size == sizeof( IO_WORKITEM ));

    //
    // Keep a reference on the device object so it doesn't go away.
    //

    ObReferenceObject( IoWorkItem->DeviceObject );

    //
    // Initialize the fields in IoWorkItem
    //

    IoWorkItem->Routine = WorkerRoutine;
    IoWorkItem->Context = Context;

    //
    // Get a pointer to the ExWorkItem, queue it, and return.
    // IopProcessWorkItem() will perform the dereference.
    // 

    exWorkItem = &IoWorkItem->WorkItem;
    ExQueueWorkItem( exWorkItem, QueueType );
}

VOID
IopProcessWorkItem(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This function is the "wrapper" routine for IoQueueWorkItem.  It calls
    the original worker function, then dereferences the device object to
    (possibly) allow the driver object to go away.

Arguments:

    Parameter - Supplies a pointer to an IO_WORKITEM for us to process.

Return Value:

    None

--*/

{
    PIO_WORKITEM ioWorkItem;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the ioWorkItem and store a copy of DeviceObject
    // locally.  This allow us to function properly if the worker routine
    // elects to free the work item.
    //

    ioWorkItem = (PIO_WORKITEM)Parameter;
    deviceObject = ioWorkItem->DeviceObject;

    //
    // Call the original worker.
    //

    ioWorkItem->Routine( deviceObject,
                         ioWorkItem->Context );

    //
    // Now we can dereference the device object, since its code is no longer
    // being executed for this work item.
    //

    ObDereferenceObject( deviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\parse.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This module contains the code to implement the device object parse routine.

Author:

    Darryl E. Havens (darrylh) 15-May-1988

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

//
// Define macro to round up the size of a name for buffer optimization.
//

#define RoundNameSize( Length ) ( \
    (Length < 64 - 8) ? 64 - 8 :  \
    (Length < 128 - 8) ? 128 - 8 :\
    (Length < 256 - 8) ? 256 - 8 : Length )

#define IO_MAX_REMOUNT_REPARSE_ATTEMPTS 32

NTSTATUS
IopGetNetworkOpenInformation(
    IN  PFILE_OBJECT    FileObject,
    IN  POPEN_PACKET    Op
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopParseFile)
#pragma alloc_text(PAGE, IopParseDevice)
#pragma alloc_text(PAGE, IopQueryName)
#pragma alloc_text(PAGE, IopQueryNameInternal)
#pragma alloc_text(PAGE, IopCheckBackupRestorePrivilege)
#pragma alloc_text(PAGE, IopGetNetworkOpenInformation)
#endif

NTSTATUS
IopCheckDeviceAndDriver(
    POPEN_PACKET op,
    PDEVICE_OBJECT parseDeviceObject
    )
{
    NTSTATUS status;
    KIRQL irql;

    //
    // Make sure that the device and its driver are really there and they are
    // going to stay there.  The object itself cannot go away just yet because
    // the object management system has performed a reference which bumps the
    // count of the number of reasons why the object must stick around.
    // However, the driver could be attempting to unload itself, so perform
    // this check.  If the driver is being unloaded, then set the final status
    // of the operation to "No such device" and return with a NULL file object
    // pointer.
    //
    // Note that it is possible to "open" an exclusive device more than once
    // provided that the caller is performing a relative open.  This feature
    // is how users "allocate" a device, and then use it to perform operations.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if (parseDeviceObject->DeviceObjectExtension->ExtensionFlags &
            (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED | DOE_START_PENDING) ||
        parseDeviceObject->Flags & DO_DEVICE_INITIALIZING) {

        status = STATUS_NO_SUCH_DEVICE;

    } else if (parseDeviceObject->Flags & DO_EXCLUSIVE &&
               parseDeviceObject->ReferenceCount != 0 &&
               op->RelatedFileObject == NULL &&
               !(op->Options & IO_ATTACH_DEVICE)) {

        status = STATUS_ACCESS_DENIED;

    } else {

        parseDeviceObject->ReferenceCount++;
        status = STATUS_SUCCESS;

    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return status;
}

PVPB
IopCheckVpbMounted(
    IN POPEN_PACKET op,
    IN PDEVICE_OBJECT parseDeviceObject,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PNTSTATUS status
    )
{
    PVPB vpb;
    PVPB mountVpb;
    KIRQL irql;
    BOOLEAN alertable;

    //
    // Loop here until the VPB_MOUNTED test can be passed while holding the
    // VPB spinlock.  After the mount succeeds, it is still necessary to acquire
    // the spinlock to check that the VPB (which may be different from the one
    // before the mount) is still mounted.  If it is, then its reference count
    // is incremented before releasing the spinlock.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );

    alertable = (op->CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) ? TRUE : FALSE;
    while (!(parseDeviceObject->Vpb->Flags & VPB_MOUNTED)) {

        KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );

        //
        // Try to mount the volume, allowing only RAW to perform the mount if
        // this is a DASD open.
        //

        mountVpb = NULL;
        *status = IopMountVolume( parseDeviceObject,
                                 (BOOLEAN) (!RemainingName->Length && !op->RelatedFileObject),
                                 FALSE,
                                 alertable,
                                 &mountVpb );
        //
        // If the mount operation was unsuccessful, adjust the reference
        // count for the device and return now.
        //

        if (!NT_SUCCESS( *status ) || *status == STATUS_USER_APC || *status == STATUS_ALERTED) {

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (!NT_SUCCESS( *status )) {
                return NULL;
            } else {
                *status = STATUS_WRONG_VOLUME;
                return NULL;
            }
        } else {

            //
            // In this case IopMountVolume did the synchronization already.
            //

            if (mountVpb) {
                return mountVpb;
            }
        }

        irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    }

    //
    // Synchronize here with the file system to make sure that volumes do not
    // go away while en route to the FS.
    //

    vpb = parseDeviceObject->Vpb;

    //
    //  Check here that the VPB is not locked.
    //

    if (vpb->Flags & VPB_LOCKED) {

        *status = STATUS_ACCESS_DENIED;
        vpb = NULL;

    } else {

        vpb->ReferenceCount += 1;
    }

    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );

    //
    // This is because VPB is locked.
    // Do the decrement outside the VPB lock because of possible deadlocks.
    //

    if (!vpb) {
        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );
    }

    return vpb;
}

VOID
IopDereferenceVpbAndFree(
    IN PVPB Vpb
    )
{
    KIRQL irql;
    PVPB vpb = (PVPB) NULL;

    irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    Vpb->ReferenceCount--;
    if ((Vpb->ReferenceCount == 0) &&
        (Vpb->RealDevice->Vpb != Vpb) &&
        !(Vpb->Flags & VPB_PERSISTENT)) {
        vpb = Vpb;
    }
    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );
    if (vpb) {
        ExFreePool( vpb );
    }
}



NTSTATUS
IopParseDevice(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and the
    name translates to a device object.  This routine is specified as the parse
    routine for all device objects.

    In the normal case of an NtCreateFile, the user specifies either the name
    of a device or of a file.  In the former situation, this routine is invoked
    with a pointer to the device and a null ("") string.  For this case, the
    routine simply allocates an IRP, fills it in, and passes it to the driver
    for the device.  The driver will then perform whatever rudimentary functions
    are necessary and will return a status code indicating whether an error was
    incurred.  This status code is remembered in the Open Packet (OP).

    In the latter situation, the name string to be opened/created is non-null.
    That is, it contains the remainder of the pathname to the file that is to
    be opened or created.  For this case, the routine allocates an IRP, fills
    it in, and passes it to the driver for the device.  The driver may then
    need to take further action or it may complete the request immediately.  If
    it needs to perform some work asynchronously, then it can queue the request
    and return a status of STATUS_PENDING.  This allows this routine and its
    caller to return to the user so that he can continue.  Otherwise, the open/
    create is basically finished.

    If the driver supports symbolic links, then it is also possible for the
    driver to return a new name.  This name will be returned to the Object
    Manager as a new name to look up.  The parsing will then begin again from
    the start.

    It is also the responsibility of this routine to create a file object for
    the file, if the name specifies a file.  The file object's address is
    returned to the NtCreateFile service through the OP.

Arguments:

    ParseObject - Pointer to the device object the name translated into.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    SecurityQos - Optional security quality of service indicator.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{


    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    POPEN_PACKET op;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    IO_SECURITY_CONTEXT securityContext;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT parseDeviceObject;
    BOOLEAN directDeviceOpen;
    PVPB vpb;
    ACCESS_MASK desiredAccess;
    PDUMMY_FILE_OBJECT localFileObject;
    BOOLEAN realFileObjectRequired;
    KPROCESSOR_MODE modeForPrivilegeCheck;
    ULONG retryCount = 0;
    BOOLEAN  relativeVolumeOpen = FALSE;     // True if opening a filesystem volume
    PETHREAD CurrentThread;
    ULONG returnedLength;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

reparse_loop:

    //
    // Assume failure by setting the returned object pointer to NULL.
    //

    *Object = (PVOID) NULL;

    //
    // Get the address of the Open Packet (OP).
    //

    op = Context;

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {

        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Obtain a pointer to the parse object as a device object, which is the
    // actual type of the object anyway.
    //

    parseDeviceObject = (PDEVICE_OBJECT) ParseObject;

    //
    // If we passed through a mountpoint do an extra set of validation checks
    // that we don't go to a remote device. We really have to let the object manager
    // open the new path. If we fail it in the path that obtains the reparse point and 
    // validates the name (using IoIsValidNameGraftingBuffer) its not sufficient. This is because
    // the path may be valid at that time and change before OB does the reparse. 
    //

    if (op->TraversedMountPoint) {

        ASSERT (op->Information == IO_REPARSE_TAG_MOUNT_POINT);

        if ((parseDeviceObject->DeviceType != FILE_DEVICE_DISK) &&
            (parseDeviceObject->DeviceType != FILE_DEVICE_CD_ROM) &&
            (parseDeviceObject->DeviceType != FILE_DEVICE_TAPE)) {

            status = STATUS_IO_REPARSE_DATA_INVALID;
            return op->FinalStatus = status;
        }
    }

    //
    // If this is a relative open, then get the device on which the file
    // is really being opened from the related file object and use that for
    // the remainder of this function and for all operations performed on
    // the file object that is about to be created.
    //

    if (op->RelatedFileObject) {
        parseDeviceObject = op->RelatedFileObject->DeviceObject;
    }

    //
    // Make sure that the device and its driver are really there and they are
    // going to stay there.  The object itself cannot go away just yet because
    // the object management system has performed a reference which bumps the
    // count of the number of reasons why the object must stick around.
    // However, the driver could be attempting to unload itself, so perform
    // this check.  If the driver is being unloaded, then set the final status
    // of the operation to "No such device" and return with a NULL file object
    // pointer.
    //
    // Note that it is possible to "open" an exclusive device more than once
    // provided that the caller is performing a relative open.  This feature
    // is how users "allocate" a device, and then use it to perform operations.
    //

    status = IopCheckDeviceAndDriver( op, parseDeviceObject );

    if (!NT_SUCCESS(status)) {
        return op->FinalStatus = status;
    }

    //
    // Since ObOpenObjectByName is called without being passed
    // any object type information, we need to map the generic
    // bits in the DesiredAccess mask here.  We also need to save
    // the object's generic mapping in the access state structure
    // here, because this is the earliest opportunity we have
    // to do so.
    //

    RtlMapGenericMask( &AccessState->RemainingDesiredAccess,
                       &IoFileObjectType->TypeInfo.GenericMapping );

    RtlMapGenericMask( &AccessState->OriginalDesiredAccess,
                       &IoFileObjectType->TypeInfo.GenericMapping );

    SeSetAccessStateGenericMapping( AccessState, &IoFileObjectType->TypeInfo.GenericMapping );

    desiredAccess = AccessState->RemainingDesiredAccess;

    //
    // Compute the previous mode to be passed in to the privilege check
    //

    if (AccessMode != KernelMode || op->Options & IO_FORCE_ACCESS_CHECK) {
        modeForPrivilegeCheck = UserMode;
    } else {
        modeForPrivilegeCheck = KernelMode;
    }

    IopCheckBackupRestorePrivilege( AccessState,
                                    &op->CreateOptions,
                                    modeForPrivilegeCheck,
                                    op->Disposition
                                    );

    //
    // If this is not the first time through here for this object, and the
    // object itself is being opened, then the desired access must also
    // include the previously granted access from the last pass.  Likewise,
    // if the privileges have been checked already, then this is another
    // pass through for a file, so add in the previously granted access.
    //

    if ((op->Override && !RemainingName->Length) ||
        AccessState->Flags & SE_BACKUP_PRIVILEGES_CHECKED) {
        desiredAccess |= AccessState->PreviouslyGrantedAccess;
    }

    //
    // If its a filesystem volume open and we are doing a relative open to it
    // then do the access check. Note that relative opens can be nested and we propagate
    // the fact that the relative open is for a volume using the FO_VOLUME_OPEN flag.
    //

    if (op->RelatedFileObject) {
        if ((op->RelatedFileObject->Flags & FO_VOLUME_OPEN) && RemainingName->Length == 0) {
            relativeVolumeOpen = TRUE;
        }
    }

    //
    // Now determine what type of security check should be made.  This is
    // based on whether the remaining name string is null.  If it is null,
    // then the device itself is being opened, so a full security check is
    // performed.  Otherwise, only a check to ensure that the caller can
    // traverse the device object is made.  Note that these checks are only
    // made if the caller's mode is user, or if access checking is being
    // forced.  Note also that if an access check was already made on the
    // device itself, and this code is being executed again because of a
    // reparse, then the access check need not be made the second time
    // around.
    //


    if ((AccessMode != KernelMode || op->Options & IO_FORCE_ACCESS_CHECK) &&
        (!op->RelatedFileObject || relativeVolumeOpen) &&
        !op->Override) {

        BOOLEAN subjectContextLocked = FALSE;
        BOOLEAN accessGranted;
        ACCESS_MASK grantedAccess;

        //
        // The caller's mode is either user or access checking is being
        // forced.  Perform the appropriate access check on the device
        // object.
        //

        if (!RemainingName->Length) {

            UNICODE_STRING nameString;
            PPRIVILEGE_SET privileges = NULL;

            //
            // The device itself is being opened.  Make a full security check
            // to ensure that the caller has the appropriate access.
            //

            KeEnterCriticalRegionThread( &CurrentThread->Tcb );
            ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

            SeLockSubjectContext( &AccessState->SubjectSecurityContext );
            subjectContextLocked = TRUE;

            accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                           &AccessState->SubjectSecurityContext,
                                           subjectContextLocked,
                                           desiredAccess,
                                           0,
                                           &privileges,
                                           &IoFileObjectType->TypeInfo.GenericMapping,
                                           UserMode,
                                           &grantedAccess,
                                           &status );

            if (privileges) {
                (VOID) SeAppendPrivileges( AccessState,
                                           privileges );
                SeFreePrivileges( privileges );
            }

            if (accessGranted) {
                AccessState->PreviouslyGrantedAccess |= grantedAccess;
                AccessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
                op->Override = TRUE;
            }

            nameString.Length = 8;
            nameString.MaximumLength = 8;
            nameString.Buffer = L"File";

            SeOpenObjectAuditAlarm( &nameString,
                                    parseDeviceObject,
                                    CompleteName,
                                    parseDeviceObject->SecurityDescriptor,
                                    AccessState,
                                    FALSE,
                                    accessGranted,
                                    UserMode,
                                    &AccessState->GenerateOnClose );

            ExReleaseResourceLite( &IopSecurityResource );
            KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

        } else {

            //
            // The device is not being opened, rather, a file on the device
            // is being opened or created.  Therefore, only perform a check
            // here for traverse access to the device.
            //

            //
            // First determine if we have to perform traverse checking at all.
            // Traverse checking only needs to be done if the device being
            // traversed is a disk, or if the caller does not already have
            // traverse checking privilege.  Note that the former case is so
            // that an administrator can turn off access to the "system
            // partition", or someone would be able to install a trojan horse
            // into the system by simply replacing one of the files there with
            // something of their own.
            //

            if (!(AccessState->Flags & TOKEN_HAS_TRAVERSE_PRIVILEGE) ||
                parseDeviceObject->DeviceType == FILE_DEVICE_DISK ||
                parseDeviceObject->DeviceType == FILE_DEVICE_CD_ROM ) {

                KeEnterCriticalRegionThread( &CurrentThread->Tcb );
                ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

                //
                // If the token is restricted we need to do the full
                // access check.
                //

                if ((AccessState->Flags & TOKEN_IS_RESTRICTED) == 0) {
                    accessGranted = SeFastTraverseCheck( parseDeviceObject->SecurityDescriptor,
                                                         FILE_TRAVERSE,
                                                         UserMode );
                } else {
                    accessGranted = FALSE;
                }

                if (!accessGranted) {

                    PPRIVILEGE_SET privileges = NULL;

                    //
                    // The caller was not granted traverse access through the
                    // normal fast path lookup.  Perform a full-blown access
                    // check to determine whether some other ACE allows traverse
                    // access.
                    //

                    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

                    subjectContextLocked = TRUE;

                    accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                                   &AccessState->SubjectSecurityContext,
                                                   subjectContextLocked,
                                                   FILE_TRAVERSE,
                                                   0,
                                                   &privileges,
                                                   &IoFileObjectType->TypeInfo.GenericMapping,
                                                   UserMode,
                                                   &grantedAccess,
                                                   &status );

                    if (privileges) {

                        (VOID) SeAppendPrivileges( AccessState,
                                                   privileges );
                        SeFreePrivileges( privileges );
                    }

                }

                ExReleaseResourceLite( &IopSecurityResource );
                KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

            } else {

                    accessGranted = TRUE;
            }
        }

        //
        // Unlock the subject's security context so that it can be changed,
        // if it was locked.
        //

        if (subjectContextLocked) {
            SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
        }

        //
        // Finally, determine whether or not access was granted to the device.
        // If not, clean everything up and get out now without even invoking
        // the device driver.
        //

        if (!accessGranted) {

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );
            return STATUS_ACCESS_DENIED;
        }

    }

    realFileObjectRequired = !(op->QueryOnly || op->DeleteOnly);

    if (RemainingName->Length == 0 &&
        op->RelatedFileObject == NULL &&
        ((desiredAccess & ~(SYNCHRONIZE |
                            FILE_READ_ATTRIBUTES |
                            READ_CONTROL |
                            ACCESS_SYSTEM_SECURITY |
                            WRITE_OWNER |
                            WRITE_DAC)) == 0) &&
        realFileObjectRequired) {

        //
        // If the name of the object being opened is just the name of the
        // device itself, and there is no related file object, and the caller
        // is opening the device for only read attributes access, then this
        // device will not be mounted.  This allows applications to obtain
        // attributes about the device without actually mounting it.
        //
        // Note that if this *is* a direct device open, then the normal path
        // through the I/O system and drivers may never be used, even if
        // the device appears to be mounted.  This is because the user may
        // remove the media from the drive (even though it is mounted), and
        // now attempting to determine what type of drive it is will still
        // fail, this time very hard, because a whole mount process is now
        // required, thus defeating this feature.
        //

        directDeviceOpen = TRUE;

    } else {

        //
        // Otherwise, this is a normal open of a file, directory, device, or
        // volume.
        //

        directDeviceOpen = FALSE;
    }

    //
    // There are now five different cases.  These are as follows:
    //
    //    1)  This is a relative open, in which case we want to send the
    //        request to then same device that opened the relative file object.
    //
    //    2)  The VPB pointer in the device object is NULL.  This means that
    //        this device does not support a file system.  This includes
    //        devices such as terminals, etc.
    //
    //    3)  The VPB pointer in the device object is not NULL and:
    //
    //        a)  The VPB is "blank".  That is, the VPB has never been filled
    //            in, which means that the device has never been mounted.
    //
    //        b)  The VPB is non-blank, but the verify flag on the device is
    //            set, indicating that the door to the drive may have been
    //            opened and the media may therefore have been changed.
    //
    //        c)  The VPB is non-blank and the verify flag is not set.
    //
    //        Both of the latter are not explicitly checked for, as #c is
    //        the normal case, and #b is the responsibility of the file
    //        system to check.
    //

    //
    //  If this is a file system that supports volumes, vpbRefCount will
    //  be filled in to point to the reference count in the Vpb.  Error
    //  exits paths later on key off this value to see if they should
    //  decrement the ref count.  Note that a direct device open does not
    //  make it to the file system, so no increment is needed, and no
    //  decrement will be performed in objsup.c IopDeleteFile().
    //

    vpb = NULL;

    //
    // If the related open was a direct device open then we should go through the full mount
    // path for this open as this may not be a direct device open.
    //
    if (op->RelatedFileObject && (!(op->RelatedFileObject->Flags & FO_DIRECT_DEVICE_OPEN))) {

        deviceObject = (PDEVICE_OBJECT)ParseObject;

        if (op->RelatedFileObject->Vpb) {

            vpb = op->RelatedFileObject->Vpb;

            //
            // Synchronize here with the file system to make sure that
            // volumes don't go away while en route to the FS.
            //

            IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                          &vpb->ReferenceCount);
        }

    } else {

        deviceObject = parseDeviceObject;

        if (parseDeviceObject->Vpb && !directDeviceOpen) {
            vpb = IopCheckVpbMounted( op,
                                      parseDeviceObject,
                                      RemainingName,
                                      &status );
            //
            // Device object reference is decremented in IopCheckVpbMounted.
            //

            if ( !vpb ) {
                return status;
            }

            //
            // Set the address of the device object associated with the VPB.
            //

            deviceObject = vpb->DeviceObject;
        }


        //
        // If the top deviceobject hint is set use the hint if possible.
        //

        if (op->InternalFlags & IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT) {

            //
            // You cannot use the device object hint if you are trying to
            // open the device directly or if you are dealing with a device
            // that is not a file system.  In these cases, return an error.
            //

            if (directDeviceOpen ||
                (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
                 deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
                 deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
                 deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
                 deviceObject->DeviceType != FILE_DEVICE_DFS_FILE_SYSTEM)) {

                if (vpb) {
                    IopDereferenceVpbAndFree( vpb );
                }
                
                IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

                return STATUS_INVALID_PARAMETER;
            }

            if  (IopVerifyDeviceObjectOnStack(deviceObject, op->TopDeviceObjectHint)) {

                deviceObject = op->TopDeviceObjectHint;

            } else {
                if (vpb) {
                    IopDereferenceVpbAndFree(vpb);
                }

                IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

                if (op->TraversedMountPoint) {
                    op->TraversedMountPoint = FALSE;
                    return STATUS_MOUNT_POINT_NOT_RESOLVED;
                } else {
                    return STATUS_INVALID_DEVICE_OBJECT_PARAMETER;
                }
            }

        } else {

            //
            // Walk the attached device list.
            //

            if (deviceObject->AttachedDevice) {
                deviceObject = IoGetAttachedDevice( deviceObject );
            }
        }
    }

    //
    //  If the TraversedMountPoint flag is still set, clear it now.  We needed
    //  to keep it to return the correct status if IopVerifyDeviceObjectOnStack
    //  failed above.
    //
    
    if (op->TraversedMountPoint) {
        op->TraversedMountPoint = FALSE;
    }
    
    //
    //  If the driver says that the IO manager should do the access checks, lets do it here.
    //  We do the check against the parse device object as that device object has a name
    //  and we can set an ACL against it.
    //  We only worry about related opens of devices as the other case is taken care of in the
    //  filesystem.
    //
    if ((deviceObject->Characteristics & FILE_DEVICE_SECURE_OPEN) &&
        (op->RelatedFileObject || RemainingName->Length) &&  (!relativeVolumeOpen)) {

        BOOLEAN subjectContextLocked = FALSE;
        BOOLEAN accessGranted;
        ACCESS_MASK grantedAccess;
        UNICODE_STRING nameString;
        PPRIVILEGE_SET privileges = NULL;

        //
        // If the device wants to ensure secure opens then lets check the two
        // cases which were skipped earlier. These cases are if its a relative
        // open or if there are trailing names.
        //

        KeEnterCriticalRegionThread( &CurrentThread->Tcb );
        ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

        SeLockSubjectContext( &AccessState->SubjectSecurityContext );
        subjectContextLocked = TRUE;

        accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                       &AccessState->SubjectSecurityContext,
                                       subjectContextLocked,
                                       desiredAccess,
                                       0,
                                       &privileges,
                                       &IoFileObjectType->TypeInfo.GenericMapping,
                                       UserMode,
                                       &grantedAccess,
                                       &status );

        if (privileges) {
            (VOID) SeAppendPrivileges( AccessState,
                                       privileges );
            SeFreePrivileges( privileges );
        }

        if (accessGranted) {
            AccessState->PreviouslyGrantedAccess |= grantedAccess;
            AccessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        }

        nameString.Length = 8;
        nameString.MaximumLength = 8;
        nameString.Buffer = L"File";

        SeOpenObjectAuditAlarm( &nameString,
                                deviceObject,
                                CompleteName,
                                parseDeviceObject->SecurityDescriptor,
                                AccessState,
                                FALSE,
                                accessGranted,
                                UserMode,
                                &AccessState->GenerateOnClose );

        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
        ExReleaseResourceLite( &IopSecurityResource );
        KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

        if (!accessGranted) {
            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
                IopDereferenceVpbAndFree(vpb);
            }
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // Allocate and fill in the I/O Request Packet (IRP) to use in interfacing
    // to the driver.  The allocation is done using an exception handler in
    // case the caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

        if (vpb) {
            IopDereferenceVpbAndFree(vpb);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = AccessMode;
    irp->Flags = IRP_CREATE_OPERATION | IRP_SYNCHRONOUS_API | IRP_DEFER_IO_COMPLETION;

    securityContext.SecurityQos = SecurityQos;
    securityContext.AccessState = AccessState;
    securityContext.DesiredAccess = desiredAccess;
    securityContext.FullCreateOptions = op->CreateOptions;

    //
    // Get a pointer to the stack location for the first driver.  This is where
    // the original function codes and parameters are passed.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Control = 0;

    if (op->CreateFileType == CreateFileTypeNone) {

        //
        // This is a normal file open or create function.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE;
        irpSp->Parameters.Create.EaLength = op->EaLength;
        irpSp->Flags = (UCHAR) op->Options;
        if (!(Attributes & OBJ_CASE_INSENSITIVE)) {
            irpSp->Flags |= SL_CASE_SENSITIVE;
        }

    } else if (op->CreateFileType == CreateFileTypeNamedPipe) {

        //
        // A named pipe is being created.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE_NAMED_PIPE;
        irpSp->Parameters.CreatePipe.Parameters = op->ExtraCreateParameters;

    } else {

        //
        // A mailslot is being created.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE_MAILSLOT;
        irpSp->Parameters.CreateMailslot.Parameters = op->ExtraCreateParameters;
    }

    //
    // Also fill in the NtCreateFile service's caller's parameters.
    //

    irp->Overlay.AllocationSize = op->AllocationSize;
    irp->AssociatedIrp.SystemBuffer = op->EaBuffer;
    irpSp->Parameters.Create.Options = (op->Disposition << 24) | (op->CreateOptions & 0x00ffffff);
    irpSp->Parameters.Create.FileAttributes = op->FileAttributes;
    irpSp->Parameters.Create.ShareAccess = op->ShareAccess;
    irpSp->Parameters.Create.SecurityContext = &securityContext;

    //
    // Fill in local parameters so this routine can determine when the I/O is
    // finished, and the normal I/O completion code will not get any errors.
    //

    irp->UserIosb = &ioStatus;
    irp->MdlAddress = (PMDL) NULL;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->UserEvent = (PKEVENT) NULL;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;

    //
    // Allocate and initialize the file object that will be used in dealing
    // with the device for the remainder of this session with the user.  How
    // the file object is allocated is based on whether or not a real file
    // object is actually required.  It is not required for the query and
    // delete only operations.
    //

    if (realFileObjectRequired) {

        OBJECT_ATTRIBUTES objectAttributes;
        ULONG             fileObjectSize;

        //
        // A real, full-blown file object is actually required.
        //

        InitializeObjectAttributes( &objectAttributes,
                                    (PUNICODE_STRING) NULL,
                                    Attributes,
                                    (HANDLE) NULL,
                                    (PSECURITY_DESCRIPTOR) NULL
                                  );

        if (op->InternalFlags & 
            (IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT|IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK)) {
            fileObjectSize = sizeof(FILE_OBJECT) + sizeof(IOP_FILE_OBJECT_EXTENSION);
        } else {
            fileObjectSize = sizeof(FILE_OBJECT);
        }

        status = ObCreateObject( KernelMode,
                                 IoFileObjectType,
                                 &objectAttributes,
                                 AccessMode,
                                 (PVOID) NULL,
                                 fileObjectSize,
                                 0,
                                 0,
                                 (PVOID *) &fileObject );

        if (!NT_SUCCESS( status )) {
            IoFreeIrp( irp );

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
               IopDereferenceVpbAndFree(vpb);
            }
            return op->FinalStatus = status;
        }

        IopPerfLogFileCreate(fileObject, CompleteName);

        RtlZeroMemory( fileObject, sizeof( FILE_OBJECT ) );
        if (op->CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) {
            fileObject->Flags = FO_SYNCHRONOUS_IO;
            if (op->CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) {
                fileObject->Flags |= FO_ALERTABLE_IO;
            }
        }

        if (op->InternalFlags & 
            (IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT|IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK)) {

            PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

            fileObject->Flags |= FO_FILE_OBJECT_HAS_EXTENSION;
            fileObjectExtension = (PIOP_FILE_OBJECT_EXTENSION)(fileObject + 1);
            fileObjectExtension->FileObjectExtensionFlags = 0;
            fileObjectExtension->TopDeviceObjectHint = NULL;
            fileObjectExtension->FilterContext = NULL;

            if (op->InternalFlags & IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT) {
                fileObjectExtension->TopDeviceObjectHint = deviceObject;
            }

            if (op->InternalFlags & IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK) {
                fileObjectExtension->FileObjectExtensionFlags |=FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK;
            }
        }

        //
        // Now fill in the file object as best is possible at this point and set
        // a pointer to it in the IRP so everyone else can find it.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            KeInitializeEvent( &fileObject->Lock, SynchronizationEvent, FALSE );
            fileObject->Waiters = 0;
            fileObject->CurrentByteOffset.QuadPart = 0;
        }
        if (op->CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING) {
            fileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;
        }
        if (op->CreateOptions & FILE_WRITE_THROUGH) {
            fileObject->Flags |= FO_WRITE_THROUGH;
        }
        if (op->CreateOptions & FILE_SEQUENTIAL_ONLY) {
            fileObject->Flags |= FO_SEQUENTIAL_ONLY;
        }
        if (op->CreateOptions & FILE_RANDOM_ACCESS) {
            fileObject->Flags |= FO_RANDOM_ACCESS;
        }

    } else {

        //
        // This is either a quick delete or query operation.  For these cases,
        // it is possible to optimize the Object Manager out of the picture by
        // simply putting together something that "looks" like a file object,
        // and then operating on it.
        //

        localFileObject = op->LocalFileObject;
        RtlZeroMemory( localFileObject, sizeof( DUMMY_FILE_OBJECT ) );
        fileObject = (PFILE_OBJECT) &localFileObject->ObjectHeader.Body;
        localFileObject->ObjectHeader.Type = IoFileObjectType;
        localFileObject->ObjectHeader.PointerCount = 1;
    }

    if (directDeviceOpen) {
        fileObject->Flags |= FO_DIRECT_DEVICE_OPEN;
    }
    if (!(Attributes & OBJ_CASE_INSENSITIVE)) {
        fileObject->Flags |= FO_OPENED_CASE_SENSITIVE;
    }

    fileObject->Type = IO_TYPE_FILE;
    fileObject->Size = sizeof( FILE_OBJECT );
    fileObject->RelatedFileObject = op->RelatedFileObject;
    fileObject->DeviceObject = parseDeviceObject;

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // Allocate a file name string buffer which is large enough to contain
    // the entire remaining name string and initialize the maximum length.
    //

    if (RemainingName->Length) {
        fileObject->FileName.MaximumLength = RoundNameSize( RemainingName->Length );
        fileObject->FileName.Buffer = ExAllocatePoolWithTag( PagedPool,
                                                             fileObject->FileName.MaximumLength,
                                                             'mNoI' );
        if (!fileObject->FileName.Buffer) {
            IoFreeIrp( irp );

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
               IopDereferenceVpbAndFree(vpb);
            }
            fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;
            if (realFileObjectRequired) {
                ObDereferenceObject( fileObject );
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Now copy the name string into the file object from the remaining name
    // that is being reparsed.  If the driver decides to reparse, then it must
    // replace this name.
    //

    RtlCopyUnicodeString( &fileObject->FileName, RemainingName );

    //
    // Before invoking the driver's open routine, check to see whether or not
    // this is a fast network attributes query and, if so, and the driver
    // implements the function, attempt to call it here.
    //

    if (op->QueryOnly) {
        PFAST_IO_DISPATCH fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;
        BOOLEAN result;

        if (fastIoDispatch &&
            fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoQueryOpen ) &&
            fastIoDispatch->FastIoQueryOpen) {

            IoSetNextIrpStackLocation( irp );
            irpSp->DeviceObject = deviceObject;
            result = (fastIoDispatch->FastIoQueryOpen)( irp,
                                                        op->NetworkInformation,
                                                        deviceObject );
            if (result) {
                op->FinalStatus = irp->IoStatus.Status;
                op->Information = irp->IoStatus.Information;

                //
                // The operation worked, so simply dereference and free the
                // resources acquired up to this point.
                //

                if ((op->FinalStatus == STATUS_REPARSE) &&
                    irp->Tail.Overlay.AuxiliaryBuffer) {
                    ASSERT( op->Information > IO_REPARSE_TAG_RESERVED_ONE );
                    ExFreePool( irp->Tail.Overlay.AuxiliaryBuffer );
                    irp->Tail.Overlay.AuxiliaryBuffer = NULL;
                    op->RelatedFileObject = (PFILE_OBJECT) NULL;
                }

                if (fileObject->FileName.Length) {
                    ExFreePool( fileObject->FileName.Buffer );
                }

                IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

                if (vpb) {
                    IopDereferenceVpbAndFree(vpb);
                }

#if DBG
                irp->CurrentLocation = irp->StackCount + 2;
#endif // DBG

                IoFreeIrp( irp );

                //
                // Finally, indicate that the parse routine was actually
                // invoked and that the information returned herein can be
                // used.
                //

                op->ParseCheck = OPEN_PACKET_PATTERN;
                status = STATUS_SUCCESS;

                if (!op->FullAttributes) {
                    try {
                        op->BasicInformation->FileAttributes = op->NetworkInformation->FileAttributes;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        status = GetExceptionCode();
                    }
                }

                return status;

            } else {

                //
                // The fast I/O operation did not work, so take the longer
                // route.
                //

                irp->Tail.Overlay.CurrentStackLocation++;
                irp->CurrentLocation++;
            }
        }
    }

    //
    // Finally, initialize the file object's event to the Not Signaled state
    // and remember that a file object was created.
    //

    KeInitializeEvent( &fileObject->Event, NotificationEvent, FALSE );
    op->FileObject = fileObject;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now invoke the driver itself to open the file.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // One of four things may have happened when the driver was invoked:
    //
    //    1.  The I/O operation is pending (Status == STATUS_PENDING).  This can
    //        occur on devices which need to perform some sort of device
    //        manipulation (such as opening a file for a file system).
    //
    //    2.  The driver returned an error (Status < 0). This occurs when either
    //        a supplied parameter was in error, or the device or file system
    //        incurred or discovered an error.
    //
    //    3.  The operation ended in a reparse (Status == STATUS_REPARSE).  This
    //        occurs when a file system opens the file, only to discover that it
    //        represents a symbolic link.
    //
    //    4.  The operation is complete and was successful (Status ==
    //        STATUS_SUCCESS).  Note that for this case the only action is to
    //        return a pointer to the file object.
    //

    if (status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject( &fileObject->Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;

    } else {

        //
        // The I/O operation was completed without returning a status of
        // pending.  This means that at this point, the IRP has not been
        // fully completed.  Complete it now.
        //

        KIRQL irql;

        ASSERT( !irp->PendingReturned );
        ASSERT( !irp->MdlAddress );

        //
        // In the case of name junctions do the transmogrify work.
        //

        if (irp->IoStatus.Status == STATUS_REPARSE &&
            irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT ) {

            PREPARSE_DATA_BUFFER reparseBuffer = NULL;

            ASSERT ( irp->Tail.Overlay.AuxiliaryBuffer != NULL );

            reparseBuffer = (PREPARSE_DATA_BUFFER) irp->Tail.Overlay.AuxiliaryBuffer;

            ASSERT( reparseBuffer->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
            ASSERT( reparseBuffer->ReparseDataLength < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
            ASSERT( reparseBuffer->Reserved < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );


            IopDoNameTransmogrify( irp,
                                   fileObject,
                                   reparseBuffer );

        }

        //
        // Now finish up the request.
        //

        KeRaiseIrql( APC_LEVEL, &irql );

        //
        // Note that normally the system would simply call IopCompleteRequest
        // here to complete the packet.  However, because this is a create
        // operation, several assumptions can be made that make it much faster
        // to perform the couple of operations that completing the request
        // would perform.  These include:  copying the I/O status block,
        // dequeueing the IRP and freeing it, and setting the file object's
        // event to the signalled state.  The latter is done here by hand,
        // since it is known that it is not possible for any thread to be
        // waiting on the event.
        //

        ioStatus = irp->IoStatus;
        status = ioStatus.Status;

        fileObject->Event.Header.SignalState = 1;

        IopDequeueThreadIrp( irp );

        //
        // The SystemBuffer is in some cases used by the driver, and
        // needs to be freed if present.
        //

        if ((irp->Flags & IRP_BUFFERED_IO) && (irp->Flags & IRP_DEALLOCATE_BUFFER)) {
            ExFreePool(irp->AssociatedIrp.SystemBuffer);
        }

        IoFreeIrp( irp );

        KeLowerIrql( irql );
    }

    //
    // Copy the information field of the I/O status block back to the
    // original caller in case it is required.
    //

    op->Information = ioStatus.Information;

    if (!NT_SUCCESS( status )) {
        int openCancelled;

        //
        // The operation ended in an error.  Kill the file object, dereference
        // the device object, and return a null pointer.
        //

        if (fileObject->FileName.Length) {
            ExFreePool( fileObject->FileName.Buffer );
            fileObject->FileName.Length = 0;
        }

        fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;

        openCancelled = (fileObject->Flags & FO_FILE_OPEN_CANCELLED);

        if (realFileObjectRequired) {
            ObDereferenceObject( fileObject );
        }
        op->FileObject = (PFILE_OBJECT) NULL;

        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

        if ((!openCancelled) && (vpb )) {
            IopDereferenceVpbAndFree(vpb);
        }

        return op->FinalStatus = status;

    } else if (status == STATUS_REPARSE) {

        //
        // The operation resulted in a reparse.  This means that the file
        // name in the file object is the new name to be looked up. Replace
        // the complete name string with the new name and return STATUS_REPARSE
        // so the object manager knows to start over again.  Note, however,
        // that the file name buffer in the file object itself is kept intact
        // so that it can be reused when coming back here again.
        //
        // A reparse status may also have been returned from the file system if
        // the volume that was in a drive needed to have been verified, but
        // the verification failed, and a new volume was mounted.  In this
        // case, everything starts over again using the new volume.
        //

        ASSERT( IO_REPARSE == IO_REPARSE_TAG_RESERVED_ZERO );

        if ((ioStatus.Information == IO_REPARSE) ||
            (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT)) {

            //
            // If the complete name buffer isn't large enough, reallocate it.
            //

            if (CompleteName->MaximumLength < fileObject->FileName.Length) {

                PVOID buffer;

                buffer = ExAllocatePoolWithTag( PagedPool,
                                                fileObject->FileName.Length,
                                                'cFoI' );
                if (!buffer) {
                    return op->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    if (CompleteName->Buffer) {
                        ExFreePool( CompleteName->Buffer );
                    }
                    CompleteName->Buffer = buffer;
                    CompleteName->MaximumLength = fileObject->FileName.Length;
                }
            }
                                                 
            RtlCopyUnicodeString( CompleteName, &fileObject->FileName );

            //
            // For NTFS directory junction points we NULL the RelatedFileObject.
            // If the prior call was a relative open, the subsequent one will
            // not be.
            //

            if (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {

                op->RelatedFileObject = (PFILE_OBJECT) NULL;
            }
        }

        //
        // Kill the file object, dereference the device object, and return a
        // null pointer.
        //

        if (fileObject->FileName.Length) {
            ExFreePool( fileObject->FileName.Buffer );
            fileObject->FileName.Length = 0;
        }

        fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;

        if (realFileObjectRequired) {
            ObDereferenceObject( fileObject );
        }
        op->FileObject = (PFILE_OBJECT) NULL;

        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

        if (vpb) {
            IopDereferenceVpbAndFree(vpb);
        }

        ASSERT( IO_REMOUNT == IO_REPARSE_TAG_RESERVED_ONE );

        if (ioStatus.Information == IO_REPARSE_TAG_RESERVED_ONE) {

            //
            // If we are reparsing to verify a volume, restart the reparse
            // by attempting to parse the device once again.  Note that it
            // would be best to simply recurse, but it's not possible since
            // there is a limited amount of stack available to kernel mode
            // and a limit needs to be enforced for the number of times that
            // verify reparse can occur.
            //

            if (++retryCount > IO_MAX_REMOUNT_REPARSE_ATTEMPTS) {

                return STATUS_UNSUCCESSFUL;
            }
            goto reparse_loop;

        } else {

            //
            // Really reparsing a symbolic link, so go back to the object
            // manager so it can begin the parse from the top.
            //

            op->RelatedFileObject = (PFILE_OBJECT) NULL;

            //
            // Note that the mountpoint should be set only for the correct
            // tag. IO_REMOUNT is sent by FAT,CDFS and UDFS to remount a volume.
            // IO_REPARSE is set by the network filesystems to just use a different path.
            // 

            if (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {
                op->TraversedMountPoint = TRUE;
            }
            return STATUS_REPARSE;
        }

    } else {

        //
        // The operation was successful. The first thing to do is to see if
        // the device that processed the open also opened the file. If
        // not, we need to adjust the vpb reference counts. Then, if this is
        // not a query or a delete, but rather a normal open/create, return
        // the address of the FileObject to the caller and set the
        // information returned in the original requestor's I/O status block.
        // Also set the value of the parse check field in the open packet to
        // a value which will let the caller know that this routine was
        // successful in creating the file object. Finally, return the status
        // of the operation to the caller.
        //

        PDEVICE_OBJECT deviceObjectThatOpenedFile;

        deviceObjectThatOpenedFile = IoGetRelatedDeviceObject(fileObject);
        if (deviceObject != deviceObjectThatOpenedFile) {
            //
            // The device that opened the related file is not the one
            // that opened this file. So, readjust the vpb reference
            // counts.
            if (vpb) {
                IopDereferenceVpbAndFree(vpb);
            }
            vpb = fileObject->Vpb;
            if (vpb) {
                IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                              &vpb->ReferenceCount);
            }
        }

        if (realFileObjectRequired) {

            *Object = fileObject;
            op->ParseCheck = OPEN_PACKET_PATTERN;

            //
            // Add a reference so the file object cannot go away before
            // the create routine gets chance to flag the object for handle
            // create.
            //

            ObReferenceObject( fileObject );

            //
            // If the filename length is zero and its not a relative open or
            // its a relative open to a volume open then set the volume open flag.
            // Also set it only for filesystem device object volume.
            //
            if ((!fileObject->RelatedFileObject || fileObject->RelatedFileObject->Flags & FO_VOLUME_OPEN) &&
                (!fileObject->FileName.Length)) {
                switch (deviceObjectThatOpenedFile->DeviceType) {
                case FILE_DEVICE_DISK_FILE_SYSTEM:
                case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
                case FILE_DEVICE_TAPE_FILE_SYSTEM:
                case FILE_DEVICE_FILE_SYSTEM:

                    fileObject->Flags |= FO_VOLUME_OPEN;
                    break;

                default:
                    break;
                }
            }

            return op->FinalStatus = ioStatus.Status;

        } else {

            //
            // This is either a quick query or delete operation.  Determine
            // which it is and quickly perform the operation.
            //

            if (op->QueryOnly) {
                PFAST_IO_DISPATCH fastIoDispatch;
                BOOLEAN queryResult = FALSE;

                fastIoDispatch = deviceObjectThatOpenedFile->DriverObject->FastIoDispatch;

                if (!op->FullAttributes) {
                    PFILE_BASIC_INFORMATION basicInfo = NULL;

                    //
                    // This is a simple FAT file attribute query.  Attempt to
                    // obtain the basic information about the file.
                    //

                    try {

                        if (fastIoDispatch && fastIoDispatch->FastIoQueryBasicInfo) {
                            queryResult = fastIoDispatch->FastIoQueryBasicInfo(
                                            fileObject,
                                            TRUE,
                                            op->BasicInformation,
                                            &ioStatus,
                                            deviceObjectThatOpenedFile
                                            );
                        }
                        if (!queryResult) {

                            basicInfo = ExAllocatePool( NonPagedPool,
                                                        sizeof( FILE_BASIC_INFORMATION ) );
                            if (basicInfo) {
                                status = IoQueryFileInformation(
                                            fileObject,
                                            FileBasicInformation,
                                            sizeof( FILE_BASIC_INFORMATION ),
                                            basicInfo,
                                            &returnedLength
                                            );
                                if (NT_SUCCESS( status )) {
                                    RtlCopyMemory( op->BasicInformation,
                                                   basicInfo,
                                                   returnedLength );
                                }
                                ExFreePool( basicInfo );
                            } else {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        } else {
                            status = ioStatus.Status;
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        if (basicInfo) {
                            ExFreePool( basicInfo );
                        }
                        status = GetExceptionCode();
                    }

                } else {

                    //
                    // This is a full attribute query.  Attempt to obtain the
                    // full network attributes for the file.  This includes
                    // both the basic and standard information about the
                    // file.  Try the fast path first, if it exists.
                    //

                    if (fastIoDispatch &&
                        fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoQueryNetworkOpenInfo ) &&
                        fastIoDispatch->FastIoQueryNetworkOpenInfo) {
                        queryResult = fastIoDispatch->FastIoQueryNetworkOpenInfo(
                                        fileObject,
                                        TRUE,
                                        op->NetworkInformation,
                                        &ioStatus,
                                        deviceObjectThatOpenedFile
                                        );
                    }
                    if (!queryResult) {

                        //
                        // Either the fast dispatch routine did not exist, or
                        // it simply wasn't callable at this time.  Attempt to
                        // obtain all of the information at once via an IRP-
                        // based call.
                        //

                        status = IoQueryFileInformation(
                                    fileObject,
                                    FileNetworkOpenInformation,
                                    sizeof( FILE_NETWORK_OPEN_INFORMATION ),
                                    op->NetworkInformation,
                                    &returnedLength
                                    );

                        if (!NT_SUCCESS( status )) {
                            if (status == STATUS_INVALID_PARAMETER ||
                                status == STATUS_NOT_IMPLEMENTED) {
                                status = IopGetNetworkOpenInformation(fileObject, op);
                            }
                        }
                    }
                }

            } else {

                //
                // There is nothing to do for a quick delete since the caller
                // set the FILE_DELETE_ON_CLOSE CreateOption so it is already
                // set in the file system.
                //

                NOTHING;

            }

            op->ParseCheck = OPEN_PACKET_PATTERN;
            if (realFileObjectRequired) {
                ObDereferenceObject( fileObject );
            } else {
                IopDeleteFile( fileObject );
            }
            op->FileObject = (PFILE_OBJECT) NULL;

            op->FinalStatus = status;

            return status;
        }
    }
}

NTSTATUS
IopGetNetworkOpenInformation(
    IN  PFILE_OBJECT    FileObject,
    IN  POPEN_PACKET    Op
    )
/*++

Routine Description:

    This routines gets the network information in two steps.
    Its called out as a separate routine from IopParseDevice to save stack for
    common create paths.
    
Arguments:

    FileObject  - Pointer to the fileobject for the opened file.
    
    Op          - Pointer to the open packet.
    

Return Value:

    NTSTATUS

--*/
{
#define COPY_ATTRIBUTES( n, b, s ) {                                    \
        (n)->CreationTime.QuadPart = (b)->CreationTime.QuadPart;        \
        (n)->LastAccessTime.QuadPart = (b)->LastAccessTime.QuadPart;    \
        (n)->LastWriteTime.QuadPart = (b)->LastWriteTime.QuadPart;      \
        (n)->ChangeTime.QuadPart = (b)->ChangeTime.QuadPart;            \
        (n)->AllocationSize.QuadPart = (s)->AllocationSize.QuadPart;    \
        (n)->EndOfFile.QuadPart = (s)->EndOfFile.QuadPart;              \
        (n)->FileAttributes = (b)->FileAttributes; }

    FILE_BASIC_INFORMATION     basicInfo;
    FILE_STANDARD_INFORMATION  stdInfo;
    ULONG                      returnedLength;
    NTSTATUS                   status;

    PAGED_CODE();

    //
    // The IRP-based call did not work either, so
    // simply try to obtain the information by
    // doing IRP-based queries for the basic and
    // standard information and piecing together
    // the results into the caller's buffer.  Note
    // that it might be possible to perform fast
    // I/O operations to get the data, but it
    // might also fail because of the above.  So
    // simply query the information the long way.
    //

    status = IoQueryFileInformation(
                FileObject,
                FileBasicInformation,
                sizeof( FILE_BASIC_INFORMATION ),
                &basicInfo,
                &returnedLength
                );

    if (NT_SUCCESS( status )) {
        status = IoQueryFileInformation(
                    FileObject,
                    FileStandardInformation,
                    sizeof( FILE_STANDARD_INFORMATION ),
                    &stdInfo,
                    &returnedLength
                    );
        if (NT_SUCCESS( status )) {
            COPY_ATTRIBUTES( Op->NetworkInformation,
                             &basicInfo,
                             &stdInfo );
        }
    }
    return status;
}

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and is
    also given a handle to a directory file object that the operation is to be
    performed relative to.  This routine is specified as the parse routine for
    all file objects.

    This routine simply invokes the parse routine for the appropriate device
    that is associated with the file object.  It is the responsibility of that
    routine to perform the operation.

Arguments:

    ParseObject - Pointer to the file object that the name is to be opened or
        created relative to.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    SecurityQos - Supplies a pointer to the captured QOS information
        if available.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{
    PDEVICE_OBJECT deviceObject;
    POPEN_PACKET op;

    PAGED_CODE();

    //
    // Get the address of the Open Packet (OP).
    //

    op = (POPEN_PACKET) Context;

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Get a pointer to the device object for this file.
    //

    deviceObject = IoGetRelatedDeviceObject( (PFILE_OBJECT) ParseObject );

    //
    // Pass the related file object to the device object parse routine.
    //

    op->RelatedFileObject = (PFILE_OBJECT) ParseObject;

    //
    // Open or create the specified file.
    //

    return IopParseDevice( deviceObject,
                           ObjectType,
                           AccessState,
                           AccessMode,
                           Attributes,
                           CompleteName,
                           RemainingName,
                           Context,
                           SecurityQos,
                           Object );
}

NTSTATUS
IopQueryNameInternal(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    IN BOOLEAN UseDosDeviceName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    )

/*++

Routine Description:

    This function implements the query name procedure for the Object Manager
    for querying the names of file objects.

Arguments:

    Object - Pointer to the file object whose name is to be retrieved.

    HasObjectName - Indicates whether or not the object has a name.

    UseDosDeviceName - Indicates whether to translate the device object part
                        of the fileobject into the dosdevice name space or the
                        regular \device namespace via ob

    ObjectNameInfo - Buffer in which to return the name.

    Length - Specifies the length of the output buffer, in bytes.

    ReturnLength - Specifies the number of bytes actually returned in the
        output buffer.

Return Value:

    The function return value is the final status of the query operation.

--*/

{
    NTSTATUS status;
    ULONG lengthNeeded;
    PFILE_OBJECT fileObject;
    PUCHAR buffer;
    PWSTR p;
    POBJECT_NAME_INFORMATION deviceNameInfo;
    PFILE_NAME_INFORMATION fileNameInfo;
    ULONG length;
    BOOLEAN deviceNameOverflow;
    BOOLEAN dosLookupSuccess = 0;

    UNREFERENCED_PARAMETER( HasObjectName );

    PAGED_CODE();

    ASSERT( FIELD_OFFSET( FILE_NAME_INFORMATION, FileName ) < sizeof( OBJECT_NAME_INFORMATION ) );

    //
    // Ensure that the size of the output buffer is at least the minimum
    // size required to include the basic object name information structure.
    //

    if (Length < sizeof( OBJECT_NAME_INFORMATION )) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Begin by allocating a buffer in which to build the name of the file.
    //

    buffer = ExAllocatePoolWithTag( PagedPool, Length, '  oI' );

    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        //
        // Query the name of the device on which the file is open.
        //

        fileObject = (PFILE_OBJECT) Object;
        deviceNameInfo = (POBJECT_NAME_INFORMATION) buffer;

        if (UseDosDeviceName) {
            if (fileObject->DeviceObject->DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM) {

                lengthNeeded = sizeof(OBJECT_NAME_INFORMATION) + 2*sizeof(WCHAR); // For the extra '\' and '\0'

                if (lengthNeeded > Length) {
                    status = STATUS_BUFFER_OVERFLOW;
                } else {
                    status = STATUS_SUCCESS;
                }

                deviceNameInfo->Name.Length = sizeof(WCHAR);
                deviceNameInfo->Name.MaximumLength = sizeof(WCHAR);
                p = (PWSTR) (deviceNameInfo + 1);
                *p = '\\'; // Start with a '\' as RDR does not return the extra
                deviceNameInfo->Name.Buffer = p;

            } else {
                status = IoVolumeDeviceToDosName( fileObject->DeviceObject, &deviceNameInfo->Name );
                lengthNeeded = sizeof(OBJECT_NAME_INFORMATION) + deviceNameInfo->Name.Length + sizeof(WCHAR);
            }

            //
            // If querying the dos name fails try to atleast get the real device name
            //

            if (!NT_SUCCESS(status)) {
                status = ObQueryNameString( (PVOID) fileObject->DeviceObject,
                                        deviceNameInfo,
                                        Length,
                                        &lengthNeeded );
            } else {
                dosLookupSuccess++;
            }
        } else {
            status = ObQueryNameString( (PVOID) fileObject->DeviceObject,
                                    deviceNameInfo,
                                    Length,
                                    &lengthNeeded );
        }

        if (!NT_SUCCESS( status )) {
            if (status != STATUS_INFO_LENGTH_MISMATCH) {
                return status;
            }
        }

        //
        // Ensure that there is enough room in the output buffer to return the
        // name and copy it.
        //

        p = (PWSTR) (ObjectNameInfo + 1);

        //
        // If we got a DOS name, note the name isn't contiguous to the device name info,
        // and that we should free it (the Rtl call did not know we allocated this big
        // buffer, and made a new one).
        //

        if (UseDosDeviceName && dosLookupSuccess) {

            ULONG BaseCopyLength;
            ULONG NameCopyLength;

            //
            //  Figure out how much of each part we can copy.
            //

            BaseCopyLength = sizeof(UNICODE_STRING);

            if ( Length < lengthNeeded ) {
                if ( Length < sizeof(UNICODE_STRING)) {
                    BaseCopyLength = Length;
                    NameCopyLength = 0;
                } else {
                    NameCopyLength = Length - BaseCopyLength;
                }
            } else {
                NameCopyLength = deviceNameInfo->Name.Length;
            }

            //
            // Copy in two parts - the base chunk of the UNICODE_STRING and then
            // as much of the name as will fit.
            //

            RtlCopyMemory( ObjectNameInfo,
                           deviceNameInfo,
                           BaseCopyLength );
            RtlCopyMemory( p,
                           deviceNameInfo->Name.Buffer,
                           NameCopyLength );

            if (fileObject->DeviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM) {
                ExFreePool( deviceNameInfo->Name.Buffer );
            }

        } else {

            RtlCopyMemory( ObjectNameInfo,
                           deviceNameInfo,
                           lengthNeeded > Length ? Length : lengthNeeded );
        }

        ObjectNameInfo->Name.Buffer = p;
        p = (PWSTR) ((PCHAR) p + deviceNameInfo->Name.Length);

        //
        // If the buffer is already full, note and continue to pick up the filename length.
        // We want to return the required length for the entire result.
        //

        deviceNameOverflow = FALSE;
        if (lengthNeeded > Length) {
            *ReturnLength = lengthNeeded;
            deviceNameOverflow = TRUE;
        }

        //
        // Reset the state for the buffer to obtain the filename portion of the
        // name and calculate the remaining length of the caller's buffer.  Note
        // that in the following calculations, there are two assumptions and
        // and dependencies:
        //
        //     1)  The above query of the device name's returned length needed
        //         include a NULL character which will be included at the end
        //         of the entire name.  This is included in the calculations
        //         although it does not appear to be included.
        //
        //     2)  The sizeof the object name information buffer is assumed
        //         (and guaranteed because it can never change) to be larger
        //         than the filename offset in a file name information buffer.
        //         Therefore it is known that the new length of the "buffer"
        //         variable can be set to the remaining length plus at least 4.
        //

        fileNameInfo = (PFILE_NAME_INFORMATION) buffer;

        if (deviceNameOverflow) {
            length = Length;
        } else {
            length = Length - lengthNeeded;
            length += FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
        }

        if (((KeGetPreviousMode() == UserMode) && (!UseDosDeviceName)) ||
            !(fileObject->Flags & FO_SYNCHRONOUS_IO)) {

            //
            // Query the name of the file based using an intermediary buffer.
            //

            status = IoQueryFileInformation( fileObject,
                                             FileNameInformation,
                                             length,
                                             (PVOID) fileNameInfo,
                                             &lengthNeeded );
        } else {

            //
            // This is a kernel mode request for a file that was opened for
            // synchronous I/O.  A special function that does not obtain the
            // file object lock is required, otherwise the request may deadlock
            // since the lock is probably already owned.
            //

            status = IopGetFileInformation( fileObject,
                                     length,
                                     FileNameInformation,
                                     fileNameInfo,
                                     &lengthNeeded );
        }

        //
        // If an error occurred attempting to obtain the filename return now.  Note
        // that buffer overflow is a warning, not an error.
        //

        if (NT_ERROR( status )) {
            if (status == STATUS_INVALID_PARAMETER ||
                status == STATUS_INVALID_DEVICE_REQUEST ||
                status == STATUS_NOT_IMPLEMENTED ||
                status == STATUS_INVALID_INFO_CLASS) {

                lengthNeeded = FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
                fileNameInfo->FileNameLength = 0;
                fileNameInfo->FileName[0] = OBJ_NAME_PATH_SEPARATOR;
                status = STATUS_SUCCESS;
            } else {
                return status;
            }
        }

        //
        // Compute the correct length
        // Note that ReturnLength already contains a space for NULL added by the previous ObQueryNameString.
        //

        if (deviceNameOverflow) {
            *ReturnLength += fileNameInfo->FileNameLength;
            return STATUS_BUFFER_OVERFLOW;
        }

        //
        // Set the remaining length of the caller's buffer as well as the total
        // length needed to contain the entire name of the file.
        //

        length = lengthNeeded - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
        lengthNeeded = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo) + fileNameInfo->FileNameLength;

        //
        // Attempt to copy the name of the file into the output buffer.  Note
        // that if the file name does not begin w/a '\', then it is not volume
        // relative, so the name of the file cannot be expressed as the
        // concatenation of the name of the device and the file.  Therefore an
        // error is returned.
        //
        // The only example of this situation known at this time is when one
        // opens a directory by file ID, and then opens a file relative to that
        // directory.  When attempting to query the path, if the caller did not
        // have traverse access to open the directory, then the only name that
        // can be returned is the path name to the file from the directory, but
        // the volume-relative name cannot be returned.  Therefore, the file
        // system returns only the name of the directory and the path to the
        // file, but this is not volume-relative so the only recourse is to
        // return an error.
        //
        // Note that if the caller were to call NtQueryInformationFile and
        // request FileNameInformation, then the name above named will be
        // successfully returned from the file system.
        //

        if (fileNameInfo->FileName[0] != OBJ_NAME_PATH_SEPARATOR) {
            return STATUS_OBJECT_PATH_INVALID;
            }

        RtlCopyMemory( p,
                       fileNameInfo->FileName,
                       length );
        p = (PWSTR) ((PCH) p + length);
        *p = '\0';
        lengthNeeded += sizeof( WCHAR );

        *ReturnLength = lengthNeeded;

        length = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo);
        ObjectNameInfo->Name.Length = (USHORT) (length - sizeof( *ObjectNameInfo ));
        ObjectNameInfo->Name.MaximumLength =  (USHORT) ((length - sizeof( *ObjectNameInfo )) + sizeof( WCHAR ));
    }

    finally {

        //
        // Finally, free the temporary buffer.
        //

        ExFreePool( buffer );
    }

    return status;
}

NTSTATUS
IopQueryName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    )

/*++

Routine Description:

    This function implements the query name procedure for the Object Manager
    for querying the names of file objects.

Arguments:

    Object - Pointer to the file object whose name is to be retrieved.

    HasObjectName - Indicates whether or not the object has a name.

    ObjectNameInfo - Buffer in which to return the name.

    Length - Specifies the length of the output buffer, in bytes.

    ReturnLength - Specifies the number of bytes actually returned in the
        output buffer.

Return Value:

    The function return value is the final status of the query operation.

--*/

{
    return IopQueryNameInternal( Object,
                                 HasObjectName,
                                 FALSE,
                                 ObjectNameInfo,
                                 Length,
                                 ReturnLength );
}



VOID
IopCheckBackupRestorePrivilege(
    IN PACCESS_STATE AccessState,
    IN OUT PULONG CreateOptions,
    IN KPROCESSOR_MODE PreviousMode,
    IN ULONG Disposition
    )

/*++

Routine Description:

    This funcion will determine if the caller is asking for any accesses
    that may be satisfied by Backup or Restore privileges, and if so,
    perform the privilge checks.  If the privilege checks succeed, then
    the appropriate bits will be moved out of the RemainingDesiredAccess
    field in the AccessState structure and placed into the PreviouslyGrantedAccess
    field.

    Note that access is not denied if the caller does not have either or
    both of the privileges, since he may be granted the desired access
    via the security descriptor on the object.

    This routine will also set a flag in the AccessState structure so that
    it will not perform these privilege checks again in case we come through
    this way again due to a reparse.

Arguments:

    AccessState - The AccessState containing the current state of this access
        attempt.

    CreateOptions - The CreateOptions field from the OPEN_PACKET structure for
        this open attempt.

    PreviousMode - The processor mode to be used in checking parameters.

    Disposition - The create disposition for this request.

Return Value:

    None.

--*/

{
    ACCESS_MASK desiredAccess;
    ACCESS_MASK readAccess;
    ACCESS_MASK writeAccess;
    PRIVILEGE_SET requiredPrivileges;
    BOOLEAN accessGranted;
    BOOLEAN keepBackupIntent = FALSE;
    BOOLEAN ForceRestoreCheck = FALSE;

    PAGED_CODE();

    //
    // Check to determine whether or not this check has already been made.
    // If so, simply return back to the caller.
    //

    if (AccessState->Flags & SE_BACKUP_PRIVILEGES_CHECKED) {
        return;
    }

    if (*CreateOptions & FILE_OPEN_FOR_BACKUP_INTENT) {
        AccessState->Flags |= SE_BACKUP_PRIVILEGES_CHECKED;

        readAccess = READ_CONTROL | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_READ | FILE_TRAVERSE;
        writeAccess = WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_WRITE | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY | DELETE;

        desiredAccess = AccessState->RemainingDesiredAccess;

        //
        // If the caller has requested MAXIMUM_ALLOWED, then make it appear as
        // if the request was for everything permitted by Backup and Restore,
        // and then grant everything that can actually be granted.
        //

        if (desiredAccess & MAXIMUM_ALLOWED) {
            desiredAccess |= ( readAccess | writeAccess );
        }

        //
        // If the disposition says that we're opening the file, check for both backup
        // and restore privilege, depending on what's in the desired access.
        //
        // If the disposition says that we're creating or trying to overwrite the file,
        // then all we need to do is to check for restore privilege, and if it's there,
        // grant every possible access.
        //

        if ((Disposition == FILE_OPEN )  || (Disposition == FILE_OPEN_IF) || (Disposition == FILE_OVERWRITE_IF)) {

            //
            // If the request was for any of the bits in the read access mask, then
            // assume that this is a backup operation, and check for the Backup
            // privielege.  If the caller has it, then grant the intersection of
            // the desired access and read access masks.
            //

            if (readAccess & desiredAccess) {

                requiredPrivileges.PrivilegeCount = 1;
                requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
                requiredPrivileges.Privilege[0].Luid = SeBackupPrivilege;
                requiredPrivileges.Privilege[0].Attributes = 0;

                accessGranted = SePrivilegeCheck( &requiredPrivileges,
                                                  &AccessState->SubjectSecurityContext,
                                                  PreviousMode );

                if (accessGranted) {

                    //
                    // The caller has Backup privilege, so grant the appropriate
                    // accesses.
                    //

                    keepBackupIntent = TRUE;
                    (VOID) SeAppendPrivileges( AccessState, &requiredPrivileges );
                    AccessState->PreviouslyGrantedAccess |= ( desiredAccess & readAccess );
                    AccessState->RemainingDesiredAccess &= ~readAccess;
                    desiredAccess &= ~readAccess;
                    AccessState->Flags |= TOKEN_HAS_BACKUP_PRIVILEGE;
                }
            }

        } else {

            ForceRestoreCheck = TRUE;
        }

        //
        // If the request was for any of the bits in the write access mask, then
        // assume that this is a restore operation, so check for the Restore
        // privilege.  If the caller has it, then grant the intersection of
        // the desired access and write access masks.
        //

        if ((writeAccess & desiredAccess) || ForceRestoreCheck) {

            requiredPrivileges.PrivilegeCount = 1;
            requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
            requiredPrivileges.Privilege[0].Luid = SeRestorePrivilege;
            requiredPrivileges.Privilege[0].Attributes = 0;

            accessGranted = SePrivilegeCheck( &requiredPrivileges,
                                              &AccessState->SubjectSecurityContext,
                                              PreviousMode );

            if (accessGranted) {

                //
                // The caller has Restore privilege, so grant the appropriate
                // accesses.
                //

                keepBackupIntent = TRUE;
                (VOID) SeAppendPrivileges( AccessState, &requiredPrivileges );
                AccessState->PreviouslyGrantedAccess |= (desiredAccess & writeAccess);
                AccessState->RemainingDesiredAccess &= ~writeAccess;
                AccessState->Flags |= TOKEN_HAS_RESTORE_PRIVILEGE;
            }
        }

        //
        // If either of the access types was granted because the caller had
        // backup or restore privilege, then the backup intent flag is kept.
        // Otherwise, it is cleared so that it is not passed onto the driver
        // so that it is not incorrectly propogated anywhere else, since this
        // caller does not actually have the privilege enabled.
        //

        if (!keepBackupIntent) {
            *CreateOptions &= ~FILE_OPEN_FOR_BACKUP_INTENT;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\qsea.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    qsea.c

Abstract:

    This module contains the code to implement the NtQueryEaFile and the
    NtSetEaFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 20-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtQueryEaFile)
#pragma alloc_text(PAGE, NtSetEaFile)
#endif

NTSTATUS
NtQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service returns the Extended Attributes (EAs) associated with the
    file specified by the FileHandle parameter.  The amount of information
    returned is based on the size of the EAs, and the size of the buffer.
    That is, either all of the EAs are written to the buffer, or the buffer
    is filled with complete EAs if the buffer is not large enough to contain
    all of the EAs.  Only complete EAs are ever written to the buffer; no
    partial EAs will ever be returned.

Arguments:

    FileHandle - Supplies a handle to the file for which the EAs are returned.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer to receive the EAs for the file.

    Length - Supplies the length, in bytes, of the buffer.

    ReturnSingleEntry - Indicates that only a single entry should be returned
        rather than filling the buffer with as many EAs as possible.

    EaList - Optionally supplies a list of EA names whose values are returned.

    EaListLength - Supplies the length of the EA list, if an EA list was
        specified.

    EaIndex - Supplies the optional index of an EA whose value is to be
        returned.  If specified, then only that EA is returned.

    RestartScan - Indicates whether the scan of the EAs should be restarted
        from the beginning.

Return Value:

    The status returned is the final completion status of the operation.

--*/

#define GET_OFFSET_LENGTH( CurrentEa, EaBase ) (    \
    (ULONG) ((PCHAR) CurrentEa - (PCHAR) EaBase) )


{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    PCHAR auxiliaryBuffer = (PCHAR) NULL;
    BOOLEAN eaListPresent = FALSE;
    ULONG eaIndexValue = 0L;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The buffer must be writeable by the caller.
            //

            ProbeForWrite( Buffer, Length, sizeof( ULONG ) );

            //
            // If the optional EaIndex parameter was specified, then it must be
            // readable by the caller.  Capture its value.
            //

            if (ARGUMENT_PRESENT( EaIndex )) {
                eaIndexValue = ProbeAndReadUlong( EaIndex );
            }

            //
            // If the optional EaList parameter was specified, then it must be
            // readable by the caller.  Validate that the buffer contains a
            // legal get information structure.
            //

            if (ARGUMENT_PRESENT( EaList ) && EaListLength != 0) {

                PFILE_GET_EA_INFORMATION eas;
                LONG tempLength;
                ULONG entrySize;

                eaListPresent = TRUE;

                ProbeForRead( EaList, EaListLength, sizeof( ULONG ) );
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           EaListLength );
                RtlCopyMemory( auxiliaryBuffer, EaList, EaListLength );

                eas = (PFILE_GET_EA_INFORMATION) auxiliaryBuffer;
                tempLength = EaListLength;

                //
                // Walk the request buffer and ensure that its format is
                // valid.  That is, ensure that it does not walk off the
                // end of the buffer that has been captured.
                //

                for (;;) {

                    //
                    // Get the size of the current entry in the buffer.
                    //

                    if (tempLength < FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0])) {
                        tempLength = 0;
                        ExFreePool( auxiliaryBuffer );
                        auxiliaryBuffer = (PVOID) NULL;
                        IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                        IoStatusBlock->Information = tempLength;
                        return STATUS_EA_LIST_INCONSISTENT;
                        }

                    entrySize = FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) + eas->EaNameLength + 1;

                    if ((ULONG) tempLength < entrySize) {
                        tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                        ExFreePool( auxiliaryBuffer );
                        auxiliaryBuffer = (PVOID) NULL;
                        IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                        IoStatusBlock->Information = tempLength;
                        return STATUS_EA_LIST_INCONSISTENT;
                        }

                    if (eas->NextEntryOffset != 0) {

                        //
                        // There is another entry in the buffer and it must
                        // be longword aligned.  Ensure that the offset
                        // indicates that it is.  If it isn't, return an
                        // invalid parameter status.
                        //

                        if ((((entrySize + 3) & ~3) != eas->NextEntryOffset) ||
                            ((LONG) eas->NextEntryOffset < 0)) {
                            tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                            ExFreePool( auxiliaryBuffer );
                            auxiliaryBuffer = (PVOID) NULL;
                            IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                            IoStatusBlock->Information = tempLength;
                            return STATUS_EA_LIST_INCONSISTENT;

                        } else {

                            //
                            // There is another entry in the buffer, so
                            // account for the size of the current entry
                            // in the length and get a pointer to the next
                            // entry.
                            //

                            tempLength -= eas->NextEntryOffset;
                            if (tempLength < 0) {
                                tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                                ExFreePool( auxiliaryBuffer );
                                auxiliaryBuffer = (PVOID) NULL;
                                IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                                IoStatusBlock->Information = tempLength;
                                return STATUS_EA_LIST_INCONSISTENT;
                            }
                            eas = (PFILE_GET_EA_INFORMATION) ((PCHAR) eas + eas->NextEntryOffset);
                        }

                    } else {

                        //
                        // There are no other entries in the buffer.  Simply
                        // account for the overall buffer length according
                        // to the size of the current entry and exit the
                        // loop.
                        //

                        tempLength -= entrySize;
                        break;
                    }
                }

                //
                // All of the entries in the buffer have been processed.
                // Check to see whether the overall buffer length went
                // negative.  If so, return an error.
                //

                if (tempLength < 0) {
                    tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                    ExFreePool( auxiliaryBuffer );
                    auxiliaryBuffer = (PVOID) NULL;
                    IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                    IoStatusBlock->Information = tempLength;
                    return STATUS_EA_LIST_INCONSISTENT;
                }

            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters, allocating the pool buffer, or copying the
            // caller's EA list to the buffer.  Cleanup and return an
            // appropriate error status code.
            //

            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }

            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was KernelMode.  Simply allocate pool for the
        // EaList, if one was specified, and copy the string to it.  Also,
        // if an EaIndex was specified copy it as well.
        //

        if (ARGUMENT_PRESENT( EaList ) && (EaListLength != 0)) {
            eaListPresent = TRUE;
            try {
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           EaListLength );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
            RtlCopyMemory( auxiliaryBuffer, EaList, EaListLength );
        }

        if (ARGUMENT_PRESENT( EaIndex )) {
            eaIndexValue = *EaIndex;
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_EA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        if (eaListPresent) {
            ExFreePool( auxiliaryBuffer );
        }
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eaListPresent) {
                    ExFreePool( auxiliaryBuffer );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            if (eaListPresent) {
                ExFreePool( auxiliaryBuffer );
            }
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (eaListPresent) {
            ExFreePool( auxiliaryBuffer );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_EA;
    irpSp->FileObject = fileObject;

    //
    // If the caller specified an EA list of names to be queried, then pass
    // the address of the intermediary buffer containing the list to the
    // driver.
    //

    if (eaListPresent) {
        irp->Tail.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
        irpSp->Parameters.QueryEa.EaList = auxiliaryBuffer;
        irpSp->Parameters.QueryEa.EaListLength = EaListLength;
    }

    //
    // Now determine whether this driver expects to have data buffered
    // to it or whether it performs direct I/O.  This is based on the
    // DO_BUFFERED_IO flag in the device object.  If the flag is set,
    // then a system buffer is allocated and the driver's data will be
    // copied to it.  If the DO_DIRECT_IO flag is set in the device
    // object, then a Memory Descriptor List (MDL) is allocated and
    // the caller's buffer is locked down using it.  Finally, if the
    // driver specifies neither of the flags, then simply pass the
    // address and length of the buffer and allow the driver to perform
    // all of the checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The driver wishes the caller's buffered be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also indicate
        // that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception
        // handler that will perform cleanup if the operation fails.
        //

        if (Length) {
            try {

                //
                // Allocate the intermediary system buffer from nonpaged
                // pool and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                   ExAllocatePoolWithQuota( NonPagedPool, Length );
 
            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the system buffer.
                // Determine what actually happened, clean everything
                // up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer != NULL) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }

            //
            // Remember the address of the caller's buffer so the copy can
            // take place during I/O completion.  Also, set the flags so
            // that the completion code knows to do the copy and to deallocate
            // the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                                   IRP_DEALLOCATE_BUFFER |
                                   IRP_INPUT_OPERATION);
        } else {
            //
            // This is a zero-length request.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO | IRP_INPUT_OPERATION);

        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke
        // the memory management routine to lock the buffer into memory.
        // This is done using an exception handler that will perform
        // cleanup if the operation fails.
        //

        if (Length) {
            mdl = (PMDL) NULL;

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off
                // of the IRP.  Probe and lock the pages associated with
                // the caller's buffer for write access and fill in the MDL
                // with the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the MDL.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer != NULL) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access
        // to it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryEa.Length = Length;
    irpSp->Parameters.QueryEa.EaIndex = eaIndexValue;
    irpSp->Flags = 0;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }
    if (ReturnSingleEntry) {
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }
    if (ARGUMENT_PRESENT( EaIndex )) {
        irpSp->Flags |= SL_INDEX_SPECIFIED;
    }

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This service replaces the Extended Attributes (EAs) associated with the file
    specified by the FileHandle parameter.  All of the EAs associated with the
    file are replaced by the EAs in the specified buffer.

Arguments:

    FileHandle - Supplies a handle to the file whose EAs should be changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer containing the new EAs which should be
        used to replace the EAs currently associated with the file.

    Length - Supplies the length, in bytes, of the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The Buffer parameter must be readable by the caller.
            //

            ProbeForRead( Buffer, Length, sizeof( ULONG ) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Cleanup and return an appropriate error status code.
            //

            return GetExceptionCode();
        }
    }


    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_WRITE_EA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_EA;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether this driver expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  if the flag is set, then a system buffer is
    // allocated and driver's data is copied to it.  If the DO_DIRECT_IO flag
    // is set in the device object, then a Memory Descriptor List (MDL) is
    // allocated and the caller's buffer is locked down using it.  Finally, if
    // the driver specifies neither of the flags, then simply pass the address
    // and length of the buffer and allow the driver to perform all of the
    // checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        PFILE_FULL_EA_INFORMATION systemBuffer;
        ULONG errorOffset;

        //
        // The driver wishes the caller's buffer to be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also check to
        // ensure that the caller's EA list is valid.  All of this is
        // performed within an exception handler that will perform
        // cleanup if the operation fails.
        //

        if (Length) {
            try {

            //
            // Allocate the intermediary system buffer and charge the caller
            // quota for its allocation.  Copy the caller's EA buffer into the
            // buffer and check to ensure that it is valid.
            //

                systemBuffer = ExAllocatePoolWithQuota( NonPagedPool, Length );

                irp->AssociatedIrp.SystemBuffer = systemBuffer;

                RtlCopyMemory( systemBuffer, Buffer, Length );

                status = IoCheckEaBufferValidity( systemBuffer,
                                                  Length,
                                                  &errorOffset );

                if (!NT_SUCCESS( status )) {
                    IoStatusBlock->Status = status;
                    IoStatusBlock->Information = errorOffset;
                    ExRaiseStatus( status );
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while allocating the buffer, copying
                // the caller's data into it, or walking the EA buffer.  Determine
                // what happened, cleanup, and return an appropriate error status
                // code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                return GetExceptionCode();

            }

            //
            // Set the flags so that the completion code knows to deallocate the
            // buffer.
            //
    
            irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
        } else {
            irp->AssociatedIrp.SystemBuffer = NULL;
        }


    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This is
        // done using an exception handler that will perform cleanup if the
        // operation fails.
        //

        mdl = (PMDL) NULL;

        if (Length) {
            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of the
                // IRP.  Probe and lock the pages associated with the caller's
                // buffer for read access and fill in the MDL with the PFNs of those
                // pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoReadAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the MDL.  Determine what actually happened,
                // clean everything up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetEa.Length = Length;


    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\qsfs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    qsfs.c

Abstract:

    This module contains the code to implement the NtQueryVolumeInformationFile
    and NtSetVolumeInformationFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 22-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"
#pragma hdrstop
#include <ioevent.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtQueryVolumeInformationFile)
#pragma alloc_text(PAGE, NtSetVolumeInformationFile)
#endif

NTSTATUS
NtQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    )

/*++

Routine Description:

    This service returns information about the volume associated with the
    FileHandle parameter.  The information returned in the buffer is defined
    by the FsInformationClass parameter.  The legal values for this parameter
    are as follows:

        o  FileFsVolumeInformation

        o  FileFsSizeInformation

        o  FileFsDeviceInformation

        o  FileFsAttributeInformation

Arguments:

    FileHandle - Supplies a handle to an open volume, directory, or file
        for which information about the volume is returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the volume.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();


    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FsInformationClass parameter is legal for querying
        // information about the volume.
        //

        if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
            IopQueryFsOperationLength[FsInformationClass] == 0) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Finally, ensure that the supplied buffer is large enough to contain
        // the information associated with the specified query operation that
        // is to be performed.
        //

        if (Length < (ULONG) IopQueryFsOperationLength[FsInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FsInformation buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( FsInformation, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( FsInformation, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( FsInformation,
                               Length,
                               IopQuerySetFsAlignmentRequirement[FsInformationClass] );

            }
#else
            ProbeForWrite( FsInformation,
                           Length,
                           IopQuerySetFsAlignmentRequirement[FsInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred probing the caller's parameters.
            // Simply return an appropriate error status code.
            //


            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopQueryFsOperationAccess[FsInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this open file object represents an open device that was explicitly
    // opened for querying the device's attributes, then ensure that the type
    // of information class was device information.
    //

    if ((fileObject->Flags & FO_DIRECT_DEVICE_OPEN) &&
        FsInformationClass != FileFsDeviceInformation) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.  A special check is made
    // here to determine whether this query is for device information.  If
    // it is, and either:
    //
    //     a)  The open was for the device itself, or
    //
    //     b)  The open was for a file but this is not a redirected device,
    //
    // then perform the query operation in-line.  That is, do not allocate
    // an IRP and call the driver, rather, simply copy the device type and
    // characteristics information from the target device object pointed
    // to by the device object in the file object (the "real" device object
    // in a mass storage device stack).
    //

    if (FsInformationClass == FileFsDeviceInformation &&
        (fileObject->Flags & FO_DIRECT_DEVICE_OPEN ||
        fileObject->DeviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM)) {

        PFILE_FS_DEVICE_INFORMATION deviceAttributes;
        BOOLEAN deviceMounted = FALSE;

        //
        // This query operation can be performed in-line.  Simply copy the
        // information directly from the target device object and indicate
        // that the operation was successful.  Begin, however, by determining
        // whether or not the device is mounted.  This cannot be done at the
        // same time as attempting to touch the user's buffer, as looking at
        // the mounted bit occurs at raised IRQL.
        //

        deviceObject = fileObject->DeviceObject;
        if (deviceObject->Vpb) {
            deviceMounted = IopGetMountFlag( deviceObject );
        }

        //
        // Copy the characteristics information from the device's object
        // into the caller's buffer.
        //

        deviceAttributes = (PFILE_FS_DEVICE_INFORMATION) FsInformation;

        try {

            deviceAttributes->DeviceType = deviceObject->DeviceType;
            deviceAttributes->Characteristics = deviceObject->Characteristics;
            if (deviceMounted) {
                deviceAttributes->Characteristics |= FILE_DEVICE_IS_MOUNTED;
            }

            IoStatusBlock->Status = STATUS_SUCCESS;
            IoStatusBlock->Information = sizeof( FILE_FS_DEVICE_INFORMATION );
            status = STATUS_SUCCESS;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            // An error occurred attempting to write into one of the caller's
            // buffers.  Simply indicate that the error occurred, and fall
            // through.
            //

            status = GetExceptionCode();
        }

        //
        // If this operation was performed as synchronous I/O, then release
        // the file object lock.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }

        //
        // Now simply cleanup and return the final status of the operation.
        //

        ObDereferenceObject( fileObject );
        return status;

    }

    if (FsInformationClass == FileFsDriverPathInformation) {

        PFILE_FS_DRIVER_PATH_INFORMATION systemBuffer = NULL;
        PFILE_FS_DRIVER_PATH_INFORMATION userBuffer = FsInformation;

        try {


            systemBuffer = ExAllocatePoolWithQuota( NonPagedPool, Length );

            RtlCopyMemory( systemBuffer,
                           userBuffer,
                           Length );

            status = IopGetDriverPathInformation(fileObject, systemBuffer, Length);

            if (!NT_SUCCESS(status)) {
                ExRaiseStatus(status);
            }

            userBuffer->DriverInPath = systemBuffer->DriverInPath; 

            ExFreePool(systemBuffer);

            IoStatusBlock->Status = STATUS_SUCCESS;
            IoStatusBlock->Information = sizeof( FILE_FS_DRIVER_PATH_INFORMATION );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while allocating the intermediary
            // system buffer or while copying the caller's data into the
            // buffer. Cleanup and return an appropriate error status code.
            //

            status = GetExceptionCode();
            if (systemBuffer) {
                ExFreePool(systemBuffer);
            }

        }

        //
        // If this operation was performed as synchronous I/O, then release
        // the file object lock.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }

        ObDereferenceObject( fileObject);
        return status;
    }

    //
    // This is either a query that is not for device characteristics
    // information, or it is a query for device information, but it is
    // a query for a redirected device.  Take the long route and actually
    // invoke the driver for the target device to get the information.
    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get a pointer to the device object for the target device.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // If this I/O operation is not being performed as synchronous I/O,
    // then allocate an event that will be used to synchronize the
    // completion of this operation.  That is, this system service is
    // a synchronous API being invoked for a file that is opened for
    // asynchronous I/O.
    //

    if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this
    // operation.  The allocation is performed with an exception handler
    // in case the caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an
        // appropriate error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer which should be used to put the information into
    // by the driver.  This will be copied back to the caller's buffer when
    // the service completes.  This is done by setting the flag which says
    // that this is an input operation.
    //

    irp->UserBuffer = FsInformation;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    //
    // Allocate the system buffer using an exception handler in case the
    // caller doesn't have enough quota remaining.
    //

    try {

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred attempting to allocate the inter-
        // mediary buffer.  Cleanup and return with an appropriate error
        // status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();

    }

    irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                           IRP_DEALLOCATE_BUFFER |
                           IRP_INPUT_OPERATION |
                           IRP_DEFER_IO_COMPLETION);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryVolume.Length = Length;
    irpSp->Parameters.QueryVolume.FsInformationClass = FsInformationClass;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    )

/*++

Routine Description:

    This service changes information about the volume "mounted" on the device
    specified by the FileHandle parameter.  The information to be changed is
    in the FsInformation buffer.  Its contents are defined by the FsInformation-
    Class parameter, whose values may be as follows:

        o  FileFsLabelInformation

Arguments:

    FileHandle - Supplies a handle to the volume whose information should be
        changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FsInformation - Supplies a buffer containing the information which should
        be changed on the volume.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        changed about the volume.

Return Value:

    The status returned is the final completion status of the operation.
    block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    PFILE_FS_LABEL_INFORMATION labelInformation;
    BOOLEAN synchronousIo;
    PDEVICE_OBJECT targetDeviceObject;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FsInformationClass parameter is legal for setting
        // information about the volume.
        //

        if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
            IopSetFsOperationLength[FsInformationClass] == 0) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Finally, ensure that the supplied buffer is large enough to contain
        // the information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopSetFsOperationLength[FsInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FsInformation buffer must be readable by the caller.
            //

#if defined(_X86_)
            ProbeForRead( FsInformation, Length, sizeof( ULONG ) );
#elif defined(_IA64_)
            // If we are a wow64 process, follow the X86 rules
            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForRead( FsInformation, Length, sizeof( ULONG ) );
            }
            else {
                ProbeForRead( FsInformation,
                              Length,
                              IopQuerySetFsAlignmentRequirement[FsInformationClass] );

            }
#else
            ProbeForRead( FsInformation,
                          Length,
                          IopQuerySetFsAlignmentRequirement[FsInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopSetFsOperationAccess[FsInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Retrieve the device object associated with this file handle.
    //
    
    status = IoGetRelatedTargetDevice( fileObject, &targetDeviceObject );

    if (NT_SUCCESS( status )) {
        //
        // The PDO associated with the devnode we got back from
        // IoGetRelatedTargetDevice has already been referenced by that
        // routine.  Store this reference away in the notification entry,
        // so we can deref it later when the notification entry is unregistered.
        //
    
        ASSERT(targetDeviceObject);
    
    } else {
        targetDeviceObject = NULL;
    }


    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  if this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                if (targetDeviceObject != NULL) {
                    ObDereferenceObject( targetDeviceObject );
                }
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            if (targetDeviceObject != NULL) {
                ObDereferenceObject( targetDeviceObject );
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (targetDeviceObject != NULL) {
            ObDereferenceObject( targetDeviceObject );
        }
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_VOLUME_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer and copy the information that is to be set on the
    // file into it.  Also, set the flags so that the completion code will
    // properly handle getting rid of the buffer and will not attempt to
    // copy data.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
        RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, FsInformation, Length );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred attempting to allocate the intermediary
        // buffer or while copying the caller's data to the buffer. Determine
        // what happened, cleanup, and return an appropriate error status
        // code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        if (targetDeviceObject != NULL) {
            ObDereferenceObject( targetDeviceObject );
        }
        
        return GetExceptionCode();

    }

    //
    // If the previous mode was not kernel, check the captured label buffer
    // for consistency.
    //

    if (requestorMode != KernelMode &&
        FsInformationClass == FileFsLabelInformation) {

        //
        // The previous mode was something other than kernel.  Check to see
        // whether or not the length of the label specified within the label
        // structure is consistent with the overall length of the structure
        // itself.  If not, then cleanup and get out.
        //

        labelInformation = (PFILE_FS_LABEL_INFORMATION) irp->AssociatedIrp.SystemBuffer;

        if ((LONG) labelInformation->VolumeLabelLength < 0 ||
            labelInformation->VolumeLabelLength +
            FIELD_OFFSET( FILE_FS_LABEL_INFORMATION, VolumeLabel ) > Length) {

            IopExceptionCleanup( fileObject,
                                 irp,
                                 (PKEVENT) NULL,
                                 event );

            if (targetDeviceObject != NULL) {
                ObDereferenceObject( targetDeviceObject );
            }
            
            return STATUS_INVALID_PARAMETER;
        }
    }

    irp->Flags |= (ULONG) (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetVolume.Length = Length;
    irpSp->Parameters.SetVolume.FsInformationClass = FsInformationClass;


    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    //
    //  Notify anyone who cares about the label change
    //

    if (targetDeviceObject != NULL) {
        if (NT_SUCCESS( status )) {
            TARGET_DEVICE_CUSTOM_NOTIFICATION ChangeEvent;
    
            ChangeEvent.Version = 1;
            ChangeEvent.FileObject = NULL;
            ChangeEvent.NameBufferOffset = -1;
            ChangeEvent.Size = (USHORT)FIELD_OFFSET( TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer );
            
            RtlCopyMemory( &ChangeEvent.Event, &GUID_IO_VOLUME_CHANGE, sizeof( GUID_IO_VOLUME_CHANGE ));
            
            IoReportTargetDeviceChange( targetDeviceObject, &ChangeEvent );
        }

        ObDereferenceObject( targetDeviceObject );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=io

TARGETNAME=iomgr
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;..\..;\
         ..\..\..\inc;\
         $(DDK_INC_PATH);\
         $(NET_INC_PATH);\
         $(SDKTOOLS_INC_PATH);\
         $(HALKIT_INC_PATH)

SOURCES= \
        ..\arcsec.c \
        ..\cancelapi.c \
        ..\complete.c \
        ..\create.c   \
        ..\devctrl.c  \
        ..\dev2dos.c \
        ..\dumpctl.c \
        ..\dir.c      \
        ..\errorlog.c \
        ..\fsctrl.c   \
        ..\internal.c \
        ..\iodata.c   \
        ..\ioinit.c   \
        ..\iosubs.c   \
        ..\ioverifier.c \
        ..\ioPerf.c \
        ..\loadunld.c \
        ..\lock.c     \
        ..\misc.c     \
        ..\objsup.c   \
        ..\open.c     \
        ..\parse.c    \
        ..\qsea.c     \
        ..\qsfs.c     \
        ..\qsinfo.c   \
        ..\qsquota.c  \
        ..\query.c \
        ..\read.c     \
        ..\triage.c \
        ..\write.c

NTTEST=
OPTIONAL_NTTEST=tio

PRECOMPILED_INCLUDE=..\iomgr.h
PRECOMPILED_PCH=iomgr.pch
PRECOMPILED_OBJ=iomgr.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\qsinfo.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    qsinfo.c

Abstract:

    This module contains the code to implement the NtQueryInformationFile and
    NtSetInformationFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 6-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

//
// Create local definitions for long flag names to make code slightly more
// readable.
//

#define FSIO_A  FILE_SYNCHRONOUS_IO_ALERT
#define FSIO_NA FILE_SYNCHRONOUS_IO_NONALERT

//
// Forward declarations of local routines.
//

ULONG
IopGetModeInformation(
    IN PFILE_OBJECT FileObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopGetModeInformation)
#pragma alloc_text(PAGE, NtQueryInformationFile)
#pragma alloc_text(PAGE, NtSetInformationFile)
#endif


ULONG
IopGetModeInformation(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This encapsulates extracting and translating the mode bits from
    the passed file object, to be returned from a query information call.

Arguments:

    FileObject - Specifies the file object for which to return Mode info.

Return Value:

    The translated mode information is returned.

--*/

{
    ULONG mode = 0;

    if (FileObject->Flags & FO_WRITE_THROUGH) {
        mode = FILE_WRITE_THROUGH;
    }
    if (FileObject->Flags & FO_SEQUENTIAL_ONLY) {
        mode |= FILE_SEQUENTIAL_ONLY;
    }
    if (FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        mode |= FILE_NO_INTERMEDIATE_BUFFERING;
    }
    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        if (FileObject->Flags & FO_ALERTABLE_IO) {
            mode |= FILE_SYNCHRONOUS_IO_ALERT;
        } else {
            mode |= FILE_SYNCHRONOUS_IO_NONALERT;
        }
    }
    if (FileObject->Flags & FO_DELETE_ON_CLOSE) {
        mode |= FILE_DELETE_ON_CLOSE;
    }
    return mode;
}

NTSTATUS
NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file about which the requested
        information should be returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    BOOLEAN skipDriver;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FileInformationClass parameter is legal for querying
        // information about the file.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Ensure that the supplied buffer is large enough to contain the
        // information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FileInformation buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( FileInformation,
                               Length,
                               IopQuerySetAlignmentRequirement[FileInformationClass] );
            }
#else
            ProbeForWrite( FileInformation,
                           Length,
                           IopQuerySetAlignmentRequirement[FileInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters.  Simply return an appropriate error status
            // code.
            //


            return GetExceptionCode();
        }

#if DBG

    } else {

        //
        // The caller's mode is kernel.  Ensure that at least the information
        // class and lengths are appropriate.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (Length < (ULONG) IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

#endif // DBG

    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopQueryOperationAccess[FileInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.  Also get the address of the Fast Io
    // dispatch structure.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to query the file position pointer.  If so, then
        // return it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested the current file position context
            // information.  This is a relatively frequent call, so it is
            // optimized here to cut through the normal IRP path.
            //
            // Begin by establishing a condition handler and attempting to
            // return both the file position information as well as the I/O
            // status block.  If writing the output buffer fails, then return
            // an appropriate error status code.  If writing the I/O status
            // block fails, then ignore the error.  This is what would
            // normally happen were everything to go through normal special
            // kernel APC processing.
            //

            BOOLEAN writingBuffer = TRUE;
            PFILE_POSITION_INFORMATION fileInformation = FileInformation;

            try {

                //
                // Return the current position information.
                //

                fileInformation->CurrentByteOffset = fileObject->CurrentByteOffset;
                writingBuffer = FALSE;

                //
                // Write the I/O status block.
                //

                IoStatusBlock->Status = STATUS_SUCCESS;
                IoStatusBlock->Information = sizeof( FILE_POSITION_INFORMATION );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                // One of writing the caller's buffer or writing the I/O
                // status block failed.  Set the final status appropriately.
                //

                if (writingBuffer) {
                    status = GetExceptionCode();
                }

            }

            //
            // Note that the state of the event in the file object has not yet
            // been reset, so it need not be set either.  Therefore, simply
            // cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;

        //
        // Also do a special check if the caller it doing a query for basic or
        // standard information and if so then try the fast query calls if they
        // exist.
        //

        } else if (fastIoDispatch &&
                   (((FileInformationClass == FileBasicInformation) &&
                     fastIoDispatch->FastIoQueryBasicInfo) ||
                    ((FileInformationClass == FileStandardInformation) &&
                     fastIoDispatch->FastIoQueryStandardInfo))) {

            IO_STATUS_BLOCK localIoStatus;
            BOOLEAN queryResult = FALSE;
            BOOLEAN writingStatus = FALSE;

            //
            // Do the query and setting of the IoStatusBlock inside an exception
            // handler.  Note that if an exception occurs, other than writing
            // the status back, then the IRP route will be taken.  If an error
            // occurs attempting to write the status back to the caller's buffer
            // then it will be ignored, just as it would be on the long path.
            //

            try {

                if (FileInformationClass == FileBasicInformation) {
                    queryResult = fastIoDispatch->FastIoQueryBasicInfo( fileObject,
                                                                        TRUE,
                                                                        FileInformation,
                                                                        &localIoStatus,
                                                                        deviceObject );
                } else {
                    queryResult = fastIoDispatch->FastIoQueryStandardInfo( fileObject,
                                                                           TRUE,
                                                                           FileInformation,
                                                                           &localIoStatus,
                                                                           deviceObject );
                }

                if (queryResult) {
                    status = localIoStatus.Status;
                    writingStatus = TRUE;
                    *IoStatusBlock = localIoStatus;
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                // If the result of the preceeding block is an exception that
                // occurred after the Fast I/O path itself, then the query
                // actually succeeded so everything is done already, but the
                // user's I/O status buffer is not writable.  This case is
                // ignored to be consistent w/the long path.
                //

                if (!writingStatus) {
                    status = GetExceptionCode();
                }
            }

            //
            // If the results of the preceeding statement block is true, then
            // the fast query call succeeeded, so simply cleanup and return.
            //

            if (queryResult) {

                //
                // Note that once again, the event in the file object has not
                // yet been set reset, so it need not be set to the Signaled
                // state, so simply cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer which should be used to put the information into by
    // the driver.  This will be copied back to the caller's buffer when the
    // service completes.  This is done by setting the flag which says that
    // this is an input operation.
    //

    irp->UserBuffer = FileInformation;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        //
        // Allocate the system buffer using an exception handler so that
        // errors can be caught and handled.
        //

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred by attempting to allocate the intermediary
        // system buffer.  Cleanup everything and return an appropriate error
        // status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();
    }

    irp->Flags |= IRP_BUFFERED_IO |
                  IRP_DEALLOCATE_BUFFER |
                  IRP_INPUT_OPERATION |
                  IRP_DEFER_IO_COMPLETION;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Update the operation count statistic for the current process for
    // operations other than read and write.
    //

    IopUpdateOtherOperationCount();

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // is device independent.  If this is the case, then the request can
    // be satisfied here without having to have all of the drivers implement
    // the same code.  Note that having the IRP is still necessary since
    // the I/O completion code requires it.
    //

    skipDriver = FALSE;

    if (FileInformationClass == FileAccessInformation) {

        PFILE_ACCESS_INFORMATION accessBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the access information for this file.
        //

        accessBuffer->AccessFlags = handleInformation.GrantedAccess;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_ACCESS_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the mode information for this file.
        //

        modeBuffer->Mode = IopGetModeInformation( fileObject );

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_MODE_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileAlignmentInformation) {

        PFILE_ALIGNMENT_INFORMATION alignmentInformation = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the alignment information for this file.
        //

        alignmentInformation->AlignmentRequirement = deviceObject->AlignmentRequirement;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_ALIGNMENT_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileAllInformation) {

        PFILE_ALL_INFORMATION allInformation = irp->AssociatedIrp.SystemBuffer;

        //
        // The caller has requested all of the information about the file.
        // This request is handled specially because the service will fill
        // in the Access and Mode and Alignment information in the buffer
        // and then pass the buffer to the driver to fill in the remainder.
        //
        // Begin by returning the Access information for the file.
        //

        allInformation->AccessInformation.AccessFlags =
            handleInformation.GrantedAccess;

        //
        // Return the mode information for this file.
        //

        allInformation->ModeInformation.Mode =
            IopGetModeInformation( fileObject );

        //
        // Return the alignment information for this file.
        //

        allInformation->AlignmentInformation.AlignmentRequirement =
            deviceObject->AlignmentRequirement;

        //
        // Finally, set the information field of the IoStatus block in the IRP
        // to account for the amount information already filled in and invoke
        // the driver to fill in the remainder.
        //

        irp->IoStatus.Information = sizeof( FILE_ACCESS_INFORMATION ) +
                                    sizeof( FILE_MODE_INFORMATION ) +
                                    sizeof( FILE_ALIGNMENT_INFORMATION );
    }

    if (skipDriver) {

        //
        // The requested operation has already been performed.  Simply
        // set the final status in the packet and the return state.
        //

        status = STATUS_SUCCESS;
        irp->IoStatus.Status = STATUS_SUCCESS;

    } else {

        //
        // This is not a request that can be [completely] performed here, so
        // invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            status = KeWaitForSingleObject( &fileObject->Event,
                                            Executive,
                                            requestorMode,
                                            (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists so that synchronization
                // with the file object will remain intact.
                //

                IopCancelAlertedRequest( &fileObject->Event, irp );

            }

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            status = KeWaitForSingleObject( event,
                                            Executive,
                                            requestorMode,
                                            FALSE,
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists or the event will not
                // be around to set to the Signaled state.
                //

                IopCancelAlertedRequest( event, irp );

            }

            status = localIoStatus.Status;

            try {

                *IoStatusBlock = localIoStatus;

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception occurred attempting to write the caller's I/O
                // status block.  Simply change the final status of the operation
                // to the exception code.
                //

                status = GetExceptionCode();
            }

            ExFreePool( event );

        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
            ExFreePool( event );
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return status;
}

NTSTATUS
NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service changes the provided information about a specified file.  The
    information that is changed is determined by the FileInformationClass that
    is specified.  The new information is taken from the FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file whose information should be
        changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer containing the information which should
        be changed on the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        changed about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    HANDLE targetHandle = (HANDLE) NULL;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FileInformationClass parameter is legal for setting
        // information about the file.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopSetOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Ensure that the supplied buffer is large enough to contain the
        // information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopSetOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FileInformation buffer must be readable by the caller.
            //

#if defined(_X86_)
            ProbeForRead( FileInformation,
                          Length,
                          Length == sizeof( BOOLEAN ) ? sizeof( BOOLEAN ) : sizeof( ULONG ) );
#elif defined(_WIN64)
            // If we are a wow64 process, follow the X86 rules
            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForRead( FileInformation,
                              Length,
                              Length == sizeof( BOOLEAN ) ? sizeof( BOOLEAN ) : sizeof( ULONG ) );
            }
            else {
                ProbeForRead( FileInformation,
                              Length,
                              IopQuerySetAlignmentRequirement[FileInformationClass] );
            }
#else
            ProbeForRead( FileInformation,
                          Length,
                          IopQuerySetAlignmentRequirement[FileInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();

        }

#if DBG

    } else {

        //
        // The caller's mode is kernel.  Ensure that at least the information
        // class and lengths are appropriate.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopSetOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (Length < (ULONG) IopSetOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

#endif // DBG

    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopSetOperationAccess[FileInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to set the file position pointer information.  If so,
        // then set it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested setting the current file position
            // context information.  This is a relatively frequent call, so
            // it is optimized here to cut through the normal IRP path.
            //
            // Begin by checking to see whether the file was opened with no
            // intermediate buffering.  If so, then the file pointer must be
            // set in a manner consistent with the alignment requirement of
            // read and write operations to a non-buffered file.
            //

            PFILE_POSITION_INFORMATION fileInformation = FileInformation;
            LARGE_INTEGER currentByteOffset;

            try {

                //
                // Attempt to read the position information from the buffer.
                //

                currentByteOffset.QuadPart = fileInformation->CurrentByteOffset.QuadPart;

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return GetExceptionCode();
            }

            if ((fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING &&
                 (deviceObject->SectorSize &&
                 (currentByteOffset.LowPart &
                 (deviceObject->SectorSize - 1)))) ||
                 currentByteOffset.HighPart < 0) {

                    status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Set the current file position information.
                //

                fileObject->CurrentByteOffset.QuadPart = currentByteOffset.QuadPart;

                try {

                    //
                    // Write the I/O status block.
                    //

                    IoStatusBlock->Status = STATUS_SUCCESS;
                    IoStatusBlock->Information = 0;

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    //
                    // Writes to I/O status blocks are ignored since the
                    // operation succeeded.
                    //

                    NOTHING;

                }

            }

            //
            // Update the transfer count statistic for the current process for
            // operations other than read and write.
            //
        
            IopUpdateOtherTransferCount( Length );

            //
            // Note that the file object's event has not yet been reset,
            // so it is not necessary to set it to the Signaled state, since
            // that is it's state at this point by definition.  Therefore,
            // simply cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // If a link is being tracked, handle this out-of-line.
    //

    if (FileInformationClass == FileTrackingInformation) {
        status = IopTrackLink( fileObject,
                               &localIoStatus,
                               FileInformation,
                               Length,
                               synchronousIo ? &fileObject->Event : event,
                               requestorMode );
        if (NT_SUCCESS( status )) {
            try {
                IoStatusBlock->Information = 0;
                IoStatusBlock->Status = status;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }
        }

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        } else {
            ExFreePool( event );
        }
        ObDereferenceObject( fileObject );
        return status;
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer and copy the information that is to be set on the
    // file into it.  Also, set the flags so that the completion code will
    // properly handle getting rid of the buffer and will not attempt to
    // copy data.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        PVOID systemBuffer;

        systemBuffer =
        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
        RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                       FileInformation,
                       Length );

        //
        //  Negative file offsets are illegal.
        //

        ASSERT((FIELD_OFFSET(FILE_END_OF_FILE_INFORMATION, EndOfFile) |
                FIELD_OFFSET(FILE_ALLOCATION_INFORMATION, AllocationSize) |
                FIELD_OFFSET(FILE_POSITION_INFORMATION, CurrentByteOffset)) == 0);

        if (((FileInformationClass == FileEndOfFileInformation) ||
             (FileInformationClass == FileAllocationInformation) ||
             (FileInformationClass == FilePositionInformation)) &&
            (((PFILE_POSITION_INFORMATION)systemBuffer)->CurrentByteOffset.HighPart < 0)) {

            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }



    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while allocating the intermediary
        // system buffer or while copying the caller's data into the
        // buffer. Cleanup and return an appropriate error status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();

    }

    irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_DEFER_IO_COMPLETION;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Update the operation count statistic for the current process for
    // operations other than read and write.
    //

    IopUpdateOtherOperationCount();


    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // to set is device independent.  If this is the case, then the request
    // can be satisfied here without having to have all of the drivers
    // implement the same code.  Note that having the IRP is still necessary
    // since the I/O completion code requires it.
    //

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Set the various flags in the mode field for the file object, if
        // they are reasonable.  There are 4 different invalid combinations
        // that the caller may not specify:
        //
        //     1)  An invalid flag was set in the mode field.  Not all Create/
        //         Open options may be changed.
        //
        //     2)  The caller set one of the synchronous I/O flags (alert or
        //         nonalert), but the file is not opened for synchronous I/O.
        //
        //     3)  The file is opened for synchronous I/O but the caller did
        //         not set either of the synchronous I/O flags (alert or non-
        //         alert).
        //
        //     4)  The caller set both of the synchronous I/O flags (alert and
        //         nonalert).
        //

        if ((modeBuffer->Mode & ~FILE_VALID_SET_FLAGS) ||
            ((modeBuffer->Mode & (FSIO_A | FSIO_NA)) && (!(fileObject->Flags & FO_SYNCHRONOUS_IO))) ||
            ((!(modeBuffer->Mode & (FSIO_A | FSIO_NA))) && (fileObject->Flags & FO_SYNCHRONOUS_IO)) ||
            (((modeBuffer->Mode & FSIO_A) && (modeBuffer->Mode & FSIO_NA) ))) {
            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Set or clear the appropriate flags in the file object.
            //

            if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)) {
                if (modeBuffer->Mode & FILE_WRITE_THROUGH) {
                    fileObject->Flags |= FO_WRITE_THROUGH;
                } else {
                    fileObject->Flags &= ~FO_WRITE_THROUGH;
                }
            }

            if (modeBuffer->Mode & FILE_SEQUENTIAL_ONLY) {
                fileObject->Flags |= FO_SEQUENTIAL_ONLY;
            } else {
                fileObject->Flags &= ~FO_SEQUENTIAL_ONLY;
            }

            if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
                if (modeBuffer->Mode & FSIO_A) {
                    fileObject->Flags |= FO_ALERTABLE_IO;
                } else {
                    fileObject->Flags &= ~FO_ALERTABLE_IO;
                }
            }

            status = STATUS_SUCCESS;
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0L;

    } else if (FileInformationClass == FileRenameInformation ||
               FileInformationClass == FileLinkInformation ||
               FileInformationClass == FileMoveClusterInformation) {

        //
        // Note that following code depends on the fact that the rename
        // information, link information and copy-on-write information
        // structures look exactly the same.
        //

        PFILE_RENAME_INFORMATION renameBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // The information being set is a variable-length structure with
        // embedded size information.  Walk the structure to ensure that
        // it is valid so the driver does not walk off the end and incur
        // an access violation in kernel mode.
        //
 
        if (renameBuffer->FileNameLength <= 0 || (renameBuffer->FileNameLength & (sizeof(WCHAR) -1))) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;
        } else if ((ULONG) (Length - FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName[0] )) < renameBuffer->FileNameLength) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        } else {

            //
            // Copy the value of the replace BOOLEAN (or the ClusterCount field)
            // from the caller's buffer to the I/O stack location parameter
            // field where it is expected by file systems.
            //

            if (FileInformationClass == FileMoveClusterInformation) {
                irpSp->Parameters.SetFile.ClusterCount =
                    ((FILE_MOVE_CLUSTER_INFORMATION *) renameBuffer)->ClusterCount;
            } else {
                irpSp->Parameters.SetFile.ReplaceIfExists = renameBuffer->ReplaceIfExists;
            }

            //
            // Check to see whether or not a fully qualified pathname was
            // supplied.  If so, then more processing is required.
            //

            if (renameBuffer->FileName[0] == (WCHAR) OBJ_NAME_PATH_SEPARATOR ||
                renameBuffer->RootDirectory) {

                //
                // A fully qualified file name was specified as the target of
                // the rename operation.  Attempt to open the target file and
                // ensure that the replacement policy for the file is consistent
                // with the caller's request, and ensure that the file is on the
                // same volume.
                //

                status = IopOpenLinkOrRenameTarget( &targetHandle,
                                                    irp,
                                                    renameBuffer,
                                                    fileObject );
                if (!NT_SUCCESS( status )) {
                    irp->IoStatus.Status = status;

                } else {

                    //
                    // The fully qualified file name specifies a file on the
                    // same volume and if it exists, then the caller specified
                    // that it should be replaced.
                    //

                    status = IoCallDriver( deviceObject, irp );

                }

            } else {

                //
                // This is a simple rename operation, so call the driver and
                // let it perform the rename operation within the same directory
                // as the source file.
                //

                status = IoCallDriver( deviceObject, irp );

            }
        }

    } else if (FileInformationClass == FileShortNameInformation) {

        PFILE_NAME_INFORMATION shortnameBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // The information being set is a variable-length structure with
        // embedded size information.  Walk the structure to ensure that
        // it is valid so the driver does not walk off the end and incur
        // an access violation in kernel mode.
        //
 
        if (shortnameBuffer->FileNameLength <= 0) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;
        } else if ((ULONG) (Length - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] )) < shortnameBuffer->FileNameLength) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        //
        // The short name must not begin with a separator character.
        //

        } else if (shortnameBuffer->FileName[0] == (WCHAR) OBJ_NAME_PATH_SEPARATOR) {

            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        //
        // Pass the request to the driver below.
        //

        } else {

            status = IoCallDriver( deviceObject, irp );
        }

    } else if (FileInformationClass == FileDispositionInformation) {

        PFILE_DISPOSITION_INFORMATION disposition = irp->AssociatedIrp.SystemBuffer;

        //
        // Check to see whether the disposition delete field has been set to
        // TRUE and, if so, copy the handle being used to do this to the IRP
        // stack location parameter.
        //

        if (disposition->DeleteFile) {
            irpSp->Parameters.SetFile.DeleteHandle = FileHandle;
        }

        //
        // Simply invoke the driver to perform the (un)delete operation.
        //

        status = IoCallDriver( deviceObject, irp );

    } else if (FileInformationClass == FileCompletionInformation) {

        PFILE_COMPLETION_INFORMATION completion = irp->AssociatedIrp.SystemBuffer;
        PIO_COMPLETION_CONTEXT context;
        PVOID portObject;

        //
        // It is an error if this file object already has an LPC port associated
        // with it.
        //

        if (fileObject->CompletionContext || fileObject->Flags & FO_SYNCHRONOUS_IO) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Attempt to reference the port object by its handle and convert it
            // into a pointer to the port object itself.
            //

            status = ObReferenceObjectByHandle( completion->Port,
                                                IO_COMPLETION_MODIFY_STATE,
                                                IoCompletionObjectType,
                                                requestorMode,
                                                (PVOID *) &portObject,
                                                NULL );
            if (NT_SUCCESS( status )) {

                //
                // Allocate the memory to be associated w/this file object
                //

                context = ExAllocatePoolWithTag( PagedPool,
                                                 sizeof( IO_COMPLETION_CONTEXT ),
                                                 'cCoI' );
                if (!context) {

                    ObDereferenceObject( portObject );
                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Everything was successful.  Capture the completion port
                    // and the key.
                    //

                    context->Port = portObject;
                    context->Key = completion->Key;

                    if (!InterlockedCompareExchangePointer( &fileObject->CompletionContext, context, NULL )) {

                        status = STATUS_SUCCESS;

                    } else {

                        //
                        // Someone set the completion context after the check.
                        // Simply drop everything on the floor and return an
                        // error.
                        //

                        ExFreePool( context );
                        ObDereferenceObject( portObject );
                        status = STATUS_INVALID_PARAMETER;
                    }
                }
            }
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

    } else {

        //
        // This is not a request that can be performed here, so invoke the
        // driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            status = KeWaitForSingleObject( &fileObject->Event,
                                            Executive,
                                            requestorMode,
                                            (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists so that synchronization
                // with the file object will remain intact.
                //

                IopCancelAlertedRequest( &fileObject->Event, irp );

            }

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            status = KeWaitForSingleObject( event,
                                            Executive,
                                            requestorMode,
                                            FALSE,
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists or the event will not
                // be around to set to the Signaled state.
                //

                IopCancelAlertedRequest( event, irp );

            }

            status = localIoStatus.Status;

            try {

                *IoStatusBlock = localIoStatus;

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception occurred attempting to write the caller's I/O
                // status block.  Simply change the final status of the
                // operation to the exception code.
                //

                status = GetExceptionCode();
            }

            ExFreePool( event );

        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
            ExFreePool( event );
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }

    }

    //
    // If there was a target handle generated because of a rename operation,
    // close it now.
    //

    if (targetHandle) {
        ObCloseHandle( targetHandle, KernelMode );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\read.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code to implement the NtReadFile system service.

Author:

    Darryl E. Havens (darrylh) 14-Apr-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
const KPRIORITY IopCacheHitIncrement = IO_NO_INCREMENT;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtReadFile)
#pragma alloc_text(PAGE, NtReadFileScatter)
#endif

NTSTATUS
NtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    Buffer.  If the end of the file is reached before Length bytes have
    been read, then the operation will terminate.  The actual length of
    the data read from the file will be returned in the second longword
    of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Optionally supplies an event to be signaled when the read operation
        is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Address of buffer to receive the data read from the file.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS exceptionCode;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_DATA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx(IoStatusBlock , ApcRoutine);

            //
            // The caller's data buffer must be writable from the caller's
            // mode.  This check ensures that this is the case.  Since the
            // buffer address is captured, the caller cannot change it,
            // even though he/she can change the protection from another
            // thread.  This error will be caught by the probe/lock or
            // buffer copy operations later.
            //

            ProbeForWrite( Buffer, Length, sizeof( UCHAR ) );

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Also ensure that the ByteOffset parameter is readable from
            // the caller's mode and capture it if it is present.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following Buffer
            // and ByteOffset parameter checks differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1))) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ||
                        (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it
                // is a valid argument.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the same parameters that are
        // required from any other mode.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }

#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the Buffer is properly aligned, and that the
            // length is an integral number of the block size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1))) ||
                (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it
            // is a valid argument.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the driver object's Fast I/O dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        //
        // Turbo read support.  If the file is currently cached on this
        // file object, then call the Cache Manager directly via FastIoRead
        // and try to successfully complete the request here.  Note if
        // FastIoRead returns FALSE or we get an I/O error, we simply
        // fall through and go the "long way" and create an Irp.
        //

        if (fileObject->PrivateCacheMap) {

            IO_STATUS_BLOCK localIoStatus;

            ASSERT(fastIoDispatch && fastIoDispatch->FastIoRead);

            //
            //  Negative file offsets are illegal.
            //

            if (fileOffset.HighPart < 0) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            if (fastIoDispatch->FastIoRead( fileObject,
                                            &fileOffset,
                                            Length,
                                            TRUE,
                                            keyValue,
                                            Buffer,
                                            &localIoStatus,
                                            deviceObject )

                    &&

                ((localIoStatus.Status == STATUS_SUCCESS) ||
                 (localIoStatus.Status == STATUS_BUFFER_OVERFLOW) ||
                 (localIoStatus.Status == STATUS_END_OF_FILE))) {

                //
                // Boost the priority of the current thread so that it appears
                // as if it just did I/O.  This causes background jobs that
                // get cache hits to be more responsive in terms of getting
                // more CPU time.
                //

                if (IopCacheHitIncrement) {
                    KeBoostPriorityThread( &CurrentThread->Tcb,
                                           IopCacheHitIncrement );
                }

                //
                // Carefully return the I/O status.
                //

                IopUpdateReadOperationCount( );
                IopUpdateReadTransferCount( (ULONG)localIoStatus.Information );

                try {
                    *IoStatusBlock = localIoStatus;
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    localIoStatus.Status = GetExceptionCode();
                    localIoStatus.Information = 0;
                }

                //
                // If an event was specified, set it.
                //

                if (ARGUMENT_PRESENT( Event )) {
                    KeSetEvent( eventObject, 0, FALSE );
                    ObDereferenceObject( eventObject );
                }

                //
                // Note that the file object event need not be set to the
                // Signaled state, as it is already set.
                //

                //
                // Cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );

                return localIoStatus.Status;
            }
        }
        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IopAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the driver's data will be copied into it.  Otherwise, a
    // Memory Descriptor List (MDL) is allocated and the caller's buffer is
    // locked down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer
        // and specify that it should be deallocated on completion.  Also
        // indicate that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception handler
        // that will perform cleanup if the operation fails.  Note that this
        // is only done if the operation has a non-zero length.
        //

        if (Length) {

            try {

                //
                // Allocate the intermediary system buffer from nonpaged pool
                // and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPoolCacheAligned, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the system buffer.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

            //
            // Remember the address of the caller's buffer so the copy can take
            // place during I/O completion.  Also, set the flags so that the
            // completion code knows to do the copy and to deallocate the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags = IRP_BUFFERED_IO |
                         IRP_DEALLOCATE_BUFFER |
                         IRP_INPUT_OPERATION;

        } else {

            //
            // This is a zero-length read.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;

        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This
        // is done using an exception handler that will perform cleanup if
        // the operation fails.  Note that no MDL is allocated, nor is any
        // memory probed or locked if the length of the request was zero.
        //

        PMDL mdl;

        irp->Flags = 0;

        if (Length) {

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of
                // the IRP.  Probe and lock the pages associated with the
                // caller's buffer for write access and fill in the MDL with
                // the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the MDL.  Determine what actually
                // happened, clean everything up, and return an appropriate
                // error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->Flags = 0;
        irp->UserBuffer = Buffer;
    }

    //
    // If this read operation is supposed to be performed with caching disabled
    // set the disable flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.Key = keyValue;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status =  IopSynchronousServiceTail( deviceObject,
                                         irp,
                                         fileObject,
                                         TRUE,
                                         requestorMode,
                                         synchronousIo,
                                         ReadTransfer );

    return status;
}

NTSTATUS
NtReadFileScatter(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    buffer segments.  The buffer segments are not virtually contiguous,
    but are 8 KB in length and alignment. If the end of the file is reached
    before Length bytes have been read, then the operation will terminate.
    The actual length of the data read from the file will be returned in
    the second longword of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Unused the I/O must use a completion port.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be placed.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

    Key - Unused.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:

    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFILE_SEGMENT_ELEMENT capturedArray = NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS exceptionCode;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    ULONG elementCount;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    ULONG i;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //
    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_DATA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Verify this is a valid scatter read request.  In particular it must be
    // non cached, asynchronous, use completion ports, non buffer I/O device
    // and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (fileObject->Flags & FO_SYNCHRONOUS_IO) ||
        deviceObject->Flags & DO_BUFFERED_IO ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS &&
         deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME )) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES(Length);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Also ensure that the ByteOffset parameter is readable from
            // the caller's mode and capture it if it is present.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following ByteOffset
            // parameter check differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1)))) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize)) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it
                // is a valid argument.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // The SegmentArray paramter must be accessible.
            //

#ifdef _X86_
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          sizeof( ULONG )
                          );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcess()->Wow64Process) {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              sizeof( ULONG )
                              );
            } else {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                              );
            }
#else
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                          );
#endif

            if (Length != 0) {

                //
                // Capture the segment array so it cannot be changed after
                // it has been looked at.
                //

                capturedArray = ExAllocatePoolWithQuota( PagedPool,
                                                elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                                                );

                RtlCopyMemory( capturedArray,
                               SegmentArray,
                               elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                               );

                SegmentArray = capturedArray;

                //
                // Verify that all the addresses are page aligned.
                //

                for (i = 0; i < elementCount; i++) {

                    if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the same parameters that are
        // required from any other mode.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }

#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the the length is an integral number of the block
            //  size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1)))) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize)) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it
            // is a valid argument.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }

        if (Length != 0) {

            //
            // Verify that all the addresses are page aligned.
            //

            for (i = 0; i < elementCount; i++) {

                if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {

                    ObDereferenceObject( fileObject );
                    ASSERT(FALSE);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the driver object's Fast I/O dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                if (capturedArray != NULL) {
                    ExFreePool( capturedArray );
                }
                return status;
            }
        }

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IopAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // Always allocate a Memory Descriptor List (MDL) and lock down the
    // caller's buffer. This way the file system do not have change to
    // build a scatter MDL. Note buffered I/O is not supported for this
    // routine.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;


    //
    // This is a direct I/O operation.  Allocate an MDL and invoke the
    // memory management routine to lock the buffer into memory.  This
    // is done using an exception handler that will perform cleanup if
    // the operation fails.  Note that no MDL is allocated, nor is any
    // memory probed or locked if the length of the request was zero.
    //

    irp->Flags = 0;

    if (Length) {

        PMDL mdl;

        try {

            //
            // Allocate an MDL, charging quota for it, and hang it off of
            // the IRP.  Probe and lock the pages associated with the
            // caller's buffer for write access and fill in the MDL with
            // the PFNs of those pages.
            //

            mdl = IoAllocateMdl( (PVOID)(ULONG_PTR) SegmentArray[0].Buffer, Length, FALSE, TRUE, irp );
            if (mdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            // The address of the first file segment is used as a base
            // address.
            //

            MmProbeAndLockSelectedPages( mdl,
                                         SegmentArray,
                                         requestorMode,
                                         IoWriteAccess );

            irp->UserBuffer = (PVOID)(ULONG_PTR) SegmentArray[0].Buffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either probing the caller's
            // buffer or allocating the MDL.  Determine what actually
            // happened, clean everything up, and return an appropriate
            // error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return GetExceptionCode();

        }

    }

    //
    // We are done with the captured buffer.
    //

    if (capturedArray != NULL) {
        ExFreePool( capturedArray );
    }

    //
    // If this read operation is supposed to be performed with caching disabled
    // set the disable flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.Key = keyValue;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status =  IopSynchronousServiceTail( deviceObject,
                                         irp,
                                         fileObject,
                                         TRUE,
                                         requestorMode,
                                         synchronousIo,
                                         ReadTransfer );

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\query.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the subroutines to Query Device Descriptions from
    the Hardware tree in the registry

Author:

    Andre Vachon (andreva) 20-Jun-1994

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

typedef struct _IO_QUERY_DESC {
    PINTERFACE_TYPE BusType;
    PULONG BusNumber;
    PCONFIGURATION_TYPE ControllerType;
    PULONG ControllerNumber;
    PCONFIGURATION_TYPE PeripheralType;
    PULONG PeripheralNumber;
    PIO_QUERY_DEVICE_ROUTINE CalloutRoutine;
    PVOID Context;
} IO_QUERY_DESC, *PIO_QUERY_DESC;


NTSTATUS
pIoQueryBusDescription(
    PIO_QUERY_DESC QueryDescription,
    UNICODE_STRING PathName,
    HANDLE RootHandle,
    PULONG BusNum,
    BOOLEAN HighKey
    );

NTSTATUS
pIoQueryDeviceDescription(
    PIO_QUERY_DESC QueryDescription,
    UNICODE_STRING PathName,
    HANDLE RootHandle,
    ULONG BusNum,
    PKEY_VALUE_FULL_INFORMATION *BusValueInfo
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoQueryDeviceDescription)
#pragma alloc_text(PAGE, pIoQueryBusDescription)
#pragma alloc_text(PAGE, pIoQueryDeviceDescription)
#endif




NTSTATUS
IoQueryDeviceDescription(
    IN PINTERFACE_TYPE BusType OPTIONAL,
    IN PULONG BusNumber OPTIONAL,
    IN PCONFIGURATION_TYPE ControllerType OPTIONAL,
    IN PULONG ControllerNumber OPTIONAL,
    IN PCONFIGURATION_TYPE PeripheralType OPTIONAL,
    IN PULONG PeripheralNumber OPTIONAL,
    IN PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:

    BusType - Supplies an optional bus type being searched for in the
        description tree. Valid types are Mca, Isa, Eisa ... If no bus type
        is specified, the system information (i.e. machine BIOS) is returned.

    BusNumber - Supplies an optional value determining which bus should be
        queried.

    ControllerType - Supplies an optional controller type being searched for.
        If no Controller type is specified, only the Bus information is
        returned.

    ControllerNumber - Supplies an optional value determining which
        controller should be queried.

    PeripheralType - Supplies an optional peripheral type being searched for.
        If no Controller type is specified, only the Bus information and the
        controller information are returned.

    PeripheralNumber - Supplies an optional value determining which
        peripheral should be queried.

    CalloutRoutine - Supplies a pointer to a routine that gets called
       for each successful match of PeripheralType.

    Context - Supplies a context value that is passed back to the callback
        routine.

Return Value:

    The status returned is the final completion status of the operation.

Notes:

--*/

{

#define UNICODE_NUM_LENGTH 14
#define UNICODE_REGISTRY_PATH_LENGTH 1024

    IO_QUERY_DESC queryDesc;

    NTSTATUS status;
    UNICODE_STRING registryPathName;
    HANDLE rootHandle;
    ULONG busNumber = (ULONG) -1;


    PAGED_CODE();

    ASSERT( CalloutRoutine != NULL );

    //
    // Check if we need to return the machine information
    //

    if (!ARGUMENT_PRESENT( BusType )) {
        return STATUS_NOT_IMPLEMENTED;
    }

    queryDesc.BusType = BusType;
    queryDesc.BusNumber = BusNumber;
    queryDesc.ControllerType = ControllerType;
    queryDesc.ControllerNumber = ControllerNumber;
    queryDesc.PeripheralType = PeripheralType;
    queryDesc.PeripheralNumber = PeripheralNumber;
    queryDesc.CalloutRoutine = CalloutRoutine;
    queryDesc.Context = Context;


    //
    // Set up a string with the pathname to the hardware description
    // portion of the registry.
    //

    registryPathName.Length = 0;
    registryPathName.MaximumLength = UNICODE_REGISTRY_PATH_LENGTH *
                                     sizeof(WCHAR);

    registryPathName.Buffer = ExAllocatePoolWithTag( PagedPool,
                                                     UNICODE_REGISTRY_PATH_LENGTH,
                                                     'NRoI' );

    if (!registryPathName.Buffer) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlAppendUnicodeStringToString( &registryPathName,
                                    &CmRegistryMachineHardwareDescriptionSystemName );


    //
    // Open a handle to the root path we have.
    //

    status = IopOpenRegistryKey( &rootHandle,
                                 (HANDLE) NULL,
                                 &registryPathName,
                                 KEY_READ,
                                 FALSE );

    if (NT_SUCCESS( status )) {

        status = pIoQueryBusDescription(&queryDesc,
                                        registryPathName,
                                        rootHandle,
                                        &busNumber,
                                        TRUE );

        ZwClose( rootHandle );

    }

    ExFreePool( registryPathName.Buffer );

    //
    // For compatibility with old version of the function.
    //

    if (status == STATUS_NO_MORE_ENTRIES) {

        return STATUS_OBJECT_NAME_NOT_FOUND;


    } else {

        return status;

    }
}


NTSTATUS
pIoQueryBusDescription(
    PIO_QUERY_DESC QueryDescription,
    UNICODE_STRING PathName,
    HANDLE RootHandle,
    PULONG BusNum,
    BOOLEAN HighKey
    )

/*++

Routine Description:


Arguments:

    QueryDescription - Buffer containing all the query information requested
        by the driver.

    PathName - Registry path name of the key we are dealing with.  This is
        a unicode strig so that we don't have to bother with resetting NULLs
        at the end of the string - the length determines how much of the
        string is valid.

    RootHandle - Handle equivalent to the registry path.

    BusNum - Pointer to a variable that keeps track of the bus number we are
        searching for (buses have to be accumulated.

    HighKey - Determines is this is a high key (a root key with a list of
        bus types) or a low level key (under which the number of the various
        buses will be little).

Return Value:

    The status returned is the final completion status of the operation.

Notes:

--*/

{
    NTSTATUS status;
    ULONG i;
    UNICODE_STRING unicodeString;

    UNICODE_STRING registryPathName;

    ULONG keyBasicInformationSize;
    PKEY_BASIC_INFORMATION keyBasicInformation = NULL;
    HANDLE handle;

    PKEY_FULL_INFORMATION keyInformation;
    ULONG size;

    PKEY_VALUE_FULL_INFORMATION busValueInfo[IoQueryDeviceMaxData];


    PAGED_CODE();

    status = IopGetRegistryKeyInformation( RootHandle,
                                           &keyInformation );

    if (NT_SUCCESS( status )) {

        //
        // With the keyInformation, allocate a buffer that will be large
        // enough for all the subkeys
        //

        keyBasicInformationSize = keyInformation->MaxNameLen +
                                  sizeof(KEY_NODE_INFORMATION);

        keyBasicInformation = ExAllocatePoolWithTag( PagedPool,
                                                     keyBasicInformationSize,
                                                     'BKoI' );

        ExFreePool(keyInformation);

        if (keyBasicInformation == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
    }

    //
    // Now we need to enumerate the keys and see if one of them is a bus
    //

    for (i = 0; NT_SUCCESS( status ); i++) {


        //
        // If we have found the Bus we are looking for, break
        //

        if ((ARGUMENT_PRESENT( QueryDescription->BusNumber )) &&
            (*(QueryDescription->BusNumber) == *BusNum)) {

            break;

        }

        status = ZwEnumerateKey( RootHandle,
                                 i,
                                 KeyBasicInformation,
                                 keyBasicInformation,
                                 keyBasicInformationSize,
                                 &size );

        //
        // If the sub function enumerated all the buses till the end, then
        // treat that as success.
        //

        if (!NT_SUCCESS( status )) {

            break;

        }

        //
        // Only if this is a high key (otherwise we are in the callback
        // pass which we will process later on).
        //
        // If the string is any valid bus string, then we have to go down
        // the tree recursively.
        // Otherwise, go on to the next key.
        //

        if (HighKey) {

            if (wcsncmp( keyBasicInformation->Name,
                         CmTypeString[MultiFunctionAdapter],
                         keyBasicInformation->NameLength / sizeof(WCHAR) )  &&
                wcsncmp( keyBasicInformation->Name,
                         CmTypeString[EisaAdapter],
                         keyBasicInformation->NameLength / sizeof(WCHAR) )  &&
                wcsncmp( keyBasicInformation->Name,
                         CmTypeString[TcAdapter],
                         keyBasicInformation->NameLength / sizeof(WCHAR) )) {

                //
                // All the comparisons returned 1 (which means they all were
                // unsuccessful) so we do not have a bus.
                //
                // Go on to the next key.
                //

                continue;
            }
        }

        //
        // We have a bus. Open that key and enumerate it's clidren
        // (which should be numbers)
        //

        unicodeString.Buffer = keyBasicInformation->Name;
        unicodeString.Length = (USHORT) keyBasicInformation->NameLength;
        unicodeString.MaximumLength = (USHORT) keyBasicInformation->NameLength;

        if (!NT_SUCCESS( IopOpenRegistryKey( &handle,
                                             RootHandle,
                                             &unicodeString,
                                             KEY_READ,
                                             FALSE ) )) {

            //
            // The key could not be opened. Go to the next key
            //

            continue;

        }

        //
        // We have the key. now build the name for this path.
        //
        // Reset the string to its original value
        //

        registryPathName = PathName;

        RtlAppendUnicodeToString( &registryPathName,
                                  L"\\" );

        RtlAppendUnicodeStringToString( &registryPathName,
                                        &unicodeString );


        if (!HighKey) {

            //
            // We have a Key. Get the information for that key
            //

            status = IopGetRegistryValues( handle,
                                           &busValueInfo[0] );

            if (NT_SUCCESS( status )) {

                //
                // Verify that the identifier value for this bus
                // sub-key matches the user-specified bus type.
                // If not, do not increment the number of *found*
                // buses.
                //

                if (( busValueInfo[IoQueryDeviceConfigurationData] != NULL ) &&
                    ( busValueInfo[IoQueryDeviceConfigurationData]->DataLength != 0 ) &&
                    ( ((PCM_FULL_RESOURCE_DESCRIPTOR)
                        ((PCCHAR) busValueInfo[IoQueryDeviceConfigurationData] +
                        busValueInfo[IoQueryDeviceConfigurationData]->DataOffset))
                        ->InterfaceType == *(QueryDescription->BusType) )) {

                    //
                    // Increment the number of buses of desired type we
                    // have found.
                    //

                    (*BusNum)++;

                    //
                    // If we are looking for a specific bus number,
                    // check to see if we are at the right number.
                    // If we are not goto the next bus.  Otherwise
                    // (i.e we have the right bus number, or we
                    // specified all buses), then go on so the
                    // information can be reported.
                    //

                    if ( (QueryDescription->BusNumber == NULL) ||
                         (*(QueryDescription->BusNumber) == *BusNum) ) {


                        //
                        // If we want controller information, call
                        // the controller function.
                        // Otherwise just return the bus information.
                        //

                        if (QueryDescription->ControllerType != NULL) {

                            status = pIoQueryDeviceDescription(
                                         QueryDescription,
                                         registryPathName,
                                         handle,
                                         *BusNum,
                                         (PKEY_VALUE_FULL_INFORMATION *) busValueInfo );

                        } else {

                            status = QueryDescription->CalloutRoutine(
                                         QueryDescription->Context,
                                         &registryPathName,
                                         *(QueryDescription->BusType),
                                         *BusNum,
                                         (PKEY_VALUE_FULL_INFORMATION *) busValueInfo,
                                         0,
                                         0,
                                         NULL,
                                         0,
                                         0,
                                         NULL );

                        }
                    }
                }

                //
                // Free the pool allocated for the controller value data.
                //

                if (busValueInfo[0]) {
                    ExFreePool( busValueInfo[0] );
                    busValueInfo[0] = NULL;
                }
                if (busValueInfo[1]) {
                    ExFreePool( busValueInfo[1] );
                    busValueInfo[1] = NULL;
                }
                if (busValueInfo[2]) {
                    ExFreePool( busValueInfo[2] );
                    busValueInfo[2] = NULL;
                }

            }


            //
            // Shortcurt exit to avoid the recursive call.
            //

            if ((QueryDescription->BusNumber !=NULL ) &&
                (*(QueryDescription->BusNumber) == *BusNum)) {
                ZwClose( handle );
                handle = NULL;
                continue;

            }
        }

        //
        // If we have the key handle, do recursive enumeration.
        // enumaration (for both high and low keys)
        //

        status = pIoQueryBusDescription(
                     QueryDescription,
                     registryPathName,
                     handle,
                     BusNum,
                     (BOOLEAN)!HighKey );

        //
        // If the sub function enumerated all the buses till the end, then
        // treat that as success.
        //

        if (status == STATUS_NO_MORE_ENTRIES) {

            status = STATUS_SUCCESS;

        }

        ZwClose( handle );
        handle = NULL;

    }

    if (keyBasicInformation) {
        ExFreePool( keyBasicInformation );
    }

    return status;
}




NTSTATUS
pIoQueryDeviceDescription(
    PIO_QUERY_DESC QueryDescription,
    UNICODE_STRING PathName,
    HANDLE RootHandle,
    ULONG BusNum,
    PKEY_VALUE_FULL_INFORMATION *BusValueInfo
    )

{

    NTSTATUS status;
    UNICODE_STRING registryPathName = PathName;
    UNICODE_STRING controllerBackupRegistryPathName;
    UNICODE_STRING peripheralBackupRegistryPathName;
    HANDLE controllerHandle = NULL;
    HANDLE peripheralHandle = NULL;
    PKEY_FULL_INFORMATION controllerTypeInfo = NULL;
    PKEY_FULL_INFORMATION peripheralTypeInfo = NULL;
    ULONG maxControllerNum;
    ULONG maxPeripheralNum;
    ULONG controllerNum;
    ULONG peripheralNum;
    WCHAR numBuffer[UNICODE_NUM_LENGTH];
    UNICODE_STRING bufferUnicodeString;
    PKEY_VALUE_FULL_INFORMATION controllerValueInfo[IoQueryDeviceMaxData];
    PKEY_VALUE_FULL_INFORMATION peripheralValueInfo[IoQueryDeviceMaxData];


    //
    // Set up a string for the number translation.
    //

    bufferUnicodeString.MaximumLength = UNICODE_NUM_LENGTH * sizeof(WCHAR);
    bufferUnicodeString.Buffer = &numBuffer[0];


    //         For each controller of the specified type (subkeys 0..M)
    //             if we are looking for controller information
    //                 call the specified callout routine
    //             else
    //                 For each peripheral of the specified type (subkeys 0..N)
    //                     call the specified callout routine

    //
    // Add the controller name to the registry path name.
    //

    status = RtlAppendUnicodeToString( &registryPathName,
                                       L"\\" );

    if (NT_SUCCESS( status )) {

        status = RtlAppendUnicodeToString( &registryPathName,
                                           CmTypeString[*(QueryDescription->ControllerType)] );

    }

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If a Contoller number was specified by the caller, use that
    // controller number. Otherwise, find out how many buses are present
    // by querying the key.
    //

    if (ARGUMENT_PRESENT( QueryDescription->ControllerNumber )) {

        controllerNum = *(QueryDescription->ControllerNumber);
        maxControllerNum = controllerNum + 1;

    } else {

        //
        // Open the registry key for the controller and
        // Get the full key information for the controller key to
        // determine the number of sub-keys (controller numbers).
        // And we fail, then go on to the next bus.
        // Note the memory allocated by the query must be freed.
        //

        status = IopOpenRegistryKey( &controllerHandle,
                                     (HANDLE) NULL,
                                     &registryPathName,
                                     KEY_READ,
                                     FALSE );

        if (NT_SUCCESS( status )) {

            status = IopGetRegistryKeyInformation( controllerHandle,
                                                   &controllerTypeInfo );

            ZwClose( controllerHandle );
            controllerHandle = NULL;
        }

        //
        // If no controller of this type was found on the bus, go on to
        // the next bus; goto the end of the loop with a successful status
        // so that the memory gets freed, but we continue looping.
        //

        if (!NT_SUCCESS( status )) {

            return status;

        }

        //
        // Get the number of controller sub-keys for this controller
        // type and free the pool.
        //

        maxControllerNum = controllerTypeInfo->SubKeys;
        controllerNum = 0;

        ExFreePool( controllerTypeInfo );
        controllerTypeInfo = NULL;
    }

    //
    // Make a backup of the string since we want to start where we were
    // on the next loop iteration.
    //

    controllerBackupRegistryPathName = registryPathName;

    //
    // For each controller of the specified type (subkeys 0..M).
    // We use BusNumber as the initial value since it is zero if we want
    // all buses, and we only want the bus specified if the value  is not
    // zero.
    //

    for ( ; controllerNum < maxControllerNum; controllerNum++) {

        //
        // Reset the string to its original value
        //

        registryPathName = controllerBackupRegistryPathName;

        //
        // Convert the controller number to a unicode string and append
        // it to the registry path name.
        //

        bufferUnicodeString.Length = (UNICODE_NUM_LENGTH-1) * sizeof(WCHAR);
        status = RtlIntegerToUnicodeString( controllerNum,
                                            10,
                                            &bufferUnicodeString );

        if (NT_SUCCESS( status )) {

            status = RtlAppendUnicodeToString( &registryPathName,
                                               L"\\" );

            if (NT_SUCCESS( status )) {

                status = RtlAppendUnicodeStringToString(
                                                     &registryPathName,
                                                     &bufferUnicodeString );

            }
        }

        if (!NT_SUCCESS( status )) {
            break;
        }

        //
        // Open the registry key for the controller number and
        // Get the value data for this controller and save it for later.
        //


        status = IopOpenRegistryKey( &controllerHandle,
                                     (HANDLE) NULL,
                                     &registryPathName,
                                     KEY_READ,
                                     FALSE );

        if (NT_SUCCESS( status )) {

            status = IopGetRegistryValues( controllerHandle,
                                           &controllerValueInfo[0] );

            ZwClose( controllerHandle );
            controllerHandle = NULL;
        }

        //
        // If we could not open the key and get the info, just continue
        // since there is no memory to free and we are using the for
        // loop to determine when we get to the last controller.
        //

        if (!NT_SUCCESS( status )) {
            continue;
        }

        //
        // Check if we want the controller and bus information only. If
        // it is the case, invoque the callout routine and go on to the
        // next loop (unless an error occurs in the callout).
        //

        if (!ARGUMENT_PRESENT( (QueryDescription->PeripheralType) )) {

            status = QueryDescription->CalloutRoutine(
                         QueryDescription->Context,
                         &registryPathName,
                         *(QueryDescription->BusType),
                         BusNum,
                         BusValueInfo,
                         *(QueryDescription->ControllerType),
                         controllerNum,
                         (PKEY_VALUE_FULL_INFORMATION *) controllerValueInfo,
                         0,
                         0,
                         NULL );

            goto IoQueryDeviceControllerLoop;
        }

        //
        // Add the peripheral name to the registry path name.
        //

        status = RtlAppendUnicodeToString( &registryPathName,
                                           L"\\" );

        if (NT_SUCCESS( status )) {

            status = RtlAppendUnicodeToString(
                                             &registryPathName,
                                             CmTypeString[*(QueryDescription->PeripheralType)] );

        }

        if (!NT_SUCCESS( status )) {
            goto IoQueryDeviceControllerLoop;
        }

        //
        // If a Peripheralnumber was specified by the caller, use that
        // peripheral number. Otherwise, find out how many buses are
        // present by querying the key.
        //

        if (ARGUMENT_PRESENT( (QueryDescription->PeripheralNumber) )) {

            peripheralNum = *(QueryDescription->PeripheralNumber);
            maxPeripheralNum = peripheralNum + 1;

        } else {

            //
            // Open the registry key for the peripheral and
            // Get the full key information for the peripheral key to
            // determine the number of sub-keys (peripheral numbers).
            // And we fail, then go on to the next controller.
            // Note the memory allocated by the query must be freed.
            //

            status = IopOpenRegistryKey( &peripheralHandle,
                                         (HANDLE) NULL,
                                         &registryPathName,
                     KEY_READ,
                     FALSE );

            if (NT_SUCCESS( status )) {

                status = IopGetRegistryKeyInformation( peripheralHandle,
                           &peripheralTypeInfo );

                ZwClose( peripheralHandle );
                peripheralHandle = NULL;
            }

            //
            // If no controller of this type was found on the bus, go on to
            // the next bus; goto the end of the loop with a successful
            // status so that the memory gets freed, but we continue looping.
            //

            if (!NT_SUCCESS( status )) {
                status = STATUS_SUCCESS;
                goto IoQueryDeviceControllerLoop;
            }

            //
            // Get the number of peripheral sub-keys for this peripheral
            // type and free the pool.
            //

            maxPeripheralNum = peripheralTypeInfo->SubKeys;
            peripheralNum = 0;

            ExFreePool( peripheralTypeInfo );
            peripheralTypeInfo = NULL;
        }

        //
        // Make a backup of the string since we want to start where we
        // were on the next loop iteration.
        //

        peripheralBackupRegistryPathName = registryPathName;

        //
        // For each peripheral of the specified type (subkeys 0..N).
        // We use BusNumber as the initial value since it is zero if we
        // want all buses, and we only want the bus specified if the
        // value is not zero.
        //

        for ( ; peripheralNum < maxPeripheralNum; peripheralNum++) {

            //
            // Reset the string to its original value.
            //

            registryPathName = peripheralBackupRegistryPathName;

            //
            // Convert the peripheral number to a unicode string and append
            // it to the registry path name.
            //

            bufferUnicodeString.Length =
                (UNICODE_NUM_LENGTH-1) * sizeof(WCHAR);
            status = RtlIntegerToUnicodeString( peripheralNum,
                                                10,
                                                &bufferUnicodeString );

            if (NT_SUCCESS( status )) {

                status = RtlAppendUnicodeToString( &registryPathName,
                                                   L"\\" );

                if (NT_SUCCESS( status )) {

                    status = RtlAppendUnicodeStringToString(
                                                     &registryPathName,
                                                     &bufferUnicodeString );

                }
            }

            if (!NT_SUCCESS( status )) {
                break;
            }

            //
            // Open the registry key for the peripheral number and
            // Get the value data for this peripheral and save it for
            // later.
            //

            status = IopOpenRegistryKey( &peripheralHandle,
                                         (HANDLE) NULL,
                                         &registryPathName,
                                         KEY_READ,
                                         FALSE );

            if (NT_SUCCESS( status )) {

                status = IopGetRegistryValues( peripheralHandle,
                                               &peripheralValueInfo[0] );

                ZwClose( peripheralHandle );
                peripheralHandle = NULL;
            }

            //
            // If getting the peripheral information worked properly,
            // call the user-specified callout routine.
            //

            if (NT_SUCCESS( status )) {

                status = QueryDescription->CalloutRoutine(
                             QueryDescription->Context,
                             &registryPathName,
                             *(QueryDescription->BusType),
                             BusNum,
                             BusValueInfo,
                             *(QueryDescription->ControllerType),
                             controllerNum,
                             (PKEY_VALUE_FULL_INFORMATION *) controllerValueInfo,
                             *(QueryDescription->PeripheralType),
                             peripheralNum,
                             (PKEY_VALUE_FULL_INFORMATION *) peripheralValueInfo );

                //
                // Free the pool allocated for the peripheral value data.
                //

                if (peripheralValueInfo[0]) {
                    ExFreePool( peripheralValueInfo[0] );
                    peripheralValueInfo[0] = NULL;
                }
                if (peripheralValueInfo[1]) {
                    ExFreePool( peripheralValueInfo[1] );
                    peripheralValueInfo[1] = NULL;
                }
                if (peripheralValueInfo[2]) {
                    ExFreePool( peripheralValueInfo[2] );
                    peripheralValueInfo[2] = NULL;
                }

                //
                // If the user-specified callout routine returned with
                // an unsuccessful status, quit.
                //

                if (!NT_SUCCESS( status )) {
                    break;
               }
            }

        } // for ( ; peripheralNum < maxPeripheralNum ...

IoQueryDeviceControllerLoop:

        //
        // Free the pool allocated for the controller value data.
        //

        if (controllerValueInfo[0]) {
            ExFreePool( controllerValueInfo[0] );
            controllerValueInfo[0] = NULL;
        }
        if (controllerValueInfo[1]) {
            ExFreePool( controllerValueInfo[1] );
            controllerValueInfo[1] = NULL;
        }
        if (controllerValueInfo[2]) {
            ExFreePool( controllerValueInfo[2] );
            controllerValueInfo[2] = NULL;
        }

        if (!NT_SUCCESS( status )) {
            break;
        }

    } // for ( ; controllerNum < maxControllerNum...


    return( status );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\qsquota.c ===
/*++

Copyright (c) 1989 - 1995  Microsoft Corporation

Module Name:

    qsquota.c

Abstract:

    This module contains the code to implement the NtQueryQuotaInformationFile
    and the NtSetQuotaInformationFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 20-Jun-1995

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtQueryQuotaInformationFile)
#pragma alloc_text(PAGE, NtSetQuotaInformationFile)
#endif

NTSTATUS
NtQueryQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID SidList OPTIONAL,
    IN ULONG SidListLength,
    IN PULONG StartSid OPTIONAL,
    IN BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service returns quota entries associated with the volume specified
    by the FileHandle parameter.  The amount of information returned is based
    on the size of the quota information associated with the volume, the size
    of the buffer, and whether or not a specific set of entries has been
    requested.

Arguments:

    FileHandle - Supplies a handle to the file/volume for which the quota
        information is returned.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer to receive the quota information for the volume.

    Length - Supplies the length, in bytes, of the buffer.

    ReturnSingleEntry - Indicates that only a single entry should be returned
        rather than filling the buffer with as many entries as possible.

    SidList - Optionally supplies a list of SIDs whose quota information is to
        be returned.

    SidListLength - Supplies the length of the SID list, if one was specified.

    StartSid - Supplies an optional SID that indicates that the returned
        information is to start with an entry other than the first.  This
        parameter is ignored if a SidList is specified.

    RestartScan - Indicates whether the scan of the quota information is to be
        restarted from the beginning.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{

#define ALIGN_LONG( Address ) ( (Address + 3) & ~3 )

    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    PCHAR auxiliaryBuffer = (PCHAR) NULL;
    ULONG startSidLength = 0;
    PSID startSid = (PSID) NULL;
    PFILE_GET_QUOTA_INFORMATION sidList = (PFILE_GET_QUOTA_INFORMATION) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    UCHAR subCount;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( Buffer, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( Buffer, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( Buffer, Length, sizeof( ULONGLONG ) );
            }
#else
            ProbeForWrite( Buffer, Length, sizeof( ULONGLONG ) );
#endif

            //
            // If the optional StartSid parameter was specified, then it must
            // be readable by the caller.  Begin by capturing the length of
            // the SID so that the SID itself can be captured.
            //

            if (ARGUMENT_PRESENT( StartSid )) {

                subCount = ProbeAndReadUchar( &(((SID *)(StartSid))->SubAuthorityCount) );
                startSidLength = RtlLengthRequiredSid( subCount );
                ProbeForRead( StartSid, startSidLength, sizeof( ULONG ) );
            }

            //
            // If the optional SidList parameter was specified, then it must
            // be readable by the caller.  Validate that the buffer contains
            // a legal get information structure.
            //

            if (ARGUMENT_PRESENT( SidList ) && SidListLength) {

                ProbeForRead( SidList, SidListLength, sizeof( ULONG ) );
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           ALIGN_LONG( SidListLength ) +
                                                           startSidLength );
                sidList = (PFILE_GET_QUOTA_INFORMATION) auxiliaryBuffer;

                RtlCopyMemory( auxiliaryBuffer, SidList, SidListLength );

            } else {

                //
                // No SidList was specified.  Check to see whether or not a
                // StartSid was specified and, if so, capture it.  Note that
                // the SID has already been probed.
                //

                SidListLength = 0;
                if (ARGUMENT_PRESENT( StartSid )) {
                    auxiliaryBuffer = ExAllocatePoolWithQuota( PagedPool,
                                                               startSidLength );
                }
            }

            //
            // If a StartSid was specified tack it onto the end of the auxiliary
            // buffer.
            //

            if (ARGUMENT_PRESENT( StartSid )) {
                startSid = (PSID) (auxiliaryBuffer + ALIGN_LONG( SidListLength ));

                RtlCopyMemory( startSid, StartSid, startSidLength );
                ((SID *) startSid)->SubAuthorityCount = subCount;
            }


        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters, allocating the pool buffer, or copying the
            // caller's EA list to the buffer.  Cleanup and return an
            // appropriate error status code.
            //

            if (auxiliaryBuffer) {
                ExFreePool( auxiliaryBuffer );
            }

            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was KernelMode.  Simply allocate pool for the
        // SidList, if one was specified, and copy the string to it.  Also,
        // if a StartSid was specified copy it as well.
        //

        if (ARGUMENT_PRESENT( SidList ) && SidListLength) {
            sidList = SidList;
        }

        if (ARGUMENT_PRESENT( StartSid )) {
            startSid = StartSid;
        }
    }

    //
    // Always check the validity of the buffer since the server uses this 
    // routine.
    //

    if (sidList != NULL) {
        status = IopCheckGetQuotaBufferValidity( sidList,
                                                 SidListLength,
                                                 &IoStatusBlock->Information );
        if (!NT_SUCCESS( status )) {
            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }
            return status;

        }
    }

    if (startSid != NULL) {

        if (!RtlValidSid( startSid )) {
            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }
            return STATUS_INVALID_SID;
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (!event) {
            if (auxiliaryBuffer) {
                ExFreePool( auxiliaryBuffer );
            }
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_QUOTA;
    irpSp->FileObject = fileObject;

    //
    // If the caller specified an SID list of names to be queried, then pass
    // the address of the intermediary buffer containing the list to the
    // driver.
    //

    irp->Tail.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
    irpSp->Parameters.QueryQuota.SidList = sidList;
    irpSp->Parameters.QueryQuota.SidListLength = SidListLength;

    //
    // Now determine whether this driver expects to have data buffered
    // to it or whether it performs direct I/O.  This is based on the
    // DO_BUFFERED_IO flag in the device object.  If the flag is set,
    // then a system buffer is allocated and the driver's data will be
    // copied to it.  If the DO_DIRECT_IO flag is set in the device
    // object, then a Memory Descriptor List (MDL) is allocated and
    // the caller's buffer is locked down using it.  Finally, if the
    // driver specifies neither of the flags, then simply pass the
    // address and length of the buffer and allow the driver to perform
    // all of the checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The driver wishes the caller's buffered be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also indicate
        // that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception
        // handler that will perform cleanup if the operation fails.
        //

        if (Length) {
            try {

                //
                // Allocate the intermediary system buffer from nonpaged
                // pool and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPool, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the system buffer.
                // Determine what actually happened, clean everything
                // up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();
            }

            //
            // Remember the address of the caller's buffer so the copy can
            // take place during I/O completion.  Also, set the flags so
            // that the completion code knows to do the copy and to deallocate
            // the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                                   IRP_DEALLOCATE_BUFFER |
                                   IRP_INPUT_OPERATION);
        } else {
            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->UserBuffer = Buffer;
        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke
        // the memory management routine to lock the buffer into memory.
        // This is done using an exception handler that will perform
        // cleanup if the operation fails.
        //

        mdl = (PMDL) NULL;

        if (Length) {
            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off
                // of the IRP.  Probe and lock the pages associated with
                // the caller's buffer for write access and fill in the MDL
                // with the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (!mdl) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the MDL.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access
        // to it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryQuota.Length = Length;
    irpSp->Parameters.QueryQuota.StartSid = StartSid;
    irpSp->Flags = 0;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }
    if (ReturnSingleEntry) {
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }
    if (ARGUMENT_PRESENT( StartSid )) {
        irpSp->Flags |= SL_INDEX_SPECIFIED;
    }

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This service changes quota entries for the volume associated with the
    FileHandle parameter.  All of the quota entries in the specified buffer
    are applied to the volume.

Arguments:

    FileHandle - Supplies a handle to the file/volume for which the quota
        entries are to be applied.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer containing the new quota entries that should
        be applied to the volume.

    Length - Supplies the length, in bytes, of the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply return the status from the internal common routine for setting
    // EAs on a file or quotas on a volume.
    //

    return IopSetEaOrQuotaInformationFile( FileHandle,
                                           IoStatusBlock,
                                           Buffer,
                                           Length,
                                           FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\assign.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    assign.c

Abstract:

    IoAssignResources

Author:

    Ken Reneris

Environment:
    EDIT IN 110 COLUMN MODE

Revision History:

    Add PnP support - shielint
    
    Cleanup - SantoshJ

--*/

#include "pnpmgrp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,IoAssignResources)
#endif  // ALLOC_PRAGMA

NTSTATUS
IoAssignResources (
    IN      PUNICODE_STRING                 RegistryPath,
    IN      PUNICODE_STRING                 DriverClassName OPTIONAL,
    IN      PDRIVER_OBJECT                  DriverObject,
    IN      PDEVICE_OBJECT                  DeviceObject OPTIONAL,
    IN      PIO_RESOURCE_REQUIREMENTS_LIST  RequestedResources,
    IN OUT  PCM_RESOURCE_LIST               *pAllocatedResources
    )
/*++

Routine Description:

    This routine takes an input request of RequestedResources, and returned
    allocated resources in pAllocatedResources.   The allocated resources are
    automatically recorded in the registry under the ResourceMap for the
    DriverClassName/DriverObject/DeviceObject requestor.

Arguments:

    RegistryPath
        For a simple driver, this would be the value passed to the drivers
        initialization function.  For drivers call IoAssignResources with
        multiple DeviceObjects are responsible for passing in a unique
        RegistryPath for each object.

        The registry path is checked for:
            RegitryPath:
                AssignedSystemResources.

        AssignSystemResources is of type REG_RESOURCE_REQUIREMENTS_LIST

        If present, IoAssignResources will attempt to use these settings to
        satisify the requested resources.  If the listed settings do
        not conform to the resource requirements, then IoAssignResources
        will fail.

        Note: IoAssignResources may store other internal binary information
        in the supplied RegisteryPath.

    DriverObject:
        The driver object of the caller.

    DeviceObject:
        If non-null, then requested resoruce list refers to this device.
        If null, the requested resource list refers to the driver.

    DriverClassName
        Used to partition allocated resources into different device classes.

    RequestedResources
        A list of resources to allocate.

        Allocated resources may be appended or freed by re-invoking
        IoAssignResources with the same RegistryPath, DriverObject and
        DeviceObject.  (editing requirements on a resource list by using
        sucessive calls is not preferred driver behaviour).

    AllocatedResources
        Returns the allocated resources for the requested resource list.

        Note that the driver is responsible for passing in a pointer to
        an uninitialized pointer.  IoAssignResources will initialize the
        pointer to point to the allocated CM_RESOURCE_LIST.  The driver
        is responisble for returning the memory back to pool when it is
        done with them structure.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    PDEVICE_NODE    deviceNode;

    UNREFERENCED_PARAMETER(RegistryPath);
    UNREFERENCED_PARAMETER(DriverClassName);

    if (DeviceObject) {

        deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
        if (    deviceNode &&
                !(deviceNode->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)) {

            PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP(DriverObject);
            PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceObject);
            KeBugCheckEx(
                PNP_DETECTED_FATAL_ERROR, 
                PNP_ERR_INVALID_PDO, 
                (ULONG_PTR)DeviceObject, 
                0, 
                0);
        }
    }
    if (RequestedResources) {

        if (    RequestedResources->AlternativeLists == 0 ||
                RequestedResources->List[0].Count == 0) {

            RequestedResources = NULL;
        }
    }
    if (pAllocatedResources) {

        *pAllocatedResources = NULL;
    }
    return IopLegacyResourceAllocation (    
            ArbiterRequestLegacyAssigned,
            DriverObject,
            DeviceObject,
            RequestedResources,
            pAllocatedResources);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\triage.c ===
/*++

Copyright(c) 1999 Microsoft Corporation

Module Name:

    triage.c

Abstract:

    Triage dump support.

Author:

    Matthew D. Hendel (math) 20-Jan-1999

Comments:

    Do not merge this file with some other file. By leaving it in it's own
    compiland, we avoid having to link with all the other random variables
    in crashlib.


--*/

#include "iomgr.h"
#include "dumpctl.h"
#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <stdio.h>
#include <malloc.h>
#include <triage.h>
#include <ntverp.h>


#ifndef NtBuildNumber
#  if DBG
#    define NtBuildNumber   (VER_PRODUCTBUILD | 0xC0000000)
#  else
#    define NtBuildNumber (VER_PRODUCTBUILD | 0xF0000000)
# endif
#endif


//
// NOTE: Pages sizes copied from ntos\inc. These must be kept in sync with
// global header files.
//

#define PAGE_SIZE_I386      0x1000
#define PAGE_SIZE_ALPHA     0x2000
#define PAGE_SIZE_IA64      0x2000


ULONG TriageImagePageSize = -1;

BOOLEAN
TriagepVerifyDump(
    IN LPVOID TriageDumpBlock
    );

ULONG
TriagepGetPageSize(
    ULONG Architecture
    );

PTRIAGE_DUMP
TriagepGetTriagePointer(
    IN PVOID TriageDumpBlock
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text (INIT, TriagepVerifyDump)
#pragma alloc_text (INIT, TriagepGetPageSize)
#pragma alloc_text (INIT, TriagepGetTriagePointer)

#pragma alloc_text (INIT, TriageGetVersion)
#pragma alloc_text (INIT, TriageGetDriverCount)
#pragma alloc_text (INIT, TriageGetContext)
#pragma alloc_text (INIT, TriageGetExceptionRecord)
#pragma alloc_text (INIT, TriageGetBugcheckData)
#pragma alloc_text (INIT, TriageGetDriverEntry)

#endif


//++
//
// PULONG
// IndexByUlong(
//     PVOID Pointer,
//     ULONG Index
//     )
//
// Routine Description:
//
//     Return the address Index ULONGs into Pointer. That is,
//     Index * sizeof (ULONG) bytes into Pointer.
//
// Arguments:
//
//     Pointer - Start of region.
//
//     Index - Number of ULONGs to index into.
//
// Return Value:
//
//     PULONG representing the pointer described above.
//
//--

#define IndexByUlong(Pointer,Index) (&(((ULONG*) (Pointer)) [Index]))


//++
//
// PBYTE
// IndexByByte(
//     PVOID Pointer,
//     ULONG Index
//     )
//
// Routine Description:
//
//     Return the address Index BYTEs into Pointer. That is,
//     Index * sizeof (BYTE) bytes into Pointer.
//
// Arguments:
//
//     Pointer - Start of region.
//
//     Index - Number of BYTEs to index into.
//
// Return Value:
//
//     PBYTE representing the pointer described above.
//
//--

#define IndexByByte(Pointer, Index) (&(((BYTE*) (Pointer)) [Index]))


ULONG
TriagepGetPageSize(
    ULONG Architecture
    )
{
    switch (Architecture) {

        case IMAGE_FILE_MACHINE_I386:
            return PAGE_SIZE_I386;

        case IMAGE_FILE_MACHINE_ALPHA:
            return PAGE_SIZE_ALPHA;

        case IMAGE_FILE_MACHINE_IA64:
            return PAGE_SIZE_IA64;

        default:
            return -1;
    }
}



BOOLEAN
TriagepVerifyDump(
    IN LPVOID TriageDumpBlock
    )
{
    BOOLEAN Succ = FALSE;
    PMEMORY_DUMP MemoryDump = NULL;

    if (!TriageDumpBlock) {
        return FALSE;
    }

    MemoryDump = (PMEMORY_DUMP) TriageDumpBlock;

    try {

        if (MemoryDump->Header.ValidDump != 'PMUD' ||
            MemoryDump->Header.Signature != 'EGAP' ||
            TriagepGetPageSize (MemoryDump->Header.MachineImageType) == -1) {

            Succ = FALSE;
            leave;
        }

        TriageImagePageSize = TriagepGetPageSize (MemoryDump->Header.MachineImageType);

        if ( MemoryDump->Header.DumpType != DUMP_TYPE_TRIAGE ||
             *(ULONG*)IndexByByte (MemoryDump, MemoryDump->Triage.SizeOfDump - sizeof (DWORD)) != TRIAGE_DUMP_VALID ) {

            Succ = FALSE;
            leave;
        }

        // else

        Succ = TRUE;
    }

    except (EXCEPTION_EXECUTE_HANDLER) {

        Succ = FALSE;
    }

    return Succ;
}


PTRIAGE_DUMP
TriagepGetTriagePointer(
    IN PVOID TriageDumpBlock
    )
{
    ASSERT (TriageImagePageSize != -1);
    ASSERT (TriagepVerifyDump (TriageDumpBlock));

    return (PTRIAGE_DUMP) IndexByByte (TriageDumpBlock, TriageImagePageSize);
}



NTSTATUS
TriageGetVersion(
    IN LPVOID TriageDumpBlock,
    OUT ULONG * MajorVersion,
    OUT ULONG * MinorVersion,
    OUT ULONG * ServicePackBuild
    )
{
    PTRIAGE_DUMP TriageDump;
    PDUMP_HEADER DumpHeader;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return STATUS_INVALID_PARAMETER;
    }

    DumpHeader = (PDUMP_HEADER) TriageDumpBlock;

    if (MajorVersion) {
        *MajorVersion = DumpHeader->MajorVersion;
    }

    if (MinorVersion) {
        *MinorVersion = DumpHeader->MinorVersion;
    }

    if (ServicePackBuild) {
        *ServicePackBuild = TriageDump->ServicePackBuild;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
TriageGetDriverCount(
    IN LPVOID TriageDumpBlock,
    OUT ULONG * DriverCount
    )
{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return STATUS_INVALID_PARAMETER;
    }

    *DriverCount = TriageDump->DriverCount;

    return STATUS_SUCCESS;
}



#if 0

NTSTATUS
TriageGetContext(
    IN LPVOID TriageDumpBlock,
    OUT LPVOID Context,
    IN ULONG SizeInBytes
    )
{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy the CONTEXT record.
    //

    if (SizeInBytes == -1) {
        SizeInBytes = sizeof (CONTEXT);
    }

    RtlCopyMemory (Context,
                   IndexByUlong (TriageDumpBlock, TriageDump->ContextOffset),
                   SizeInBytes
                   );

    return STATUS_SUCCESS;
}


NTSTATUS
TriageGetExceptionRecord(
    IN LPVOID TriageDumpBlock,
    OUT EXCEPTION_RECORD * ExceptionRecord
    )
{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory (ExceptionRecord,
                   IndexByUlong (TriageDumpBlock, TriageDump->ExceptionOffset),
                   sizeof (*ExceptionRecord)
                   );

    return STATUS_SUCCESS;
}
#endif


LOGICAL
TriageActUpon(
    IN PVOID TriageDumpBlock
    )
{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return FALSE;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return FALSE;
    }

    if ((TriageDump->TriageOptions & DCB_TRIAGE_DUMP_ACT_UPON_ENABLED) == 0) {
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
TriageGetBugcheckData(
    IN LPVOID TriageDumpBlock,
    OUT ULONG * BugCheckCode,
    OUT UINT_PTR * BugCheckParam1,
    OUT UINT_PTR * BugCheckParam2,
    OUT UINT_PTR * BugCheckParam3,
    OUT UINT_PTR * BugCheckParam4
    )
{
    PDUMP_HEADER DumpHeader;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    DumpHeader = (PDUMP_HEADER) TriageDumpBlock;

    *BugCheckCode = DumpHeader->BugCheckCode;
    *BugCheckParam1 = DumpHeader->BugCheckParameter1;
    *BugCheckParam2 = DumpHeader->BugCheckParameter2;
    *BugCheckParam3 = DumpHeader->BugCheckParameter3;
    *BugCheckParam4 = DumpHeader->BugCheckParameter4;

    return STATUS_SUCCESS;
}



PKLDR_DATA_TABLE_ENTRY
TriageGetLoaderEntry(
    IN PVOID TriageDumpBlock,
    IN ULONG ModuleIndex
    )

/*++

Routine Description:

    This function retrieves a loaded module list entry.

Arguments:

    TriageDumpBlock - Supplies the triage dump to reference.

    ModuleIndex - Supplies the driver index number to locate.

Return Value:

    A pointer to a loader data table entry if one is available, NULL if not.

Environment:

    Kernel mode, APC_LEVEL or below.  Phase 0 only.

    N.B. This function is for use by memory management ONLY.

--*/

{
    PDUMP_STRING DriverName;
    PDUMP_DRIVER_ENTRY DriverList;
    PTRIAGE_DUMP TriageDump;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return NULL;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (ModuleIndex >= TriageDump->DriverCount) {
        return NULL;
    }

    DriverList = (PDUMP_DRIVER_ENTRY)
            IndexByByte (TriageDumpBlock, TriageDump->DriverListOffset);


    DataTableEntry = (PKLDR_DATA_TABLE_ENTRY) (&DriverList[ModuleIndex].LdrEntry);

    //
    // Repoint the module driver name into the triage buffer.
    //

    DriverName = (PDUMP_STRING)
            IndexByByte (TriageDumpBlock,
                         DriverList [ ModuleIndex ].DriverNameOffset);

    DataTableEntry->BaseDllName.Length = (USHORT) (DriverName->Length * sizeof (WCHAR));
    DataTableEntry->BaseDllName.MaximumLength = DataTableEntry->BaseDllName.Length;
    DataTableEntry->BaseDllName.Buffer = DriverName->Buffer;

    return DataTableEntry;
}


PVOID
TriageGetMmInformation(
    IN PVOID TriageDumpBlock
    )

/*++

Routine Description:

    This function retrieves a loaded module list entry.

Arguments:

    TriageDumpBlock - Supplies the triage dump to reference.

Return Value:

    A pointer to an opaque Mm information structure.

Environment:

    Kernel mode, APC_LEVEL or below.  Phase 0 only.

    N.B. This function is for use by memory management ONLY.

--*/

{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return NULL;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return NULL;
    }

    return (PVOID)IndexByByte (TriageDumpBlock, TriageDump->MmOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\iomgr\write.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code to implement the NtWriteFile system service.

Author:

    Darryl E. Havens (darrylh) 14-Apr-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtWriteFile)
#pragma alloc_text(PAGE, NtWriteFile64)
#pragma alloc_text(PAGE, NtWriteFileGather)
#endif

NTSTATUS
NtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    file associated with FileHandle starting at StartingBlock|ByteOffset.
    The actual number of bytes written to the file will be returned in the
    second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    Buffer - Supplies the address of the buffer containing data to be written
        to the file.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    KPROCESSOR_MODE requestorMode;
    PMDL mdl;
    PIO_STACK_LOCATION irpSp;
    ACCESS_MASK grantedAccess;
    ACCESS_MASK desiredAccess = (ACCESS_MASK)0;
    OBJECT_HANDLE_INFORMATION handleInformation;
    NTSTATUS exceptionCode;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceFileObjectForWrite( FileHandle,
                                            requestorMode,
                                            (PVOID *) &fileObject,
                                            &handleInformation);

    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Attempt to probe the caller's parameters within the exception
        // handler block.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // The caller's data buffer must be readable from the caller's
            // mode.  This check ensures that this is the case.  Since the
            // buffer address is captured, the caller cannot change it,
            // even though he/she can change the protection from another
            // thread.  This error will be caught by the probe/lock or
            // buffer copy operations later.
            //

            ProbeForRead( Buffer, Length, sizeof( UCHAR ) );

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Check that the ByteOffset parameter is readable from the
            // caller's mode, if one was specified, and capture it.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following Buffer
            // and ByteOffset parameter checks differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of the block size.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1))) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ||
                        (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it is
                // is of the proper type.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                        fileOffset.HighPart == -1) {
                        NOTHING;
                    } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                               fileOffset.HighPart == -1 &&
                               (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                        NOTHING;
                    } else if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Simply cleanup, dereference the file
            // object, and return with the appropriate status code.
            //

            ObDereferenceObject( fileObject );
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the appropriate parameters to
        // their expected locations without making all of the checks.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }
#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the Buffer is properly aligned, and that the
            // length is an integral number of the block size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1))) ||
                (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it is
            // is of the proper type.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                    fileOffset.HighPart == -1) {
                    NOTHING;
                } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                           fileOffset.HighPart == -1 &&
                           (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                    NOTHING;
                } else if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG

    }

    //
    // If the caller has only append access to the file, ignore the input
    // parameters and set the ByteOffset to indicate that this write is
    // to the end of the file.  Otherwise, ensure that the parameters are
    // valid.
    //

    if (SeComputeGrantedAccesses( grantedAccess, FILE_APPEND_DATA | FILE_WRITE_DATA ) == FILE_APPEND_DATA) {

        //
        // This is an append operation to the end of a file.  Set the
        // ByteOffset parameter to give drivers a consistent view of
        // this type of call.
        //

        fileOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
        fileOffset.HighPart = -1;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the fast io dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        //
        // Turbo write support.  If the file is currently cached on this
        // file object, then call the Cache Manager directly via FsRtl
        // and try to successfully complete the request here.  Note if
        // FastIoWrite returns FALSE or we get an I/O error, we simply
        // fall through and go the "long way" and create an Irp.
        //

        if (fileObject->PrivateCacheMap) {

            IO_STATUS_BLOCK localIoStatus;

            ASSERT(fastIoDispatch && fastIoDispatch->FastIoWrite);

            //
            //  Negative file offsets are illegal.
            //

            if (fileOffset.HighPart < 0 &&
                (fileOffset.HighPart != -1 ||
                fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            if (fastIoDispatch->FastIoWrite( fileObject,
                                             &fileOffset,
                                             Length,
                                             TRUE,
                                             keyValue,
                                             Buffer,
                                             &localIoStatus,
                                             deviceObject )

                    &&

                (localIoStatus.Status == STATUS_SUCCESS)) {

                IopUpdateWriteOperationCount( );
                IopUpdateWriteTransferCount( (ULONG)localIoStatus.Information );

                //
                // Carefully return the I/O status.

                try {
                    *IoStatusBlock = localIoStatus;
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    localIoStatus.Status = GetExceptionCode();
                    localIoStatus.Information = 0;
                }

                //
                // If an event was specified, set it.
                //

                if (ARGUMENT_PRESENT( Event )) {
                    KeSetEvent( eventObject, 0, FALSE );
                    ObDereferenceObject( eventObject );
                }

                //
                // Note that the file object event need not be set to the
                // Signaled state, as it is already set.
                //

                //
                // Cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return localIoStatus.Status;
            }
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function code here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) irpSp;
    *majorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the caller's data is copied into it.  Otherwise, a Memory
    // Descriptor List (MDL) is allocated and the caller's buffer is locked
    // down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer,
        // and copy the caller's data into it.  This is done using an
        // exception handler that will perform cleanup if the operation
        // fails.  Note that this is only done if the operation has a non-zero
        // length.
        //

        if (Length) {

            try {

                //
                // Allocate the intermediary system buffer from nonpaged pool,
                // charge quota for it, and copy the caller's data into it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPoolCacheAligned, Length );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, Buffer, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer, allocating the system buffer, or copying the data
                // from the caller's buffer to the system buffer.  Determine
                // what actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

            //
            // Set the IRP_BUFFERED_IO flag in the IRP so that I/O completion
            // will know that this is not a direct I/O operation.  Also set the
            // IRP_DEALLOCATE_BUFFER flag so it will deallocate the buffer.
            //

            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;

        } else {

            //
            // This is a zero-length write.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->Flags = IRP_BUFFERED_IO;
        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This
        // is done using an exception handler that will perform cleanup if
        // the operation fails.  Note that no MDL is allocated, nor is any
        // memory probed or locked if the length of the request was zero.
        //

        mdl = (PMDL) NULL;
        irp->Flags = 0;

        if (Length) {

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of
                // the IRP.  Probe and lock the pages associated with the
                // caller's buffer for read access and fill in the MDL with
                // the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                MmProbeAndLockPages( mdl, requestorMode, IoReadAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either allocating the MDL
                // or while attempting to probe and lock the caller's buffer.
                // Determine what actually happened, clean everything up, and
                // return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();
            }

        }

    } else {

        //
        // Pass the address of the caller's buffer to the device driver.  It
        // is now up to the driver to do everything.
        //

        irp->Flags = 0;
        irp->UserBuffer = Buffer;

    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.Key = keyValue;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        WriteTransfer );

    return status;
}

NTSTATUS
NtWriteFileGather(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's segment
    buffers to the file associated with FileHandle starting at
    StartingBlock|ByteOffset. The actual number of bytes written to the file
    will be returned in the second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be read from.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:
    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFILE_SEGMENT_ELEMENT capturedArray = NULL;
    KPROCESSOR_MODE requestorMode;
    PMDL mdl;
    PIO_STACK_LOCATION irpSp;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    NTSTATUS exceptionCode;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG elementCount;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    ULONG i;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Verify this is a valid gather write request.  In particular it must
    // be non cached, asynchronous, use completion ports, non buffer I/O
    // device and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (fileObject->Flags & FO_SYNCHRONOUS_IO) ||
        deviceObject->Flags & DO_BUFFERED_IO ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS &&
         deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME)) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES( Length );

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either WRITE_DATA or APPEND_DATA
        // access to the file.  If not, cleanup and return an access denied
        // error status value.  Note that if this is a pipe then the APPEND_DATA
        // access check may not be made since this access code is overlaid with
        // CREATE_PIPE_INSTANCE access.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, (!(fileObject->Flags & FO_NAMED_PIPE) ? FILE_APPEND_DATA : 0) | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        //
        // Attempt to probe the caller's parameters within the exception
        // handler block.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // The SegmentArray paramter must be accessible.
            //

#ifdef _X86_
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          sizeof( ULONG )
                          );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcess()->Wow64Process) {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              sizeof( ULONG )
                              );
            } else {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                              );
            }
#else
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                          );
#endif

            if (Length != 0) {

                //
                // Capture the segment array so it cannot be changed after
                // it has been looked at.
                //

                capturedArray = ExAllocatePoolWithQuota( PagedPool,
                                                         elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                                                         );

                RtlCopyMemory( capturedArray,
                               SegmentArray,
                               elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                               );

                SegmentArray = capturedArray;

                //
                // Verify that all the addresses are page aligned.
                //

                for (i = 0; i < elementCount; i++) {

                    if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }
            }

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {

                ExRaiseStatus(STATUS_INVALID_PARAMETER);

            }

            //
            // Check that the ByteOffset parameter is readable from the
            // caller's mode, if one was specified, and capture it.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following ByteOffset
            // parameter check differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1)))) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ) {

                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it is
                // is of the proper type.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                        fileOffset.HighPart == -1) {
                        NOTHING;
                    } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                               fileOffset.HighPart == -1 &&
                               (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                        NOTHING;
                    } else if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {

                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Simply cleanup, dereference the file
            // object, and return with the appropriate status code.
            //

            ObDereferenceObject( fileObject );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }

            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the appropriate parameters to
        // their expected locations without making all of the checks.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }
#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the the length is an integral number of the block
            //  size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1)))) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize)) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it is
            // is of the proper type.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                    fileOffset.HighPart == -1) {
                    NOTHING;
                } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                           fileOffset.HighPart == -1 &&
                           (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                    NOTHING;
                } else if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }

        if (Length != 0) {

            //
            // Verify that all the addresses are page aligned.
            //

            for (i = 0; i < elementCount; i++) {

                if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {

                    ObDereferenceObject( fileObject );
                    ASSERT(FALSE);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG

    }

    //
    // If the caller has only append access to the file, ignore the input
    // parameters and set the ByteOffset to indicate that this write is
    // to the end of the file.  Otherwise, ensure that the parameters are
    // valid.
    //

    if (SeComputeGrantedAccesses( grantedAccess, FILE_APPEND_DATA | FILE_WRITE_DATA ) == FILE_APPEND_DATA) {

        //
        // This is an append operation to the end of a file.  Set the
        // ByteOffset parameter to give drivers a consistent view of
        // this type of call.
        //

        fileOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
        fileOffset.HighPart = -1;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the fast io dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                if (capturedArray != NULL) {
                    ExFreePool( capturedArray );
                }
                return status;
            }
        }

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function code here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) irpSp;
    *majorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the caller's data is copied into it.  Otherwise, a Memory
    // Descriptor List (MDL) is allocated and the caller's buffer is locked
    // down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    //
    // This is a direct I/O operation.  Allocate an MDL and invoke the
    // memory management routine to lock the buffer into memory.  This
    // is done using an exception handler that will perform cleanup if
    // the operation fails.  Note that no MDL is allocated, nor is any
    // memory probed or locked if the length of the request was zero.
    //

    mdl = (PMDL) NULL;
    irp->Flags = 0;

    if (Length) {

        try {

            //
            // Allocate an MDL, charging quota for it, and hang it off of
            // the IRP.  Probe and lock the pages associated with the
            // caller's buffer for write access and fill in the MDL with
            // the PFNs of those pages.
            //

            mdl = IoAllocateMdl( (PVOID)(ULONG_PTR) SegmentArray[0].Buffer, Length, FALSE, TRUE, irp );
            if (mdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            // The address of the first file segment is used as a base
            // address.
            //

            MmProbeAndLockSelectedPages( mdl,
                                         SegmentArray,
                                         requestorMode,
                                         IoReadAccess );

            irp->UserBuffer = (PVOID)(ULONG_PTR) SegmentArray[0].Buffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either allocating the MDL
            // or while attempting to probe and lock the caller's buffer.
            // Determine what actually happened, clean everything up, and
            // return an appropriate error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
           return GetExceptionCode();
        }

    }

    //
    // We are done with the captured buffer.
    //

    if (capturedArray != NULL) {
        ExFreePool( capturedArray );
    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.Key = keyValue;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        WriteTransfer );

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\devices.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    devices.c

Abstract:

    Plug and Play Manager routines dealing with device manipulation/registration.

Author:

    Lonny McMichael (lonnym) 02/14/95

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

typedef struct {
    BOOLEAN Add;
} PROCESS_DRIVER_CONTEXT, *PPROCESS_DRIVER_CONTEXT;

typedef NTSTATUS (*PDEVICE_SERVICE_ITERATOR_ROUTINE)(
    IN PUNICODE_STRING DeviceInstancePath,
    IN PUNICODE_STRING ServiceName,
    IN ULONG ServiceType,
    IN PVOID Context
    );

typedef struct {
    PUNICODE_STRING DeviceInstancePath;
    PDEVICE_SERVICE_ITERATOR_ROUTINE Iterator;
    PVOID Context;
} DEVICE_SERVICE_ITERATOR_CONTEXT, *PDEVICE_SERVICE_ITERATOR_CONTEXT;

//
// Prototype utility functions internal to this file.
//

NTSTATUS
PiFindDevInstMatch(
    IN HANDLE ServiceEnumHandle,
    IN PUNICODE_STRING DeviceInstanceName,
    OUT PULONG InstanceCount,
    OUT PUNICODE_STRING MatchingValueName
    );

NTSTATUS PiProcessDriverInstance(
    IN PUNICODE_STRING DeviceInstancePath,
    IN PUNICODE_STRING ServiceName,
    IN ULONG ServiceType,
    IN PPROCESS_DRIVER_CONTEXT Context
    );

NTSTATUS
PpForEachDeviceInstanceDriver(
    PUNICODE_STRING DeviceInstancePath,
    PDEVICE_SERVICE_ITERATOR_ROUTINE IteratorRoutine,
    PVOID Context
    );

NTSTATUS
PiForEachDriverQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PDEVICE_SERVICE_ITERATOR_CONTEXT InternalContext,
    IN ULONG ServiceType
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpDeviceRegistration)
#pragma alloc_text(PAGE, PiDeviceRegistration)
#pragma alloc_text(PAGE, PiProcessDriverInstance)
#pragma alloc_text(PAGE, PiFindDevInstMatch)
#pragma alloc_text(PAGE, PpForEachDeviceInstanceDriver)
#pragma alloc_text(PAGE, PiForEachDriverQueryRoutine)
#endif // ALLOC_PRAGMA

NTSTATUS
PpDeviceRegistration(
    IN PUNICODE_STRING DeviceInstancePath,
    IN BOOLEAN Add,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL
    )

/*++

Routine Description:

    If Add is set to TRUE, this Plug and Play Manager API creates (if necessary)
    and populates the volatile Enum subkey of a device's service list entry, based
    on the device instance path specified.  If Add is set to FALSE, the specified
    device instance will be removed from the volatile Enum subkey of a device's
    service list entry.

    For example, if there is a device in the Enum tree as follows:

    HKLM\System\Enum\PCI
        \foo
            \0000
                Service = REG_SZ bar
            \0001
                Service = REG_SZ other

    The result of the call, PpDeviceRegistration("PCI\foo\0000", Add = TRUE), would be:

    HKLM\CurrentControlSet\Services
        \bar
            \Enum
                Count = REG_DWORD 1
                0 = REG_SZ PCI\foo\0000

Arguments:

    DeviceInstancePath - Supplies the path in the registry (relative to
                         HKLM\CCS\System\Enum) of the device to be registered/deregistered.
                         This path must point to an instance subkey.

    Add - Supplies a BOOLEAN value to indicate the operation is for addition or removal.

    ServiceKeyName - Optionally, supplies the address of a unicode string to
                     receive the name of the registry key for this device
                     instance's service (if one exists).  The caller must
                     release the space once done with it.

Return Value:

    NTSTATUS code indicating whether or not the function was successful

--*/

{

    NTSTATUS Status;

    PAGED_CODE();

    //
    // Acquire PnP device-specific registry resource for exclusive (read/write) access.
    //
    PiLockPnpRegistry(TRUE);

    Status = PiDeviceRegistration(DeviceInstancePath,
                                  Add,
                                  ServiceKeyName
                                  );

    PiUnlockPnpRegistry();
    return Status;
}


NTSTATUS
PiDeviceRegistration(
    IN PUNICODE_STRING DeviceInstancePath,
    IN BOOLEAN Add,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL
    )

/*++

Routine Description:

    If Add is set to TRUE, this Plug and Play Manager API creates (if necessary)
    and populates the volatile Enum subkey of a device's service list entry, based
    on the device instance path specified.  If Add is set to FALSE, the specified
    device instance will be removed from the volatile Enum subkey of a device's
    service list entry.

    For example, if there is a device in the Enum tree as follows:

    HKLM\System\Enum\PCI
        \foo
            \0000
                Service = REG_SZ bar
            \0001
                Service = REG_SZ other

    The result of the call, PpDeviceRegistration("PCI\foo\0000", Add = TRUE), would be:

    HKLM\CurrentControlSet\Services
        \bar
            \Enum
                Count = REG_DWORD 1
                0 = REG_SZ PCI\foo\0000

Arguments:

    DeviceInstancePath - Supplies the path in the registry (relative to
                         HKLM\CCS\System\Enum) of the device to be registered/deregistered.
                         This path must point to an instance subkey.

    Add - Supplies a BOOLEAN value to indicate the operation is for addition or removal.

    ServiceKeyName - Optionally, supplies the address of a unicode string to
                     receive the name of the registry key for this device
                     instance's service (if one exists).  The caller must
                     release the space once done with it.

Return Value:

    NTSTATUS code indicating whether or not the function was successful

--*/

{

    NTSTATUS Status;
    UNICODE_STRING ServiceName;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    HANDLE TempKeyHandle;
    HANDLE DeviceInstanceHandle = NULL;

    PAGED_CODE();

    //
    // Assume successful completion.
    //
    Status = STATUS_SUCCESS;

    if (ServiceKeyName) {
        PiWstrToUnicodeString(ServiceKeyName, NULL);
    }

    //
    // 'Normalize' the DeviceInstancePath by stripping off a trailing
    // backslash (if present)
    //

    if (DeviceInstancePath->Length <= sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        goto PrepareForReturn1;
    }

    if (DeviceInstancePath->Buffer[CB_TO_CWC(DeviceInstancePath->Length) - 1] ==
                                                            OBJ_NAME_PATH_SEPARATOR) {
        DeviceInstancePath->Length -= sizeof(WCHAR);
    }

    //
    // Open HKLM\System\CurrentControlSet\Enum
    //
    Status = IopOpenRegistryKeyEx( &TempKeyHandle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );
    if(!NT_SUCCESS(Status)) {
        goto PrepareForReturn1;
    }

    //
    // Open the specified device instance key under HKLM\CCS\System\Enum
    //

    Status = IopOpenRegistryKeyEx( &DeviceInstanceHandle,
                                   TempKeyHandle,
                                   DeviceInstancePath,
                                   KEY_READ
                                   );
    ZwClose(TempKeyHandle);
    if(!NT_SUCCESS(Status)) {
        goto PrepareForReturn1;
    }

    //
    // Read Service= value entry of the specified device instance key.
    //

    Status = IopGetRegistryValue(DeviceInstanceHandle,
                                 REGSTR_VALUE_SERVICE,
                                 &KeyValueInformation
                                 );
    ZwClose(DeviceInstanceHandle);
    if (NT_SUCCESS(Status)) {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength > sizeof(UNICODE_NULL)) {
                IopRegistryDataToUnicodeString(&ServiceName,
                                               (PWSTR)KEY_VALUE_DATA(KeyValueInformation),
                                               KeyValueInformation->DataLength
                                               );
                Status = STATUS_SUCCESS;
                if (ServiceKeyName) {

                    //
                    // If need to return ServiceKeyName, make a copy now.
                    //

                    if (!PipConcatenateUnicodeStrings(  ServiceKeyName,
                                                        &ServiceName,
                                                        NULL)) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                }
            }
        }
        ExFreePool(KeyValueInformation);

    } else if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        //
        // The device instance key may have no Service value entry if the device
        // is raw capable.
        //
        Status = STATUS_SUCCESS;
        goto PrepareForReturn1;
    }

    if (NT_SUCCESS(Status)) {

        PROCESS_DRIVER_CONTEXT context;
        context.Add = Add;

        Status = PpForEachDeviceInstanceDriver(
                    DeviceInstancePath,
                    (PDEVICE_SERVICE_ITERATOR_ROUTINE) PiProcessDriverInstance,
                    &context);

        if(!NT_SUCCESS(Status) && Add) {

            context.Add = FALSE;
            PpForEachDeviceInstanceDriver(DeviceInstancePath,
                                          PiProcessDriverInstance,
                                          &context);
        }
    }

PrepareForReturn1:

    if (!NT_SUCCESS(Status)) {
        if (ServiceKeyName) {
            if (ServiceKeyName->Length != 0) {
                ExFreePool(ServiceKeyName->Buffer);
                ServiceKeyName->Buffer = NULL;
                ServiceKeyName->Length = ServiceKeyName->MaximumLength = 0;
            }
        }
    }

    return Status;
}

NTSTATUS
PiProcessDriverInstance(
    IN PUNICODE_STRING DeviceInstancePath,
    IN PUNICODE_STRING ServiceName,
    IN ULONG ServiceType,
    IN PPROCESS_DRIVER_CONTEXT Context
    )
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;

    PKEY_VALUE_FULL_INFORMATION KeyValueInformation = NULL;
    HANDLE ServiceEnumHandle;
    UNICODE_STRING MatchingDeviceInstance;
    UNICODE_STRING TempUnicodeString;
    CHAR UnicodeBuffer[20];
    BOOLEAN UpdateCount = FALSE;
    ULONG i, j, Count, junk, maxCount;

    UNREFERENCED_PARAMETER( ServiceType );

    PAGED_CODE();

    ASSERT(Context != NULL);

    //
    // Next, open the service entry, and volatile Enum subkey
    // under HKLM\System\CurrentControlSet\Services (creating it if it
    // doesn't exist)
    //

    Status = PipOpenServiceEnumKeys(ServiceName,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &ServiceEnumHandle,
                                    TRUE
                                   );
    if(!NT_SUCCESS(Status)) {
        goto PrepareForReturn2;
    }

    //
    // Now, search through the service's existing list of device instances, to see
    // if this instance has previously been registered.
    //

    Status = PiFindDevInstMatch(ServiceEnumHandle,
                                DeviceInstancePath,
                                &Count,
                                &MatchingDeviceInstance);

    if (!NT_SUCCESS(Status)) {
        goto PrepareForReturn3;
    }

    if (!MatchingDeviceInstance.Buffer) {

        //
        // If we didn't find a match and caller wants to register the device, then we add
        // this instance to the service's Enum list.
        //

        if (Context->Add) {
            PWSTR instancePathBuffer;
            ULONG instancePathLength;
            BOOLEAN freeBuffer = FALSE;

            //
            // Create the value entry and update NextInstance= for the madeup key
            //

            if (DeviceInstancePath->Buffer[DeviceInstancePath->Length / sizeof(WCHAR) - 1] !=
                UNICODE_NULL) {
                instancePathLength = DeviceInstancePath->Length + sizeof(WCHAR);
                instancePathBuffer = (PWSTR)ExAllocatePool(PagedPool, instancePathLength);
                if (instancePathBuffer) {
                    RtlCopyMemory(instancePathBuffer,
                                  DeviceInstancePath->Buffer,
                                  DeviceInstancePath->Length
                                  );
                    instancePathBuffer[DeviceInstancePath->Length / sizeof(WCHAR)] = UNICODE_NULL;
                    freeBuffer = TRUE;
                }
            }
            if (!freeBuffer) {
                instancePathBuffer = DeviceInstancePath->Buffer;
                instancePathLength = DeviceInstancePath->Length;
            }
            PiUlongToUnicodeString(&TempUnicodeString, UnicodeBuffer, 20, Count);
            Status = ZwSetValueKey(
                        ServiceEnumHandle,
                        &TempUnicodeString,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        instancePathBuffer,
                        instancePathLength
                        );
            if (freeBuffer) {
                ExFreePool(instancePathBuffer);
            }
            Count++;
            UpdateCount = TRUE;
        }
    } else {

        //
        // If we did find a match and caller wants to deregister the device, then we remove
        // this instance from the service's Enum list.
        //

        if (Context->Add == FALSE) {
            ZwDeleteValueKey(ServiceEnumHandle, &MatchingDeviceInstance);
            Count--;
            UpdateCount = TRUE;

            //
            // Finally, if Count is not zero we need to physically reorganize the
            // instances under the ServiceKey\Enum key to make them contiguous.
            //

            if (Count != 0) {
                KEY_FULL_INFORMATION keyInfo;
                ULONG tmp;

                Status = ZwQueryKey(ServiceEnumHandle, KeyFullInformation, &keyInfo, sizeof(keyInfo), &tmp);
                if (NT_SUCCESS(Status) && keyInfo.Values) {
                    maxCount = keyInfo.Values;
                } else {
                    maxCount = 0x200;
                }
                i = j = 0;
                while (j < Count && i < maxCount) {
                    PiUlongToUnicodeString(&TempUnicodeString, UnicodeBuffer, 20, i);
                    Status = ZwQueryValueKey( ServiceEnumHandle,
                                              &TempUnicodeString,
                                              KeyValueFullInformation,
                                              (PVOID) NULL,
                                              0,
                                              &junk);
                    if ((Status != STATUS_OBJECT_NAME_NOT_FOUND) && (Status != STATUS_OBJECT_PATH_NOT_FOUND)) {
                        if (i != j) {

                            //
                            // Need to change the instance i to instance j
                            //

                            Status = IopGetRegistryValue(ServiceEnumHandle,
                                                         TempUnicodeString.Buffer,
                                                         &KeyValueInformation
                                                         );
                            if (NT_SUCCESS(Status)) {
                                ZwDeleteValueKey(ServiceEnumHandle, &TempUnicodeString);
                                PiUlongToUnicodeString(&TempUnicodeString, UnicodeBuffer, 20, j);
                                ZwSetValueKey (ServiceEnumHandle,
                                               &TempUnicodeString,
                                               TITLE_INDEX_VALUE,
                                               REG_SZ,
                                               (PVOID)KEY_VALUE_DATA(KeyValueInformation),
                                               KeyValueInformation->DataLength
                                               );
                                ExFreePool(KeyValueInformation);
                                KeyValueInformation = NULL;
                            } else {
                                IopDbgPrint((IOP_WARNING_LEVEL,
                                           "PpDeviceRegistration: Fail to rearrange device instances %x\n",
                                           Status));

                                break;
                            }
                        }
                        j++;
                    }
                    i++;
                }
            }
        }
    }
    if (UpdateCount) {
        PiWstrToUnicodeString(&TempUnicodeString, REGSTR_VALUE_COUNT);
        ZwSetValueKey(
                ServiceEnumHandle,
                &TempUnicodeString,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &Count,
                sizeof(Count)
                );
        PiWstrToUnicodeString(&TempUnicodeString, REGSTR_VALUE_NEXT_INSTANCE);
        ZwSetValueKey(
                ServiceEnumHandle,
                &TempUnicodeString,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &Count,
                sizeof(Count)
                );
    }

    //
    // Need to release the matching device value name
    //

    if (MatchingDeviceInstance.Buffer) {
        RtlFreeUnicodeString(&MatchingDeviceInstance);
    }
    Status = STATUS_SUCCESS;

PrepareForReturn3:

    ZwClose(ServiceEnumHandle);

PrepareForReturn2:

    if (KeyValueInformation) {
        ExFreePool(KeyValueInformation);
    }

    return Status;
}


NTSTATUS
PiFindDevInstMatch(
    IN HANDLE ServiceEnumHandle,
    IN PUNICODE_STRING DeviceInstanceName,
    OUT PULONG Count,
    OUT PUNICODE_STRING MatchingValueName
    )

/*++

Routine Description:

    This routine searches through the specified Service\Enum values entries
    for a device instance matching the one specified by KeyInformation.
    If a matching is found, the MatchingValueName is returned and caller must
    free the unicode string when done with it.

Arguments:

    ServiceEnumHandle - Supplies a handle to service enum key.

    DeviceInstanceName - Supplies a pointer to a unicode string specifying the
                         name of the device instance key to search for.

    InstanceCount - Supplies a pointer to a ULONG variable to receive the device
                    instance count under the service enum key.

    MatchingNameFound - Supplies a pointer to a UNICODE_STRING to receive the value
                        name of the matched device instance.

Return Value:

    A NTSTATUS code.  if a matching is found, the MatchingValueName is the unicode
    string of the value name.  Otherwise its length and Buffer will be set to empty.

--*/

{
    NTSTATUS status;
    ULONG i, instanceCount, length = 256, junk;
    UNICODE_STRING valueName, unicodeValue;
    PWCHAR unicodeBuffer;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation = NULL;

    PAGED_CODE();

    //
    // Find out how many instances are referenced in the service's Enum key.
    //

    MatchingValueName->Length = 0;
    MatchingValueName->Buffer = NULL;
    *Count = instanceCount = 0;

    status = IopGetRegistryValue(ServiceEnumHandle,
                                 REGSTR_VALUE_COUNT,
                                 &keyValueInformation
                                );
    if (NT_SUCCESS(status)) {

        if((keyValueInformation->Type == REG_DWORD) &&
           (keyValueInformation->DataLength >= sizeof(ULONG))) {

            instanceCount = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            *Count = instanceCount;
        }
        ExFreePool(keyValueInformation);

    } else if(status != STATUS_OBJECT_NAME_NOT_FOUND) {
        return status;
    } else {

        //
        // If 'Count' value entry not found, consider this to mean there are simply
        // no device instance controlled by this service.  Thus we don't have a match.
        //

        return STATUS_SUCCESS;
    }

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePool(
                                    PagedPool, length);
    if (!keyValueInformation) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate heap to store value name
    //

    unicodeBuffer = (PWSTR)ExAllocatePool(PagedPool, 10 * sizeof(WCHAR));
    if (!unicodeBuffer) {
        ExFreePool(keyValueInformation);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Next scan thru each value key to find a match
    //

    for (i = 0; i < instanceCount ; i++) {
       PiUlongToUnicodeString(&valueName, unicodeBuffer, 20, i);
       status = ZwQueryValueKey (
                        ServiceEnumHandle,
                        &valueName,
                        KeyValueFullInformation,
                        keyValueInformation,
                        length,
                        &junk
                        );
        if (!NT_SUCCESS(status)) {
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
                ExFreePool(keyValueInformation);
                length = junk;
                keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePool(
                                        PagedPool, length);
                if (!keyValueInformation) {
                    ExFreePool(unicodeBuffer);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                i--;
            }
            continue;
        }

        if (keyValueInformation->Type == REG_SZ) {
            if (keyValueInformation->DataLength > sizeof(UNICODE_NULL)) {
                IopRegistryDataToUnicodeString(&unicodeValue,
                                               (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                               keyValueInformation->DataLength
                                               );
            } else {
                continue;
            }
        } else {
            continue;
        }

        if (RtlEqualUnicodeString(&unicodeValue,
                                  DeviceInstanceName,
                                  TRUE)) {
            //
            // We found a match.
            //

            *MatchingValueName= valueName;
            break;
        }
    }
    if (keyValueInformation) {
        ExFreePool(keyValueInformation);
    }
    if (MatchingValueName->Length == 0) {

        //
        // If we did not find a match, we need to release the buffer.  Otherwise
        // it is caller's responsibility to release the buffer.
        //

        ExFreePool(unicodeBuffer);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
PpForEachDeviceInstanceDriver(
    PUNICODE_STRING DeviceInstancePath,
    PDEVICE_SERVICE_ITERATOR_ROUTINE IteratorRoutine,
    PVOID Context
    )
/*++

Routine Description:

    This routine will call the iterator routine once for each driver listed
    for this particular device instance.  It will walk through any class
    filter drivers and device filter drivers, as well as the service, in the
    order they will be added to the PDO.  If the iterator routine returns
    a failure status at any point the iteration will be terminated.

Arguments:

    DeviceInstancePath - the registry path (relative to CCS\Enum)

    IteratorRoutine - the routine to be called for each service.  This routine
                      will be passed:

                       * The device instance path
                       * The type of driver that this is (filter, service, etc.)
                       * the Context value passed in
                       * The name of the service

    Context - an arbitrary context passed into the iterator routine

Return Value:

    STATUS_SUCCCESS if everything was run across properly

    status if an error occurred opening critical keys or if the iterator
    routine returns an error.

--*/

{
    HANDLE enumKey,instanceKey, classKey, controlKey;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    DEVICE_SERVICE_ITERATOR_CONTEXT internalContext;
    RTL_QUERY_REGISTRY_TABLE queryTable[4];
    NTSTATUS status;
    UNICODE_STRING unicodeClassGuid;


    PAGED_CODE();

    //
    // Open the HKLM\System\CCS\Enum key.
    //

    status = IopOpenRegistryKeyEx( &enumKey,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Open the instance key for this devnode
    //

    status = IopOpenRegistryKeyEx( &instanceKey,
                                   enumKey,
                                   DeviceInstancePath,
                                   KEY_READ
                                   );

    ZwClose(enumKey);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    classKey = NULL;
    status = IopGetRegistryValue(instanceKey,
                                 REGSTR_VALUE_CLASSGUID,
                                 &keyValueInformation);
    if(NT_SUCCESS(status)) {

        if (    keyValueInformation->Type == REG_SZ &&
                keyValueInformation->DataLength) {

            IopRegistryDataToUnicodeString(
                &unicodeClassGuid,
                (PWSTR) KEY_VALUE_DATA(keyValueInformation),
                keyValueInformation->DataLength);
            //
            // Open the class key
            //
            status = IopOpenRegistryKeyEx( &controlKey,
                                           NULL,
                                           &CmRegistryMachineSystemCurrentControlSetControlClass,
                                           KEY_READ
                                           );
            if(NT_SUCCESS(status)) {

                status = IopOpenRegistryKeyEx( &classKey,
                                               controlKey,
                                               &unicodeClassGuid,
                                               KEY_READ
                                               );
                ZwClose(controlKey);
            }
        }
        ExFreePool(keyValueInformation);
        keyValueInformation = NULL;
    }

    //
    // For each type of filter driver we want to query for the list and
    // call into our callback routine.  We should do this in order from
    // bottom to top.
    //

    internalContext.Context = Context;
    internalContext.DeviceInstancePath = DeviceInstancePath;
    internalContext.Iterator = IteratorRoutine;

    //
    // First get all the information we have to out of the instance key and
    // the device node.
    //

    if(classKey != NULL) {
        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable[0].QueryRoutine =
            (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
        queryTable[0].Name = REGSTR_VAL_LOWERFILTERS;
        queryTable[0].EntryContext = (PVOID) 0;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) classKey,
                                        queryTable,
                                        &internalContext,
                                        NULL);

        if(!NT_SUCCESS(status)) {
            goto PrepareForReturn;
        }
    }

    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].QueryRoutine =
        (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
    queryTable[0].Name = REGSTR_VAL_LOWERFILTERS;
    queryTable[0].EntryContext = (PVOID) 1;

    queryTable[1].QueryRoutine =
        (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
    queryTable[1].Name = REGSTR_VAL_SERVICE;
    queryTable[1].EntryContext = (PVOID) 2;

    queryTable[2].QueryRoutine =
        (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
    queryTable[2].Name = REGSTR_VAL_UPPERFILTERS;
    queryTable[2].EntryContext = (PVOID) 3;

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR) instanceKey,
                                    queryTable,
                                    &internalContext,
                                    NULL);

    if(!NT_SUCCESS(status)) {
        goto PrepareForReturn;
    }

    if(classKey != NULL) {

        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable[0].QueryRoutine =
            (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
        queryTable[0].Name = REGSTR_VAL_UPPERFILTERS;
        queryTable[0].EntryContext = (PVOID) 4;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) classKey,
                                        queryTable,
                                        &internalContext,
                                        NULL);
        if(!NT_SUCCESS(status)) {
            goto PrepareForReturn;
        }
    }

PrepareForReturn:

    if(classKey != NULL) {
        ZwClose(classKey);
    }

    ZwClose(instanceKey);

    return status;
}

NTSTATUS
PiForEachDriverQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PDEVICE_SERVICE_ITERATOR_CONTEXT InternalContext,
    IN ULONG ServiceType
    )
{
    UNICODE_STRING ServiceName;

    UNREFERENCED_PARAMETER( ValueName );

    if (ValueType != REG_SZ) {
        return STATUS_SUCCESS;
    }

    //
    // Make sure the string is a reasonable length.
    // copied directly from IopCallDriverAddDeviceQueryRoutine
    //

    if (ValueLength <= sizeof(WCHAR)) {
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&ServiceName, ValueData);

    return InternalContext->Iterator(
                InternalContext->DeviceInstancePath,
                &ServiceName,
                ServiceType,
                InternalContext->Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\convert.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xlate.c

Abstract:

    This file contains routines to translate resources between PnP ISA/BIOS
    format and Windows NT formats.

Author:

    Shie-Lin Tzong (shielint) 12-Apr-1995

Environment:

    Kernel mode only.

Revision History:

Note:

    This file is shared between the io subsystem and the ISAPNP bus driver.

    It is not compiled directly but is included by:
        base\ntos\io\pnpmgr\pnpcvrt.c
        base\busdrv\isapnp\convert.c

    ***** If you change this file make sure you build in *BOTH* places *****

--*/

#include "pbios.h"
#include "pnpcvrt.h"

#if UMODETEST
#undef IsNEC_98
#define IsNEC_98 0
#endif

#define NO_PLACEHOLDER_DMA_IRQ_SUPPORT  1

//
// internal structures for resource translation
//

typedef struct _PB_DEPENDENT_RESOURCES {
    ULONG Count;
    UCHAR Flags;
    UCHAR Priority;
    struct _PB_DEPENDENT_RESOURCES *Next;
} PB_DEPENDENT_RESOURCES, *PPB_DEPENDENT_RESOURCES;

#define DEPENDENT_FLAGS_END  1

typedef struct _PB_ATERNATIVE_INFORMATION {
    PPB_DEPENDENT_RESOURCES Resources;
    ULONG NoDependentFunctions;
    ULONG TotalResourceCount;
} PB_ALTERNATIVE_INFORMATION, *PPB_ALTERNATIVE_INFORMATION;

//
// Internal function references
//

PPB_DEPENDENT_RESOURCES
PbAddDependentResourcesToList (
    IN OUT PUCHAR *ResourceDescriptor,
    IN ULONG ListNo,
    IN PPB_ALTERNATIVE_INFORMATION AlternativeList
    );

NTSTATUS
PbBiosIrqToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    );

NTSTATUS
PbBiosDmaToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    );

NTSTATUS
PbBiosPortFixedToIoDescriptor (
    IN OUT PUCHAR               *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR   IoDescriptor,
    IN BOOLEAN                   ForceFixedIoTo16bit
    );

NTSTATUS
PbBiosPortToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    );

NTSTATUS
PbBiosMemoryToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    );

NTSTATUS
PpCmResourcesToBiosResources (
    IN PCM_RESOURCE_LIST CmResources,
    IN PUCHAR BiosRequirements,
    IN PUCHAR *BiosResources,
    IN PULONG Length
    );

NTSTATUS
PbCmIrqToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    );

NTSTATUS
PbCmDmaToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    );

NTSTATUS
PbCmPortToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    );

NTSTATUS
PbCmMemoryToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PpBiosResourcesToNtResources)
#pragma alloc_text(PAGE, PpBiosResourcesSetToDisabled)
#pragma alloc_text(PAGE, PbAddDependentResourcesToList)
#pragma alloc_text(PAGE, PbBiosIrqToIoDescriptor)
#pragma alloc_text(PAGE, PbBiosDmaToIoDescriptor)
#pragma alloc_text(PAGE, PbBiosPortFixedToIoDescriptor)
#pragma alloc_text(PAGE, PbBiosPortToIoDescriptor)
#pragma alloc_text(PAGE, PbBiosMemoryToIoDescriptor)
#pragma alloc_text(PAGE, PpCmResourcesToBiosResources)
#pragma alloc_text(PAGE, PbCmIrqToBiosDescriptor)
#pragma alloc_text(PAGE, PbCmDmaToBiosDescriptor)
#pragma alloc_text(PAGE, PbCmPortToBiosDescriptor)
#pragma alloc_text(PAGE, PbCmMemoryToBiosDescriptor)
#endif
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif

NTSTATUS
PpBiosResourcesToNtResources (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PUCHAR *BiosData,
    IN ULONG ConvertFlags,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *ReturnedList,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine parses the Bios resource list and generates
    a NT resource list.  The returned Nt resource list could be either IO
    format or CM format.  It is caller's responsibility to release the
    returned data buffer.

Arguments:

    SlotNumber - specifies the slot number of the BIOS resource.

    BiosData - Supplies a pointer to a variable which specifies the bios resource
        data buffer and which to receive the pointer to next bios resource data.

    ReturnedList - supplies a variable to receive the desired resource list.

    ReturnedLength - Supplies a variable to receive the length of the resource list.

Return Value:

    NTSTATUS code

--*/
{
    PUCHAR buffer;
    USHORT mask16, increment;
    UCHAR tagName, mask8;
    NTSTATUS status;
    PPB_ALTERNATIVE_INFORMATION alternativeList = NULL;
    ULONG commonResCount = 0, dependDescCount = 0, i, j;
    ULONG alternativeListCount = 0, dependFunctionCount = 0;
    PIO_RESOURCE_DESCRIPTOR ioDesc;
    PPB_DEPENDENT_RESOURCES dependResList = NULL, dependResources;
    BOOLEAN dependent = FALSE;
    BOOLEAN forceFixedIoTo16bit;
    ULONG listSize, noResLists;
    ULONG totalDescCount, descCount;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResReqList;
    PIO_RESOURCE_LIST ioResList;

    //
    // First, scan the bios data to determine the memory requirement and
    // the information to build internal data structures.
    //

    *ReturnedLength = 0;
    alternativeListCount = 0;
    buffer = *BiosData;
    tagName = *buffer;

    forceFixedIoTo16bit =
        (BOOLEAN)((ConvertFlags & PPCONVERTFLAG_FORCE_FIXED_IO_16BIT_DECODE) != 0);

    for ( ; ; ) {

        //
        // Determine the size of the BIOS resource descriptor
        //

        if (!(tagName & LARGE_RESOURCE_TAG)) {
            increment = (USHORT)(tagName & SMALL_TAG_SIZE_MASK);
            increment += 1;     // length of small tag
            tagName &= SMALL_TAG_MASK;
        } else {
            increment = *(USHORT UNALIGNED *)(buffer+1);
            increment += 3;     // length of large tag
        }

        if (tagName == TAG_END) {
            buffer += increment;
            break;
        }

        //
        // Based on the type of the BIOS resource, determine the count of
        // the IO descriptors.
        //

        switch (tagName) {
        case TAG_IRQ:
             mask16 = ((PPNP_IRQ_DESCRIPTOR)buffer)->IrqMask;
             i = 0;

#if NO_PLACEHOLDER_DMA_IRQ_SUPPORT
             while (mask16) {
                 if(mask16 & 1) {
                    i++;
                 }
                 mask16 >>= 1;
             }
#else
             if (mask16 == 0) {
                 i++;
             } else {
                 while (mask16) {
                     if(mask16 & 1) {
                        i++;
                     }
                     mask16 >>= 1;
                 }
             }
#endif
             if (!dependent) {
                 commonResCount += i;
             } else {
                 dependDescCount += i;
             }
             break;

        case TAG_DMA:
             mask8 = ((PPNP_DMA_DESCRIPTOR)buffer)->ChannelMask;
             i = 0;

#if NO_PLACEHOLDER_DMA_IRQ_SUPPORT
             while (mask8) {
                 if (mask8 & 1) {
                     i++;
                 }
                 mask8 >>= 1;
             }
#else
             if (mask8 == 0) {
                 i++;
             } else {
                 while (mask8) {
                     if (mask8 & 1) {
                         i++;
                     }
                     mask8 >>= 1;
                 }
             }
#endif
             if (!dependent) {
                 commonResCount += i;
             } else {
                 dependDescCount += i;
             }
             break;
        case TAG_START_DEPEND:
             dependent = TRUE;
             dependFunctionCount++;
             break;
        case TAG_END_DEPEND:
             dependent = FALSE;
             alternativeListCount++;
             break;
        case TAG_IO_FIXED:
        case TAG_IO:
        case TAG_MEMORY:
        case TAG_MEMORY32:
        case TAG_MEMORY32_FIXED:
             if (!dependent) {
                 commonResCount++;
             } else {
                 dependDescCount++;
             }
             break;
        default:

             //
             // Unknown tag. Skip it.
             //

             break;
        }

        //
        // Move to next bios resource descriptor.
        //

        buffer += increment;
        tagName = *buffer;
        if ((tagName & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
            break;
        }
    }

    if (dependent) {
        //
        // TAG_END_DEPEND was not found before we hit TAG_COMPLETE_END, so
        // simulate it.
        //
        dependent = FALSE;
        alternativeListCount++;
    }

    //
    // if empty bios resources, simply return.
    //

    if (commonResCount == 0 && dependFunctionCount == 0) {
        *ReturnedList = NULL;
        *ReturnedLength = 0;
        *BiosData = buffer;
        return STATUS_SUCCESS;
    }

    //
    // Allocate memory for our internal data structures
    //

    dependFunctionCount += commonResCount;
    dependResources = (PPB_DEPENDENT_RESOURCES)ExAllocatePoolWithTag(
                          PagedPool,
                          dependFunctionCount * sizeof(PB_DEPENDENT_RESOURCES) +
                              (commonResCount + dependDescCount) * sizeof(IO_RESOURCE_DESCRIPTOR),
                          'bPnP'
                          );
    if (!dependResources) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    dependResList = dependResources;  // remember it so we can free it.

    alternativeListCount += commonResCount;
    alternativeList = (PPB_ALTERNATIVE_INFORMATION)ExAllocatePoolWithTag(
                          PagedPool,
                          sizeof(PB_ALTERNATIVE_INFORMATION) * (alternativeListCount + 1),
                          'bPnP'
                          );
    if (!alternativeList) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit0;
    }
    RtlZeroMemory(alternativeList,
                  sizeof(PB_ALTERNATIVE_INFORMATION) * alternativeListCount
                  );

    alternativeList[0].Resources = dependResources;
    ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);

    //
    // Now start over again to process the bios data and initialize our internal
    // resource representation.
    //

    dependDescCount = 0;
    alternativeListCount = 0;
    buffer = *BiosData;
    tagName = *buffer;
    dependent = FALSE;

    for ( ; ; ) {
        if (!(tagName & LARGE_RESOURCE_TAG)) {
            tagName &= SMALL_TAG_MASK;
        }

        if (tagName == TAG_END) {
            buffer += (*buffer & SMALL_TAG_SIZE_MASK) + 1;
            break;
        }

        switch (tagName) {
        case TAG_DMA:
        case TAG_IRQ:
        case TAG_IO:
        case TAG_IO_FIXED:
        case TAG_MEMORY:
        case TAG_MEMORY32:
        case TAG_MEMORY32_FIXED:

             if (tagName == TAG_DMA) {
                 status = PbBiosDmaToIoDescriptor(&buffer, ioDesc);
             } else if (tagName == TAG_IRQ) {
                 status = PbBiosIrqToIoDescriptor(&buffer, ioDesc);
             } else if (tagName == TAG_IO) {
                 status = PbBiosPortToIoDescriptor(&buffer, ioDesc);
             } else if (tagName == TAG_IO_FIXED) {
                 status = PbBiosPortFixedToIoDescriptor(&buffer, ioDesc, forceFixedIoTo16bit);
             } else {
                 status = PbBiosMemoryToIoDescriptor(&buffer, ioDesc);
             }

             if (NT_SUCCESS(status)) {
                 ioDesc++;
                 if (dependent) {
                     dependDescCount++;
                 } else {
                     alternativeList[alternativeListCount].NoDependentFunctions = 1;
                     alternativeList[alternativeListCount].TotalResourceCount = 1;
                     dependResources->Count = 1;
                     dependResources->Flags = DEPENDENT_FLAGS_END;
                     dependResources->Next = alternativeList[alternativeListCount].Resources;
                     alternativeListCount++;
                     alternativeList[alternativeListCount].Resources = (PPB_DEPENDENT_RESOURCES)ioDesc;
                     dependResources = alternativeList[alternativeListCount].Resources;
                     ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);
                 }
             }
             break;
        case TAG_START_DEPEND:
             //
             // Some card (OPTI) put empty START_DEPENDENT functions
             //

             dependent = TRUE;
             if (alternativeList[alternativeListCount].NoDependentFunctions != 0) {

                 //
                 // End of current dependent function
                 //

                 dependResources->Count = dependDescCount;
                 dependResources->Flags = 0;
                 dependResources->Next = (PPB_DEPENDENT_RESOURCES)ioDesc;
                 dependResources = dependResources->Next;
                 ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);
                 alternativeList[alternativeListCount].TotalResourceCount += dependDescCount;
             }
             alternativeList[alternativeListCount].NoDependentFunctions++;
             if (*buffer & SMALL_TAG_SIZE_MASK) {
                 dependResources->Priority = *(buffer + 1);
             }
             dependDescCount = 0;
             buffer += 1 + (*buffer & SMALL_TAG_SIZE_MASK);
             break;
        case TAG_END_DEPEND:
             alternativeList[alternativeListCount].TotalResourceCount += dependDescCount;
             dependResources->Count = dependDescCount;
             dependResources->Flags = DEPENDENT_FLAGS_END;
             dependResources->Next = alternativeList[alternativeListCount].Resources;
             dependent = FALSE;
             dependDescCount = 0;
             alternativeListCount++;
             alternativeList[alternativeListCount].Resources = (PPB_DEPENDENT_RESOURCES)ioDesc;
             dependResources = alternativeList[alternativeListCount].Resources;
             ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);
             buffer++;
             break;
        default:

            //
            // Don't-care tag simply advance the buffer pointer to next tag.
            //

            if (*buffer & LARGE_RESOURCE_TAG) {
                increment = *(USHORT UNALIGNED *)(buffer+1);
                increment += 3;     // length of large tag
            } else {
                increment = (USHORT)(*buffer & SMALL_TAG_SIZE_MASK);
                increment += 1;     // length of small tag
            }
            buffer += increment;
        }
        tagName = *buffer;
        if ((tagName & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
            break;
        }
    }

    if (dependent) {
        //
        // TAG_END_DEPEND was not found before we hit TAG_COMPLETE_END, so
        // simulate it.
        //
        alternativeList[alternativeListCount].TotalResourceCount += dependDescCount;
        dependResources->Count = dependDescCount;
        dependResources->Flags = DEPENDENT_FLAGS_END;
        dependResources->Next = alternativeList[alternativeListCount].Resources;
        dependent = FALSE;
        dependDescCount = 0;
        alternativeListCount++;
        alternativeList[alternativeListCount].Resources = (PPB_DEPENDENT_RESOURCES)ioDesc;
        dependResources = alternativeList[alternativeListCount].Resources;
        ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);
    }

    if (alternativeListCount != 0) {
        alternativeList[alternativeListCount].Resources = NULL; // dummy alternativeList record
    }
    *BiosData = buffer;

    //
    // prepare IoResourceList
    //

    noResLists = 1;
    for (i = 0; i < alternativeListCount; i++) {
        noResLists *= alternativeList[i].NoDependentFunctions;
    }
    totalDescCount = 0;
    for (i = 0; i < alternativeListCount; i++) {
        descCount = 1;
        for (j = 0; j < alternativeListCount; j++) {
            if (j == i) {
                descCount *= alternativeList[j].TotalResourceCount;
            } else {
                descCount *= alternativeList[j].NoDependentFunctions;
            }
        }
        totalDescCount += descCount;
    }
    listSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
               sizeof(IO_RESOURCE_LIST) * (noResLists - 1) +
               sizeof(IO_RESOURCE_DESCRIPTOR) * totalDescCount -
               sizeof(IO_RESOURCE_DESCRIPTOR) * noResLists +
               sizeof(IO_RESOURCE_DESCRIPTOR) * commonResCount *  noResLists;

    if (ConvertFlags & PPCONVERTFLAG_SET_RESTART_LCPRI) {
        listSize += noResLists * sizeof(IO_RESOURCE_DESCRIPTOR);
    }

    ioResReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)ExAllocatePoolWithTag(PagedPool, listSize, 'bPnP');
    if (!ioResReqList) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit1;
    }

    ioResReqList->ListSize = listSize;
    ioResReqList->InterfaceType = Isa;
    ioResReqList->BusNumber = BusNumber;
    ioResReqList->SlotNumber = SlotNumber;
    ioResReqList->Reserved[0] = 0;
    ioResReqList->Reserved[1] = 0;
    ioResReqList->Reserved[2] = 0;
    ioResReqList->AlternativeLists = noResLists;
    ioResList = &ioResReqList->List[0];

    //
    // Build resource lists
    //

    for (i = 0; i < noResLists; i++) {

        ioResList->Version = 1;
        ioResList->Revision = 0x30 | (USHORT)i;

        if (ConvertFlags & PPCONVERTFLAG_SET_RESTART_LCPRI) {

            RtlZeroMemory(&ioResList->Descriptors[0], sizeof(IO_RESOURCE_DESCRIPTOR));

            ioResList->Descriptors[0].Option = IO_RESOURCE_PREFERRED;
            ioResList->Descriptors[0].Type = CmResourceTypeConfigData;
            ioResList->Descriptors[0].u.ConfigData.Priority = LCPRI_RESTART;

            buffer = (PUCHAR)&ioResList->Descriptors[1];

        } else {

            buffer = (PUCHAR)&ioResList->Descriptors[0];
        }

        //
        // Copy dependent functions if any.
        //

        if (alternativeList) {
            PbAddDependentResourcesToList(&buffer, 0, alternativeList);
        }

        //
        // Update io resource list ptr
        //

        ioResList->Count = ((ULONG)((ULONG_PTR)buffer - (ULONG_PTR)&ioResList->Descriptors[0])) /
                             sizeof(IO_RESOURCE_DESCRIPTOR);

        //
        // Hack for user mode pnp mgr
        //

        for (j = 0; j < ioResList->Count; j++) {
            ioResList->Descriptors[j].Spare2 = (USHORT)j;
        }
        ioResList = (PIO_RESOURCE_LIST)buffer;
    }

    *ReturnedLength = listSize;
    status = STATUS_SUCCESS;
    *ReturnedList = ioResReqList;
exit1:
    if (alternativeList) {
        ExFreePool(alternativeList);
    }
exit0:
    if (dependResList) {
        ExFreePool(dependResList);
    }
    return status;
}

VOID
PpBiosResourcesSetToDisabled (
    IN OUT PUCHAR BiosData,
    OUT    PULONG Length
    )

/*++

Routine Description:

    This routine modifies the passed in Bios resource list so that it reflects
    what PnPBIOS expects to see if a device is disabled.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer

    Length   - This points to a ULONG that will contain the length of the single
               resource list that has been programmed to look disabled.

Return Value:

    None.

--*/
{
    PUCHAR buffer;
    USHORT increment;
    UCHAR tagName ;

    //
    // First, scan the bios data to determine the memory requirement and
    // the information to build internal data structures.
    //

    buffer = BiosData;

    do {

        tagName = *buffer;

        //
        // Determine the size of the BIOS resource descriptor
        //
        if (!(tagName & LARGE_RESOURCE_TAG)) {
            increment = (USHORT)(tagName & SMALL_TAG_SIZE_MASK);
            tagName &= SMALL_TAG_MASK;

            //
            // Be careful not to wipe out the version field. That's very bad.
            //
            if (tagName != TAG_VERSION) {
               memset(buffer+1, '\0', increment);
            }
            increment += 1;     // length of small tag
        } else {
            increment = *(USHORT UNALIGNED *)(buffer+1);
            memset(buffer+3, '\0', increment);
            increment += 3;     // length of large tag
        }

        buffer += increment;
    } while (tagName != TAG_END) ;

    *Length = (ULONG)(buffer - BiosData) ;
}


PPB_DEPENDENT_RESOURCES
PbAddDependentResourcesToList (
    IN OUT PUCHAR *ResourceDescriptor,
    IN ULONG ListNo,
    IN PPB_ALTERNATIVE_INFORMATION AlternativeList
    )

/*++

Routine Description:

    This routine adds dependent functions to caller specified list.

Arguments:

    ResourceDescriptor - supplies a pointer to the descriptor buffer.

    ListNo - supplies an index to the AlternativeList.

    AlternativeList - supplies a pointer to the alternativelist array.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    PPB_DEPENDENT_RESOURCES dependentResources, ptr;
    ULONG size;

    //
    // Copy dependent resources to caller supplied list buffer and
    // update the list buffer pointer.
    //

    dependentResources = AlternativeList[ListNo].Resources;
    size = sizeof(IO_RESOURCE_DESCRIPTOR) *  dependentResources->Count;
    RtlMoveMemory(*ResourceDescriptor, dependentResources + 1, size);
    *ResourceDescriptor = *ResourceDescriptor + size;

    //
    // Add dependent resource of next list to caller's buffer
    //

    if (AlternativeList[ListNo + 1].Resources) {
        ptr = PbAddDependentResourcesToList(ResourceDescriptor, ListNo + 1, AlternativeList);
    } else {
        ptr = NULL;
    }
    if (ptr == NULL) {
        AlternativeList[ListNo].Resources = dependentResources->Next;
        if (!(dependentResources->Flags & DEPENDENT_FLAGS_END)) {
            ptr = dependentResources->Next;
        }
    }
    return ptr;
}

#if NO_PLACEHOLDER_DMA_IRQ_SUPPORT
NTSTATUS
PbBiosIrqToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS IRQ information to NT usable format.
    This routine stops when an irq io resource is generated.  if there are
    more irq io resource descriptors available, the BiosData pointer will
    not advance.  So caller will pass us the same resource tag again.

    Note, BIOS DMA info alway uses SMALL TAG.  A tag structure is repeated
    for each seperated channel required.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    static ULONG bitPosition = 0;
    USHORT mask;
    ULONG irq;
    PPNP_IRQ_DESCRIPTOR buffer;
    UCHAR size, option;
    NTSTATUS status = STATUS_SUCCESS;

    buffer = (PPNP_IRQ_DESCRIPTOR)*BiosData;

    //
    // if this is not the first descriptor for the tag, set
    // its option to alternative.
    //

    if (bitPosition == 0) {
        option = 0;
    } else {
        option = IO_RESOURCE_ALTERNATIVE;
    }
    size = buffer->Tag & SMALL_TAG_SIZE_MASK;
    mask = buffer->IrqMask;
    mask >>= bitPosition;
    irq = (ULONG) -1;

    while (mask) {
        if (mask & 1) {
            irq = bitPosition;
            break;
        }
        mask >>= 1;
        bitPosition++;
    }

    //
    // Fill in Io resource descriptor
    //

    if (irq != (ULONG)-1) {
        IoDescriptor->Option = option;
        IoDescriptor->Type = CmResourceTypeInterrupt;
        IoDescriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
        if (size == 3 && buffer->Information & 0x0C) {
            IoDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            IoDescriptor->ShareDisposition = CmResourceShareShared;
        }
        IoDescriptor->Spare1 = 0;
        IoDescriptor->Spare2 = 0;
        IoDescriptor->u.Interrupt.MinimumVector = irq;
        IoDescriptor->u.Interrupt.MaximumVector = irq;
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // try to move bitPosition to next 1 bit.
        //

        while (mask) {
            mask >>= 1;
            bitPosition++;
            if (mask & 1) {
                return status;
            }
        }
    }

    //
    // Done with current irq tag, advance pointer to next tag
    //

    bitPosition = 0;
    *BiosData = (PUCHAR)buffer + size + 1;
    return status;
}

NTSTATUS
PbBiosDmaToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS DMA information to NT usable format.
    This routine stops when an dma io resource is generated.  if there are
    more dma io resource descriptors available, the BiosData pointer will
    not advance.  So caller will pass us the same resource tag again.

    Note, BIOS DMA info alway uses SMALL TAG.  A tag structure is repeated
    for each seperated channel required.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    static ULONG bitPosition = 0;
    ULONG dma;
    PPNP_DMA_DESCRIPTOR buffer;
    UCHAR mask, option;
    NTSTATUS status = STATUS_SUCCESS;

    buffer = (PPNP_DMA_DESCRIPTOR)*BiosData;

    //
    // if this is not the first descriptor for the tag, set
    // its option to alternative.
    //

    if (bitPosition == 0) {
        option = 0;
    } else {
        option = IO_RESOURCE_ALTERNATIVE;
    }
    mask = buffer->ChannelMask;
    mask >>= bitPosition;
    dma = (ULONG) -1;

    while (mask) {
        if (mask & 1) {
            dma = bitPosition;
            break;
        }
        mask >>= 1;
        bitPosition++;
    }

    //
    // Fill in Io resource descriptor
    //

    if (dma != (ULONG)-1) {
        IoDescriptor->Option = option;
        IoDescriptor->Type = CmResourceTypeDma;
        IoDescriptor->Flags = 0;
        IoDescriptor->ShareDisposition = CmResourceShareUndetermined;
        IoDescriptor->Spare1 = 0;
        IoDescriptor->Spare2 = 0;
        IoDescriptor->u.Dma.MinimumChannel = dma;
        IoDescriptor->u.Dma.MaximumChannel = dma;
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // try to move bitPosition to next 1 bit.
        //

        while (mask) {
            mask >>= 1;
            bitPosition++;
            if (mask & 1) {
                return status;
            }
        }
    }

    //
    // Done with current dma tag, advance pointer to next tag
    //

    bitPosition = 0;
    buffer += 1;
    *BiosData = (PUCHAR)buffer;
    return status;
}
#else
NTSTATUS
PbBiosIrqToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS IRQ information to NT usable format.
    This routine stops when an irq io resource is generated.  if there are
    more irq io resource descriptors available, the BiosData pointer will
    not advance.  So caller will pass us the same resource tag again.

    Note, BIOS DMA info alway uses SMALL TAG.  A tag structure is repeated
    for each seperated channel required.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    static ULONG bitPosition = 0;
    USHORT mask;
    ULONG irq;
    PPNP_IRQ_DESCRIPTOR buffer;
    UCHAR size, option;

    buffer = (PPNP_IRQ_DESCRIPTOR)*BiosData;

    //
    // if this is not the first descriptor for the tag, set
    // its option to alternative.
    //

    if (bitPosition == 0) {
        option = 0;
    } else {
        option = IO_RESOURCE_ALTERNATIVE;
    }
    size = buffer->Tag & SMALL_TAG_SIZE_MASK;
    mask = buffer->IrqMask;
    mask >>= bitPosition;
    irq = (ULONG) -1;

    while (mask) {
        if (mask & 1) {
            irq = bitPosition;
            break;
        }
        mask >>= 1;
        bitPosition++;
    }

    //
    // Fill in Io resource descriptor
    //

    IoDescriptor->Option = option;
    IoDescriptor->Type = CmResourceTypeInterrupt;
    IoDescriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
    IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    if (size == 3 && buffer->Information & 0x0C) {
        IoDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        IoDescriptor->ShareDisposition = CmResourceShareShared;
    }
    IoDescriptor->Spare1 = 0;
    IoDescriptor->Spare2 = 0;
    IoDescriptor->u.Interrupt.MinimumVector = irq;
    IoDescriptor->u.Interrupt.MaximumVector = irq;

    //
    // try to move bitPosition to next 1 bit.
    //

    while (mask) {
        mask >>= 1;
        bitPosition++;
        if (mask & 1) {
            return STATUS_SUCCESS;
        }
    }

    //
    // Done with current irq tag, advance pointer to next tag
    //

    bitPosition = 0;
    *BiosData = (PUCHAR)buffer + size + 1;
    return STATUS_SUCCESS;
}

NTSTATUS
PbBiosDmaToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS DMA information to NT usable format.
    This routine stops when an dma io resource is generated.  if there are
    more dma io resource descriptors available, the BiosData pointer will
    not advance.  So caller will pass us the same resource tag again.

    Note, BIOS DMA info alway uses SMALL TAG.  A tag structure is repeated
    for each seperated channel required.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    static ULONG bitPosition = 0;
    ULONG dma;
    PPNP_DMA_DESCRIPTOR buffer;
    UCHAR mask, option;

    buffer = (PPNP_DMA_DESCRIPTOR)*BiosData;

    //
    // if this is not the first descriptor for the tag, set
    // its option to alternative.
    //

    if (bitPosition == 0) {
        option = 0;
    } else {
        option = IO_RESOURCE_ALTERNATIVE;
    }
    mask = buffer->ChannelMask;
    mask >>= bitPosition;
    dma = (ULONG) -1;

    while (mask) {
        if (mask & 1) {
            dma = bitPosition;
            break;
        }
        mask >>= 1;
        bitPosition++;
    }

    //
    // Fill in Io resource descriptor
    //

    IoDescriptor->Option = option;
    IoDescriptor->Type = CmResourceTypeDma;
    IoDescriptor->Flags = 0;
    IoDescriptor->ShareDisposition = CmResourceShareUndetermined;
    IoDescriptor->Spare1 = 0;
    IoDescriptor->Spare2 = 0;
    IoDescriptor->u.Dma.MinimumChannel = dma;
    IoDescriptor->u.Dma.MaximumChannel = dma;

    //
    // try to move bitPosition to next 1 bit.
    //

    while (mask) {
        mask >>= 1;
        bitPosition++;
        if (mask & 1) {
            return STATUS_SUCCESS;
        }
    }

    //
    // Done with current dma tag, advance pointer to next tag
    //

    bitPosition = 0;
    buffer += 1;
    *BiosData = (PUCHAR)buffer;
    return STATUS_SUCCESS;
}
#endif

NTSTATUS
PbBiosPortFixedToIoDescriptor (
    IN OUT PUCHAR               *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR   IoDescriptor,
    IN BOOLEAN                   ForceFixedIoTo16bit
    )

/*++

Routine Description:

    This routine translates BIOS FIXED IO information to NT usable format.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

    ForceFixedIoTo16bit - hack option to force fixed I/O resources to 16bit
        for far too pessimistic BIOS's.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    PPNP_FIXED_PORT_DESCRIPTOR buffer;

    buffer = (PPNP_FIXED_PORT_DESCRIPTOR)*BiosData;

    //
    // Fill in Io resource descriptor
    //

    IoDescriptor->Option = 0;
    IoDescriptor->Type = CmResourceTypePort;

    if (ForceFixedIoTo16bit) {

        IoDescriptor->Flags = CM_RESOURCE_PORT_IO + CM_RESOURCE_PORT_16_BIT_DECODE;

    } else {

        IoDescriptor->Flags = CM_RESOURCE_PORT_IO + CM_RESOURCE_PORT_10_BIT_DECODE;
    }

#if defined(_X86_)

    //
    // Workaround:
    //  NEC PC9800 series's PnPBIOS report I/O resources between 0x00 and 0xFF as FIXED IO.
    //  But These resources are 16bit DECODE resource, not 10bit DECODE one. We need to check
    //  the range of I/O resources .
    //

    if (IsNEC_98) {
        if ( (ULONG)buffer->MinimumAddress < 0x100 ) {
            IoDescriptor->Flags = CM_RESOURCE_PORT_IO + CM_RESOURCE_PORT_16_BIT_DECODE;
        }
    }
#endif                                                                                 // <--end changing code

    IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    IoDescriptor->Spare1 = 0;
    IoDescriptor->Spare2 = 0;
    IoDescriptor->u.Port.Length = (ULONG)buffer->Length;
    IoDescriptor->u.Port.MinimumAddress.LowPart = (ULONG)(buffer->MinimumAddress & 0x3ff);
    IoDescriptor->u.Port.MinimumAddress.HighPart = 0;
    IoDescriptor->u.Port.MaximumAddress.LowPart = IoDescriptor->u.Port.MinimumAddress.LowPart +
                                                      IoDescriptor->u.Port.Length - 1;
    IoDescriptor->u.Port.MaximumAddress.HighPart = 0;
    IoDescriptor->u.Port.Alignment = 1;

    //
    // Done with current fixed port tag, advance pointer to next tag
    //

    buffer += 1;
    *BiosData = (PUCHAR)buffer;
    return STATUS_SUCCESS;
}

NTSTATUS
PbBiosPortToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS IO information to NT usable format.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    PPNP_PORT_DESCRIPTOR buffer;

    buffer = (PPNP_PORT_DESCRIPTOR)*BiosData;

    //
    // Fill in Io resource descriptor
    //

    IoDescriptor->Option = 0;
    IoDescriptor->Type = CmResourceTypePort;
    IoDescriptor->Flags = CM_RESOURCE_PORT_IO;
    if (buffer->Information & 1) {
        IoDescriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
    } else {
        IoDescriptor->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
    }
    IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    IoDescriptor->Spare1 = 0;
    IoDescriptor->Spare2 = 0;
    IoDescriptor->u.Port.Length = (ULONG)buffer->Length;

#if defined(_X86_)
    if (IsNEC_98) {
        if (buffer->Information & 0x80) {
            IoDescriptor->u.Port.Length *= 2;
        }
    }
#endif

    IoDescriptor->u.Port.MinimumAddress.LowPart = (ULONG)buffer->MinimumAddress;
    IoDescriptor->u.Port.MinimumAddress.HighPart = 0;
    IoDescriptor->u.Port.MaximumAddress.LowPart = (ULONG)buffer->MaximumAddress +
                                                     IoDescriptor->u.Port.Length - 1;
    IoDescriptor->u.Port.MaximumAddress.HighPart = 0;
    IoDescriptor->u.Port.Alignment = (ULONG)buffer->Alignment;

    //
    // Done with current fixed port tag, advance pointer to next tag
    //

    buffer += 1;
    *BiosData = (PUCHAR)buffer;
    return STATUS_SUCCESS;
}

NTSTATUS
PbBiosMemoryToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS MEMORY information to NT usable format.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    PUCHAR buffer;
    UCHAR tag;
    PHYSICAL_ADDRESS minAddr, maxAddr;
    ULONG alignment, length;
    USHORT increment;
    USHORT flags = 0;

    buffer = *BiosData;
    tag = ((PPNP_MEMORY_DESCRIPTOR)buffer)->Tag;
    increment = ((PPNP_MEMORY_DESCRIPTOR)buffer)->Length + 3; // larg tag size = 3

    minAddr.HighPart = 0;
    maxAddr.HighPart = 0;
    switch (tag) {
    case TAG_MEMORY:
         minAddr.LowPart = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)buffer)->MinimumAddress)) << 8;
         if ((alignment = ((PPNP_MEMORY_DESCRIPTOR)buffer)->Alignment) == 0) {
             alignment = 0x10000;
         }
         length = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)buffer)->MemorySize)) << 8;
         maxAddr.LowPart = (((ULONG)(((PPNP_MEMORY_DESCRIPTOR)buffer)->MaximumAddress)) << 8) + length - 1;
         flags = CM_RESOURCE_MEMORY_24;
         break;
    case TAG_MEMORY32:
         length = ((PPNP_MEMORY32_DESCRIPTOR)buffer)->MemorySize;
         minAddr.LowPart = ((PPNP_MEMORY32_DESCRIPTOR)buffer)->MinimumAddress;
         maxAddr.LowPart = ((PPNP_MEMORY32_DESCRIPTOR)buffer)->MaximumAddress + length - 1;
         alignment = ((PPNP_MEMORY32_DESCRIPTOR)buffer)->Alignment;
         break;
    case TAG_MEMORY32_FIXED:
         length = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)buffer)->MemorySize;
         minAddr.LowPart = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)buffer)->BaseAddress;
         maxAddr.LowPart = minAddr.LowPart + length - 1;
         alignment = 1;
         break;
    }
    //
    // Fill in Io resource descriptor
    //

    IoDescriptor->Option = 0;
    IoDescriptor->Type = CmResourceTypeMemory;
    IoDescriptor->Flags = CM_RESOURCE_PORT_MEMORY + flags;
    IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    IoDescriptor->Spare1 = 0;
    IoDescriptor->Spare2 = 0;
    IoDescriptor->u.Memory.MinimumAddress = minAddr;
    IoDescriptor->u.Memory.MaximumAddress = maxAddr;
    IoDescriptor->u.Memory.Alignment = alignment;
    IoDescriptor->u.Memory.Length = length;

    //
    // Done with current tag, advance pointer to next tag
    //

    buffer += increment;
    *BiosData = (PUCHAR)buffer;
    return STATUS_SUCCESS;
}

NTSTATUS
PpCmResourcesToBiosResources (
    IN PCM_RESOURCE_LIST CmResources,
    IN PUCHAR BiosRequirements,
    IN PUCHAR *BiosResources,
    IN PULONG Length
    )

/*++

Routine Description:

    This routine parses the Cm resource list and generates
    a Pnp BIOS resource list.  It is caller's responsibility to release the
    returned data buffer.

Arguments:

    CmResources - Supplies a pointer to a Cm resource list buffer.

    BiosRequirements - supplies a pointer to the PnP BIOS possible resources.

    BiosResources - Supplies a variable to receive the pointer to the
        converted bios resource buffer.

    Length - supplies a pointer to a variable to receive the length
        of the Pnp Bios resources.

Return Value:

    a pointer to a Pnp Bios resource list if succeeded.  Else,
    a NULL pointer will be returned.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    ULONG i, l, count, length, totalSize = 0;
    PUCHAR p, px;
    PNP_MEMORY_DESCRIPTOR biosDesc;
    NTSTATUS status;

    *BiosResources = NULL;
    *Length = 0;
    CmResources->Count;
    if (CmResources->Count == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Determine pool size needed
    //

    count = 0;
    cmFullDesc = &CmResources->List[0];
    for (l = 0; l < CmResources->Count; l++) {
        cmDesc = cmFullDesc->PartialResourceList.PartialDescriptors;
        for (i = 0; i < cmFullDesc->PartialResourceList.Count; i++) {
            switch (cmDesc->Type) {
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:
                 count++;
                 cmDesc++;
                 break;
            case CmResourceTypeDeviceSpecific:
                 length = cmDesc->u.DeviceSpecificData.DataSize;
                 cmDesc++;
                 cmDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDesc + length);
            }
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDesc;
    }

    if (count == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Allocate max amount of memory
    //

    px = p= ExAllocatePoolWithTag(PagedPool,
                             count * sizeof(PNP_MEMORY_DESCRIPTOR),
                             'bPnP');
    if (!p) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    status = STATUS_RESOURCE_TYPE_NOT_FOUND;
    cmFullDesc = &CmResources->List[0];
    for (l = 0; l < CmResources->Count; l++) {
        cmDesc = cmFullDesc->PartialResourceList.PartialDescriptors;
        for (i = 0; i < cmFullDesc->PartialResourceList.Count; i++) {
            switch (cmDesc->Type) {
            case CmResourceTypePort:
                 status = PbCmPortToBiosDescriptor (
                                  BiosRequirements,
                                  cmDesc,
                                  &biosDesc,
                                  &length
                                  );
                 break;
            case CmResourceTypeInterrupt:
                 status = PbCmIrqToBiosDescriptor(
                                  BiosRequirements,
                                  cmDesc,
                                  &biosDesc,
                                  &length
                                  );
                 break;
            case CmResourceTypeMemory:
                 status = PbCmMemoryToBiosDescriptor (
                                  BiosRequirements,
                                  cmDesc,
                                  &biosDesc,
                                  &length
                                  );
                 break;
            case CmResourceTypeDma:
                 status = PbCmDmaToBiosDescriptor (
                                  BiosRequirements,
                                  cmDesc,
                                  &biosDesc,
                                  &length
                                  );
                 break;
            case CmResourceTypeDeviceSpecific:
                 length = cmDesc->u.DeviceSpecificData.DataSize;
                 cmDesc++;
                 cmDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDesc + length);
                 continue;
            }
            if (NT_SUCCESS(status)) {
                cmDesc++;
                RtlCopyMemory(p, &biosDesc, length);
                p += length;
                totalSize += length;
            } else {
                ExFreePool(px);
                goto exit;
            }
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDesc;
    }

exit:
    if (NT_SUCCESS(status)) {
        *p = TAG_COMPLETE_END;
        p++;
        *p = 0;            // checksum ignored
        totalSize += 2;
        *BiosResources = px;
        *Length = totalSize;
    }
    return status;
}

NTSTATUS
PbCmIrqToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine translates CM IRQ information to Pnp BIOS format.
    Since there is not enough information in the CM int descriptor to
    convert it to Pnp BIOS descriptor.  We will search the Bios
    possible resource lists for the corresponding resource information.

Arguments:

    BiosRequirements - Supplies a pointer to the bios possible resource lists.

    CmDescriptor - supplies a pointer to an CM_PARTIAL_RESOURCE_DESCRIPTOR buffer.

    ReturnDescriptor - Supplies a buffer to receive the returned BIOS descriptor.

    Length - Supplies a variable to receive the length of the returned bios descriptor.

Return Value:

    return a pointer to the desired dma descriptor in the BiosRequirements.  Null
    if not found.

--*/
{
    USHORT irqMask;
    UCHAR tag;
    PPNP_IRQ_DESCRIPTOR biosDesc;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG increment;
    PPNP_IRQ_DESCRIPTOR irqDesc = (PPNP_IRQ_DESCRIPTOR)ReturnDescriptor;


    if (!(CmDescriptor->u.Interrupt.Level & 0xfffffff0)) {
        irqMask = (USHORT)(1 << CmDescriptor->u.Interrupt.Level);
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    if (!BiosRequirements) {
        irqDesc->Tag = TAG_IRQ | (sizeof(PNP_IRQ_DESCRIPTOR) - 2);  // No Information
        irqDesc->IrqMask = irqMask;
        *Length = sizeof(PNP_IRQ_DESCRIPTOR) - 1;
        status = STATUS_SUCCESS;
    } else {
        tag = *BiosRequirements;
        while (tag != TAG_COMPLETE_END) {
            if ((tag & SMALL_TAG_MASK) == TAG_IRQ) {
                biosDesc = (PPNP_IRQ_DESCRIPTOR)BiosRequirements;
                if (biosDesc->IrqMask & irqMask) {
                    *Length = (biosDesc->Tag & SMALL_TAG_SIZE_MASK) + 1;
                    RtlCopyMemory(ReturnDescriptor, BiosRequirements, *Length);
                    ((PPNP_IRQ_DESCRIPTOR)ReturnDescriptor)->IrqMask = irqMask;
                    status = STATUS_SUCCESS;
                    break;
                }
            }

            //
            // Don't-care tag simply advance the buffer pointer to next tag.
            //

            if (tag & LARGE_RESOURCE_TAG) {
                increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
                increment += 3;     // length of large tag
            } else {
                increment = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
                increment += 1;     // length of small tag
            }
            BiosRequirements += increment;
            tag = *BiosRequirements;
        }
    }
    return status;
}

NTSTATUS
PbCmDmaToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine translates CM DMA information to Pnp BIOS format.
    Since there is not enough information in the CM descriptor to
    convert it to Pnp BIOS descriptor.  We will search the Bios
    possible resource lists for the corresponding resource information.

Arguments:

    BiosRequirements - Supplies a pointer to the bios possible resource lists.

    CmDescriptor - supplies a pointer to an CM_PARTIAL_RESOURCE_DESCRIPTOR buffer.

    BiosDescriptor - Supplies a variable to receive the returned BIOS descriptor.

    Length - Supplies a variable to receive the length of the returned bios descriptor.

Return Value:

    return a pointer to the desired dma descriptor in the BiosRequirements.  Null
    if not found.

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    UCHAR dmaMask, tag;
    PPNP_DMA_DESCRIPTOR biosDesc;
    ULONG increment;
    PPNP_DMA_DESCRIPTOR dmaDesc = (PPNP_DMA_DESCRIPTOR)ReturnDescriptor;
    USHORT flags = CmDescriptor->Flags;

    if (!(CmDescriptor->u.Dma.Channel & 0xfffffff0)) {
        dmaMask = (UCHAR)(1 << CmDescriptor->u.Dma.Channel);
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    if (!BiosRequirements) {
        dmaDesc->Tag = TAG_DMA | (sizeof(PNP_DMA_DESCRIPTOR) - 1);
        dmaDesc->ChannelMask = dmaMask;
        dmaDesc->Flags = 0;
        if (flags & CM_RESOURCE_DMA_8_AND_16) {
            dmaDesc->Flags += 1;
        } else if (flags & CM_RESOURCE_DMA_16) {
            dmaDesc->Flags += 2;
        }
        if (flags & CM_RESOURCE_DMA_BUS_MASTER) {
            dmaDesc->Flags += 4;
        }
        if (flags & CM_RESOURCE_DMA_TYPE_A) {
            dmaDesc->Flags += 32;
        }
        if (flags & CM_RESOURCE_DMA_TYPE_B) {
            dmaDesc->Flags += 64;
        }
        if (flags & CM_RESOURCE_DMA_TYPE_F) {
            dmaDesc->Flags += 96;
        }
        *Length = sizeof(PNP_DMA_DESCRIPTOR);
        status = STATUS_SUCCESS;
    } else {
        tag = *BiosRequirements;
        while (tag != TAG_COMPLETE_END) {
            if ((tag & SMALL_TAG_MASK) == TAG_DMA) {
                biosDesc = (PPNP_DMA_DESCRIPTOR)BiosRequirements;
                if (biosDesc->ChannelMask & dmaMask) {
                    *Length = (biosDesc->Tag & SMALL_TAG_SIZE_MASK) + 1;
                    RtlMoveMemory(ReturnDescriptor, BiosRequirements, *Length);
                    ((PPNP_DMA_DESCRIPTOR)ReturnDescriptor)->ChannelMask = dmaMask;
                    status = STATUS_SUCCESS;
                    break;
                }
            }

            //
            // Don't-care tag simply advance the buffer pointer to next tag.
            //

            if (tag & LARGE_RESOURCE_TAG) {
                increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
                increment += 3;     // length of large tag
            } else {
                increment = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
                increment += 1;     // length of small tag
            }
            BiosRequirements += increment;
            tag = *BiosRequirements;
        }
    }
    return status;
}

NTSTATUS
PbCmPortToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine translates CM PORT information to Pnp BIOS format.
    Since there is not enough information in the CM descriptor to
    convert it to Pnp BIOS full function port descriptor.  We will
    convert it to Pnp Bios fixed PORT descriptor.  It is caller's
    responsibility to release the returned data buffer.

Arguments:

    CmDescriptor - supplies a pointer to an CM_PARTIAL_RESOURCE_DESCRIPTOR buffer.

    BiosDescriptor - supplies a variable to receive the buffer which contains
        the desired Bios Port descriptor.

    Length - supplies a variable to receive the size the returned bios port
        descriptor.

    ReturnDescriptor - supplies a buffer to receive the desired Bios Port descriptor.

    Length - Supplies a variable to receive the length of the returned bios descriptor.

Return Value:

    A NTSTATUS code.

--*/
{
    PPNP_PORT_DESCRIPTOR portDesc = (PPNP_PORT_DESCRIPTOR)ReturnDescriptor;
    USHORT minAddr, maxAddr, address;
    UCHAR alignment, length, size, information, tag, returnTag;
    USHORT increment;
    BOOLEAN test = FALSE;

    if (CmDescriptor->u.Port.Start.HighPart != 0 ||
        CmDescriptor->u.Port.Start.LowPart & 0xffff0000 ||
        CmDescriptor->u.Port.Length & 0xffffff00) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Search the possible resource list to get the information
    // for the port range described by CmDescriptor.
    //

    address = (USHORT) CmDescriptor->u.Port.Start.LowPart;
    size = (UCHAR) CmDescriptor->u.Port.Length;
    if (!BiosRequirements) {

        //
        // No BiosRequirement.  Use TAG_IO as default.
        //

        portDesc->Tag = TAG_IO | (sizeof(PNP_PORT_DESCRIPTOR) - 1);
        if (CmDescriptor->Flags & CM_RESOURCE_PORT_16_BIT_DECODE) {
            portDesc->Information = 1;
        } else {
            portDesc->Information = 0;
        }
        portDesc->Length = size;
        portDesc->Alignment = 1;
        portDesc->MinimumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
        portDesc->MaximumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
        *Length = sizeof(PNP_PORT_DESCRIPTOR);
    } else {
        tag = *BiosRequirements;
        while (tag != TAG_COMPLETE_END) {
            test = FALSE;
            switch (tag & SMALL_TAG_MASK) {
            case TAG_IO:
                 minAddr = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->MinimumAddress;
                 alignment = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->Alignment;
                 length = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->Length;
                 maxAddr = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->MaximumAddress;
                 information = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->Information;
                 test = TRUE;
                 returnTag = TAG_IO;
                 if (!alignment) {
                    if (minAddr == maxAddr) {

                       //
                       // If the max is equal to the min, the alignment is
                       // meaningless. As we told OEMs 0 is appropriate here,
                       // let us handle it.
                       //
                       alignment = 1 ;
                    }
                 }
                 maxAddr += length - 1;
                 break;
            case TAG_IO_FIXED:
                 length = ((PPNP_FIXED_PORT_DESCRIPTOR)BiosRequirements)->Length;
                 minAddr = ((PPNP_FIXED_PORT_DESCRIPTOR)BiosRequirements)->MinimumAddress;
                 maxAddr = minAddr + length - 1;
                 alignment = 1;
                 information = 0;  // 10 bit decode
                 returnTag = TAG_IO_FIXED;
                 test = TRUE;
                 break;
            }
            if (test) {
                if (minAddr <= address && maxAddr >= (address + size - 1) && !(address & (alignment - 1 ))) {
                    break;
                }
                test = FALSE;
            }

            //
            // Advance to next tag
            //

            if (tag & LARGE_RESOURCE_TAG) {
                increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
                increment += 3;     // length of large tag
            } else {
                increment = (USHORT) tag & SMALL_TAG_SIZE_MASK;
                increment += 1;     // length of small tag
            }
            BiosRequirements += increment;
            tag = *BiosRequirements;
        }
        if (tag == TAG_COMPLETE_END) {
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Set the return port descriptor
        //

        if (returnTag == TAG_IO) {
            portDesc->Tag = TAG_IO + (sizeof(PNP_PORT_DESCRIPTOR) - 1);
            portDesc->Information = information;
            portDesc->Length = size;
            portDesc->Alignment = alignment;
            portDesc->MinimumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
            portDesc->MaximumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
            *Length = sizeof(PNP_PORT_DESCRIPTOR);
        } else {
            PPNP_FIXED_PORT_DESCRIPTOR fixedPortDesc = (PPNP_FIXED_PORT_DESCRIPTOR)ReturnDescriptor;

            fixedPortDesc->Tag = TAG_IO_FIXED + (sizeof(PPNP_FIXED_PORT_DESCRIPTOR) - 1);
            fixedPortDesc->MinimumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
            fixedPortDesc->Length = size;
            *Length = sizeof(PNP_FIXED_PORT_DESCRIPTOR);
        }
    }
    return STATUS_SUCCESS;

}

NTSTATUS
PbCmMemoryToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine translates CM Memory information to Pnp BIOS format.
    Since there is not enough information in the CM descriptor to
    convert it to Pnp BIOS descriptor.  We will search the Bios
    possible resource lists for the corresponding resource information and
    build a Pnp BIOS memory descriptor from there.  It is caller's responsibility
    to release the returned buffer.

Arguments:

    BiosRequirements - Supplies a pointer to the bios possible resource lists.

    CmDescriptor - supplies a pointer to an CM_PARTIAL_RESOURCE_DESCRIPTOR buffer.

    ReturnDescriptor - supplies a buffer to receive the desired Bios Memory descriptor.

    Length - supplies a variable to receive the size the returned bios port
        descriptor.

Return Value:

    A NTSTATUS code.

--*/
{
    UCHAR tag, information;
    PPNP_FIXED_MEMORY32_DESCRIPTOR memoryDesc = (PPNP_FIXED_MEMORY32_DESCRIPTOR)ReturnDescriptor;
    ULONG address, size, length, minAddr, maxAddr, alignment;
    USHORT increment;
    BOOLEAN test = FALSE;

    //
    // Search the possible resource list to get the information
    // for the memory range described by CmDescriptor.
    //

    address = CmDescriptor->u.Memory.Start.LowPart;
    size = CmDescriptor->u.Memory.Length;
    if (!BiosRequirements) {

        //
        // We don't support reserving legacy device's memory ranges from PNP
        // BIOS.  There isn't really any reason why not it just wasn't
        // implemented for Windows 2000.  It isn't near as necessary as it is
        // for I/O ports since ROM memory has a signature and is self
        // describing.
        //

        *Length = 0;
        return STATUS_SUCCESS;
    }
    tag = *BiosRequirements;
    while (tag != TAG_COMPLETE_END) {
        switch (tag & SMALL_TAG_MASK) {
        case TAG_MEMORY:
             minAddr = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MinimumAddress)) << 8;
             if ((alignment = ((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->Alignment) == 0) {
                 alignment = 0x10000;
             }
             length = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MemorySize)) << 8;
             maxAddr = (((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MaximumAddress)) << 8)
                             + length - 1;
             test = TRUE;
             break;
        case TAG_MEMORY32:
             length = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MemorySize;
             minAddr = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MinimumAddress;
             maxAddr = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MaximumAddress
                             + length - 1;
             alignment = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->Alignment;
             break;
        case TAG_MEMORY32_FIXED:
             length = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)BiosRequirements)->MemorySize;
             minAddr = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)BiosRequirements)->BaseAddress;
             maxAddr = minAddr + length - 1;
             alignment = 1;
             test = TRUE;
             break;
        }

        if (test) {
            if (minAddr <= address && maxAddr >= (address + size - 1) && !(address & (alignment - 1 ))) {
                information = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->Information;
                break;
            }
            test = FALSE;
        }

        //
        // Advance to next tag
        //

        if (tag & LARGE_RESOURCE_TAG) {
            increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
            increment += 3;     // length of large tag
        } else {
            increment = (USHORT) tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    if (tag == TAG_COMPLETE_END) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set up Pnp BIOS memory descriptor
    //

    memoryDesc->Tag = TAG_MEMORY32_FIXED;
    memoryDesc->Length = sizeof (PNP_FIXED_MEMORY32_DESCRIPTOR);
    memoryDesc->Information = information;
    memoryDesc->BaseAddress = address;
    memoryDesc->MemorySize = size;
    *Length = sizeof(PNP_FIXED_MEMORY32_DESCRIPTOR);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\devnode.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devnode.c

Abstract:

    This file contains routines to maintain our private device node list.

Author:

    Forrest Foltz (forrestf) 27-Mar-1996

Revision History:

    Modified for nt kernel.

--*/

#include "pnpmgrp.h"

//
// Internal definitions
//

typedef struct _ENUM_CONTEXT{
    PENUM_CALLBACK CallersCallback;
    PVOID CallersContext;
} ENUM_CONTEXT, *PENUM_CONTEXT;

//
// Internal References
//

NTSTATUS
PipForAllDeviceNodesCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    );

BOOLEAN
PipAreDriversLoadedWorker(
    IN PNP_DEVNODE_STATE    CurrentNodeState,
    IN PNP_DEVNODE_STATE    PreviousNodeState
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PipAreDriversLoaded)
#pragma alloc_text(PAGE, PipAreDriversLoadedWorker)
#pragma alloc_text(PAGE, PipAllocateDeviceNode)
#pragma alloc_text(PAGE, PipForAllDeviceNodes)
#pragma alloc_text(PAGE, PipForDeviceNodeSubtree)
#pragma alloc_text(PAGE, PipForAllChildDeviceNodes)
#pragma alloc_text(PAGE, PipForAllDeviceNodesCallback)
#pragma alloc_text(PAGE, IopDestroyDeviceNode)
//#pragma alloc_text(NONPAGE, PpDevNodeInsertIntoTree)
//#pragma alloc_text(NONPAGE, PpDevNodeRemoveFromTree)
#pragma alloc_text(PAGE, PpDevNodeLockTree)
#pragma alloc_text(PAGE, PpDevNodeUnlockTree)
#if DBG
#pragma alloc_text(PAGE, PpDevNodeAssertLockLevel)
#endif // DBG
#endif // ALLOC_PRAGMA


BOOLEAN
PipAreDriversLoaded(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This routine determines whether a devnode should be treated as if it has
    drivers attached to the PDO's stack (ie it's been added.)

Arguments:

    DeviceNode - Device node to examine.

Return Value:

    TRUE if drivers are loaded, FALSE otherwise.

--*/
{
    PAGED_CODE();

    return PipAreDriversLoadedWorker(
        DeviceNode->State,
        DeviceNode->PreviousState
        );
}

BOOLEAN
PipAreDriversLoadedWorker(
    IN PNP_DEVNODE_STATE    CurrentNodeState,
    IN PNP_DEVNODE_STATE    PreviousNodeState
    )
/*++

Routine Description:

    This routine determines whether a devnode should be treated as if it has
    drivers attached to the PDO's stack (ie it's been added.)

Arguments:

    CurrentNodeState - Current state of device node to examine.

    PreviousNodeState - Previous state of device node to examine.

Return Value:

    TRUE if drivers are loaded, FALSE otherwise.

--*/
{
    switch(CurrentNodeState) {

        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
        case DeviceNodeStarted:
        case DeviceNodeQueryStopped:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeQueryRemoved:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeDeletePendingCloses:
        case DeviceNodeAwaitingQueuedRemoval:
            return TRUE;

        case DeviceNodeAwaitingQueuedDeletion:
            return PipAreDriversLoadedWorker(
                PreviousNodeState,
                DeviceNodeUnspecified
                );

        case DeviceNodeUninitialized:
        case DeviceNodeInitialized:
        case DeviceNodeRemoved:
            return FALSE;

        case DeviceNodeDeleted:
            //
            // This can be seen by user mode because we defer delinking devices
            // from the tree during removal.
            //
            return FALSE;

        case DeviceNodeStartPending:
        case DeviceNodeEnumeratePending:
        case DeviceNodeUnspecified:
        default:
            ASSERT(0);
            return FALSE;
    }
}

BOOLEAN
PipIsDevNodeDNStarted(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This routine takes a devnode and determines whether the devnode should
    have the user mode DN_STARTED bit set.

Arguments:

    DeviceNode - Device node to examine.

Return Value:

    TRUE if the devnode should be considered started, FALSE otherwise.

--*/
{
    switch (DeviceNode->State) {

        case DeviceNodeStartPending:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
        case DeviceNodeStarted:
        case DeviceNodeQueryStopped:
        case DeviceNodeEnumeratePending:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
            return TRUE;

        case DeviceNodeUninitialized:
        case DeviceNodeInitialized:
        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeRemoved:
        case DeviceNodeQueryRemoved:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeDeletePendingCloses:
        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeAwaitingQueuedDeletion:
            return FALSE;

        case DeviceNodeDeleted:
            //
            // This can be seen by user mode because we defer delinking devices
            // from the tree during removal.
            //
            return FALSE;

        case DeviceNodeUnspecified:
        default:
            ASSERT(0);
            return FALSE;
    }
}

VOID
PipClearDevNodeProblem(
    IN PDEVICE_NODE DeviceNode
    )
{
    DeviceNode->Flags &= ~DNF_HAS_PROBLEM;
    DeviceNode->Problem = 0;
}

VOID
PipSetDevNodeProblem(
    IN PDEVICE_NODE DeviceNode,
    IN ULONG        Problem
    )
{
    ASSERT(DeviceNode->State != DeviceNodeUninitialized || !(DeviceNode->Flags & DNF_ENUMERATED) || Problem == CM_PROB_INVALID_DATA);
    ASSERT(DeviceNode->State != DeviceNodeStarted);
    ASSERT(Problem != 0);
    DeviceNode->Flags |= DNF_HAS_PROBLEM;                        \
    DeviceNode->Problem = Problem;
}

VOID
PipSetDevNodeState(
    IN  PDEVICE_NODE        DeviceNode,
    IN  PNP_DEVNODE_STATE   State,
    OUT PNP_DEVNODE_STATE   *OldState    OPTIONAL
    )
/*++

Routine Description:

    This routine sets a devnodes state and optional returns the prior state.
    The prior state is saved and can be restored via PipRestoreDevNodeState.

Arguments:

    DeviceNode - Device node to update state.

    State - State to place devnode in.

    OldState - Optionally receives prior state of devnode.

Return Value:

    None.

--*/
{
    PNP_DEVNODE_STATE   previousState;
    KIRQL               oldIrql;

    ASSERT(State != DeviceNodeQueryStopped || DeviceNode->State == DeviceNodeStarted);

#if DBG
    if ((State == DeviceNodeDeleted) ||
        (State == DeviceNodeDeletePendingCloses)) {

        ASSERT(!(DeviceNode->Flags & DNF_ENUMERATED));
    }
#endif

    KeAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    previousState = DeviceNode->State;
    if (DeviceNode->State != State) {

        //
        // Update the devnode's current and previous state.
        //
        DeviceNode->State = State;
        DeviceNode->PreviousState = previousState;

        //
        // Push prior state onto the history stack.
        //
        DeviceNode->StateHistory[DeviceNode->StateHistoryEntry] = previousState;
        DeviceNode->StateHistoryEntry++;
        DeviceNode->StateHistoryEntry %= STATE_HISTORY_SIZE;
    }

    KeReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    if (ARGUMENT_PRESENT(OldState)) {

        *OldState = previousState;
    }
    if (State == DeviceNodeDeleted) {

        PpRemoveDeviceActionRequests(DeviceNode->PhysicalDeviceObject);
    }
}

VOID
PipRestoreDevNodeState(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This routine restores a devnodes state to the state pushed by the last
    PipSetDevNodeState call. This function can only be called once for each
    call to PipSetDevNodeState.

Arguments:

    DeviceNode - Device node to restore state.

Return Value:

    None.

--*/
{
    PNP_DEVNODE_STATE   previousState;
    KIRQL               oldIrql;

    ASSERT((DeviceNode->State == DeviceNodeQueryRemoved) ||
           (DeviceNode->State == DeviceNodeQueryStopped) ||
           (DeviceNode->State == DeviceNodeAwaitingQueuedRemoval) ||
           (DeviceNode->State == DeviceNodeAwaitingQueuedDeletion));

    KeAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    //
    // Update the devnode's state.
    //
    previousState = DeviceNode->State;
    DeviceNode->State = DeviceNode->PreviousState;

    //
    // Push the old state onto the history stack.
    //
    DeviceNode->StateHistory[DeviceNode->StateHistoryEntry] = previousState;
    DeviceNode->StateHistoryEntry++;
    DeviceNode->StateHistoryEntry %= STATE_HISTORY_SIZE;

#if DBG
    //
    // Put a sentinel on the stack - restoring twice is a bug.
    //
    DeviceNode->PreviousState = DeviceNodeUnspecified;
#endif

    KeReleaseSpinLock(&IopPnPSpinLock, oldIrql);
}

BOOLEAN
PipIsProblemReadonly(
    IN  ULONG   Problem
    )
/*++

Routine Description:

    This routine returns TRUE if the specified CM_PROB code cannot be cleared
    by user mode, FALSE otherwise.

Arguments:

    Problem - CM_PROB_...

Return Value:

    TRUE/FALSE.

--*/
{
    switch(Problem) {

        case CM_PROB_OUT_OF_MEMORY: // Nonresettable due to IoReportResourceUsage path.
        case CM_PROB_NORMAL_CONFLICT:
        case CM_PROB_PARTIAL_LOG_CONF:
        case CM_PROB_DEVICE_NOT_THERE:
        case CM_PROB_HARDWARE_DISABLED:
        case CM_PROB_DISABLED_SERVICE:
        case CM_PROB_TRANSLATION_FAILED:
        case CM_PROB_NO_SOFTCONFIG:
        case CM_PROB_BIOS_TABLE:
        case CM_PROB_IRQ_TRANSLATION_FAILED:
        case CM_PROB_DUPLICATE_DEVICE:
        case CM_PROB_SYSTEM_SHUTDOWN:
        case CM_PROB_HELD_FOR_EJECT:
        case CM_PROB_REGISTRY_TOO_LARGE:
        case CM_PROB_INVALID_DATA:

            return TRUE;

        case CM_PROB_FAILED_INSTALL:
        case CM_PROB_FAILED_ADD:
        case CM_PROB_FAILED_START:
        case CM_PROB_NOT_CONFIGURED:
        case CM_PROB_NEED_RESTART:
        case CM_PROB_REINSTALL:
        case CM_PROB_REGISTRY:
        case CM_PROB_DISABLED:
        case CM_PROB_FAILED_DRIVER_ENTRY:
        case CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD:
        case CM_PROB_DRIVER_FAILED_LOAD:
        case CM_PROB_DRIVER_SERVICE_KEY_INVALID:
        case CM_PROB_LEGACY_SERVICE_NO_DEVICES:
        case CM_PROB_HALTED:
        case CM_PROB_FAILED_POST_START:
        case CM_PROB_WILL_BE_REMOVED:
        case CM_PROB_DRIVER_BLOCKED:

            return FALSE;

        case CM_PROB_PHANTOM:

            //
            // Should never see in kernel mode
            //

        case CM_PROB_DEVLOADER_FAILED:
        case CM_PROB_DEVLOADER_NOT_FOUND:
        case CM_PROB_REENUMERATION:
        case CM_PROB_VXDLDR:
        case CM_PROB_NOT_VERIFIED:
        case CM_PROB_LIAR:
        case CM_PROB_FAILED_FILTER:
        case CM_PROB_MOVED:
        case CM_PROB_TOO_EARLY:
        case CM_PROB_NO_VALID_LOG_CONF:
        case CM_PROB_UNKNOWN_RESOURCE:
        case CM_PROB_ENTRY_IS_WRONG_TYPE:
        case CM_PROB_LACKED_ARBITRATOR:
        case CM_PROB_BOOT_CONFIG_CONFLICT:
        case CM_PROB_DEVLOADER_NOT_READY:
        case CM_PROB_CANT_SHARE_IRQ:

            //
            // Win9x specific
            //

        default:
            ASSERT(0);

            //
            // We return TRUE in this path because that prevents these problems
            // from being set on devnodes (SetDeviceProblem won't allow usage
            // of ReadOnly problems)
            //
            return TRUE;
    }
}

NTSTATUS
PipAllocateDeviceNode(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PDEVICE_NODE *DeviceNode
    )
/*++

Routine Description:

    This function allocates a device node from nonpaged pool and initializes
    the fields which do not require to hold lock to do so.  Since adding
    the device node to pnp mgr's device node tree requires acquiring lock,
    this routine does not add the device node to device node tree.

Arguments:

    PhysicalDeviceObject - Supplies a pointer to its corresponding physical device
        object.

Return Value:

    a pointer to the newly created device node. Null is returned if failed.

--*/
{

    PAGED_CODE();

    *DeviceNode = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(DEVICE_NODE),
                    IOP_DNOD_TAG
                    );

    if (*DeviceNode == NULL ){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    InterlockedIncrement((LONG *)&IopNumberDeviceNodes);

    RtlZeroMemory(*DeviceNode, sizeof(DEVICE_NODE));
    (*DeviceNode)->InterfaceType = InterfaceTypeUndefined;
    (*DeviceNode)->BusNumber = (ULONG)-1;
    (*DeviceNode)->ChildInterfaceType = InterfaceTypeUndefined;
    (*DeviceNode)->ChildBusNumber = (ULONG)-1;
    (*DeviceNode)->ChildBusTypeIndex = (USHORT)-1;
    (*DeviceNode)->State = DeviceNodeUninitialized;
    (*DeviceNode)->DisableableDepends = 0;
    PpHotSwapInitRemovalPolicy(*DeviceNode);

    InitializeListHead(&(*DeviceNode)->DeviceArbiterList);
    InitializeListHead(&(*DeviceNode)->DeviceTranslatorList);

    if (PhysicalDeviceObject){

        (*DeviceNode)->PhysicalDeviceObject = PhysicalDeviceObject;
        PhysicalDeviceObject->DeviceObjectExtension->DeviceNode = (PVOID)*DeviceNode;
        PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    InitializeListHead(&(*DeviceNode)->TargetDeviceNotify);

    InitializeListHead(&(*DeviceNode)->DockInfo.ListEntry);

    InitializeListHead(&(*DeviceNode)->PendedSetInterfaceState);

    InitializeListHead(&(*DeviceNode)->LegacyBusListEntry);

    if (PpSystemHiveTooLarge) {

        return STATUS_SYSTEM_HIVE_TOO_LARGE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PipForAllDeviceNodes(
    IN PENUM_CALLBACK Callback,
    IN PVOID Context
    )
/*++

Routine Description:

    This function walks the device node tree and invokes the caller specified
    'Callback' function for each device node.

    Note, this routine (or its worker routine) traverses the tree in a top
    down manner.

Arguments:

    Callback - Supplies the call back routine for each device node.

    Context - Supplies a parameter/context for the callback function.

Return Value:

    Status returned from Callback, if not successfull then the tree walking stops.

--*/
{
    PAGED_CODE();

    return PipForDeviceNodeSubtree(IopRootDeviceNode, Callback, Context);
}


NTSTATUS
PipForDeviceNodeSubtree(
    IN PDEVICE_NODE     DeviceNode,
    IN PENUM_CALLBACK   Callback,
    IN PVOID            Context
    )
/*++

Routine Description:

    This function walks the device node tree under but not including the passed
    in device node and perform caller specified 'Callback' function for each
    device node.

    Note, this routine (or its worker routine) traverses the tree in a top
    down manner.

Arguments:

    Callback - Supplies the call back routine for each device node.

    Context - Supplies a parameter/context for the callback function.

Return Value:

    Status returned from Callback, if not successfull then the tree walking stops.

--*/
{
    ENUM_CONTEXT enumContext;
    NTSTATUS status;

    PAGED_CODE();

    enumContext.CallersCallback = Callback;
    enumContext.CallersContext = Context;

    //
    // Start with a pointer to the root device node, recursively examine all the
    // children until we the callback function says stop or we've looked at all
    // of them.
    //
    PpDevNodeLockTree(PPL_SIMPLE_READ);

    status = PipForAllChildDeviceNodes(DeviceNode,
                                       PipForAllDeviceNodesCallback,
                                       (PVOID)&enumContext );


    PpDevNodeUnlockTree(PPL_SIMPLE_READ);
    return status;
}


NTSTATUS
PipForAllChildDeviceNodes(
    IN PDEVICE_NODE Parent,
    IN PENUM_CALLBACK Callback,
    IN PVOID Context
    )

/*++

Routine Description:

    This function walks the Parent's device node subtree and perform caller specified
    'Callback' function for each device node under Parent.

    Note, befor calling this rotuine, callers must acquire the enumeration mutex
    of the 'Parent' device node to make sure its children won't go away unless the
    call tells them to.

Arguments:

    Parent - Supplies a pointer to the device node whose subtree is to be walked.

    Callback - Supplies the call back routine for each device node.

    Context - Supplies a parameter/context for the callback function.

Return Value:

    NTSTATUS value.

--*/

{
    PDEVICE_NODE nextChild = Parent->Child;
    PDEVICE_NODE child;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Process siblings until we find the end of the sibling list or
    // the Callback() returns FALSE.  Set result = TRUE at the top of
    // the loop so that if there are no siblings we will return TRUE,
    // e.g. Keep Enumerating.
    //
    // Note, we need to find next child before calling Callback function
    // in case the current child is deleted by the Callback function.
    //

    while (nextChild && NT_SUCCESS(status)) {
        child = nextChild;
        nextChild = child->Sibling;
        status = Callback(child, Context);
    }

    return status;
}

NTSTATUS
PipForAllDeviceNodesCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the worker routine for PipForAllChildDeviceNodes routine.

Arguments:

    DeviceNode - Supplies a pointer to the device node whose subtree is to be walked.

    Context - Supplies a context which contains the caller specified call back
              function and parameter.

Return Value:

    NTSTATUS value.

--*/

{
    PENUM_CONTEXT enumContext;
    NTSTATUS status;

    PAGED_CODE();

    enumContext = (PENUM_CONTEXT)Context;

    //
    // First call the caller's callback for this devnode
    //

    status =
        enumContext->CallersCallback(DeviceNode, enumContext->CallersContext);

    if (NT_SUCCESS(status)) {

        //
        // Now enumerate the children, if any.
        //
        if (DeviceNode->Child) {

            status = PipForAllChildDeviceNodes(
                                        DeviceNode,
                                        PipForAllDeviceNodesCallback,
                                        Context);
        }
    }

    return status;
}
VOID
IopDestroyDeviceNode(
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This function is invoked by IopDeleteDevice to clean up the device object's
    device node structure.

Arguments:

    DeviceNode - Supplies a pointer to the device node whose subtree is to be walked.

    Context - Supplies a context which contains the caller specified call back
              function and parameter.

Return Value:

    NTSTATUS value.

--*/

{
#if DBG
    PDEVICE_OBJECT dbgDeviceObject;
#endif

    PAGED_CODE();

    if (DeviceNode) {

        if ((DeviceNode->PhysicalDeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) &&
            DeviceNode->Parent != NULL)  {

            PP_SAVE_DEVNODE_TO_TRIAGE_DUMP(DeviceNode);
            KeBugCheckEx( PNP_DETECTED_FATAL_ERROR,
                          PNP_ERR_ACTIVE_PDO_FREED,
                          (ULONG_PTR)DeviceNode->PhysicalDeviceObject,
                          0,
                          0);
        }
        if (DeviceNode->Flags & DNF_LEGACY_RESOURCE_DEVICENODE) {
            //
            // Release the resources this device consumes (the devicenode will
            // get deleted after the release). Basically cleanup after bad
            // (legacy) drivers.
            //
            IopLegacyResourceAllocation(    ArbiterRequestUndefined,
                                            IoPnpDriverObject,
                                            DeviceNode->PhysicalDeviceObject,
                                            NULL,
                                            NULL);
            return;
        }

#if DBG

        //
        // If Only Parent is NOT NULL, most likely the driver forgot to
        // release resources before deleting its FDO.  (The driver previously
        // call legacy assign resource interface.)
        //

        ASSERT(DeviceNode->Child == NULL &&
               DeviceNode->Sibling == NULL &&
               DeviceNode->LastChild == NULL
               );

        ASSERT(DeviceNode->DockInfo.SerialNumber == NULL &&
               IsListEmpty(&DeviceNode->DockInfo.ListEntry));

        if (DeviceNode->PhysicalDeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) {
            ASSERT (DeviceNode->Parent == 0);
        }

        if (DeviceNode->PreviousResourceList) {
            ExFreePool(DeviceNode->PreviousResourceList);
        }
        if (DeviceNode->PreviousResourceRequirements) {
            ExFreePool(DeviceNode->PreviousResourceRequirements);
        }

        //
        // device should not appear to be not-disableable if/when we get here
        // if either of these two lines ASSERT, email: jamiehun
        //

        ASSERT((DeviceNode->UserFlags & DNUF_NOT_DISABLEABLE) == 0);
        ASSERT(DeviceNode->DisableableDepends == 0);

        if (DeviceNode->InstancePath.Length) {

            dbgDeviceObject = IopDeviceObjectFromDeviceInstance(&DeviceNode->InstancePath);

            if (dbgDeviceObject) {

                ASSERT(dbgDeviceObject != DeviceNode->PhysicalDeviceObject);
                ObDereferenceObject(dbgDeviceObject);
            }
        }

#endif
        if (DeviceNode->DuplicatePDO) {
            ObDereferenceObject(DeviceNode->DuplicatePDO);
        }
        if (DeviceNode->ServiceName.Length != 0) {
            ExFreePool(DeviceNode->ServiceName.Buffer);
        }
        if (DeviceNode->InstancePath.Length != 0) {
            ExFreePool(DeviceNode->InstancePath.Buffer);
        }
        if (DeviceNode->ResourceRequirements) {
            ExFreePool(DeviceNode->ResourceRequirements);
        }
        //
        // Dereference all the arbiters and translators on this PDO.
        //
        IopUncacheInterfaceInformation(DeviceNode->PhysicalDeviceObject) ;

        //
        // Release any pended IoSetDeviceInterface structures
        //

        while (!IsListEmpty(&DeviceNode->PendedSetInterfaceState)) {

            PPENDING_SET_INTERFACE_STATE entry;

            entry = (PPENDING_SET_INTERFACE_STATE)RemoveHeadList(&DeviceNode->PendedSetInterfaceState);

            ExFreePool(entry->LinkName.Buffer);

            ExFreePool(entry);
        }

        DeviceNode->PhysicalDeviceObject->DeviceObjectExtension->DeviceNode = NULL;
        ExFreePool(DeviceNode);
        IopNumberDeviceNodes--;
    }
}


VOID
PpDevNodeInsertIntoTree(
    IN PDEVICE_NODE     ParentNode,
    IN PDEVICE_NODE     DeviceNode
    )
/*++

Routine Description:

    This function is called to insert a new devnode into the device tree.

    Note that there are two classes of callers:
        PnP callers
        Legacy callers

    All PnP callers hold the device tree lock. Legacy callers however come in
    with no locks, as they might be brought into being due to a PnP event. To
    deal with the later case, inserts are atomic and legacy callers can never
    remove themselves from the tree.

Arguments:

    ParentNode - Supplies a pointer to the device node's parent

    DeviceNode - Supplies a pointer to the device node which needs to be
                 inserted into the tree.

Return Value:

    None.

--*/
{
    ULONG depth;
    KIRQL oldIrql;

    //
    // Acquire spinlock to deal with legacy/PnP synchronization.
    //
    KeAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    //
    // Determine the depth of the devnode.
    //
    depth = ParentNode->Level + 1;
    DeviceNode->Level = depth;

    //
    // Update the maximum depth of the tree.
    //
    if (depth > IopMaxDeviceNodeLevel) {
        IopMaxDeviceNodeLevel = depth;
    }

    //
    // Put this devnode at the end of the parent's list of children. Note that
    // the Child/Sibling fields are really the last things to be updated. This
    // has to be done as walkers of the tree hold no locks that protect the
    // tree from legacy inserts.
    //
    DeviceNode->Parent = ParentNode;
    KeMemoryBarrier();
    if (ParentNode->LastChild) {
        ASSERT(ParentNode->LastChild->Sibling == NULL);
        ParentNode->LastChild->Sibling = DeviceNode;
        ParentNode->LastChild = DeviceNode;
    } else {
        ASSERT(ParentNode->Child == NULL);
        ParentNode->Child = ParentNode->LastChild = DeviceNode;
    }

    KeReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    //
    // Tree has changed
    //
    IoDeviceNodeTreeSequence += 1;
}


VOID
PpDevNodeRemoveFromTree(
    IN PDEVICE_NODE     DeviceNode
    )
/*++

Routine Description:

    This function removes the device node from the device node tree

Arguments:

    DeviceNode      - Device node to remove

Return Value:

--*/
{
    PDEVICE_NODE    *node;
    KIRQL           oldIrql;

    //
    // Acquire spinlock to deal with legacy/PnP synchronization.
    //
    KeAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    //
    // Unlink the pointer to this device node.  (If this is the
    // first entry, unlink it from the parents child pointer, else
    // remove it from the sibling list)
    //

    node = &DeviceNode->Parent->Child;
    while (*node != DeviceNode) {
        node = &(*node)->Sibling;
    }
    *node = DeviceNode->Sibling;

    if (DeviceNode->Parent->Child == NULL) {
        DeviceNode->Parent->LastChild = NULL;
    } else {
        while (*node) {
            node = &(*node)->Sibling;
        }
        DeviceNode->Parent->LastChild = CONTAINING_RECORD(node, DEVICE_NODE, Sibling);
    }

    KeReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    //
    // Remove this device node from Legacy Bus information table.
    //
    IopRemoveLegacyBusDeviceNode(DeviceNode);

    //
    // Orphan any outstanding device change notifications on these nodes.
    //
    IopOrphanNotification(DeviceNode);

    //
    // No longer linked
    //
    DeviceNode->Parent    = NULL;
    DeviceNode->Child     = NULL;
    DeviceNode->Sibling   = NULL;
    DeviceNode->LastChild = NULL;
}


VOID
PpDevNodeLockTree(
    IN  PNP_LOCK_LEVEL  LockLevel
    )
/*++

Routine Description:

    This function acquires the tree lock with the appropriate level of
    restrictions.

Arguments:

    LockLevel:
        PPL_SIMPLE_READ         - Allows simple examination of the tree.

        PPL_TREEOP_ALLOW_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads can go through however.

        PPL_TREEOP_BLOCK_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads are also blocked.

        PPL_TREEOP_BLOCK_READS_FROM_ALLOW - Switch to PPL_TREEOP_BLOCK_READS
                                            when already in
                                            PPL_TREEOP_BLOCK_READS. Note that
                                            PpDevNodeUnlockTree must be
                                            subsequently called on both to
                                            release.

Return Value:

    None.

--*/
{
    ULONG refCount, remainingCount;

    //
    // Block any attempt to suspend the thread via user mode.
    //
    KeEnterCriticalRegion();

    switch(LockLevel) {

        case PPL_SIMPLE_READ:
            ExAcquireSharedWaitForExclusive(&IopDeviceTreeLock, TRUE);
            break;

        case PPL_TREEOP_ALLOW_READS:
            ExAcquireResourceExclusiveLite(&PiEngineLock, TRUE);
            ExAcquireSharedWaitForExclusive(&IopDeviceTreeLock, TRUE);
            break;

        case PPL_TREEOP_BLOCK_READS:
            ExAcquireResourceExclusiveLite(&PiEngineLock, TRUE);
            ExAcquireResourceExclusiveLite(&IopDeviceTreeLock, TRUE);
            break;

        case PPL_TREEOP_BLOCK_READS_FROM_ALLOW:

            //
            // Drop the tree lock and require exclusive.
            //
            ASSERT(ExIsResourceAcquiredExclusiveLite(&PiEngineLock));

            //
            // "Shared" is a subset of exclusive. ExIsResourceAcquiredShared
            // will return nonzero if it's owned exclusive. We flush out that
            // case here.
            //
            ASSERT(ExIsResourceAcquiredSharedLite(&IopDeviceTreeLock) &&
                   (!ExIsResourceAcquiredExclusiveLite(&IopDeviceTreeLock)));

            //
            // Drop the tree lock entirely.
            //
            refCount = ExIsResourceAcquiredSharedLite(&IopDeviceTreeLock);
            for(remainingCount = refCount; remainingCount; remainingCount--) {

                ExReleaseResourceLite(&IopDeviceTreeLock);
            }

            //
            // Grab it exclusively while keeping the original count.
            //
            for(remainingCount = refCount; remainingCount; remainingCount--) {

                ExAcquireResourceExclusiveLite(&IopDeviceTreeLock, TRUE);
            }
            break;

        default:
            ASSERT(0);
            break;
    }
}


VOID
PpDevNodeUnlockTree(
    IN  PNP_LOCK_LEVEL  LockLevel
    )
/*++

Routine Description:

    This function releases the tree lock with the appropriate level of
    restrictions.

Arguments:

    LockLevel:
        PPL_SIMPLE_READ         - Allows simple examination of the tree.

        PPL_TREEOP_ALLOW_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads can go through however.

        PPL_TREEOP_BLOCK_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads are also blocked.

        PPL_TREEOP_BLOCK_READS_FROM_ALLOW - Switch to PPL_TREEOP_BLOCK_READS
                                            when already in
                                            PPL_TREEOP_BLOCK_READS. Note that
                                            PpDevNodeUnlockTree must be
                                            subsequently called on both to
                                            release.
Return Value:

    None.

--*/
{
    PPDEVNODE_ASSERT_LOCK_HELD(LockLevel);
    switch(LockLevel) {

        case PPL_SIMPLE_READ:
            ExReleaseResourceLite(&IopDeviceTreeLock);
            break;

        case PPL_TREEOP_ALLOW_READS:
            ExReleaseResourceLite(&IopDeviceTreeLock);
            ExReleaseResourceLite(&PiEngineLock);
            break;

        case PPL_TREEOP_BLOCK_READS:
            ExReleaseResourceLite(&IopDeviceTreeLock);
            ExReleaseResourceLite(&PiEngineLock);
            break;

        case PPL_TREEOP_BLOCK_READS_FROM_ALLOW:
            //
            // The engine lock should still be held here. Now we adjust the
            // tree lock. Go back to allow by converting the exclusive lock to
            // shared. Note that this doesn't chance the acquisition count.
            //
            ASSERT(ExIsResourceAcquiredExclusiveLite(&IopDeviceTreeLock));
            ASSERT(ExIsResourceAcquiredExclusiveLite(&PiEngineLock));
            ExConvertExclusiveToSharedLite(&IopDeviceTreeLock);
            break;

        default:
            ASSERT(0);
            break;
    }

    KeLeaveCriticalRegion();
}


#if DBG
VOID
PpDevNodeAssertLockLevel(
    IN  PNP_LOCK_LEVEL  LockLevel,
    IN  PCSTR           File,
    IN  ULONG           Line
    )
/*++

Routine Description:

    This asserts the lock is currently held at the appropriate level.

Arguments:

    LockLevel:
        PPL_SIMPLE_READ         - Allows simple examination of the tree.

        PPL_TREEOP_ALLOW_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads can go through however.

        PPL_TREEOP_BLOCK_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads are also blocked.

        PPL_TREEOP_BLOCK_READS_FROM_ALLOW - Switch to PPL_TREEOP_BLOCK_READS
                                            when already in
                                            PPL_TREEOP_BLOCK_READS. Note that
                                            PpDevNodeUnlockTree must be
                                            subsequently called on both to
                                            release.

    File: Name of c-file asserting the lock is held.

    Line: Line number in above c-file.

Return Value:

    None.

--*/
{
    switch(LockLevel) {

        case PPL_SIMPLE_READ:
            ASSERT(ExIsResourceAcquiredSharedLite(&IopDeviceTreeLock));
            break;

        case PPL_TREEOP_ALLOW_READS:
            ASSERT(ExIsResourceAcquiredSharedLite(&IopDeviceTreeLock));
            ASSERT(ExIsResourceAcquiredExclusiveLite(&PiEngineLock));
            break;

        case PPL_TREEOP_BLOCK_READS_FROM_ALLOW:
            //
            // This isn't really a lock level, but this assert-o-matic function
            // is called from Unlock, in which case this level means "drop back
            // to PPL_TREEOP_ALLOW_READS *from* PPL_TREEOP_BLOCK_READS." So...
            //
            // Fall through
            //

        case PPL_TREEOP_BLOCK_READS:
            ASSERT(ExIsResourceAcquiredExclusiveLite(&IopDeviceTreeLock));
            ASSERT(ExIsResourceAcquiredExclusiveLite(&PiEngineLock));
            break;

        default:
            ASSERT(0);
            break;
    }
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\iofileutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IoFileUtil.c

Abstract:

    This module implements various file utility functions for the Io subsystem.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#include "pnpmgrp.h"
#include "IopFileUtil.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IopFileUtilWalkDirectoryTreeTopDown)
#pragma alloc_text(INIT, IopFileUtilWalkDirectoryTreeBottomUp)
#pragma alloc_text(INIT, IopFileUtilWalkDirectoryTreeHelper)
#pragma alloc_text(INIT, IopFileUtilClearAttributes)
#pragma alloc_text(INIT, IopFileUtilRename)
#endif

#define POOLTAG_FILEUTIL ('uFoI')

NTSTATUS
IopFileUtilWalkDirectoryTreeTopDown(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    )
/*++

Routine Description:

    This funcion walks a directory tree *top down*, passing each entry to the
    callback with the below restrictions. Note that the root directory itself
    is not included in the  callback!

Arguments:

    Directory - Supplies the NT Path to the directory to walk. The directory
                should *not* have a slash '\\'.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                          in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

Return Value:

    NTSTATUS - status of the operation.

--*/
{
    PDIRWALK_ENTRY pDirEntry;
    PLIST_ENTRY pListEntry;
    NTSTATUS status;
    UCHAR buffer[1024];
    LIST_ENTRY dirListHead;

    InitializeListHead(&dirListHead);

    //
    // Walk the first directory.
    //
    status = IopFileUtilWalkDirectoryTreeHelper(
        Directory,
        Flags,
        CallbackFunction,
        Context,
        buffer,
        sizeof(buffer),
        &dirListHead
        );

    //
    // Each directory that WalkDirectory finds gets added to the list.
    // process the list until we have no more directories.
    //
    while((!IsListEmpty(&dirListHead)) && NT_SUCCESS(status)) {

        pListEntry = RemoveHeadList(&dirListHead);

        pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

        status = IopFileUtilWalkDirectoryTreeHelper(
            &pDirEntry->Directory,
            Flags,
            CallbackFunction,
            Context,
            buffer,
            sizeof(buffer),
            &dirListHead
            );

        ExFreePool(pDirEntry);
    }

    //
    // If we failed we need to empty out our directory list.
    //
    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&dirListHead)) {

            pListEntry = RemoveHeadList(&dirListHead);

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            ExFreePool(pDirEntry);
        }
    }

    return status;
}


NTSTATUS
IopFileUtilWalkDirectoryTreeBottomUp(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    )
/*++

Routine Description:

    This funcion walks a directory tree *bottom up*, passing each entry to the
    callback with the below restrictions. Note that the root directory itself
    is not included in the callback!

Arguments:

    Directory - Supplies the NT Path to the directory to walk. The directory
        should *not* have a slash trailing '\\'.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

Return Value:

    NTSTATUS - status of the operation.

--*/
{
    PDIRWALK_ENTRY pDirEntry;
    PLIST_ENTRY pListEntry;
    NTSTATUS status;
    UCHAR buffer[1024];
    LIST_ENTRY dirListHead, dirNothingHead;

    InitializeListHead(&dirListHead);
    InitializeListHead(&dirNothingHead);

    //
    // Create an entry for the root directory.
    //
    pDirEntry = (PDIRWALK_ENTRY) ExAllocatePoolWithTag(
        PagedPool,
        sizeof(DIRWALK_ENTRY) + Directory->Length - sizeof(WCHAR),
        POOLTAG_FILEUTIL
        );

    if (pDirEntry == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pDirEntry->Directory.Length = 0;
    pDirEntry->Directory.MaximumLength = Directory->Length;
    pDirEntry->Directory.Buffer = &pDirEntry->Name[0];
    RtlCopyUnicodeString(&pDirEntry->Directory, Directory);

    InsertHeadList(&dirListHead, &pDirEntry->Link);

    //
    // Collect the directory trees. When we are done we will walk the list in
    // reverse.
    //
    status = STATUS_SUCCESS;
    if (Flags & DIRWALK_TRAVERSE) {

        for(pListEntry = &dirListHead;
            pListEntry->Flink != &dirListHead;
            pListEntry = pListEntry->Flink) {

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            status = IopFileUtilWalkDirectoryTreeHelper(
                &pDirEntry->Directory,
                DIRWALK_TRAVERSE,
                NULL,
                NULL,
                buffer,
                sizeof(buffer),
                &dirListHead
                );

            if (!NT_SUCCESS(status)) {

                break;
            }
        }
    }

    //
    // Each directory that WalkDirectory finds gets added to the list.
    // process the list until we have no more directories.
    //
    while((!IsListEmpty(&dirListHead)) && NT_SUCCESS(status)) {

        pListEntry = RemoveTailList(&dirListHead);

        pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

        status = IopFileUtilWalkDirectoryTreeHelper(
            &pDirEntry->Directory,
            Flags & ~DIRWALK_TRAVERSE,
            CallbackFunction,
            Context,
            buffer,
            sizeof(buffer),
            &dirNothingHead
            );

        ExFreePool(pDirEntry);

        ASSERT(IsListEmpty(&dirNothingHead));
    }

    //
    // Now do any final cleanup.
    //
    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&dirListHead)) {

            pListEntry = RemoveHeadList(&dirListHead);

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            ExFreePool(pDirEntry);
        }
    }

    return status;
}


NTSTATUS
IopFileUtilWalkDirectoryTreeHelper(
    IN      PUNICODE_STRING  Directory,
    IN      ULONG            Flags,
    IN      DIRWALK_CALLBACK CallbackFunction,
    IN      PVOID            Context,
    IN      PUCHAR           Buffer,
    IN      ULONG            BufferSize,
    IN OUT  PLIST_ENTRY      DirList
    )
/*++

Routine Description:

    This is a helper function for the IopFileUtilWalkDirectoryTree* functions.

Arguments:

    Directory - Supplies the NT Path to the directory to walk. The directory
                should *not* have a slash trailing '\\'.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    DirList - Recieves list of new directories to scan after completion of this
              directory. Each entry is a member of the DIRECTORY_ENTRY
              structure.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

    Buffer    - A scratch buffer to use.

    BufferSize - The length of Buffer. Must be greater than sizeof(WCHAR).

Return Value:

    NTSTATUS - status of the operation.

--*/
{
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    BOOLEAN bRestartScan, bIsDotPath;
    WCHAR savedChar;
    PFILE_BOTH_DIR_INFORMATION pFileInfo;
    UNICODE_STRING entryName;
    USHORT newNameLength;
    PDIRWALK_ENTRY pDirEntry;
    ULONG OpenFlags;

    //
    // Setup initial values
    //
    bRestartScan = TRUE;

    //
    //  Open the file for list directory access
    //
    if (Flags & DIRWALK_TRAVERSE_MOUNTPOINTS) {

        OpenFlags = FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT;

    } else {

        OpenFlags = FILE_OPEN_REPARSE_POINT |
                    FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        Directory,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
        &fileHandle,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ,
        OpenFlags
        );

    if (!NT_SUCCESS(status)) {

        goto cleanup;
    }

    //
    //  Do the directory loop
    //
    while(1) {

        //
        // We subtract off a WCHAR so that we can append a terminating null as
        // needed.
        //
        ASSERT(BufferSize > sizeof(WCHAR));

        status = ZwQueryDirectoryFile(
            fileHandle,
            (HANDLE)NULL,
            (PIO_APC_ROUTINE)NULL,
            (PVOID)NULL,
            &ioStatus,
            Buffer,
            BufferSize - sizeof(WCHAR),
            FileBothDirectoryInformation,
            FALSE,
            (PUNICODE_STRING)NULL,
            bRestartScan
            );

        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // We may come back here. Make sure the file scan doesn't start back
        // over.
        //
        bRestartScan = FALSE;

        //
        // Wait for the event to complete if neccessary.
        //
        if (status == STATUS_PENDING) {

            ZwWaitForSingleObject(fileHandle, TRUE, NULL);
            status = ioStatus.Status;

            //
            //  Check the Irp for success
            //
            if (!NT_SUCCESS(status)) {

                break;
            }
        }

        //
        // Walk each returned record. Note that we won't be here if there are
        // no records, as ioStatus will have contains STATUS_NO_MORE_FILES.
        //
        pFileInfo = (PFILE_BOTH_DIR_INFORMATION) Buffer;

        while(1) {

            //
            // Temporarily terminate the file. We allocated an extra WCHAR to
            // make sure we could safely do this.
            //
            savedChar = pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)];
            pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)] = 0;

            //
            // Build a full unicode path for the file along with a directory
            // entry at the same time.
            //
            RtlInitUnicodeString(&entryName, pFileInfo->FileName);

            newNameLength =
                (Directory->Length + entryName.Length + sizeof(WCHAR));

            pDirEntry = (PDIRWALK_ENTRY) ExAllocatePoolWithTag(
                PagedPool,
                sizeof(DIRWALK_ENTRY) + newNameLength - sizeof(WCHAR),
                POOLTAG_FILEUTIL
                );

            if (pDirEntry == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            pDirEntry->Directory.Length = 0;
            pDirEntry->Directory.MaximumLength = newNameLength;
            pDirEntry->Directory.Buffer = &pDirEntry->Name[0];
            RtlCopyUnicodeString(&pDirEntry->Directory, Directory);
            RtlAppendUnicodeToString(&pDirEntry->Directory, L"\\");
            RtlAppendUnicodeStringToString(&pDirEntry->Directory, &entryName);

            if (pFileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // Check for . and ..
                //
                if ((!_wcsicmp(pFileInfo->FileName, L".")) ||
                              (!_wcsicmp(pFileInfo->FileName, L".."))) {
                    bIsDotPath = TRUE;
                }
                else {
                    bIsDotPath = FALSE;
                }

                if ((Flags & DIRWALK_INCLUDE_DIRECTORIES) &&
                    ((!(Flags & DIRWALK_CULL_DOTPATHS)) || (!bIsDotPath))) {

                    status = CallbackFunction(
                        &pDirEntry->Directory,
                        &entryName,
                        pFileInfo->FileAttributes,
                        Context
                        );
                }

                if ((!bIsDotPath) && (Flags & DIRWALK_TRAVERSE)) {

                    InsertTailList(DirList, &pDirEntry->Link);

                } else {

                    ExFreePool(pDirEntry);
                }

            } else {

                if (Flags & DIRWALK_INCLUDE_FILES) {

                    status = CallbackFunction(
                        &pDirEntry->Directory,
                        &entryName,
                        pFileInfo->FileAttributes,
                        Context
                        );
                }

                ExFreePool(pDirEntry);
            }

            if (!NT_SUCCESS(status)) {

                break;
            }

            //
            // Put back the character we wrote down. It might have been part of
            // the next entry.
            //
            pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)] = savedChar;

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //
            if (pFileInfo->NextEntryOffset == 0) {

                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //
            pFileInfo = (PFILE_BOTH_DIR_INFORMATION)
                (((PUCHAR) pFileInfo) + pFileInfo->NextEntryOffset);
        }

        if (!NT_SUCCESS(status)) {

            break;
        }
    }

    ZwClose( fileHandle );

    if (status == STATUS_NO_MORE_FILES) {

        status = STATUS_SUCCESS;
    }

cleanup:
    return status;
}


NTSTATUS
IopFileUtilClearAttributes(
    IN PUNICODE_STRING  FullPathName,
    IN ULONG            FileAttributes
    )
/*++

Routine Description:

    This function clears the passed in attributes off the specified file.

Arguments:

    FullPathName - Full path name of the identified file.

    FileAttributes - Attributes to clear.

Return Value:

    NTSTATUS.

--*/
{
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    FILE_BASIC_INFORMATION fileBasicInformation;
    ULONG newAttributes;
    NTSTATUS status;

    //
    // First we open the file.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        FullPathName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
        &fileHandle,
        FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_FOR_BACKUP_INTENT | FILE_WRITE_THROUGH
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Then we get the file attributes.
    //
    status = ZwQueryInformationFile(
        fileHandle,
        &ioStatus,
        &fileBasicInformation,
        sizeof(fileBasicInformation),
        FileBasicInformation
        );

    if (!NT_SUCCESS(status)) {

        ZwClose(fileHandle);
        return status;
    }

    //
    // Anything to do?
    //
    if (fileBasicInformation.FileAttributes & FileAttributes) {

        //
        // Clear the specified bits.
        //
        newAttributes = fileBasicInformation.FileAttributes;
        newAttributes &= ~FileAttributes;
        if (newAttributes == 0) {

            newAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        //
        // Zero fields that shouldn't be touched.
        //
        RtlZeroMemory(
            &fileBasicInformation,
            sizeof(FILE_BASIC_INFORMATION)
            );

        fileBasicInformation.FileAttributes = newAttributes;

        //
        // Commit the changes.
        //
        status = ZwSetInformationFile(
            fileHandle,
            &ioStatus,
            &fileBasicInformation,
            sizeof(fileBasicInformation),
            FileBasicInformation
            );
    }

    ZwClose(fileHandle);
    return status;
}


NTSTATUS
IopFileUtilRename(
    IN PUNICODE_STRING  SourcePathName,
    IN PUNICODE_STRING  DestinationPathName,
    IN BOOLEAN          ReplaceIfPresent
    )
/*++

Routine Description:

    This function renames or moves a file or directory.

Arguments:

    SourcePathName - Full path name of the file or directory to rename.

    DestinationPathName - Future full path name of the file or directory.

    ReplaceIfPresent - If true, NewPathName is deleted if already present.

Return Value:

    NTSTATUS.

--*/
{
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    PFILE_RENAME_INFORMATION pNewName;
    NTSTATUS status;

    pNewName = ExAllocatePoolWithTag(
        PagedPool,
        sizeof(FILE_RENAME_INFORMATION) + DestinationPathName->Length,
        POOLTAG_FILEUTIL
        );

    if (pNewName == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we may be replacing the file, we first need to clear the read only
    // attributes.
    //
    if (ReplaceIfPresent) {

        //
        // Errors are ignored as the file may not exist.
        //
        IopFileUtilClearAttributes(
            DestinationPathName,
            ( FILE_ATTRIBUTE_READONLY |
              FILE_ATTRIBUTE_HIDDEN |
              FILE_ATTRIBUTE_SYSTEM )
            );
    }

    InitializeObjectAttributes(
        &objectAttributes,
        SourcePathName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
        &fileHandle,
        FILE_READ_ATTRIBUTES | DELETE | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_FOR_BACKUP_INTENT | FILE_WRITE_THROUGH
        );

    if (!NT_SUCCESS(status)) {

        ExFreePool(pNewName);
        return status;
    }

    //
    // Change \\SystemRoot\LastGood\Blah... to \\SystemRoot\Blah...
    //
    RtlCopyMemory(
        pNewName->FileName,
        DestinationPathName->Buffer,
        DestinationPathName->Length
        );

    pNewName->ReplaceIfExists = ReplaceIfPresent;
    pNewName->RootDirectory = NULL;
    pNewName->FileNameLength = DestinationPathName->Length;

    status = ZwSetInformationFile(
        fileHandle,
        &ioStatus,
        pNewName,
        pNewName->FileNameLength + sizeof(FILE_RENAME_INFORMATION),
        FileRenameInformation
        );

    ExFreePool(pNewName);
    ZwClose(fileHandle);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\devintrf.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    devintrf.c

Abstract:

    This module contains APIs and routines for handling Device Interfaces.

Author:


Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Guid related definitions
//

#define GUID_STRING_LENGTH  38
#define GUID_STRING_SIZE    GUID_STRING_LENGTH * sizeof(WCHAR)

//
// Definitions for IoGetDeviceInterfaces
//

#define INITIAL_INFO_BUFFER_SIZE         512
#define INFO_BUFFER_GROW_SIZE            64
#define INITIAL_SYMLINK_BUFFER_SIZE      1024
#define SYMLINK_BUFFER_GROW_SIZE         128
#define INITIAL_RETURN_BUFFER_SIZE       4096
#define RETURN_BUFFER_GROW_SIZE          512

//
// This should never have to grow, since it accomodates the maximum length of a
// device instance name.
//
#define INITIAL_DEVNODE_NAME_BUFFER_SIZE   (FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + (MAX_DEVICE_ID_LEN * sizeof(WCHAR)))

//
// Definitions for IoOpenDeviceInterfaceRegistryKey
//

#define KEY_STRING_PREFIX                  TEXT("##?#")

//
// Definitions for IoRegisterDeviceInterface
//

#define SEPERATOR_STRING                   TEXT("\\")
#define SEPERATOR_CHAR                     (L'\\')
#define ALT_SEPERATOR_CHAR                 (L'/')
#define REPLACED_SEPERATOR_STRING          TEXT("#")
#define REPLACED_SEPERATOR_CHAR            (L'#')
#define USER_SYMLINK_STRING_PREFIX         TEXT("\\\\?\\")
#define KERNEL_SYMLINK_STRING_PREFIX       TEXT("\\??\\")
#define GLOBAL_SYMLINK_STRING_PREFIX       TEXT("\\GLOBAL??\\")
#define REFSTRING_PREFIX_CHAR              (L'#')

//
// Prototypes
//

NTSTATUS
IopAppendBuffer(
    IN PBUFFER_INFO Info,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
IopOverwriteBuffer(
    IN PBUFFER_INFO Info,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
IopRealloc(
    IN OUT PVOID *Buffer,
    IN ULONG OldSize,
    IN ULONG NewSize
    );

NTSTATUS
IopBuildSymbolicLinkStrings(
    IN PUNICODE_STRING DeviceString,
    IN PUNICODE_STRING GuidString,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    OUT PUNICODE_STRING UserString,
    OUT PUNICODE_STRING KernelString
    );

NTSTATUS
IopBuildGlobalSymbolicLinkString(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING GlobalString
    );

NTSTATUS
IopDeviceInterfaceKeysFromSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceClassKey     OPTIONAL,
    OUT PHANDLE DeviceInterfaceKey          OPTIONAL,
    OUT PHANDLE DeviceInterfaceInstanceKey  OPTIONAL
    );

NTSTATUS
IopDropReferenceString(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
IopOpenOrCreateDeviceInterfaceSubKeys(
    OUT PHANDLE InterfaceKeyHandle           OPTIONAL,
    OUT PULONG InterfaceKeyDisposition       OPTIONAL,
    OUT PHANDLE InterfaceInstanceKeyHandle   OPTIONAL,
    OUT PULONG InterfaceInstanceDisposition  OPTIONAL,
    IN HANDLE InterfaceClassKeyHandle,
    IN PUNICODE_STRING DeviceInterfaceName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

NTSTATUS
IopParseSymbolicLinkName(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING PrefixString        OPTIONAL,
    OUT PUNICODE_STRING MungedPathString    OPTIONAL,
    OUT PUNICODE_STRING GuidString          OPTIONAL,
    OUT PUNICODE_STRING RefString           OPTIONAL,
    OUT PBOOLEAN        RefStringPresent    OPTIONAL,
    OUT LPGUID Guid                         OPTIONAL
    );

NTSTATUS
IopReplaceSeperatorWithPound(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
IopSetRegistryStringValue(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN PUNICODE_STRING ValueData
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoGetDeviceInterfaceAlias)
#pragma alloc_text(PAGE, IoGetDeviceInterfaces)
#pragma alloc_text(PAGE, IoOpenDeviceInterfaceRegistryKey)
#pragma alloc_text(PAGE, IoRegisterDeviceInterface)
#pragma alloc_text(PAGE, IoSetDeviceInterfaceState)

#pragma alloc_text(PAGE, IopAllocateBuffer)
#pragma alloc_text(PAGE, IopAllocateUnicodeString)
#pragma alloc_text(PAGE, IopAppendBuffer)
#pragma alloc_text(PAGE, IopBuildSymbolicLinkStrings)
#pragma alloc_text(PAGE, IopBuildGlobalSymbolicLinkString)
#pragma alloc_text(PAGE, IopDeviceInterfaceKeysFromSymbolicLink)
#pragma alloc_text(PAGE, IopDropReferenceString)
#pragma alloc_text(PAGE, IopFreeAllocatedUnicodeString)
#pragma alloc_text(PAGE, IopFreeBuffer)
#pragma alloc_text(PAGE, IopGetDeviceInterfaces)
#pragma alloc_text(PAGE, IopOpenOrCreateDeviceInterfaceSubKeys)
#pragma alloc_text(PAGE, IopOverwriteBuffer)
#pragma alloc_text(PAGE, IopParseSymbolicLinkName)
#pragma alloc_text(PAGE, IopProcessSetInterfaceState)
#pragma alloc_text(PAGE, IopRealloc)
#pragma alloc_text(PAGE, IopRegisterDeviceInterface)
#pragma alloc_text(PAGE, IopRemoveDeviceInterfaces)
#pragma alloc_text(PAGE, IopDisableDeviceInterfaces)
#pragma alloc_text(PAGE, IopReplaceSeperatorWithPound)
#pragma alloc_text(PAGE, IopResizeBuffer)
#pragma alloc_text(PAGE, IopSetRegistryStringValue)
#pragma alloc_text(PAGE, IopUnregisterDeviceInterface)
#endif // ALLOC_PRAGMA



NTSTATUS
IopAllocateBuffer(
    IN PBUFFER_INFO Info,
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates a buffer of Size bytes and initialises the BUFFER_INFO
    structure so the current position is at the start of the buffer.

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the new
           buffer

    Size - The number of bytes to be allocated for the buffer

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    ASSERT(Info);

    Info->Buffer = ExAllocatePool(PagedPool, Size);
    if (Info->Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Info->Current = Info->Buffer;
    Info->MaxSize = Size;

    return STATUS_SUCCESS;
}


NTSTATUS
IopResizeBuffer(
    IN PBUFFER_INFO Info,
    IN ULONG NewSize,
    IN BOOLEAN CopyContents
    )

/*++

Routine Description:

    Allocates a new buffer of NewSize bytes and associates it with Info, freeing the
    old buffer.  It will optionally copy the data stored in the old buffer into the
    new buffer and update the current position.

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the buffer

    NewSize - The new size of the buffer in bytes

    CopyContents - If TRUE indicates that the contents of the old buffer should be
                   copied to the new buffer

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    ULONG used;
    PCHAR newBuffer;

    ASSERT(Info);

    used = (ULONG)(Info->Current - Info->Buffer);

    newBuffer = ExAllocatePool(PagedPool, NewSize);
    if (newBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (CopyContents) {

        //
        // Assert there is room in the buffer
        //

        ASSERT(used < NewSize);

        RtlCopyMemory(newBuffer,
                      Info->Buffer,
                      used);

        Info->Current = newBuffer + used;

    } else {

        Info->Current = newBuffer;
    }

    ExFreePool(Info->Buffer);

    Info->Buffer = newBuffer;
    Info->MaxSize = NewSize;

    return STATUS_SUCCESS;
}

VOID
IopFreeBuffer(
    IN PBUFFER_INFO Info
    )

/*++

Routine Description:

    Frees the buffer associated with Info and resets all Info fields

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the buffer

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    ASSERT(Info);

    //
    // Free the buffer
    //

    ExFreePool(Info->Buffer);

    //
    // Zero out the info parameters so we can't accidently used the free buffer
    //

    Info->Buffer = NULL;
    Info->Current = NULL;
    Info->MaxSize = 0;
}

NTSTATUS
IopAppendBuffer(
    IN PBUFFER_INFO Info,
    IN PVOID Data,
    IN ULONG DataSize
    )

/*++

Routine Description:

    Copies the data to the end of the buffer, resizing if necessary.  The current
    position is set to the end of the data just added.

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the buffer

    Data - Pointer to the data to be added to the buffer

    DataSize - The size of the data pointed to by Data in bytes

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    ULONG free, used;

    ASSERT(Info);

    used = (ULONG)(Info->Current - Info->Buffer);
    free = Info->MaxSize - used;

    if (free < DataSize) {
        status = IopResizeBuffer(Info, used + DataSize, TRUE);

        if (!NT_SUCCESS(status)) {
            goto clean0;
        }

    }

    //
    // Copy the data into the buffer
    //

    RtlCopyMemory(Info->Current,
                  Data,
                  DataSize);

    //
    // Advance down the buffer
    //

    Info->Current += DataSize;

clean0:
    return status;

}

NTSTATUS
IopOverwriteBuffer(
    IN PBUFFER_INFO Info,
    IN PVOID Data,
    IN ULONG DataSize
    )

/*++

Routine Description:

    Copies data into the buffer, overwriting what is currently present,
    resising if necessary.  The current position is set to the end of the
    data just added.

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the buffer

    Data - Pointer to the data to be added to the buffer

    DataSize - The size of the data pointed to by Data in bytes

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG free;

    ASSERT(Info);

    free = Info->MaxSize;


    if (free < DataSize) {
        status = IopResizeBuffer(Info, DataSize, FALSE);

        if (!NT_SUCCESS(status)) {
            goto clean0;
        }

    }

    //
    // Copy the data into the buffer
    //

    RtlCopyMemory(Info->Buffer,
                  Data,
                  DataSize);

    //
    // Advance down the buffer
    //

    Info->Current += DataSize;

clean0:
    return status;
}


NTSTATUS
IopGetDeviceInterfaces(
        IN CONST GUID *InterfaceClassGuid,
        IN PUNICODE_STRING DevicePath   OPTIONAL,
        IN ULONG Flags,
        IN BOOLEAN UserModeFormat,
        OUT PWSTR *SymbolicLinkList,
        OUT PULONG SymbolicLinkListSize OPTIONAL
        )

/*++

Routine Description:

    This API allows a WDM driver to get a list of paths that represent all
    devices registered for the specified interface class.

Parameters:

    InterfaceClassGuid - Supplies a pointer to a GUID representing the interface class
        for whom a list of members is to be retrieved

    DevicePath - Optionally, supplies a pointer to a unicode string containing the
        enumeration path for a device for whom interfaces of the specified class are
        to be re-trieved.  If this parameter  is not supplied, then all interface
        devices (regardless of what physical device exposes them) will be returned.

    Flags - Supplies flags that modify the behavior of list retrieval.
        The following flags are presently defined:

        DEVICE_INTERFACE_INCLUDE_NONACTIVE -- If this flag is specified, then all
            interface devices, whether currently active or not, will be returned
            (potentially filtered based on the Physi-calDeviceObject, if specified).

    UserModeFormat - If TRUE the multi-sz returned will have user mode prefixes
        (\\?\) otherwise they will have kernel mode prefixes (\??\).

    SymbolicLinkList - Supplies the address of a character pointer, that on
        success will contain a multi-sz list of \??\ symbolic link
        names that provide the requested functionality.  The caller is
        responsible for freeing the memory via ExFreePool.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING guidString, tempString, defaultString, symLinkString, devnodeString;
    BUFFER_INFO returnBuffer, infoBuffer, symLinkBuffer, devnodeNameBuffer;
    PKEY_VALUE_FULL_INFORMATION pDefaultInfo;
    ULONG keyIndex, instanceKeyIndex, resultSize;
    HANDLE hDeviceClasses, hClass, hKey, hInstanceKey, hControl;
    BOOLEAN defaultPresent = FALSE;

    PAGED_CODE();

    //
    // Initialise out parameters
    //

    *SymbolicLinkList = NULL;

    //
    // Convert the GUID into a string
    //

    status = RtlStringFromGUID(InterfaceClassGuid, &guidString);
    if (!NT_SUCCESS(status)) {
        goto finalClean;
    }

    //
    // Allocate initial buffers
    //

    status = IopAllocateBuffer(&returnBuffer,
                               INITIAL_RETURN_BUFFER_SIZE
                               );

    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    status = IopAllocateBuffer(&infoBuffer,
                               INITIAL_INFO_BUFFER_SIZE
                               );

    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    status = IopAllocateBuffer(&symLinkBuffer,
                               INITIAL_SYMLINK_BUFFER_SIZE
                               );

    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    status = IopAllocateBuffer(&devnodeNameBuffer,
                               INITIAL_DEVNODE_NAME_BUFFER_SIZE
                               );

    if (!NT_SUCCESS(status)) {
        goto clean2a;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //

    PiLockPnpRegistry(TRUE);

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses key
    //

    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopCreateRegistryKeyEx( &hDeviceClasses,
                                     NULL,
                                     &tempString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Open function class GUID key
    //

    status = IopOpenRegistryKeyEx( &hClass,
                                   hDeviceClasses,
                                   &guidString,
                                   KEY_ALL_ACCESS
                                   );
    ZwClose(hDeviceClasses);

    if(status == STATUS_OBJECT_NAME_NOT_FOUND || status == STATUS_OBJECT_PATH_NOT_FOUND) {

        //
        // The path does not exist - return a single null character buffer
        //

        status = STATUS_SUCCESS;
        goto clean5;
    } else if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Get the default value if it exists
    //

    status = IopGetRegistryValue(hClass,
                                 REGSTR_VAL_DEFAULT,
                                 &pDefaultInfo
                                 );


    if (NT_SUCCESS(status)
        && pDefaultInfo->Type == REG_SZ
        && pDefaultInfo->DataLength >= sizeof(WCHAR)) {

        //
        // We have a default - construct a counted string from the default
        //

        defaultPresent = TRUE;
        defaultString.Buffer = (PWSTR) KEY_VALUE_DATA(pDefaultInfo);
        defaultString.Length = (USHORT) pDefaultInfo->DataLength - sizeof(UNICODE_NULL);
        defaultString.MaximumLength = defaultString.Length;

        //
        // Open the device interface instance key for the default name.
        //
        status = IopOpenOrCreateDeviceInterfaceSubKeys(NULL,
                                                       NULL,
                                                       &hKey,
                                                       NULL,
                                                       hClass,
                                                       &defaultString,
                                                       KEY_READ,
                                                       FALSE
                                                      );

        if (!NT_SUCCESS(status)) {
            defaultPresent = FALSE;
            ExFreePool(pDefaultInfo);
            //
            // Continue with the call but ignore the invalid default entry
            //
        } else {

            //
            // If we are just supposed to return live interfaces, then make sure this default
            // interface is linked.
            //

            if (!(Flags & DEVICE_INTERFACE_INCLUDE_NONACTIVE)) {

                defaultPresent = FALSE;

                //
                // Open the control subkey
                //

                PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
                status = IopOpenRegistryKeyEx( &hControl,
                                               hKey,
                                               &tempString,
                                               KEY_ALL_ACCESS
                                               );

                if (NT_SUCCESS(status)) {
                    //
                    // Get the linked value
                    //

                    PiWstrToUnicodeString(&tempString, REGSTR_VAL_LINKED);
                    ASSERT(infoBuffer.MaxSize >= sizeof(KEY_VALUE_PARTIAL_INFORMATION));
                    status = ZwQueryValueKey(hControl,
                                             &tempString,
                                             KeyValuePartialInformation,
                                             (PVOID) infoBuffer.Buffer,
                                             infoBuffer.MaxSize,
                                             &resultSize
                                             );

                    //
                    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
                    // was not enough room for even the fixed portions of the structure.
                    //
                    ASSERT(status != STATUS_BUFFER_TOO_SMALL);

                    ZwClose(hControl);

                    //
                    // We don't need to check the buffer was big enough because it starts
                    // off that way and doesn't get any smaller!
                    //

                    if (NT_SUCCESS(status)
                        && (((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->Type == REG_DWORD)
                        && (((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->DataLength == sizeof(ULONG))) {

                        defaultPresent = *(PULONG)(((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->Data)
                                       ? TRUE
                                       : FALSE;
                    }
                }
            }

            ZwClose(hKey);

            if(defaultPresent) {
                //
                // Add the default as the first entry in the return buffer and patch to usermode if necessary
                //
                status = IopAppendBuffer(&returnBuffer,
                                         defaultString.Buffer,
                                         defaultString.Length + sizeof(UNICODE_NULL)
                                        );

                if (!UserModeFormat) {

                    RtlCopyMemory(returnBuffer.Buffer,
                                  KERNEL_SYMLINK_STRING_PREFIX,
                                  IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX)
                                  );
                }

            } else {
                //
                // The default device interface isn't active--free the memory for the name buffer now.
                //
                ExFreePool(pDefaultInfo);
            }
        }

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND || status == STATUS_OBJECT_PATH_NOT_FOUND) {
        //
        // Do nothing - there is no default
        //
    } else {
        //
        // An unexpected error occured - clean up
        //
        if (NT_SUCCESS(status)) {

            ExFreePool(pDefaultInfo);
            status = STATUS_UNSUCCESSFUL;
        }

        ZwClose(hClass);
        goto clean4;
    }

    //
    // Iterate through the subkeys under this interface class key.
    //
    keyIndex = 0;
    ASSERT(infoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
    while((status = ZwEnumerateKey(hClass,
                                   keyIndex,
                                   KeyBasicInformation,
                                   (PVOID) infoBuffer.Buffer,
                                   infoBuffer.MaxSize,
                                   &resultSize
                                   )) != STATUS_NO_MORE_ENTRIES) {

        //
        // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
        // was not enough room for even the fixed portions of the structure.
        //
        ASSERT(status != STATUS_BUFFER_TOO_SMALL);

        if (status == STATUS_BUFFER_OVERFLOW) {
            status = IopResizeBuffer(&infoBuffer, resultSize, FALSE);
            continue;
        } else if (!NT_SUCCESS(status)) {
            ZwClose(hClass);
            goto clean4;
        }

        //
        // Open up this interface key.
        //
        tempString.Length = (USHORT) ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->NameLength;
        tempString.MaximumLength = tempString.Length;
        tempString.Buffer = ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->Name;

        //
        // Open the associated key
        //

        status = IopOpenRegistryKeyEx( &hKey,
                                       hClass,
                                       &tempString,
                                       KEY_READ
                                       );

        if (!NT_SUCCESS(status)) {
            //
            // For some reason we couldn't open this key--skip it and move on.
            //
            keyIndex++;
            continue;
        }

        //
        // If we're filtering on a particular PDO, then retrieve the owning device
        // instance name for this interface key, and make sure they match.
        //
        PiWstrToUnicodeString(&tempString, REGSTR_VAL_DEVICE_INSTANCE);
        ASSERT(devnodeNameBuffer.MaxSize >= sizeof(KEY_VALUE_PARTIAL_INFORMATION));
        while ((status = ZwQueryValueKey(hKey,
                                         &tempString,
                                         KeyValuePartialInformation,
                                         devnodeNameBuffer.Buffer,
                                         devnodeNameBuffer.MaxSize,
                                         &resultSize
                                         )) == STATUS_BUFFER_OVERFLOW) {

            status = IopResizeBuffer(&devnodeNameBuffer, resultSize, FALSE);

            if (!NT_SUCCESS(status)) {
                ZwClose(hKey);
                ZwClose(hClass);
                goto clean4;
            }
        }

        //
        // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
        // was not enough room for even the fixed portions of the structure.
        //
        ASSERT(status != STATUS_BUFFER_TOO_SMALL);

        if (!(NT_SUCCESS(status)
              && ((PKEY_VALUE_PARTIAL_INFORMATION)(devnodeNameBuffer.Buffer))->Type == REG_SZ
              && ((PKEY_VALUE_PARTIAL_INFORMATION)(devnodeNameBuffer.Buffer))->DataLength > sizeof(WCHAR))) {
            goto CloseInterfaceKeyAndContinue;
        }

        //
        // Build counted string
        //

        devnodeString.Length = (USHORT) ((PKEY_VALUE_PARTIAL_INFORMATION)(devnodeNameBuffer.Buffer))->DataLength - sizeof(UNICODE_NULL);
        devnodeString.MaximumLength = tempString.Length;
        devnodeString.Buffer = (PWSTR) ((PKEY_VALUE_PARTIAL_INFORMATION)(devnodeNameBuffer.Buffer))->Data;

        //
        // Enumerate each interface instance subkey under this PDO's interface key.
        //
        instanceKeyIndex = 0;
        ASSERT(infoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
        while((status = ZwEnumerateKey(hKey,
                                       instanceKeyIndex,
                                       KeyBasicInformation,
                                       (PVOID) infoBuffer.Buffer,
                                       infoBuffer.MaxSize,
                                       &resultSize
                                       )) != STATUS_NO_MORE_ENTRIES) {

            //
            // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
            // was not enough room for even the fixed portions of the structure.
            //
            ASSERT(status != STATUS_BUFFER_TOO_SMALL);

            if (status == STATUS_BUFFER_OVERFLOW) {
                status = IopResizeBuffer(&infoBuffer, resultSize, FALSE);
                continue;
            } else if (!NT_SUCCESS(status)) {
                ZwClose(hKey);
                ZwClose(hClass);
                goto clean4;
            }

            //
            // Open up this interface instance key.
            //
            tempString.Length = (USHORT) ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->NameLength;
            tempString.MaximumLength = tempString.Length;
            tempString.Buffer = ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->Name;

            //
            // Open the associated key
            //

            status = IopOpenRegistryKeyEx( &hInstanceKey,
                                           hKey,
                                           &tempString,
                                           KEY_READ
                                           );

            if (!NT_SUCCESS(status)) {
                //
                // For some reason we couldn't open this key--skip it and move on.
                //
                instanceKeyIndex++;
                continue;
            }

            if (!(Flags & DEVICE_INTERFACE_INCLUDE_NONACTIVE)) {

                //
                // Open the control subkey
                //

                PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
                status = IopOpenRegistryKeyEx( &hControl,
                                               hInstanceKey,
                                               &tempString,
                                               KEY_READ
                                               );

                if (!NT_SUCCESS(status)) {

                    //
                    // We have no control subkey so can't be linked -
                    // continue enumerating the keys ignoring this one
                    //
                    goto CloseInterfaceInstanceKeyAndContinue;
                }

                //
                // Get the linked value
                //

                PiWstrToUnicodeString(&tempString, REGSTR_VAL_LINKED);
                ASSERT(infoBuffer.MaxSize >= sizeof(KEY_VALUE_PARTIAL_INFORMATION));
                status = ZwQueryValueKey(hControl,
                                         &tempString,
                                         KeyValuePartialInformation,
                                         (PVOID) infoBuffer.Buffer,
                                         infoBuffer.MaxSize,
                                         &resultSize
                                         );

                //
                // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
                // was not enough room for even the fixed portions of the structure.
                //
                ASSERT(status != STATUS_BUFFER_TOO_SMALL);

                ZwClose(hControl);

                //
                // We don't need to check the buffer was big enough because it starts
                // off that way and doesn't get any smaller!
                //

                if (!NT_SUCCESS(status)
                    || (((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->Type != REG_DWORD)
                    || (((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->DataLength != sizeof(ULONG))
                    || !*(PULONG)(((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->Data)) {

                    //
                    // We are NOT linked so continue enumerating the keys ignoring this one
                    //
                    goto CloseInterfaceInstanceKeyAndContinue;
                }
            }

            //
            // Open the "SymbolicLink" value and place the information into the symLink buffer
            //

            PiWstrToUnicodeString(&tempString, REGSTR_VAL_SYMBOLIC_LINK);
            ASSERT(symLinkBuffer.MaxSize >= sizeof(KEY_VALUE_PARTIAL_INFORMATION));
            while ((status = ZwQueryValueKey(hInstanceKey,
                                             &tempString,
                                             KeyValuePartialInformation,
                                             symLinkBuffer.Buffer,
                                             symLinkBuffer.MaxSize,
                                             &resultSize
                                             )) == STATUS_BUFFER_OVERFLOW) {

                status = IopResizeBuffer(&symLinkBuffer, resultSize, FALSE);

                if (!NT_SUCCESS(status)) {
                    ZwClose(hInstanceKey);
                    ZwClose(hKey);
                    ZwClose(hClass);
                    goto clean4;
                }
            }

            //
            // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
            // was not enough room for even the fixed portions of the structure.
            //
            ASSERT(status != STATUS_BUFFER_TOO_SMALL);

            if (!(NT_SUCCESS(status)
                && ((PKEY_VALUE_PARTIAL_INFORMATION)(symLinkBuffer.Buffer))->Type == REG_SZ
                && ((PKEY_VALUE_PARTIAL_INFORMATION)(symLinkBuffer.Buffer))->DataLength > sizeof(WCHAR))) {
                goto CloseInterfaceInstanceKeyAndContinue;
            }

            //
            // Build counted string from value data
            //

            symLinkString.Length = (USHORT) ((PKEY_VALUE_PARTIAL_INFORMATION)(symLinkBuffer.Buffer))->DataLength - sizeof(UNICODE_NULL);
            symLinkString.MaximumLength = symLinkString.Length;
            symLinkString.Buffer = (PWSTR) ((PKEY_VALUE_PARTIAL_INFORMATION)(symLinkBuffer.Buffer))->Data;

            //
            // If we have a default, check this is not it
            //

            if (defaultPresent) {

                if (RtlCompareUnicodeString(&defaultString, &symLinkString, TRUE) == 0) {

                    //
                    // We have already added the default to the beginning of the buffer so skip it
                    //
                    goto CloseInterfaceInstanceKeyAndContinue;
                }
            }

            //
            // If we are only returning interfaces for a particular PDO then check
            // this is from that PDO
            //
            if (ARGUMENT_PRESENT(DevicePath)) {
                //
                // Check if it is from the same PDO
                //
                if (RtlCompareUnicodeString(DevicePath, &devnodeString, TRUE) != 0) {
                    //
                    // If not then go onto the next key
                    //
                    goto CloseInterfaceInstanceKeyAndContinue;
                }
            }

            //
            // Copy the symLink string to the return buffer including the NULL termination
            //

            status = IopAppendBuffer(&returnBuffer,
                                     symLinkString.Buffer,
                                     symLinkString.Length + sizeof(UNICODE_NULL)
                                     );

            ASSERT(((PWSTR) returnBuffer.Current)[-1] == UNICODE_NULL);

            //
            // If we are returning KM strings then patch the prefix
            //

            if (!UserModeFormat) {

                RtlCopyMemory(returnBuffer.Current - (symLinkString.Length + sizeof(UNICODE_NULL)),
                              KERNEL_SYMLINK_STRING_PREFIX,
                              IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX)
                              );
            }

CloseInterfaceInstanceKeyAndContinue:
            ZwClose(hInstanceKey);
            instanceKeyIndex++;
        }

CloseInterfaceKeyAndContinue:
        ZwClose(hKey);
        keyIndex++;
    }

    ZwClose(hClass);

clean5:
    //
    // We've got then all!  Resize to leave space for a terminating NULL.
    //

    status = IopResizeBuffer(&returnBuffer,
                             (ULONG) (returnBuffer.Current - returnBuffer.Buffer + sizeof(UNICODE_NULL)),
                             TRUE
                             );

    if (NT_SUCCESS(status)) {

        //
        // Terminate the buffer
        //
        *((PWSTR) returnBuffer.Current) = UNICODE_NULL;
    }

clean4:
    if (defaultPresent) {
        ExFreePool(pDefaultInfo);
    }

clean3:
    PiUnlockPnpRegistry();
    IopFreeBuffer(&devnodeNameBuffer);

clean2a:
    IopFreeBuffer(&symLinkBuffer);

clean2:
    IopFreeBuffer(&infoBuffer);

clean1:
    if (!NT_SUCCESS(status)) {
        IopFreeBuffer(&returnBuffer);
    }

clean0:
    RtlFreeUnicodeString(&guidString);

finalClean:
    if (NT_SUCCESS(status)) {

        *SymbolicLinkList = (PWSTR) returnBuffer.Buffer;

        if (ARGUMENT_PRESENT(SymbolicLinkListSize)) {
            *SymbolicLinkListSize = returnBuffer.MaxSize;
        }

    } else {

        *SymbolicLinkList = NULL;

        if (ARGUMENT_PRESENT(SymbolicLinkListSize)) {
            *SymbolicLinkListSize = 0;
        }

    }

    return status;
}

NTSTATUS
IoGetDeviceInterfaces(
    IN CONST GUID *InterfaceClassGuid,
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN ULONG Flags,
    OUT PWSTR *SymbolicLinkList
    )

/*++

Routine Description:

    This API allows a WDM driver to get a list of paths that represent all
    device interfaces registered for the specified interface class.

Parameters:

    InterfaceClassGuid - Supplies a pointer to a GUID representing the interface class
        for whom a list of members is to be retrieved

    PhysicalDeviceObject - Optionally, supplies a pointer to the PDO for whom
        interfaces of the specified class are to be re-trieved.  If this parameter
        is not supplied, then all interface devices (regardless of what physical
        device exposes them) will be returned.

    Flags - Supplies flags that modify the behavior of list retrieval.
        The following flags are presently defined:

        DEVICE_INTERFACE_INCLUDE_NONACTIVE -- If this flag is specified, then all
            device interfaces, whether currently active or not, will be returned
            (potentially filtered based on the PhysicalDeviceObject, if specified).

    SymbolicLinkList - Supplies the address of a character pointer, that on
        success will contain a multi-sz list of \DosDevices\ symbolic link
        names that provide the requested functionality.  The caller is
        responsible for freeing the memory via ExFreePool

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    PUNICODE_STRING pDeviceName = NULL;
    PDEVICE_NODE pDeviceNode;

    PAGED_CODE();

    //
    // Check we have a PDO and if so extract the instance path from it
    //

    if (ARGUMENT_PRESENT(PhysicalDeviceObject)) {

        ASSERT_PDO(PhysicalDeviceObject);
        pDeviceNode = (PDEVICE_NODE) PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;
        pDeviceName = &pDeviceNode->InstancePath;
    }

    status = IopGetDeviceInterfaces(InterfaceClassGuid,
                                    pDeviceName,
                                    Flags,
                                    FALSE,
                                    SymbolicLinkList,
                                    NULL
                                    );
    return status;
}


NTSTATUS
IopRealloc(
    IN OUT PVOID *Buffer,
    IN ULONG OldSize,
    IN ULONG NewSize
)

/*++

Routine Description:

    This implements a variation of the traditional C realloc routine.

Parameters:

    Buffer - Supplies a pointer to a pointer to the buffer that is being
        reallocated.  On sucessful completion it the pointer will be updated
        to point to the new buffer, on failure it will still point to the old
        buffer.

    OldSize - The size in bytes of the memory block referenced by Buffer

    NewSize - The desired new size in bytes of the buffer.  This can be larger
        or smaller than the OldSize

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{

    PVOID newBuffer;

    PAGED_CODE();

    ASSERT(*Buffer);

    //
    // Allocate a new buffer
    //

    newBuffer = ExAllocatePool(PagedPool, NewSize);
    if (newBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the contents of the old buffer
    //

    if(OldSize <= NewSize) {
        RtlCopyMemory(newBuffer, *Buffer , OldSize);
    } else {
        RtlCopyMemory(newBuffer, *Buffer , NewSize);
    }
    //
    // Free up the old buffer
    //

    ExFreePool(*Buffer);

    //
    // Hand the new buffer back to the caller
    //

    *Buffer = newBuffer;

    return STATUS_SUCCESS;

}

NTSTATUS
IoSetDeviceInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This DDI allows a device class to activate and deactivate an association
    previously registered using IoRegisterDeviceInterface

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name which was
        returned by IoRegisterDeviceInterface when the interface was registered,
        or as returned by IoGetDeviceInterfaces.

    Enable - If TRUE (non-zero), the interface will be enabled.  If FALSE, it
        will be disabled.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //

    PiLockPnpRegistry(TRUE);
    status = IopProcessSetInterfaceState(SymbolicLinkName, Enable, TRUE);

    PiUnlockPnpRegistry();

    if (!NT_SUCCESS(status) && !Enable) {
        //
        // If we failed to disable an interface (most likely because the
        // interface keys have already been deleted) report success.
        //
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
IoOpenDeviceInterfaceRegistryKey(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceKey
    )

/*++

Routine Description:

    This routine will open the registry key where the data associated with a
    specific device interface can be stored.

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name which was
        returned by IoRegisterDeviceInterface when the device class was registered.

    DesiredAccess - Supplies the access privileges to the key the caller wants.

    DeviceInterfaceKey - Supplies a pointer to a handle which on success will
        contain the handle to the requested registry key.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    HANDLE hKey;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //

    PiLockPnpRegistry(TRUE);
    //
    // Open the interface device key
    //

    status = IopDeviceInterfaceKeysFromSymbolicLink(SymbolicLinkName,
                                                    KEY_READ,
                                                    NULL,
                                                    NULL,
                                                    &hKey
                                                    );
    if(!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Open the "Device Parameters" subkey.
    //

    PiWstrToUnicodeString(&unicodeString, REGSTR_KEY_DEVICEPARAMETERS);
    status = IopCreateRegistryKeyEx( DeviceInterfaceKey,
                                     hKey,
                                     &unicodeString,
                                     DesiredAccess,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );
    ZwClose(hKey);

clean0:
    PiUnlockPnpRegistry();

    return status;
}

NTSTATUS
IopDeviceInterfaceKeysFromSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceClassKey    OPTIONAL,
    OUT PHANDLE DeviceInterfaceKey         OPTIONAL,
    OUT PHANDLE DeviceInterfaceInstanceKey OPTIONAL
    )

/*++

Routine Description:

    This routine will open the registry key where the data associated with the
    device pointed to by SymbolicLinkName is stored.  If the path does not exist
    it will not be created.

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name.

    DesiredAccess - Supplies the access privto the function class instance key the
        caller wants.

    DeviceInterfaceClassKey - Optionally, supplies the address of a variable that
        receives a handle to the device class key for the interface.

    DeviceInterfaceKey - Optionally, supplies the address of a variable that receives
        a handle to the device interface (parent) key.

    DeviceInterfaceInstanceKey - Optionally, Supplies the address of a variable that
        receives a handle to the device interface instance key (i.e., the
        refstring-specific one).

Return Value:

    Status code that indicates whether or not the function was successful.


--*/

{
    NTSTATUS status;
    UNICODE_STRING guidString, tempString;
    HANDLE hDeviceClasses, hFunctionClass;

    PAGED_CODE();

    //
    // Check that the supplied symbolic link can be parsed to extract the device
    // class guid string - note that this is also a way of verifying that the
    // SymbolicLinkName string is valid.
    //
    status = IopParseSymbolicLinkName(SymbolicLinkName,
                                      NULL,
                                      NULL,
                                      &guidString,
                                      NULL,
                                      NULL,
                                      NULL);
    if(!NT_SUCCESS(status)){
        goto clean0;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //

    PiLockPnpRegistry(TRUE);        

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses key
    //

    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopOpenRegistryKeyEx( &hDeviceClasses,
                                   NULL,
                                   &tempString,
                                   KEY_READ
                                   );

    if( !NT_SUCCESS(status) ){
        goto clean1;
    }

    //
    // Open function class GUID key
    //

    status = IopOpenRegistryKeyEx( &hFunctionClass,
                                   hDeviceClasses,
                                   &guidString,
                                   KEY_READ
                                   );

    if( !NT_SUCCESS(status) ){
        goto clean2;
    }

    //
    // Open device interface instance key
    //
    status = IopOpenOrCreateDeviceInterfaceSubKeys(DeviceInterfaceKey,
                                                   NULL,
                                                   DeviceInterfaceInstanceKey,
                                                   NULL,
                                                   hFunctionClass,
                                                   SymbolicLinkName,
                                                   DesiredAccess,
                                                   FALSE
                                                  );

    if((!NT_SUCCESS(status)) || (!ARGUMENT_PRESENT(DeviceInterfaceClassKey))) {
        ZwClose(hFunctionClass);
    } else {
        *DeviceInterfaceClassKey = hFunctionClass;
    }

clean2:
    ZwClose(hDeviceClasses);
clean1:
    PiUnlockPnpRegistry();
clean0:
    return status;

}

NTSTATUS
IoRegisterDeviceInterface(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    OUT PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This device driver interface allows a WDM driver to register a particular
    interface of its underlying hardware (ie PDO) as a member of a function class.

Parameters:

    PhysicalDeviceObject - Supplies a pointer to the PDO for the P&P device
        instance associated with the functionality being registered

    InterfaceClassGuid - Supplies a pointer to the GUID representring the functionality
        to be registered

    ReferenceString - Optionally, supplies an additional context string which is
        appended to the enumeration path of the device

    SymbolicLinkName - Supplies a pointer to a string which on success will contain the
        kernel mode path of the symbolic link used to open this device.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_NODE pDeviceNode;
    PUNICODE_STRING pDeviceString;
    NTSTATUS status;
    PWSTR   pRefString;
    USHORT  count;

    PAGED_CODE();

    //
    // Until PartMgr/Disk stop registering non PDOs allow the system to boot.
    //
    // ASSERT_PDO(PhysicalDeviceObject);
    //

    //
    // Ensure we have a PDO - only PDO's have a device node attached
    //

    pDeviceNode = (PDEVICE_NODE) PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;
    if (pDeviceNode) {

        //
        // Get the instance path string
        //
        pDeviceString = &pDeviceNode->InstancePath;

        if (pDeviceNode->InstancePath.Length == 0) {
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // Make sure the ReferenceString does not contain any path seperator characters
        //
        if (ReferenceString) {
            pRefString = ReferenceString->Buffer;
            count = ReferenceString->Length / sizeof(WCHAR);
            while (count--) {
                if((*pRefString == SEPERATOR_CHAR) || (*pRefString == ALT_SEPERATOR_CHAR)) {
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoRegisterDeviceInterface: Invalid RefString!! failed with status = %8.8X\n", status));
                    return status;
                }
                pRefString++;
            }
        }

        return IopRegisterDeviceInterface(pDeviceString,
                                          InterfaceClassGuid,
                                          ReferenceString,
                                          FALSE,           // kernel-mode format
                                          SymbolicLinkName
                                          );
    } else {

        return STATUS_INVALID_DEVICE_REQUEST;
    }
}

NTSTATUS
IopRegisterDeviceInterface(
    IN PUNICODE_STRING DeviceInstanceName,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    IN BOOLEAN UserModeFormat,
    OUT PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This is the worker routine for IoRegisterDeviceInterface.  It is also
    called by the user-mode ConfigMgr (via an NtPlugPlayControl), which is why it
    must take a device instance name instead of a PDO (since the device instance
    may not currently be 'live'), and also why it must optionally return the user-
    mode form of the interface device name (i.e., "\\?\" instead of "\??\").

Parameters:

    DeviceInstanceName - Supplies the name of the device instance for which a
        device interface is being registered.

    InterfaceClassGuid - Supplies a pointer to the GUID representring the class
        of the device interface being registered.

    ReferenceString - Optionally, supplies an additional context string which is
        appended to the enumeration path of the device

    UserModeFormat - If non-zero, then the symbolic link name returned for the
        interface device is in user-mode form (i.e., "\\?\").  If zero (FALSE),
        it is in kernel-mode form (i.e., "\??\").

    SymbolicLinkName - Supplies a pointer to a string which on success will contain
        either the kernel-mode or user-mode path of the symbolic link used to open
        this device.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING tempString, guidString, otherString;
    PUNICODE_STRING pUserString, pKernelString;
    HANDLE hTemp1, hTemp2, hInterfaceInstanceKey;
    ULONG InterfaceDisposition, InterfaceInstanceDisposition;

    PAGED_CODE();

    //
    // Convert the class guid into string form
    //

    status = RtlStringFromGUID(InterfaceClassGuid, &guidString);
    if( !NT_SUCCESS(status) ){
        goto clean0;
    }

    //
    // Construct both flavors of symbolic link name (go ahead and store the form
    // that the user wants in the SymbolicLinkName parameter they supplied--this
    // saves us from having to copy the appropriate string over to their string
    // later).
    //
    if(UserModeFormat) {
        pUserString = SymbolicLinkName;
        pKernelString = &otherString;
    } else {
        pKernelString = SymbolicLinkName;
        pUserString = &otherString;
    }

    status = IopBuildSymbolicLinkStrings(DeviceInstanceName,
                                         &guidString,
                                         ReferenceString,
                                         pUserString,
                                         pKernelString
                                         );
    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //

    PiLockPnpRegistry(TRUE);

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses key into hTemp1
    //

    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopCreateRegistryKeyEx( &hTemp1,
                                     NULL,
                                     &tempString,
                                     KEY_CREATE_SUB_KEY,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if( !NT_SUCCESS(status) ){
        goto clean2;
    }

    //
    // Open/create function class GUID key into hTemp2
    //

    status = IopCreateRegistryKeyEx( &hTemp2,
                                     hTemp1,
                                     &guidString,
                                     KEY_CREATE_SUB_KEY,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );
    ZwClose(hTemp1);

    if( !NT_SUCCESS(status) ){
        goto clean2;
    }

    //
    // Now open/create the two-level device interface hierarchy underneath this
    // interface class key.
    //
    status = IopOpenOrCreateDeviceInterfaceSubKeys(&hTemp1,
                                                   &InterfaceDisposition,
                                                   &hInterfaceInstanceKey,
                                                   &InterfaceInstanceDisposition,
                                                   hTemp2,
                                                   pUserString,
                                                   KEY_WRITE | DELETE,
                                                   TRUE
                                                  );

    ZwClose(hTemp2);

    if(!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // Create the device instance value under the device interface key
    //

    PiWstrToUnicodeString(&tempString, REGSTR_VAL_DEVICE_INSTANCE);
    status = IopSetRegistryStringValue(hTemp1,
                                       &tempString,
                                       DeviceInstanceName
                                       );
    if(!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Create symbolic link value under interface instance subkey
    //

    PiWstrToUnicodeString(&tempString, REGSTR_VAL_SYMBOLIC_LINK);
    status = IopSetRegistryStringValue(hInterfaceInstanceKey,
                                       &tempString,
                                       pUserString
                                       );

clean3:
    if (!NT_SUCCESS(status)) {
        //
        // Since we failed to register the device interface, delete any keys
        // that were newly created in the attempt.
        //
        if(InterfaceInstanceDisposition == REG_CREATED_NEW_KEY) {
            ZwDeleteKey(hInterfaceInstanceKey);
        }

        if(InterfaceDisposition == REG_CREATED_NEW_KEY) {
            ZwDeleteKey(hTemp1);
        }
    }

    ZwClose(hInterfaceInstanceKey);
    ZwClose(hTemp1);

clean2:
    PiUnlockPnpRegistry();
    IopFreeAllocatedUnicodeString(&otherString);
    if (!NT_SUCCESS(status)) {
        IopFreeAllocatedUnicodeString(SymbolicLinkName);
    }

clean1:
    RtlFreeUnicodeString(&guidString);
clean0:
    return status;
}

NTSTATUS
IopUnregisterDeviceInterface(
    IN PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine removes the interface instance subkey of
    ReferenceString from the interface for DeviceInstanceName to the
    given InterfaceClassGuid.  If the interface instance specified by
    the Reference String portion of SymbolicLinkName is the only
    instance of the interface, the interface subkey is removed from
    the device class key as well.

Parameters:

    SymbolicLinkName - Supplies a pointer to a unicode string which
        contains the symbolic link name of the device to unregister.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS        status = STATUS_SUCCESS;
    HANDLE          hInterfaceClassKey=NULL, hInterfaceKey=NULL,
                    hInterfaceInstanceKey=NULL, hControl=NULL;
    UNICODE_STRING  tempString, mungedPathString, guidString, refString;
    BOOLEAN         refStringPresent;
    GUID            guid;
    UNICODE_STRING  interfaceKeyName, instanceKeyName;
    ULONG           linked, remainingSubKeys;
    USHORT          length;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PKEY_FULL_INFORMATION keyInformation;

    PAGED_CODE();

    //
    // Check that the supplied symbolic link can be parsed - note that this is
    // also a way of verifying that the SymbolicLinkName string is valid.
    //
    status = IopParseSymbolicLinkName(SymbolicLinkName,
                                      NULL,
                                      &mungedPathString,
                                      &guidString,
                                      &refString,
                                      &refStringPresent,
                                      &guid);
    if (!NT_SUCCESS(status)) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // Allocate a unicode string for the interface instance key name.
    // (includes the REFSTRING_PREFIX_CHAR, and ReferenceString, if present)
    //
    length = sizeof(WCHAR) + refString.Length;
    status = IopAllocateUnicodeString(&instanceKeyName,
                                      length);
    if(!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Set the MaximumLength of the Buffer, and append the
    // REFSTRING_PREFIX_CHAR to it.
    //
    *instanceKeyName.Buffer = REFSTRING_PREFIX_CHAR;
    instanceKeyName.Length = sizeof(WCHAR);
    instanceKeyName.MaximumLength = length + sizeof(UNICODE_NULL);

    //
    // Append the ReferenceString to the prefix char, if necessary.
    //
    if (refStringPresent) {
        RtlAppendUnicodeStringToString(&instanceKeyName, &refString);
    }

    instanceKeyName.Buffer[instanceKeyName.Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Allocate a unicode string for the interface key name.
    // (includes KEY_STRING_PREFIX, mungedPathString, separating '#'
    //  char, and the guidString)
    //
    length = IopConstStringSize(KEY_STRING_PREFIX) + mungedPathString.Length +
             sizeof(WCHAR) + guidString.Length;

    status = IopAllocateUnicodeString(&interfaceKeyName,
                                      length);
    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    interfaceKeyName.MaximumLength = length + sizeof(UNICODE_NULL);

    //
    // Copy the symbolic link name (without refString) to the interfaceKeyNam
    //
    RtlCopyMemory(interfaceKeyName.Buffer, SymbolicLinkName->Buffer, length);
    interfaceKeyName.Length = length;
    interfaceKeyName.Buffer[interfaceKeyName.Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Replace the "\??\" or "\\?\" symbolic link name prefix with "##?#"
    //
    RtlCopyMemory(interfaceKeyName.Buffer,
                  KEY_STRING_PREFIX,
                  IopConstStringSize(KEY_STRING_PREFIX));

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //
    
    PiLockPnpRegistry(TRUE);

    //
    // Get class, interface, and instance handles
    //
    status = IopDeviceInterfaceKeysFromSymbolicLink(SymbolicLinkName,
                                                    KEY_ALL_ACCESS,
                                                    &hInterfaceClassKey,
                                                    &hInterfaceKey,
                                                    &hInterfaceInstanceKey
                                                    );
    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // Determine whether this interface is currently "enabled"
    //
    linked = 0;
    PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &hControl,
                                   hInterfaceInstanceKey,
                                   &tempString,
                                   KEY_ALL_ACCESS
                                   );
    if (NT_SUCCESS(status)) {
        //
        // Check the "linked" value under the "Control" subkey of this
        // interface instance
        //
        keyValueInformation=NULL;
        status = IopGetRegistryValue(hControl,
                                     REGSTR_VAL_LINKED,
                                     &keyValueInformation);

        if(NT_SUCCESS(status)) {
            if (keyValueInformation->Type == REG_DWORD &&
                keyValueInformation->DataLength == sizeof(ULONG)) {

                linked = *((PULONG) KEY_VALUE_DATA(keyValueInformation));
                ExFreePool(keyValueInformation);
            }
        }

        ZwClose(hControl);
        hControl = NULL;
    }

    //
    // Ignore any status code returned while attempting to retieve the
    // state of the device.  The value of linked will tell us if we
    // need to disable the interface instance first.
    //
    // If no instance "Control" subkey or "linked" value was present
    //     (status == STATUS_OBJECT_NAME_NOT_FOUND), this interface instance
    //     is not currently enabled -- ok to delete.
    //
    // If the attempt to retrieve these values failed with some other error,
    //     any attempt to disable the interface will also likely fail,
    //     so we'll just have to delete this instance anyways.
    //
    status = STATUS_SUCCESS;

    if (linked) {
        //
        // Disabled the active interface before unregistering it, ignore any
        // status returned, we'll delete this interface instance key anyways.
        //
        IoSetDeviceInterfaceState(SymbolicLinkName, FALSE);
    }

    //
    // Recursively delete the interface instance key, if it exists.
    //
    ZwClose(hInterfaceInstanceKey);
    hInterfaceInstanceKey = NULL;
    IopDeleteKeyRecursive (hInterfaceKey, instanceKeyName.Buffer);

    //
    // Find out how many subkeys to the interface key remain.
    //
    status = IopGetRegistryKeyInformation(hInterfaceKey,
                                          &keyInformation);
    if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    remainingSubKeys = keyInformation->SubKeys;

    ExFreePool(keyInformation);

    //
    // See if a volatile "Control" subkey exists under this interface key
    //
    PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &hControl,
                                   hInterfaceKey,
                                   &tempString,
                                   KEY_READ
                                   );
    if (NT_SUCCESS(status)) {
        ZwClose(hControl);
        hControl = NULL;
    }
    if ((remainingSubKeys==0) ||
        ((remainingSubKeys==1) && (NT_SUCCESS(status)))) {
        //
        // If the interface key has no subkeys, or the only the remaining subkey
        // is the volatile interface "Control" subkey, then there are no more
        // instances to this interface.  We should delete the interface key
        // itself also.
        //
        ZwClose(hInterfaceKey);
        hInterfaceKey = NULL;

        IopDeleteKeyRecursive (hInterfaceClassKey, interfaceKeyName.Buffer);
    }

    status = STATUS_SUCCESS;


clean3:
    if (hControl) {
        ZwClose(hControl);
    }
    if (hInterfaceInstanceKey) {
        ZwClose(hInterfaceInstanceKey);
    }
    if (hInterfaceKey) {
        ZwClose(hInterfaceKey);
    }
    if (hInterfaceClassKey) {
        ZwClose(hInterfaceClassKey);
    }

clean2:
    PiUnlockPnpRegistry();

    IopFreeAllocatedUnicodeString(&interfaceKeyName);

clean1:
    IopFreeAllocatedUnicodeString(&instanceKeyName);

clean0:
    return status;
}

NTSTATUS
IopRemoveDeviceInterfaces(
    IN PUNICODE_STRING DeviceInstancePath
    )

/*++

Routine Description:

    This routine checks all device class keys under
    HKLM\SYSTEM\CCS\Control\DeviceClasses for interfaces for which the
    DeviceInstance value matches the supplied DeviceInstancePath.  Instances of
    such device interfaces are unregistered, and the device interface subkey
    itself is removed.

    Note that a lock on the registry must have already been acquired,
    by the caller of this routine.

Parameters:

    DeviceInterfacePath - Supplies a pointer to a unicode string which
        contains the DeviceInterface name of the device for which
        interfaces to are to be removed.

Return Value:

    Status code that indicates whether or not the function was
    successful.

--*/

{
    NTSTATUS       status;
    HANDLE         hDeviceClasses=NULL, hClassGUID=NULL, hInterface=NULL;
    UNICODE_STRING tempString, guidString, interfaceString, deviceInstanceString;
    ULONG          resultSize, classIndex, interfaceIndex;
    ULONG          symbolicLinkListSize;
    PWCHAR         symbolicLinkList, symLink;
    BUFFER_INFO    classInfoBuffer, interfaceInfoBuffer;
    PKEY_VALUE_FULL_INFORMATION deviceInstanceInfo;
    BOOLEAN        deletedInterface;
    GUID           classGUID;

    PAGED_CODE();

    //
    // Allocate initial buffers
    //
    status = IopAllocateBuffer(&classInfoBuffer,
                               INITIAL_INFO_BUFFER_SIZE);
    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    status = IopAllocateBuffer(&interfaceInfoBuffer,
                               INITIAL_INFO_BUFFER_SIZE);
    if (!NT_SUCCESS(status)) {
        IopFreeBuffer(&classInfoBuffer);
        goto clean0;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses
    //
    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopOpenRegistryKeyEx( &hDeviceClasses,
                                   NULL,
                                   &tempString,
                                   KEY_READ
                                   );
    if(!NT_SUCCESS(status)){
        goto clean1;
    }

    //
    // Enumerate all device classes
    //
    classIndex = 0;
    ASSERT(classInfoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
    while((status = ZwEnumerateKey(hDeviceClasses,
                                   classIndex,
                                   KeyBasicInformation,
                                   (PVOID) classInfoBuffer.Buffer,
                                   classInfoBuffer.MaxSize,
                                   &resultSize
                                   )) != STATUS_NO_MORE_ENTRIES) {

        //
        // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
        // was not enough room for even the fixed portions of the structure.
        //
        ASSERT(status != STATUS_BUFFER_TOO_SMALL);

        if (status == STATUS_BUFFER_OVERFLOW) {
            status = IopResizeBuffer(&classInfoBuffer, resultSize, FALSE);
            continue;
        } else if (!NT_SUCCESS(status)) {
            goto clean1;
        }

        //
        // Get the key name for this device class
        //
        guidString.Length = (USHORT)((PKEY_BASIC_INFORMATION)(classInfoBuffer.Buffer))->NameLength;
        guidString.MaximumLength = guidString.Length;
        guidString.Buffer = ((PKEY_BASIC_INFORMATION)(classInfoBuffer.Buffer))->Name;

        //
        // Open the key for this device class
        //
        status = IopOpenRegistryKeyEx( &hClassGUID,
                                       hDeviceClasses,
                                       &guidString,
                                       KEY_ALL_ACCESS
                                       );
        if (!NT_SUCCESS(status)) {
            //
            // Couldn't open key for this device class -- skip it and move on.
            //
            goto CloseClassKeyAndContinue;
        }

        //
        // Enumerate all device interfaces for this device class
        //
        interfaceIndex = 0;
        ASSERT(interfaceInfoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
        while((status = ZwEnumerateKey(hClassGUID,
                                       interfaceIndex,
                                       KeyBasicInformation,
                                       (PVOID) interfaceInfoBuffer.Buffer,
                                       interfaceInfoBuffer.MaxSize,
                                       &resultSize
                                       )) != STATUS_NO_MORE_ENTRIES) {

            //
            // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
            // was not enough room for even the fixed portions of the structure.
            //
            ASSERT(status != STATUS_BUFFER_TOO_SMALL);

            if (status == STATUS_BUFFER_OVERFLOW) {
                status = IopResizeBuffer(&interfaceInfoBuffer, resultSize, FALSE);
                continue;
            } else if (!NT_SUCCESS(status)) {
                goto clean1;
            }

            //
            // This interface key has not yet been deleted
            //
            deletedInterface = FALSE;

            //
            // Create a NULL-terminated unicode string for the interface key name
            //
            status = IopAllocateUnicodeString(&interfaceString,
                                              (USHORT)((PKEY_BASIC_INFORMATION)(interfaceInfoBuffer.Buffer))->NameLength);

            if (!NT_SUCCESS(status)) {
                goto clean1;
            }

            interfaceString.Length = (USHORT)((PKEY_BASIC_INFORMATION)(interfaceInfoBuffer.Buffer))->NameLength;
            interfaceString.MaximumLength = interfaceString.Length + sizeof(UNICODE_NULL);
            RtlCopyMemory(interfaceString.Buffer,
                          ((PKEY_BASIC_INFORMATION)(interfaceInfoBuffer.Buffer))->Name,
                          interfaceString.Length);
            interfaceString.Buffer[interfaceString.Length/sizeof(WCHAR)] = UNICODE_NULL;

            //
            // Open the device interface key
            //
            status = IopOpenRegistryKeyEx( &hInterface,
                                           hClassGUID,
                                           &interfaceString,
                                           KEY_ALL_ACCESS
                                           );
            if (!NT_SUCCESS(status)) {
                //
                // Couldn't open the device interface key -- skip it and move on.
                //
                hInterface = NULL;
                goto CloseInterfaceKeyAndContinue;
            }

            //
            // Get the DeviceInstance value for this interface key
            //
            status = IopGetRegistryValue(hInterface,
                                         REGSTR_VAL_DEVICE_INSTANCE,
                                         &deviceInstanceInfo);

            if(!NT_SUCCESS(status)) {
                //
                //  Couldn't get the DeviceInstance for this interface --
                //  skip it and move on.
                //
                goto CloseInterfaceKeyAndContinue;
            }

            if((deviceInstanceInfo->Type == REG_SZ) &&
               (deviceInstanceInfo->DataLength != 0)) {

                IopRegistryDataToUnicodeString(&deviceInstanceString,
                                               (PWSTR)KEY_VALUE_DATA(deviceInstanceInfo),
                                               deviceInstanceInfo->DataLength);

            } else {
                //
                // DeviceInstance value is invalid -- skip it and move on.
                //
                ExFreePool(deviceInstanceInfo);
                goto CloseInterfaceKeyAndContinue;

            }

            //
            // Compare the DeviceInstance of this interface to DeviceInstancePath
            //
            if (RtlEqualUnicodeString(&deviceInstanceString, DeviceInstancePath, TRUE)) {

                ZwClose(hInterface);
                hInterface = NULL;

                //
                // Retrieve all instances of this device interface
                // (active and non-active)
                //
                RtlGUIDFromString(&guidString, &classGUID);

                status = IopGetDeviceInterfaces(&classGUID,
                                                DeviceInstancePath,
                                                DEVICE_INTERFACE_INCLUDE_NONACTIVE,
                                                FALSE,       // kernel-mode format
                                                &symbolicLinkList,
                                                &symbolicLinkListSize);

                if (NT_SUCCESS(status)) {

                    //
                    // Iterate through all instances of the interface
                    //
                    symLink = symbolicLinkList;
                    while(*symLink != UNICODE_NULL) {

                        RtlInitUnicodeString(&tempString, symLink);

                        //
                        // Unregister this instance of the interface.  Since we are
                        // removing the device, ignore any returned status, since
                        // there isn't anything we can do about interfaces which
                        // fail unregistration.
                        //
                        IopUnregisterDeviceInterface(&tempString);

                        symLink += ((tempString.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR));
                    }
                    ExFreePool(symbolicLinkList);
                }

                //
                // Recursively delete the interface key, if it still exists.
                // While IopUnregisterDeviceInterface will itself delete the
                // interface key if no interface instance subkeys remain, if any
                // of the above calls to IopUnregisterDeviceInterface failed to
                // delete an interface instance key, subkeys will remain, and
                // the interface key will not have been deleted.  We'll catch
                // that here.
                //
                status = IopOpenRegistryKeyEx( &hInterface,
                                               hClassGUID,
                                               &interfaceString,
                                               KEY_READ
                                               );
                if(NT_SUCCESS(status)){
                    if (NT_SUCCESS(IopDeleteKeyRecursive(hClassGUID,
                                                         interfaceString.Buffer))) {
                        deletedInterface = TRUE;
                    }
                    ZwDeleteKey(hInterface);
                    ZwClose(hInterface);
                    hInterface = NULL;
                } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                    //
                    // Interface was already deleted by IopUnregisterDeviceInterface
                    //
                    deletedInterface = TRUE;
                }
            }

            //
            // Free allocated key info structure
            //
            ExFreePool(deviceInstanceInfo);

CloseInterfaceKeyAndContinue:

            if (hInterface != NULL) {
                ZwClose(hInterface);
                hInterface = NULL;
            }

            IopFreeAllocatedUnicodeString(&interfaceString);

            //
            // Only increment the enumeration index for non-deleted keys
            //
            if (!deletedInterface) {
                interfaceIndex++;
            }

        }

CloseClassKeyAndContinue:

        if (hClassGUID != NULL) {
            ZwClose(hClassGUID);
            hClassGUID = NULL;
        }
        classIndex++;
    }

clean1:
    if (hInterface) {
        ZwClose(hInterface);
    }
    if (hClassGUID) {
        ZwClose(hClassGUID);
    }
    if (hDeviceClasses) {
        ZwClose(hDeviceClasses);
    }

    IopFreeBuffer(&interfaceInfoBuffer);
    IopFreeBuffer(&classInfoBuffer);

clean0:
    return status;
}



NTSTATUS
IopDisableDeviceInterfaces(
    IN PUNICODE_STRING DeviceInstancePath
    )
/*++

Routine Description:

    This routine disables all enabled device interfaces for a given device
    instance.  This is typically done after a device has been removed, in case
    the driver did not disable the interfaces for that device, as it should
    have.

    Note that this routine acquires a lock on the registry.

Parameters:

    DeviceInterfacePath - Supplies a pointer to a unicode string which contains
                          the DeviceInterface name of the device for which
                          interfaces to are to be disabled.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING tempString, guidString;
    HANDLE hDeviceClasses = NULL;
    ULONG classIndex, resultSize;
    BUFFER_INFO classInfoBuffer;
    GUID classGuid;
    PWCHAR symbolicLinkList, symLink;
    ULONG symbolicLinkListSize;

    PAGED_CODE();

    //
    // Allocate initial buffer to hold device class GUID subkeys.
    //
    status = IopAllocateBuffer(&classInfoBuffer,
                               sizeof(KEY_BASIC_INFORMATION) +
                               GUID_STRING_SIZE + sizeof(UNICODE_NULL));
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //
    PiLockPnpRegistry(TRUE);

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses
    //
    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopOpenRegistryKeyEx(&hDeviceClasses,
                                  NULL,
                                  &tempString,
                                  KEY_READ
                                  );
    if (!NT_SUCCESS(status)){
        goto clean0;
    }

    //
    // Enumerate all device classes
    //
    classIndex = 0;
    ASSERT(classInfoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
    while((status = ZwEnumerateKey(hDeviceClasses,
                                   classIndex,
                                   KeyBasicInformation,
                                   (PVOID)classInfoBuffer.Buffer,
                                   classInfoBuffer.MaxSize,
                                   &resultSize
                                   )) != STATUS_NO_MORE_ENTRIES) {

        //
        // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
        // was not enough room for even the fixed portions of the structure.
        //
        ASSERT(status != STATUS_BUFFER_TOO_SMALL);

        if (status == STATUS_BUFFER_OVERFLOW) {
            status = IopResizeBuffer(&classInfoBuffer, resultSize, FALSE);
            continue;
        } else if (!NT_SUCCESS(status)) {
            ZwClose(hDeviceClasses);
            goto clean0;
        }

        //
        // Get the key name for this device class
        //
        guidString.Length = (USHORT)((PKEY_BASIC_INFORMATION)(classInfoBuffer.Buffer))->NameLength;
        guidString.MaximumLength = guidString.Length;
        guidString.Buffer = ((PKEY_BASIC_INFORMATION)(classInfoBuffer.Buffer))->Name;

        //
        // Retrieve all enabled device interfaces for this device class that are
        // exposed by the given device instance.
        //
        RtlGUIDFromString(&guidString, &classGuid);

        status = IopGetDeviceInterfaces(&classGuid,
                                        DeviceInstancePath,
                                        0,     // active interfaces only
                                        FALSE, // kernel-mode format
                                        &symbolicLinkList,
                                        &symbolicLinkListSize);

        if (NT_SUCCESS(status)) {

            //
            // Iterate through all enabled instances of this device interface
            // members of this device interface class, exposed by the given
            // device instance.
            //
            symLink = symbolicLinkList;
            while(*symLink != UNICODE_NULL) {

                RtlInitUnicodeString(&tempString, symLink);

                IopDbgPrint((IOP_WARNING_LEVEL,
                           "IopDisableDeviceInterfaces: auto-disabling interface %Z for device instance %Z\n",
                           tempString,
                           DeviceInstancePath));

                //
                // Disable this device interface.
                //
                IoSetDeviceInterfaceState(&tempString, FALSE);

                symLink += ((tempString.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR));
            }
            ExFreePool(symbolicLinkList);
        }
        classIndex++;
    }

    ZwClose(hDeviceClasses);

 clean0:

    IopFreeBuffer(&classInfoBuffer);

    PiUnlockPnpRegistry();

    return status;
}



NTSTATUS
IopOpenOrCreateDeviceInterfaceSubKeys(
    OUT PHANDLE InterfaceKeyHandle           OPTIONAL,
    OUT PULONG InterfaceKeyDisposition       OPTIONAL,
    OUT PHANDLE InterfaceInstanceKeyHandle   OPTIONAL,
    OUT PULONG InterfaceInstanceDisposition  OPTIONAL,
    IN HANDLE InterfaceClassKeyHandle,
    IN PUNICODE_STRING DeviceInterfaceName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    This API opens or creates a two-level registry hierarchy underneath the
    specified interface class key for a particular device interface.  The first
    level is the (munged) symbolic link name (sans RefString).  The second level
    is the refstring, prepended with a '#' sign (if the device interface has no
    refstring, then this key name is simply '#').

Parameters:

    InterfaceKeyHandle - Optionally, supplies the address of a variable that
        receives a handle to the interface key (1st level in the hierarchy).

    InterfaceKeyDisposition - Optionally, supplies the address of a variable that
        receives either REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY indicating
        whether the interface key was newly-created.

    InterfaceInstanceKeyHandle - Optionally, supplies the address of a variable
        that receives a handle to the interface instance key (2nd level in the
        hierarchy).

    InterfaceInstanceDisposition - Optionally, supplies the address of a variable
        that receives either REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY
        indicating whether the interface instance key was newly-created.

    InterfaceClassKeyHandle - Supplies a handle to the interface class key under
        which the device interface keys are to be opened/created.

    DeviceInterfaceName - Supplies the (user-mode or kernel-mode form) device
        interface name.

    DesiredAccess - Specifies the desired access that the caller needs to the keys.

    Create - Determines if the keys are to be created if they do not exist.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING TempString, RefString;
    WCHAR PoundCharBuffer;
    HANDLE hTempInterface, hTempInterfaceInstance;
    ULONG TempInterfaceDisposition;
    BOOLEAN RefStringPresent=FALSE;

    PAGED_CODE();

    //
    // Make a copy of the device interface name, since we're going to munge it.
    //
    status = IopAllocateUnicodeString(&TempString, DeviceInterfaceName->Length);

    if(!NT_SUCCESS(status)) {
        goto clean0;
    }

    RtlCopyUnicodeString(&TempString, DeviceInterfaceName);

    //
    // Parse the SymbolicLinkName for the refstring component (if there is one).
    // Note that this is also a way of verifying that the string is valid.
    //
    status = IopParseSymbolicLinkName(&TempString,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &RefString,
                                      &RefStringPresent,
                                      NULL);
    ASSERT(NT_SUCCESS(status));

    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    if(RefStringPresent) {
        //
        // Truncate the device interface name before the refstring separator char.
        //
        RefString.Buffer--;
        RefString.Length += sizeof(WCHAR);
        RefString.MaximumLength += sizeof(WCHAR);
        TempString.MaximumLength = TempString.Length = (USHORT)((PUCHAR)RefString.Buffer - (PUCHAR)TempString.Buffer);
    } else {
        //
        // Set up refstring to point to a temporary character buffer that will hold
        // the single '#' used for the key name when no refstring is present.
        //
        RefString.Buffer = &PoundCharBuffer;
        RefString.Length = RefString.MaximumLength = sizeof(PoundCharBuffer);
    }

    //
    // Replace the "\??\" or "\\?\" symbolic link name prefix with ##?#
    //
    RtlCopyMemory(TempString.Buffer, KEY_STRING_PREFIX, IopConstStringSize(KEY_STRING_PREFIX));

    //
    // Munge the string
    //
    IopReplaceSeperatorWithPound(&TempString, &TempString);

    //
    // Now open/create this subkey under the interface class key.
    //

    if (Create) {
        status = IopCreateRegistryKeyEx( &hTempInterface,
                                         InterfaceClassKeyHandle,
                                         &TempString,
                                         DesiredAccess,
                                         REG_OPTION_NON_VOLATILE,
                                         &TempInterfaceDisposition
                                         );
    } else {
        status = IopOpenRegistryKeyEx( &hTempInterface,
                                       InterfaceClassKeyHandle,
                                       &TempString,
                                       DesiredAccess
                                       );
    }

    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Store a '#' as the first character of the RefString, and then we're ready to open the
    // refstring subkey.
    //
    *RefString.Buffer = REFSTRING_PREFIX_CHAR;

    //
    // Now open/create the subkey under the interface key representing this interface instance
    // (i.e., differentiated by refstring).
    //

    if (Create) {
        status = IopCreateRegistryKeyEx( &hTempInterfaceInstance,
                                       hTempInterface,
                                       &RefString,
                                       DesiredAccess,
                                       REG_OPTION_NON_VOLATILE,
                                       InterfaceInstanceDisposition
                                       );
    } else {
        status = IopOpenRegistryKeyEx( &hTempInterfaceInstance,
                                       hTempInterface,
                                       &RefString,
                                       DesiredAccess
                                       );

        TempInterfaceDisposition = REG_OPENED_EXISTING_KEY;
    }

    if (NT_SUCCESS(status)) {
        //
        // Store any requested return values in the caller-supplied buffers.
        //
        if (InterfaceKeyHandle) {
            *InterfaceKeyHandle = hTempInterface;
        } else {
            ZwClose(hTempInterface);
        }
        if (InterfaceKeyDisposition) {
            *InterfaceKeyDisposition = TempInterfaceDisposition;
        }
        if (InterfaceInstanceKeyHandle) {
            *InterfaceInstanceKeyHandle = hTempInterfaceInstance;
        } else {
            ZwClose(hTempInterfaceInstance);
        }
        //
        // (no need to set InterfaceInstanceDisposition--we already set it above)
        //
    } else {
        //
        // If the interface key was newly-created above, then delete it.
        //
        if (TempInterfaceDisposition == REG_CREATED_NEW_KEY) {
            ZwDeleteKey(hTempInterface);
        }
        ZwClose(hTempInterface);
    }

clean1:
    IopFreeAllocatedUnicodeString(&TempString);

clean0:
    return status;
}

NTSTATUS
IoGetDeviceInterfaceAlias(
    IN PUNICODE_STRING SymbolicLinkName,
    IN CONST GUID *AliasInterfaceClassGuid,
    OUT PUNICODE_STRING AliasSymbolicLinkName
    )

/*++

Routine Description:

    This API returns a symbolic link name (i.e., device interface) of a
    particular interface class that 'aliases' the specified device interface.
    Two device interfaces are considered aliases of each other if the
    following two criteria are met:

        1.  Both interfaces are exposed by the same PDO (devnode).
        2.  Both interfaces share the same RefString.

Parameters:

    SymbolicLinkName - Supplies the name of the device interface whose alias is
        to be retrieved.

    AliasInterfaceClassGuid - Supplies a pointer to the GUID representing the interface
        class for which an alias is to be retrieved.

    AliasSymbolicLinkName - Supplies a pointer to a string which, upon success,
        will contain the name of the device interface in the specified class that
        aliases the SymbolicLinkName interface.  (This symbolic link name will be
        returned in either kernel-mode or user-mode form, depeding upon the form
        of the SymbolicLinkName path).

        It is the caller's responsibility to free the buffer allocated for this
        string via ExFreePool().

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    HANDLE hKey;
    PKEY_VALUE_FULL_INFORMATION pDeviceInstanceInfo;
    UNICODE_STRING deviceInstanceString, refString, guidString, otherString;
    PUNICODE_STRING pUserString, pKernelString;
    BOOLEAN refStringPresent, userModeFormat;

    PAGED_CODE();

    //
    // Make sure we have a SymbolicLinkName to parse.
    //

    if ((!ARGUMENT_PRESENT(SymbolicLinkName)) ||
        (SymbolicLinkName->Buffer == NULL)) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // check that the input buffer really is big enough
    //

    ASSERT(IopConstStringSize(USER_SYMLINK_STRING_PREFIX) == IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX));

    if (SymbolicLinkName->Length < (IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX)+GUID_STRING_SIZE+1)) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // Convert the class guid into string form
    //

    status = RtlStringFromGUID(AliasInterfaceClassGuid, &guidString);
    if( !NT_SUCCESS(status) ){
        goto clean0;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //

    PiLockPnpRegistry(TRUE);

    //
    // Open the (parent) device interface key--not the refstring-specific one.
    //

    status = IopDeviceInterfaceKeysFromSymbolicLink(SymbolicLinkName,
                                                    KEY_READ,
                                                    NULL,
                                                    &hKey,
                                                    NULL
                                                    );
    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Get the name of the device instance that 'owns' this interface.
    //

    status = IopGetRegistryValue(hKey, REGSTR_VAL_DEVICE_INSTANCE, &pDeviceInstanceInfo);

    ZwClose(hKey);

    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    if(pDeviceInstanceInfo->Type == REG_SZ) {

        IopRegistryDataToUnicodeString(&deviceInstanceString,
                                       (PWSTR)KEY_VALUE_DATA(pDeviceInstanceInfo),
                                       pDeviceInstanceInfo->DataLength
                                      );

    } else {

        status = STATUS_INVALID_PARAMETER_1;
        goto clean2;

    }

    //
    // Now parse out the refstring, so that we can construct the name of the interface device's
    // alias.  (NOTE: we have not yet verified that the alias actually exists, we're only
    // constructing what its name would be, if it did exist.)
    //
    // Don't bother to check the return code.  If this were a bad string, we'd have already
    // failed above when we called IopDeviceInterfaceKeysFromSymbolicLink (since it also
    // calls IopParseSymbolicLinkName internally.)
    //
    status = IopParseSymbolicLinkName(SymbolicLinkName,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &refString,
                                      &refStringPresent,
                                      NULL);
    ASSERT(NT_SUCCESS(status));

    //
    // Did the caller supply us with a user-mode or kernel-mode format path?
    //
    userModeFormat = (BOOLEAN)(IopConstStringSize(USER_SYMLINK_STRING_PREFIX) ==
                          RtlCompareMemory(SymbolicLinkName->Buffer,
                                           USER_SYMLINK_STRING_PREFIX,
                                           IopConstStringSize(USER_SYMLINK_STRING_PREFIX)
                                          ));

    if(userModeFormat) {
        pUserString = AliasSymbolicLinkName;
        pKernelString = &otherString;
    } else {
        pKernelString = AliasSymbolicLinkName;
        pUserString = &otherString;
    }

    status = IopBuildSymbolicLinkStrings(&deviceInstanceString,
                                         &guidString,
                                         refStringPresent ? &refString : NULL,
                                         pUserString,
                                         pKernelString
                                         );
    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // OK, we now have the symbolic link name of the alias, but we don't yet know whether
    // it actually exists.  Check this by attempting to open the associated registry key.
    //
    status = IopDeviceInterfaceKeysFromSymbolicLink(AliasSymbolicLinkName,
                                                    KEY_READ,
                                                    NULL,
                                                    NULL,
                                                    &hKey
                                                    );

    if(NT_SUCCESS(status)) {
        //
        // Alias exists--close the key handle.
        //
        ZwClose(hKey);
    } else {
        IopFreeAllocatedUnicodeString(AliasSymbolicLinkName);
    }

    IopFreeAllocatedUnicodeString(&otherString);

clean2:
    ExFreePool(pDeviceInstanceInfo);

clean1:
    PiUnlockPnpRegistry();
    RtlFreeUnicodeString(&guidString);

clean0:
    return status;
}

NTSTATUS
IopBuildSymbolicLinkStrings(
    IN PUNICODE_STRING DeviceString,
    IN PUNICODE_STRING GuidString,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    OUT PUNICODE_STRING UserString,
    OUT PUNICODE_STRING KernelString
)
/*++

Routine Description:

    This routine will construct various strings used in the registration of
    function device class associations (IoRegisterDeviceClassAssociation).
    The specific strings are detailed below

Parameters:

    DeviceString - Supplies a pointer to the instance path of the device.
        It is of the form <Enumerator>\<Device>\<Instance>.

    GuidString - Supplies a pointer to the string representation of the
        function class guid.

    ReferenceString - Supplies a pointer to the reference string for the given
        device to exhibit the given function.  This is optional

    UserString - Supplies a pointer to an uninitialised string which on success
        will contain the string to be assigned to the "SymbolicLink" value under the
        KeyString.  It is of the format \\?\<MungedDeviceString>\<GuidString>\<Reference>
        When no longer required it should be freed using IopFreeAllocatedUnicodeString.

    KernelString - Supplies a pointer to an uninitialised string which on success
        will contain the kernel mode path of the device and is of the format
        \??\<MungedDeviceString>\<GuidString>\<Reference>. When no longer required it
        should be freed using IopFreeAllocatedUnicodeString.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    USHORT length;
    UNICODE_STRING mungedDeviceString;

    PAGED_CODE();

    //
    // The code is optimised to use the fact that \\.\ and \??\ are the same size - if
    // these prefixes change then we need to change the code.
    //

    ASSERT(IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) == IopConstStringSize(USER_SYMLINK_STRING_PREFIX));

    //
    // Calculate the lengths of the strings
    //

    length = IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) + DeviceString->Length +
             IopConstStringSize(REPLACED_SEPERATOR_STRING) + GuidString->Length;

    if(ARGUMENT_PRESENT(ReferenceString) && (ReferenceString->Length != 0)) {
        length += IopConstStringSize(SEPERATOR_STRING) + ReferenceString->Length;
    }

    //
    // Allocate space for the strings
    //

    status = IopAllocateUnicodeString(KernelString, length);
    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    status = IopAllocateUnicodeString(UserString, length);
    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Allocate a temporary string to hold the munged device string
    //

    status = IopAllocateUnicodeString(&mungedDeviceString, DeviceString->Length);
    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // Copy and munge the device string
    //

    status = IopReplaceSeperatorWithPound(&mungedDeviceString, DeviceString);
    if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Construct the user mode string
    //

    RtlAppendUnicodeToString(UserString, USER_SYMLINK_STRING_PREFIX);
    RtlAppendUnicodeStringToString(UserString, &mungedDeviceString);
    RtlAppendUnicodeToString(UserString, REPLACED_SEPERATOR_STRING);
    RtlAppendUnicodeStringToString(UserString, GuidString);

    if (ARGUMENT_PRESENT(ReferenceString) && (ReferenceString->Length != 0)) {
        RtlAppendUnicodeToString(UserString, SEPERATOR_STRING);
        RtlAppendUnicodeStringToString(UserString, ReferenceString);
    }

    ASSERT( UserString->Length == length );

    //
    // Construct the kernel mode string by replacing the prefix on the value string
    //

    RtlCopyUnicodeString(KernelString, UserString);
    RtlCopyMemory(KernelString->Buffer,
                  KERNEL_SYMLINK_STRING_PREFIX,
                  IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX)
                 );

clean3:
    IopFreeAllocatedUnicodeString(&mungedDeviceString);

clean2:
    if (!NT_SUCCESS(status)) {
        IopFreeAllocatedUnicodeString(UserString);
    }

clean1:
    if (!NT_SUCCESS(status)) {
        IopFreeAllocatedUnicodeString(KernelString);
    }

clean0:
    return status;
}

NTSTATUS
IopReplaceSeperatorWithPound(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine will copy a string from InString to OutString replacing any occurence of
    '\' or '/' with '#' as it goes.

Parameters:

    OutString - Supplies a pointer to a string which has already been initialised to
        have a buffer large enough to accomodate the string.  The contents of this
        string will be over written

    InString - Supplies a pointer to the string to be munged

Return Value:

    Status code that indicates whether or not the function was successful.

Remarks:

    In place munging can be performed - ie. the In and Out strings can be the same.

--*/

{
    PWSTR pInPosition, pOutPosition;
    USHORT count;

    PAGED_CODE();

    ASSERT(InString);
    ASSERT(OutString);

    //
    // Ensure we have enough space in the output string
    //

    if(InString->Length > OutString->MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    pInPosition = InString->Buffer;
    pOutPosition = OutString->Buffer;
    count = InString->Length / sizeof(WCHAR);

    //
    // Traverse the in string copying and replacing all occurences of '\' or '/'
    // with '#'
    //

    while (count--) {
        if((*pInPosition == SEPERATOR_CHAR) || (*pInPosition == ALT_SEPERATOR_CHAR)) {
            *pOutPosition = REPLACED_SEPERATOR_CHAR;
        } else {
            *pOutPosition = *pInPosition;
        }
        pInPosition++;
        pOutPosition++;
    }

    OutString->Length = InString->Length;

    return STATUS_SUCCESS;

}

NTSTATUS
IopDropReferenceString(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine removes the reference string from a symbolic link name.  No space
    is allocated for the out string so no attempt should be made to free the buffer
    of OutString.

Parameters:

    SymbolicLinkName - Supplies a pointer to a symbolic link name string.
        Both the prefixed strings are valid.

    GuidReferenceString - Supplies a pointer to an uninitialised string which on
        success will contain the symbolic link name without the reference string.
        See the note on storage allocation above.

Return Value:

    Status code that indicates whether or not the function was successful.

Remarks:

    The string returned in OutString is dependant on the buffer of
    InString and is only valid as long as InString is valid.

--*/

{
    UNICODE_STRING refString;
    NTSTATUS status;
    BOOLEAN refStringPresent;

    PAGED_CODE();

    ASSERT(InString);
    ASSERT(OutString);

    //
    // Parse the SymbolicLinkName for the refstring component (if there is one).
    // Note that this is also a way of verifying that the string is valid.
    //
    status = IopParseSymbolicLinkName(InString,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &refString,
                                      &refStringPresent,
                                      NULL);

    if (NT_SUCCESS(status)) {
        //
        // The refstring is always at the end, so just use the same buffer and
        // set the length of the output string accordingly.
        //
        OutString->Buffer = InString->Buffer;

        //
        // If we have a refstring then subtract it's length
        //
        if (refStringPresent) {
            OutString->Length = InString->Length - (refString.Length + sizeof(WCHAR));
        } else {
            OutString->Length = InString->Length;
        }

    } else {
        //
        // Invalidate the returned string
        //
        OutString->Buffer = NULL;
        OutString->Length = 0;
    }

    OutString->MaximumLength = OutString->Length;

    return status;
}

NTSTATUS
IopBuildGlobalSymbolicLinkString(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING GlobalString
    )
/*++

Routine Description:

    This routine will construct the global symbolic link name for the given
    kernel-mode or user-mode relative symbolic link name.

Parameters:

    SymbolicLinkName - Supplies a pointer to a symbolic link name string.
        Both the kernel-mode and user-mode prefixed strings are valid.

    GlobalString - Supplies a pointer to an uninitialised string which on
        success will contain the string that represents the symbolic link
        withing the global namespace.  It is of the format
        \GLOBAL??\<MungedDeviceString>\<GuidString>\<Reference>. When no longer
        required it should be freed using IopFreeAllocatedUnicodeString.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    USHORT length;
    UNICODE_STRING tempString;

    PAGED_CODE();

    //
    // The code is optimised to use the fact that \\.\ and \??\ are the same
    // size, and that since we are replacing the prefix, the routine can take
    // either one.  If these prefixes change then we need to change the code.
    //

    ASSERT(IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) == IopConstStringSize(USER_SYMLINK_STRING_PREFIX));

    //
    // Make sure the supplied SymbolicLinkName string begins with either the
    // kernel or user symbolic link prefix.  If it does not have a \\?\ or \??\
    // prefix then fail.
    //

    if ((RtlCompareMemory(SymbolicLinkName->Buffer,
                          USER_SYMLINK_STRING_PREFIX,
                          IopConstStringSize(USER_SYMLINK_STRING_PREFIX))
         != IopConstStringSize(USER_SYMLINK_STRING_PREFIX)) &&
        (RtlCompareMemory(SymbolicLinkName->Buffer,
                          KERNEL_SYMLINK_STRING_PREFIX,
                          IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX))
         != IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX))) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // Compute the length of the global symbolic link string.
    //

    length = SymbolicLinkName->Length - IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) +
             IopConstStringSize(GLOBAL_SYMLINK_STRING_PREFIX);

    //
    // Allocate space for the strings.
    //

    status = IopAllocateUnicodeString(GlobalString, length);
    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Copy the \GLOBAL?? symbolic link name prefix to the string.
    //

    status = RtlAppendUnicodeToString(GlobalString,
                                      GLOBAL_SYMLINK_STRING_PREFIX);
    ASSERT(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {
        IopFreeAllocatedUnicodeString(GlobalString);
        goto clean0;
    }

    //
    // Append the part of the SymbolicLinkName that follows the prefix.
    //

    tempString.Buffer = SymbolicLinkName->Buffer +
        IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);
    tempString.Length = SymbolicLinkName->Length -
        IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX);
    tempString.MaximumLength = SymbolicLinkName->MaximumLength -
        IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX);

    status = RtlAppendUnicodeStringToString(GlobalString, &tempString);

    ASSERT(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {
        IopFreeAllocatedUnicodeString(GlobalString);
        goto clean0;
    }

    ASSERT(GlobalString->Length == length);

clean0:

    return status;
}

NTSTATUS
IopParseSymbolicLinkName(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING PrefixString        OPTIONAL,
    OUT PUNICODE_STRING MungedPathString    OPTIONAL,
    OUT PUNICODE_STRING GuidString          OPTIONAL,
    OUT PUNICODE_STRING RefString           OPTIONAL,
    OUT PBOOLEAN        RefStringPresent    OPTIONAL,
    OUT LPGUID Guid                         OPTIONAL
    )

/*++

Routine Description:

    This routine breaks apart a symbolic link name constructed by
    IopBuildSymbolicLinkNames.  Both formats of name are valid - user
    mode \\?\ and kernel mode \??\.

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name to
        be analysed.

    PrefixString - Optionally contains a pointer to a string which will contain
        the prefix of the string.

    MungedPathString - Optionally contains a pointer to a string which will contain
        the enumeration path of the device with all occurences of '\' replaced with '#'.

    GuidString - Optionally contains a pointer to a string which will contain
        the device class guid in string format from the string.

    RefString - Optionally contains a pointer to a string which will contain
        the refstring of the string if one is present, otherwise it is undefined.

    RefStringPresent - Optionally contains a pointer to a boolean value which will
        be set to true if a refstring is present.

    Guid - Optionally contains a pointer to a guid which will contain
        the function class guid of the string.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR pCurrent;
    USHORT current, path, guid, reference = 0;
    UNICODE_STRING tempString;
    GUID tempGuid;
    BOOLEAN haveRefString;

    PAGED_CODE();

    //
    // Make sure we have a SymbolicLinkName to parse.
    //

    if ((!ARGUMENT_PRESENT(SymbolicLinkName)) ||
        (SymbolicLinkName->Buffer == NULL)    ||
        (SymbolicLinkName->Length == 0)) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // check that the input buffer really is big enough
    //

    ASSERT(IopConstStringSize(USER_SYMLINK_STRING_PREFIX) == IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX));

    if (SymbolicLinkName->Length < (IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX)+GUID_STRING_SIZE+1)) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // Sanity check on the incoming string - if it does not have a \\?\ or \??\ prefix then fail
    //

    if ((RtlCompareMemory(SymbolicLinkName->Buffer,
                          USER_SYMLINK_STRING_PREFIX,
                          IopConstStringSize(USER_SYMLINK_STRING_PREFIX))
         != IopConstStringSize(USER_SYMLINK_STRING_PREFIX)) &&
        (RtlCompareMemory(SymbolicLinkName->Buffer,
                          KERNEL_SYMLINK_STRING_PREFIX,
                          IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX))
         != IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX))) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // Break apart the string into it's constituent parts
    //

    path = IopConstStringSize(USER_SYMLINK_STRING_PREFIX) + 1;

    //
    // Find the '\' seperator
    //

    pCurrent = SymbolicLinkName->Buffer + IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);

    for (current = 0;
         current < (SymbolicLinkName->Length / sizeof(WCHAR)) - IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);
         current++, pCurrent++) {

        if(*pCurrent == SEPERATOR_CHAR) {
            reference = current + 1 + IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);
            break;
        }

    }

    //
    // If we don't have a reference string fake it to where it would have been
    //

    if (reference == 0) {
        haveRefString = FALSE;
        reference = SymbolicLinkName->Length / sizeof(WCHAR) + 1;

    } else {
        haveRefString = TRUE;
    }

    //
    // Check the guid looks plausable
    //

    tempString.Length = GUID_STRING_SIZE;
    tempString.MaximumLength = GUID_STRING_SIZE;
    tempString.Buffer = SymbolicLinkName->Buffer + reference - GUID_STRING_LENGTH - 1;

    if (!NT_SUCCESS( RtlGUIDFromString(&tempString, &tempGuid) )) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    guid = reference - GUID_STRING_LENGTH - 1;

    //
    // Setup return strings
    //

    if (ARGUMENT_PRESENT(PrefixString)) {
        PrefixString->Length = IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX);
        PrefixString->MaximumLength = PrefixString->Length;
        PrefixString->Buffer = SymbolicLinkName->Buffer;
    }

    if (ARGUMENT_PRESENT(MungedPathString)) {
        MungedPathString->Length = (reference - 1 - GUID_STRING_LENGTH - 1 -
                                   IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX)) *
                                   sizeof(WCHAR);
        MungedPathString->MaximumLength = MungedPathString->Length;
        MungedPathString->Buffer = SymbolicLinkName->Buffer +
                                   IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);

    }

    if (ARGUMENT_PRESENT(GuidString)) {
        GuidString->Length = GUID_STRING_SIZE;
        GuidString->MaximumLength = GuidString->Length;
        GuidString->Buffer = SymbolicLinkName->Buffer + reference -
                             GUID_STRING_LENGTH - 1;
    }

    if (ARGUMENT_PRESENT(RefString)) {
        //
        // Check if we have a refstring
        //
        if (haveRefString) {
            RefString->Length = SymbolicLinkName->Length -
                                  (reference * sizeof(WCHAR));
            RefString->MaximumLength = RefString->Length;
            RefString->Buffer = SymbolicLinkName->Buffer + reference;
        } else {
            RefString->Length = 0;
            RefString->MaximumLength = 0;
            RefString->Buffer = NULL;
        }
    }

    if (ARGUMENT_PRESENT(RefStringPresent)) {
        *RefStringPresent = haveRefString;
    }

    if(ARGUMENT_PRESENT(Guid)) {
        *Guid = tempGuid;
    }

clean0:

    return status;

}

NTSTATUS
IopDoDeferredSetInterfaceState(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    Process the queued IoSetDeviceInterfaceState calls.

Parameters:

    DeviceNode - Device node which has just been started.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    KIRQL           irql;
    PDEVICE_OBJECT  attachedDevice;

    PiLockPnpRegistry(TRUE);

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (attachedDevice = DeviceNode->PhysicalDeviceObject;
         attachedDevice;
         attachedDevice = attachedDevice->AttachedDevice) {

        attachedDevice->DeviceObjectExtension->ExtensionFlags &= ~DOE_START_PENDING;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    while (!IsListEmpty(&DeviceNode->PendedSetInterfaceState)) {

        PPENDING_SET_INTERFACE_STATE entry;

        entry = (PPENDING_SET_INTERFACE_STATE)RemoveHeadList(&DeviceNode->PendedSetInterfaceState);

        IopProcessSetInterfaceState(&entry->LinkName, TRUE, FALSE);

        ExFreePool(entry->LinkName.Buffer);

        ExFreePool(entry);
    }

    PiUnlockPnpRegistry();

    return STATUS_SUCCESS;
}

NTSTATUS
IopProcessSetInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable,
    IN BOOLEAN DeferNotStarted
    )
/*++

Routine Description:

    This DDI allows a device class to activate and deactivate an association
    previously registered using IoRegisterDeviceInterface

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name which was
        returned by IoRegisterDeviceInterface when the interface was registered,
        or as returned by IoGetDeviceInterfaces.

    Enable - If TRUE (non-zero), the interface will be enabled.  If FALSE, it
        will be disabled.

    DeferNotStarted - If TRUE then enables will be queued if the PDO isn't
        started.  It is FALSE when we've started the PDO and are processing the
        queued enables.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    HANDLE hInterfaceClassKey = NULL;
    HANDLE hInterfaceParentKey= NULL, hInterfaceInstanceKey = NULL;
    HANDLE hInterfaceParentControl = NULL, hInterfaceInstanceControl = NULL;
    UNICODE_STRING tempString, deviceNameString;
    UNICODE_STRING actualSymbolicLinkName, globalSymbolicLinkName;
    PKEY_VALUE_FULL_INFORMATION pKeyValueInfo;
    ULONG linked, refcount;
    GUID guid;
    PDEVICE_OBJECT physicalDeviceObject;
    PWCHAR deviceNameBuffer = NULL;
    ULONG deviceNameBufferLength;

    PAGED_CODE();

    //
    // Check that the supplied symbolic link can be parsed to extract the device
    // class guid - note that this is also a way of verifying that the
    // SymbolicLinkName string is valid.
    //

    status = IopParseSymbolicLinkName(SymbolicLinkName,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &guid);
    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Get the symbolic link name without the ref string.
    //

    status = IopDropReferenceString(&actualSymbolicLinkName, SymbolicLinkName);

    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Symbolic links created for device interfaces should be visible to all
    // users, in all sessions, so we need to contruct an absolute name for
    // symbolic link in the global DosDevices namespace '\GLOBAL??'.  This
    // ensures that a global symbolic link will always be created or deleted by
    // IoSetDeviceInterfaceState, no matter what context it is called in.
    //

    status = IopBuildGlobalSymbolicLinkString(&actualSymbolicLinkName,
                                              &globalSymbolicLinkName);

    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Get function class instance handle
    //

    status = IopDeviceInterfaceKeysFromSymbolicLink(SymbolicLinkName,
                                                    KEY_READ | KEY_WRITE,
                                                    &hInterfaceClassKey,
                                                    &hInterfaceParentKey,
                                                    &hInterfaceInstanceKey
                                                    );

    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Open the parent interface control subkey
    //
    PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
    status = IopCreateRegistryKeyEx( &hInterfaceParentControl,
                                     hInterfaceParentKey,
                                     &tempString,
                                     KEY_READ,
                                     REG_OPTION_VOLATILE,
                                     NULL
                                     );
    if (!NT_SUCCESS(status)) {
        goto clean1;
    }


    //
    // Find out the name of the device instance that 'owns' this interface.
    //
    status = IopGetRegistryValue(hInterfaceParentKey,
                                 REGSTR_VAL_DEVICE_INSTANCE,
                                 &pKeyValueInfo
                                 );

    if(NT_SUCCESS(status)) {
        //
        // Open the device instance control subkey
        //
        PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
        status = IopCreateRegistryKeyEx( &hInterfaceInstanceControl,
                                         hInterfaceInstanceKey,
                                         &tempString,
                                         KEY_READ,
                                         REG_OPTION_VOLATILE,
                                         NULL
                                         );
        if(!NT_SUCCESS(status)) {
            ExFreePool(pKeyValueInfo);
            hInterfaceInstanceControl = NULL;
        }
    }

    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // Find the PDO corresponding to this device instance name.
    //
    if (pKeyValueInfo->Type == REG_SZ) {

        IopRegistryDataToUnicodeString(&tempString,
                                        (PWSTR)KEY_VALUE_DATA(pKeyValueInfo),
                                        pKeyValueInfo->DataLength
                                        );

        physicalDeviceObject = IopDeviceObjectFromDeviceInstance(&tempString);

        if (physicalDeviceObject) {

            //
            // DeferNotStarted is set TRUE if we are being called from
            // IoSetDeviceInterfaceState.  It will be set FALSE if we are
            // processing previously queued operations as we are starting the
            // device.
            //

            if (DeferNotStarted) {

                if (physicalDeviceObject->DeviceObjectExtension->ExtensionFlags & DOE_START_PENDING) {

                    PDEVICE_NODE deviceNode;
                    PPENDING_SET_INTERFACE_STATE pendingSetState;

                    //
                    // The device hasn't been started yet.  We need to queue
                    // any enables and remove items from the queue on a disable.
                    //
                    deviceNode = (PDEVICE_NODE)physicalDeviceObject->DeviceObjectExtension->DeviceNode;

                    if (Enable) {

                        pendingSetState = ExAllocatePool( PagedPool,
                                                          sizeof(PENDING_SET_INTERFACE_STATE));

                        if (pendingSetState != NULL) {

                            pendingSetState->LinkName.Buffer = ExAllocatePool( PagedPool,
                                                                               SymbolicLinkName->Length);

                            if (pendingSetState->LinkName.Buffer != NULL) {

                                //
                                // Capture the callers info and queue it to the
                                // devnode.  Once the device stack is started
                                // we will dequeue and process it.
                                //
                                pendingSetState->LinkName.MaximumLength = SymbolicLinkName->Length;
                                pendingSetState->LinkName.Length = SymbolicLinkName->Length;
                                RtlCopyMemory( pendingSetState->LinkName.Buffer,
                                               SymbolicLinkName->Buffer,
                                               SymbolicLinkName->Length);
                                InsertTailList( &deviceNode->PendedSetInterfaceState,
                                                &pendingSetState->List);

                                ExFreePool(pKeyValueInfo);

                                ObDereferenceObject(physicalDeviceObject);

                                status = STATUS_SUCCESS;
                                goto clean2;

                            } else {
                                //
                                // Couldn't allocate a buffer to hold the
                                // symbolic link name.
                                //

                                ExFreePool(pendingSetState);
                                status = STATUS_INSUFFICIENT_RESOURCES;
                            }

                        } else {
                            //
                            // Couldn't allocate the PENDING_SET_INTERFACE_STATE
                            // structure.
                            //


                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }

                    } else {

                        PLIST_ENTRY entry;

                        //
                        // We are disabling an interface.  Since we aren't
                        // started yet we should have queued the enable.  Now
                        // we go back and find the matching enable and remove
                        // it from the queue.
                        //

                        for (entry = deviceNode->PendedSetInterfaceState.Flink;
                             entry != &deviceNode->PendedSetInterfaceState;
                             entry = entry->Flink)  {

                            pendingSetState = CONTAINING_RECORD( entry,
                                                                 PENDING_SET_INTERFACE_STATE,
                                                                 List );

                            if (RtlEqualUnicodeString( &pendingSetState->LinkName,
                                                       SymbolicLinkName,
                                                       TRUE)) {

                                //
                                // We found it, remove it from the list and
                                // free it.
                                //
                                RemoveEntryList(&pendingSetState->List);

                                ExFreePool(pendingSetState->LinkName.Buffer);
                                ExFreePool(pendingSetState);

                                break;
                            }
                        }

#if 0
                        //
                        // Debug code to catch the case where we couldn't find
                        // the entry to remove.  This could happen if we messed
                        // up adding the entry to the list or the driver disabled
                        // an interface without first enabling it.  Either way
                        // it probably merits some investigation.
                        //
                        if (entry == &deviceNode->PendedSetInterfaceState) {
                            IopDbgPrint((IOP_ERROR_LEVEL,
                                       "IopProcessSetInterfaceState: Disable couldn't find deferred enable, DeviceNode = 0x%p, SymbolicLink = \"%Z\"\n",
                                       deviceNode,
                                       SymbolicLinkName));
                        }

                        ASSERT(entry != &deviceNode->PendedSetInterfaceState);
#endif
                        ExFreePool(pKeyValueInfo);

                        ObDereferenceObject(physicalDeviceObject);

                        status = STATUS_SUCCESS;
                        goto clean2;
                    }
                }
            }

            if (!Enable || !NT_SUCCESS(status)) {
                ObDereferenceObject(physicalDeviceObject);
            }
        } else {

            status = STATUS_INVALID_DEVICE_REQUEST;
        }

    } else {
        //
        // This will only happen if the registry information is messed up.
        //
        physicalDeviceObject = NULL;
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    if (!Enable) {
        //
        // In the case of Disable we want to continue even if there was an error
        // finding the PDO.  Prior to adding support for deferring the
        // IoSetDeviceInterfaceState calls, we never looked up the PDO for
        // disables.  This will make sure that we continue to behave the same as
        // we used to in the case where we can't find the PDO.
        //
        status = STATUS_SUCCESS;
    }

    ExFreePool(pKeyValueInfo);

    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    if (Enable) {
        //
        // Retrieve the PDO's device object name.  (Start out with a reasonably-sized
        // buffer so we hopefully only have to retrieve this once.
        //
        deviceNameBufferLength = 256 * sizeof(WCHAR);

        for ( ; ; ) {

            deviceNameBuffer = ExAllocatePool(PagedPool, deviceNameBufferLength);
            if (!deviceNameBuffer) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            status = IoGetDeviceProperty( physicalDeviceObject,
                                          DevicePropertyPhysicalDeviceObjectName,
                                          deviceNameBufferLength,
                                          deviceNameBuffer,
                                          &deviceNameBufferLength
                                         );

            if (NT_SUCCESS(status)) {
                break;
            } else {
                //
                // Free the current buffer before we figure out what went wrong.
                //
                ExFreePool(deviceNameBuffer);

                if (status != STATUS_BUFFER_TOO_SMALL) {
                    //
                    // Our failure wasn't because the buffer was too small--bail now.
                    //
                    break;
                }

                //
                // Otherwise, loop back and try again with our new buffer size.
                //
            }
        }

        //
        // OK, we don't need the PDO anymore.
        //
        ObDereferenceObject(physicalDeviceObject);

        if (!NT_SUCCESS(status) || deviceNameBufferLength == 0) {
            goto clean2;
        }

        //
        // Now create a unicode string based on the device object name we just retrieved.
        //

        RtlInitUnicodeString(&deviceNameString, deviceNameBuffer);
    }

    //
    // Retrieve the linked value from the control subkey.
    //
    pKeyValueInfo=NULL;
    status = IopGetRegistryValue(hInterfaceInstanceControl, REGSTR_VAL_LINKED, &pKeyValueInfo);

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // The absence of a linked value is taken to mean not linked
        //

        linked = 0;

    } else {
        if (!NT_SUCCESS(status)) {
            //
            // If the call failed, pKeyValueInfo was never allocated
            //
            goto clean3;
        }

        //
        // Check linked is a DWORD
        //

        if(pKeyValueInfo->Type == REG_DWORD && pKeyValueInfo->DataLength == sizeof(ULONG)) {

            linked = *((PULONG) KEY_VALUE_DATA(pKeyValueInfo));

        } else {

            //
            // The registry is messed up - assume linked is 0 and the registry will be fixed when
            // we update linked in a few moments
            //

            linked = 0;

        }

    }
    if (pKeyValueInfo) {
        ExFreePool (pKeyValueInfo);
    }

    //
    // Retrieve the refcount value from the control subkey.
    //

    PiWstrToUnicodeString(&tempString, REGSTR_VAL_REFERENCECOUNT);
    status = IopGetRegistryValue(hInterfaceParentControl,
                                 tempString.Buffer,
                                 &pKeyValueInfo
                                 );

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // The absence of a refcount value is taken to mean refcount == 0
        //

        refcount = 0;

    } else {
        if (!NT_SUCCESS(status)) {
            goto clean3;
        }

        //
        // Check refcount is a DWORD
        //

        if(pKeyValueInfo->Type == REG_DWORD && pKeyValueInfo->DataLength == sizeof(ULONG)) {

            refcount = *((PULONG) KEY_VALUE_DATA(pKeyValueInfo));

        } else {

            //
            // The registry is messed up - assume refcount is 0 and the registry will be fixed when
            // we update refcount in a few moments
            //

            refcount = 0;

        }

        ExFreePool(pKeyValueInfo);
    }


    if (Enable) {

        if (!linked) {
            //
            // check and update the reference count
            //

            if (refcount > 0) {
                //
                // Another device instance has already referenced this interface;
                // just increment the reference count; don't try create a symbolic link.
                //
                refcount += 1;
            } else {
                //
                // According to the reference count, no other device instances currently
                // reference this interface, and therefore no symbolic links should exist,
                // so we should create one.
                //
                refcount = 1;

                status = IoCreateSymbolicLink(&globalSymbolicLinkName, &deviceNameString);

                if (status == STATUS_OBJECT_NAME_COLLISION) {
                    //
                    // The reference count is messed up.
                    //
                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoSetDeviceInterfaceState: symbolic link for %ws already exists! status = %8.8X\n",
                                    globalSymbolicLinkName.Buffer, status));
                    status = STATUS_SUCCESS;
                }

            }

            linked = 1;

#if 0
            IopSetupDeviceObjectFromDeviceClass(physicalDeviceObject,
                                                hInterfaceClassKey);
#endif

        } else {

            //
            // The association already exists - don't perform the notification
            //

            status = STATUS_OBJECT_NAME_EXISTS; // Informational message not error
            goto clean3;

        }
    } else {

        if (linked) {

            //
            // check and update the reference count
            //

            if (refcount > 1) {
                //
                // Another device instance already references this interface;
                // just decrement the reference count; don't try to remove the symbolic link.
                //
                refcount -= 1;
            } else {
                //
                // According to the reference count, only this device instance currently
                // references this interface, so it is ok to delete this symbolic link
                //
                refcount = 0;
                status = IoDeleteSymbolicLink(&globalSymbolicLinkName);

                if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                    //
                    // The reference count is messed up.
                    //
                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoSetDeviceInterfaceState: no symbolic link for %ws to delete! status = %8.8X\n",
                             globalSymbolicLinkName.Buffer, status));
                    status = STATUS_SUCCESS;
                }

            }

            linked = 0;

        } else {

            //
            // The association does not exists - fail and do not perform notification
            //

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Update the value of linked
    //

    PiWstrToUnicodeString(&tempString, REGSTR_VAL_LINKED);
    status = ZwSetValueKey(hInterfaceInstanceControl,
                           &tempString,
                           0,
                           REG_DWORD,
                           &linked,
                           sizeof(linked)
                          );

    //
    // Update the value of refcount
    //

    PiWstrToUnicodeString(&tempString, REGSTR_VAL_REFERENCECOUNT);
    status = ZwSetValueKey(hInterfaceParentControl,
                           &tempString,
                           0,
                           REG_DWORD,
                           &refcount,
                           sizeof(refcount)
                          );


    //
    // Notify anyone that is interested
    //

    if (linked) {

        PpSetDeviceClassChange( (LPGUID) &GUID_DEVICE_INTERFACE_ARRIVAL, &guid, SymbolicLinkName);

    } else {

        PpSetDeviceClassChange( (LPGUID) &GUID_DEVICE_INTERFACE_REMOVAL, &guid, SymbolicLinkName);

    }

clean3:
    if (deviceNameBuffer != NULL) {
        ExFreePool(deviceNameBuffer);
    }

clean2:
    if (hInterfaceParentControl) {
        ZwClose(hInterfaceParentControl);
    }
    if (hInterfaceInstanceControl) {
        ZwClose(hInterfaceInstanceControl);
    }

clean1:

    IopFreeAllocatedUnicodeString(&globalSymbolicLinkName);

    if (hInterfaceParentKey) {
        ZwClose(hInterfaceParentKey);
    }
    if (hInterfaceInstanceKey) {
        ZwClose(hInterfaceInstanceKey);
    }
    if(hInterfaceClassKey != NULL) {
        ZwClose(hInterfaceClassKey);
    }

clean0:
    if (!NT_SUCCESS(status) && !Enable) {
        //
        // If we failed to disable an interface (most likely because the
        // interface keys have already been deleted) report success.
        //
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
IopSetRegistryStringValue(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN PUNICODE_STRING ValueData
    )

/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key.  The data
        will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);
    ASSERT(ValueName->Buffer);
    ASSERT(ValueData->Buffer);

    //
    // Null terminate the string
    //

    if ((ValueData->MaximumLength - ValueData->Length) >= sizeof(UNICODE_NULL)) {

        //
        // There is room in the buffer so just append a null
        //

        ValueData->Buffer[(ValueData->Length / sizeof(WCHAR))] = UNICODE_NULL;

        //
        // Set the registry value
        //

        status = ZwSetValueKey(KeyHandle,
                               ValueName,
                               0,
                               REG_SZ,
                               (PVOID) ValueData->Buffer,
                               ValueData->Length + sizeof(UNICODE_NULL)
                               );

    } else {

        UNICODE_STRING tempString;

        //
        // There is no room so allocate a new buffer and so we need to build
        // a new string with room
        //

        status = IopAllocateUnicodeString(&tempString, ValueData->Length);

        if (!NT_SUCCESS(status)) {
            goto clean0;
        }

        //
        // Copy the input string to the output string
        //

        tempString.Length = ValueData->Length;
        RtlCopyMemory(tempString.Buffer, ValueData->Buffer, ValueData->Length);

        //
        // Add the null termination
        //

        tempString.Buffer[tempString.Length / sizeof(WCHAR)] = UNICODE_NULL;

        //
        // Set the registry value
        //

        status = ZwSetValueKey(KeyHandle,
                               ValueName,
                               0,
                               REG_SZ,
                               (PVOID) tempString.Buffer,
                               tempString.Length + sizeof(UNICODE_NULL)
                               );

        //
        // Free the temporary string
        //

        IopFreeAllocatedUnicodeString(&tempString);

    }

clean0:
    return status;

}

NTSTATUS
IopAllocateUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT Length
    )

/*++

Routine Description:

    This routine allocates a buffer for a unicode string of a given length
    and initialises the UNICODE_STRING structure appropriately. When the
    string is no longer required it can be freed using IopFreeAllocatedString.
    The buffer also be directly deleted by ExFreePool and so can be handed
    back to a caller.

Parameters:

    String - Supplies a pointer to an uninitialised unicode string which will
        be manipulated by the function.

    Length - The number of BYTES long that the string will be.

Return Value:

    Either STATUS_INSUFFICIENT_RESOURCES indicating paged pool is exhausted or
    STATUS_SUCCESS.

Remarks:

    The buffer allocated will be one character (2 bytes) more than length specified.
    This is to allow for easy null termination of the strings - eg for registry
    storage.

--*/

{
    PAGED_CODE();

    String->Length = 0;
    String->MaximumLength = Length + sizeof(UNICODE_NULL);

    String->Buffer = ExAllocatePool(PagedPool, Length + sizeof(UNICODE_NULL));
    if (String->Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    } else {
        return STATUS_SUCCESS;
    }
}

VOID
IopFreeAllocatedUnicodeString(
    PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine frees a string previously allocated with IopAllocateUnicodeString.

Parameters:

    String - Supplies a pointer to the string that has been previously allocated.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(String);

    RtlFreeUnicodeString(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\dockhwp.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    dock.c

Abstract:


Author:

    Kenneth D. Ray (kenray) Feb 1998

Revision History:

--*/

#include "pnpmgrp.h"
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#include "..\config\cmp.h"
#include <string.h>
#include <profiles.h>
#include <wdmguid.h>

//
// Internal functions to dockhwp.c
//

NTSTATUS
IopExecuteHardwareProfileChange(
    IN  HARDWARE_PROFILE_BUS_TYPE   Bus,
    IN  PWCHAR                    * ProfileSerialNumbers,
    IN  ULONG                       SerialNumbersCount,
    OUT PHANDLE                     NewProfile,
    OUT PBOOLEAN                    ProfileChanged
    );

NTSTATUS
IopExecuteHwpDefaultSelect(
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse,
    IN  PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopExecuteHwpDefaultSelect)
#pragma alloc_text(PAGE, IopExecuteHardwareProfileChange)
#endif // ALLOC_PRAGMA


NTSTATUS
IopExecuteHwpDefaultSelect(
    IN  PCM_HARDWARE_PROFILE_LIST   ProfileList,
    OUT PULONG                      ProfileIndexToUse,
    IN  PVOID                       Context
    )
{
    UNREFERENCED_PARAMETER(ProfileList);
    UNREFERENCED_PARAMETER(Context);

    * ProfileIndexToUse = 0;

    return STATUS_SUCCESS;
}


NTSTATUS
IopExecuteHardwareProfileChange(
    IN  HARDWARE_PROFILE_BUS_TYPE   Bus,
    IN  PWCHAR                     *ProfileSerialNumbers,
    IN  ULONG                       SerialNumbersCount,
    OUT HANDLE                     *NewProfile,
    OUT BOOLEAN                    *ProfileChanged
    )
/*++

Routine Description:

    A docking event has occured and now, given a list of Profile Serial Numbers
    that describe the new docking state:
    Transition to the given docking state.
    Set the Current Hardware Profile to based on the new state.
    (Possibly Prompt the user if there is ambiguity)
    Send Removes to those devices that are turned off in this profile,

Arguments:
    Bus - This is the bus that is supplying the hardware profile change.
            (currently only HardwareProfileBusTypeAcpi is supported).

    ProfileSerialNumbers - A list of serial numbers (a list of null terminated
                           UCHAR lists) representing this new docking state.
                           These can be listed in any order, and form a
                           complete representation of the new docking state
    caused by a docking even on the given bus.  A Serial Number string of "\0"
    represents an "undocked state" and should not be listed with any other
    strings.  This list need not be sorted.

    SerialNumbersCount - The number of serial numbers listed.

    NewProfile - a handle to the registry key representing the new hardware
    profile (IE \CCS\HardwareProfiles\Current".)

    ProfileChanged - set to TRUE if new current profile (as a result of this
    docking event, is different that then old current profile.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    ULONG           len;
    ULONG           tmplen;
    ULONG           i, j;
    PWCHAR          tmpStr;
    UNICODE_STRING  tmpUStr;
    PUNICODE_STRING sortedSerials = NULL;

    PPROFILE_ACPI_DOCKING_STATE dockState = NULL;

    IopDbgPrint((   IOP_TRACE_LEVEL,
                    "Execute Profile (BusType %x), (SerialNumCount %x)\n", Bus, SerialNumbersCount));

    //
    // Sort the list of serial numbers
    //
    len = sizeof(UNICODE_STRING) * SerialNumbersCount;
    sortedSerials = ExAllocatePool(NonPagedPool, len);

    if (NULL == sortedSerials) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean;
    }

    for(i=0; i < SerialNumbersCount; i++) {

        RtlInitUnicodeString(&sortedSerials[i], ProfileSerialNumbers[i]);
    }

    //
    // I do not anticipate getting more than a few serial numbers, and I am
    // just lazy enough to write this comment and use a bubble sort.
    //
    for(i = 0; i < SerialNumbersCount; i++) {
        for(j = 0; j < SerialNumbersCount - 1; j++) {

            if (0 < RtlCompareUnicodeString(&sortedSerials[j],
                                            &sortedSerials[j+1],
                                            FALSE)) {

                tmpUStr = sortedSerials[j];
                sortedSerials[j] = sortedSerials[j+1];
                sortedSerials[j+1] = tmpUStr;
            }
        }
    }

    //
    // Construct the DockState ID
    //
    len = 0;
    for(i=0; i < SerialNumbersCount; i++) {

        len += sortedSerials[i].Length;
    }

    len += sizeof(WCHAR); // NULL termination;

    dockState = (PPROFILE_ACPI_DOCKING_STATE) ExAllocatePool(
        NonPagedPool,
        len + sizeof(PROFILE_ACPI_DOCKING_STATE)
        );

    if (NULL == dockState) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean;
    }

    for(i = 0, tmpStr = dockState->SerialNumber, tmplen = 0;
        i < SerialNumbersCount;
        i++) {

        tmplen = sortedSerials[i].Length;
        ASSERT(tmplen <= len - ((PCHAR)tmpStr - (PCHAR)dockState->SerialNumber));

        RtlCopyMemory(tmpStr, sortedSerials[i].Buffer, tmplen);
        (PCHAR) tmpStr += tmplen;
    }

    *(tmpStr++) = L'\0';

    ASSERT(len == (ULONG) ((PCHAR) tmpStr - (PCHAR) dockState->SerialNumber));
    dockState->SerialLength = (USHORT) len;

    if ((SerialNumbersCount > 1) || (L'\0' !=  dockState->SerialNumber[0])) {

        dockState->DockingState = HW_PROFILE_DOCKSTATE_DOCKED;

    } else {

        dockState->DockingState = HW_PROFILE_DOCKSTATE_UNDOCKED;
    }

    //
    // Set the new Profile
    //
    switch(Bus) {

        case HardwareProfileBusTypeACPI:

            status = CmSetAcpiHwProfile(
                dockState,
                IopExecuteHwpDefaultSelect,
                NULL,
                NewProfile,
                ProfileChanged
                );

            ASSERT(NT_SUCCESS(status) || (!(*ProfileChanged)));
            break;

        default:
            *ProfileChanged = FALSE;
            status = STATUS_NOT_SUPPORTED;
            goto Clean;
    }

Clean:

    if (NULL != sortedSerials) {

        ExFreePool(sortedSerials);
    }

    if (NULL != dockState) {

        ExFreePool(dockState);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\iofileutil.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    IoFileUtil.h

Abstract:

    This header exposes various file utility functions for the Io subsystem.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#define DIRWALK_INCLUDE_FILES           0x00000001
#define DIRWALK_INCLUDE_DIRECTORIES     0x00000002
#define DIRWALK_CULL_DOTPATHS           0x00000004
#define DIRWALK_TRAVERSE                0x00000008
#define DIRWALK_TRAVERSE_MOUNTPOINTS    0x00000010

typedef NTSTATUS (*DIRWALK_CALLBACK)(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    );

NTSTATUS
IopFileUtilWalkDirectoryTreeTopDown(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    );

NTSTATUS
IopFileUtilWalkDirectoryTreeBottomUp(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    );

NTSTATUS
IopFileUtilClearAttributes(
    IN PUNICODE_STRING  FullPathName,
    IN ULONG            FileAttributes
    );

NTSTATUS
IopFileUtilRename(
    IN PUNICODE_STRING  SourcePathName,
    IN PUNICODE_STRING  DestinationPathName,
    IN BOOLEAN          ReplaceIfPresent
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\iopfileutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    IopFileUtil.h

Abstract:

    This header contains private information to implement various file utility
    functions for the Io subsystem. This file is mean to be included only by
    IoFileUtil.c.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

typedef struct {

    LIST_ENTRY Link;
    UNICODE_STRING Directory;
    WCHAR Name[1];

} DIRWALK_ENTRY, *PDIRWALK_ENTRY;

NTSTATUS
IopFileUtilWalkDirectoryTreeHelper(
    IN      PUNICODE_STRING  Directory,
    IN      ULONG            Flags,
    IN      DIRWALK_CALLBACK CallbackFunction,
    IN      PVOID            Context,
    IN      PUCHAR           Buffer,
    IN      ULONG            BufferSize,
    IN OUT  PLIST_ENTRY      DirList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\mapper.c ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    mapper.c

Abstract:

    This module contains the code that manipulates the ARC firmware
    tree and other elements in the registry.

Author:

    Bob Rinne (BobRi) 15-Oct-1994

Environment:

    Kernel mode

Revision History :

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'rpaM')
#endif


//
// This contains information obtained by checking the firmware
// tree of the registry
//

typedef struct _FIRMWARE_CONFIGURATION {
    struct _FIRMWARE_CONFIGURATION *Next;
    INTERFACE_TYPE     BusType;
    ULONG              BusNumber;
    CONFIGURATION_TYPE ControllerType;
    ULONG              ControllerNumber;
    CONFIGURATION_TYPE PeripheralType;
    ULONG              PeripheralNumber;
    ULONG              NumberBases;
    ULONG              ResourceDescriptorSize;
    PVOID              ResourceDescriptor;
    ULONG              IdentifierLength;
    ULONG              IdentifierType;
    PVOID              Identifier;
    WCHAR const*       PnPId;
    BOOLEAN            NewlyCreated;
} FIRMWARE_CONFIGURATION, *PFIRMWARE_CONFIGURATION;

//
// Device extension information
//

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT     DeviceObject;
    PDRIVER_OBJECT     DriverObject;
    INTERFACE_TYPE     InterfaceType;
    ULONG              BusNumber;
    PFIRMWARE_CONFIGURATION FirmwareList;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
//
// mapping table from firmware to enum
//

typedef struct _FIRMWARE_IDENT_TO_PNP_ID {
    PWCHAR  FirmwareName;
    PWCHAR  PnPId;
} FIRMWARE_IDENT_TO_PNP_ID, *PFIRMWARE_IDENT_TO_PNP_ID;

//
// table to hold seed information for a firmware tree entry.
//

#define OPTIONS_NONE                    0x00000000
#define OPTIONS_INSERT_PNP_ID           0x00000001
#define OPTIONS_INSERT_DEVICEDESC       0x00000002
#define OPTIONS_INSERT_COMPATIBLE_IDS   0x00000004
#define OPTIONS_INSERT_PHANTOM_MARKER   0x00000008
typedef struct _MAPPER_SEED {
    PWCHAR  ValueName;
    ULONG   ValueType;
    ULONG   DwordValueContent;
    ULONG   Options;
} MAPPER_SEED, *PMAPPER_SEED;

//
// table to hold key names and attributes for construction
// in the root enumerator tree
//

#define KEY_SEED_REQUIRED               0x00000000
#define KEY_SEED_DEVICE_PARAMETERS      0x00000001
typedef struct _KEY_SEED {
    PWCHAR  KeyName;
    ULONG   Attribute;
    ULONG   Options;
} KEY_SEED, *PKEY_SEED;


//
// All the data here is INIT only
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#pragma data_seg("INITDATA")
#endif

DEVICE_EXTENSION MapperDeviceExtension;

//
// This table is used to translate the firmware tree information
// to the root enumerator PNP id for keyboard devices.
//

const FIRMWARE_IDENT_TO_PNP_ID KeyboardMap[] = {
    L"XT_83KEY",        L"*PNP0300",
    L"PCAT_86KEY",      L"*PNP0301",
    L"PCXT_84KEY",      L"*PNP0302",
    L"XT_84KEY",        L"*PNP0302",
    L"101-KEY",         L"*PNP0303",
    L"OLI_83KEY",       L"*PNP0304",
    L"ATT_301",         L"*PNP0304",
    L"OLI_102KEY",      L"*PNP0305",
    L"OLI_86KEY",       L"*PNP0306",
    L"OLI_A101_102KEY", L"*PNP0309",
    L"ATT_302",         L"*PNP030a",
    L"PCAT_ENHANCED",   L"*PNP030b",
    L"PC98_106KEY",     L"*nEC1300",
    L"PC98_LaptopKEY",  L"*nEC1300",
    L"PC98_N106KEY",    L"*PNP0303",
    NULL, NULL
};

#define PS2_KEYBOARD_COMPATIBLE_ID  L"PS2_KEYBOARD"
#define PS2_MOUSE_COMPATIBLE_ID     L"PS2_MOUSE"

//
// This table is used to translate the firmware tree information
// to the root enumerator PNP id for pointer devices.
//

const FIRMWARE_IDENT_TO_PNP_ID PointerMap[] = {
    L"PS2 MOUSE",                        L"*PNP0F0E",
    L"SERIAL MOUSE",                     L"*PNP0F0C",
    L"MICROSOFT PS2 MOUSE",              L"*PNP0F03",
    L"LOGITECH PS2 MOUSE",               L"*PNP0F12",
    L"MICROSOFT INPORT MOUSE",           L"*PNP0F02",
    L"MICROSOFT SERIAL MOUSE",           L"*PNP0F01",
    L"MICROSOFT BALLPOINT SERIAL MOUSE", L"*PNP0F09",
    L"LOGITECH SERIAL MOUSE",            L"*PNP0F08",
    L"MICROSOFT BUS MOUSE",              L"*PNP0F00",
    L"NEC PC-9800 BUS MOUSE",            L"*nEC1F00",
    NULL, NULL
};

//
// the MapperValueSeed table is a NULL terminated table (i.e. the name
// pointer is NULL) that contains the list of values and their type
// for insertion in a newly created root enumerator key.
//

const MAPPER_SEED MapperValueSeed[] = {
    REGSTR_VALUE_HARDWAREID,       REG_MULTI_SZ, 0, OPTIONS_INSERT_PNP_ID,
    REGSTR_VALUE_COMPATIBLEIDS,    REG_MULTI_SZ, 0, OPTIONS_INSERT_COMPATIBLE_IDS,
    REGSTR_VAL_FIRMWAREIDENTIFIED, REG_DWORD,    1, OPTIONS_NONE,
    REGSTR_VAL_DEVDESC,            REG_SZ,       0, OPTIONS_INSERT_DEVICEDESC,
    REGSTR_VAL_PHANTOM,            REG_DWORD,    1, OPTIONS_INSERT_PHANTOM_MARKER,
    NULL, 0, 0, 0
};

//
// the MapperKeySeed table is a NULL terminated table (i.e. the name
// pointer is NULL) that contains the list of keys to and their
// attributes (volatile or non-volatile) for keys to be created under
// a newly created root enumerator key.
//
// The preceeding backslash is required on all entries in this table.
//

const KEY_SEED MapperKeySeed[] = {
    L"\\Control",           REG_OPTION_VOLATILE,     KEY_SEED_REQUIRED,
    L"\\LogConf",           REG_OPTION_NON_VOLATILE, KEY_SEED_REQUIRED,
    L"",                    REG_OPTION_NON_VOLATILE, KEY_SEED_DEVICE_PARAMETERS,
    NULL, 0, 0
};

//
// SerialId is used as the PNP id for all serial controllers.
// NOTE: there is no code to detect presense of a 16550.
//

const WCHAR SerialId[] = L"*PNP0501"; // RDR should be two entries.  *PNP0501 is 16550

//
// ParallelId is used as the PNP id for all parallel controllers.
// NOTE: there is no code to detect presense of ECP support.
//

const WCHAR ParallelId[] = L"*PNP0400"; // RDR should be two entries.  *PNP0401 is ECP

//
// FloppyId is used as the PNP id for all floppy peripherals.
//

const WCHAR FloppyId[] = L"*PNP0700";

//
// ATAId is here, but not used - there is nothing in the firmware
// tree for the IDE controller.
//

const WCHAR ATAId[] = L"*PNP0600";

//
// Proto type declarations
//

FIRMWARE_IDENT_TO_PNP_ID const*
MapperFindIdentMatch(
    FIRMWARE_IDENT_TO_PNP_ID const* IdentTable,
    PWCHAR String
    );

WCHAR const*
MapperTranslatePnPId(
    CONFIGURATION_TYPE PeripheralType,
    PKEY_VALUE_FULL_INFORMATION Identifier
    );

NTSTATUS
MapperPeripheralCallback(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
MapperCallback(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

VOID
MapperMarkKey(
    IN HANDLE Handle,
    IN PUNICODE_STRING  PathName,
    IN PFIRMWARE_CONFIGURATION FirmwareEntry
    );

VOID
MapperSeedKey(
    IN HANDLE                  Handle,
    IN PUNICODE_STRING         PathName,
    IN PFIRMWARE_CONFIGURATION FirmwareEntry,
    IN BOOLEAN                 DeviceIsPhantom
    );

PCM_RESOURCE_LIST
MapperAdjustResourceList (
    IN     PCM_RESOURCE_LIST ResourceList,
    IN     WCHAR const*      PnPId,
    IN OUT PULONG            Size
    );

NTSTATUS
ComPortDBAdd(
    IN  HANDLE  DeviceParamKey,
    IN  PWSTR   PortName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, MapperFindIdentMatch)
#pragma alloc_text(INIT, MapperTranslatePnPId)
#pragma alloc_text(INIT, MapperPeripheralCallback)
#pragma alloc_text(INIT, MapperCallback)
#pragma alloc_text(INIT, MapperProcessFirmwareTree)
#pragma alloc_text(INIT, MapperMarkKey)
#pragma alloc_text(INIT, MapperSeedKey)
#pragma alloc_text(INIT, MapperFreeList)
#pragma alloc_text(INIT, MapperConstructRootEnumTree)
#pragma alloc_text(INIT, MapperAdjustResourceList)
#pragma alloc_text(INIT, ComPortDBAdd)
#pragma alloc_text(INIT, MapperPhantomizeDetectedComPorts)
#endif

FIRMWARE_IDENT_TO_PNP_ID const*
MapperFindIdentMatch(
    FIRMWARE_IDENT_TO_PNP_ID const* IdentTable,
    PWCHAR                    String
    )

/*++

Routine Description:

    Given a table of strings to match, find the match for
    the identifier given.

Arguments:

Return Value:

    A pointer to the ident table entry for the match if found
    NULL if not found.

--*/

{
    FIRMWARE_IDENT_TO_PNP_ID const* entry;

    entry = IdentTable;
    while (entry->FirmwareName) {
        if (!wcscmp(String, entry->FirmwareName)) {
            return entry;
        }
        entry++;
    }
    return NULL;
}

WCHAR const*
MapperTranslatePnPId(
    CONFIGURATION_TYPE          PeripheralType,
    PKEY_VALUE_FULL_INFORMATION Identifier
    )

/*++

Routine Description:

    Given the peripheral type and a location in the firmware tree
    this routine will determine the PnP Id to be used when constructing
    the root enumeration portion of the registry.

Arguments:

    PeripheralType - the type of item being translated (keyboard, mouse, etc)
    PathName       - the registry path name into the firmware tree for
                     this device.

Return Value:

    A pointer to the PnP Id string if a map is found.

--*/

{
    FIRMWARE_IDENT_TO_PNP_ID const* identMap;
    PWSTR identifierString = NULL;
    WCHAR const* idStr;

    if (Identifier) {
        identifierString = (PWSTR)((PUCHAR)Identifier + Identifier->DataOffset);
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "Mapper: identifier = %ws\n\tType = ",
                    identifierString));
    }

    idStr = NULL;
    switch (PeripheralType) {
    case DiskController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "DiskController",
                    PeripheralType));
        idStr = FloppyId;
        break;

    case SerialController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "SerialController",
                    PeripheralType));
        idStr = SerialId;
        break;

    case ParallelController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "ParallelController",
                    PeripheralType));
        idStr = ParallelId;
        break;

    case PointerController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "PointerController",
                    PeripheralType));
        idStr = PointerMap[0].PnPId;
        break;

    case KeyboardController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "KeyboardController",
                    PeripheralType));
        idStr = KeyboardMap[0].PnPId;
        break;

    case DiskPeripheral:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "DiskPeripheral",
                    PeripheralType));
        break;

    case FloppyDiskPeripheral:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "FloppyDiskPeripheral",
                    PeripheralType));
        idStr = FloppyId;
        break;

    case PointerPeripheral:
        if (identifierString) {
            identMap = MapperFindIdentMatch(PointerMap, identifierString);
            if (identMap) {
                IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                            "%ws\n",
                            identMap->PnPId));
                idStr = identMap->PnPId;
            } else {
                IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                            "Mapper: No pointer match found\n"));
            }
        } else {
            IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                        "Mapper: No identifier specified\n"));
        }
        break;

    case KeyboardPeripheral:
        if (identifierString) {
            identMap = MapperFindIdentMatch(KeyboardMap, identifierString);

            if (identMap) {
                IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                            "%ws\n",
                            identMap->PnPId));
                idStr = identMap->PnPId;
            } else {
                IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                            "Mapper: No keyboard match found\n"));
            }
        } else {
            IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                        "Mapper: No identifier specified\n"));
        }
        break;

    default:
        IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                    "Mapper: Unknown device (%d)\n",
                    PeripheralType));
        break;
    }
    return idStr;
}


NTSTATUS
MapperPeripheralCallback(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This routine is used to acquire firmware tree information about
    pointer devices in the system.

Arguments:

    Context               - Pointer to the device extension.
    PathName              - unicode registry path.
    BusType               - Internal, Isa, ...
    BusNumber             - Which bus if we are on a multibus system.
    BusInformation        - Configuration information about the bus. Not Used.
    ControllerType        - serial or ata disk.
    ControllerNumber      - Which controller if there is more than one
                            controller in the system.
    ControllerInformation - Array of pointers to the three pieces of
                            registry information.
    PeripheralType        - Undefined for this call.
    PeripheralNumber      - Undefined for this call.
    PeripheralInformation - Undefined for this call.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the device object, or
    all of the resource information couldn't be acquired.

--*/

{
    PFIRMWARE_CONFIGURATION     firmwareEntry = Context;
    PKEY_VALUE_FULL_INFORMATION information;
    ULONG                       dataLength;
    PWCHAR                      ptr;
    PVOID                       temp;

    UNREFERENCED_PARAMETER( BusType );
    UNREFERENCED_PARAMETER( BusNumber );
    UNREFERENCED_PARAMETER( BusInformation );
    UNREFERENCED_PARAMETER( ControllerType );
    UNREFERENCED_PARAMETER( ControllerNumber );

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: peripheral registry location is\n %ws\n",
                PathName->Buffer));

    if (!ControllerInformation) {
        IopDbgPrint((IOP_MAPPER_VERBOSE_LEVEL,
                    "Mapper: No component information\n"));
    }
    if (!PeripheralInformation) {
        IopDbgPrint((IOP_MAPPER_VERBOSE_LEVEL,
                    "Mapper: No peripheral information\n"));
        return STATUS_SUCCESS;
    }

    //
    // Map the PnP Id for this device.
    //

    if (PeripheralInformation[IoQueryDeviceIdentifier]) {
        information = PeripheralInformation[IoQueryDeviceIdentifier];
        firmwareEntry->PnPId = MapperTranslatePnPId(PeripheralType, information);

        if (firmwareEntry->PnPId) {
            //
            // Remember the peripheral's identifier (if it has one, and it's a REG_SZ value)
            // for use as the default PnP device description.
            //

            if (((dataLength = information->DataLength) > sizeof(WCHAR)) &&
                (information->Type == REG_SZ)) {

                ptr = (PWCHAR) ((PUCHAR)information + information->DataOffset);

                if (*ptr) {
                    temp = ExAllocatePool(NonPagedPool, dataLength);
                    if (temp) {

                        //
                        // If there's already an identifier here (from the peripheral's
                        // controller) then wipe it out.
                        //

                        if(firmwareEntry->Identifier) {
                            ExFreePool(firmwareEntry->Identifier);
                        }

                        //
                        // Move the data
                        //

                        firmwareEntry->Identifier = temp;
                        firmwareEntry->IdentifierType = information->Type;
                        firmwareEntry->IdentifierLength = dataLength;
                        RtlCopyMemory(temp, ptr, dataLength);
                    }
                }
            }
        }
    }

    //
    // Save the ordinals for the peripheral type and number
    //

    firmwareEntry->PeripheralType = PeripheralType;
    firmwareEntry->PeripheralNumber = PeripheralNumber;

    return STATUS_SUCCESS;
}

NTSTATUS
MapperCallback(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This routine is used to acquire firmware tree information about
    pointer devices in the system.

Arguments:

    Context               - Pointer to the device extension.
    PathName              - unicode registry path.
    BusType               - Internal, Isa, ...
    BusNumber             - Which bus if we are on a multibus system.
    BusInformation        - Configuration information about the bus. Not Used.
    ControllerType        - serial or ata disk.
    ControllerNumber      - Which controller if there is more than one
                            controller in the system.
    ControllerInformation - Array of pointers to the three pieces of
                            registry information.
    PeripheralType        - Undefined for this call.
    PeripheralNumber      - Undefined for this call.
    PeripheralInformation - Undefined for this call.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the device object, or
    all of the resource information couldn't be acquired.

--*/

{
    PDEVICE_EXTENSION               deviceExtension = Context;
    PCM_FULL_RESOURCE_DESCRIPTOR    controllerData;
    PKEY_VALUE_FULL_INFORMATION     information;
    PFIRMWARE_CONFIGURATION         firmwareEntry;
    CONFIGURATION_TYPE              peripheralType;
    PUCHAR                          buffer;
    ULONG                           dataLength;

    UNREFERENCED_PARAMETER( BusInformation );
    UNREFERENCED_PARAMETER( PeripheralType );
    UNREFERENCED_PARAMETER( PeripheralNumber );
    UNREFERENCED_PARAMETER( PeripheralInformation );

    //
    // If entry is found, but there is no information just return
    //

    information = ControllerInformation[IoQueryDeviceConfigurationData];
    if (information == NULL) {

        return STATUS_SUCCESS;
    }

    dataLength = information->DataLength;
    if (dataLength == 0) {

        return STATUS_SUCCESS;
    }

    //
    // Setup to capture the information from the firmware tree
    //

    firmwareEntry = ExAllocatePool(NonPagedPool, sizeof(FIRMWARE_CONFIGURATION));
    if (!firmwareEntry) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(firmwareEntry, sizeof(FIRMWARE_CONFIGURATION));

    //
    // Save information concerning the controller
    //

    firmwareEntry->ControllerType   = ControllerType;
    firmwareEntry->ControllerNumber = ControllerNumber;
    firmwareEntry->BusNumber = BusNumber;
    firmwareEntry->BusType   = BusType;

    //
    // Save the resource descriptor
    //

    buffer = firmwareEntry->ResourceDescriptor = ExAllocatePool(NonPagedPool,
                                                                dataLength);

    if (!buffer) {
        ExFreePool(firmwareEntry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Save the configuration information on this controller.
    //

    controllerData = (PCM_FULL_RESOURCE_DESCRIPTOR)
        ((PUCHAR)information + information->DataOffset);
    RtlCopyMemory(buffer, controllerData, dataLength);
    firmwareEntry->ResourceDescriptorSize = dataLength;

    //
    // If there is a device identifier save it.
    //

    information = ControllerInformation[IoQueryDeviceIdentifier];
    if (information != NULL) {
        PWCHAR ptr;

        dataLength = information->DataLength;
        if (dataLength != 0) {

            ptr = (PWCHAR) ((PUCHAR)information + information->DataOffset);
            if (ControllerType == ParallelController) {
                PWCHAR tmpChar;

                //
                // Some extra mapping is performed here to
                // translate the firmware names to LPT names.
                //

                *ptr++ = (WCHAR) 'L';
                *ptr++ = (WCHAR) 'P';
                *ptr++ = (WCHAR) 'T';

                //
                // Find the number.
                //

                tmpChar = ptr;
                while (*tmpChar) {
                    if ((*tmpChar >= (WCHAR) '0') &&
                        (*tmpChar <= (WCHAR) '9')) {
                        break;
                    }
                    tmpChar++;
                }

                if (*tmpChar) {
                    while (*tmpChar) {
                        *ptr++ = *tmpChar++;
                    }
                    *ptr = (WCHAR) 0;

                    //
                    // Update the datalength to be 4 wchars and eos and
                    // restore the pointer.
                    //

                    ptr = (PWCHAR) ((PUCHAR)information + information->DataOffset);
                    dataLength = 10;
                } else {
                    dataLength = 0;
                    IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                                "Mapper: no parallel port number!\n"));
                }
            }

            if (dataLength) {
                firmwareEntry->Identifier = ExAllocatePool(NonPagedPool,
                                                           dataLength);
                if (firmwareEntry->Identifier) {

                    //
                    // Move the data
                    //

                    firmwareEntry->IdentifierType = information->Type;
                    firmwareEntry->IdentifierLength = dataLength;
                    RtlCopyMemory(firmwareEntry->Identifier, ptr, dataLength);
                }
            }
        }
    }

    //
    // For some controllers, search the peripheral information
    //

    switch (ControllerType) {
    case SerialController:
    case ParallelController:
        //
        // Don't look for a peripheral.
        //
        peripheralType = (CONFIGURATION_TYPE) 0;
        break;
    case DiskController:
        peripheralType = FloppyDiskPeripheral;
        break;
    case KeyboardController:
        peripheralType = KeyboardPeripheral;
        break;
    case PointerController:
        peripheralType = PointerPeripheral;
        break;
    default:
        peripheralType = (CONFIGURATION_TYPE) 0;
        break;
    }

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: registry location is\n %ws\n",
                PathName->Buffer));

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: ControllerInformation[] -\n\tIdent: %x -\n\tData: %x -\n\tInformation: %x\n",
                ControllerInformation[0],
                ControllerInformation[1],
                ControllerInformation[2]));

    if (peripheralType) {
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "Mapper: searching for peripheral type %d\n",
                    peripheralType));

        IoQueryDeviceDescription(&BusType,
                                 &BusNumber,
                                 &ControllerType,
                                 &ControllerNumber,
                                 &peripheralType,
                                 NULL,
                                 MapperPeripheralCallback,
                                 firmwareEntry);
    }

    //
    // firmwareEntry->PnPId will be NULL if there are no peripherals of this
    // type in the tree or if the peripheral's description doesn't match one of
    // those in our table.
    //
    // firmwareEntry->PeripheralType will be equal to peripheralType if we found
    // one of the proper type regardless of whether or not it is in the table.
    //
    // So this test just ensures that we fallback to the controller IDs in the
    // case were there is no peripheral entry.  If there is a peripheral entry
    // that we don't understand we will suppress the entire node.
    //
    // This prevents creating devices with hw ids of bogus as we were seeing on
    // the SGI x86 ARC machines.
    //

    if (!firmwareEntry->PnPId && firmwareEntry->PeripheralType == 0) {

        //
        // Attempt to get PnPId from the controller type.
        //

        firmwareEntry->PnPId = MapperTranslatePnPId(ControllerType, NULL);

        if (!firmwareEntry->PnPId) {
            IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                        "Mapper: NO PnP Id for\n ==> %ws\n",
                        PathName->Buffer));
        }
    }

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: constructed name %d_%d_%d_%d_%d_%d\n",
                firmwareEntry->BusType,
                firmwareEntry->BusNumber,
                firmwareEntry->ControllerType,
                firmwareEntry->ControllerNumber,
                firmwareEntry->PeripheralType,
                firmwareEntry->PeripheralNumber));

    if (firmwareEntry->PnPId) {

        //
        // Link into chain of entries.
        //

        firmwareEntry->Next = deviceExtension->FirmwareList;
        deviceExtension->FirmwareList = firmwareEntry;
    } else {

        //
        // No map found - don't remember this entry.
        //

        ExFreePool(buffer);
        if(firmwareEntry->Identifier) {
            ExFreePool(firmwareEntry->Identifier);
        }
        ExFreePool(firmwareEntry);
    }
    return STATUS_SUCCESS;
}


VOID
MapperProcessFirmwareTree(
    IN BOOLEAN OnlyProcessSerialPorts
    )

/*++

Routine Description:

    Query the information in the firmware tree to know what
    system board devices were located.  This will cause a FirmwareList
    to be created on the device extention passed.

Arguments:

    OnlyProcessSerialPorts - if non-zero, then we'll only look at serial ports.
        This is done on ACPI machines where, in general, we don't want to pay
        attention to ntdetect/firmware information (but we have to for serial
        ports so that legacy add-in ISA serial ports and modems are detected
        automatically as in previous versions of NT as well as Win9x).

Return Value:

    None

--*/

{
    INTERFACE_TYPE     interfaceType;
    ULONG              index;
    CONFIGURATION_TYPE sc;
    CONFIGURATION_TYPE controllerTypes[] = { PointerController,
                                             KeyboardController,
                                             ParallelController,
                                             DiskController,
                                             FloppyDiskPeripheral,
                                             SerialController   // must be last
                                           };
#define CONTROLLER_TYPES_COUNT (sizeof(controllerTypes) / sizeof(controllerTypes[0]))

    PAGED_CODE();

    //
    // Locate all firmware controller information and save its resource usage.
    //
    // It's pretty inefficient to be going through all interface types, when we
    // really only care about a very small subset of non-PnP buses (e.g., ISA,
    // EISA, maybe Internal).
    //

    for (interfaceType = 0; interfaceType < MaximumInterfaceType; interfaceType++) {

        IopDbgPrint((IOP_MAPPER_VERBOSE_LEVEL,
                    "Mapper: searching on interface ===> %d\n",
                    interfaceType));

        if(OnlyProcessSerialPorts) {

            //
            // Start out at the last element of the array, so we only process
            // SerialControllers.
            //

            index = CONTROLLER_TYPES_COUNT - 1;
        } else {
            index = 0;
        }

        for ( ; index < CONTROLLER_TYPES_COUNT; index++) {
            sc = controllerTypes[index];

            IoQueryDeviceDescription(&interfaceType,
                                     NULL,
                                     &sc,
                                     NULL,
                                     NULL,
                                     NULL,
                                     MapperCallback,
                                     &MapperDeviceExtension);
        }
    }
}


VOID
MapperMarkKey(
    IN HANDLE           Handle,
    IN PUNICODE_STRING  PathName,
    IN PFIRMWARE_CONFIGURATION FirmwareEntry
    )

/*++

Routine Description:

    Record in the root enum key that the firmware mapper found this entry.
    Migrate configuration information entries.

Arguments:

    Handle   - handle to the key
    PathName - base path name to this key
    FirmwareEntry - information from the firmware tree.

Return Value:

    None

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    PCM_RESOURCE_LIST resourceList;
    UNICODE_STRING    unicodeName;
    NTSTATUS          status;
    HANDLE            subKeyHandle;
    PWCHAR            wcptr;
    ULONG             disposition;
    ULONG             buffer;
    USHORT            originalLength;

    //
    // Mark that this entry was in the firmware tree.
    //

    buffer = 1;
    PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_FIRMWAREIDENTIFIED);

    ZwSetValueKey(Handle,
                  &unicodeName,
                  0,
                  REG_DWORD,
                  &buffer,
                  sizeof(ULONG));

    //
    // Create the control subkey
    //

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: marking existing key\n"));
    originalLength = PathName->Length;
    wcptr = (PWCHAR) ((PUCHAR)PathName->Buffer + PathName->Length);
    wcptr++; // locate eos

    //
    // Build the volatile control key
    //

    InitializeObjectAttributes(&objectAttributes,
                               PathName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    RtlAppendUnicodeToString(PathName, L"\\Control");
    status = ZwCreateKey(&subKeyHandle,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         &disposition);

    if (NT_SUCCESS(status)) {

        //
        // Create the found by firmware volatile.
        //

        buffer = 1;
        PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_FIRMWAREMEMBER);

        ZwSetValueKey(subKeyHandle,
                      &unicodeName,
                      0,
                      REG_DWORD,
                      &buffer,
                      sizeof(ULONG));
        ZwClose(subKeyHandle);

    } else {

        //
        // ignore failures
        //

        IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                    "Mapper: failed to mark control key %x\n",
                    status));
    }

    //
    // if there is a resource descriptor, restore path and open LogConf key.
    //

    if (FirmwareEntry->ResourceDescriptor) {
        PathName->Length = originalLength;
        *wcptr = (WCHAR) 0;

        InitializeObjectAttributes(&objectAttributes,
                                   PathName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        RtlAppendUnicodeToString(PathName, L"\\LogConf");
        status = ZwCreateKey(&subKeyHandle,
                             KEY_READ | KEY_WRITE,
                             &objectAttributes,
                             0,
                             NULL,
                             REG_OPTION_VOLATILE,
                             &disposition);

        if (NT_SUCCESS(status)) {
            ULONG size;

            //
            // two entries need to be made:
            // BootConfig:REG_RESOURCE_LIST
            // BasicConfigVector:REG_RESOURCE_REQUIREMENTS_LIST
            //

            size = sizeof(CM_RESOURCE_LIST) -
                   sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                   FirmwareEntry->ResourceDescriptorSize;

            resourceList = ExAllocatePool(NonPagedPool, size);

            if (resourceList) {

                resourceList->Count = 1;
                RtlCopyMemory(&resourceList->List[0],
                              FirmwareEntry->ResourceDescriptor,
                              FirmwareEntry->ResourceDescriptorSize);

                resourceList = MapperAdjustResourceList (
                                   resourceList,
                                   FirmwareEntry->PnPId,
                                   &size
                                   );

                PiWstrToUnicodeString(&unicodeName,
                                     L"BootConfig");
                ZwSetValueKey(subKeyHandle,
                              &unicodeName,
                              0,
                              REG_RESOURCE_LIST,
                              resourceList,
                              size);
#if 0
                //
                // Now do the resource requirements list.
                //

                reqList = IopCmResourcesToIoResources(0, resourceList);

                if (reqList) {
                    PiWstrToUnicodeString(&unicodeName,
                                         L"BasicConfigVector");
                    ZwSetValueKey(subKeyHandle,
                                  &unicodeName,
                                  0,
                                  REG_RESOURCE_REQUIREMENTS_LIST,
                                  reqList,
                                  reqList->ListSize);
                    ExFreePool(reqList);
                }
#endif
                ExFreePool(resourceList);
            }

            ZwClose(subKeyHandle);

        } else {

            //
            // ignore errors
            //

            IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                        "Mapper: failed to update logconf key %x\n",
                        status));
        }
    }

    //
    // Restore path passed in.
    //

    PathName->Length = originalLength;
    *wcptr = (WCHAR) 0;
}

VOID
MapperSeedKey(
    IN HANDLE                  Handle,
    IN PUNICODE_STRING         PathName,
    IN PFIRMWARE_CONFIGURATION FirmwareEntry,
    IN BOOLEAN                 DeviceIsPhantom
    )

/*++

Routine Description:

    This routine seeds a registry key with enough information
    to get PnP to run the class installer on the devnode.

Arguments:

    Handle          - handle to the key

    PathName        - base path name to this key

    FirmwareEntry   - information from the firmware tree

    DeviceIsPhantom - if non-zero, add "Phantom" value entry so the root
        enumerator will skip this device instance (i.e., not turn it into a
        devnode)

Return Value:

    None

--*/

{
#define SEED_BUFFER_SIZE (512 * sizeof(WCHAR))
    UNICODE_STRING    unicodeName;
    OBJECT_ATTRIBUTES objectAttributes;
    MAPPER_SEED const* valueSeed;
    KEY_SEED const*   keySeed;
    NTSTATUS          status;
    HANDLE            subKeyHandle;
    WCHAR const*      pnpid;
    PWCHAR            buffer;
    PWCHAR            wcptr;
    ULONG             disposition;
    ULONG             size;
    USHORT            originalLength;

    buffer = ExAllocatePool(NonPagedPool, SEED_BUFFER_SIZE);
    if (!buffer) {
        return;
    }
    RtlZeroMemory(buffer, SEED_BUFFER_SIZE);

    //
    // Create subkeys.
    //

    originalLength = PathName->Length;
    wcptr = (PWCHAR) ((PUCHAR)PathName->Buffer + PathName->Length);

    for (keySeed = MapperKeySeed; keySeed->KeyName; keySeed++) {

        //
        // Reset the base path for the next key to seed.
        //

        *wcptr = (WCHAR) 0;
        PathName->Length = originalLength;
        RtlAppendUnicodeToString(PathName, keySeed->KeyName);

        //
        // Only build a device parameters key if there is something
        // to put in the key (i.e., this is a serial or parallel port).
        //

        if (keySeed->Options & KEY_SEED_DEVICE_PARAMETERS) {
            if (((FirmwareEntry->ControllerType != SerialController) && (FirmwareEntry->ControllerType != ParallelController)) ||
                !FirmwareEntry->Identifier) {
                continue;
            }

            status = IopOpenDeviceParametersSubkey( &subKeyHandle,
                                                    NULL,
                                                    PathName,
                                                    KEY_READ | KEY_WRITE
                                                    );
            if (NT_SUCCESS(status)) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_UNSUCCESSFUL;
            }
        } else {

            //
            // need to construct this key.
            //

            InitializeObjectAttributes(&objectAttributes,
                                       PathName,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
            status = ZwCreateKey(&subKeyHandle,
                                 KEY_READ | KEY_WRITE,
                                 &objectAttributes,
                                 0,
                                 NULL,
                                 keySeed->Attribute,
                                 &disposition);
        }

        if (NT_SUCCESS(status)) {

            //
            // Check to see if this is the parameters key and
            // migrate the parameter information.
            //

            if (keySeed->Options & KEY_SEED_DEVICE_PARAMETERS) {

                if (FirmwareEntry->ControllerType == SerialController)  {

                    ComPortDBAdd(subKeyHandle, (PWSTR)FirmwareEntry->Identifier);
                } else {
                    //
                    // to get here there must be identifier information
                    // in the FirmwareEntry, so that check is not performed.
                    //
                    // NOTE: this will only happen once - when the key is
                    // created -- perhaps this needs to happen on every
                    // boot.
                    //

                    PiWstrToUnicodeString(&unicodeName,
                                        L"DosDeviceName");
                    ZwSetValueKey(subKeyHandle,
                                &unicodeName,
                                0,
                                FirmwareEntry->IdentifierType,
                                FirmwareEntry->Identifier,
                                FirmwareEntry->IdentifierLength);
                }
            }
            ZwClose(subKeyHandle);
        } else {

            //
            // ignore failures
            //

            IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                        "Mapper: failed to build control key %x\n",
                        status));
        }
    }

    //
    // Undo the mangling of the path name performed in the loop above.
    //

    *wcptr = (WCHAR) 0;
    PathName->Length = originalLength;

    //
    // Create values.
    //

    pnpid = FirmwareEntry->PnPId;
    for (valueSeed = MapperValueSeed; valueSeed->ValueName; valueSeed++) {

        if (valueSeed->ValueType == REG_DWORD) {

            if ((valueSeed->Options == OPTIONS_INSERT_PHANTOM_MARKER) &&
                !DeviceIsPhantom) {

                //
                // Device isn't a phantom--we don't want to mark it as such.
                //

                continue;
            }

            size = sizeof(ULONG);
            RtlCopyMemory(buffer, &valueSeed->DwordValueContent, size);

        } else if (valueSeed->Options == OPTIONS_INSERT_PNP_ID) {

            size = (ULONG)((wcslen(pnpid) + 2) * sizeof(WCHAR)); // eos multi_sz
            if (FirmwareEntry->BusType == Eisa) {

                //
                // need a mult_sz of EISA\PNPblah *PNPblah
                //

                RtlZeroMemory(buffer, SEED_BUFFER_SIZE);
                wcptr = (PWCHAR)pnpid;
                wcptr++;
                swprintf(buffer, L"EISA\\%s", wcptr);

                wcptr = buffer;
                while (*wcptr) {
                    wcptr++;
                }
                wcptr++; // step past eos for 1st string

                RtlCopyMemory(wcptr, pnpid, size);

                size += (ULONG)((PUCHAR)wcptr - (PUCHAR)buffer);
            } else {
                RtlCopyMemory(buffer, pnpid, size - sizeof(WCHAR));
                buffer[size / sizeof(WCHAR) - 1] = L'\0';
            }
        } else if (valueSeed->Options == OPTIONS_INSERT_COMPATIBLE_IDS) {
            if (FirmwareEntry->PeripheralType == KeyboardPeripheral)  {
                size = sizeof(PS2_KEYBOARD_COMPATIBLE_ID);
                RtlCopyMemory(buffer, PS2_KEYBOARD_COMPATIBLE_ID, size);
            } else if (FirmwareEntry->PeripheralType == PointerPeripheral &&
                       (wcscmp(pnpid, L"*PNP0F0E") == 0 ||
                        wcscmp(pnpid, L"*PNP0F03") == 0 ||
                        wcscmp(pnpid, L"*PNP0F12") == 0)) {
                size = sizeof(PS2_MOUSE_COMPATIBLE_ID);
                RtlCopyMemory(buffer, PS2_MOUSE_COMPATIBLE_ID, size);
            } else {
                continue;
            }
            buffer[size / 2] = L'\0';  // 2nd NUL for MULTI_SZ
            size += sizeof(L'\0');
        } else if (valueSeed->Options == OPTIONS_INSERT_DEVICEDESC) {
            size = FirmwareEntry->IdentifierLength;
            RtlCopyMemory(buffer, FirmwareEntry->Identifier, size);
        } else {
            IopDbgPrint((IOP_MAPPER_ERROR_LEVEL, "Mapper: NO VALUE TYPE!\n"));
            ASSERT(FALSE);
            continue;
        }

        RtlInitUnicodeString(&unicodeName,
                             valueSeed->ValueName);
        ZwSetValueKey(Handle,
                      &unicodeName,
                      0,
                      valueSeed->ValueType,
                      buffer,
                      size);
    }
    ExFreePool(buffer);
}


VOID
MapperFreeList(
    VOID
    )

/*++

Routine Description:

    This routine walks through the list of firmware entries
    and frees all allocated memory.

Arguments:

    None

Return Value:

    None

--*/

{
    PDEVICE_EXTENSION       deviceExtension = &MapperDeviceExtension;
    PFIRMWARE_CONFIGURATION tempEntry;
    PFIRMWARE_CONFIGURATION firmwareEntry;

    firmwareEntry = deviceExtension->FirmwareList;
    while (firmwareEntry) {

        //
        // free allocated structures associated with the firmware entry
        //

        if (firmwareEntry->ResourceDescriptor) {
            ExFreePool(firmwareEntry->ResourceDescriptor);
        }
        if (firmwareEntry->Identifier) {
            ExFreePool(firmwareEntry->Identifier);
        }

        //
        // free this entry and move to the next
        //

        tempEntry = firmwareEntry->Next;
        ExFreePool(firmwareEntry);
        firmwareEntry = tempEntry;
    }
}

VOID
MapperConstructRootEnumTree(
    IN BOOLEAN CreatePhantomDevices
    )

/*++

Routine Description:

    This routine walks through the list of firmware entries
    in the device extension and migrates the information into
    the root enumerator's tree in the registry.

Arguments:

    CreatePhantomDevices - If non-zero, then the device instances are created
        as "phantoms" (i.e., they are marked with the "Phantom" value entry so
        that the root enumerator will ignore them).  The only time these device
        instance registry keys will ever turn into real live devnodes is if the
        class installer (in response to DIF_FIRSTTIMESETUP or DIF_DETECT)
        decides that these devices aren't duplicates of any PnP-enumerated
        devnodes, and subsequently registers and installs them.

Return Value:

    None

--*/

{
#define ENUM_KEY_BUFFER_SIZE (1024 * sizeof(WCHAR))
#define INSTANCE_BUFFER_SIZE (256 * sizeof(WCHAR))
    UNICODE_STRING          enumKey;
    PFIRMWARE_CONFIGURATION firmwareEntry;
    OBJECT_ATTRIBUTES       objectAttributes;
    NTSTATUS                status;
    BOOLEAN                 keyPresent;
    PWCHAR                  registryBase;
    PWCHAR                  instanceBuffer;
    HANDLE                  handle;
    ULONG                   disposition;
    PVOID                   buffer;
    PDEVICE_EXTENSION       DeviceExtension = &MapperDeviceExtension;

    PAGED_CODE();

    //
    // allocate space needed for the registry path into the root
    // enumerator tree.  Note, limited size on path length.
    //

    buffer = ExAllocatePool(NonPagedPool, ENUM_KEY_BUFFER_SIZE);

    if (!buffer) {
        MapperFreeList();
        IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                    "Mapper: could not allocate memory for registry update\n"));
        return;
    }

    instanceBuffer = ExAllocatePool(NonPagedPool, INSTANCE_BUFFER_SIZE);
    if (!instanceBuffer) {
        MapperFreeList();
        ExFreePool(buffer);
        IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                    "Mapper: could not allocate memory for instance buffer\n"));
        return;
    }

    InitializeObjectAttributes(&objectAttributes,
                               &enumKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

#if UMODETEST
    registryBase = L"\\Registry\\Machine\\System\\TestControlSet\\Enum\\Root\\";
#else
    registryBase = L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root\\";
#endif

    firmwareEntry = DeviceExtension->FirmwareList;
    while (firmwareEntry) {

        //
        // Construct the base for the path for this entry.
        //


        PiWstrToUnicodeString(&enumKey, NULL);
        enumKey.MaximumLength = ENUM_KEY_BUFFER_SIZE;
        enumKey.Buffer = buffer;
        RtlZeroMemory(buffer, ENUM_KEY_BUFFER_SIZE);
        RtlAppendUnicodeToString(&enumKey, registryBase);
        RtlAppendUnicodeToString(&enumKey, firmwareEntry->PnPId);

        //
        // Build the pnp Key.
        //

        status = ZwCreateKey(&handle,
                             KEY_READ | KEY_WRITE,
                             &objectAttributes,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &disposition);

        if (NT_SUCCESS(status)) {

            //
            // Do not need the handle, so close it
            // Remember if the key was present prior to call
            //

            ZwClose(handle);
            keyPresent = (disposition == REG_OPENED_EXISTING_KEY) ? TRUE : FALSE;
            IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                        "Mapper: Key was %s\n",
                        keyPresent ? "Present" : "Created"));

            //
            // Construct the instance name.
            //

            RtlZeroMemory(instanceBuffer, INSTANCE_BUFFER_SIZE);
            swprintf(instanceBuffer,
                     L"\\%d_%d_%d_%d_%d_%d",
                     firmwareEntry->BusType,
                     firmwareEntry->BusNumber,
                     firmwareEntry->ControllerType,
                     firmwareEntry->ControllerNumber,
                     firmwareEntry->PeripheralType,
                     firmwareEntry->PeripheralNumber);
            RtlAppendUnicodeToString(&enumKey, instanceBuffer);

            status = ZwCreateKey(&handle,
                                 KEY_READ | KEY_WRITE,
                                 &objectAttributes,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 &disposition);

            if (NT_SUCCESS(status)) {

                if (firmwareEntry->ResourceDescriptor) {
                    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                                "Mapper: firmware entry has resources %x\n",
                                firmwareEntry->ResourceDescriptor));
                }

                if (firmwareEntry->Identifier) {
                    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                                "Mapper: firmware entry has identifier %x\n",
                                firmwareEntry->Identifier));
                }

                //
                // If the key already exists because it was explicitly migrated
                // during textmode setup, we should still consider it a "new key".
                //
                if (disposition != REG_CREATED_NEW_KEY) {
                    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
                    UNICODE_STRING unicodeString;

                    status = IopGetRegistryValue(handle,
                                                 REGSTR_VALUE_MIGRATED,
                                                 &keyValueInformation);
                    if (NT_SUCCESS(status)) {

                        if ((keyValueInformation->Type == REG_DWORD) &&
                            (keyValueInformation->DataLength == sizeof(ULONG)) &&
                            ((*(PULONG)KEY_VALUE_DATA(keyValueInformation)) != 0)) {
                            disposition = REG_CREATED_NEW_KEY;
                        }

                        ExFreePool(keyValueInformation);

                        PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_MIGRATED);
                        ZwDeleteValueKey(handle, &unicodeString);
                    }
                }

                //
                // Only if this is a new entry do we see the key.
                //

                if (disposition == REG_CREATED_NEW_KEY) {

                    //
                    // Remember the fact that the key was newly-created for the
                    // PnP BIOS case where we need to come along and "phantomize"
                    // all newly-created ntdetect COM ports.
                    //

                    firmwareEntry->NewlyCreated = TRUE;

                    //
                    // Create enough information to get pnp to
                    // install drivers
                    //

                    MapperSeedKey(handle,
                                  &enumKey,
                                  firmwareEntry,
                                  CreatePhantomDevices
                                 );
                }
                MapperMarkKey(handle,
                              &enumKey,
                              firmwareEntry);
                ZwClose(handle);

            } else {
                IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                            "Mapper: create of instance key failed %x\n",
                            status));
            }

        } else {
            IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                        "Mapper: create pnp key failed %x\n",
                        status));
        }

        firmwareEntry = firmwareEntry->Next;
    }
    ExFreePool(instanceBuffer);
}

PCM_RESOURCE_LIST
MapperAdjustResourceList (
    IN     PCM_RESOURCE_LIST ResourceList,
    IN     WCHAR const*      PnPId,
    IN OUT PULONG            Size
    )
{
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR problemPartialDescriptors;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    PCM_RESOURCE_LIST               newResourceList;
    ULONG                           i;

    newResourceList = ResourceList;

#if _X86_
    if (KeI386MachineType == MACHINE_TYPE_EISA) {

        PCM_FULL_RESOURCE_DESCRIPTOR    fullDescriptor;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
        PUCHAR                          nextDescriptor;
        ULONG                           j;
        ULONG                           lastResourceIndex;

        fullDescriptor = &ResourceList->List[0];

        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &fullDescriptor->PartialResourceList;

            for (j = 0; j < partialResourceList->Count; j++) {
                partialDescriptor = &partialResourceList->PartialDescriptors[j];

                if (partialDescriptor->Type == CmResourceTypePort) {
                    if (partialDescriptor->u.Port.Start.HighPart == 0 &&
                        (partialDescriptor->u.Port.Start.LowPart & 0x00000300) == 0) {
                        partialDescriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
                    }
                }
            }

            nextDescriptor = (PUCHAR)fullDescriptor + sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

            //
            // account for any resource descriptors in addition to the single
            // imbedded one I've already accounted for (if there aren't any,
            // then I'll end up subtracting off the extra imbedded descriptor
            // from the previous step)
            //
            //
            // finally, account for any extra device specific data at the end of
            // the last partial resource descriptor (if any)
            //
            if (partialResourceList->Count > 0) {

                nextDescriptor += (partialResourceList->Count - 1) *
                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                lastResourceIndex = partialResourceList->Count - 1;

                if (partialResourceList->PartialDescriptors[lastResourceIndex].Type ==
                          CmResourceTypeDeviceSpecific) {

                    nextDescriptor += partialResourceList->PartialDescriptors[lastResourceIndex].
                               u.DeviceSpecificData.DataSize;
                }
            }

            fullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)nextDescriptor;
        }
    }
#endif

    if (wcscmp(PnPId, FloppyId) == 0) {

        if (ResourceList->Count == 1) {

            partialResourceList = &ResourceList->List->PartialResourceList;

            partialDescriptors = partialResourceList->PartialDescriptors;

            //
            // Look for the one and only one 8 byte port resource
            //
            problemPartialDescriptors = NULL;
            for (i=0; i<partialResourceList->Count; i++) {

                if ((partialDescriptors[i].Type == CmResourceTypePort) &&
                    (partialDescriptors[i].u.Port.Length == 8)) {

                    if (problemPartialDescriptors == NULL) {

                        problemPartialDescriptors = partialDescriptors + i;
                    } else {

                        problemPartialDescriptors = NULL;
                        break;
                    }
                }
            }

            if (problemPartialDescriptors) {

                problemPartialDescriptors->u.Port.Length = 6;

                newResourceList = ExAllocatePool (
                                      NonPagedPool,
                                      *Size + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                                      );
                if (newResourceList) {

                    RtlCopyMemory (
                        newResourceList,
                        ResourceList,
                        *Size
                        );

                    //
                    // pick out the new partial resource descriptor
                    //
                    partialDescriptors = newResourceList->List->
                                             PartialResourceList.PartialDescriptors;
                    partialDescriptors += newResourceList->List->PartialResourceList.Count;

                    RtlCopyMemory (
                        partialDescriptors,
                        problemPartialDescriptors,
                        sizeof(*partialDescriptors)
                        );

                    partialDescriptors->u.Port.Start.QuadPart += 7;
                    partialDescriptors->u.Port.Length = 1;

                    //
                    // we got one more now
                    //
                    newResourceList->List->PartialResourceList.Count++;
                    *Size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                    ExFreePool (ResourceList);

                } else {

                    newResourceList = ResourceList;
                }
            }
        }
    }

    return newResourceList;
}

NTSTATUS
ComPortDBAdd(
    IN  HANDLE  DeviceParamKey,
    IN  PWSTR   PortName
    )
{
    UNICODE_STRING                  portNameString;
    UNICODE_STRING                  portPrefixString;
    UNICODE_STRING                  comDBName;
    UNICODE_STRING                  valueName;
    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo;
    ULONG                           valueInfoLength;
    ULONG                           returnedLength;
    HANDLE                          comDBKey;
    ULONG                           portNo;
    NTSTATUS                        status;

    RtlInitUnicodeString(&portNameString, PortName);

    if (portNameString.Length > 3 * sizeof(WCHAR)) {
        portNameString.Length = 3 * sizeof(WCHAR);
    }

    PiWstrToUnicodeString(&portPrefixString, L"COM");

    if (RtlCompareUnicodeString(&portNameString, &portPrefixString, TRUE) == 0) {
        portNo = _wtol(&PortName[3]);

        if (portNo > 0 && portNo <= 256) {

#if UMODETEST
            PiWstrToUnicodeString(&comDBName, L"\\Registry\\Machine\\System\\TestControlSet\\Control\\COM Name Arbiter");
#else
            PiWstrToUnicodeString(&comDBName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
#endif

            status = IopCreateRegistryKeyEx( &comDBKey,
                                             NULL,
                                             &comDBName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );

            if (NT_SUCCESS(status)) {

                PiWstrToUnicodeString(&valueName, L"ComDB Merge");

#define COMPORT_DB_MERGE_SIZE    32           //  256 / 8

                valueInfoLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + COMPORT_DB_MERGE_SIZE;
                valueInfo = ExAllocatePool(PagedPool, valueInfoLength);

                if (valueInfo != NULL) {

                    status = ZwQueryValueKey( comDBKey,
                                              &valueName,
                                              KeyValuePartialInformation,
                                              valueInfo,
                                              valueInfoLength,
                                              &returnedLength);

                    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

                        valueInfo->Type = REG_BINARY;
                        valueInfo->DataLength = COMPORT_DB_MERGE_SIZE;
                        RtlZeroMemory(valueInfo->Data, valueInfo->DataLength);
                        status = STATUS_SUCCESS;
                    }

                    if (NT_SUCCESS(status)) {
                        portNo--;
                        valueInfo->Data[ portNo / 8 ] |= 1 << (portNo % 8);

                        status = ZwSetValueKey( comDBKey,
                                                &valueName,
                                                0,
                                                valueInfo->Type,
                                                valueInfo->Data,
                                                valueInfo->DataLength );

                        ASSERT(NT_SUCCESS(status));
                    }

                    ExFreePool(valueInfo);
                }

                ZwClose(comDBKey);
            }
        }
    }

    PiWstrToUnicodeString( &valueName, L"DosDeviceName" );

    status = ZwSetValueKey( DeviceParamKey,
                            &valueName,
                            0,
                            REG_SZ,
                            PortName,
                            (ULONG)((wcslen(PortName) + 1) * sizeof(WCHAR)) );

    return status;
}


VOID
MapperPhantomizeDetectedComPorts (
    VOID
    )
/*++

Routine Description:

    This routine turns all newly-created firmware/ntdetect COM ports into
    phantoms.

Arguments:

    None

Return Value:

    None

--*/
{
    PFIRMWARE_CONFIGURATION firmwareEntry;
    NTSTATUS                status;
    PWCHAR                  registryBase;
    PWCHAR                  instanceBuffer;
    HANDLE                  handle;
    PWCHAR                  buffer;
    PDEVICE_EXTENSION       DeviceExtension = &MapperDeviceExtension;
    UNICODE_STRING          enumKey;
    OBJECT_ATTRIBUTES       objectAttributes;
    UNICODE_STRING          unicodeName;
    ULONG                   regValue;

    //
    // allocate space needed for the registry path into the root
    // enumerator tree.  Note, limited size on path length.
    //

    buffer = ExAllocatePool(NonPagedPool, ENUM_KEY_BUFFER_SIZE);

    if (!buffer) {
        IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                    "Mapper: could not allocate memory for registry update\n"));
        return;
    }

    instanceBuffer = ExAllocatePool(NonPagedPool, INSTANCE_BUFFER_SIZE);
    if (!instanceBuffer) {
        ExFreePool(buffer);
        IopDbgPrint((IOP_MAPPER_ERROR_LEVEL,
                    "Mapper: could not allocate memory for instance buffer\n"));
        return;
    }

    InitializeObjectAttributes(&objectAttributes,
                               &enumKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

#if UMODETEST
    registryBase = L"\\Registry\\Machine\\System\\TestControlSet\\Enum\\Root\\";
#else
    registryBase = L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root\\";
#endif

    firmwareEntry = DeviceExtension->FirmwareList;
    while (firmwareEntry) {

        //
        // Construct the base for the path for this entry.
        //


        if ((firmwareEntry->ControllerType == SerialController) &&
            firmwareEntry->NewlyCreated) {

            PiWstrToUnicodeString(&enumKey, NULL);
            enumKey.MaximumLength = ENUM_KEY_BUFFER_SIZE;
            enumKey.Buffer = buffer;
            RtlZeroMemory(buffer, ENUM_KEY_BUFFER_SIZE);
            RtlAppendUnicodeToString(&enumKey, registryBase);
            RtlAppendUnicodeToString(&enumKey, firmwareEntry->PnPId);

            //
            // Construct the instance name.
            //

            RtlZeroMemory(instanceBuffer, INSTANCE_BUFFER_SIZE);
            swprintf(instanceBuffer,
                     L"\\%d_%d_%d_%d_%d_%d",
                     firmwareEntry->BusType,
                     firmwareEntry->BusNumber,
                     firmwareEntry->ControllerType,
                     firmwareEntry->ControllerNumber,
                     firmwareEntry->PeripheralType,
                     firmwareEntry->PeripheralNumber);
            RtlAppendUnicodeToString(&enumKey, instanceBuffer);

            status = ZwOpenKey(&handle,
                               KEY_READ | KEY_WRITE,
                               &objectAttributes
                              );

            if (NT_SUCCESS(status)) {

                PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_PHANTOM);
                regValue = 1;
                ZwSetValueKey(handle,
                              &unicodeName,
                              0,
                              REG_DWORD,
                              &regValue,
                              sizeof(regValue)
                             );

                ZwClose(handle);
            }
        }

        firmwareEntry = firmwareEntry->Next;
    }

    ExFreePool (buffer);
    ExFreePool (instanceBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\notify.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This module contains APIs and routines for handling device event
    notifications.

Author:


Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <pnpmgr.h>
#include <pnpsetup.h>

#define PNP_DEVICE_EVENT_ENTRY_TAG 'EEpP'

typedef struct _ASYNC_TDC_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_CHANGE_COMPLETE_CALLBACK Callback;
    PVOID Context;
    PTARGET_DEVICE_CUSTOM_NOTIFICATION NotificationStructure;
}   ASYNC_TDC_WORK_ITEM, *PASYNC_TDC_WORK_ITEM;

typedef struct _DEFERRED_REGISTRATION_ENTRY {
    LIST_ENTRY            ListEntry;
    PNOTIFY_ENTRY_HEADER  NotifyEntry;
} DEFERRED_REGISTRATION_ENTRY, *PDEFERRED_REGISTRATION_ENTRY;
//
// Kernel mode notification data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#pragma  const_seg("PAGECONST")
#endif
LIST_ENTRY IopDeviceClassNotifyList[NOTIFY_DEVICE_CLASS_HASH_BUCKETS] = {NULL};
PSETUP_NOTIFY_DATA IopSetupNotifyData = NULL;
LIST_ENTRY IopProfileNotifyList = {NULL};
LIST_ENTRY IopDeferredRegistrationList = {NULL};
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

FAST_MUTEX  IopDeviceClassNotifyLock;
FAST_MUTEX  IopTargetDeviceNotifyLock;
FAST_MUTEX  IopHwProfileNotifyLock;
FAST_MUTEX  IopDeferredRegistrationLock;

BOOLEAN     PiNotificationInProgress;
FAST_MUTEX  PiNotificationInProgressLock;

//
// Prototypes
//

VOID
IopDereferenceNotify(
    PNOTIFY_ENTRY_HEADER Notify
    );

VOID
IopInitializePlugPlayNotification(
    VOID
    );

NTSTATUS
PiNotifyUserMode(
    PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    );

NTSTATUS
PiNotifyDriverCallback(
    IN  PDRIVER_NOTIFICATION_CALLBACK_ROUTINE  CallbackRoutine,
    IN  PVOID   NotificationStructure,
    IN  PVOID   Context,
    IN  ULONG   SessionId,
    IN  PVOID   OpaqueSession,
    OUT PNTSTATUS  CallbackStatus  OPTIONAL
    );

VOID
IopReferenceNotify(
    PNOTIFY_ENTRY_HEADER notify
    );

VOID
IopReportTargetDeviceChangeAsyncWorker(
    PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoGetRelatedTargetDevice)
#pragma alloc_text(PAGE, IoNotifyPowerOperationVetoed)
#pragma alloc_text(PAGE, IoPnPDeliverServicePowerNotification)
#pragma alloc_text(PAGE, IoRegisterPlugPlayNotification)
#pragma alloc_text(PAGE, IoReportTargetDeviceChange)
#pragma alloc_text(PAGE, IoUnregisterPlugPlayNotification)
#pragma alloc_text(PAGE, IopDereferenceNotify)
#pragma alloc_text(PAGE, IopGetRelatedTargetDevice)
#pragma alloc_text(PAGE, IopInitializePlugPlayNotification)
#pragma alloc_text(PAGE, IopNotifyDeviceClassChange)
#pragma alloc_text(PAGE, IopNotifyHwProfileChange)
#pragma alloc_text(PAGE, IopNotifySetupDeviceArrival)
#pragma alloc_text(PAGE, IopNotifyTargetDeviceChange)
#pragma alloc_text(PAGE, IopOrphanNotification)
#pragma alloc_text(PAGE, IopProcessDeferredRegistrations)
#pragma alloc_text(PAGE, IopReferenceNotify)
#pragma alloc_text(PAGE, IopReportTargetDeviceChangeAsyncWorker)
#pragma alloc_text(PAGE, IopRequestHwProfileChangeNotification)
#pragma alloc_text(PAGE, PiNotifyDriverCallback)
#endif // ALLOC_PRAGMA



NTSTATUS
IoUnregisterPlugPlayNotification(
    IN PVOID NotificationEntry
    )

/*++

Routine Description:

    This routine unregisters a notification previously registered via
    IoRegisterPlugPlayNotification.  A driver cannot be unloaded until it has
    unregistered all of its notification handles.

Parameters:

    NotificationEntry - This provices the cookie returned by IoRegisterPlugPlayNotification
        which identifies the registration in question.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PNOTIFY_ENTRY_HEADER entry;
    PFAST_MUTEX lock;
    BOOLEAN wasDeferred = FALSE;

    PAGED_CODE();

    ASSERT(NotificationEntry);

    entry = (PNOTIFY_ENTRY_HEADER)NotificationEntry;

    lock = entry->Lock;

    ExAcquireFastMutex(&PiNotificationInProgressLock);
    if (PiNotificationInProgress) {
        //
        // Before unregistering the entry, we need to make sure that it's not sitting
        // around in the deferred registration list.
        //
        IopAcquireNotifyLock(&IopDeferredRegistrationLock);

        if (!IsListEmpty(&IopDeferredRegistrationList)) {

            PLIST_ENTRY link;
            PDEFERRED_REGISTRATION_ENTRY deferredNode;

            link = IopDeferredRegistrationList.Flink;
            deferredNode = (PDEFERRED_REGISTRATION_ENTRY)link;

            while (link != (PLIST_ENTRY)&IopDeferredRegistrationList) {
                ASSERT(deferredNode->NotifyEntry->Unregistered);
                if (deferredNode->NotifyEntry == entry) {
                    wasDeferred = TRUE;
                    if (lock) {
                        IopAcquireNotifyLock(lock);
                    }
                    link = link->Flink;
                    RemoveEntryList((PLIST_ENTRY)deferredNode);
                    IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)deferredNode->NotifyEntry);
                    if (lock) {
                        IopReleaseNotifyLock(lock);
                    }
                    ExFreePool(deferredNode);
                    deferredNode = (PDEFERRED_REGISTRATION_ENTRY)link;
                } else {
                    link = link->Flink;
                    deferredNode = (PDEFERRED_REGISTRATION_ENTRY)link;
                }
            }
        }

        IopReleaseNotifyLock(&IopDeferredRegistrationLock);
    } else {
        //
        // If there is currently no notification in progress, the deferred
        // registration list must be empty.
        //
        ASSERT(IsListEmpty(&IopDeferredRegistrationList));
    }
    ExReleaseFastMutex(&PiNotificationInProgressLock);

    //
    // Acquire lock
    //
    if (lock) {
        IopAcquireNotifyLock(lock);
    }

    ASSERT(wasDeferred == entry->Unregistered);

    if (!entry->Unregistered || wasDeferred) {
        //
        // Dereference the entry if it is currently registered, or had its
        // registration pending completion of the notification in progress.
        //

        //
        // Mark the entry as unregistered so we don't notify on it
        //

        entry->Unregistered = TRUE;

        //
        // Dereference it thus deleting if no longer required
        //

        IopDereferenceNotify(entry);
    }

    //
    // Release the lock
    //

    if (lock) {
        IopReleaseNotifyLock(lock);
    }

    return STATUS_SUCCESS;

}



VOID
IopProcessDeferredRegistrations(
    VOID
    )
/*++

Routine Description:

    This routine removes notification entries from the deferred registration
    list, marking them as "registered" so that they can receive notifications.

Parameters:

    None.

Return Value:

    None.

  --*/
{
    PDEFERRED_REGISTRATION_ENTRY deferredNode;
    PFAST_MUTEX lock;

    IopAcquireNotifyLock(&IopDeferredRegistrationLock);

    while (!IsListEmpty(&IopDeferredRegistrationList)) {

        deferredNode = (PDEFERRED_REGISTRATION_ENTRY)RemoveHeadList(&IopDeferredRegistrationList);

        //
        // Acquire this entry's list lock.
        //
        lock = deferredNode->NotifyEntry->Lock;
        if (lock) {
            IopAcquireNotifyLock(lock);
        }

        //
        // Mark this entry as registered.
        //
        deferredNode->NotifyEntry->Unregistered = FALSE;

        //
        // Dereference the notification entry when removing it from the deferred
        // list, and free the node.
        //
        IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)deferredNode->NotifyEntry);
        ExFreePool(deferredNode);

        //
        // Release this entry's list lock.
        //
        if (lock) {
            IopReleaseNotifyLock(lock);
            lock = NULL;
        }
    }

    IopReleaseNotifyLock(&IopDeferredRegistrationLock);
}



NTSTATUS
IoReportTargetDeviceChange(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    )

/*++

Routine Description:

    This routine may be used to give notification of 3rd-party target device
    change events.  This API will notify every driver that has registered for
    notification on a file object associated with PhysicalDeviceObject about
    the event indicated in the NotificationStructure.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO that the change begin
        reported is associated with.

    NotificationStructure - Provides a pointer to the notification structure to be
        sent to all parties registered for notifications about changes to
        PhysicalDeviceObject.

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    This API may only be used to report non-PnP target device changes.  In particular,
    it will fail if it's called with the NotificationStructure->Event field set to
    GUID_TARGET_DEVICE_QUERY_REMOVE, GUID_TARGET_DEVICE_REMOVE_CANCELLED, or
    GUID_TARGET_DEVICE_REMOVE_COMPLETE.

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    KEVENT completionEvent;
    NTSTATUS completionStatus;
    PTARGET_DEVICE_CUSTOM_NOTIFICATION notifyStruct;
    LONG                   dataSize;

    PAGED_CODE();

    notifyStruct = (PTARGET_DEVICE_CUSTOM_NOTIFICATION)NotificationStructure;

    ASSERT(notifyStruct);

    ASSERT_PDO(PhysicalDeviceObject);

    ASSERT(NULL == notifyStruct->FileObject);


    if (IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_QUERY_REMOVE) ||
        IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_REMOVE_CANCELLED) ||
        IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        //
        //  Passed in an illegal value
        //

        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "IoReportTargetDeviceChange: "
            "Illegal Event type passed as custom notification\n"));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (notifyStruct->Size < FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    dataSize = notifyStruct->Size - FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer);

    if (notifyStruct->NameBufferOffset != -1 && notifyStruct->NameBufferOffset > dataSize)  {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    KeInitializeEvent(&completionEvent, NotificationEvent, FALSE);

    status = PpSetCustomTargetEvent( PhysicalDeviceObject,
                                     &completionEvent,
                                     (PULONG)&completionStatus,
                                     NULL,
                                     NULL,
                                     notifyStruct);

    if (NT_SUCCESS(status))  {

        KeWaitForSingleObject( &completionEvent, Executive, KernelMode, FALSE, NULL );

        status = completionStatus;
    }

    return status;
}



NTSTATUS
IoReportTargetDeviceChangeAsynchronous(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure,  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    IN PDEVICE_CHANGE_COMPLETE_CALLBACK Callback        OPTIONAL,
    IN PVOID Context    OPTIONAL
    )

/*++

Routine Description:

    This routine may be used to give notification of 3rd-party target device
    change events.  This API will notify every driver that has registered for
    notification on a file object associated with PhysicalDeviceObject about
    the event indicated in the NotificationStructure.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO that the change begin
        reported is associated with.

    NotificationStructure - Provides a pointer to the notification structure to be
        sent to all parties registered for notifications about changes to
        PhysicalDeviceObject.

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    This API may only be used to report non-PnP target device changes.  In particular,
    it will fail if it's called with the NotificationStructure->Event field set to
    GUID_TARGET_DEVICE_QUERY_REMOVE, GUID_TARGET_DEVICE_REMOVE_CANCELLED, or
    GUID_TARGET_DEVICE_REMOVE_COMPLETE.

--*/
{
    PASYNC_TDC_WORK_ITEM    asyncWorkItem;
    PWORK_QUEUE_ITEM        workItem;
    NTSTATUS                status;
    LONG                    dataSize;

    PTARGET_DEVICE_CUSTOM_NOTIFICATION   notifyStruct;

    notifyStruct = (PTARGET_DEVICE_CUSTOM_NOTIFICATION)NotificationStructure;

    ASSERT(notifyStruct);

    ASSERT_PDO(PhysicalDeviceObject);

    ASSERT(NULL == notifyStruct->FileObject);

    if (IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_QUERY_REMOVE) ||
        IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_REMOVE_CANCELLED) ||
        IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        //
        //  Passed in an illegal value
        //

        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "IoReportTargetDeviceChangeAsynchronous: "
            "Illegal Event type passed as custom notification\n"));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (notifyStruct->Size < FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    dataSize = notifyStruct->Size - FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer);

    if (notifyStruct->NameBufferOffset != -1 && notifyStruct->NameBufferOffset > dataSize)  {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Since this routine can be called at DPC level we need to queue
    // a work item and process it when the irql drops.
    //

    asyncWorkItem = ExAllocatePool( NonPagedPool,
                                    sizeof(ASYNC_TDC_WORK_ITEM) + notifyStruct->Size);

    if (asyncWorkItem != NULL) {

        //
        // ISSUE-ADRIAO-2000/08/24 - We should use an IO work item here.
        //
        ObReferenceObject(PhysicalDeviceObject);

        asyncWorkItem->DeviceObject = PhysicalDeviceObject;
        asyncWorkItem->NotificationStructure =
            (PTARGET_DEVICE_CUSTOM_NOTIFICATION)((PUCHAR)asyncWorkItem + sizeof(ASYNC_TDC_WORK_ITEM));

        RtlCopyMemory( asyncWorkItem->NotificationStructure,
                       notifyStruct,
                       notifyStruct->Size);

        asyncWorkItem->Callback = Callback;
        asyncWorkItem->Context = Context;
        workItem = &asyncWorkItem->WorkItem;

        ExInitializeWorkItem(workItem, IopReportTargetDeviceChangeAsyncWorker, asyncWorkItem);

        //
        // Queue a work item to do the enumeration
        //

        ExQueueWorkItem(workItem, DelayedWorkQueue);
        status = STATUS_PENDING;
    } else {
        //
        // Failed to allocate memory for work item.  Nothing we can do ...
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}



VOID
IopReportTargetDeviceChangeAsyncWorker(
    PVOID Context
    )

/*++

Routine Description:

    This routine is the worker routine of IoInvalidateDeviceState.
    Its main purpose is to invoke IopSynchronousQueryDeviceState and release
    work item space.

Parameters:

    Context - Supplies a pointer to the ASYNC_TDC_WORK_ITEM.

ReturnValue:

    None.

--*/

{
    PASYNC_TDC_WORK_ITEM asyncWorkItem = (PASYNC_TDC_WORK_ITEM)Context;

    PpSetCustomTargetEvent( asyncWorkItem->DeviceObject,
                            NULL,
                            NULL,
                            asyncWorkItem->Callback,
                            asyncWorkItem->Context,
                            asyncWorkItem->NotificationStructure);

    ObDereferenceObject(asyncWorkItem->DeviceObject);
    ExFreePool(asyncWorkItem);
}



VOID
IopInitializePlugPlayNotification(
    VOID
    )

/*++

Routine Description:

    This routine performs initialization required before any of the notification
    APIs can be called.

Parameters:

    None

Return Value:

    None

--*/

{
    ULONG count;

    PAGED_CODE();

    //
    // Initialize the notification structures
    //

    for (count = 0; count < NOTIFY_DEVICE_CLASS_HASH_BUCKETS; count++) {

        InitializeListHead(&IopDeviceClassNotifyList[count]);

    }

    //
    // Initialize the profile notification list
    //
    InitializeListHead(&IopProfileNotifyList);

    //
    // Initialize the deferred registration list
    //
    InitializeListHead(&IopDeferredRegistrationList);

    ExInitializeFastMutex(&IopDeviceClassNotifyLock);
    ExInitializeFastMutex(&IopTargetDeviceNotifyLock);
    ExInitializeFastMutex(&IopHwProfileNotifyLock);
    ExInitializeFastMutex(&IopDeferredRegistrationLock);
}



VOID
IopReferenceNotify(
    PNOTIFY_ENTRY_HEADER Notify
    )

/*++

Routine Description:

    This routine increments the reference count for a notification entry.

Parameters:

    Notify - Supplies a pointer to the notification entry to be referenced

Return Value:

    None

Note:

    The appropriate synchronization lock must be held on the notification
    list before this routine can be called

--*/

{
    PAGED_CODE();

    ASSERT(Notify);
    ASSERT(Notify->RefCount > 0);

    Notify->RefCount++;

}



VOID
IopDereferenceNotify(
    PNOTIFY_ENTRY_HEADER Notify
    )

/*++

Routine Description:

    This routine decrements the reference count for a notification entry, removing
    the entry from the list and freeing the associated memory if there are no
    outstanding reference counts.

Parameters:

    Notify - Supplies a pointer to the notification entry to be referenced

Return Value:

    None

Note:

    The appropriate synchronization lock must be held on the notification
    list before this routine can be called

--*/

{
    PAGED_CODE();

    ASSERT(Notify);
    ASSERT(Notify->RefCount > 0);

    Notify->RefCount--;

    if (Notify->RefCount == 0) {

        //
        // If the refcount is zero then the node should have been deregisterd
        // and is no longer needs to be in the list so remove and free it
        //

        ASSERT(Notify->Unregistered);

        //
        // Remove the notification entry from its list.
        //
        // Note that this MUST be done first, since the notification list head
        // for a target device notification entry resides in the target device
        // node, which may be freed immediately after the device object is
        // dereferenced.  For notification entry types other than target device
        // change this is not critical, but still a good idea.
        //

        RemoveEntryList((PLIST_ENTRY)Notify);

        //
        // Dereference the driver object that registered for notifications
        //

        ObDereferenceObject(Notify->DriverObject);

        //
        // If this notification entry is for target device change, dereference
        // the PDO upon which this notification entry was hooked.
        //

        if (Notify->EventCategory == EventCategoryTargetDeviceChange) {
            PTARGET_DEVICE_NOTIFY_ENTRY entry = (PTARGET_DEVICE_NOTIFY_ENTRY)Notify;

            if (entry->PhysicalDeviceObject) {
                ObDereferenceObject(entry->PhysicalDeviceObject);
                entry->PhysicalDeviceObject = NULL;
            }
        }

        //
        // Dereference the opaque session object
        //

        if (Notify->OpaqueSession) {
            MmQuitNextSession(Notify->OpaqueSession);
            Notify->OpaqueSession = NULL;
        }

        //
        // Free the notification entry
        //

        ExFreePool(Notify);

    }
}



NTSTATUS
IopRequestHwProfileChangeNotification(
    IN   LPGUID                         EventGuid,
    IN   PROFILE_NOTIFICATION_TIME      NotificationTime,
    OUT  PPNP_VETO_TYPE                 VetoType            OPTIONAL,
    OUT  PUNICODE_STRING                VetoName            OPTIONAL
    )

/*++

Routine Description:

    This routine is used to notify all registered drivers of a hardware profile
    change.  If the operation is a HW provile change query then the operation
    is synchronous and the veto information is propagated.  All other operations
    are asynchronous and veto information is not returned.

Parameters:

    EventTypeGuid       - The event that has occured

    NotificationTime    - This is used to tell if we are already in an event
                          when delivering a synchronous notification (ie,
                          querying profile change to eject). It is one of
                          three values:
                              PROFILE_IN_PNPEVENT
                              PROFILE_NOT_IN_PNPEVENT
                              PROFILE_PERHAPS_IN_PNPEVENT

    VetoType            - Type of vetoer.

    VetoName            - Name of vetoer.

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/

{
    NTSTATUS status=STATUS_SUCCESS,completionStatus;
    KEVENT completionEvent;
    ULONG dataSize,totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    if ((!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE)) &&
        (!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_CHANGE_CANCELLED)) &&
        (!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_CHANGE_COMPLETE))) {

        //
        //  Passed in an illegal value
        //

        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "IopRequestHwProfileChangeNotification: "
            "Illegal Event type passed as profile notification\n"));

        return STATUS_INVALID_DEVICE_REQUEST;
    }


    //
    // Only the query changes are synchronous, and in that case we must
    // know definitely whether we are nested within a Pnp event or not.
    //
    ASSERT((!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE))||
           (NotificationTime != PROFILE_PERHAPS_IN_PNPEVENT)) ;

    if (!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE) ) {

        //
        // Asynchronous case. Very easy.
        //
        ASSERT(!ARGUMENT_PRESENT(VetoName));
        ASSERT(!ARGUMENT_PRESENT(VetoType));

        return PpSetHwProfileChangeEvent( EventGuid,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL
                                          );
    }

    //
    // Query notifications are synchronous. Determine if we are currently
    // within an event, in which case we must do the notify here instead
    // of queueing it up.
    //
    if (NotificationTime == PROFILE_NOT_IN_PNPEVENT) {

        //
        // Queue up and block on the notification.
        //
        KeInitializeEvent(&completionEvent, NotificationEvent, FALSE);

        status = PpSetHwProfileChangeEvent( EventGuid,
                                            &completionEvent,
                                            &completionStatus,
                                            VetoType,
                                            VetoName
                                            );

        if (NT_SUCCESS(status))  {

            KeWaitForSingleObject( &completionEvent, Executive, KernelMode, FALSE, NULL );

            status = completionStatus;
        }

        return status;
    }

    //
    // Synchronous notify inside our Pnp event.
    //

    //
    // ISSUE-ADRIAO-1998/11/12 - We are MANUALLY sending the profile
    // query change notification because we are blocking inside a PnPEvent and
    // thus can't queue/wait on another!
    //
    ASSERT(PiNotificationInProgress == TRUE);

    dataSize =  sizeof(PLUGPLAY_EVENT_BLOCK);

    totalSize = dataSize + FIELD_OFFSET (PNP_DEVICE_EVENT_ENTRY,Data);

    deviceEvent = ExAllocatePoolWithTag (PagedPool,
                                         totalSize,
                                         PNP_DEVICE_EVENT_ENTRY_TAG);

    if (NULL == deviceEvent) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent,totalSize);
    deviceEvent->Data.EventCategory = HardwareProfileChangeEvent;
    RtlCopyMemory(&deviceEvent->Data.EventGuid, EventGuid, sizeof(GUID));
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->CallerEvent = &completionEvent;
    deviceEvent->Data.Result = (PULONG)&completionStatus;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;

    //
    // Notify K-Mode
    //
    status = IopNotifyHwProfileChange(&deviceEvent->Data.EventGuid,
                                      VetoType,
                                      VetoName);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Notify user-mode (synchronously).
    //
    status = PiNotifyUserMode(deviceEvent);

    if (!NT_SUCCESS(status)) {
        //
        // Notify K-mode that the query has been cancelled.
        //
        IopNotifyHwProfileChange((LPGUID)&GUID_HWPROFILE_CHANGE_CANCELLED,
                                 NULL,
                                 NULL);
    }
    return status;
}



NTSTATUS
IopNotifyHwProfileChange(
    IN  LPGUID           EventGuid,
    OUT PPNP_VETO_TYPE   VetoType    OPTIONAL,
    OUT PUNICODE_STRING  VetoName    OPTIONAL
    )
/*++

Routine Description:

    This routine is used to deliver the HWProfileNotifications. It is
    called from the worker thread only
    It does not return until all interested parties have been notified.

Parameters:

    EventTypeGuid - The event that has occured

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/
{
    NTSTATUS status = STATUS_SUCCESS, dispatchStatus;
    PHWPROFILE_NOTIFY_ENTRY  pNotifyList, vetoEntry;
    PLIST_ENTRY link;


    PAGED_CODE();

    //Lock the Profile Notification List
    IopAcquireNotifyLock (&IopHwProfileNotifyLock);

    //
    //  Grab the list head (inside the lock)
    //
    link = IopProfileNotifyList.Flink;
    pNotifyList=(PHWPROFILE_NOTIFY_ENTRY)link;

    //
    //circular list
    //
    while (link != (PLIST_ENTRY)&IopProfileNotifyList) {
        if (!pNotifyList->Unregistered) {

            HWPROFILE_CHANGE_NOTIFICATION notification;

            //
            // Reference the entry so that no one deletes during the callback
            // and then release the lock
            //
            IopReferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);
            IopReleaseNotifyLock(&IopHwProfileNotifyLock);

            //
            // Fill in the notification structure
            //
            notification.Version = PNP_NOTIFICATION_VERSION;
            notification.Size = sizeof(HWPROFILE_CHANGE_NOTIFICATION);
            notification.Event = *EventGuid;

            //
            // Dispatch the notification to the callback routine for the
            // appropriate session.
            //
            dispatchStatus = PiNotifyDriverCallback(pNotifyList->CallbackRoutine,
                                                    &notification,
                                                    pNotifyList->Context,
                                                    pNotifyList->SessionId,
                                                    pNotifyList->OpaqueSession,
                                                    &status);
            ASSERT(NT_SUCCESS(dispatchStatus));

            //
            // Failure to dispatch the notification to the specified callback
            // should not be considered a veto.
            //
            if (!NT_SUCCESS(dispatchStatus)) {
                status = STATUS_SUCCESS;
            }

            //
            // If the caller returned anything other than success and it was a
            // query hardware profile change, we veto the query and send cancels
            // to all callers that already got the query.
            //

            if ((!NT_SUCCESS(status)) &&
                (IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE))) {

                if (VetoType) {
                    *VetoType = PNP_VetoDriver;
                }
                if (VetoName) {
                    VetoName->Length = 0;
                    RtlCopyUnicodeString(VetoName, &pNotifyList->DriverObject->DriverName);
                }

                notification.Event = GUID_HWPROFILE_CHANGE_CANCELLED;
                notification.Size = sizeof(GUID_HWPROFILE_CHANGE_CANCELLED);

                //
                // Keep track of the entry that vetoed the query.  We can't
                // dereference it just yet, because we may need to send it a
                // cancel-remove first.  Since it's possible that the entry
                // may have been unregistered when the list was unlocked
                // during the query callback (removing all but the reference
                // we are currently holding), we need to make sure we don't
                // dereference it until we're absolutely done with it.
                //
                vetoEntry = pNotifyList;

                IopAcquireNotifyLock(&IopHwProfileNotifyLock);

                //
                // Make sure we are starting where we left off above, at the
                // vetoing entry.
                //
                ASSERT((PHWPROFILE_NOTIFY_ENTRY)link == vetoEntry);

                do {
                    pNotifyList = (PHWPROFILE_NOTIFY_ENTRY)link;
                    if (!pNotifyList->Unregistered) {
                        IopReferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);
                        IopReleaseNotifyLock(&IopHwProfileNotifyLock);

                        dispatchStatus = PiNotifyDriverCallback(pNotifyList->CallbackRoutine,
                                                                &notification,
                                                                pNotifyList->Context,
                                                                pNotifyList->SessionId,
                                                                pNotifyList->OpaqueSession,
                                                                NULL);
                        ASSERT(NT_SUCCESS(dispatchStatus));

                        IopAcquireNotifyLock(&IopHwProfileNotifyLock);
                        link = link->Blink;
                        IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);

                    } else {
                        link = link->Blink;
                    }

                    if (pNotifyList == vetoEntry) {
                        //
                        // Dereference the entry which vetoed the query change.
                        //
                        IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);
                    }

                } while (link != (PLIST_ENTRY)&IopProfileNotifyList);

                goto Clean0;
            }

            //
            // Reacquire the lock, walk forward, and dereference
            //
            IopAcquireNotifyLock (&IopHwProfileNotifyLock);
            link = link->Flink;
            IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);
            pNotifyList=(PHWPROFILE_NOTIFY_ENTRY)link;

        } else {
            //
            //Walk forward if we hit an unregistered node
            //
            if (pNotifyList) {
                //
                //walk forward
                //
                link = link->Flink;
                pNotifyList=(PHWPROFILE_NOTIFY_ENTRY)link;
            }
        }
    }

 Clean0:

    //UnLock the Profile Notification List
    IopReleaseNotifyLock (&IopHwProfileNotifyLock);

    return status;
}



NTSTATUS
IopNotifyTargetDeviceChange(
    IN  LPCGUID                             EventGuid,
    IN  PDEVICE_OBJECT                      DeviceObject,
    IN  PTARGET_DEVICE_CUSTOM_NOTIFICATION  NotificationStructure   OPTIONAL,
    OUT PDRIVER_OBJECT                     *VetoingDriver
    )
/*++

Routine Description:

    This routine is used to notify all registered drivers of a change to a
    particular device. It does not return until all interested parties have
    been notified.

Parameters:

    EventGuid - The event guid to send to the drivers.

    DeviceObject - The device object for the affected device.  The devnode for
        this device object contains a list of callback routines that have
        registered for notification of any changes on this device object.

    NotificationStructure - Custom notification structure to send to the
        registrants.

    VetoingDriver - Driver that vetoed the event if
                    (EventGuid == GUID_TARGET_DEVICE_QUERY_REMOVE).

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/
{
    NTSTATUS status, dispatchStatus;
    PLIST_ENTRY link;
    PTARGET_DEVICE_NOTIFY_ENTRY entry, vetoEntry;
    TARGET_DEVICE_REMOVAL_NOTIFICATION targetNotification;
    PVOID notification;
    PDEVICE_NODE deviceNode;
    BOOLEAN reverse;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);
    ASSERT(EventGuid != NULL);

    //
    // Reference the device object so it can't go away while we're doing notification
    //
    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

    ASSERT(deviceNode != NULL);


    if (ARGUMENT_PRESENT(NotificationStructure)) {

        //
        // We're handling a custom notification
        //
        NotificationStructure->Version = PNP_NOTIFICATION_VERSION;

    } else {

        //
        // Fill in the notification structure
        //
        targetNotification.Version = PNP_NOTIFICATION_VERSION;
        targetNotification.Size = sizeof(TARGET_DEVICE_REMOVAL_NOTIFICATION);
        targetNotification.Event = *EventGuid;
    }

    //
    // Lock the notify list
    //

    IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);

    //
    // Get the first entry
    //

    reverse = (BOOLEAN)IopCompareGuid(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_REMOVE_CANCELLED);

    if (reverse) {
        link = deviceNode->TargetDeviceNotify.Blink;
    } else {
        link = deviceNode->TargetDeviceNotify.Flink;
    }

    //
    // Iterate through the list
    //

    while (link != &deviceNode->TargetDeviceNotify) {

        entry = (PTARGET_DEVICE_NOTIFY_ENTRY)link;

        //
        // Only callback on registered nodes
        //

        if (!entry->Unregistered) {

            //
            // Reference the entry so that no one deletes during the callback
            // and then release the lock
            //
            IopReferenceNotify((PNOTIFY_ENTRY_HEADER)entry);
            IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);

            //
            // Select the notification structure to deliver and set the file
            // object in the notification structure to that for the current
            // entry
            //
            if (ARGUMENT_PRESENT(NotificationStructure)) {
                NotificationStructure->FileObject = entry->FileObject;
                notification = (PVOID)NotificationStructure;
            } else {
                targetNotification.FileObject = entry->FileObject;
                notification = (PVOID)&targetNotification;
            }

            //
            // Dispatch the notification to the callback routine for the
            // appropriate session.
            //
            dispatchStatus = PiNotifyDriverCallback(entry->CallbackRoutine,
                                                    notification,
                                                    entry->Context,
                                                    entry->SessionId,
                                                    entry->OpaqueSession,
                                                    &status);
            ASSERT(NT_SUCCESS(dispatchStatus));

            //
            // Failure to dispatch the notification to the specified callback
            // should not be considered a veto.
            //
            if (!NT_SUCCESS(dispatchStatus)) {
                status = STATUS_SUCCESS;
            }

            //
            // If the caller returned anything other than success and it was
            // a query remove, we veto the query remove and send cancels to
            // all callers that already got the query remove.
            //
            if (!NT_SUCCESS(status)) {

                if (IopCompareGuid(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_QUERY_REMOVE)) {

                    ASSERT(notification == (PVOID)&targetNotification);

                    if (VetoingDriver != NULL) {
                        *VetoingDriver = entry->DriverObject;
                    }

                    targetNotification.Event = GUID_TARGET_DEVICE_REMOVE_CANCELLED;

                    //
                    // Keep track of the entry that vetoed the query.  We can't
                    // dereference it just yet, because we may need to send it a
                    // cancel-remove first.  Since it's possible that the entry
                    // may have been unregistered when the list was unlocked
                    // during the query callback (removing all but the reference
                    // we are currently holding), we need to make sure we don't
                    // dereference it until we're absolutely done with it.
                    //
                    vetoEntry = entry;

                    IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);

                    //
                    // Make sure we are starting where we left off above, at the
                    // vetoing entry.
                    //
                    ASSERT((PTARGET_DEVICE_NOTIFY_ENTRY)link == vetoEntry);

                    do {
                        entry = (PTARGET_DEVICE_NOTIFY_ENTRY)link;
                        if (!entry->Unregistered) {

                            //
                            // Reference the entry so that no one deletes during
                            // the callback and then release the lock
                            //
                            IopReferenceNotify((PNOTIFY_ENTRY_HEADER)entry);
                            IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);

                            //
                            // Set the file object in the notification structure
                            // to that for the current entry
                            //
                            targetNotification.FileObject = entry->FileObject;

                            //
                            // Dispatch the notification to the callback routine
                            // for the appropriate session.
                            //
                            dispatchStatus = PiNotifyDriverCallback(entry->CallbackRoutine,
                                                                    &targetNotification,
                                                                    entry->Context,
                                                                    entry->SessionId,
                                                                    entry->OpaqueSession,
                                                                    NULL);
                            ASSERT(NT_SUCCESS(dispatchStatus));

                            //
                            // Reacquire the lock and dereference
                            //
                            IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);
                            link = link->Blink;
                            IopDereferenceNotify( (PNOTIFY_ENTRY_HEADER) entry );

                        } else {
                            link = link->Blink;
                        }

                        if (entry == vetoEntry) {
                            //
                            // Dereference the entry which vetoed the query remove.
                            //
                            IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)vetoEntry);
                        }

                    } while (link != &deviceNode->TargetDeviceNotify);

                    goto Clean0;

                } else {

                    ASSERT(notification == (PVOID)NotificationStructure);

                    IopDbgPrint((
                        IOP_IOEVENT_ERROR_LEVEL,
                        "IopNotifyTargetDeviceChange: "
                        "Driver %Z, handler @ 0x%p failed non-failable notification 0x%p with return code %x\n",
                        &entry->DriverObject->DriverName,
                        entry->CallbackRoutine,
                        notification,
                        status));

                    DbgBreakPoint();
                }
            }

            //
            // Reacquire the lock and dereference
            //
            IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);
            if (reverse) {
                link = link->Blink;
            } else {
                link = link->Flink;
            }
            IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)entry);

        } else {

            //
            // Advance down the list
            //
            if (reverse) {
                link = link->Blink;
            } else {
                link = link->Flink;
            }
        }
    }

    //
    // If it's not a query, it can't be failed.
    //
    status = STATUS_SUCCESS;

Clean0:

    //
    // Release the lock and dereference the object
    //

    IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);

    ObDereferenceObject(DeviceObject);

    return status;
}



NTSTATUS
IopNotifyDeviceClassChange(
    LPGUID EventGuid,
    LPGUID ClassGuid,
    PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine is used to notify all registered drivers of a changes to a
    particular class of device. It does not return until all interested parties have
    been notified.

Parameters:

    EventTypeGuid - The event that has occured

    ClassGuid - The device class this change has occured in

    SymbolicLinkName - The kernel mode symbolic link name of the interface device
        that changed

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/

{
    NTSTATUS status, dispatchStatus;
    PLIST_ENTRY link;
    PDEVICE_CLASS_NOTIFY_ENTRY entry;
    DEVICE_INTERFACE_CHANGE_NOTIFICATION notification;
    ULONG hash;

    PAGED_CODE();

    //
    // Fill in the notification structure
    //

    notification.Version = PNP_NOTIFICATION_VERSION;
    notification.Size = sizeof(DEVICE_INTERFACE_CHANGE_NOTIFICATION);
    notification.Event = *EventGuid;
    notification.InterfaceClassGuid = *ClassGuid;
    notification.SymbolicLinkName = SymbolicLinkName;

    //
    // Lock the notify list
    //

    IopAcquireNotifyLock(&IopDeviceClassNotifyLock);

    //
    // Get the first entry
    //

    hash = IopHashGuid(ClassGuid);
    link = IopDeviceClassNotifyList[hash].Flink;

    //
    // Iterate through the list
    //

    while (link != &IopDeviceClassNotifyList[hash]) {

        entry = (PDEVICE_CLASS_NOTIFY_ENTRY) link;

        //
        // Only callback on registered nodes of the correct device class
        //

        if ( !entry->Unregistered && IopCompareGuid(&(entry->ClassGuid), ClassGuid) ) {

            //
            // Reference the entry so that no one deletes during the callback
            // and then release the lock
            //
            IopReferenceNotify( (PNOTIFY_ENTRY_HEADER) entry );
            IopReleaseNotifyLock(&IopDeviceClassNotifyLock);

            //
            // Dispatch the notification to the callback routine for the
            // appropriate session.  Ignore the returned result for non-query
            // type events.
            //
            dispatchStatus = PiNotifyDriverCallback(entry->CallbackRoutine,
                                                    &notification,
                                                    entry->Context,
                                                    entry->SessionId,
                                                    entry->OpaqueSession,
                                                    &status);

            ASSERT(NT_SUCCESS(dispatchStatus));

            //
            // ISSUE -2000/11/27 - JAMESCA: Overactive assert
            // This assert is temporarily commented out until mountmgr is fixed.
            //
            // ASSERT(NT_SUCCESS(status));

            //
            // Reacquire the lock and dereference
            //

            IopAcquireNotifyLock(&IopDeviceClassNotifyLock);
            link = link->Flink;
            IopDereferenceNotify( (PNOTIFY_ENTRY_HEADER) entry );

        } else {

            //
            // Advance down the list
            //

            link = link->Flink;
        }
    }

    //
    // Release the lock
    //

    IopReleaseNotifyLock(&IopDeviceClassNotifyLock);

    return STATUS_SUCCESS;
}



NTSTATUS
IoRegisterPlugPlayNotification(
    IN IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
    IN ULONG EventCategoryFlags,
    IN PVOID EventCategoryData OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Context,
    OUT PVOID *NotificationEntry
    )
/*++

Routine Description:

    IoRegisterPlugPlayNotification provides a mechanism by which WDM drivers may
    receive notification (via callback) for a variety of Plug&Play events.

Arguments:

    EventCategory - Specifies the event category being registered for.  WDM drivers
        may currently register for hard-ware profile changes, device class changes
        (instance arrivals and removals), and target device changes (query-removal,
        cancel-removal, removal-complete, as well as 3rd-party extensible events).

    EventCategoryFlags - Supplies flags that modify the behavior of event registration.
        There is a separate group of flags defined for each event category.  Presently,
        only the interface device change event category has any flags defined:

            DEVICE_CLASS_NOTIFY_FOR_EXISTING_DEVICES -- Drivers wishing to retrieve a
                complete list of all interface devices presently available, and keep
                the list up-to-date (i.e., receive notification of interface device
                arrivals and removals), may specify this flag.  This will cause the
                PnP manager to immediately notify the driver about every currently-existing
                device of the specified interface class.

    EventCategoryData - Used to  'filter' events of the desired category based on the
        supplied criteria.  Not all event categories will use this parameter.  The
        event categories presently defined use this information as fol-lows:

        EventCategoryHardwareProfileChange -- this parameter is unused, and should be NULL.
        EventCategoryDeviceClassChange -- LPGUID representing the interface class of interest
        EventCategoryTargetDeviceChange -- PFILE_OBJECT of interest

    DriverObject - The caller must supply a reference to its driver object (obtained via
        ObReferenceObject), to prevent the driver from being unloaded while registered for
        notification.  The PnP Manager will dereference the driver object when the driver
        unregisters for notification via IoUnregisterPlugPlayNotification).

    CallbackRoutine - Entry point within the driver that the PnP manager should call
        whenever an applicable PnP event occurs.  The entry point must have the
        following prototype:

            typedef
            NTSTATUS
            (*PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) (
                IN PVOID NotificationStructure,
                IN PVOID Context
                );

        where NotificationStructure contains information about the event.  Each event
        GUID within an event category may potentially have its own notification structure
        format, but the buffer must al-ways begin with a PLUGPLAY_NOTIFICATION_HEADER,
        which indicates the size and ver-sion of the structure, as well as the GUID for
        the event.

        The Context parameter provides the callback with the same context data that the
        caller passed in during registration.

    Context - Points to the context data passed to the callback upon event notification.

    NotificationEntry - Upon success, receives a handle representing the notification
        registration.  This handle may be used to unregister for notification via
        IoUnregisterPlugPlayNotification.

--*/
{

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(NotificationEntry);

    //
    // Initialize out parameters
    //

    *NotificationEntry = NULL;

    //
    // Reference the driver object so it doesn't go away while we still have
    // a pointer outstanding
    //
    status = ObReferenceObjectByPointer(DriverObject,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode
                                        );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    switch (EventCategory) {

    case EventCategoryReserved:
        {

            PSETUP_NOTIFY_DATA setupData;

            //
            // Note that the only setup notification callback currently supported
            // (setupdd.sys) is never in session space.
            //

            ASSERT(MmIsSessionAddress((PVOID)CallbackRoutine) == FALSE);
            ASSERT(MmGetSessionId(PsGetCurrentProcess()) == 0);

            //
            // Allocate space for the setup data
            //

            setupData = ExAllocatePool(PagedPool, sizeof(SETUP_NOTIFY_DATA));
            if (!setupData) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean0;
            }

            //
            // Store the required information
            //

            InitializeListHead(&(setupData->ListEntry));
            setupData->EventCategory = EventCategory;
            setupData->SessionId = MmGetSessionId(PsGetCurrentProcess());
            setupData->CallbackRoutine = CallbackRoutine;
            setupData->Context = Context;
            setupData->RefCount = 1;
            setupData->Unregistered = FALSE;
            setupData->Lock = NULL;
            setupData->DriverObject = DriverObject;

            //
            // Reference the session object only if the callback is in session space
            //

            if (MmIsSessionAddress((PVOID)CallbackRoutine)) {
                setupData->OpaqueSession = MmGetSessionById(setupData->SessionId);
            } else {
                setupData->OpaqueSession = NULL;
            }

            //
            // Activate the notifications
            //

            IopSetupNotifyData = setupData;

            //
            // Explicitly NULL out the returned entry as you can *NOT* unregister
            // for setup notifications
            //

            *NotificationEntry = NULL;

            break;

        }

    case EventCategoryHardwareProfileChange:
        {
            PHWPROFILE_NOTIFY_ENTRY entry;

            //
            // new entry
            //
            entry =ExAllocatePool (PagedPool,sizeof (HWPROFILE_NOTIFY_ENTRY));
            if (!entry) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean0;
            }

            //
            // grab the fields
            //

            entry->EventCategory = EventCategory;
            entry->SessionId = MmGetSessionId(PsGetCurrentProcess());
            entry->CallbackRoutine = CallbackRoutine;
            entry->Context = Context;
            entry->RefCount = 1;
            entry->Unregistered = FALSE;
            entry->Lock = &IopHwProfileNotifyLock;
            entry->DriverObject = DriverObject;

            //
            // Reference the session object only if the callback is in session space
            //

            if (MmIsSessionAddress((PVOID)CallbackRoutine)) {
                entry->OpaqueSession = MmGetSessionById(entry->SessionId);
            } else {
                entry->OpaqueSession = NULL;
            }

            ExAcquireFastMutex(&PiNotificationInProgressLock);
            if (PiNotificationInProgress) {
                //
                // If a notification is in progress, mark the entry as
                // Unregistered until after the current notification is
                // complete.
                //

                PDEFERRED_REGISTRATION_ENTRY deferredNode;

                deferredNode = ExAllocatePool(PagedPool, sizeof(DEFERRED_REGISTRATION_ENTRY));
                if (!deferredNode) {
                    ExReleaseFastMutex(&PiNotificationInProgressLock);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto clean0;
                }

                deferredNode->NotifyEntry = (PNOTIFY_ENTRY_HEADER)entry;

                //
                // Consider this entry unregistered during the current
                // notification
                //
                entry->Unregistered = TRUE;

                //
                // Reference the entry so that it doesn't go away until it has
                // been removed from the deferred registration list
                //
                IopReferenceNotify((PNOTIFY_ENTRY_HEADER)entry);

                //
                // Add this entry to the deferred registration list
                //
                IopAcquireNotifyLock(&IopDeferredRegistrationLock);
                InsertTailList(&IopDeferredRegistrationList, (PLIST_ENTRY)deferredNode);
                IopReleaseNotifyLock(&IopDeferredRegistrationLock);
            } else {
                //
                // If there is currently no notification in progress, the deferred
                // registration list must be empty.
                //
                ASSERT(IsListEmpty(&IopDeferredRegistrationList));
            }
            ExReleaseFastMutex(&PiNotificationInProgressLock);

            //
            // Lock the list, insert the new entry, and unlock it.
            //

            IopAcquireNotifyLock(&IopHwProfileNotifyLock);
            InsertTailList(&IopProfileNotifyList, (PLIST_ENTRY)entry);
            IopReleaseNotifyLock(&IopHwProfileNotifyLock);

            *NotificationEntry = entry;

            break;
        }
    case EventCategoryTargetDeviceChange:
        {
            PTARGET_DEVICE_NOTIFY_ENTRY entry;
            PDEVICE_NODE deviceNode;

            ASSERT(EventCategoryData);

            //
            // Allocate a new list entry
            //

            entry = ExAllocatePool(PagedPool, sizeof(TARGET_DEVICE_NOTIFY_ENTRY));
            if (!entry) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean0;
            }

            //
            // Retrieve the device object associated with this file handle.
            //
            status = IopGetRelatedTargetDevice((PFILE_OBJECT)EventCategoryData,
                                               &deviceNode);
            if (!NT_SUCCESS(status)) {
                ExFreePool(entry);
                goto clean0;
            }

            //
            // Fill out the entry
            //

            entry->EventCategory = EventCategory;
            entry->SessionId = MmGetSessionId(PsGetCurrentProcess());
            entry->CallbackRoutine = CallbackRoutine;
            entry->Context = Context;
            entry->DriverObject = DriverObject;
            entry->RefCount = 1;
            entry->Unregistered = FALSE;
            entry->Lock = &IopTargetDeviceNotifyLock;
            entry->FileObject = (PFILE_OBJECT)EventCategoryData;

            //
            // Reference the session object only if the callback is in session space
            //

            if (MmIsSessionAddress((PVOID)CallbackRoutine)) {
                entry->OpaqueSession = MmGetSessionById(entry->SessionId);
            } else {
                entry->OpaqueSession = NULL;
            }

            //
            // The PDO associated with the devnode we got back from
            // IopGetRelatedTargetDevice has already been referenced by that
            // routine.  Store this reference away in the notification entry,
            // so we can deref it later when the notification entry is unregistered.
            //

            ASSERT(deviceNode->PhysicalDeviceObject);
            entry->PhysicalDeviceObject = deviceNode->PhysicalDeviceObject;

            ExAcquireFastMutex(&PiNotificationInProgressLock);
            if (PiNotificationInProgress) {
                //
                // If a notification is in progress, mark the entry as
                // Unregistered until after the current notification is
                // complete.
                //

                PDEFERRED_REGISTRATION_ENTRY deferredNode;

                deferredNode = ExAllocatePool(PagedPool, sizeof(DEFERRED_REGISTRATION_ENTRY));
                if (!deferredNode) {
                    ExReleaseFastMutex(&PiNotificationInProgressLock);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto clean0;
                }

                deferredNode->NotifyEntry = (PNOTIFY_ENTRY_HEADER)entry;

                //
                // Consider this entry unregistered during the current
                // notification
                //
                entry->Unregistered = TRUE;

                //
                // Reference the entry so that it doesn't go away until it has
                // been removed from the deferred registration list
                //
                IopReferenceNotify((PNOTIFY_ENTRY_HEADER)entry);

                //
                // Add this entry to the deferred registration list
                //
                IopAcquireNotifyLock(&IopDeferredRegistrationLock);
                InsertTailList(&IopDeferredRegistrationList, (PLIST_ENTRY)deferredNode);
                IopReleaseNotifyLock(&IopDeferredRegistrationLock);
            } else {
                //
                // If there is currently no notification in progress, the deferred
                // registration list must be empty.
                //
                ASSERT(IsListEmpty(&IopDeferredRegistrationList));
            }
            ExReleaseFastMutex(&PiNotificationInProgressLock);

            //
            // Lock the list, insert the new entry, and unlock it.
            //

            IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);
            InsertTailList(&deviceNode->TargetDeviceNotify, (PLIST_ENTRY)entry);
            IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);

            *NotificationEntry = entry;
            break;
        }

    case EventCategoryDeviceInterfaceChange:
        {
            PDEVICE_CLASS_NOTIFY_ENTRY entry;

            ASSERT(EventCategoryData);

            //
            // Allocate a new list entry
            //

            entry = ExAllocatePool(PagedPool, sizeof(DEVICE_CLASS_NOTIFY_ENTRY));
            if (!entry) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean0;
            }

            //
            // Fill out the entry
            //

            entry->EventCategory = EventCategory;
            entry->SessionId = MmGetSessionId(PsGetCurrentProcess());
            entry->CallbackRoutine = CallbackRoutine;
            entry->Context = Context;
            entry->ClassGuid = *((LPGUID) EventCategoryData);
            entry->RefCount = 1;
            entry->Unregistered = FALSE;
            entry->Lock = &IopDeviceClassNotifyLock;
            entry->DriverObject = DriverObject;

            //
            // Reference the session object only if the callback is in session space
            //

            if (MmIsSessionAddress((PVOID)CallbackRoutine)) {
                entry->OpaqueSession = MmGetSessionById(entry->SessionId);
            } else {
                entry->OpaqueSession = NULL;
            }

            ExAcquireFastMutex(&PiNotificationInProgressLock);
            if (PiNotificationInProgress) {
                //
                // If a notification is in progress, mark the entry as
                // Unregistered until after the current notification is
                // complete.
                //

                PDEFERRED_REGISTRATION_ENTRY deferredNode;

                deferredNode = ExAllocatePool(PagedPool, sizeof(DEFERRED_REGISTRATION_ENTRY));
                if (!deferredNode) {
                    ExReleaseFastMutex(&PiNotificationInProgressLock);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto clean0;
                }

                deferredNode->NotifyEntry = (PNOTIFY_ENTRY_HEADER)entry;

                //
                // Consider this entry unregistered during the current
                // notification
                //
                entry->Unregistered = TRUE;

                //
                // Reference the entry so that it doesn't go away until it has
                // been removed from the deferred registration list
                //
                IopReferenceNotify((PNOTIFY_ENTRY_HEADER)entry);

                //
                // Add this entry to the deferred registration list
                //
                IopAcquireNotifyLock(&IopDeferredRegistrationLock);
                InsertTailList(&IopDeferredRegistrationList, (PLIST_ENTRY)deferredNode);
                IopReleaseNotifyLock(&IopDeferredRegistrationLock);
            } else {
                //
                // If there is currently no notification in progress, the deferred
                // registration list must be empty.
                //
                ASSERT(IsListEmpty(&IopDeferredRegistrationList));
            }
            ExReleaseFastMutex(&PiNotificationInProgressLock);

            //
            // Lock the list
            //

            IopAcquireNotifyLock(&IopDeviceClassNotifyLock);

            //
            // Insert it at the tail
            //

            InsertTailList( (PLIST_ENTRY) &(IopDeviceClassNotifyList[ IopHashGuid(&(entry->ClassGuid)) ]),
                            (PLIST_ENTRY) entry
                          );

            //
            // Unlock the list
            //

            IopReleaseNotifyLock(&IopDeviceClassNotifyLock);

            //
            // See if we need to notify for all the device classes already present
            //

            if (EventCategoryFlags & PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES) {

                PWCHAR pSymbolicLinks, pCurrent;
                DEVICE_INTERFACE_CHANGE_NOTIFICATION notification;
                UNICODE_STRING unicodeString;

                //
                // Fill in the notification structure
                //

                notification.Version = PNP_NOTIFICATION_VERSION;
                notification.Size = sizeof(DEVICE_INTERFACE_CHANGE_NOTIFICATION);
                notification.Event = GUID_DEVICE_INTERFACE_ARRIVAL;
                notification.InterfaceClassGuid = entry->ClassGuid;

                //
                // Get the list of all the devices of this function class that are
                // already in the system
                //

                status = IoGetDeviceInterfaces(&(entry->ClassGuid),
                                                NULL,
                                                0,
                                                &pSymbolicLinks
                                                );
                if (!NT_SUCCESS(status)) {
                    //
                    // No buffer will have been returned so just return status
                    //
                    goto clean0;
                }

                //
                // Callback for each device currently in the system
                //

                pCurrent = pSymbolicLinks;
                while(*pCurrent != UNICODE_NULL) {

                    NTSTATUS dispatchStatus, tempStatus;

                    RtlInitUnicodeString(&unicodeString, pCurrent);
                    notification.SymbolicLinkName = &unicodeString;

                    //
                    // Dispatch the notification to the callback routine for the
                    // appropriate session.  Ignore the returned result for non-query
                    // type events.
                    //
                    dispatchStatus = PiNotifyDriverCallback(CallbackRoutine,
                                                            &notification,
                                                            Context,
                                                            entry->SessionId,
                                                            entry->OpaqueSession,
                                                            &tempStatus);

                    //
                    // ISSUE -2000/11/27 - JAMESCA: Overactive assert
                    //     ClusDisk failed here. The code in question is being
                    // removed, but we don't we want to make sure we flush
                    // anyone else out before we enable it again.
                    //
                    //ASSERT(NT_SUCCESS(dispatchStatus) && NT_SUCCESS(tempStatus));
                    ASSERT(NT_SUCCESS(dispatchStatus));

                    pCurrent += (unicodeString.Length / sizeof(WCHAR)) + 1;

                }

                ExFreePool(pSymbolicLinks);

            }

            *NotificationEntry = entry;
        }

        break;
    }

clean0:

    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(DriverObject);
    }

    return status;
}



NTSTATUS
IopGetRelatedTargetDevice(
    IN PFILE_OBJECT FileObject,
    OUT PDEVICE_NODE *DeviceNode
    )

/*++

Routine Description:

    IopGetRelatedTargetDevice retrieves the device object associated with
    the specified file object and then sends a query device relations irp
    to that device object.

    NOTE: The PDO associated with the returned device node has been referenced,
    and must be dereferenced when no longer needed.

Arguments:

    FileObject - Specifies the file object that is associated with the device
                 object that will receive the query device relations irp.

    DeviceNode - Returns the related target device node.

ReturnValue

    Returns an NTSTATUS value.

--*/

{
    NTSTATUS status;
    IO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject, targetDeviceObject;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_NODE targetDeviceNode;

    ASSERT(FileObject);

    //
    // Retrieve the device object associated with this file handle.
    //

    deviceObject = IoGetRelatedDeviceObject(FileObject);
    if (!deviceObject) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Query what the "actual" target device node should be for
    // this file object. Initialize the stack location to pass to
    // IopSynchronousCall() and then send the IRP to the device
    // object that's associated with the file handle.
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpSp.Parameters.QueryDeviceRelations.Type = TargetDeviceRelation;
    irpSp.DeviceObject = deviceObject;
    irpSp.FileObject = FileObject;

    status = IopSynchronousCall(deviceObject, &irpSp, (PULONG_PTR)&deviceRelations);
    if (!NT_SUCCESS(status)) {
#if 0
        IopDbgPrint((
            IOP_IOEVENT_INFO_LEVEL,
            "IopGetRelatedTargetDevice: "
            "Contact dev owner for %WZ, which may not correctly support\n"
            "\tIRP_MN_QUERY_DEVICE_RELATIONS:TargetDeviceRelation\n",
            &deviceObject->DriverObject->DriverExtension->ServiceKeyName));
        //ASSERT(0);
#endif
        return status;
    }

    ASSERT(deviceRelations);

    if (deviceRelations) {

        ASSERT(deviceRelations->Count == 1);

        if (deviceRelations->Count == 1) {

            targetDeviceObject = deviceRelations->Objects[0];

        } else {

            targetDeviceObject = NULL;
        }

        ExFreePool(deviceRelations);

        if (targetDeviceObject) {

            targetDeviceNode = (PDEVICE_NODE) targetDeviceObject->DeviceObjectExtension->DeviceNode;
            if (targetDeviceNode) {

                *DeviceNode = targetDeviceNode;
                return status;
            }
        }
    }

    //
    // Definite driver screw up. If the verifier is enabled we will fail the
    // driver. Otherwise, we will ignore this. Note that we would have crashed
    // in Win2K!
    //
    PpvUtilFailDriver(
        PPVERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
        (PVOID) deviceObject->DriverObject->MajorFunction[IRP_MJ_PNP],
        deviceObject,
        NULL
        );

    *DeviceNode = NULL;
    return STATUS_NO_SUCH_DEVICE;
}



NTSTATUS
IoGetRelatedTargetDevice(
    IN PFILE_OBJECT FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    IoGetRelatedTargetDevice retrieves the device object associated with
    the specified file object and then sends a query device relations irp
    to that device object.

    NOTE: The PDO associated with the returned device node has been referenced,
    and must be dereferenced when no longer needed.

Arguments:

    FileObject - Specifies the file object that is associated with the device
                 object that will receive the query device relations irp.

    DeviceObject - Returns the related target device object.

ReturnValue

    Returns an NTSTATUS value.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode = NULL;

    status = IopGetRelatedTargetDevice( FileObject, &deviceNode );
    if (NT_SUCCESS(status) && deviceNode != NULL) {
        *DeviceObject = deviceNode->PhysicalDeviceObject;
    }
    return status;
}



NTSTATUS
IopNotifySetupDeviceArrival(
    PDEVICE_OBJECT PhysicalDeviceObject,    // PDO of the device
    HANDLE EnumEntryKey,                    // Handle into the enum branch of the registry for this device
    BOOLEAN InstallDriver
    )

/*++

Routine Description:

    This routine is used to notify setup (during text-mode setup) of arrivals
    of a particular device. It does not return until all interested parties have
    been notified.

Parameters:

    PhysicalDeviceObject - Supplies a pointer to the PDO of the newly arrived
        device.

    EnumEntryKey - Supplies a handle to the key associated with the devide under
        the Enum\ branch of the registry.  Can be NULL in which case the key
        will be opened here.

    InstallDriver - Indicates whether setup should attempt to install a driver
                    for this object.  Device objects created through
                    IoReportDetectedDevice() already have a driver but we want
                    to indicate them to setup anyway.

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/

{
    NTSTATUS status, dispatchStatus;
    SETUP_DEVICE_ARRIVAL_NOTIFICATION notification;
    PDEVICE_NODE deviceNode;
    HANDLE enumKey = NULL;

    PAGED_CODE();

    //
    // Only perform notifications if someone has registered
    //

    if (IopSetupNotifyData) {

        if (!EnumEntryKey) {
            status = IopDeviceObjectToDeviceInstance(PhysicalDeviceObject,
                                                     &enumKey,
                                                     KEY_WRITE);
            if (!NT_SUCCESS(status)) {
                return status;
            }
            EnumEntryKey = enumKey;
        }

        //
        // Fill in the notification structure
        //
        notification.Version = PNP_NOTIFICATION_VERSION;
        notification.Size = sizeof(SETUP_DEVICE_ARRIVAL_NOTIFICATION);
        notification.Event = GUID_SETUP_DEVICE_ARRIVAL;
        notification.PhysicalDeviceObject = PhysicalDeviceObject;
        notification.EnumEntryKey = EnumEntryKey;
        deviceNode = (PDEVICE_NODE) PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;
        notification.EnumPath = &deviceNode->InstancePath;
        notification.InstallDriver = InstallDriver;

        //
        // Note that the only setup notification callback currently supported
        // (setupdd.sys) is never in session space.
        //
        ASSERT(MmIsSessionAddress((PVOID)(IopSetupNotifyData->CallbackRoutine)) == FALSE);
        ASSERT(IopSetupNotifyData->SessionId == 0);

        //
        // Dispatch the notification to the callback routine for the
        // appropriate session.
        //
        dispatchStatus = PiNotifyDriverCallback(IopSetupNotifyData->CallbackRoutine,
                                                &notification,
                                                IopSetupNotifyData->Context,
                                                IopSetupNotifyData->SessionId,
                                                IopSetupNotifyData->OpaqueSession,
                                                &status);

        ASSERT(NT_SUCCESS(dispatchStatus));

        //
        // Failure to dispatch setup notification should be reported as if a
        // match was not found, because the device has not been setup.
        //
        if (!NT_SUCCESS(dispatchStatus)) {
            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        if (enumKey) {
            ZwClose(enumKey);
        }

        return status;

    } else {

        return STATUS_OBJECT_NAME_NOT_FOUND;

    }
}



NTSTATUS
IoNotifyPowerOperationVetoed(
    IN POWER_ACTION             VetoedPowerOperation,
    IN PDEVICE_OBJECT           TargetedDeviceObject    OPTIONAL,
    IN PDEVICE_OBJECT           VetoingDeviceObject
    )
/*++

Routine Description:

    This routine is called by the power subsystem to initiate user-mode
    notification of vetoed system power events.  The power events are submitted
    into a serialized asynchronous queue.  This queue is processed by a work
    item.  This routine does not wait for the event to be processed.

Parameters:

    VetoedPowerOperation - Specifies the system-wide power action that was
                           vetoed.

    TargetedDeviceObject - Optionally, supplies the device object target of the
                           vetoed operation.

    VetoingDeviceObject  - Specifies the device object responsible for vetoing
                           the power operation.

Return Value:

    Status code that indicates whether or not the event was successfully
    inserted into the asynchronous event queue..

--*/
{
    PDEVICE_NODE deviceNode, vetoingDeviceNode;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // We have two types of power events, system wide (standby) and device
    // targetted (warm eject). Rather than have two different veto mechanisms,
    // we just retarget the operation against the root device if none is
    // specified (hey, someone's gotta represent the system, right?).
    //
    if (TargetedDeviceObject) {

        deviceObject = TargetedDeviceObject;

    } else {

        deviceObject = IopRootDeviceNode->PhysicalDeviceObject;
    }

    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        return STATUS_INVALID_PARAMETER_2;
    }

    vetoingDeviceNode = (PDEVICE_NODE)VetoingDeviceObject->DeviceObjectExtension->DeviceNode;
    if (!vetoingDeviceNode) {
        return STATUS_INVALID_PARAMETER_3;
    }

    return PpSetPowerVetoEvent(
        VetoedPowerOperation,
        NULL,
        NULL,
        deviceObject,
        PNP_VetoDevice,
        &vetoingDeviceNode->InstancePath
        );
}



ULONG
IoPnPDeliverServicePowerNotification(
    IN   POWER_ACTION           PowerOperation,
    IN   ULONG                  PowerNotificationCode,
    IN   ULONG                  PowerNotificationData,
    IN   BOOLEAN                Synchronous
    )

/*++

Routine Description:

    This routine is called by the win32k driver to notify user-mode services of
    system power events.  The power events are submitted into a serialized
    asynchronous queue.  This queue is processed by a work item.

Parameters:

    PowerOperation - Specifies the system-wide power action that has occured.
        If the Synchronous parameter is TRUE, the event is a query for
        permission to perform the supplied power operation.

    PowerNotificationCode - Supplies the power event code that is to be
        communicated to user-mode components.

        (Specifically, this event code is actually one of the PBT_APM* user-mode
        power event ids, as defined in sdk\inc\winuser.h.  It is typically used
        as the WPARAM data associated with WM_POWERBROADCAST user-mode window
        messages.  It is supplied to kernel-mode PnP, directly from win32k, for
        the explicit purpose of user-mode power event notification.)

    PowerNotificationData - Specifies additional event-specific data for the specified
        power event id.

        (Specifically, this event data is the LPARAM data for the corresponding
        PBT_APM* user-mode power event id, specified above.)

    Synchronous - Specifies whether this is a query operation.  If the event is
        a query, this routine will wait for the result of the query before
        returning.  If the query event is unsuccessful, this routine will
        initiate an appropriate veto event.


Return Value:

    Returns a non-zero value if the event was successful, zero otherwise.

--*/

{

    NTSTATUS status = STATUS_SUCCESS;
    KEVENT completionEvent;
    NTSTATUS completionStatus=STATUS_SUCCESS;
    PNP_VETO_TYPE vetoType = PNP_VetoTypeUnknown;
    UNICODE_STRING vetoName;

    PAGED_CODE();

    if (Synchronous) {

        vetoName.Buffer = ExAllocatePool (PagedPool,MAX_VETO_NAME_LENGTH*sizeof (WCHAR));

        if (vetoName.Buffer) {
            vetoName.MaximumLength = MAX_VETO_NAME_LENGTH;
        }else {
            vetoName.MaximumLength = 0;
        }
        vetoName.Length = 0;

        KeInitializeEvent(&completionEvent, NotificationEvent, FALSE);

        status = PpSetPowerEvent(PowerNotificationCode,
                                 PowerNotificationData,
                                 &completionEvent,
                                 &completionStatus,
                                 &vetoType,
                                 &vetoName);

        if (NT_SUCCESS(status))  {
            //
            // PpSetPowerEvent returns success immediately after the event has
            // been successfully inserted into the event queue.  Queued power
            // events are sent to user-mode via PiNotifyUserMode, which waits
            // for the the result.  PiNotifyUserMode signals the completionEvent
            // below when the user response is received.
            //
            KeWaitForSingleObject( &completionEvent, Executive, KernelMode, FALSE, NULL );
            status = completionStatus;

            //
            // We only have power event veto information to report if
            // user-mode responded to the event with failure.
            //
            if (!NT_SUCCESS(completionStatus)) {
                //
                // PpSetPowerVetoEvent requires a device object as the target of
                // the vetoed power operation.  Since this is a system-wide
                // event, we just target the operation against the root device.
                //
                PpSetPowerVetoEvent(PowerOperation,
                                    NULL,
                                    NULL,
                                    IopRootDeviceNode->PhysicalDeviceObject,
                                    vetoType,
                                    &vetoName);
            }
        }

        if (vetoName.Buffer) {
            ExFreePool (vetoName.Buffer);
        }

    } else {
        //
        // No response is required for 'asynchronous' (non-query) events.
        // Just set the event and go.
        //
        status = PpSetPowerEvent(PowerNotificationCode,
                                 PowerNotificationData,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);
    }

    //
    // Since the user-mode power notification routine only returns a BOOLEAN
    // success value, PiNotifyUserMode only returns one of the following status
    // values:
    //
    ASSERT ((completionStatus == STATUS_SUCCESS) ||
            (completionStatus == STATUS_UNSUCCESSFUL));

    //
    // The private code in Win32k that calls this, assumes that 0 is failure, !0 is success
    //
    return (NT_SUCCESS(completionStatus));

}



VOID
IopOrphanNotification(
    IN PDEVICE_NODE TargetNode
    )

/*++

Routine Description:

    This routine releases the references to the device object for all the
    notifications entries of a device object, then fixes up the notification
    node to not point to a physical device object.

Parameters:

    TargetNode - Specifies the device node whose registered target device
                 notification recipients are to be orphaned.

Return Value:

    None.

Notes:

    The notification node will be released when IoUnregisterPlugPlayNotification
    is actually called, but the device object will already be gone.

--*/

{
    PTARGET_DEVICE_NOTIFY_ENTRY entry;

    IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);

    while (!IsListEmpty(&TargetNode->TargetDeviceNotify)) {

        //
        // Remove all target device change notification entries for this devnode
        //

        entry = (PTARGET_DEVICE_NOTIFY_ENTRY)
            RemoveHeadList(&TargetNode->TargetDeviceNotify);

        ASSERT(entry->EventCategory == EventCategoryTargetDeviceChange);

        //
        // Re-initialize the orphaned list entry so we don't attempt to remove
        // it from the list again.
        //

        InitializeListHead((PLIST_ENTRY)entry);

        //
        // Dereference the target device object, and NULL it out so we don't
        // attempt to dereference it when the entry is actually unregistered.
        //

        if (entry->PhysicalDeviceObject) {
            ObDereferenceObject(entry->PhysicalDeviceObject);
            entry->PhysicalDeviceObject = NULL;
        }
    }

    IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);

    return;
}



NTSTATUS
PiNotifyDriverCallback(
    IN  PDRIVER_NOTIFICATION_CALLBACK_ROUTINE  CallbackRoutine,
    IN  PVOID   NotificationStructure,
    IN  PVOID   Context,
    IN  ULONG   SessionId,
    IN  PVOID   OpaqueSession      OPTIONAL,
    OUT PNTSTATUS  CallbackStatus  OPTIONAL
    )
/*++

Routine Description:

    This routine dispatches a plug and play notification event to a specified
    callback routine.

    If the callback routine specifies an address outside of session space, or if
    the calling process is already in the context of the specified session, it
    will call the callback routine directly.

    Otherwise, this routine will attempt to attach to the specified session and
    call the callback routine.

Parameters:

    CallbackRoutine - Entry point within the driver that will be called with
                      information about the event that has occured.

    NotificationStructure - Contains information about the event.

    Context         - Points to the context data supplied at registration.

    SessionId       - Specifies the ID of the session in which the specified
                      callback is to be called.

    OpqueSession    - Optionally, specifies the opaque handle to the session that
                      to attach to when the specified callback is called.

    CallbackStatus  - Optionally, supplies the address of a variable to receive
                      the NTSTATUS code returned by the callback routine.

Return Value:

    Status code that indicates whether or not the function was successful.

Notes:

    Returns STATUS_NOT_FOUND if the specified session was not found.

--*/
{
    NTSTATUS Status, CallStatus;
    KAPC_STATE ApcState;
#if DBG
    KIRQL Irql;
    ULONG ApcDisable;
#endif

    PAGED_CODE();

    //
    // Make sure we have all the information we need to deliver notification.
    //
    if (!ARGUMENT_PRESENT(CallbackRoutine) ||
        !ARGUMENT_PRESENT(NotificationStructure)) {
        return STATUS_INVALID_PARAMETER;
    }

#if DBG
    //
    // Remember the current IRQL and ApcDisable count so we can make sure
    // the callback routine returns with these in tact.
    //
    Irql = KeGetCurrentIrql();
    ApcDisable = KeGetCurrentThread()->KernelApcDisable;
#endif  // DBG

    if ((OpaqueSession == NULL) ||
        ((PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
         (SessionId == PsGetCurrentProcessSessionId()))) {
        //
        // No session object was specified, or the current process is already in
        // the specified session, so just call the callback routine directly.
        //
        ASSERT(!MmIsSessionAddress((PVOID)CallbackRoutine) || OpaqueSession);

        IopDbgPrint((
            IOP_IOEVENT_TRACE_LEVEL,
            "PiNotifyDriverCallback: "
            "calling notification callback @ 0x%p directly\n",
            CallbackRoutine));

        CallStatus = (CallbackRoutine)(NotificationStructure,
                                       Context);

        if (ARGUMENT_PRESENT(CallbackStatus)) {
            *CallbackStatus = CallStatus;
        }
        Status = STATUS_SUCCESS;

    } else {
        //
        // Otherwise, call the callback routine in session space.
        //
        ASSERT(MmIsSessionAddress((PVOID)CallbackRoutine));

        //
        // Attach to the specified session.
        //
        Status = MmAttachSession(OpaqueSession, &ApcState);
        ASSERT(NT_SUCCESS(Status));

        if (NT_SUCCESS(Status)) {
            //
            // Dispatch notification to the callback routine.
            //
            IopDbgPrint((
                IOP_IOEVENT_TRACE_LEVEL,
                "PiNotifyDriverCallback: "
                "calling notification callback @ 0x%p for SessionId %d\n",
                CallbackRoutine,
                SessionId));

            CallStatus = (CallbackRoutine)(NotificationStructure,
                                           Context);

            //
            // Return the callback status.
            //
            if (ARGUMENT_PRESENT(CallbackStatus)) {
                *CallbackStatus = CallStatus;
            }

            //
            // Detach from the session.
            //
            Status = MmDetachSession(OpaqueSession, &ApcState);
            ASSERT(NT_SUCCESS(Status));
        }
    }

#if DBG
    //
    // Check the IRQL and ApcDisable count.
    //
    if (Irql != KeGetCurrentIrql()) {
        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "PiNotifyDriverCallback: "
            "notification handler @ 0x%p returned at raised IRQL = %d, original = %d\n",
            CallbackRoutine,
            KeGetCurrentIrql(),
            Irql));
        DbgBreakPoint();
    }
    if (ApcDisable != KeGetCurrentThread()->KernelApcDisable) {
        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "PiNotifyDriverCallback: "
            "notification handler @ 0x%p returned with different KernelApcDisable = %d, original = %d\n",
            CallbackRoutine,
            KeGetCurrentThread()->KernelApcDisable,
            ApcDisable));
        DbgBreakPoint();
    }
#endif  // DBG

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pihandle.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    PiHandle.h

Abstract:

    This header contains private information to implement handle walking
    support in the PNP subsystem. This file is meant to be included only by
    pphandle.c.

Author:

    Adrian J. Oney  - April 4, 2001

Revision History:

--*/

#if DBG

typedef struct {

    PDEVICE_OBJECT                  DeviceObject;
    PEPROCESS                       Process;
    PHANDLE_ENUMERATION_CALLBACK    CallBack;
    PVOID                           Context;

} HANDLE_ENUM_CONTEXT, *PHANDLE_ENUM_CONTEXT;

BOOLEAN
PiHandleEnumerateHandlesAgainstDeviceObject(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PHANDLE_ENUMERATION_CALLBACK    HandleEnumCallBack,
    IN  PVOID                           Context
    );

BOOLEAN
PiHandleProcessWalkWorker(
    IN  PHANDLE_TABLE_ENTRY     ObjectTableEntry,
    IN  HANDLE                  HandleId,
    IN  PHANDLE_ENUM_CONTEXT    EnumContext
    );

//
// This macro uses private information from the ntos\ex module. It should be
// replaced with an inter-module define or function
//
#define OBJECT_FROM_EX_TABLE_ENTRY(x) \
    (POBJECT_HEADER)((ULONG_PTR)(x)->Object & ~7)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pilastgood.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pilastgood.h

Abstract:

    This header contains private information to implement last known good
    support in the IO subsystem. This file is meant to be included only by
    pplastgood.c.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

VOID
PiLastGoodRevertLastKnownDirectory(
    IN PUNICODE_STRING  LastKnownGoodDirectory,
    IN PUNICODE_STRING  LastKnownGoodRegPath
    );

NTSTATUS
PiLastGoodRevertCopyCallback(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    );

NTSTATUS
PiLastGoodCopyKeyContents(
    IN PUNICODE_STRING  SourceRegPath,
    IN PUNICODE_STRING  DestinationRegPath,
    IN BOOLEAN          DeleteSourceKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pihotswap.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    PiHotSwap.h

Abstract:

    This header contains private prototypes for managing hotswappable devices.
    This file should be included only by PpHotSwap.c.

Author:

    Adrian J. Oney (AdriaO) 02/10/2001

Revision History:

--*/

VOID
PiHotSwapGetDetachableNode(
    IN  PDEVICE_NODE    DeviceNode,
    OUT PDEVICE_NODE   *DetachableNode
    );

VOID
PiHotSwapGetDefaultBusRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode,
    OUT PDEVICE_REMOVAL_POLICY  RemovalPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\picontrol.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    picontrol.h

Abstract:

    This header contains private prototypes for communication between
    kernel-mode and user-mode. This file should be included only by control.c.

Author:

    Adrian J. Oney (AdriaO) 07/19/2000

Revision History:

--*/

typedef NTSTATUS (*PLUGPLAY_CONTROL_HANDLER)(
    IN     PLUGPLAY_CONTROL_CLASS   PnPControlClass,
    IN OUT PVOID                    PnPControlData,
    IN     ULONG                    PnPControlDataLength,
    IN     KPROCESSOR_MODE          CallerMode
    );

typedef struct {

    PLUGPLAY_CONTROL_CLASS      ControlCode;
    ULONG                       ControlDataSize;
    PLUGPLAY_CONTROL_HANDLER    ControlFunction;

} PLUGPLAY_CONTROL_HANDLER_DATA, *PPLUGPLAY_CONTROL_HANDLER_DATA;

NTSTATUS
PiControlMakeUserModeCallersCopy(
    PVOID           *Destination,
    PVOID           Src,
    ULONG           Length,
    ULONG           Alignment,
    KPROCESSOR_MODE CallerMode,
    BOOLEAN         AllocateDestination
    );

VOID
PiControlGetUserFlagsFromDeviceNode(
    IN  PDEVICE_NODE    DeviceNode,
    OUT ULONG          *StatusFlags
    );

NTSTATUS
PiControlStartDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlResetDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlInitializeDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlDeregisterDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlRegisterNewDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlEnumerateDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlQueryAndRemoveDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA  QueryAndRemoveData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlUserResponse(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_USER_RESPONSE_DATA UserResponseData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    );

NTSTATUS
PiControlGenerateLegacyDevice(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA LegacyDevGenData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    );

NTSTATUS
PiControlGetInterfaceDeviceList(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_INTERFACE_LIST_DATA    InterfaceData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlGetPropertyData(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_PROPERTY_DATA  PropertyData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    );

NTSTATUS
PiControlDeviceClassAssociation(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA AssociationData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlGetRelatedDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_RELATED_DEVICE_DATA    RelatedData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlGetInterfaceDeviceAlias(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA   InterfaceAliasData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlGetSetDeviceStatus(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_STATUS_DATA    StatusData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    );

NTSTATUS
PiControlGetDeviceDepth(
    IN     PLUGPLAY_CONTROL_CLASS       PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEPTH_DATA DepthData,
    IN     ULONG                        PnPControlDataLength,
    IN     KPROCESSOR_MODE              CallerMode
    );

NTSTATUS
PiControlQueryDeviceRelations(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA  RelationsData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlQueryTargetDeviceRelation(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_TARGET_RELATION_DATA   TargetData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlQueryConflictList(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_CONFLICT_DATA  ConflictData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    );

NTSTATUS
PiControlRetrieveDockData(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA DockData,
    IN     ULONG                                DockDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    );

NTSTATUS
PiControlGetDevicePowerData(
    IN  PDEVICE_NODE        DeviceNode,
    IN  KPROCESSOR_MODE     CallerMode,
    IN  ULONG               OutputBufferLength,
    IN  PVOID               PowerDataBuffer     OPTIONAL,
    OUT ULONG              *BytesWritten
    );

NTSTATUS
PiControlHaltDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pipagepath.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    PiPagePath.h

Abstract:

    This header contains private definitions for managing devices on the paging
    path. This file should be including *only* by PiPagePath.c

Author:

    Adrian J. Oney (AdriaO) February 3rd, 2001

Revision History:

    Originally taken from ChuckL's implementation in mm\modwrite.c.

--*/

NTSTATUS
PiPagePathSetState(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN      InPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\piprofile.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    PiProfile.h

Abstract:

    This header contains private prototypes for managing docking stations.
    This file should be included only by PpProfile.c.

Author:

    Adrian J. Oney (AdriaO) 07/19/2000

Revision History:

--*/

#if DBG
#define ASSERT_SEMA_NOT_SIGNALLED(SemaphoreObject) \
    ASSERT(KeReadStateSemaphore(SemaphoreObject) == 0)
#else // DBG
#define ASSERT_SEMA_NOT_SIGNALLED(SemaphoreObject)
#endif // DBG

typedef struct {

    ULONG           Depth;
    PDEVICE_OBJECT  PhysicalDeviceObject;

} BEST_DOCK_TO_EJECT, *PBEST_DOCK_TO_EJECT;

VOID
PiProfileSendHardwareProfileCommit(
    VOID
    );

VOID
PiProfileSendHardwareProfileCancel(
    VOID
    );

NTSTATUS
PiProfileUpdateHardwareProfile(
    OUT BOOLEAN     *ProfileChanged
    );

NTSTATUS
PiProfileRetrievePreferredCallback(
    IN PDEVICE_NODE         DeviceNode,
    IN PVOID                Context
    );

PDEVICE_NODE
PiProfileConvertFakeDockToRealDock(
    IN  PDEVICE_NODE    FakeDockDevnode
    );

NTSTATUS
PiProfileUpdateDeviceTree(
    VOID
    );

VOID
PiProfileUpdateDeviceTreeWorker(
    IN PVOID Context
    );

NTSTATUS
PiProfileUpdateDeviceTreeCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    );

//
// Functions not yet ported from dockhwp.c
//

NTSTATUS
IopExecuteHardwareProfileChange(
    IN  HARDWARE_PROFILE_BUS_TYPE   Bus,
    IN  PWCHAR                    * ProfileSerialNumbers,
    IN  ULONG                       SerialNumbersCount,
    OUT PHANDLE                     NewProfile,
    OUT PBOOLEAN                    ProfileChanged
    );

NTSTATUS
IopExecuteHwpDefaultSelect (
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse,
    IN  PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpcvrt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pnpcvrt.c

Abstract:

    This module contains support routines for the translating PnP resources.

Author:

    Robert Nelson (robertn) 13-October-1997


Environment:

    Kernel mode

--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// This is a cpp style symbolic link
//
#include "convert.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpdata.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpdata.c

Abstract:

    This module contains the plug-and-play data

Author:

    Shie-Lin Tzong (shielint) 30-Jan-1995

Environment:

    Kernel mode


Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <initguid.h>

//
// INIT data segment
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

PVOID IopPnpScratchBuffer1 = NULL;
PVOID IopPnpScratchBuffer2 = NULL;
PCM_RESOURCE_LIST IopInitHalResources;
PDEVICE_NODE IopInitHalDeviceNode;
PIOP_RESERVED_RESOURCES_RECORD IopInitReservedResourceList;

//
// Regular data segment
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

//
// IopRootDeviceNode - the head of the PnP manager's device node tree.
//

PDEVICE_NODE IopRootDeviceNode;

//
// IoPnPDriverObject - the madeup driver object for pnp manager
//

PDRIVER_OBJECT IoPnpDriverObject;

//
// IopPnPSpinLock - spinlock for Pnp code.
//

KSPIN_LOCK IopPnPSpinLock;

//
// IopDeviceTreeLock - performs synchronization around the whole device node tree.
//

ERESOURCE IopDeviceTreeLock;

//
// IopSurpriseRemoveListLock - synchronizes access to the surprise remove list.
//

ERESOURCE IopSurpriseRemoveListLock;

//
// PiEngineLock - Synchronizes the start/enum and remove engines.
//

ERESOURCE PiEngineLock;

//
// PiEventQueueEmpty - Manual reset event which is set when the queue is empty
//

KEVENT PiEventQueueEmpty;

//
// PiEnumerationLock - to synchronize boot phase device enumeration
//

KEVENT PiEnumerationLock;

//
// IopNumberDeviceNodes - Number of outstanding device nodes in the system.
//

ULONG IopNumberDeviceNodes;

//
// IopPnpEnumerationRequestList - a link list of device enumeration requests to worker thread.
//

LIST_ENTRY IopPnpEnumerationRequestList;

//
// PnPInitComplete - A flag to indicate if PnP initialization is completed.
//

BOOLEAN PnPInitialized;

//
// PnPBootDriverInitialied
//

BOOLEAN PnPBootDriversInitialized;

//
// PnPBootDriverLoaded
//

BOOLEAN PnPBootDriversLoaded;

//
// IopBootConfigsReserved - Indicates whether we have reserved BOOT configs or not.
//

BOOLEAN IopBootConfigsReserved;

//
// Variable to hold boot allocation routine.
//

PIO_ALLOCATE_BOOT_RESOURCES_ROUTINE IopAllocateBootResourcesRoutine;

//
// Device node tree sequence.  Is bumped every time the tree is modified or a warm
// eject is queued.
//

ULONG IoDeviceNodeTreeSequence;

//
// PnpDefaultInterfaceTYpe - Use this if the interface type of resource list is unknown.
//

INTERFACE_TYPE PnpDefaultInterfaceType;

//
// PnpStartAsynOk - control how start irp should be handled. Synchronously or Asynchronously?
//

BOOLEAN PnpAsyncOk;

//
// IopMaxDeviceNodeLevel - Level number of the DeviceNode deepest in the tree
//
ULONG IopMaxDeviceNodeLevel;

//
// IopPendingEjects - List of pending eject requests
//
LIST_ENTRY  IopPendingEjects;

//
// IopPendingSurpriseRemovals - List of pending surprise removal requests
//
LIST_ENTRY  IopPendingSurpriseRemovals;

//
// Warm eject lock - only one warm eject is allowed to occur at a time
//
KEVENT IopWarmEjectLock;

//
// This field contains a devobj if a warm eject is in progress.
//
PDEVICE_OBJECT IopWarmEjectPdo;

//
// Arbiter data
//

ARBITER_INSTANCE IopRootPortArbiter;
ARBITER_INSTANCE IopRootMemArbiter;
ARBITER_INSTANCE IopRootDmaArbiter;
ARBITER_INSTANCE IopRootIrqArbiter;
ARBITER_INSTANCE IopRootBusNumberArbiter;

//
// The following resource is used to control access to device-related, Plug and Play-specific
// portions of the registry. These portions are:
//
//   HKLM\System\Enum
//   HKLM\System\CurrentControlSet\Hardware Profiles
//   HKLM\System\CurrentControlSet\Services\<service>\Enum
//
// It allows exclusive access for writing, as well as shared access for reading.
// The resource is initialized by the PnP manager initialization code during phase 0
// initialization.
//

ERESOURCE  PpRegistryDeviceResource;

//
// Table for Legacy Bus information
//
LIST_ENTRY  IopLegacyBusInformationTable[MaximumInterfaceType];

//
// Set to TRUE in the shutdown process.  This prevents us from starting any
// PNP operations once there is no longer a reasonable expectation they will
// succeed.
//
BOOLEAN PpPnpShuttingDown;

//
// The following semaphore is used by the IO system when it reports resource
// usage to the configuration registry on behalf of a driver.  This semaphore
// is initialized by the I/O system initialization code when the system is
// started.
//
KSEMAPHORE PpRegistrySemaphore;

//DEFINE_GUID(REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID, 0x8ECC055D, 0x047F, 0x11D1, 0xA5, 0x37, 0x00, 0x00, 0xF8, 0x75, 0x3E, 0xD1);

SYSTEM_HIVE_LIMITS PpSystemHiveLimits = {0};
BOOLEAN PpSystemHiveTooLarge = FALSE;

//
// This is really gross.
// HACK for MATROX G100 because it was too late to make this change for XP.
//

BOOLEAN PpCallerInitializesRequestTable = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpbusno.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pnpbusno.c

Abstract:

    Root Bus Number arbiter

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Constants
//


#define MAX_ULONGLONG           ((ULONGLONG) -1)

//
// Prototypes
//

NTSTATUS
IopBusNumberInitialize(
    VOID
    );

NTSTATUS
IopBusNumberUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
IopBusNumberPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
IopBusNumberScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
IopBusNumberUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );


//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IopBusNumberInitialize)
#pragma alloc_text(PAGE, IopBusNumberUnpackRequirement)
#pragma alloc_text(PAGE, IopBusNumberPackResource)
#pragma alloc_text(PAGE, IopBusNumberScoreRequirement)
#pragma alloc_text(PAGE, IopBusNumberUnpackResource)

#endif // ALLOC_PRAGMA

//
// Implementation
//

NTSTATUS
IopBusNumberInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{
    NTSTATUS    status;

    IopRootBusNumberArbiter.UnpackRequirement = IopBusNumberUnpackRequirement;
    IopRootBusNumberArbiter.PackResource = IopBusNumberPackResource;
    IopRootBusNumberArbiter.UnpackResource = IopBusNumberUnpackResource;
    IopRootBusNumberArbiter.ScoreRequirement = IopBusNumberScoreRequirement;

    status = ArbInitializeArbiterInstance(&IopRootBusNumberArbiter,
                                          NULL,  // Indicates a root arbiter
                                          CmResourceTypeBusNumber,
                                          L"RootBusNumber",
                                          L"Root",
                                          NULL    // no translation of BusNumber
                                          );
    if (NT_SUCCESS(status)) {

        //
        // Add the invalid range 100 - ffffffff ffffffff
        //
        RtlAddRange( IopRootBusNumberArbiter.Allocation,
                     (ULONGLONG) 0x100,
                     (ULONGLONG) -1,
                     0, // UserFlags
                     0, // Flag
                     NULL,
                     NULL
                   );

    }

    return status;
}

//
// Arbiter callbacks
//

NTSTATUS
IopBusNumberUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    ARB_PRINT(2,
                ("Unpacking BusNumber requirement %p => 0x%I64x-0x%I64x\n",
                Descriptor,
                (ULONGLONG) Descriptor->u.BusNumber.MinBusNumber,
                (ULONGLONG) Descriptor->u.BusNumber.MaxBusNumber
                ));

    *Minimum = (ULONGLONG) Descriptor->u.BusNumber.MinBusNumber;
    *Maximum = (ULONGLONG) Descriptor->u.BusNumber.MaxBusNumber;
    *Length = Descriptor->u.BusNumber.Length;
    *Alignment = 1;

    return STATUS_SUCCESS;

}

LONG
IopBusNumberScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    score = (Descriptor->u.BusNumber.MaxBusNumber -
                Descriptor->u.BusNumber.MinBusNumber) /
                Descriptor->u.BusNumber.Length;

    ARB_PRINT(2,
                ("Scoring BusNumber resource %p => %i\n",
                Descriptor,
                score
                ));

    return score;
}

NTSTATUS
IopBusNumberPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start < ((ULONG)-1));
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeBusNumber);

    ARB_PRINT(2,
                ("Packing BusNumber resource %p => 0x%I64x\n",
                Descriptor,
                Start
                ));

    Descriptor->Type = CmResourceTypeBusNumber;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->u.BusNumber.Start = (ULONG) Start;
    Descriptor->u.BusNumber.Length = Requirement->u.BusNumber.Length;

    return STATUS_SUCCESS;
}

NTSTATUS
IopBusNumberUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    End - Pointer to where the end value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start);
    ASSERT(Length);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    *Start = (ULONGLONG) Descriptor->u.BusNumber.Start;
    *Length = Descriptor->u.BusNumber.Length;

    ARB_PRINT(2,
                ("Unpacking BusNumber resource %p => 0x%I64x\n",
                Descriptor,
                *Start
                ));

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpdma.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    pnpdma.c

Abstract:

    Root DMA arbiter

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Constants
//


#define MAX_ULONGLONG           ((ULONGLONG) -1)

//
// Prototypes
//

NTSTATUS
IopDmaInitialize(
    VOID
    );

NTSTATUS
IopDmaUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
IopDmaPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
IopDmaScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
IopDmaUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );


BOOLEAN
IopDmaOverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IopDmaInitialize)
#pragma alloc_text(PAGE, IopDmaUnpackRequirement)
#pragma alloc_text(PAGE, IopDmaPackResource)
#pragma alloc_text(PAGE, IopDmaScoreRequirement)
#pragma alloc_text(PAGE, IopDmaUnpackResource)
#pragma alloc_text(PAGE, IopDmaOverrideConflict)
#endif // ALLOC_PRAGMA

//
// Implementation
//

NTSTATUS
IopDmaInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{

    IopRootDmaArbiter.UnpackRequirement = IopDmaUnpackRequirement;
    IopRootDmaArbiter.PackResource = IopDmaPackResource;
    IopRootDmaArbiter.UnpackResource = IopDmaUnpackResource;
    IopRootDmaArbiter.ScoreRequirement = IopDmaScoreRequirement;
    IopRootDmaArbiter.OverrideConflict = IopDmaOverrideConflict;

    return ArbInitializeArbiterInstance(&IopRootDmaArbiter,
                                        NULL,
                                        CmResourceTypeDma,
                                        L"RootDMA",
                                        L"Root",
                                        NULL    // no translation of DMA
                                       );
}

//
// Arbiter callbacks
//

NTSTATUS
IopDmaUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeDma);

    ARB_PRINT(2,
                ("Unpacking DMA requirement %p => 0x%I64x-0x%I64x\n",
                Descriptor,
                (ULONGLONG) Descriptor->u.Dma.MinimumChannel,
                (ULONGLONG) Descriptor->u.Dma.MaximumChannel
                ));

    *Minimum = (ULONGLONG) Descriptor->u.Dma.MinimumChannel;
    *Maximum = (ULONGLONG) Descriptor->u.Dma.MaximumChannel;
    *Length = 1;
    *Alignment = 1;

    return STATUS_SUCCESS;

}

LONG
IopDmaScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeDma);

    score = Descriptor->u.Dma.MaximumChannel - Descriptor->u.Dma.MinimumChannel;

    ARB_PRINT(2,
                ("Scoring DMA resource %p => %i\n",
                Descriptor,
                score
                ));

    return score;
}

NTSTATUS
IopDmaPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start < ((ULONG)-1));
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeDma);

    ARB_PRINT(2,
                ("Packing DMA resource %p => 0x%I64x\n",
                Descriptor,
                Start
                ));

    Descriptor->Type = CmResourceTypeDma;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->u.Dma.Channel = (ULONG) Start;
    Descriptor->u.Dma.Port = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
IopDmaUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    Length - Pointer to where the length value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{

    *Start = Descriptor->u.Dma.Channel;
    *Length = 1;

    ARB_PRINT(2,
                ("Unpacking DMA resource %p => 0x%I64x\n",
                Descriptor,
                *Start
                ));

    return STATUS_SUCCESS;

}


BOOLEAN
IopDmaOverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    Just say no.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if the conflict is allowable, false otherwise

--*/

{
    UNREFERENCED_PARAMETER( Arbiter );
    UNREFERENCED_PARAMETER( State );

    PAGED_CODE();

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpdel.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    pnpdel.c

Abstract:

    This module contains routines to perform device removal

Author:

    Robert B. Nelson (RobertN) Jun 1, 1998.

Revision History:

--*/

#include "pnpmgrp.h"
#include "wdmguid.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'edpP')
#endif

//
// Kernel mode PNP specific routines.
//

NTSTATUS
IopCancelPendingEject(
    IN PPENDING_RELATIONS_LIST_ENTRY EjectEntry
    );

VOID
IopDelayedRemoveWorker(
    IN PVOID Context
    );

BOOLEAN
IopDeleteLockedDeviceNode(
    IN  PDEVICE_NODE                    DeviceNode,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN  PRELATION_LIST                  RelationsList,
    IN  ULONG                           Problem,
    OUT PNP_VETO_TYPE                  *VetoType        OPTIONAL,
    OUT PUNICODE_STRING                 VetoName        OPTIONAL
    );

NTSTATUS
IopProcessRelation(
    IN      PDEVICE_NODE                    DeviceNode,
    IN      PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN      BOOLEAN                         IsDirectDescendant,
    OUT     PNP_VETO_TYPE                  *VetoType,
    OUT     PUNICODE_STRING                 VetoName,
    IN OUT  PRELATION_LIST                  RelationsList
    );

VOID
IopSurpriseRemoveLockedDeviceNode(
    IN      PDEVICE_NODE     DeviceNode,
    IN OUT  PRELATION_LIST   RelationsList
    );

BOOLEAN
IopQueryRemoveLockedDeviceNode(
    IN  PDEVICE_NODE        DeviceNode,
    OUT PNP_VETO_TYPE      *VetoType,
    OUT PUNICODE_STRING     VetoName
    );

VOID
IopCancelRemoveLockedDeviceNode(
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopRemoveLockedDeviceNode(
    IN      PDEVICE_NODE    DeviceNode,
    IN      ULONG           Problem,
    IN OUT  PRELATION_LIST  RelationsList
    );

typedef struct {

    BOOLEAN TreeDeletion;
    BOOLEAN DescendantNode;

} REMOVAL_WALK_CONTEXT, *PREMOVAL_WALK_CONTEXT;

NTSTATUS
PipRequestDeviceRemovalWorker(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID        Context
    );

NTSTATUS
PiProcessBusRelations(
    IN      PDEVICE_NODE                    DeviceNode,
    IN      PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN      BOOLEAN                         IsDirectDescendant,
    OUT     PNP_VETO_TYPE                  *VetoType,
    OUT     PUNICODE_STRING                 VetoName,
    IN OUT  PRELATION_LIST                  RelationsList
    );

WORK_QUEUE_ITEM IopDeviceRemovalWorkItem;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopChainDereferenceComplete)
#pragma alloc_text(PAGE, IopDelayedRemoveWorker)
#pragma alloc_text(PAGE, IopDeleteLockedDeviceNode)
#pragma alloc_text(PAGE, IopSurpriseRemoveLockedDeviceNode)
#pragma alloc_text(PAGE, IopQueryRemoveLockedDeviceNode)
#pragma alloc_text(PAGE, IopCancelRemoveLockedDeviceNode)
#pragma alloc_text(PAGE, IopDeleteLockedDeviceNodes)
#pragma alloc_text(PAGE, IopInvalidateRelationsInList)
#pragma alloc_text(PAGE, IopBuildRemovalRelationList)
#pragma alloc_text(PAGE, IopProcessCompletedEject)
#pragma alloc_text(PAGE, IopProcessRelation)
#pragma alloc_text(PAGE, IopQueuePendingEject)
#pragma alloc_text(PAGE, IopQueuePendingSurpriseRemoval)
#pragma alloc_text(PAGE, IopUnloadAttachedDriver)
#pragma alloc_text(PAGE, IopUnlinkDeviceRemovalRelations)
#pragma alloc_text(PAGE, PipRequestDeviceRemoval)
#pragma alloc_text(PAGE, PipRequestDeviceRemovalWorker)
#pragma alloc_text(PAGE, PipIsBeingRemovedSafely)
#pragma alloc_text(PAGE, PiProcessBusRelations)
#endif

VOID
IopChainDereferenceComplete(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  BOOLEAN         OnCleanStack
    )

/*++

Routine Description:

    This routine is invoked when the reference count on a PDO and all its
    attached devices transitions to a zero.  It tags the devnode as ready for
    removal.  If all the devnodes are tagged then IopDelayedRemoveWorker is
    called to actually send the remove IRPs.

Arguments:

    PhysicalDeviceObject - Supplies a pointer to the PDO whose references just
        went to zero.

    OnCleanStack - Indicates whether the current thread is in the middle a
                   driver operation.

Return Value:

    None.

--*/

{
    PPENDING_RELATIONS_LIST_ENTRY   entry;
    PLIST_ENTRY                     link;
    ULONG                           count;
    ULONG                           taggedCount;
    NTSTATUS                        status;

    PAGED_CODE();

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&IopSurpriseRemoveListLock, TRUE);

    //
    // Find the relation list this devnode is a member of.
    //
    for (link = IopPendingSurpriseRemovals.Flink;
         link != &IopPendingSurpriseRemovals;
         link = link->Flink) {

        entry = CONTAINING_RECORD(link, PENDING_RELATIONS_LIST_ENTRY, Link);

        //
        // Tag the devnode as ready for remove.  If it isn't in this list
        //
        status = IopSetRelationsTag( entry->RelationsList, PhysicalDeviceObject, TRUE );

        if (NT_SUCCESS(status)) {
            taggedCount = IopGetRelationsTaggedCount( entry->RelationsList );
            count = IopGetRelationsCount( entry->RelationsList );

            if (taggedCount == count) {
                //
                // Remove relations list from list of pending surprise removals.
                //
                RemoveEntryList( link );

                ExReleaseResourceLite(&IopSurpriseRemoveListLock);
                KeLeaveCriticalRegion();

                if ((!OnCleanStack) ||
                    (PsGetCurrentProcess() != PsInitialSystemProcess)) {

                    //
                    // Queue a work item to do the removal so we call the driver
                    // in the system process context rather than the random one
                    // we're in now.
                    //
                    ExInitializeWorkItem( &entry->WorkItem,
                                        IopDelayedRemoveWorker,
                                        entry);

                    ExQueueWorkItem(&entry->WorkItem, DelayedWorkQueue);

                } else {

                    //
                    // We are already in the system process and not in some
                    // random ObDeref call, so call the worker inline.
                    //
                    IopDelayedRemoveWorker( entry );
                }

                return;
            }

            break;
        }
    }

    ASSERT(link != &IopPendingSurpriseRemovals);

    ExReleaseResourceLite(&IopSurpriseRemoveListLock);
    KeLeaveCriticalRegion();
}

VOID
IopDelayedRemoveWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is usually called from a worker thread to actually send the
    remove IRPs once the reference count on a PDO and all its attached devices
    transitions to a zero.

Arguments:

    Context - Supplies a pointer to the pending relations list entry which has
        the relations list of PDOs we need to remove.

Return Value:

    None.

--*/

{
    PPENDING_RELATIONS_LIST_ENTRY entry = (PPENDING_RELATIONS_LIST_ENTRY)Context;

    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    IopDeleteLockedDeviceNodes( entry->DeviceObject,
                                entry->RelationsList,
                                RemoveDevice,           // OperationCode
                                FALSE,                  // ProcessIndirectDescendants
                                entry->Problem,         // Problem
                                NULL,                   // VetoType
                                NULL);                  // VetoName

    //
    // The final reference on DeviceNodes in the DeviceNodeDeletePendingCloses
    // state is dropped here.
    //
    IopFreeRelationList( entry->RelationsList );

    ExFreePool( entry );
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
}


BOOLEAN
IopDeleteLockedDeviceNode(
    IN  PDEVICE_NODE                    DeviceNode,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN  PRELATION_LIST                  RelationsList,
    IN  ULONG                           Problem,
    OUT PNP_VETO_TYPE                  *VetoType        OPTIONAL,
    OUT PUNICODE_STRING                 VetoName        OPTIONAL
    )
/*++

Routine Description:

    This function assumes that the specified device is a bus and will
    recursively remove all its children.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be removed.

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_OBJECT deviceObject;
    BOOLEAN success;

    PAGED_CODE();

    IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
              "IopDeleteLockedDeviceNode: Entered\n    DeviceNode = 0x%p\n    OperationCode = 0x%08X\n    RelationsList = 0x%p\n    Problem = %d\n",
              DeviceNode,
              OperationCode,
              RelationsList,
              Problem));

    success = TRUE;
    switch(OperationCode) {

        case SurpriseRemoveDevice:

            IopSurpriseRemoveLockedDeviceNode(DeviceNode, RelationsList);
            break;

        case RemoveDevice:

            IopRemoveLockedDeviceNode(DeviceNode, Problem, RelationsList);
            break;

        case QueryRemoveDevice:

            ASSERT(VetoType && VetoName);

            success = IopQueryRemoveLockedDeviceNode(
                DeviceNode,
                VetoType,
                VetoName
                );

            break;

        case CancelRemoveDevice:

            IopCancelRemoveLockedDeviceNode(DeviceNode);
            break;

        default:
            ASSERT(0);
            break;
    }

    return success;
}


VOID
IopSurpriseRemoveLockedDeviceNode(
    IN      PDEVICE_NODE     DeviceNode,
    IN OUT  PRELATION_LIST   RelationsList
    )
/*++

Routine Description:

    This function sends a surprise remove IRP to a devnode and processes the
    results.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be surprise removed.

Return Value:

    None.

--*/
{
    PNP_DEVNODE_STATE devnodeState, schedulerState;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE child, nextChild;
    NTSTATUS status;

    PAGED_CODE();

    schedulerState = DeviceNode->State;

    ASSERT((schedulerState == DeviceNodeAwaitingQueuedDeletion) ||
           (schedulerState == DeviceNodeAwaitingQueuedRemoval));

    //
    // Clear the scheduling state (DeviceNodeAwaitingQueuedDeletion) off
    // the state stack.
    //
    PipRestoreDevNodeState(DeviceNode);

    devnodeState = DeviceNode->State;

    //
    // Do our state updates.
    //
    PpHotSwapInitRemovalPolicy(DeviceNode);

    if (devnodeState == DeviceNodeRemovePendingCloses) {

        //
        // If the state is DeviceNodeRemovePendingCloses, we should have got
        // here via DeviceNodeAwaitingQueuedDeletion. We're probably surprise
        // removing a device that was already surprise failed.
        //
        ASSERT(schedulerState == DeviceNodeAwaitingQueuedDeletion);

        //ASSERT(DeviceNode->Child == NULL);
        PipSetDevNodeState(DeviceNode, DeviceNodeDeletePendingCloses, NULL);
        return;
    }

    //
    // Detach any children from the tree here. If they needed SurpriseRemove
    // IRPs, they already will have received them.
    //
    for(child = DeviceNode->Child; child; child = nextChild) {

        //
        // Grab a copy of the next sibling before we blow away this devnode.
        //
        nextChild = child->Sibling;

        if (child->Flags & DNF_ENUMERATED) {
            child->Flags &= ~DNF_ENUMERATED;
        }

        //
        // If the child has resources and we are wiping out the parent, we need
        // to drop the resources (the parent will lose them when his arbiter is
        // nuked with the upcoming SurpriseRemoveDevice.)
        //
        if (PipDoesDevNodeHaveResources(child)) {

            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                       "IopSurpriseRemoveLockedDeviceNode: Releasing resources for child device = 0x%p\n",
                       child->PhysicalDeviceObject));

            //
            // ADRIAO N.B. 2000/08/21 -
            //     Note that if the child stack has no drivers then a Remove
            // IRP could be sent here. The stack would be unable to distinguish
            // this from AddDevice cleanup.
            //
/*
            if ((child->State == DeviceNodeUninitialized) ||
                (child->State == DeviceNodeInitialized)) {

                IopRemoveDevice(child->PhysicalDeviceObject, IRP_MN_REMOVE_DEVICE);
            }
*/
            IopReleaseDeviceResources(child, FALSE);
        }

        //
        // The devnode will be removed from the tree in
        // IopUnlinkDeviceRemovalRelations. We don't remove it here as we want
        // the tree structure in place for the upcoming broadcast down to user
        // mode.
        //
        // Note - Children in the Uninitialized/Initialized states are not
        //        put directly into DeviceNodeDeleted today. This could be
        //        done but we'd have to verify what happens to API calls in
        //        response to SurpriseRemoval notifications. (Actually, those
        //        API's are blocked in ppcontrol.c, hotplug cannot in fact
        //        walk the tree!)
        //
        PipSetDevNodeState(child, DeviceNodeDeletePendingCloses, NULL);
    }

    //
    // Only send surprise removes where neccessary.
    //
    // ISSUE - 2000/08/24 - ADRIAO: Maintaining noncorrect Win2K behavior
    //                      Win2K erroneously sent SR's to nonstarted nodes.
    //
    deviceObject = DeviceNode->PhysicalDeviceObject;

    status = IopRemoveDevice(deviceObject, IRP_MN_SURPRISE_REMOVAL);

    if ((devnodeState == DeviceNodeStarted) ||
        (devnodeState == DeviceNodeStopped) ||
        (devnodeState == DeviceNodeRestartCompletion)) {

        //deviceObject = DeviceNode->PhysicalDeviceObject;

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopSurpriseRemoveLockedDeviceNode: Sending surprise remove irp to device = 0x%p\n",
                   deviceObject));

        //status = IopRemoveDevice(deviceObject, IRP_MN_SURPRISE_REMOVAL);

        //
        // Disable any device interfaces that may still be enabled for this
        // device after the removal.
        //
        IopDisableDeviceInterfaces(&DeviceNode->InstancePath);

        if (NT_SUCCESS(status)) {

            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                       "IopSurpriseRemoveLockedDeviceNode: Releasing devices resources\n"));

            IopReleaseDeviceResources(DeviceNode, FALSE);
        }

        if (DeviceNode->Flags & DNF_ENUMERATED) {

            PipSetDevNodeState(DeviceNode, DeviceNodeRemovePendingCloses, NULL);

        } else {

            ASSERT(schedulerState == DeviceNodeAwaitingQueuedDeletion);
            PipSetDevNodeState(DeviceNode, DeviceNodeDeletePendingCloses, NULL);
        }
    }

    ASSERT(DeviceNode->DockInfo.DockStatus != DOCK_ARRIVING);
}


BOOLEAN
IopQueryRemoveLockedDeviceNode(
    IN  PDEVICE_NODE        DeviceNode,
    OUT PNP_VETO_TYPE      *VetoType,
    OUT PUNICODE_STRING     VetoName
    )
/*++

Routine Description:

    This function sends a query remove IRP to a devnode and processes the
    results.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be query removed.

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

Return Value:

    BOOLEAN (success/failure).

--*/
{
    PNP_DEVNODE_STATE devnodeState;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;

    PAGED_CODE();

    devnodeState = DeviceNode->State;

    switch(devnodeState) {
        case DeviceNodeUninitialized:
        case DeviceNodeInitialized:
        case DeviceNodeRemoved:
            //
            // Don't send Queries to devices that haven't been started.
            //
            ASSERT(DeviceNode->Child == NULL);
            return TRUE;

        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
            //
            // ISSUE - 2000/08/24 - ADRIAO: Maintaining noncorrect Win2K behavior
            //                      Win2K erroneously sent QR's to all nodes.
            //
            break;

        case DeviceNodeStarted:
            //
            // This guy needs to be queried
            //
            break;

        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeAwaitingQueuedDeletion:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
            //
            // These states should have been culled by IopProcessRelation
            //
            ASSERT(0);
            return TRUE;

        case DeviceNodeQueryStopped:
        case DeviceNodeEnumeratePending:
        case DeviceNodeStartPending:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeQueryRemoved:
        case DeviceNodeDeletePendingCloses:
        case DeviceNodeDeleted:
        case DeviceNodeUnspecified:
        default:
            //
            // None of these should be seen here.
            //
            ASSERT(0);
            return TRUE;
    }

    ASSERT(PipAreDriversLoaded(DeviceNode));

    deviceObject = DeviceNode->PhysicalDeviceObject;

    IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
               "IopQueryRemoveLockedDeviceNode: Sending QueryRemove irp to device = 0x%p\n",
               deviceObject));

    status = IopRemoveDevice(deviceObject, IRP_MN_QUERY_REMOVE_DEVICE);

    if (!NT_SUCCESS(status)) {

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopQueryRemoveLockedDeviceNode: QueryRemove vetoed by device = 0x%p, sending CancelRemove\n",
                   deviceObject));

        IopRemoveDevice(deviceObject, IRP_MN_CANCEL_REMOVE_DEVICE);

        *VetoType = PNP_VetoDevice;
        RtlCopyUnicodeString(VetoName, &DeviceNode->InstancePath);
        return FALSE;
    }

    PipSetDevNodeState(DeviceNode, DeviceNodeQueryRemoved, NULL);
    return TRUE;
}


VOID
IopCancelRemoveLockedDeviceNode(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This function sends a cancel remove IRP to a devnode and processes the
    results.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be cancel removed.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    if (DeviceNode->State != DeviceNodeQueryRemoved) {

        return;
    }

    //
    // ISSUE - 2000/08/24 - ADRIAO: Maintaining noncorrect Win2K behavior
    //                      Win2K erroneously sent QR's to all nodes.
    //
    //ASSERT(DeviceNode->PreviousState == DeviceNodeStarted);

    deviceObject = DeviceNode->PhysicalDeviceObject;

    IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
               "IopCancelRemoveLockedDeviceNode: Sending CancelRemove irp to device = 0x%p\n",
               deviceObject));

    IopRemoveDevice(deviceObject, IRP_MN_CANCEL_REMOVE_DEVICE);

    PipRestoreDevNodeState(DeviceNode);
}


VOID
IopRemoveLockedDeviceNode(
    IN      PDEVICE_NODE    DeviceNode,
    IN      ULONG           Problem,
    IN OUT  PRELATION_LIST  RelationsList
    )
/*++

Routine Description:

    This function sends a remove IRP to a devnode and processes the
    results.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be removed.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject = DeviceNode->PhysicalDeviceObject;
    PDEVICE_OBJECT *attachedDevices, device1, *device2;
    PDRIVER_OBJECT *attachedDrivers, *driver;
    ULONG length = 0;
    NTSTATUS status;
    PDEVICE_NODE child, nextChild;
    PDEVICE_OBJECT childPDO;
    BOOLEAN removeIrpNeeded;

    PAGED_CODE();

    //
    // Do our state updates.
    //
    PpHotSwapInitRemovalPolicy(DeviceNode);

    //
    // Make sure we WILL drop our references to its children.
    //
    for(child = DeviceNode->Child; child; child = nextChild) {

        //
        // Grab a copy of the next sibling before we blow away this devnode.
        //
        nextChild = child->Sibling;

        if (child->Flags & DNF_ENUMERATED) {
            child->Flags &= ~DNF_ENUMERATED;
        }

        ASSERT(child->State == DeviceNodeRemoved);
        ASSERT(!PipAreDriversLoaded(child));

        //
        // If the child has resources and we are wiping out the parent, we need
        // to drop the resources (the parent will lose them when his arbiter is
        // nuked with the upcoming RemoveDevice.)
        //
        if (PipDoesDevNodeHaveResources(child)) {

            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                       "IopRemoveLockedDeviceNode: Releasing resources for child device = 0x%p\n",
                       child->PhysicalDeviceObject));

            //
            // ADRIAO N.B. 2000/08/21 -
            //     Note that the child stack has no drivers and as such a
            // Remove IRP could be sent here. The stack would be unable to
            // distinguish this from AddDevice cleanup.
            //
            IopRemoveDevice(child->PhysicalDeviceObject, IRP_MN_REMOVE_DEVICE);

            IopReleaseDeviceResources(child, FALSE);
        }

        //
        // The devnode will be removed from the tree in
        // IopUnlinkDeviceRemovalRelations. We don't remove it here as we want
        // the tree structure in place for the upcoming broadcast down to user
        // mode.
        //
        PipSetDevNodeState(child, DeviceNodeDeleted, NULL);
    }

    if ((DeviceNode->State == DeviceNodeAwaitingQueuedDeletion) ||
        (DeviceNode->State == DeviceNodeAwaitingQueuedRemoval)) {

        if (!(DeviceNode->Flags & DNF_ENUMERATED)) {

            ASSERT(DeviceNode->State == DeviceNodeAwaitingQueuedDeletion);
            //
            // This happens when pnpevent shortcircuits the surprise remove path
            // upon discovering a nonstarted device has been removed from the
            // system. This devnode will need a final remove if it alone has been
            // pulled from the tree (we don't here know if the parent is going to
            // get pulled too, which would make this remove IRP unneccessary.)
            //
            //PipRestoreDevNodeState(DeviceNode);
            PipSetDevNodeState(DeviceNode, DeviceNodeDeletePendingCloses, NULL);

        } else {

            ASSERT(DeviceNode->State == DeviceNodeAwaitingQueuedRemoval);
            PipRestoreDevNodeState(DeviceNode);
        }
    }

    //
    // Do the final remove cleanup on the device...
    //
    switch(DeviceNode->State) {

        case DeviceNodeUninitialized:
        case DeviceNodeInitialized:
        case DeviceNodeRemoved:
            //
            // ISSUE - 2000/08/24 - ADRIAO: Maintaining noncorrect Win2K behavior
            //                      Win2K erroneously sent SR's and R's to all
            //                      nodes. Those bugs must be fixed in tandem.
            //
            //removeIrpNeeded = FALSE;
            removeIrpNeeded = TRUE;
            break;

        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
        case DeviceNodeQueryRemoved:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeDeletePendingCloses:
            //
            // Expected.
            //
            removeIrpNeeded = TRUE;
            break;

        case DeviceNodeStarted:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
        case DeviceNodeQueryStopped:
        case DeviceNodeEnumeratePending:
        case DeviceNodeStartPending:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeAwaitingQueuedDeletion:
        case DeviceNodeDeleted:
        case DeviceNodeUnspecified:
        default:
            //
            // None of these should be seen here.
            //
            ASSERT(0);
            removeIrpNeeded = TRUE;
            break;
    }

    //
    // Add a reference to each FDO attached to the PDO such that the FDOs won't
    // actually go away until the removal operation is completed.
    // Note we need to make a copy of all the attached devices because we won't be
    // able to traverse the attached chain when the removal operation is done.
    //
    // ISSUE - 2000/08/21 - ADRIAO: Low resource path
    //     The allocation failure cases here are quite broken, and now that
    // IofCallDriver and IofCompleteRequest reference things appropriately, all
    // this is strictly unneccessary.
    //
    device1 = deviceObject->AttachedDevice;
    while (device1) {
        length++;
        device1 = device1->AttachedDevice;
    }

    attachedDevices = NULL;
    attachedDrivers = NULL;
    if (length != 0) {

        length = (length + 2) * sizeof(PDEVICE_OBJECT);

        attachedDevices = (PDEVICE_OBJECT *) ExAllocatePool(PagedPool, length);
        if (attachedDevices) {

            attachedDrivers = (PDRIVER_OBJECT *) ExAllocatePool(PagedPool, length);
            if (attachedDrivers) {

                RtlZeroMemory(attachedDevices, length);
                RtlZeroMemory(attachedDrivers, length);
                device1 = deviceObject->AttachedDevice;
                device2 = attachedDevices;
                driver = attachedDrivers;

                while (device1) {
                    ObReferenceObject(device1);
                    *device2++ = device1;
                    *driver++ = device1->DriverObject;
                    device1 = device1->AttachedDevice;
                }

            } else {

                ExFreePool(attachedDevices);
                attachedDevices = NULL;
            }
        }
    }

    if (removeIrpNeeded) {

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopRemoveLockedDeviceNode: Sending remove irp to device = 0x%p\n",
                   deviceObject));

        IopRemoveDevice(deviceObject, IRP_MN_REMOVE_DEVICE);

        if (DeviceNode->State == DeviceNodeQueryRemoved) {
            //
            // Disable any device interfaces that may still be enabled for this
            // device after the removal.
            //
            IopDisableDeviceInterfaces(&DeviceNode->InstancePath);
        }

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopRemoveLockedDeviceNode: Releasing devices resources\n"));

        //
        // ISSUE - 2000/3/8 - RobertN - This doesn't take into account the
        // cleanup of surprise removed devices.  We will query for boot configs
        // unnecessarily.  We should probably also check if the parent is NULL.
        //
        IopReleaseDeviceResources(
            DeviceNode,
            (BOOLEAN) ((DeviceNode->Flags & DNF_ENUMERATED) != 0)
            );
    }

    if (!(DeviceNode->Flags & DNF_ENUMERATED)) {
        //
        // If the device is a dock, remove it from the list of dock devices
        // and change the current Hardware Profile, if necessary.
        //
        ASSERT(DeviceNode->DockInfo.DockStatus != DOCK_ARRIVING) ;
        if ((DeviceNode->DockInfo.DockStatus == DOCK_DEPARTING)||
            (DeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED)) {

            PpProfileCommitTransitioningDock(DeviceNode, DOCK_DEPARTING);
        }
    }

    //
    // Remove the reference to the attached FDOs to allow them to be actually
    // deleted.
    //
    device2 = attachedDevices;
    if (device2 != NULL) {
        driver = attachedDrivers;
        while (*device2) {
            (*device2)->DeviceObjectExtension->ExtensionFlags &= ~(DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED);
            (*device2)->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;
            IopUnloadAttachedDriver(*driver);
            ObDereferenceObject(*device2);
            device2++;
            driver++;
        }
        ExFreePool(attachedDevices);
        ExFreePool(attachedDrivers);
    }

    deviceObject->DeviceObjectExtension->ExtensionFlags &= ~(DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED);
    deviceObject->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;

    //
    // Now mark this one removed if it's still in the tree.
    //
    if (DeviceNode->Flags & DNF_ENUMERATED) {

        ASSERT(DeviceNode->Parent);
        PipSetDevNodeState(DeviceNode, DeviceNodeRemoved, NULL);

    } else if (DeviceNode->Parent != NULL) {

        //
        // The devnode will be removed from the tree in
        // IopUnlinkDeviceRemovalRelations.
        //
        PipSetDevNodeState(DeviceNode, DeviceNodeDeleted, NULL);

    } else {

        ASSERT(DeviceNode->State == DeviceNodeDeletePendingCloses);
        PipSetDevNodeState(DeviceNode, DeviceNodeDeleted, NULL);
    }

    //
    // Set the problem codes appropriatly. We don't change the problem codes
    // on a devnode unless:
    // a) It disappeared.
    // b) We're disabling it.
    //
    if ((!PipDoesDevNodeHaveProblem(DeviceNode)) ||
        (Problem == CM_PROB_DEVICE_NOT_THERE) ||
        (Problem == CM_PROB_DISABLED)) {

        PipClearDevNodeProblem(DeviceNode);
        PipSetDevNodeProblem(DeviceNode, Problem);
    }
}


NTSTATUS
IopDeleteLockedDeviceNodes(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PRELATION_LIST                  RelationsList,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN  BOOLEAN                         ProcessIndirectDescendants,
    IN  ULONG                           Problem,
    OUT PNP_VETO_TYPE                  *VetoType                    OPTIONAL,
    OUT PUNICODE_STRING                 VetoName                    OPTIONAL
    )
/*++

Routine Description:

    This routine performs requested operation on the DeviceObject and
    the device objects specified in the DeviceRelations.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    DeviceRelations - supplies a pointer to the device's removal relations.

    OperationCode - Operation code, i.e., QueryRemove, CancelRemove, Remove...

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT relatedDeviceObject;
    ULONG marker;
    BOOLEAN directDescendant;

    PAGED_CODE();

    IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
               "IopDeleteLockedDeviceNodes: Entered\n    DeviceObject = 0x%p\n    RelationsList = 0x%p\n    OperationCode = %d\n",
               DeviceObject,
               RelationsList,
               OperationCode));

    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;

    marker = 0;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  TRUE)) {

        //
        // Depending on the operation we need to do different things.
        //
        //  QueryRemoveDevice / CancelRemoveDevice
        //      Process both direct and indirect descendants
        //
        //  SurpriseRemoveDevice / RemoveDevice
        //      Ignore indirect descendants
        //
        if (directDescendant || ProcessIndirectDescendants) {

            deviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            if (!IopDeleteLockedDeviceNode( deviceNode,
                                            OperationCode,
                                            RelationsList,
                                            Problem,
                                            VetoType,
                                            VetoName)) {

                ASSERT(OperationCode == QueryRemoveDevice);

                while (IopEnumerateRelations( RelationsList,
                                              &marker,
                                              &relatedDeviceObject,
                                              NULL,
                                              NULL,
                                              FALSE)) {

                    deviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                    IopDeleteLockedDeviceNode( deviceNode,
                                               CancelRemoveDevice,
                                               RelationsList,
                                               Problem,
                                               VetoType,
                                               VetoName);
                }

                status = STATUS_UNSUCCESSFUL;
                goto exit;
            }
        }
    }

exit:
    return status;
}

NTSTATUS
IopBuildRemovalRelationList(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    OUT PNP_VETO_TYPE                  *VetoType,
    OUT PUNICODE_STRING                 VetoName,
    OUT PRELATION_LIST                 *RelationsList
    )
/*++

Routine Description:

    This routine locks the device subtrees for removal operation and returns
    a list of device objects which need to be removed with the specified
    DeviceObject.

    Caller must hold a reference to the DeviceObject.

Arguments:

    DeviceObject - Supplies a pointer to the device object to be removed.

    OperationCode - Operation code, i.e., QueryEject, CancelEject, Eject...

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

    RelationList - supplies a pointer to a variable to receive the device's
                   relations.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject;
    PDEVICE_NODE            deviceNode, parent;
    PRELATION_LIST          newRelationsList;
    ULONG                   marker;
    BOOLEAN                 tagged;

    PAGED_CODE();

    *RelationsList = NULL;

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

    //
    // Obviously no one should try to delete the whole device node tree.
    //
    ASSERT(DeviceObject != IopRootDeviceNode->PhysicalDeviceObject);

    if ((newRelationsList = IopAllocateRelationList(OperationCode)) == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // First process the object itself
    //
    status = IopProcessRelation(
        deviceNode,
        OperationCode,
        TRUE,
        VetoType,
        VetoName,
        newRelationsList
        );

    ASSERT(status != STATUS_INVALID_DEVICE_REQUEST);

    if (NT_SUCCESS(status)) {
        IopCompressRelationList(&newRelationsList);
        *RelationsList = newRelationsList;

        //
        // At this point we have a list of all the relations, those that are
        // direct descendants of the original device we are ejecting or
        // removing have the DirectDescendant bit set.
        //
        // Relations which were merged from an existing eject have the tagged
        // bit set.
        //
        // All of the relations and their parents are locked.
        //
        // There is a reference on each device object by virtue of it being in
        // the list.  There is another one on each device object because it is
        // locked and the lock count is >= 1.
        //
        // There is also a reference on each relation's parent and it's lock
        // count is >= 1.
        //
    } else {

        IopFreeRelationList(newRelationsList);
    }

    return status;
}

NTSTATUS
PiProcessBusRelations(
    IN      PDEVICE_NODE                    DeviceNode,
    IN      PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN      BOOLEAN                         IsDirectDescendant,
    OUT     PNP_VETO_TYPE                  *VetoType,
    OUT     PUNICODE_STRING                 VetoName,
    IN OUT  PRELATION_LIST                  RelationsList
    )
/*++

Routine Description:

    This routine processes the BusRelations for the specified devnode.    
    Caller must hold the device tree lock.

Arguments:

    DeviceNode - Supplies a pointer to the device object to be collected.

    OperationCode - Operation code, i.e., QueryRemove, QueryEject, ...

    IsDirectDescendant - TRUE if the device object is a direct descendant
                         of the node the operation is being performed upon.

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

    RelationList - supplies a pointer to a variable to receive the device's
                   removal relations.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_NODE child;
    PDEVICE_OBJECT childDeviceObject;
    NTSTATUS status;

    PAGED_CODE();

    for(child = DeviceNode->Child;
        child != NULL;
        child = child->Sibling) {

        childDeviceObject = child->PhysicalDeviceObject;

        status = IopProcessRelation(
            child,
            OperationCode,
            IsDirectDescendant,
            VetoType,
            VetoName,
            RelationsList
            );

        ASSERT(status == STATUS_SUCCESS || status == STATUS_UNSUCCESSFUL);

        if (!NT_SUCCESS(status)) {

            return status;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopProcessRelation(
    IN      PDEVICE_NODE                    DeviceNode,
    IN      PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN      BOOLEAN                         IsDirectDescendant,
    OUT     PNP_VETO_TYPE                  *VetoType,
    OUT     PUNICODE_STRING                 VetoName,
    IN OUT  PRELATION_LIST                  RelationsList
    )
/*++

Routine Description:

    This routine builds the list of device objects that need to be removed or
    examined when the passed in device object is torn down.

    Caller must hold the device tree lock.

Arguments:

    DeviceNode - Supplies a pointer to the device object to be collected.

    OperationCode - Operation code, i.e., QueryRemove, QueryEject, ...

    IsDirectDescendant - TRUE if the device object is a direct descendant
                         of the node the operation is being performed upon.

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

    RelationList - supplies a pointer to a variable to receive the device's
                   removal relations.


Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_NODE                    relatedDeviceNode;
    PDEVICE_OBJECT                  relatedDeviceObject;
    PDEVICE_RELATIONS               deviceRelations;
    PLIST_ENTRY                     ejectLink;
    PPENDING_RELATIONS_LIST_ENTRY   ejectEntry;
    PRELATION_LIST                  pendingRelationList;
    PIRP                            pendingIrp;
    NTSTATUS                        status;
    ULONG                           i;
    PNP_DEVNODE_STATE               devnodeState;

    PAGED_CODE();

    if (OperationCode == QueryRemoveDevice || OperationCode == EjectDevice) {

        if (DeviceNode->State == DeviceNodeDeleted) {

            //
            // The device has already been removed, fail the attempt.
            //
            return STATUS_UNSUCCESSFUL;
        }

        if ((DeviceNode->State == DeviceNodeAwaitingQueuedRemoval) ||
            (DeviceNode->State == DeviceNodeAwaitingQueuedDeletion)) {

            //
            // The device has failed or is going away.  Let the queued
            // remove deal with it.
            //
            return STATUS_UNSUCCESSFUL;
        }

        if ((DeviceNode->State == DeviceNodeRemovePendingCloses) ||
            (DeviceNode->State == DeviceNodeDeletePendingCloses)) {

            //
            // The device is in the process of being surprise removed, let it finish
            //
            *VetoType = PNP_VetoOutstandingOpen;
            RtlCopyUnicodeString(VetoName, &DeviceNode->InstancePath);
            return STATUS_UNSUCCESSFUL;
        }

        if ((DeviceNode->State == DeviceNodeStopped) ||
            (DeviceNode->State == DeviceNodeRestartCompletion)) {

            //
            // We are recovering from a rebalance. This should never happen and
            // this return code will cause us to ASSERT.
            //
            return STATUS_INVALID_DEVICE_REQUEST;
        }

    } else if (DeviceNode->State == DeviceNodeDeleted) {

        //
        // The device has already been removed, ignore it. We should only have
        // seen such a thing if it got handed to us in a Removal or Ejection
        // relation.
        //
        ASSERT(!IsDirectDescendant);
        return STATUS_SUCCESS;
    }

    status = IopAddRelationToList( RelationsList,
                                   DeviceNode->PhysicalDeviceObject,
                                   IsDirectDescendant,
                                   FALSE);

    if (status == STATUS_SUCCESS) {

        if (!(DeviceNode->Flags & DNF_LOCKED_FOR_EJECT)) {

            //
            // Then process the bus relations
            //
            status = PiProcessBusRelations(
                DeviceNode,
                OperationCode,
                IsDirectDescendant,
                VetoType,
                VetoName,
                RelationsList
                );
            if (!NT_SUCCESS(status)) {

                return status;
            }

            //
            // Retrieve the state of the devnode when it failed.
            //
            devnodeState = DeviceNode->State;
            if ((devnodeState == DeviceNodeAwaitingQueuedRemoval) ||
                (devnodeState == DeviceNodeAwaitingQueuedDeletion)) {

                devnodeState = DeviceNode->PreviousState;
            }

            //
            // Next the removal relations
            //
            if ((devnodeState == DeviceNodeStarted) ||
                (devnodeState == DeviceNodeStopped) ||
                (devnodeState == DeviceNodeRestartCompletion)) {

                status = IopQueryDeviceRelations( RemovalRelations,
                                                  DeviceNode->PhysicalDeviceObject,
                                                  TRUE,
                                                  &deviceRelations);

                if (NT_SUCCESS(status) && deviceRelations) {

                    for (i = 0; i < deviceRelations->Count; i++) {

                        relatedDeviceObject = deviceRelations->Objects[i];

                        relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                        ASSERT(relatedDeviceNode);

                        if (relatedDeviceNode) {

                            status = IopProcessRelation(
                                relatedDeviceNode,
                                OperationCode,
                                FALSE,
                                VetoType,
                                VetoName,
                                RelationsList
                                );
                        }

                        ObDereferenceObject( relatedDeviceObject );

                        ASSERT(status == STATUS_SUCCESS ||
                               status == STATUS_UNSUCCESSFUL);

                        if (!NT_SUCCESS(status)) {

                            ExFreePool(deviceRelations);

                            return status;
                        }
                    }

                    ExFreePool(deviceRelations);
                } else {
                    if (status != STATUS_NOT_SUPPORTED) {
                        IopDbgPrint((IOP_LOADUNLOAD_WARNING_LEVEL,
                                   "IopProcessRelation: IopQueryDeviceRelations failed, DeviceObject = 0x%p, status = 0x%08X\n",
                                   DeviceNode->PhysicalDeviceObject, status));
                    }
                }
            }

            //
            // Finally the eject relations if we are doing an eject operation
            //
            if (OperationCode != QueryRemoveDevice &&
                OperationCode != RemoveFailedDevice &&
                OperationCode != RemoveUnstartedFailedDevice) {
                status = IopQueryDeviceRelations( EjectionRelations,
                                                  DeviceNode->PhysicalDeviceObject,
                                                  TRUE,
                                                  &deviceRelations);

                if (NT_SUCCESS(status) && deviceRelations) {

                    for (i = 0; i < deviceRelations->Count; i++) {

                        relatedDeviceObject = deviceRelations->Objects[i];

                        relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                        ASSERT(relatedDeviceNode);

                        if (relatedDeviceNode) {

                            status = IopProcessRelation(
                                relatedDeviceNode,
                                OperationCode,
                                FALSE,
                                VetoType,
                                VetoName,
                                RelationsList
                                );
                        }

                        ObDereferenceObject( relatedDeviceObject );

                        ASSERT(status == STATUS_SUCCESS ||
                               status == STATUS_UNSUCCESSFUL);

                        if (!NT_SUCCESS(status)) {

                            ExFreePool(deviceRelations);

                            return status;
                        }
                    }

                    ExFreePool(deviceRelations);
                } else {
                    if (status != STATUS_NOT_SUPPORTED) {
                        IopDbgPrint((IOP_LOADUNLOAD_WARNING_LEVEL,
                                   "IopProcessRelation: IopQueryDeviceRelations failed, DeviceObject = 0x%p, status = 0x%08X\n",
                                   DeviceNode->PhysicalDeviceObject,
                                   status));
                    }
                }
            }

            status = STATUS_SUCCESS;

        } else {

            //
            // Look to see if this device is already part of a pending ejection.
            // If it is and we are doing an ejection then we will subsume it
            // within the larger ejection.  If we aren't doing an ejection then
            // we better be processing the removal of one of the ejected devices.
            //
            for(ejectLink = IopPendingEjects.Flink;
                ejectLink != &IopPendingEjects;
                ejectLink = ejectLink->Flink) {

                ejectEntry = CONTAINING_RECORD( ejectLink,
                                                PENDING_RELATIONS_LIST_ENTRY,
                                                Link);

                if (ejectEntry->RelationsList != NULL &&
                    IopIsRelationInList(ejectEntry->RelationsList, DeviceNode->PhysicalDeviceObject)) {


                    if (OperationCode == EjectDevice) {

                        status = IopRemoveRelationFromList(RelationsList, DeviceNode->PhysicalDeviceObject);

                        ASSERT(NT_SUCCESS(status));

                        pendingIrp = InterlockedExchangePointer(&ejectEntry->EjectIrp, NULL);
                        pendingRelationList = ejectEntry->RelationsList;
                        ejectEntry->RelationsList = NULL;

                        if (pendingIrp != NULL) {
                            IoCancelIrp(pendingIrp);
                        }

                        //
                        //     If a parent fails eject and it has a child that is
                        // infinitely pending an eject, this means the child now
                        // wakes up. One suggestion brought up that does not involve
                        // a code change is to amend the WDM spec to say if driver
                        // gets a start IRP for a device pending eject, it should
                        // cancel the eject IRP automatically.
                        //
                        IopMergeRelationLists(RelationsList, pendingRelationList, FALSE);

                        IopFreeRelationList(pendingRelationList);

                        if (IsDirectDescendant) {
                            //
                            // If IsDirectDescendant is specified then we need to
                            // get that bit set on the relation that caused us to
                            // do the merge.  IopAddRelationToList will fail with
                            // STATUS_OBJECT_NAME_COLLISION but the bit will still
                            // be set as a side effect.
                            //
                            IopAddRelationToList( RelationsList,
                                                  DeviceNode->PhysicalDeviceObject,
                                                  TRUE,
                                                  FALSE);
                        }
                    } else if (OperationCode != QueryRemoveDevice) {

                        //
                        // Either the device itself disappeared or an ancestor
                        // of this device failed in some way. In both cases this
                        // happened before we completed the eject IRP. We'll
                        // remove it from the list in the pending ejection and
                        // return it.
                        //

                        status = IopRemoveRelationFromList( ejectEntry->RelationsList,
                                                            DeviceNode->PhysicalDeviceObject);

                        DeviceNode->Flags &= ~DNF_LOCKED_FOR_EJECT;

                        ASSERT(NT_SUCCESS(status));

                    } else {

                        //
                        // Someone is trying to take offline a supertree of this
                        // device which happens to be prepared for ejection.
                        // Whistler like Win2K won't let this happen (doing so
                        // isn't too hard, it involves writing code to cancel
                        // the outstanding eject and free the relation list.)
                        //
                        ASSERT(0);
                        return STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;
                }
            }

            ASSERT(ejectLink != &IopPendingEjects);

            if (ejectLink == &IopPendingEjects) {

                PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceNode->PhysicalDeviceObject);
                KeBugCheckEx( PNP_DETECTED_FATAL_ERROR,
                              PNP_ERR_DEVICE_MISSING_FROM_EJECT_LIST,
                              (ULONG_PTR)DeviceNode->PhysicalDeviceObject,
                              0,
                              0);
            }
        }
    } else if (status == STATUS_OBJECT_NAME_COLLISION) {

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopProcessRelation: Duplicate relation, DeviceObject = 0x%p\n",
                   DeviceNode->PhysicalDeviceObject));

        status = PiProcessBusRelations(
            DeviceNode,
            OperationCode,
            IsDirectDescendant,
            VetoType,
            VetoName,
            RelationsList
            );

    } else if (status != STATUS_INSUFFICIENT_RESOURCES) {

        PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceNode->PhysicalDeviceObject);
        KeBugCheckEx( PNP_DETECTED_FATAL_ERROR,
                      PNP_ERR_UNEXPECTED_ADD_RELATION_ERR,
                      (ULONG_PTR)DeviceNode->PhysicalDeviceObject,
                      (ULONG_PTR)RelationsList,
                      status);
    }

    return status;
}

BOOLEAN
IopQueuePendingEject(
    PPENDING_RELATIONS_LIST_ENTRY Entry
    )
{
    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    InsertTailList(&IopPendingEjects, &Entry->Link);

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    return TRUE;
}

NTSTATUS
IopInvalidateRelationsInList(
    IN  PRELATION_LIST              RelationsList,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE OperationCode,
    IN  BOOLEAN                     OnlyIndirectDescendants,
    IN  BOOLEAN                     RestartDevNode
    )
/*++

Routine Description:

    Iterate over the relations in the list creating a second list containing the
    parent of each entry skipping parents which are also in the list.  In other
    words, if the list contains node P and node C where node C is a child of node
    P then the parent of node P would be added but not node P itself.


Arguments:

    RelationsList           - List of relations

    OperationCode           - Type of operation the invalidation is associated
                              with.

    OnlyIndirectDescendants - Indirect relations are those which aren't direct
                              descendants (bus relations) of the PDO originally
                              targetted for the operation or its direct
                              descendants.  This would include Removal or
                              Eject relations.

    RestartDevNode          - If true then any node who's parent was invalidated
                              is restarted.  This flag requires that all the
                              relations in the list have been previously
                              sent a remove IRP.


Return Value:

    NTSTATUS code.

--*/
{
    PRELATION_LIST                  parentsList;
    PDEVICE_OBJECT                  deviceObject, parentObject;
    PDEVICE_NODE                    deviceNode;
    ULONG                           marker;
    BOOLEAN                         directDescendant, tagged;

    PAGED_CODE();

    parentsList = IopAllocateRelationList(OperationCode);

    if (parentsList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IopSetAllRelationsTags( RelationsList, FALSE );

    //
    // Traverse the list creating a new list with the topmost parents of
    // each sublist contained in RelationsList.
    //

    marker = 0;

    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &deviceObject,
                                  &directDescendant,
                                  &tagged,
                                  TRUE)) {

        if (!OnlyIndirectDescendants || !directDescendant) {

            if (!tagged) {

                parentObject = deviceObject;

                while (IopSetRelationsTag( RelationsList, parentObject, TRUE ) == STATUS_SUCCESS) {

                    deviceNode = parentObject->DeviceObjectExtension->DeviceNode;

                    if (RestartDevNode)  {

                        deviceNode->Flags &= ~DNF_LOCKED_FOR_EJECT;

                        //
                        // Bring the devnode back online if it:
                        // a) It is still physically present
                        // b) It was held for an eject
                        //
                        if ((deviceNode->Flags & DNF_ENUMERATED) &&
                            PipIsDevNodeProblem(deviceNode, CM_PROB_HELD_FOR_EJECT)) {

                            ASSERT(deviceNode->Child == NULL);
                            ASSERT(!PipAreDriversLoaded(deviceNode));

                            //
                            // This operation is a reorder barrier. This keeps
                            // our subsequent enumeration from draining prior
                            // to our problem clearing.
                            //
                            PipRequestDeviceAction( parentObject,
                                                    ClearEjectProblem,
                                                    TRUE,
                                                    0,
                                                    NULL,
                                                    NULL );
                        }
                    }

                    if (deviceNode->Parent != NULL) {

                        parentObject = deviceNode->Parent->PhysicalDeviceObject;

                    } else {
                        parentObject = NULL;
                        break;
                    }
                }

                if (parentObject != NULL)  {
                    IopAddRelationToList( parentsList, parentObject, FALSE, FALSE );
                }
            }

        }
    }

    //
    // Reenumerate each of the parents
    //

    marker = 0;

    while (IopEnumerateRelations( parentsList,
                                  &marker,
                                  &deviceObject,
                                  NULL,
                                  NULL,
                                  FALSE)) {

        PipRequestDeviceAction( deviceObject,
                                ReenumerateDeviceTree,
                                FALSE,
                                0,
                                NULL,
                                NULL );
    }

    //
    // Free the parents list
    //

    IopFreeRelationList( parentsList );

    return STATUS_SUCCESS;
}

VOID
IopProcessCompletedEject(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called at passive level from a worker thread that was queued
    either when an eject IRP completed (see io\pnpirp.c - IopDeviceEjectComplete
    or io\pnpirp.c - IopEjectDevice), or when a warm eject needs to be performed.
    We also may need to fire off any enumerations of parents of ejected devices
    to verify they have indeed left.

Arguments:

    Context - Pointer to the pending relations list which contains the device
              to eject (warm) and the list of parents to reenumerate.

Return Value:

    None.

--*/
{
    PPENDING_RELATIONS_LIST_ENTRY entry = (PPENDING_RELATIONS_LIST_ENTRY)Context;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if ((entry->LightestSleepState != PowerSystemWorking) &&
        (entry->LightestSleepState != PowerSystemUnspecified)) {

        //
        // For docks, WinLogon gets to do the honors. For other devices, the
        // user must infer when it's safe to remove the device (if we've powered
        // up, it may not be safe now!)
        //
        entry->DisplaySafeRemovalDialog = FALSE;

        //
        // This is a warm eject request, initiate it here.
        //
        status = IopWarmEjectDevice(entry->DeviceObject, entry->LightestSleepState);

        //
        // We're back and we either succeeded or failed. Either way...
        //
    }

    if (entry->DockInterface) {

        entry->DockInterface->ProfileDepartureSetMode(
            entry->DockInterface->Context,
            PDS_UPDATE_DEFAULT
            );

        entry->DockInterface->InterfaceDereference(
            entry->DockInterface->Context
            );
    }

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    RemoveEntryList( &entry->Link );

    //
    // Check if the RelationsList pointer in the context structure is NULL.  If
    // so, this means we were cancelled because this eject is part of a new
    // larger eject.  In that case all we want to do is unlink and free the
    // context structure.
    //

    //
    // Two interesting points about such code.
    //
    // 1) If you wait forever to complete an eject of a dock, we *wait* forever
    //    in the Query profile change state. No sneaky adding another dock. You
    //    must finish what you started...
    // 2) Let's say you are ejecting a dock, and it is taking a long time. If
    //    you try to eject the parent, that eject will *not* grab this lower
    //    eject as we will block on the profile change semaphore. Again, finish
    //    what you started...
    //

    if (entry->RelationsList != NULL)  {

        if (entry->ProfileChangingEject) {

            PpProfileMarkAllTransitioningDocksEjected();
        }

        IopInvalidateRelationsInList(
            entry->RelationsList,
            EjectDevice,
            FALSE,
            TRUE
            );

        //
        // Free the relations list
        //

        IopFreeRelationList( entry->RelationsList );

    } else {

        entry->DisplaySafeRemovalDialog = FALSE;
    }

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Complete the event
    //
    if (entry->DeviceEvent != NULL ) {

        PpCompleteDeviceEvent( entry->DeviceEvent, status );
    }

    if (entry->DisplaySafeRemovalDialog) {

        PpSetDeviceRemovalSafe(entry->DeviceObject, NULL, NULL);
    }

    ObDereferenceObject(entry->DeviceObject);
    ExFreePool( entry );
}

VOID
IopQueuePendingSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRELATION_LIST List,
    IN ULONG Problem
    )
{
    PPENDING_RELATIONS_LIST_ENTRY   entry;

    PAGED_CODE();

    entry = (PPENDING_RELATIONS_LIST_ENTRY) PiAllocateCriticalMemory(
        SurpriseRemoveDevice,
        NonPagedPool,
        sizeof(PENDING_RELATIONS_LIST_ENTRY),
        0
        );

    ASSERT(entry != NULL);

    entry->DeviceObject = DeviceObject;
    entry->RelationsList = List;
    entry->Problem = Problem;
    entry->ProfileChangingEject = FALSE ;

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&IopSurpriseRemoveListLock, TRUE);

    InsertTailList(&IopPendingSurpriseRemovals, &entry->Link);

    ExReleaseResourceLite(&IopSurpriseRemoveListLock);
    KeLeaveCriticalRegion();
}

VOID
IopUnlinkDeviceRemovalRelations(
    IN      PDEVICE_OBJECT          RemovedDeviceObject,
    IN OUT  PRELATION_LIST          RelationsList,
    IN      UNLOCK_UNLINK_ACTION    UnlinkAction
    )
/*++

Routine Description:

    This routine unlocks the device tree deletion operation.
    If there is any pending kernel deletion, this routine initiates
    a worker thread to perform the work.

Arguments:

    RemovedDeviceObject - Supplies a pointer to the device object to which the
        remove was originally targetted (as opposed to one of the relations).

    DeviceRelations - supplies a pointer to the device's removal relations.

    UnlinkAction - Specifies which devnodes will be unlinked from the devnode
        tree.

        UnLinkRemovedDeviceNodes - Devnodes which are no longer enumerated and
            have been sent a REMOVE_DEVICE IRP are unlinked.

        UnlinkAllDeviceNodesPendingClose - This is used when a device is
            surprise removed.  Devnodes in RelationsList are unlinked from the
            tree if they don't have children and aren't consuming any resources.

        UnlinkOnlyChildDeviceNodesPendingClose - This is used when a device fails
            while started.  We unlink any child devnodes of the device which
            failed but not the failed device's devnode.

Return Value:

    NTSTATUS code.

--*/
{

    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT deviceObject;
    ULONG marker;

    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);

    if (ARGUMENT_PRESENT(RelationsList)) {
        marker = 0;
        while (IopEnumerateRelations( RelationsList,
                                      &marker,
                                      &deviceObject,
                                      NULL,
                                      NULL,
                                      TRUE)) {

            deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;

            //
            // There are three different scenarios in which we want to unlink a
            // devnode from the tree.
            //
            // 1) A devnode is no longer enumerated and has been sent a
            //    remove IRP.
            //
            // 2) A devnode has been surprise removed, has no children, has
            //    no resources or they've been freed.  UnlinkAction will be
            //    UnlinkAllDeviceNodesPendingClose.
            //
            // 3) A devnode has failed and a surprise remove IRP has been sent.
            //    Then we want to remove children without resources but not the
            //    failed devnode itself.  UnlinkAction will be
            //    UnlinkOnlyChildDeviceNodesPendingClose.
            //
            switch(UnlinkAction) {

                case UnlinkRemovedDeviceNodes:

                    //
                    // Removes have been sent to every devnode in this relation
                    // list. Deconstruct the tree appropriately.
                    //
                    ASSERT(deviceNode->State != DeviceNodeDeletePendingCloses);
                    break;

                case UnlinkAllDeviceNodesPendingClose:

                    ASSERT((deviceNode->State == DeviceNodeDeletePendingCloses) ||
                           (deviceNode->State == DeviceNodeDeleted));
                    break;

                case UnlinkOnlyChildDeviceNodesPendingClose:

#if DBG
                    if (RemovedDeviceObject != deviceObject) {

                        ASSERT((deviceNode->State == DeviceNodeDeletePendingCloses) ||
                               (deviceNode->State == DeviceNodeDeleted));
                    } else {

                        ASSERT(deviceNode->State == DeviceNodeRemovePendingCloses);
                    }
#endif
                    break;

                default:
                    ASSERT(0);
                    break;
            }

            //
            // Deconstruct the tree appropriately.
            //
            if ((deviceNode->State == DeviceNodeDeletePendingCloses) ||
                (deviceNode->State == DeviceNodeDeleted)) {

                ASSERT(!(deviceNode->Flags & DNF_ENUMERATED));

                //
                // Remove the devnode from the tree.
                //
                IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                           "IopUnlinkDeviceRemovalRelations: Cleaning up registry values, instance = %wZ\n",
                           &deviceNode->InstancePath));

                PiLockPnpRegistry(TRUE);

                IopCleanupDeviceRegistryValues(&deviceNode->InstancePath);

                IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                           "IopUnlinkDeviceRemovalRelations: Removing DevNode tree, DevNode = 0x%p\n",
                           deviceNode));

                PpDevNodeRemoveFromTree(deviceNode);

                PiUnlockPnpRegistry();

                if (deviceNode->State == DeviceNodeDeleted) {

                    ASSERT(PipDoesDevNodeHaveProblem(deviceNode));
                    IopRemoveRelationFromList(RelationsList, deviceObject);

                    //
                    //     Ashes to ashes
                    //     Memory to freelist
                    //
                    ObDereferenceObject(deviceObject); // Added during Enum
                } else {

                    //
                    // There is still one more ref on the device object, one
                    // holding it to the relation list. Once the final removes
                    // are sent the relationlist will be freed and then the
                    // final ref will be dropped.
                    //
                    ObDereferenceObject(deviceObject); // Added during Enum
                }

            } else {

                ASSERT(deviceNode->Flags & DNF_ENUMERATED);
            }
        }
    }

    PpDevNodeUnlockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);
}

//
// The routines below are specific to kernel mode PnP configMgr.
//
NTSTATUS
IopUnloadAttachedDriver(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This function unloads the driver for the specified device object if it does not
    control any other device object.

Arguments:

    DeviceObject - Supplies a pointer to a device object

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    PWCHAR buffer;
    UNICODE_STRING unicodeName;
    PUNICODE_STRING serviceName = &DriverObject->DriverExtension->ServiceKeyName;

    PAGED_CODE();

    if (DriverObject->DriverSection != NULL) {
        if (DriverObject->DeviceObject == NULL) {
            buffer = (PWCHAR) ExAllocatePool(
                                 PagedPool,
                                 CmRegistryMachineSystemCurrentControlSetServices.Length +
                                     serviceName->Length + sizeof(WCHAR) +
                                     sizeof(L"\\"));
            if (!buffer) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            swprintf(buffer,
                     L"%s\\%s",
                     CmRegistryMachineSystemCurrentControlSetServices.Buffer,
                     serviceName->Buffer);
            RtlInitUnicodeString(&unicodeName, buffer);
            status = IopUnloadDriver(&unicodeName, TRUE);
            if (NT_SUCCESS(status)) {
                IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                           "****** Unloaded driver (%wZ)\n",
                           serviceName));

            } else {
                IopDbgPrint((IOP_LOADUNLOAD_WARNING_LEVEL,
                           "****** Error unloading driver (%wZ), status = 0x%08X\n",
                           serviceName,
                           status));

            }
            ExFreePool(unicodeName.Buffer);
        }
        else {
            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                       "****** Skipping unload of driver (%wZ), DriverObject->DeviceObject != NULL\n",
                       serviceName));
        }
    }
    else {
        //
        // This is a boot driver, can't be unloaded just return SUCCESS
        //
        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "****** Skipping unload of boot driver (%wZ)\n",
                   serviceName));
    }
    return STATUS_SUCCESS;
}

VOID
PipRequestDeviceRemoval(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN      TreeDeletion,
    IN ULONG        Problem
    )
/*++

Routine Description:

    This routine queues a work item to remove or delete a device.

Arguments:

    DeviceNode - Supplies a pointer to the device object to be cleaned up.

    TreeDeletion - If TRUE, the devnode is physically missing and should
                   eventually end up in the deleted state. If FALSE, the
                   stack just needs to be torn down.

    Problem - Problem code to assign to the removed stack.

Return Value:

    None.

--*/
{
    REMOVAL_WALK_CONTEXT removalWalkContext;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(DeviceNode != NULL);

    if (DeviceNode) {

        if (DeviceNode->InstancePath.Length == 0) {

            IopDbgPrint((IOP_ERROR_LEVEL, "Driver %wZ reported child %p missing right after enumerating it!\n", &DeviceNode->Parent->ServiceName, DeviceNode));
            ASSERT(DeviceNode->InstancePath.Length != 0);
        }

        PPDEVNODE_ASSERT_LOCK_HELD(PPL_TREEOP_ALLOW_READS);

        removalWalkContext.TreeDeletion = TreeDeletion;
        removalWalkContext.DescendantNode = FALSE;

        status = PipRequestDeviceRemovalWorker(
            DeviceNode,
            (PVOID) &removalWalkContext
            );

        ASSERT(NT_SUCCESS(status));

        //
        // Queue the event, we'll return immediately after it's queued.
        //
        PpSetTargetDeviceRemove(
            DeviceNode->PhysicalDeviceObject,
            TRUE,
            TRUE,
            FALSE,
            Problem,
            NULL,
            NULL,
            NULL,
            NULL
            );
    }
}

NTSTATUS
PipRequestDeviceRemovalWorker(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID        Context
    )
/*++

Routine Description:

    This function is a worker routine for PipRequestDeviceRemoval routine. It
    is used to mark an entire subtree for removal.

Arguments:

    DeviceNode - Supplies a pointer to the device node to mark.

    Context - Points to a boolean that indicates whether the removal is
              physical or stack specific.

Return Value:

    NTSTATUS value.

--*/
{
    PREMOVAL_WALK_CONTEXT removalWalkContext;
    PNP_DEVNODE_STATE     sentinelState;

    PAGED_CODE();

    removalWalkContext = (PREMOVAL_WALK_CONTEXT) Context;

    switch(DeviceNode->State) {

        case DeviceNodeUninitialized:
            ASSERT(removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeInitialized:
            //
            // This can happen on a non-descendant node if it fails AddDevice.
            //
            break;

        case DeviceNodeDriversAdded:
            //
            // Happens when a parent stops enumerating a kid who had a
            // resource conflict. This can also happen if AddDevice fails when
            // a lower filter is attached but the service fails.
            //
            break;

        case DeviceNodeResourcesAssigned:
            //
            // Happens when a parent stops enumerating a kid who has been
            // assigned resources but hadn't yet been started.
            //
            ASSERT(removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeStartPending:
            //
            // Not implemented yet.
            //
            ASSERT(0);
            break;

        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
            //
            // These are operational states for taking Added to Started. No
            // descendant should be in this state as the engine currently
            // finishes these before progressing to the next node.
            //
            // Note that DeviceNodeStartPostWork can occur on a legacy added
            // root enumerated devnode. Since the root itself cannot disappear
            // or be removed the below asserts still hold true.
            //
            // ISSUE - 2000/08/12 - ADRIAO: IoReportResourceUsage sync problems
            //
            ASSERT(!removalWalkContext->DescendantNode);
            ASSERT(!removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeStarted:
            break;

        case DeviceNodeQueryStopped:
            //
            // Internal rebalance engine state, should never be seen.
            //
            ASSERT(0);
            break;

        case DeviceNodeStopped:
            ASSERT(removalWalkContext->DescendantNode);
            ASSERT(removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeRestartCompletion:
            //
            // This is an operational state for taking Stopped to Started. No
            // descendant should be in this state as the engine currently
            // finishes these before progressing to the next node.
            //
            ASSERT(!removalWalkContext->DescendantNode);
            ASSERT(!removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeEnumeratePending:
            //
            // Not implemented yet.
            //
            ASSERT(0);
            break;

        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeAwaitingQueuedDeletion:

            //
            // ISSUE - 2000/08/30 - ADRIAO: Excessive reenum race
            //     Here we hit a case where we didn't flush the removes in the
            // queue due to excessive enumeration. Flushing the last removes
            // is problematic as they themselves will queue up enums! Until a
            // better solution is found, we convert the state here. Bleargh!!!
            //     Note that this can also happen because PipDeviceActionWorker
            // doesn't flush enums in the case of failed
            // PipProcessQueryDeviceState or PipCallDriverAddDevice!
            //
            ASSERT(removalWalkContext->TreeDeletion);
            //ASSERT(0);
            PipRestoreDevNodeState(DeviceNode);
            PipSetDevNodeState(DeviceNode, DeviceNodeAwaitingQueuedDeletion, NULL);
            return STATUS_SUCCESS;

        case DeviceNodeRemovePendingCloses:
        case DeviceNodeRemoved:
            ASSERT(removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeEnumerateCompletion:
        case DeviceNodeQueryRemoved:
        case DeviceNodeDeletePendingCloses:
        case DeviceNodeDeleted:
        case DeviceNodeUnspecified:
        default:
            ASSERT(0);
            break;
    }

    //
    // Give the devnode a sentinel state that will keep the start/enum engine
    // at bay until the removal engine processes the tree.
    //
    sentinelState = (removalWalkContext->TreeDeletion) ?
        DeviceNodeAwaitingQueuedDeletion :
        DeviceNodeAwaitingQueuedRemoval;

    PipSetDevNodeState(DeviceNode, sentinelState, NULL);

    //
    // All subsequent nodes are descendants, and all subsequent removals are
    // deletions.
    //
    removalWalkContext->DescendantNode = TRUE;
    removalWalkContext->TreeDeletion = TRUE;

    return PipForAllChildDeviceNodes(
        DeviceNode,
        PipRequestDeviceRemovalWorker,
        (PVOID) removalWalkContext
        );
}


BOOLEAN
PipIsBeingRemovedSafely(
    IN  PDEVICE_NODE    DeviceNode
    )
/*++

Routine Description:

    This function looks at a device with a physical remove queued against it
    and indicates whether it is safe to remove.

Arguments:

    DeviceNode - Supplies a pointer to the device node to examine. The devnode
                 should be in the DeviceNodeAwaitingQueuedDeletion state.

Return Value:

    BOOLEAN - TRUE iff the devnode is safe to be removed.

--*/
{
    PAGED_CODE();

    ASSERT(DeviceNode->State == DeviceNodeAwaitingQueuedDeletion);

    if (IopDeviceNodeFlagsToCapabilities(DeviceNode)->SurpriseRemovalOK) {

        return TRUE;
    }

    return ((DeviceNode->PreviousState != DeviceNodeStarted) &&
            (DeviceNode->PreviousState != DeviceNodeStopped) &&
            (DeviceNode->PreviousState != DeviceNodeRestartCompletion));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpdd.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

All rights reserved

Module Name:

    pnpdd.c

Abstract:

    This module implements new Plug-And-Play driver entries and IRPs.

Author:

    Shie-Lin Tzong (shielint) June-16-1995

Environment:

    Kernel mode only.

Revision History:

*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ddpP')
#endif

//
// Internal definitions and references
//

typedef struct _ROOT_ENUMERATOR_CONTEXT {
    NTSTATUS Status;
    PUNICODE_STRING KeyName;
    ULONG MaxDeviceCount;
    ULONG DeviceCount;
    PDEVICE_OBJECT *DeviceList;
} ROOT_ENUMERATOR_CONTEXT, *PROOT_ENUMERATOR_CONTEXT;

NTSTATUS
IopGetServiceType(
    IN PUNICODE_STRING KeyName,
    IN PULONG ServiceType
    );

BOOLEAN
IopInitializeDeviceInstanceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    );

BOOLEAN
IopInitializeDeviceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    );

BOOLEAN
IopIsFirmwareDisabled (
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopPnPCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

NTSTATUS
IopTranslatorHandlerCm (
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT DeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );
NTSTATUS
IopTranslatorHandlerIo (
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopGetRootDevices)
#pragma alloc_text(PAGE, IopGetServiceType)
#pragma alloc_text(PAGE, IopInitializeDeviceKey)
#pragma alloc_text(PAGE, IopInitializeDeviceInstanceKey)
#pragma alloc_text(PAGE, IopIsFirmwareDisabled)
#pragma alloc_text(PAGE, PipIsFirmwareMapperDevicePresent)
#pragma alloc_text(PAGE, IopPnPAddDevice)
#pragma alloc_text(PAGE, IopPnPDispatch)
#pragma alloc_text(PAGE, IopTranslatorHandlerCm)
#pragma alloc_text(PAGE, IopTranslatorHandlerIo)
#pragma alloc_text(PAGE, IopSystemControlDispatch)
#endif // ALLOC_PRAGMA

NTSTATUS
IopPnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine handles AddDevice for an madeup PDO device.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{
    UNREFERENCED_PARAMETER( DriverObject );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

#if DBG

    //
    // We should never get an AddDevice request.
    //

    DbgBreakPoint();

#endif

    return STATUS_SUCCESS;
}
//  PNPRES test

NTSTATUS
IopArbiterHandlerxx (
    IN PVOID Context,
    IN ARBITER_ACTION Action,
    IN OUT PARBITER_PARAMETERS Parameters
    )
{
    PLIST_ENTRY listHead, listEntry;
    PIO_RESOURCE_DESCRIPTOR ioDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    PARBITER_LIST_ENTRY arbiterListEntry;

    UNREFERENCED_PARAMETER( Context );

    if (Action == ArbiterActionQueryArbitrate) {
        return STATUS_SUCCESS;
    }
    if (Parameters == NULL) {
        return STATUS_SUCCESS;
    }
    listHead = Parameters->Parameters.TestAllocation.ArbitrationList;
    if (IsListEmpty(listHead)) {
        return STATUS_SUCCESS;
    }
    listEntry = listHead->Flink;
    while (listEntry != listHead) {
      arbiterListEntry = (PARBITER_LIST_ENTRY)listEntry;
      cmDesc = arbiterListEntry->Assignment;
      ioDesc = arbiterListEntry->Alternatives;
      if (cmDesc == NULL || ioDesc == NULL) {
          return STATUS_SUCCESS;
      }
      cmDesc->Type = ioDesc->Type;
      cmDesc->ShareDisposition = ioDesc->ShareDisposition;
      cmDesc->Flags = ioDesc->Flags;
      if (ioDesc->Type == CmResourceTypePort) {
          cmDesc->u.Port.Start = ioDesc->u.Port.MinimumAddress;
          cmDesc->u.Port.Length = ioDesc->u.Port.Length;
      } else if (ioDesc->Type == CmResourceTypeInterrupt) {
          cmDesc->u.Interrupt.Level = ioDesc->u.Interrupt.MinimumVector;
          cmDesc->u.Interrupt.Vector = ioDesc->u.Interrupt.MinimumVector;
          cmDesc->u.Interrupt.Affinity = (ULONG) -1;
      } else if (ioDesc->Type == CmResourceTypeMemory) {
          cmDesc->u.Memory.Start = ioDesc->u.Memory.MinimumAddress;
          cmDesc->u.Memory.Length = ioDesc->u.Memory.Length;
      } else if (ioDesc->Type == CmResourceTypeDma) {
          cmDesc->u.Dma.Channel = ioDesc->u.Dma.MinimumChannel;
          cmDesc->u.Dma.Port = 0;
          cmDesc->u.Dma.Reserved1 = 0;
      }
      listEntry = listEntry->Flink;
    }
    return STATUS_SUCCESS;
}
NTSTATUS
IopTranslatorHandlerCm (
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT DeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
{
    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( Direction );
    UNREFERENCED_PARAMETER( AlternativesCount );
    UNREFERENCED_PARAMETER( Alternatives );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    *Target = *Source;
#if 0
    if (Direction == TranslateChildToParent) {
        if (Target->Type == CmResourceTypePort) {
            Target->u.Port.Start.LowPart += 0x10000;
        } else if (Target->Type == CmResourceTypeMemory) {
            Target->u.Memory.Start.LowPart += 0x100000;
        }
    } else {
        if (Target->Type == CmResourceTypePort) {
            Target->u.Port.Start.LowPart -= 0x10000;
        } else if (Target->Type == CmResourceTypeMemory) {
            Target->u.Memory.Start.LowPart -= 0x100000;
        }
    }
#endif
    return STATUS_SUCCESS;
}
NTSTATUS
IopTranslatorHandlerIo (
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
{
    PIO_RESOURCE_DESCRIPTOR newDesc;

    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    newDesc = (PIO_RESOURCE_DESCRIPTOR) ExAllocatePool(PagedPool, sizeof(IO_RESOURCE_DESCRIPTOR));
    if (newDesc == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    *TargetCount = 1;
    *newDesc = *Source;
#if 0
    if (newDesc->Type == CmResourceTypePort) {
        newDesc->u.Port.MinimumAddress.LowPart += 0x10000;
        newDesc->u.Port.MaximumAddress.LowPart += 0x10000;
    } else if (newDesc->Type == CmResourceTypeMemory) {
        newDesc->u.Memory.MinimumAddress.LowPart += 0x100000;
        newDesc->u.Memory.MaximumAddress.LowPart += 0x100000;
    }
#endif
    *Target = newDesc;
    return STATUS_SUCCESS;
}

NTSTATUS
IopPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION      IrpSp;
    PPOWER_SEQUENCE         PowerSequence;
    NTSTATUS                Status;


    UNREFERENCED_PARAMETER( DeviceObject );

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    Status = Irp->IoStatus.Status;

    switch (IrpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
            Status = STATUS_NOT_SUPPORTED;
            break;

        case IRP_MN_POWER_SEQUENCE:
            PowerSequence = IrpSp->Parameters.PowerSequence.PowerSequence;
            PowerSequence->SequenceD1 = PoPowerSequence;
            PowerSequence->SequenceD2 = PoPowerSequence;
            PowerSequence->SequenceD3 = PoPowerSequence;
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_POWER:
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_SET_POWER:
            switch (IrpSp->Parameters.Power.Type) {
                case SystemPowerState:
                    Status = STATUS_SUCCESS;
                    break;

                case DevicePowerState:
                    //
                    // To be here the FDO must have passed the IRP on.
                    // We do not know how to turn the device off, but the
                    // FDO is prepaired for it work
                    //

                    Status = STATUS_SUCCESS;
                    break;

                default:
                    // Unkown power type
                    Status = STATUS_NOT_SUPPORTED;
                    break;
            }
            break;

        default:
            // Unkown power minor code
            Status = STATUS_NOT_SUPPORTED;
            break;
    }


    //
    // For lagecy devices that do not have drivers loaded, complete
    // power irps with success.
    //

    PoStartNextPowerIrp(Irp);
    if (Status != STATUS_NOT_SUPPORTED) {
       Irp->IoStatus.Status = Status;
    } else {
       Status = Irp->IoStatus.Status;
    }
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;
}

NTSTATUS
IopPnPDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for madeup PDO device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIOPNP_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PVOID information = NULL;
    ULONG length, uiNumber;
    PWCHAR id, wp;
    PDEVICE_NODE deviceNode;
    PARBITER_INTERFACE arbiterInterface;  // PNPRES test
    PTRANSLATOR_INTERFACE translatorInterface;  // PNPRES test

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    switch (irpSp->MinorFunction){

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:
    case IRP_MN_START_DEVICE:

        //
        // If we get a start device request for a PDO, we simply
        // return success.
        //

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        //
        // As we fail all STOP's, this cancel is always successful, and we have
        // no work to do.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_STOP_DEVICE:

        //
        // We can not success the query stop.  We don't handle it.  because
        // we don't know how to stop a root enumerated device.
        //
        status = STATUS_UNSUCCESSFUL ;
        break;

    case IRP_MN_QUERY_RESOURCES:

        status = IopGetDeviceResourcesFromRegistry(
                         DeviceObject,
                         QUERY_RESOURCE_LIST,
                         REGISTRY_BOOT_CONFIG,
                         &information,
                         &length);
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = STATUS_SUCCESS;
            information = NULL;
        }
        break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

        status = IopGetDeviceResourcesFromRegistry(
                         DeviceObject,
                         QUERY_RESOURCE_REQUIREMENTS,
                         REGISTRY_BASIC_CONFIGVECTOR,
                         &information,
                         &length);
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = STATUS_SUCCESS;
            information = NULL;
        }
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:

        //
        // For root enumerated devices we let the device objects stay.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (DeviceObject == IopRootDeviceNode->PhysicalDeviceObject &&
            irpSp->Parameters.QueryDeviceRelations.Type == BusRelations) {
            status = IopGetRootDevices((PDEVICE_RELATIONS *)&information);
        } else {
            if (irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation) {
                PDEVICE_RELATIONS deviceRelations;

                deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
                if (deviceRelations == NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    deviceRelations->Count = 1;
                    deviceRelations->Objects[0] = DeviceObject;
                    ObReferenceObject(DeviceObject);
                    information = (PVOID)deviceRelations;
                    status = STATUS_SUCCESS;
                }
            } else {
                information = (PVOID)Irp->IoStatus.Information;
                status = Irp->IoStatus.Status;
            }
        }
        break;

    case IRP_MN_QUERY_INTERFACE:
        status = Irp->IoStatus.Status;
        deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
        if (deviceNode == IopRootDeviceNode) {
            if ( IopCompareGuid((PVOID)irpSp->Parameters.QueryInterface.InterfaceType, (PVOID)&GUID_ARBITER_INTERFACE_STANDARD)) {
                status = STATUS_SUCCESS;
                arbiterInterface = (PARBITER_INTERFACE) irpSp->Parameters.QueryInterface.Interface;
                arbiterInterface->ArbiterHandler = ArbArbiterHandler;
                switch ((UCHAR)((ULONG_PTR)irpSp->Parameters.QueryInterface.InterfaceSpecificData)) {
                case CmResourceTypePort:
                    arbiterInterface->Context = (PVOID) &IopRootPortArbiter;
                    break;
                case CmResourceTypeMemory:
                    arbiterInterface->Context = (PVOID) &IopRootMemArbiter;
                    break;
                case CmResourceTypeInterrupt:
                    arbiterInterface->Context = (PVOID) &IopRootIrqArbiter;
                    break;
                case CmResourceTypeDma:
                    arbiterInterface->Context = (PVOID) &IopRootDmaArbiter;
                    break;
                case CmResourceTypeBusNumber:
                    arbiterInterface->Context = (PVOID) &IopRootBusNumberArbiter;
                    break;
                default:
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
            } else if ( IopCompareGuid((PVOID)irpSp->Parameters.QueryInterface.InterfaceType, (PVOID)&GUID_TRANSLATOR_INTERFACE_STANDARD)) {
                translatorInterface = (PTRANSLATOR_INTERFACE) irpSp->Parameters.QueryInterface.Interface;
                translatorInterface->TranslateResources = IopTranslatorHandlerCm;
                translatorInterface->TranslateResourceRequirements = IopTranslatorHandlerIo;
                status = STATUS_SUCCESS;
            }
        }
        break;

    case IRP_MN_QUERY_CAPABILITIES:

        {
            ULONG i;
            PDEVICE_POWER_STATE state;
            PDEVICE_CAPABILITIES deviceCapabilities;

            deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

            deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
            deviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
            deviceCapabilities->Version = 1;

            deviceCapabilities->DeviceState[PowerSystemUnspecified]=PowerDeviceUnspecified;
            deviceCapabilities->DeviceState[PowerSystemWorking]=PowerDeviceD0;

            state = &deviceCapabilities->DeviceState[PowerSystemSleeping1];

            for (i = PowerSystemSleeping1; i < PowerSystemMaximum; i++) {

                //
                // Only supported state, currently, is off.
                //

                *state++ = PowerDeviceD3;
            }

            if(IopIsFirmwareDisabled(deviceNode)) {
                //
                // this device has been disabled by BIOS
                //
                deviceCapabilities->HardwareDisabled = TRUE;
            }
            if (deviceCapabilities->UINumber == (ULONG)-1) {
                //
                // Get the UI number from the registry.
                //
                length = sizeof(uiNumber);
                status = PiGetDeviceRegistryProperty(
                    DeviceObject,
                    REG_DWORD,
                    REGSTR_VALUE_UI_NUMBER,
                    NULL,
                    &uiNumber,
                    &length);
                if (NT_SUCCESS(status)) {

                    deviceCapabilities->UINumber = uiNumber;
                }
            }

            status = STATUS_SUCCESS;
        }
        break;

    case IRP_MN_QUERY_ID:
        if (DeviceObject != IopRootDeviceNode->PhysicalDeviceObject &&
            (!NT_SUCCESS(Irp->IoStatus.Status) || !Irp->IoStatus.Information)) {

            deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
            switch (irpSp->Parameters.QueryId.IdType) {

            case BusQueryInstanceID:
            case BusQueryDeviceID:

                id = (PWCHAR)ExAllocatePool(PagedPool, deviceNode->InstancePath.Length);
                if (id) {
                    ULONG separatorCount = 0;

                    RtlZeroMemory(id, deviceNode->InstancePath.Length);
                    information = id;
                    status = STATUS_SUCCESS;
                    wp = deviceNode->InstancePath.Buffer;
                    if (irpSp->Parameters.QueryId.IdType == BusQueryDeviceID) {
                        while(*wp) {
                            if (*wp == OBJ_NAME_PATH_SEPARATOR) {
                                separatorCount++;
                                if (separatorCount == 2) {
                                    break;
                                }
                            }
                            *id = *wp;
                            id++;
                            wp++;
                        }
                    } else {
                        while(*wp) {
                            if (*wp == OBJ_NAME_PATH_SEPARATOR) {
                                separatorCount++;
                                if (separatorCount == 2) {
                                    wp++;
                                    break;
                                }
                            }
                            wp++;
                        }
                        while (*wp) {
                            *id = *wp;
                            id++;
                            wp++;
                        }
                    }
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;

            case BusQueryCompatibleIDs:

                if((Irp->IoStatus.Status != STATUS_NOT_SUPPORTED) ||
                   (deviceExtension == NULL))  {

                    //
                    // Upper driver has given some sort of reply or this device
                    // object wasn't allocated to handle these requests.
                    //

                    status = Irp->IoStatus.Status;
                    break;
                }

                if(deviceExtension->CompatibleIdListSize != 0) {

                    id = ExAllocatePool(PagedPool,
                                        deviceExtension->CompatibleIdListSize);

                    if(id == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    RtlCopyMemory(id,
                                  deviceExtension->CompatibleIdList,
                                  deviceExtension->CompatibleIdListSize);

                    information = id;
                    status = STATUS_SUCCESS;
                    break;
                }

            default:

                information = (PVOID)Irp->IoStatus.Information;
                status = Irp->IoStatus.Status;
            }
        } else {
            information = (PVOID)Irp->IoStatus.Information;
            status = Irp->IoStatus.Status;
        }

        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        if (    irpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation &&
                !Irp->IoStatus.Information) {
            //
            // Read and return the location in the registry.
            //
            length = 0;
            PiGetDeviceRegistryProperty(
                DeviceObject,
                REG_SZ,
                REGSTR_VALUE_LOCATION_INFORMATION,
                NULL,
                NULL,
                &length);
            if (length) {

                information = ExAllocatePool(PagedPool, length);
                if (information) {

                    status = PiGetDeviceRegistryProperty(
                        DeviceObject,
                        REG_SZ,
                        REGSTR_VALUE_LOCATION_INFORMATION,
                        NULL,
                        information,
                        &length);
                    if (!NT_SUCCESS(status)) {

                        ExFreePool(information);
                        information = NULL;
                    }
                } else {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {

                status = STATUS_UNSUCCESSFUL;
            }
        } else {

            information = (PVOID)Irp->IoStatus.Information;
            status = Irp->IoStatus.Status;
        }
        break;

    default:

        information = (PVOID)Irp->IoStatus.Information;
        status = Irp->IoStatus.Status;
        break;
    }

    //
    // Complete the Irp and return.
    //

    IopPnPCompleteRequest(Irp, status, (ULONG_PTR)information);
    return status;
}

VOID
IopPnPCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )

/*++

Routine Description:

    This routine completes PnP irps for our pseudo driver.

Arguments:

    Irp - Supplies a pointer to the irp to be completed.

    Status - completion status.

    Information - completion information to be passed back.

Return Value:

    None.

--*/

{

    //
    // Complete the IRP.  First update the status...
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = Information;

    //
    // ... and complete it.
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

BOOLEAN
IopIsFirmwareDisabled (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine determines if the devicenode has been disabled by firmware.

Arguments:

    DeviceNode - Supplies a pointer to the device node structure of the device.

Return Value:

    TRUE if disabled, otherwise FALSE

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject = DeviceNode->PhysicalDeviceObject;
    HANDLE handle, handlex;
    UNICODE_STRING unicodeName;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    ULONG buflen;
    BOOLEAN FirmwareDisabled = FALSE;

    PiLockPnpRegistry(FALSE);

    status = IopDeviceObjectToDeviceInstance(
                                    deviceObject,
                                    &handlex,
                                    KEY_ALL_ACCESS);
    if (NT_SUCCESS(status)) {

        //
        // Open the LogConfig key of the device instance.
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
        status = IopCreateRegistryKeyEx( &handle,
                                         handlex,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_VOLATILE,
                                         NULL
                                         );
        ZwClose(handlex);
        if (NT_SUCCESS(status)) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_FIRMWAREDISABLED);
            value = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
            buflen = sizeof(buffer);
            status = ZwQueryValueKey(handle,
                                     &unicodeName,
                                     KeyValuePartialInformation,
                                     value,
                                     sizeof(buffer),
                                     &buflen
                                     );

            ZwClose(handle);

            //
            // We don't need to check the buffer was big enough because it starts
            // off that way and doesn't get any smaller!
            //

            if (NT_SUCCESS(status)
                && value->Type == REG_DWORD
                && value->DataLength == sizeof(ULONG)
                && (*(PULONG)(value->Data))!=0) {

                //
                // firmware disabled
                //
                FirmwareDisabled = TRUE;
            }
        }
    }
    PiUnlockPnpRegistry();
    return FirmwareDisabled;
}


NTSTATUS
IopGetRootDevices (
    PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:

    This routine scans through System\Enum\Root subtree to build a device node for
    each root device.

Arguments:

    DeviceRelations - supplies a variable to receive the returned DEVICE_RELATIONS structure.

Return Value:

    A NTSTATUS code.

--*/

{
    NTSTATUS status;
    HANDLE baseHandle;
    UNICODE_STRING workName, tmpName;
    PVOID buffer;
    ROOT_ENUMERATOR_CONTEXT context;
    ULONG i;
    PDEVICE_RELATIONS deviceRelations;

    PAGED_CODE();

    *DeviceRelations = NULL;
    buffer = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate a buffer to store the PDOs enumerated.
    // Note, the the buffer turns out to be not big enough, it will be reallocated dynamically.
    //

    context.DeviceList = (PDEVICE_OBJECT *) ExAllocatePool(PagedPool, PNP_SCRATCH_BUFFER_SIZE * 2);
    if (context.DeviceList) {
        context.MaxDeviceCount = (PNP_SCRATCH_BUFFER_SIZE * 2) / sizeof(PDEVICE_OBJECT);
        context.DeviceCount = 0;
    } else {
        ExFreePool(buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    PiLockPnpRegistry(TRUE);

    //
    // Open System\CurrentControlSet\Enum\Root key and call worker routine to recursively
    // scan through the subkeys.
    //

    status = IopCreateRegistryKeyEx( &baseHandle,
                                     NULL,
                                     &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                                     KEY_READ,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (NT_SUCCESS(status)) {

        workName.Buffer = (PWSTR)buffer;
        RtlFillMemory(buffer, PNP_LARGE_SCRATCH_BUFFER_SIZE, 0);
        workName.MaximumLength = PNP_LARGE_SCRATCH_BUFFER_SIZE;
        workName.Length = 0;

        //
        // only look at ROOT key
        //

        PiWstrToUnicodeString(&tmpName, REGSTR_KEY_ROOTENUM);
        RtlAppendStringToString((PSTRING)&workName, (PSTRING)&tmpName);

        //
        // Enumerate all subkeys under the System\CCS\Enum\Root.
        //

        context.Status = STATUS_SUCCESS;
        context.KeyName = &workName;

        status = PipApplyFunctionToSubKeys(baseHandle,
                                           NULL,
                                           KEY_ALL_ACCESS,
                                           FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                                           IopInitializeDeviceKey,
                                           &context
                                           );
        ZwClose(baseHandle);

        //
        // Build returned information from ROOT_ENUMERATOR_CONTEXT.
        //


        status = context.Status;
        if (NT_SUCCESS(status) && context.DeviceCount != 0) {
            deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
                PagedPool,
                sizeof (DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT) * context.DeviceCount
                );
            if (deviceRelations == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                deviceRelations->Count = context.DeviceCount;
                RtlCopyMemory(deviceRelations->Objects,
                              context.DeviceList,
                              sizeof (PDEVICE_OBJECT) * context.DeviceCount);
                *DeviceRelations = deviceRelations;
            }
        }
        if (!NT_SUCCESS(status)) {

            //
            // If somehow the enumeration failed, we need to derefernece all the
            // device objects.
            //

            for (i = 0; i < context.DeviceCount; i++) {
                ObDereferenceObject(context.DeviceList[i]);
            }
        }
    }
    PiUnlockPnpRegistry();
    ExFreePool(buffer);
    ExFreePool(context.DeviceList);
    return status;
}

BOOLEAN
IopInitializeDeviceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToSubKeys.
    It is called for each subkey under HKLM\System\CCS\Enum\BusKey.

Arguments:

    KeyHandle - Supplies a handle to this key.

    KeyName - Supplies the name of this key.

    Context - points to the ROOT_ENUMERATOR_CONTEXT structure.

Returns:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/
{
    USHORT length;
    PWSTR p;
    PUNICODE_STRING unicodeName = ((PROOT_ENUMERATOR_CONTEXT)Context)->KeyName;

    length = unicodeName->Length;

    p = unicodeName->Buffer;
    if ( unicodeName->Length / sizeof(WCHAR) != 0) {
        p += unicodeName->Length / sizeof(WCHAR);
        *p = OBJ_NAME_PATH_SEPARATOR;
        unicodeName->Length += sizeof (WCHAR);
    }

    RtlAppendStringToString((PSTRING)unicodeName, (PSTRING)KeyName);

    //
    // Enumerate all subkeys under the current device key.
    //

    PipApplyFunctionToSubKeys(KeyHandle,
                              NULL,
                              KEY_ALL_ACCESS,
                              FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                              IopInitializeDeviceInstanceKey,
                              Context
                              );
    unicodeName->Length = length;

    return (BOOLEAN)NT_SUCCESS(((PROOT_ENUMERATOR_CONTEXT)Context)->Status);
}

BOOLEAN
IopInitializeDeviceInstanceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToSubKeys.
    It is called for each subkey under HKLM\System\Enum\Root\DeviceKey.

Arguments:

    KeyHandle - Supplies a handle to this key.

    KeyName - Supplies the name of this key.

    Context - points to the ROOT_ENUMERATOR_CONTEXT structure.

Returns:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/
{
    UNICODE_STRING unicodeName, serviceName;
    PKEY_VALUE_FULL_INFORMATION serviceKeyValueInfo;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    NTSTATUS status;
    BOOLEAN isDuplicate = FALSE;
    BOOLEAN configuredBySetup;
    ULONG deviceFlags, tmpValue1;
    ULONG legacy;
    USHORT savedLength;
    PUNICODE_STRING pUnicode;
    HANDLE handle;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode = NULL;
    PROOT_ENUMERATOR_CONTEXT enumContext = (PROOT_ENUMERATOR_CONTEXT)Context;

    //
    // First off, check to see if this is a phantom device instance (i.e.,
    // registry key only).  If so, we want to totally ignore this key and
    // move on to the next one.
    //
    status = IopGetRegistryValue(KeyHandle,
                                 REGSTR_VAL_PHANTOM,
                                 &keyValueInformation);

    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {
            tmpValue1 = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        } else {
            tmpValue1 = 0;
        }

        ExFreePool(keyValueInformation);

        if (tmpValue1) {
            return TRUE;
        }
    }

    //
    // Since it is highly likely we are going to report another PDO make sure
    // there will be room in the buffer.
    //

    if (enumContext->DeviceCount == enumContext->MaxDeviceCount) {

        PDEVICE_OBJECT *tmpDeviceObjectList;
        ULONG tmpDeviceObjectListSize;

        //
        // We need to grow our PDO list buffer.
        //

        tmpDeviceObjectListSize = (enumContext->MaxDeviceCount * sizeof(PDEVICE_OBJECT))
                                        + (PNP_SCRATCH_BUFFER_SIZE * 2);

        tmpDeviceObjectList = ExAllocatePool(PagedPool, tmpDeviceObjectListSize);

        if (tmpDeviceObjectList) {

            RtlCopyMemory( tmpDeviceObjectList,
                           enumContext->DeviceList,
                           enumContext->DeviceCount * sizeof(PDEVICE_OBJECT)
                           );
            ExFreePool(enumContext->DeviceList);
            enumContext->DeviceList = tmpDeviceObjectList;
            enumContext->MaxDeviceCount = tmpDeviceObjectListSize / sizeof(PDEVICE_OBJECT);

        } else {

            //
            // We are out of memory.  There is no point going any further
            // since we don't have any place to report the PDOs anyways.
            //

            enumContext->Status = STATUS_INSUFFICIENT_RESOURCES;

            return FALSE;
        }
    }

    //
    // Combine Context->KeyName, i.e. the device name and KeyName (device instance name)
    // to form device instance path.
    //

    pUnicode = ((PROOT_ENUMERATOR_CONTEXT)Context)->KeyName;
    savedLength = pUnicode->Length;                  // Save WorkName
    if (pUnicode->Buffer[pUnicode->Length / sizeof(WCHAR) - 1] != OBJ_NAME_PATH_SEPARATOR) {
        pUnicode->Buffer[pUnicode->Length / sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
        pUnicode->Length += 2;
    }

    RtlAppendStringToString((PSTRING)pUnicode, (PSTRING)KeyName);

    //
    // Check if the PDO for the device instance key exists already.  If no,
    // see if we need to create it.
    //

    deviceObject = IopDeviceObjectFromDeviceInstance(pUnicode);

    if (deviceObject != NULL) {

        enumContext->DeviceList[enumContext->DeviceCount] = deviceObject;
        enumContext->DeviceCount++;
        pUnicode->Length = savedLength;         // Restore WorkName
        return TRUE;
    }

    //
    // We don't have device object for it.
    // First check if this key was created by firmware mapper.  If yes, make sure
    // the device is still present.
    //

    if (!PipIsFirmwareMapperDevicePresent(KeyHandle)) {
        pUnicode->Length = savedLength;         // Restore WorkName
        return TRUE;
    }

    //
    // Get the "DuplicateOf" value entry to determine if the device instance
    // should be registered.  If the device instance is duplicate, We don't
    // add it to its service key's enum branch.
    //

    status = IopGetRegistryValue( KeyHandle,
                                  REGSTR_VALUE_DUPLICATEOF,
                                  &keyValueInformation
                                  );
    if (NT_SUCCESS(status)) {
        if (keyValueInformation->Type == REG_SZ &&
            keyValueInformation->DataLength > 0) {
            isDuplicate = TRUE;
        }

        ExFreePool(keyValueInformation);
    }

    //
    // Get the "Service=" value entry from KeyHandle
    //

    serviceKeyValueInfo = NULL;

    PiWstrToUnicodeString(&serviceName, NULL);

    status = IopGetRegistryValue ( KeyHandle,
                                   REGSTR_VALUE_SERVICE,
                                   &serviceKeyValueInfo
                                   );
    if (NT_SUCCESS(status)) {

        //
        // Append the new instance to its corresponding
        // Service\Name\Enum.
        //

        if (serviceKeyValueInfo->Type == REG_SZ &&
            serviceKeyValueInfo->DataLength != 0) {

            //
            // Set up ServiceKeyName unicode string
            //

            IopRegistryDataToUnicodeString(
                                &serviceName,
                                (PWSTR)KEY_VALUE_DATA(serviceKeyValueInfo),
                                serviceKeyValueInfo->DataLength
                                );
        }

        //
        // Do not Free serviceKeyValueInfo.  It contains Service Name.
        //

    }

    //
    // Register this device instance by constructing new value entry for
    // ServiceKeyName\Enum key.i.e., <Number> = <PathToSystemEnumBranch>
    // For the stuff under Root, we need to expose devnodes for everything
    // except those devices whose CsConfigFlags are set to CSCONFIGFLAG_DO_NOT_CREATE.
    //

    status = IopGetDeviceInstanceCsConfigFlags( pUnicode, &deviceFlags );

    if (NT_SUCCESS(status) && (deviceFlags & CSCONFIGFLAG_DO_NOT_CREATE)) {
        ExFreePool(serviceKeyValueInfo);
        pUnicode->Length = savedLength;         // Restore WorkName
        return TRUE;
    }

    //
    // Make sure this device instance is really a "device" by checking
    // the "Legacy" value name.
    //

    legacy = 0;
    status = IopGetRegistryValue( KeyHandle,
                                  REGSTR_VALUE_LEGACY,
                                  &keyValueInformation
                                  );
    if (NT_SUCCESS(status)) {

        //
        // If "Legacy=" exists ...
        //

        if (keyValueInformation->Type == REG_DWORD) {
            if (keyValueInformation->DataLength >= sizeof(ULONG)) {
                legacy = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
        }
        ExFreePool(keyValueInformation);
    }

    if (legacy) {
        BOOLEAN doCreate = FALSE;

        //
        // Check if the the service for the device instance is a kernel mode
        // driver (even though it is a legacy device instance.) If yes, we will
        // create a PDO for it.
        //

        if (serviceName.Length) {
            status = IopGetServiceType(&serviceName, &tmpValue1);
            if (NT_SUCCESS(status) && tmpValue1 == SERVICE_KERNEL_DRIVER) {
                doCreate = TRUE;
            }
        }

        if (!doCreate)  {

            //
            // We are not creating PDO for the device instance.  In this case we
            // need to register the device ourself for legacy compatibility.
            //
            // Note we will register this device to its driver even it is a
            // duplicate.  It will be deregistered when the real enumerated
            // device shows up.  We need to do this because the driver which
            // controls the device may be a boot driver.
            //

            PpDeviceRegistration( pUnicode, TRUE, NULL );

            //
            // We did not create a PDO.  Release the service and ordinal names.
            //

            if (serviceKeyValueInfo) {
                ExFreePool(serviceKeyValueInfo);
            }

            pUnicode->Length = savedLength;         // Restore WorkName

            return TRUE;
        }
    }

    if (serviceKeyValueInfo) {
        ExFreePool(serviceKeyValueInfo);
    }

    //
    // Create madeup PDO and device node to represent the root device.
    //

    //
    // Madeup a name for the device object.
    //

    //
    // Create madeup PDO and device node to represent the root device.
    //

    status = IoCreateDevice( IoPnpDriverObject,
                             sizeof(IOPNP_DEVICE_EXTENSION),
                             NULL,
                             FILE_DEVICE_CONTROLLER,
                             FILE_AUTOGENERATED_DEVICE_NAME,
                             FALSE,
                             &deviceObject );

    if (NT_SUCCESS(status)) {

        deviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;
        deviceObject->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;

        status = PipAllocateDeviceNode(deviceObject, &deviceNode);
        if (status != STATUS_SYSTEM_HIVE_TOO_LARGE && deviceNode) {

            //
            // Make a copy of the device instance path and save it in
            // device node.
            //

            if (PipConcatenateUnicodeStrings(   &deviceNode->InstancePath,
                                                pUnicode,
                                                NULL
                                                )) {
                PCM_RESOURCE_LIST cmResource;

                deviceNode->Flags = DNF_MADEUP | DNF_ENUMERATED;

                PipSetDevNodeState(deviceNode, DeviceNodeInitialized, NULL);

                PpDevNodeInsertIntoTree(IopRootDeviceNode, deviceNode);

                if (legacy) {

                    deviceNode->Flags |= DNF_LEGACY_DRIVER | DNF_NO_RESOURCE_REQUIRED;

                    PipSetDevNodeState( deviceNode, DeviceNodeStarted, NULL );

                } else {

                    //
                    // The device instance key exists.  We need to propagate the ConfigFlag
                    // to problem and StatusFlags
                    //

                    deviceFlags = 0;
                    status = IopGetRegistryValue(KeyHandle,
                                                    REGSTR_VALUE_CONFIG_FLAGS,
                                                    &keyValueInformation);
                    if (NT_SUCCESS(status)) {
                        if ((keyValueInformation->Type == REG_DWORD) &&
                            (keyValueInformation->DataLength >= sizeof(ULONG))) {
                            deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                        }
                        ExFreePool(keyValueInformation);
                        if (deviceFlags & CONFIGFLAG_REINSTALL) {
                            PipSetDevNodeProblem(deviceNode, CM_PROB_REINSTALL);
                        } else if (deviceFlags & CONFIGFLAG_PARTIAL_LOG_CONF) {
                            PipSetDevNodeProblem(deviceNode, CM_PROB_PARTIAL_LOG_CONF);
                        } else if (deviceFlags & CONFIGFLAG_FAILEDINSTALL) {
                            PipSetDevNodeProblem(deviceNode, CM_PROB_FAILED_INSTALL);
                        }

                    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND || status == STATUS_OBJECT_PATH_NOT_FOUND) {
                        PipSetDevNodeProblem(deviceNode, CM_PROB_NOT_CONFIGURED);
                    }
                }

                if (isDuplicate) {
                    deviceNode->Flags |= DNF_DUPLICATE;
                }

                //
                // If the key say don't assign any resource, honor it...
                //

                PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_NO_RESOURCE_AT_INIT);
                status = IopGetRegistryValue( KeyHandle,
                                              unicodeName.Buffer,
                                              &keyValueInformation
                                              );

                if (NT_SUCCESS(status)) {
                    if (keyValueInformation->Type == REG_DWORD) {
                        if (keyValueInformation->DataLength >= sizeof(ULONG)) {
                            tmpValue1 = *(PULONG)KEY_VALUE_DATA(keyValueInformation);

                            if (tmpValue1 != 0) {
                                deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED;
                            }
                        }
                    }
                    ExFreePool(keyValueInformation);
                }

                //
                // we need to set initial capabilities, like any other device
                // this will also handle hardware-disabled case
                //
                IopQueryAndSaveDeviceNodeCapabilities(deviceNode);

                if (IopDeviceNodeFlagsToCapabilities(deviceNode)->HardwareDisabled &&
                    !PipIsDevNodeProblem(deviceNode,CM_PROB_NOT_CONFIGURED)) {
                    //
                    // mark the node as hardware disabled, if no other problems
                    //

                    PipClearDevNodeProblem(deviceNode);
                    PipSetDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED);
                    //
                    // Issue a PNP REMOVE_DEVICE Irp so when we query resources
                    // we have those required after boot
                    //
                    //status = IopRemoveDevice (deviceNode->PhysicalDeviceObject, IRP_MN_REMOVE_DEVICE);
                    //ASSERT(NT_SUCCESS(status));
                }

                //
                // Install service for critical devices.
                // however don't do it if we found HardwareDisabled to be set
                //
                if (PipDoesDevNodeHaveProblem(deviceNode) &&
                    !IopDeviceNodeFlagsToCapabilities(deviceNode)->HardwareDisabled) {
                    PipProcessCriticalDevice(deviceNode);
                }

                //
                // Set DNF_DISABLED flag if the device instance is disabled.
                //

                ASSERT(!PipDoesDevNodeHaveProblem(deviceNode) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_NOT_CONFIGURED) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_REINSTALL) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_FAILED_INSTALL) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_PARTIAL_LOG_CONF));

                if (!PipIsDevNodeProblem(deviceNode, CM_PROB_DISABLED) &&
                    !PipIsDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED) &&
                    !IopIsDeviceInstanceEnabled(KeyHandle, &deviceNode->InstancePath, TRUE)) {

                    //
                    // Normally IopIsDeviceInstanceEnabled would set
                    // CM_PROB_DISABLED as a side effect (if necessary).  But it
                    // relies on the DeviceReference already being in the registry.
                    // We don't write it out till later so just set the problem
                    // now.

                    PipClearDevNodeProblem( deviceNode );
                    PipSetDevNodeProblem( deviceNode, CM_PROB_DISABLED );
                }

                status = IopNotifySetupDeviceArrival( deviceNode->PhysicalDeviceObject,
                                                      KeyHandle,
                                                      TRUE);

                configuredBySetup = (BOOLEAN)NT_SUCCESS(status);

                status = PpDeviceRegistration( &deviceNode->InstancePath,
                                               TRUE,
                                               &deviceNode->ServiceName
                                               );

                if (NT_SUCCESS(status) && configuredBySetup &&
                    PipIsDevNodeProblem(deviceNode, CM_PROB_NOT_CONFIGURED)) {

                    PipClearDevNodeProblem(deviceNode);
                }

                //
                // Add an entry into the table to set up a mapping between the DO
                // and the instance path.
                //

                status = IopMapDeviceObjectToDeviceInstance(deviceNode->PhysicalDeviceObject, &deviceNode->InstancePath);
                ASSERT(NT_SUCCESS(status));

                //
                // Add a reference for config magr
                //

                ObReferenceObject(deviceObject);

                //
                // Check if this device has BOOT config.  If yes, reserve them
                //

                cmResource = NULL;
                status = IopGetDeviceResourcesFromRegistry (
                                    deviceObject,
                                    QUERY_RESOURCE_LIST,
                                    REGISTRY_BOOT_CONFIG,
                                    &cmResource,
                                    &tmpValue1
                                    );

                if (NT_SUCCESS(status) && cmResource) {

                    //
                    // Still reserve boot config, even though the device is
                    // disabled.
                    //

                    status = (*IopAllocateBootResourcesRoutine)(
                                            ArbiterRequestPnpEnumerated,
                                            deviceNode->PhysicalDeviceObject,
                                            cmResource);
                    if (NT_SUCCESS(status)) {
                        deviceNode->Flags |= DNF_HAS_BOOT_CONFIG;
                    }
                    ExFreePool(cmResource);
                }

                status = STATUS_SUCCESS;

                //
                // Add a reference for query device relations
                //

                ObReferenceObject(deviceObject);
            } else {
                IoDeleteDevice(deviceObject);
                deviceObject = NULL;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {

            IoDeleteDevice(deviceObject);
            deviceObject = NULL;
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    pUnicode->Length = savedLength;                  // Restore WorkName

    //
    // If we enumerated a root device, add it to the device list
    //

    if (NT_SUCCESS(status)) {
        ASSERT(deviceObject != NULL);

        enumContext->DeviceList[enumContext->DeviceCount] = deviceObject;
        enumContext->DeviceCount++;

        return TRUE;
    } else {
        enumContext->Status = status;
        return FALSE;
    }
}

NTSTATUS
IopGetServiceType(
    IN PUNICODE_STRING KeyName,
    IN PULONG ServiceType
    )

/*++

Routine Description:

    This routine returns the controlling service's service type of the specified
    Device instance.

Arguments:

    KeyName - supplies a unicode string to specify the device instance.

    ServiceType - supplies a pointer to a variable to receive the service type.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;


    PAGED_CODE();

    *ServiceType = ~0ul;
    status = PipOpenServiceEnumKeys (
                             KeyName,
                             KEY_READ,
                             &handle,
                             NULL,
                             FALSE
                             );
    if (NT_SUCCESS(status)) {
        status = IopGetRegistryValue(handle, L"Type", &keyValueInformation);
        if (NT_SUCCESS(status)) {
            if (keyValueInformation->Type == REG_DWORD) {
                if (keyValueInformation->DataLength >= sizeof(ULONG)) {
                    *ServiceType = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                }
            }
            ExFreePool(keyValueInformation);
        }
        ZwClose(handle);
    }
    return status;
}

BOOLEAN
PipIsFirmwareMapperDevicePresent (
    IN HANDLE KeyHandle
    )

/*++

Routine Description:

    This routine checks if the registry key is created by FirmwareMapper.
    If Yes, it further checks if the device for the key is present in this
    boot.

Parameters:

    KeyHandle - Specifies a handle to the registry key to be checked.

Return Value:

    A BOOLEAN vaStatus code that indicates whether or not the function was successful.

--*/
{
    NTSTATUS status;
    HANDLE handle;
    UNICODE_STRING unicodeName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG tmp = 0;

    PAGED_CODE();

    //
    // First check to see if this device instance key is a firmware-created one
    //

    status = IopGetRegistryValue (KeyHandle,
                                  REGSTR_VAL_FIRMWAREIDENTIFIED,
                                  &keyValueInformation);
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength == sizeof(ULONG))) {

            tmp = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (tmp == 0) {
        return TRUE;
    }

    //
    // Make sure the device is present.
    //

    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &handle,
                                   KeyHandle,
                                   &unicodeName,
                                   KEY_READ
                                   );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    status = IopGetRegistryValue (handle,
                                  REGSTR_VAL_FIRMWAREMEMBER,
                                  &keyValueInformation);
    ZwClose(handle);
    tmp = 0;

    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength == sizeof(ULONG))) {

            tmp = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (!tmp) {
        return FALSE;
    } else {
        return TRUE;
    }
}


NTSTATUS
IopSystemControlDispatch(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpeisa.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    PnpEisa.c

Abstract:

    This file implements Eisa related code.

Author:

    Shie-Lin Tzong (shielint)

Environment:

    Kernel Mode.

Notes:

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'iepP')
#endif

#define EISA_DEVICE_NODE_NAME L"EisaResources"
#define BUFFER_LENGTH 50

NTSTATUS
EisaGetEisaDevicesResources (
    OUT PCM_RESOURCE_LIST *ResourceList,
    OUT PULONG ResourceLength
    );

NTSTATUS
EisaBuildSlotsResources (
    IN ULONG SlotMasks,
    IN ULONG NumberMasks,
    OUT PCM_RESOURCE_LIST *Resource,
    OUT ULONG *Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, EisaBuildEisaDeviceNode)
#pragma alloc_text(INIT, EisaGetEisaDevicesResources)
#pragma alloc_text(INIT, EisaBuildSlotsResources)
#endif

NTSTATUS
EisaBuildEisaDeviceNode (
    VOID
    )

/*++

Routine Description:

    This routine build an registry key to report eisa resources to arbiters.

Arguments:

    None.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS            status;
    ULONG               disposition, tmpValue;
    WCHAR               buffer[BUFFER_LENGTH];

    UNICODE_STRING      unicodeString;
    HANDLE              rootHandle, deviceHandle, instanceHandle, logConfHandle;

    PCM_RESOURCE_LIST   resourceList;
    ULONG               resourceLength;

    status = EisaGetEisaDevicesResources(&resourceList, &resourceLength);
    if (!NT_SUCCESS(status) || resourceList == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    PiWstrToUnicodeString(&unicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root");
    status = IopOpenRegistryKeyEx( &rootHandle,
                                   NULL,
                                   &unicodeString,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
        if (resourceList) {
            ExFreePool (resourceList);
        }
        return status;
    }

    PiWstrToUnicodeString(&unicodeString, EISA_DEVICE_NODE_NAME);
    status = IopCreateRegistryKeyEx( &deviceHandle,
                                     rootHandle,
                                     &unicodeString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    ZwClose(rootHandle);
    if (!NT_SUCCESS(status)) {
        if (resourceList) {
            ExFreePool (resourceList);
        }
        return status;
    }

    PiWstrToUnicodeString( &unicodeString, L"0000" );
    status = IopCreateRegistryKeyEx( &instanceHandle,
                                     deviceHandle,
                                     &unicodeString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     &disposition );
    ZwClose(deviceHandle);
    if (NT_SUCCESS(status))  {

        //
        // If the key already exists because it was explicitly migrated
        // during textmode setup, we should still consider it a "new key".
        //
        if (disposition != REG_CREATED_NEW_KEY) {
            PKEY_VALUE_FULL_INFORMATION keyValueInformation;

            status = IopGetRegistryValue(instanceHandle,
                                         REGSTR_VALUE_MIGRATED,
                                         &keyValueInformation);
            if (NT_SUCCESS(status)) {

                if ((keyValueInformation->Type == REG_DWORD) &&
                    (keyValueInformation->DataLength == sizeof(ULONG)) &&
                    ((*(PULONG)KEY_VALUE_DATA(keyValueInformation)) != 0)) {
                    disposition = REG_CREATED_NEW_KEY;
                }

                ExFreePool(keyValueInformation);

                PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_MIGRATED);
                ZwDeleteValueKey(instanceHandle, &unicodeString);
            }
        }

        if (disposition == REG_CREATED_NEW_KEY) {

            PiWstrToUnicodeString( &unicodeString, L"DeviceDesc" );
            wcsncpy(buffer, L"Device to report Eisa Slot Resources", sizeof(buffer) / sizeof(WCHAR));
            buffer[(sizeof(buffer) / sizeof(WCHAR)) - 1] = UNICODE_NULL;

            ZwSetValueKey(instanceHandle,
                          &unicodeString,
                          0,
                          REG_SZ,
                          buffer,
                          (ULONG)((wcslen(buffer) + 1) * sizeof(WCHAR))
                          );

            PiWstrToUnicodeString( &unicodeString, L"HardwareID" );
            RtlZeroMemory(buffer, BUFFER_LENGTH * sizeof(WCHAR));
            wcsncpy(buffer, L"*Eisa_Resource_Device", sizeof(buffer) / sizeof(WCHAR));
            buffer[(sizeof(buffer) / sizeof(WCHAR)) - 1] = UNICODE_NULL;

            ZwSetValueKey(instanceHandle,
                          &unicodeString,
                          0,
                          REG_MULTI_SZ,
                          buffer,
                          (ULONG)((wcslen(buffer) + 2) * sizeof(WCHAR))
                          );

            PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_CONFIG_FLAGS);
            tmpValue = 0;
            ZwSetValueKey(instanceHandle,
                         &unicodeString,
                         TITLE_INDEX_VALUE,
                         REG_DWORD,
                         &tmpValue,
                         sizeof(tmpValue)
                         );

        }

        PiWstrToUnicodeString( &unicodeString, REGSTR_KEY_LOGCONF );
        status = IopCreateRegistryKeyEx( &logConfHandle,
                                         instanceHandle,
                                         &unicodeString,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        ZwClose(instanceHandle);
        if (NT_SUCCESS(status))  {
            PiWstrToUnicodeString( &unicodeString, REGSTR_VAL_BOOTCONFIG );

            status = ZwSetValueKey(logConfHandle,
                                   &unicodeString,
                                   0,
                                   REG_RESOURCE_LIST,
                                   resourceList,
                                   resourceLength
                                   );
            ZwClose(logConfHandle);
        }
    }
    if (resourceList) {
        ExFreePool (resourceList);
    }
    return status;
}

NTSTATUS
EisaGetEisaDevicesResources (
    OUT PCM_RESOURCE_LIST *ResourceList,
    OUT PULONG ResourceLength
    )

/*++

Routine Description:

    This routine builds a cm resource list for all the eisa slots.

Arguments:

    None.

Return Value:

    A CmResourceList.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING unicodeString;
    ULONG slotMasks = 0, numberMasks = 0, i;

    *ResourceList = NULL;
    *ResourceLength = 0;

    //
    // Open LocalMachine\Hardware\Description
    //

    //PiWstrToUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\EisaAdapter\\0");
    PiWstrToUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\EisaAdapter");
    status = IopOpenRegistryKeyEx( &handle,
                                   NULL,
                                   &unicodeString,
                                   KEY_READ
                                   );
    if (NT_SUCCESS(status)) {
        status = IopGetRegistryValue(handle,
                                     L"Configuration Data",
                                     &keyValueInformation
                                     );
        if (NT_SUCCESS(status)) {
            PCM_FULL_RESOURCE_DESCRIPTOR resourceDescriptor;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDescriptor;

            resourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)
                ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);

            if ((keyValueInformation->DataLength >= sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) &&
                (resourceDescriptor->PartialResourceList.Count > 0) ) {
                LONG eisaInfoLength;
                PCM_EISA_SLOT_INFORMATION eisaInfo;

                partialResourceDescriptor = resourceDescriptor->PartialResourceList.PartialDescriptors;
                if (partialResourceDescriptor->Type == CmResourceTypeDeviceSpecific) {
                    eisaInfo = (PCM_EISA_SLOT_INFORMATION)
                        ((PUCHAR)partialResourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
                    eisaInfoLength = (LONG)partialResourceDescriptor->u.DeviceSpecificData.DataSize;

                    //
                    // Parse the eisa slot info to find the eisa slots with device installed.
                    //

                    for (i = 0; i < 0x10 && eisaInfoLength > 0; i++) {
                        if (eisaInfo->ReturnCode == EISA_INVALID_SLOT) {
                            break;
                        }
                        if (eisaInfo->ReturnCode != EISA_EMPTY_SLOT && (i != 0)) {
                            slotMasks |= (1 << i);
                            numberMasks++;
                        }
                        if (eisaInfo->ReturnCode == EISA_EMPTY_SLOT) {
                            eisaInfoLength -= sizeof(CM_EISA_SLOT_INFORMATION);
                            eisaInfo++;
                        } else {
                            eisaInfoLength -= sizeof(CM_EISA_SLOT_INFORMATION) + eisaInfo->NumberFunctions * sizeof(CM_EISA_FUNCTION_INFORMATION);
                            eisaInfo = (PCM_EISA_SLOT_INFORMATION)
                                       ((PUCHAR)eisaInfo + eisaInfo->NumberFunctions * sizeof(CM_EISA_FUNCTION_INFORMATION) +
                                           sizeof(CM_EISA_SLOT_INFORMATION));
                        }
                    }

                    if (slotMasks) {
                        status = EisaBuildSlotsResources(slotMasks, numberMasks, ResourceList, ResourceLength);
                    }
                }

            }
            ExFreePool(keyValueInformation);
        }
        ZwClose(handle);
    }
    return status;
}

NTSTATUS
EisaBuildSlotsResources (
    IN ULONG SlotMasks,
    IN ULONG NumberMasks,
    OUT PCM_RESOURCE_LIST *Resources,
    OUT ULONG *Length
    )

/*++

Routine Description:

    This routine build a cm resource list for all the io resources used
    by the eisa devices.

Arguments:

    SlotMask - a mask to indicate the valid eisa slot.

Return Value:

    A pointer to a CM_RESOURCE_LIST.

--*/

{
    PCM_RESOURCE_LIST resources = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDesc;
    ULONG slot;

    *Length = sizeof(CM_RESOURCE_LIST) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * (NumberMasks - 1);
    resources = ExAllocatePool(PagedPool, *Length);
    if (resources) {
        resources->Count = 1;
        resources->List[0].InterfaceType = Eisa;
        resources->List[0].BusNumber = 0;
        resources->List[0].PartialResourceList.Version = 0;
        resources->List[0].PartialResourceList.Revision = 0;
        resources->List[0].PartialResourceList.Count = NumberMasks;
        partialDesc = resources->List[0].PartialResourceList.PartialDescriptors;
        slot = 0; // ignore slot 0
        while (SlotMasks) {
            SlotMasks >>= 1;
            slot++;
            if (SlotMasks & 1) {
                partialDesc->Type = CmResourceTypePort;
                partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
                partialDesc->Flags = CM_RESOURCE_PORT_16_BIT_DECODE + CM_RESOURCE_PORT_IO;
                partialDesc->u.Port.Start.LowPart = slot << 12;
                partialDesc->u.Port.Start.HighPart = 0;
                partialDesc->u.Port.Length = 0x1000;
                partialDesc++;
            }
        }
        *Resources = resources;
        return STATUS_SUCCESS;
    } else {
        return STATUS_NO_MEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpenum.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpenum.c

Abstract:

    This module contains routines to perform device enumeration

Author:

    Shie-Lin Tzong (shielint) Sept. 5, 1996.

Revision History:

    James Cavalaris (t-jcaval) July 29, 1997.
    Added IopProcessCriticalDeviceRoutine.

--*/

#include "pnpmgrp.h"
#pragma hdrstop
#include <setupblk.h>

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'nepP')
#endif

#define MAX_REENUMERATION_ATTEMPTS  32

typedef struct _DRIVER_LIST_ENTRY DRIVER_LIST_ENTRY, *PDRIVER_LIST_ENTRY;

typedef struct _PI_DEVICE_REQUEST {
    LIST_ENTRY ListEntry;
    PDEVICE_OBJECT DeviceObject;
    DEVICE_REQUEST_TYPE RequestType;
    BOOLEAN ReorderingBarrier;
    ULONG_PTR RequestArgument;
    PKEVENT CompletionEvent;
    PNTSTATUS CompletionStatus;
} PI_DEVICE_REQUEST, *PPI_DEVICE_REQUEST;

struct _DRIVER_LIST_ENTRY {
    PDRIVER_OBJECT DriverObject;
    PDRIVER_LIST_ENTRY NextEntry;
};

typedef enum _ADD_DRIVER_STAGE {
    LowerDeviceFilters = 0,
    LowerClassFilters,
    DeviceService,
    UpperDeviceFilters,
    UpperClassFilters,
    MaximumAddStage
} ADD_DRIVER_STAGE;

typedef enum _ENUM_TYPE {
    EnumTypeNone,
    EnumTypeShallow,
    EnumTypeDeep
} ENUM_TYPE;

#define VerifierTypeFromServiceType(service) \
    (VF_DEVOBJ_TYPE) (service + 2)

typedef struct {
    PDEVICE_NODE DeviceNode;

    BOOLEAN LoadDriver;

    PADD_CONTEXT AddContext;

    PDRIVER_LIST_ENTRY DriverLists[MaximumAddStage];
} QUERY_CONTEXT, *PQUERY_CONTEXT;

//
// Hash routine from CNTFS (see cntfs\prefxsup.c)
// (used here in the construction of unique ids)
//

#define HASH_UNICODE_STRING( _pustr, _phash ) {                             \
    PWCHAR _p = (_pustr)->Buffer;                                           \
    PWCHAR _ep = _p + ((_pustr)->Length/sizeof(WCHAR));                     \
    ULONG _chHolder =0;                                                     \
                                                                            \
    while( _p < _ep ) {                                                     \
        _chHolder = 37 * _chHolder + (unsigned int) (*_p++);                \
    }                                                                       \
                                                                            \
    *(_phash) = abs(314159269 * _chHolder) % 1000000007;                    \
}

// Parent prefixes are of the form %x&%x&%x
#define MAX_PARENT_PREFIX (8 + 8 + 8 + 2)

#if 0
#define ASSERT_INITED(x) \
        ASSERTMSG("DO_DEVICE_INITIALIZING not cleared on device object",       \
                  ((((x)->Flags) & DO_DEVICE_INITIALIZING) == 0))
#else
#if DBG
#define ASSERT_INITED(x) \
        if (((x)->Flags & DO_DEVICE_INITIALIZING) != 0)    \
            DbgPrint("DO_DEVICE_INITIALIZING flag not cleared on DO %#08lx\n", x);
#else
#define ASSERT_INITED(x) /* nothing */
#endif
#endif

#define PiSetDeviceInstanceSzValue(k, n, v) {               \
    if (k && *(v)) {                                        \
        UNICODE_STRING u;                                   \
        PiWstrToUnicodeString(&u, n);                       \
        ZwSetValueKey(                                      \
            k,                                              \
            &u,                                             \
            TITLE_INDEX_VALUE,                              \
            REG_SZ,                                         \
            *(v),                                           \
            (ULONG)((wcslen(*(v))+1) * sizeof(WCHAR)));     \
    }                                                       \
    if (*v) {                                               \
        ExFreePool(*v);                                     \
        *(v) = NULL;                                        \
    }                                                       \
}

#define PiSetDeviceInstanceMultiSzValue(k, n, v, s) {       \
    if (k && *(v)) {                                        \
        UNICODE_STRING u;                                   \
        PiWstrToUnicodeString(&u, n);                       \
        ZwSetValueKey(                                      \
            k,                                              \
            &u,                                             \
            TITLE_INDEX_VALUE,                              \
            REG_MULTI_SZ,                                   \
            *(v),                                           \
            s);                                             \
    }                                                       \
    if (*(v)) {                                             \
        ExFreePool(*v);                                     \
        *(v) = NULL;                                        \
    }                                                       \
}

#if DBG
VOID
PipAssertDevnodesInConsistentState(
    VOID
    );
#else
#define PipAssertDevnodesInConsistentState()
#endif

NTSTATUS
PipCallDriverAddDevice(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN LoadDriver,
    IN PADD_CONTEXT AddContext
    );

NTSTATUS
PipCallDriverAddDeviceQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PWCHAR ValueData,
    IN ULONG ValueLength,
    IN PQUERY_CONTEXT Context,
    IN ULONG ServiceType
    );

NTSTATUS
PipChangeDeviceObjectFromRegistryProperties(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN HANDLE DeviceClassPropKey,
    IN HANDLE DevicePropKey,
    IN BOOLEAN UsePdoCharacteristics
    );

VOID
PipDeviceActionWorker(
    IN  PVOID   Context
    );

NTSTATUS
PipEnumerateDevice(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    );

BOOLEAN
PipGetRegistryDwordWithFallback(
    IN     PUNICODE_STRING valueName,
    IN     HANDLE PrimaryKey,
    IN     HANDLE SecondaryKey,
    IN OUT PULONG Value
    );

PSECURITY_DESCRIPTOR
PipGetRegistrySecurityWithFallback(
    IN     PUNICODE_STRING valueName,
    IN     HANDLE PrimaryKey,
    IN     HANDLE SecondaryKey
    );

NTSTATUS
PipMakeGloballyUniqueId(
    IN PDEVICE_OBJECT DeviceObject,
    IN PWCHAR         UniqueId,
    OUT PWCHAR       *GloballyUniqueId
    );

NTSTATUS
PipProcessCriticalDeviceRoutine(
    IN HANDLE hDevInstance,
    IN PBOOLEAN FoundMatch,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING ClassGuid,
    IN PUNICODE_STRING Driver,
    IN PUNICODE_STRING LowerFilters,
    IN PUNICODE_STRING UpperFilters
    );

NTSTATUS
PipProcessDevNodeTree(
    IN  PDEVICE_NODE        SubtreeRootDeviceNode,
    IN  BOOLEAN             LoadDriver,
    IN  BOOLEAN             ReallocateResources,
    IN  ENUM_TYPE           EnumType,
    IN  BOOLEAN             Synchronous,
    IN  BOOLEAN             ProcessOnlyIntermediateStates,
    IN  PADD_CONTEXT        AddContext,
    IN PPI_DEVICE_REQUEST   Request
    );

NTSTATUS
PipProcessNewDeviceNode(
    IN OUT PDEVICE_NODE DeviceNode
    );

NTSTATUS
PiProcessQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PipProcessRestartPhase1(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    );

NTSTATUS
PipProcessRestartPhase2(
    IN PDEVICE_NODE     DeviceNode
    );

NTSTATUS
PipProcessStartPhase1(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    );

NTSTATUS
PipProcessStartPhase2(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
PipProcessStartPhase3(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
PiRestartDevice(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessHaltDevice(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiResetProblemDevicesWorker(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PVOID           Context
    );

VOID
PiMarkDeviceTreeForReenumeration(
    IN  PDEVICE_NODE DeviceNode,
    IN  BOOLEAN Subtree
    );

NTSTATUS
PiMarkDeviceTreeForReenumerationWorker(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PVOID           Context
    );

BOOLEAN
PiCollapseEnumRequests(
    PLIST_ENTRY ListHead
    );

NTSTATUS
PiProcessAddBootDevices(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessClearDeviceProblem(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessRequeryDeviceState(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessResourceRequirementsChanged(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessReenumeration(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessSetDeviceProblem(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessShutdownPnpDevices(
    IN PDEVICE_NODE        DeviceNode
    );

NTSTATUS
PiProcessStartSystemDevices(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiBuildDeviceNodeInstancePath(
    IN PDEVICE_NODE DeviceNode,
    IN PWCHAR BusID,
    IN PWCHAR DeviceID,
    IN PWCHAR InstanceID
    );

NTSTATUS
PiCreateDeviceInstanceKey(
    IN PDEVICE_NODE DeviceNode,
    OUT PHANDLE InstanceHandle,
    OUT PULONG Disposition
    );

NTSTATUS
PiQueryAndAllocateBootResources(
    IN PDEVICE_NODE DeviceNode,
    IN HANDLE LogConfKey
    );

NTSTATUS
PiQueryResourceRequirements(
    IN PDEVICE_NODE DeviceNode,
    IN HANDLE LogConfKey
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoShutdownPnpDevices)

#pragma alloc_text(PAGE, PipCallDriverAddDevice)
#pragma alloc_text(PAGE, PipCallDriverAddDeviceQueryRoutine)
#pragma alloc_text(PAGE, PipChangeDeviceObjectFromRegistryProperties)
#pragma alloc_text(PAGE, PipEnumerateDevice)
#pragma alloc_text(PAGE, PipGetRegistryDwordWithFallback)
#pragma alloc_text(PAGE, PipGetRegistrySecurityWithFallback)
#pragma alloc_text(PAGE, PipMakeGloballyUniqueId)
#pragma alloc_text(PAGE, PipProcessCriticalDevice)
#pragma alloc_text(PAGE, PipProcessCriticalDeviceRoutine)
#pragma alloc_text(PAGE, PipProcessDevNodeTree)
#pragma alloc_text(PAGE, PipProcessNewDeviceNode)
#pragma alloc_text(PAGE, PiProcessQueryDeviceState)
#pragma alloc_text(PAGE, PipQueryDeviceCapabilities)
#pragma alloc_text(PAGE, PiProcessHaltDevice)
#pragma alloc_text(PAGE, PpResetProblemDevices)
#pragma alloc_text(PAGE, PiResetProblemDevicesWorker)
#pragma alloc_text(PAGE, PiMarkDeviceTreeForReenumeration)
#pragma alloc_text(PAGE, PiMarkDeviceTreeForReenumerationWorker)
#pragma alloc_text(PAGE, PiProcessAddBootDevices)
#pragma alloc_text(PAGE, PiProcessClearDeviceProblem)
#pragma alloc_text(PAGE, PiProcessRequeryDeviceState)
#pragma alloc_text(PAGE, PiRestartDevice)
#pragma alloc_text(PAGE, PiProcessResourceRequirementsChanged)
#pragma alloc_text(PAGE, PiProcessReenumeration)
#pragma alloc_text(PAGE, PiProcessSetDeviceProblem)
#pragma alloc_text(PAGE, PiProcessShutdownPnpDevices)
#pragma alloc_text(PAGE, PiProcessStartSystemDevices)
#pragma alloc_text(PAGE, PiBuildDeviceNodeInstancePath)
#pragma alloc_text(PAGE, PiCreateDeviceInstanceKey)
#pragma alloc_text(PAGE, PiQueryAndAllocateBootResources)
#pragma alloc_text(PAGE, PiQueryResourceRequirements)

#pragma alloc_text(PAGELK, PiLockDeviceActionQueue)
#pragma alloc_text(PAGELK, PiUnlockDeviceActionQueue)
//#pragma alloc_text(NONPAGE, PiCollapseEnumRequests)
//#pragma alloc_text(NONPAGE, PpRemoveDeviceActionRequests)
//#pragma alloc_text(NONPAGE, PiMarkDeviceStackStartPending)
#endif

//
// This flag indicates if the device's InvalidateDeviceRelation is in progress.
// To read or write this flag, callers must get IopPnpSpinlock.
//

BOOLEAN PipEnumerationInProgress;
BOOLEAN PipTearDownPnpStacksOnShutdown;
WORK_QUEUE_ITEM PipDeviceEnumerationWorkItem;

//
// Internal constant strings
//

#define DEVICE_PREFIX_STRING                TEXT("\\Device\\")
#define DOSDEVICES_PREFIX_STRING            TEXT("\\DosDevices\\")

VOID
PiLockDeviceActionQueue(
    VOID
    )
{
    KIRQL oldIrql;

    for (;;) {
        //
        // Lock the device tree so that power operations dont overlap PnP
        // operations like rebalance.
        //
        PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

        ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

        if (!PipEnumerationInProgress) {
            //
            // Device action worker queue is empty. Make it so that new requests
            // get queued but new device action worker item does not get kicked
            // off.
            //
            PipEnumerationInProgress = TRUE;
            KeClearEvent(&PiEnumerationLock);
            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
            break;
        }

        ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
        //
        // Unlock the tree so device action worker can finish current processing.
        //
        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        //
        // Wait for current device action worker item to complete.
        //
        KeWaitForSingleObject(
            &PiEnumerationLock,
            Executive,
            KernelMode,
            FALSE,
            NULL );
    }
}

VOID
PiUnlockDeviceActionQueue(
    VOID
    )
{
    KIRQL oldIrql;
    //
    // Check if we need to kick off the enumeration worker here.
    //
    ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    if (!IsListEmpty(&IopPnpEnumerationRequestList)) {

        ExInitializeWorkItem(&PipDeviceEnumerationWorkItem, PipDeviceActionWorker, NULL);
        ExQueueWorkItem(&PipDeviceEnumerationWorkItem, DelayedWorkQueue);
    } else {

        PipEnumerationInProgress = FALSE;
        KeSetEvent(&PiEnumerationLock, 0, FALSE);
    }

    ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
}

NTSTATUS
PipRequestDeviceAction(
    IN PDEVICE_OBJECT       DeviceObject        OPTIONAL,
    IN DEVICE_REQUEST_TYPE  RequestType,
    IN BOOLEAN              ReorderingBarrier,
    IN ULONG_PTR            RequestArgument,
    IN PKEVENT              CompletionEvent     OPTIONAL,
    IN PNTSTATUS            CompletionStatus    OPTIONAL
    )

/*++

Routine Description:

    This routine queues a work item to enumerate a device. This is for IO
    internal use only.

Arguments:

    DeviceObject - Supplies a pointer to the device object to be enumerated.
                   if NULL, this is a request to retry resources allocation
                   failed devices.

    Request - the reason for the enumeration.

Return Value:

    NTSTATUS code.

--*/

{
    PPI_DEVICE_REQUEST  request;
    KIRQL               oldIrql;

    if (PpPnpShuttingDown) {
        return STATUS_TOO_LATE;
    }

    //
    // If this node is ready for enumeration, enqueue it
    //

    request = ExAllocatePool(NonPagedPool, sizeof(PI_DEVICE_REQUEST));

    if (request) {
        //
        // Put this request onto the pending list
        //

        if (DeviceObject == NULL) {

            DeviceObject = IopRootDeviceNode->PhysicalDeviceObject;
        }

        ObReferenceObject(DeviceObject);

        request->DeviceObject = DeviceObject;
        request->RequestType = RequestType;
        request->ReorderingBarrier = ReorderingBarrier;
        request->RequestArgument = RequestArgument;
        request->CompletionEvent = CompletionEvent;
        request->CompletionStatus = CompletionStatus;

        InitializeListHead(&request->ListEntry);

        //
        // Insert the  request to the request queue.  If the request queue is
        // not currently being worked on, request a worker thread to start it.
        //

        ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

        InsertTailList(&IopPnpEnumerationRequestList, &request->ListEntry);

        if (RequestType == AddBootDevices ||
            RequestType == ReenumerateBootDevices ||
            RequestType == ReenumerateRootDevices) {

            ASSERT(!PipEnumerationInProgress);
            //
            // This is a special request used when booting the system.  Instead
            // of queuing a work item it synchronously calls the worker routine.
            //

            PipEnumerationInProgress = TRUE;
            KeClearEvent(&PiEnumerationLock);
            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

            PipDeviceActionWorker(NULL);

        } else if (PnPBootDriversLoaded && !PipEnumerationInProgress) {
            PipEnumerationInProgress = TRUE;
            KeClearEvent(&PiEnumerationLock);
            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

            //
            // Queue a work item to do the enumeration
            //

            ExInitializeWorkItem(&PipDeviceEnumerationWorkItem, PipDeviceActionWorker, NULL);
            ExQueueWorkItem(&PipDeviceEnumerationWorkItem, DelayedWorkQueue);
        } else {
            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
        }
    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}

VOID
PipDeviceActionWorker(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This function drains items from the "PnP Action queue". The action queue
    contains a list of operations that must be synchronized wrt to Start & Enum.

Parameters:

    Context - Not used.

ReturnValue:

    None.

--*/
{
    PPI_DEVICE_REQUEST  request;
    PPI_DEVICE_REQUEST  collapsedRequest;
    PLIST_ENTRY         entry;
    BOOLEAN             assignResources;
    BOOLEAN             bootProcess;
    BOOLEAN             newDevice;
    ADD_CONTEXT         addContext;
    KIRQL               oldIrql;
    NTSTATUS            status;
    BOOLEAN             dereferenceDevice;

    UNREFERENCED_PARAMETER(Context);

    assignResources = FALSE;
    bootProcess = FALSE;
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    for ( ; ; ) {

        status = STATUS_SUCCESS;
        //
        // PipProcessDevNodeTree always dereferences passed in device. Set this
        // to false if PipProcessDevNodeTree is called with the device in the
        // original request.
        //
        dereferenceDevice = TRUE;

        ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

        entry = RemoveHeadList(&IopPnpEnumerationRequestList);
        if (entry == &IopPnpEnumerationRequestList) {

            if (assignResources == FALSE && bootProcess == FALSE) {
                //
                // No more processing.
                //
                break;
            }
            entry = NULL;
        }

        ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

        if (entry == NULL) {

            ASSERT(assignResources || bootProcess);

            if (assignResources || bootProcess) {

                addContext.DriverStartType = SERVICE_DEMAND_START;

                ObReferenceObject(IopRootDeviceNode->PhysicalDeviceObject);
                status = PipProcessDevNodeTree( IopRootDeviceNode,
                                                PnPBootDriversInitialized, // LoadDriver
                                                assignResources,            // ReallocateResources
                                                EnumTypeNone,
                                                FALSE,
                                                FALSE,
                                                &addContext,
                                                NULL);
                if (!NT_SUCCESS(status)) {

                    status = STATUS_SUCCESS;
                }
                assignResources = FALSE;
                bootProcess = FALSE;
            }

            continue;
        }
        //
        // We have a list of requests to process. Processing depends on the type
        // of the first one in the list.
        //
        ASSERT(entry);
        request = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
        InitializeListHead(&request->ListEntry);

        if (PP_DO_TO_DN(request->DeviceObject)->State == DeviceNodeDeleted) {

            status = STATUS_UNSUCCESSFUL;
        } else {

            switch (request->RequestType) {

            case AddBootDevices:
                //
                // Boot driver initialization.
                //
                status = PiProcessAddBootDevices(request);
                break;

            case AssignResources:
                //
                // Resources were freed, we want to try to satisfy any
                // DNF_INSUFFICIENT_RESOURCES devices.
                //
                assignResources = TRUE;
                break;

            case ClearDeviceProblem:
            case ClearEjectProblem:

                status = PiProcessClearDeviceProblem(request);
                break;

            case HaltDevice:

                status = PiProcessHaltDevice(request);
                break;

            case RequeryDeviceState:

                status = PiProcessRequeryDeviceState(request);
                break;

            case ResetDevice:

                status = PiRestartDevice(request);
                break;

            case ResourceRequirementsChanged:

                status = PiProcessResourceRequirementsChanged(request);
                if (!NT_SUCCESS(status)) {
                    //
                    // The device wasn't started when IopResourceRequirementsChanged
                    // was called.
                    //
                    assignResources = TRUE;
                    status = STATUS_SUCCESS;
                }
                break;

            case ReenumerateBootDevices:

                //
                // Indicate that this is during boot driver initialization phase.
                //
                bootProcess = TRUE;
                break;

            case RestartEnumeration:        // Used after completion of async I/O
            case ReenumerateRootDevices:
            case ReenumerateDeviceTree:
                //
                // FALL THROUGH...
                //
            case ReenumerateDeviceOnly:

                status = PiProcessReenumeration(request);
                dereferenceDevice = FALSE;
                break;

            case SetDeviceProblem:

                status = PiProcessSetDeviceProblem(request);
                break;

            case ShutdownPnpDevices:

                status = PiProcessShutdownPnpDevices(IopRootDeviceNode);
                break;

            case StartDevice:

                status = PiRestartDevice(request);
                break;

            case StartSystemDevices:

                status = PiProcessStartSystemDevices(request);
                dereferenceDevice = FALSE;
                break;
            }
        }
        //
        // Free the list.
        //
        do {

            entry = RemoveHeadList(&request->ListEntry);
            collapsedRequest = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
            //
            // Done with this enumeration request
            //
            if (collapsedRequest->CompletionStatus) {

                *collapsedRequest->CompletionStatus = status;
            }
            if (collapsedRequest->CompletionEvent) {

                KeSetEvent(collapsedRequest->CompletionEvent, 0, FALSE);
            }
            //
            // Only dereference the original request, the rest get dereferenced
            // when we collapse.
            //
            if ((collapsedRequest == request && dereferenceDevice)) {

                ObDereferenceObject(collapsedRequest->DeviceObject);
            }
            ExFreePool(collapsedRequest);

        } while (collapsedRequest != request);
    }

    PipEnumerationInProgress = FALSE;

    KeSetEvent(&PiEnumerationLock, 0, FALSE);
    ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
}

NTSTATUS
IoShutdownPnpDevices(
    VOID
    )

/*++

Routine Description:

    This function is called by the IO system driver verifier during shutdown.
    It queues a work item to Query/Remove all the devices in the tree.  All
    the ones supporting removal will be removed and their drivers unloaded if
    all instances of their devices are removed.

    This API should only be called once during shutdown, it has no effect on the
    second and subsequent calls.

Parameters:

    NONE.

Return Value:

    STATUS_SUCCESS if the process was successfully completed.  Doesn't mean
    any devices were actually removed.  Otherwise an error code indicating the
    error.  There is no guarantee that no devices have been removed if an error
    occurs however in the current implementation the only time an error will
    be reported is if the operation couldn't be queued.

--*/

{
    KEVENT          actionEvent;
    NTSTATUS        actionStatus;
    NTSTATUS        status;

    PAGED_CODE();

    KeInitializeEvent(&actionEvent, NotificationEvent, FALSE);

    status = PipRequestDeviceAction( NULL,
                                     ShutdownPnpDevices,
                                     FALSE,
                                     0,
                                     &actionEvent,
                                     &actionStatus);

    if (NT_SUCCESS(status)) {

        //
        // Wait for the event we just queued to finish since synchronous
        // operation was requested (non alertable wait).
        //
        // FUTURE ITEM - Use a timeout here?
        //

        status = KeWaitForSingleObject( &actionEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        if (NT_SUCCESS(status)) {
            status = actionStatus;
        }
    }

    return status;

}

NTSTATUS
PipEnumerateDevice(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    )

/*++

Routine Description:

    This function assumes that the specified physical device object is
    a bus and will enumerate all of the children PDOs on the bus.

Arguments:

    DeviceObject - Supplies a pointer to the physical device object to be
                   enumerated.

    StartContext - supplies a pointer to the START_CONTEXT to control how to
                   add/start new devices.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    DeviceNode->Flags &= ~DNF_REENUMERATE;

    //
    // First get a reference to the PDO to make sure it won't go away.
    //

    deviceObject = DeviceNode->PhysicalDeviceObject;

    status = IopQueryDeviceRelations( BusRelations,
                                      deviceObject,
                                      Synchronous,
                                      &DeviceNode->OverUsed1.PendingDeviceRelations);

    return status;
}

NTSTATUS
PipEnumerateCompleted(
    IN PDEVICE_NODE DeviceNode
    )
{
    PDEVICE_NODE    childDeviceNode, nextChildDeviceNode;
    PDEVICE_OBJECT  childDeviceObject;
    BOOLEAN         childRemoved;
    NTSTATUS        status, allocationStatus;
    ULONG           i;

    if (DeviceNode->OverUsed1.PendingDeviceRelations == NULL) {

        PipSetDevNodeState(DeviceNode, DeviceNodeStarted, NULL);

        return STATUS_SUCCESS;
    }

    //
    // Walk all the child device nodes and mark them as not present
    //

    childDeviceNode = DeviceNode->Child;
    while (childDeviceNode) {
        childDeviceNode->Flags &= ~DNF_ENUMERATED;
        childDeviceNode = childDeviceNode->Sibling;
    }

    //
    // Check all the PDOs returned see if any new one or any one disappeared.
    //

    for (i = 0; i < DeviceNode->OverUsed1.PendingDeviceRelations->Count; i++) {

        childDeviceObject = DeviceNode->OverUsed1.PendingDeviceRelations->Objects[i];

        ASSERT_INITED(childDeviceObject);

        if (childDeviceObject->DeviceObjectExtension->ExtensionFlags & DOE_DELETE_PENDING) {

            PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(childDeviceObject);
            KeBugCheckEx( PNP_DETECTED_FATAL_ERROR,
                          PNP_ERR_PDO_ENUMERATED_AFTER_DELETION,
                          (ULONG_PTR)childDeviceObject,
                          0,
                          0);
        }

        //
        // We've found another physical device, see if there is
        // already a devnode for it.
        //

        childDeviceNode = (PDEVICE_NODE)childDeviceObject->DeviceObjectExtension->DeviceNode;
        if (childDeviceNode == NULL) {

            //
            // Device node doesn't exist, create one.
            //

            allocationStatus = PipAllocateDeviceNode(
                childDeviceObject,
                &childDeviceNode);

            if (childDeviceNode) {

                //
                // We've found or created a devnode for the PDO that the
                // bus driver just enumerated.
                //
                childDeviceNode->Flags |= DNF_ENUMERATED;

                //
                // Mark the device object a bus enumerated device
                //
                childDeviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;

                //
                // Put this new device node at the head of the parent's list
                // of children.
                //
                PpDevNodeInsertIntoTree(DeviceNode, childDeviceNode);
                if (allocationStatus == STATUS_SYSTEM_HIVE_TOO_LARGE) {

                    PipSetDevNodeProblem(childDeviceNode, CM_PROB_REGISTRY_TOO_LARGE);
                }

            } else {

                //
                // Had a problem creating a devnode.  Pretend we've never
                // seen it.
                //
                IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                             "PipEnumerateDevice: Failed to allocate device node\n"));

                ObDereferenceObject(childDeviceObject);
            }
        } else {

            //
            // The device is alreay enumerated.  Remark it and release the
            // device object reference.
            //
            childDeviceNode->Flags |= DNF_ENUMERATED;

            if (childDeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED) {

                //
                // A dock that was listed as departing in an eject relation
                // didn't actually leave. Remove it from the profile transition
                // list...
                //
                PpProfileCancelTransitioningDock(childDeviceNode, DOCK_DEPARTING);
            }

            ASSERT(!(childDeviceNode->Flags & DNF_DEVICE_GONE));

            ObDereferenceObject(childDeviceObject);
        }
    }

    ExFreePool(DeviceNode->OverUsed1.PendingDeviceRelations);
    DeviceNode->OverUsed1.PendingDeviceRelations = NULL;

    //
    // If we get here, the enumeration was successful.  Process any missing
    // devnodes.
    //

    childRemoved = FALSE;

    for (childDeviceNode = DeviceNode->Child;
         childDeviceNode != NULL;
         childDeviceNode = nextChildDeviceNode) {

        //
        // First, we need to remember the 'next child' because the 'child' will be
        // removed and we won't be able to find the 'next child.'
        //

        nextChildDeviceNode = childDeviceNode->Sibling;

        if (!(childDeviceNode->Flags & DNF_ENUMERATED)) {

            if (!(childDeviceNode->Flags & DNF_DEVICE_GONE)) {

                childDeviceNode->Flags |= DNF_DEVICE_GONE;

                PipRequestDeviceRemoval(
                    childDeviceNode,
                    TRUE,
                    CM_PROB_DEVICE_NOT_THERE
                    );

                childRemoved = TRUE;
            }
        }
    }

    ASSERT(DeviceNode->State == DeviceNodeEnumerateCompletion);
    PipSetDevNodeState(DeviceNode, DeviceNodeStarted, NULL);

    //
    // The root enumerator gets confused if we reenumerate it before we process
    // newly reported PDOs.  Since it can't possibly create the scenario we are
    // trying to fix, we won't bother waiting for the removes to complete before
    // processing the new devnodes.
    //

    if (childRemoved && DeviceNode != IopRootDeviceNode) {

        status = STATUS_PNP_RESTART_ENUMERATION;

    } else {

        status = STATUS_SUCCESS;
    }

    return status;
}

VOID
PiMarkDeviceStackStartPending(
    IN PDEVICE_OBJECT   DeviceObject,
    IN BOOLEAN          Set
    )

/*++

Routine Description:

    This function marks the entire device stack with DOE_START_PENDING.

Arguments:

    DeviceObject - PDO for the device stack.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT attachedDevice;
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (attachedDevice = DeviceObject;
         attachedDevice != NULL;
         attachedDevice = attachedDevice->AttachedDevice) {

        if (Set) {

            attachedDevice->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;
        } else {

            attachedDevice->DeviceObjectExtension->ExtensionFlags &= ~DOE_START_PENDING;
        }
    }

    KeReleaseQueuedSpinLock(LockQueueIoDatabaseLock, irql);
}

NTSTATUS
PiBuildDeviceNodeInstancePath(
    IN PDEVICE_NODE DeviceNode,
    IN PWCHAR BusID,
    IN PWCHAR DeviceID,
    IN PWCHAR InstanceID
    )

/*++

Routine Description:

    This function builds the instance path (BusID\DeviceID\InstanceID). If 
    successful, it will free the storage for any existing instance path and 
    replace with the new one.

Arguments:

    DeviceNode - DeviceNode for which the instance path will be built.
    
    BusID - Bus ID.
    
    DeviceID - Device ID.
    
    InstanceID - Instance ID.

Return Value:

    NTSTATUS.

--*/

{
    ULONG length;
    PWCHAR instancePath;

    PAGED_CODE();

    if (BusID == NULL || DeviceID == NULL || InstanceID == NULL) {

        ASSERT( PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) ||
                PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) ||
                PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY));

        return STATUS_UNSUCCESSFUL;
    }

    length = (ULONG)((wcslen(BusID) + wcslen(DeviceID) + wcslen(InstanceID) + 2) * sizeof(WCHAR) + sizeof(UNICODE_NULL));
    instancePath = (PWCHAR)ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);
    if (!instancePath) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Construct the instance path as <BUS>\<DEVICE>\<INSTANCE>. This should always be NULL terminated 
    // since we have precomputed the length that we pass into this counted routine.
    //
    _snwprintf(instancePath, length / sizeof(WCHAR), L"%s\\%s\\%s", BusID, DeviceID, InstanceID);
    //
    // Free old instance path.
    //
    if (DeviceNode->InstancePath.Buffer != NULL) {

        IopCleanupDeviceRegistryValues(&DeviceNode->InstancePath);
        ExFreePool(DeviceNode->InstancePath.Buffer);
    }

    RtlInitUnicodeString(&DeviceNode->InstancePath, instancePath);

    return STATUS_SUCCESS;
}

NTSTATUS
PiCreateDeviceInstanceKey(
    IN PDEVICE_NODE DeviceNode,
    OUT PHANDLE InstanceKey,
    OUT PULONG Disposition
    )

/*++

Routine Description:

    This function will create the device instance key.
    
Arguments:

    DeviceNode - DeviceNode for which the instance path will be built.
    
    InstanceKey - Will recieve the instance key handle.
    
    Disposition - Will recieve the disposition whether the key existed or was newly created.
    
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    HANDLE enumHandle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    *InstanceKey = NULL;
    *Disposition = 0;

    PiLockPnpRegistry(FALSE);

    status = IopOpenRegistryKeyEx( 
                &enumHandle,
                NULL,
                &CmRegistryMachineSystemCurrentControlSetEnumName,
                KEY_ALL_ACCESS
                );
    if (NT_SUCCESS(status)) {

        status = IopCreateRegistryKeyEx( 
                    InstanceKey,
                    enumHandle,
                    &DeviceNode->InstancePath,
                    KEY_ALL_ACCESS,
                    REG_OPTION_NON_VOLATILE,
                    Disposition
                    );
        if (NT_SUCCESS(status)) {
            //
            // Keys migrated by textmode setup should be treated as "new".
            // Migrated keys are identified by the presence of non-zero 
            // REG_DWORD value "Migrated" under the device instance key.
            //
            if (*Disposition != REG_CREATED_NEW_KEY) {

                keyValueInformation = NULL;
                IopGetRegistryValue(
                    *InstanceKey,
                    REGSTR_VALUE_MIGRATED,
                    &keyValueInformation);
                if (keyValueInformation) {

                    if (    keyValueInformation->Type == REG_DWORD &&
                            keyValueInformation->DataLength == sizeof(ULONG) &&
                            *(PULONG)KEY_VALUE_DATA(keyValueInformation) != 0) {

                        *Disposition = REG_CREATED_NEW_KEY;
                    }

                    PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_MIGRATED);
                    ZwDeleteValueKey(*InstanceKey, &unicodeString);

                    ExFreePool(keyValueInformation);
                }
            }

        } else {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PpCreateDeviceInstanceKey: Unable to create %wZ\n", 
                         &DeviceNode->InstancePath));
            ASSERT(*InstanceKey != NULL);
        }

        ZwClose(enumHandle);
    } else {
        //
        // This would be very bad.
        //
        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PpCreateDeviceInstanceKey: Unable to open %wZ\n", 
                     &CmRegistryMachineSystemCurrentControlSetEnumName));
        ASSERT(enumHandle != NULL);
    }

    PiUnlockPnpRegistry();

    return status;
}

NTSTATUS
PiQueryAndAllocateBootResources(
    IN PDEVICE_NODE DeviceNode,
    IN HANDLE LogConfKey
    )

/*++

Routine Description:

    This function will query the BOOT resources for the device and reserve them from the arbiter.
    
Arguments:

    DeviceNode - DeviceNode for which the BOOT resources need to be queried.
    
    LogConfKey - Handle to the LogConf key under the device instance key.
        
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    PCM_RESOURCE_LIST cmResource;
    ULONG cmLength;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    cmResource = NULL;
    cmLength = 0;
    if (DeviceNode->BootResources == NULL) {

        status = IopQueryDeviceResources( 
                    DeviceNode->PhysicalDeviceObject,
                    QUERY_RESOURCE_LIST,
                    &cmResource,
                    &cmLength);
        if (!NT_SUCCESS(status)) {

            ASSERT(cmResource == NULL && cmLength == 0);
            cmResource = NULL;
            cmLength = 0;
        }
    } else {

        IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                        "PNPENUM: %ws already has BOOT config in PiQueryAndAllocateBootResources!\n",
                        DeviceNode->InstancePath.Buffer));
    }
    //
    // Write boot resources to registry
    //
    if (LogConfKey && DeviceNode->BootResources == NULL) {

        PiWstrToUnicodeString(&unicodeString, REGSTR_VAL_BOOTCONFIG);

        PiLockPnpRegistry(FALSE);

        if (cmResource) {

            ZwSetValueKey(
                LogConfKey,
                &unicodeString,
                TITLE_INDEX_VALUE,
                REG_RESOURCE_LIST,
                cmResource,
                cmLength);
        } else {

            ZwDeleteValueKey(LogConfKey, &unicodeString);
        }

        PiUnlockPnpRegistry();

        if (cmResource) {
            //
            // This device consumes BOOT resources.  Reserve its boot resources
            //
            status = (*IopAllocateBootResourcesRoutine)(    
                        ArbiterRequestPnpEnumerated,
                        DeviceNode->PhysicalDeviceObject,
                        cmResource);
            if (NT_SUCCESS(status)) {

                DeviceNode->Flags |= DNF_HAS_BOOT_CONFIG;
            }
        }
    }
    if (cmResource) {

        ExFreePool(cmResource);
    }

    return status;
}

NTSTATUS
PiQueryResourceRequirements(
    IN PDEVICE_NODE DeviceNode,
    IN HANDLE LogConfKey
    )

/*++

Routine Description:

    This function will query the resource requirements for the device.
    
Arguments:

    DeviceNode - DeviceNode for which the resource requirements need to be queried.
    
    LogConfKey - Handle to the LogConf key under the device instance key.
        
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResource;
    ULONG ioLength;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    //
    // Query the device's basic config vector. 
    //
    status = PpIrpQueryResourceRequirements(
                DeviceNode->PhysicalDeviceObject, 
                &ioResource);
    if (!NT_SUCCESS(status)) {

        ASSERT(ioResource == NULL);
        ioResource = NULL;
    }
    if (ioResource) {

        ioLength = ioResource->ListSize;
    } else {

        ioLength = 0;
    }
    //
    // Write resource requirements to registry
    //
    if (LogConfKey) {

        PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_BASIC_CONFIG_VECTOR);

        PiLockPnpRegistry(FALSE);

        if (ioResource) {

            ZwSetValueKey(
                LogConfKey,
                &unicodeString,
                TITLE_INDEX_VALUE,
                REG_RESOURCE_REQUIREMENTS_LIST,
                ioResource,
                ioLength);

            DeviceNode->Flags |= DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED;
            DeviceNode->ResourceRequirements = ioResource;
            ioResource = NULL;
        } else {

            ZwDeleteValueKey(LogConfKey, &unicodeString);
        }
        PiUnlockPnpRegistry();
    }
    if (ioResource) {

        ExFreePool(ioResource);
    }

    return status;
}

NTSTATUS
PipProcessNewDeviceNode(
    IN PDEVICE_NODE DeviceNode

/*++

Routine Description:

    This function will process a new device.
    
Arguments:

    DeviceNode - New DeviceNode.
            
Return Value:

    NTSTATUS.

--*/

    )
{
    NTSTATUS status, finalStatus;
    PDEVICE_OBJECT deviceObject, dupeDeviceObject;
    PWCHAR busID, deviceID, instanceID, description, location, uniqueInstanceID, hwIDs, compatibleIDs;
    DEVICE_CAPABILITIES capabilities;
    BOOLEAN globallyUnique, criticalDevice, configuredBySetup, isRemoteBootCard;
    ULONG instanceIDLength, disposition, configFlags, problem, hwIDLength, compatibleIDLength;
    HANDLE instanceKey, logConfKey;
    PDEVICE_NODE dupeDeviceNode;
    UNICODE_STRING unicodeString;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    IO_STACK_LOCATION irpSp;
    GUID busTypeGuid;

    PAGED_CODE();

    finalStatus = STATUS_SUCCESS;

    criticalDevice = FALSE;
    isRemoteBootCard = FALSE;
    logConfKey = NULL;
    instanceKey = NULL;
    disposition = 0;

    deviceObject = DeviceNode->PhysicalDeviceObject;

    status = PpQueryDeviceID(DeviceNode, &busID, &deviceID);
    if (!NT_SUCCESS(status)) {

        if (status == STATUS_PNP_INVALID_ID) {

            finalStatus = STATUS_UNSUCCESSFUL;
        } else {

            finalStatus = status;
        }
    }
    //
    // Query the device's capabilities.
    //
    status = PipQueryDeviceCapabilities(DeviceNode, &capabilities);
    //
    // Process the capabilities before saving them.
    //
    DeviceNode->UserFlags &= ~DNUF_DONT_SHOW_IN_UI;
    globallyUnique = FALSE;
    if (NT_SUCCESS(status)) {

        if (capabilities.NoDisplayInUI) {

            DeviceNode->UserFlags |= DNUF_DONT_SHOW_IN_UI;
        }
        if (capabilities.UniqueID) {

            globallyUnique = TRUE;
        }
    }
    //
    // Record, is this a dock?
    //

    if (capabilities.DockDevice) {

        if (DeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED) {

            ASSERT(DeviceNode->DockInfo.DockStatus != DOCK_EJECTIRP_COMPLETED);
            PpProfileCancelTransitioningDock(DeviceNode, DOCK_DEPARTING);
        }
        DeviceNode->DockInfo.DockStatus = DOCK_QUIESCENT;
    } else {

        DeviceNode->DockInfo.DockStatus = DOCK_NOTDOCKDEVICE;
    }

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Query the device's description.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_TEXT;
    irpSp.Parameters.QueryDeviceText.DeviceTextType = DeviceTextDescription;
    irpSp.Parameters.QueryDeviceText.LocaleId = PsDefaultSystemLocaleId;
    status = IopSynchronousCall(deviceObject, &irpSp, (PULONG_PTR)&description);

    if (!NT_SUCCESS(status)) {
        description = NULL;
    }

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Query the device's location information.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_TEXT;
    irpSp.Parameters.QueryDeviceText.DeviceTextType = DeviceTextLocationInformation;
    irpSp.Parameters.QueryDeviceText.LocaleId = PsDefaultSystemLocaleId;
    status = IopSynchronousCall(deviceObject, &irpSp, (PULONG_PTR)&location);

    if (!NT_SUCCESS(status)) {
        location = NULL;
    }
    //
    // Query the instance ID for the new devnode.
    //
    status = PpQueryInstanceID(DeviceNode, &instanceID, &instanceIDLength);
    if (!globallyUnique) {

        if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) && 
                DeviceNode->Parent != IopRootDeviceNode) {

            uniqueInstanceID = NULL;

            status = PipMakeGloballyUniqueId(deviceObject, instanceID, &uniqueInstanceID);

            if (instanceID != NULL) {

                ExFreePool(instanceID);
            }
            instanceID = uniqueInstanceID;
            if (instanceID) {

                instanceIDLength = ((ULONG)wcslen(instanceID) + 1) * sizeof(WCHAR);
            } else {
                
                instanceIDLength = 0;
                ASSERT(!NT_SUCCESS(status));
            }
        }
    } else if (status == STATUS_NOT_SUPPORTED) {

        PipSetDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA);
        DeviceNode->Parent->Flags |= DNF_CHILD_WITH_INVALID_ID;
        PpSetInvalidIDEvent(&DeviceNode->Parent->InstancePath);

        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PpQueryID: Bogus ID returned by %wZ\n",
                     &DeviceNode->Parent->ServiceName));
        ASSERT(status != STATUS_NOT_SUPPORTED || !globallyUnique);
    }

RetryDuplicateId:

    if (!NT_SUCCESS(status)) {
         
        finalStatus = status;
        if (!PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA)) {

            if (status == STATUS_INSUFFICIENT_RESOURCES) {
    
                PipSetDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY);
            } else {
                //
                // Perhaps some other problem code?
                //
                PipSetDevNodeProblem(DeviceNode, CM_PROB_REGISTRY);
            }
        }
    }
    //
    // Build the device instance path and create the instance key.
    //
    status = PiBuildDeviceNodeInstancePath(DeviceNode, busID, deviceID, instanceID);
    if (NT_SUCCESS(status)) {

        status = PiCreateDeviceInstanceKey(DeviceNode, &instanceKey, &disposition);
    }

    if (!NT_SUCCESS(status)) {

        finalStatus = status;
    }
    //
    // Mark the devnode as initialized.
    //
    PiMarkDeviceStackStartPending(deviceObject, TRUE);

    //
    // ISSUE: Should not mark the state if the IDs were invalid.
    //
    PipSetDevNodeState(DeviceNode, DeviceNodeInitialized, NULL);

    if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {
        //
        // Check if we are encountering this device for the very first time.
        //
        if (disposition == REG_CREATED_NEW_KEY) {
            //
            // Save the description only for new devices so we dont clobber 
            // the inf written description for already installed devices.
            //
            PiLockPnpRegistry(FALSE);

            PiSetDeviceInstanceSzValue(instanceKey, REGSTR_VAL_DEVDESC, &description);

            PiUnlockPnpRegistry();
        } else {
            //
            // Check if there is another device with the same name.
            //
            dupeDeviceObject = IopDeviceObjectFromDeviceInstance(&DeviceNode->InstancePath);
            if (dupeDeviceObject) {

                if (dupeDeviceObject != deviceObject) {

                    if (globallyUnique) {

                        globallyUnique = FALSE;
                        PipSetDevNodeProblem(DeviceNode, CM_PROB_DUPLICATE_DEVICE);

                        dupeDeviceNode = dupeDeviceObject->DeviceObjectExtension->DeviceNode;
                        ASSERT(dupeDeviceNode);

                        if (dupeDeviceNode->Parent == DeviceNode->Parent) {
                            //
                            // Definite driver screw up. If the verifier is enabled
                            // we will fail the driver. Otherwise, we will attempt
                            // to uniquify the second device to keep the system
                            // alive.
                            //
                            PpvUtilFailDriver(
                                PPVERROR_DUPLICATE_PDO_ENUMERATED,
                                (PVOID) deviceObject->DriverObject->MajorFunction[IRP_MJ_PNP],
                                deviceObject,
                                (PVOID)dupeDeviceObject);
                        }

                        ObDereferenceObject(dupeDeviceObject);

                        status = PipMakeGloballyUniqueId(deviceObject, instanceID, &uniqueInstanceID);

                        if (instanceID != NULL) {

                            ExFreePool(instanceID);
                        }
                        instanceID = uniqueInstanceID;
                        if (instanceID) {

                            instanceIDLength = ((ULONG)wcslen(instanceID) + 1) * sizeof(WCHAR);
                        } else {

                            instanceIDLength = 0;
                            ASSERT(!NT_SUCCESS(status));
                        }
                        //
                        // Cleanup and retry.
                        //
                        goto RetryDuplicateId;
                    }
                    //
                    // No need to clean up the ref as we're going to crash the
                    // system.
                    //
                    //ObDereferenceObject(dupCheckDeviceObject);

                    PpvUtilFailDriver(
                        PPVERROR_DUPLICATE_PDO_ENUMERATED,
                        (PVOID) deviceObject->DriverObject->MajorFunction[IRP_MJ_PNP],
                        deviceObject,
                        (PVOID)dupeDeviceObject);

                    PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(deviceObject);
                    PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(dupeDeviceObject);
                    KeBugCheckEx( 
                        PNP_DETECTED_FATAL_ERROR,
                        PNP_ERR_DUPLICATE_PDO,
                        (ULONG_PTR)deviceObject,
                        (ULONG_PTR)dupeDeviceObject,
                        0);
                }
                ObDereferenceObject(dupeDeviceObject);
            }
        }
    }

    if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {

        PiLockPnpRegistry(FALSE);
        //
        // Save device location and capabilities.
        //
        PiSetDeviceInstanceSzValue(instanceKey, REGSTR_VALUE_LOCATION_INFORMATION, &location);

        IopSaveDeviceCapabilities(DeviceNode, &capabilities);
        //
        // ADRIAO N.B. 2001/05/29 - Raw device issue
        //     processCriticalDevice has no effect on raw devnodes. A raw
        // devnode with CONFIGFLAG_FAILED_INSTALL or CONFIGFLAG_REINSTALL
        // should be started anyway if it's in the CDDB (not that NULL CDDB
        // entries are supported yet), but that doesn't happen today. This
        // means that boot volumes with CONFIGFLAG_REINSTALL will lead to a
        // definite 7B.
        //
        problem = 0;
        criticalDevice = (disposition == REG_CREATED_NEW_KEY)? TRUE : FALSE;
        status = IopGetRegistryValue(instanceKey, REGSTR_VALUE_CONFIG_FLAGS, &keyValueInformation);
        if (NT_SUCCESS(status)) {

            configFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            if (configFlags & CONFIGFLAG_REINSTALL) {

                problem = CM_PROB_REINSTALL;
                criticalDevice = TRUE;
            } else if (configFlags & CONFIGFLAG_FAILEDINSTALL) {

                problem = CM_PROB_FAILED_INSTALL;
                criticalDevice = TRUE;
            }

            ExFreePool(keyValueInformation);
        } else {

            configFlags = 0;
            problem = CM_PROB_NOT_CONFIGURED;
            criticalDevice = TRUE;
        }
        if (problem) {

            if (capabilities.RawDeviceOK) {

                configFlags |= CONFIGFLAG_FINISH_INSTALL;
                PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_CONFIG_FLAGS);
                ZwSetValueKey(
                    instanceKey,
                    &unicodeString,
                    TITLE_INDEX_VALUE,
                    REG_DWORD,
                    &configFlags,
                    sizeof(configFlags));
            } else {

                PipSetDevNodeProblem(DeviceNode, problem);
            }
        }
        status = IopMapDeviceObjectToDeviceInstance(DeviceNode->PhysicalDeviceObject, &DeviceNode->InstancePath);
        ASSERT(NT_SUCCESS(status));
        if (!NT_SUCCESS(status)) {

            finalStatus = status;
        }

        PiUnlockPnpRegistry();
    }

    PpQueryHardwareIDs( 
        DeviceNode,
        &hwIDs,
        &hwIDLength);

    PpQueryCompatibleIDs(  
        DeviceNode,
        &compatibleIDs,
        &compatibleIDLength);

    PiLockPnpRegistry(FALSE);

    DeviceNode->Flags |= DNF_IDS_QUERIED;

    if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {

        PiWstrToUnicodeString(&unicodeString, REGSTR_KEY_LOG_CONF);
        IopCreateRegistryKeyEx( 
            &logConfKey,
            instanceKey,
            &unicodeString,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);
    }

    PiUnlockPnpRegistry();

    PiQueryResourceRequirements(DeviceNode, logConfKey);

    PiLockPnpRegistry(FALSE);

    if (IoRemoteBootClient && (IopLoaderBlock != NULL)) {

        if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
                !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
                !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {
        
            if (hwIDs) {
    
                isRemoteBootCard = IopIsRemoteBootCard(
                                        DeviceNode->ResourceRequirements,
                                        (PLOADER_PARAMETER_BLOCK)IopLoaderBlock,
                                        hwIDs);
            }
            if (!isRemoteBootCard && compatibleIDs) {
    
                isRemoteBootCard = IopIsRemoteBootCard(
                                        DeviceNode->ResourceRequirements,
                                        (PLOADER_PARAMETER_BLOCK)IopLoaderBlock,
                                        compatibleIDs);
            }
        }
    }

    PiSetDeviceInstanceMultiSzValue(instanceKey, REGSTR_VALUE_HARDWAREID, &hwIDs, hwIDLength);

    PiSetDeviceInstanceMultiSzValue(instanceKey, REGSTR_VALUE_COMPATIBLEIDS, &compatibleIDs, compatibleIDLength);

    status = STATUS_SUCCESS;
    if (isRemoteBootCard) {

        status = IopSetupRemoteBootCard(
                        (PLOADER_PARAMETER_BLOCK)IopLoaderBlock,
                        instanceKey,
                        &DeviceNode->InstancePath);
        if (!NT_SUCCESS(status)) {

            finalStatus = status;
        }
    }

    PiUnlockPnpRegistry();

    //
    // we've pretty much got the PDO information ready, apart from Child bus information
    // get that now, because class-installer may want it
    //

    if (NT_SUCCESS(IopQueryPnpBusInformation(
                     deviceObject,
                     &busTypeGuid,
                     &DeviceNode->ChildInterfaceType,
                     &DeviceNode->ChildBusNumber))) {

        DeviceNode->ChildBusTypeIndex = PpBusTypeGuidGetIndex(&busTypeGuid);

    } else {

        DeviceNode->ChildBusTypeIndex = 0xffff;
        DeviceNode->ChildInterfaceType = InterfaceTypeUndefined;
        DeviceNode->ChildBusNumber = 0xfffffff0;
    }

    if (NT_SUCCESS(status)) {

        if (criticalDevice) {
            //
            // Process the device as a critical device.
            //
            // This will attempt to locate a match for the device in the
            // CriticalDeviceDatabase using the device's hardware and compatible
            // ids.  If a match is found, critical device settings such as Service,
            // ClassGUID (to determine Class filters), and device LowerFilters and
            // UpperFilters will be applied to the device.
            //
            // If DevicePath location information matching this device is present
            // critical device database entry, this routine will also pre-install
            // the new device with those settings.
            //
            if (!capabilities.HardwareDisabled && !PipIsDevNodeProblem(DeviceNode, CM_PROB_NEED_RESTART)) {

                PipProcessCriticalDevice(DeviceNode);
            }
        }

        ASSERT(!PipDoesDevNodeHaveProblem(DeviceNode) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_NOT_CONFIGURED) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_REINSTALL) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_FAILED_INSTALL) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_PARTIAL_LOG_CONF) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_HARDWARE_DISABLED) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_NEED_RESTART) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_DUPLICATE_DEVICE) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY));

        if (!PipIsDevNodeProblem(DeviceNode, CM_PROB_DISABLED) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_HARDWARE_DISABLED) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_NEED_RESTART) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {

            IopIsDeviceInstanceEnabled(instanceKey, &DeviceNode->InstancePath, TRUE);
        }
    }

    PiQueryAndAllocateBootResources(DeviceNode, logConfKey);

    if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {

        PiLockPnpRegistry(FALSE);

        IopSaveDeviceCapabilities(DeviceNode, &capabilities);

        PiUnlockPnpRegistry();

        PpHotSwapUpdateRemovalPolicy(DeviceNode);
        //
        // Create new value entry under ServiceKeyName\Enum to reflect the newly
        // added made-up device instance node.
        //
        status = IopNotifySetupDeviceArrival( deviceObject,
                                              instanceKey,
                                              TRUE);

        configuredBySetup = NT_SUCCESS(status) ? TRUE : FALSE;

        status = PpDeviceRegistration(
                     &DeviceNode->InstancePath,
                     TRUE,
                     &DeviceNode->ServiceName
                     );
        if (NT_SUCCESS(status)) {

            if (    (configuredBySetup || isRemoteBootCard) &&
                    PipIsDevNodeProblem(DeviceNode, CM_PROB_NOT_CONFIGURED)) {

                PipClearDevNodeProblem(DeviceNode);
            }
        }
        //
        // Add an event so user-mode will attempt to install this device later.
        //
        PpSetPlugPlayEvent(&GUID_DEVICE_ENUMERATED, deviceObject);
    }
    //
    // Cleanup.
    //
    if (hwIDs) {

        ExFreePool(hwIDs);        
    }
    if (compatibleIDs) {

        ExFreePool(compatibleIDs);
    }
    if (logConfKey) {

        ZwClose(logConfKey);
    }
    if (instanceKey) {

        ZwClose(instanceKey);
    }
    if (instanceID) {

        ExFreePool(instanceID);
    }
    if (location) {

        ExFreePool(location);
    }
    if (description) {

        ExFreePool(description);
    }
    if (busID) {

        ExFreePool(busID);
    }

    return finalStatus;
}

NTSTATUS
PipCallDriverAddDevice(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN LoadDriver,
    IN PADD_CONTEXT Context
    )

/*++

Routine Description:

    This function checks if the driver for the DeviceNode is present and loads
    the driver if necessary.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be enumerated.

    LoadDriver - Supplies a BOOLEAN value to indicate should a driver be loaded
                 to complete enumeration.

    Context - Supplies a pointer to ADD_CONTEXT to control how the device be added.

Return Value:

    NTSTATUS code.

--*/

{
    HANDLE enumKey, instanceKey, controlKey, classKey = NULL, classPropsKey = NULL;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation = NULL;
    RTL_QUERY_REGISTRY_TABLE queryTable[3];
    QUERY_CONTEXT queryContext;
    BOOLEAN deviceRaw = FALSE;
    BOOLEAN usePdoCharacteristics = TRUE;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT fdoDeviceObject, topOfPdoStack, topOfLowerFilterStack;
    BOOLEAN deviceObjectHasBeenAttached = FALSE;
    UNICODE_STRING unicodeClassGuid;

    IopDbgPrint((   IOP_ENUMERATION_TRACE_LEVEL,
                    "PipCallDriverAddDevice: Processing devnode %#08lx\n",
                   DeviceNode));
    IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                    "PipCallDriverAddDevice: DevNode flags going in = %#08lx\n",
                   DeviceNode->Flags));

    //
    // The device node may have been started at this point.  This is because
    // some ill-behaved miniport drivers call IopReportedDetectedDevice at
    // DriverEntry for the devices which we already know about.
    //

    ASSERT_INITED(DeviceNode->PhysicalDeviceObject);

    IopDbgPrint((   IOP_ENUMERATION_TRACE_LEVEL,
                    "PipCallDriverAddDevice:\t%s load driver\n",
                    LoadDriver? "Will" : "Won't"));

    IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                    "PipCallDriverAddDevice:\tOpening registry key %wZ\n",
                    &DeviceNode->InstancePath));

    //
    // Open the HKLM\System\CCS\Enum key.
    //

    status = IopOpenRegistryKeyEx( &enumKey,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice:\tUnable to open HKLM\\SYSTEM\\CCS\\ENUM\n"));
        return status;
    }

    //
    // Open the instance key for this devnode
    //

    status = IopOpenRegistryKeyEx( &instanceKey,
                                   enumKey,
                                   &DeviceNode->InstancePath,
                                   KEY_READ
                                   );

    ZwClose(enumKey);

    if (!NT_SUCCESS(status)) {

        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice:\t\tError %#08lx opening %wZ enum key\n",
                        status, &DeviceNode->InstancePath));
        return status;
    }
    //
    // Get the class value to locate the class key for this devnode
    //
    status = IopGetRegistryValue(instanceKey,
                                 REGSTR_VALUE_CLASSGUID,
                                 &keyValueInformation);
    if(NT_SUCCESS(status)) {

        if (    keyValueInformation->Type == REG_SZ &&
                keyValueInformation->DataLength) {

            IopRegistryDataToUnicodeString(
                &unicodeClassGuid,
                (PWSTR) KEY_VALUE_DATA(keyValueInformation),
                keyValueInformation->DataLength);
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipCallDriverAddDevice:\t\tClass GUID is %wZ\n",
                            &unicodeClassGuid));
            if (InitSafeBootMode) {

                if (!IopSafebootDriverLoad(&unicodeClassGuid)) {

                    PKEY_VALUE_FULL_INFORMATION ClassValueInformation = NULL;
                    NTSTATUS s;
                    //
                    // don't load the driver
                    //
                    IopDbgPrint((IOP_ENUMERATION_WARNING_LEVEL,
                                 "SAFEBOOT: skipping device = %wZ\n", &unicodeClassGuid));

                    s = IopGetRegistryValue(instanceKey,
                                            REGSTR_VAL_DEVDESC,
                                            &ClassValueInformation);
                    if (NT_SUCCESS(s)) {

                        UNICODE_STRING ClassString;

                        RtlInitUnicodeString(&ClassString, (PCWSTR) KEY_VALUE_DATA(ClassValueInformation));
                        IopBootLog(&ClassString, FALSE);
                    } else {

                        IopBootLog(&unicodeClassGuid, FALSE);
                    }
                    ZwClose(instanceKey);
                    return STATUS_UNSUCCESSFUL;
                }
            }
            //
            // Open the class key
            //
            status = IopOpenRegistryKeyEx( &controlKey,
                                           NULL,
                                           &CmRegistryMachineSystemCurrentControlSetControlClass,
                                           KEY_READ
                                           );
            if (NT_SUCCESS(status)) {

                status = IopOpenRegistryKeyEx( &classKey,
                                               controlKey,
                                               &unicodeClassGuid,
                                               KEY_READ
                                               );
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                    "PipCallDriverAddDevice:\tUnable to open GUID key "
                                    "%wZ - %#08lx\n",
                                    &unicodeClassGuid,status));
                }
                ZwClose(controlKey);
            } else {

                IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                "PipCallDriverAddDevice:\tUnable to open "
                                "HKLM\\SYSTEM\\CCS\\CONTROL\\CLASS - %#08lx\n",
                                status));
            }
            if (classKey != NULL) {

                UNICODE_STRING unicodeProperties;

                PiWstrToUnicodeString(&unicodeProperties, REGSTR_KEY_DEVICE_PROPERTIES );
                status = IopOpenRegistryKeyEx( &classPropsKey,
                                               classKey,
                                               &unicodeProperties,
                                               KEY_READ
                                               );
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                    "PipCallDriverAddDevice:\tUnable to open GUID\\Properties key "
                                    "%wZ - %#08lx\n",
                                    &unicodeClassGuid,status));
                }
            }
        }
        ExFreePool(keyValueInformation);
        keyValueInformation = NULL;
    }
    //
    // Check to see if there's a service assigned to this device node.  If
    // there's not then we can bail out without wasting too much time.
    //
    RtlZeroMemory(&queryContext, sizeof(queryContext));

    queryContext.DeviceNode = DeviceNode;
    queryContext.LoadDriver = LoadDriver;

    queryContext.AddContext = Context;

    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].QueryRoutine =
        (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
    queryTable[0].Name = REGSTR_VAL_LOWERFILTERS;
    queryTable[0].EntryContext = (PVOID) UIntToPtr(LowerDeviceFilters);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR) instanceKey,
                                    queryTable,
                                    &queryContext,
                                    NULL);
    if (NT_SUCCESS(status)) {

        if (classKey != NULL) {

            queryTable[0].QueryRoutine =
                (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
            queryTable[0].Name = REGSTR_VAL_LOWERFILTERS;
            queryTable[0].EntryContext = (PVOID) UIntToPtr(LowerClassFilters);
            status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                            (PWSTR) classKey,
                                            queryTable,
                                            &queryContext,
                                            NULL);
            if (!NT_SUCCESS(status)) {

                IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                "PipCallDriverAddDevice\t\tError %#08lx reading LowerClassFilters "
                                "value for %wZ\n", status, &DeviceNode->InstancePath));

            }
        }

        if (NT_SUCCESS(status)) {
            queryTable[0].QueryRoutine = (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
            queryTable[0].Name = REGSTR_VALUE_SERVICE;
            queryTable[0].EntryContext = (PVOID) UIntToPtr(DeviceService);
            queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;

            status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                            (PWSTR) instanceKey,
                                            queryTable,
                                            &queryContext,
                                            NULL);
            if (!NT_SUCCESS(status)) {

                IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                "PipCallDriverAddDevice\t\tError %#08lx reading service "
                                "value for %wZ\n", status, &DeviceNode->InstancePath));

            }
        }
    } else {

        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice\t\tError %#08lx reading LowerDeviceFilters "
                        "value for %wZ\n", status, &DeviceNode->InstancePath));
    }

    if (DeviceNode->Flags & DNF_LEGACY_DRIVER) {

        //
        // One of the services for this device is a legacy driver.  Don't try
        // to add any filters since we'll just mess up the device stack.
        //

        status = STATUS_SUCCESS;
        goto Cleanup;

    } else if (NT_SUCCESS(status)) {

        //
        // Call was successful so we must have been able to reference the
        // driver object.
        //

        ASSERT(queryContext.DriverLists[DeviceService] != NULL);

        if (queryContext.DriverLists[DeviceService]->NextEntry != NULL) {

            //
            // There's more than one service assigned to this device.  Configuration
            // error
            IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                            "PipCallDriverAddDevice: Configuration Error - more "
                            "than one service in driver list\n"));

            PipSetDevNodeProblem(DeviceNode, CM_PROB_REGISTRY);

            status = STATUS_UNSUCCESSFUL;

            goto Cleanup;
        }
        //
        // this is the only case (FDO specified) where we can ignore PDO's characteristics
        //
        usePdoCharacteristics = FALSE;

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        if (!IopDeviceNodeFlagsToCapabilities(DeviceNode)->RawDeviceOK) {

            //
            // The device cannot be used raw.  Bail out now.
            //

            status = STATUS_UNSUCCESSFUL;
            goto Cleanup;

        } else {

            //
            // Raw device access is okay.
            //

            PipClearDevNodeProblem(DeviceNode);

            usePdoCharacteristics = TRUE; // shouldn't need to do this, but better be safe than sorry
            deviceRaw = TRUE;
            status = STATUS_SUCCESS;

        }

    } else {

        //
        // something else went wrong while parsing the service key.  The
        // query routine will have set the flags appropriately so we can
        // just bail out.
        //

        goto Cleanup;

    }

    //
    // For each type of filter driver we want to build a list of the driver
    // objects to be loaded.  We'll build all the driver lists if we can
    // and deal with error conditions afterwards.
    //

     //
     // First get all the information we have to out of the instance key and
     // the device node.
     //

     RtlZeroMemory(queryTable, sizeof(queryTable));

     queryTable[0].QueryRoutine =
         (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
     queryTable[0].Name = REGSTR_VAL_UPPERFILTERS;
     queryTable[0].EntryContext = (PVOID) UIntToPtr(UpperDeviceFilters);
     status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                     (PWSTR) instanceKey,
                                     queryTable,
                                     &queryContext,
                                     NULL);

     if (NT_SUCCESS(status) && classKey) {
         queryTable[0].QueryRoutine =
             (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
         queryTable[0].Name = REGSTR_VAL_UPPERFILTERS;
         queryTable[0].EntryContext = (PVOID) UIntToPtr(UpperClassFilters);

         status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                         (PWSTR) classKey,
                                         queryTable,
                                         &queryContext,
                                         NULL);
    }

    if (NT_SUCCESS(status)) {

        UCHAR serviceType = 0;
        PDRIVER_LIST_ENTRY listEntry = queryContext.DriverLists[serviceType];

        //
        // Make sure there's no more than one device service.  Anything else is
        // a configuration error.
        //

        ASSERT(!(DeviceNode->Flags & DNF_LEGACY_DRIVER));

        ASSERTMSG(
            "Error - Device has no service but cannot be run RAW\n",
            ((queryContext.DriverLists[DeviceService] != NULL) || (deviceRaw)));

        //
        // Do preinit work.
        //
        fdoDeviceObject = NULL;
        topOfLowerFilterStack = NULL;
        topOfPdoStack = IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject);

        //
        // It's okay to try adding all the drivers.
        //
        for (serviceType = 0; serviceType < MaximumAddStage; serviceType++) {

            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipCallDriverAddDevice: Adding Services (type %d)\n",
                            serviceType));

            if (serviceType == DeviceService) {

                topOfLowerFilterStack = IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject);

                if (deviceRaw && (queryContext.DriverLists[serviceType] == NULL)) {

                    //
                    // Mark the devnode as added, as it has no service.
                    //

                    ASSERT(queryContext.DriverLists[serviceType] == NULL);
                    PipSetDevNodeState(DeviceNode, DeviceNodeDriversAdded, NULL);

                } else {

                    //
                    // Since we are going to see a service, grab a pointer to
                    // the current top of the stack. While here, assert there
                    // is exactly one service driver to load...
                    //
                    ASSERT(queryContext.DriverLists[serviceType]);
                    ASSERT(!queryContext.DriverLists[serviceType]->NextEntry);
                }
            }

            for (listEntry = queryContext.DriverLists[serviceType];
                listEntry != NULL;
                listEntry = listEntry->NextEntry) {

                PDRIVER_ADD_DEVICE addDeviceRoutine;

                IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                                "PipCallDriverAddDevice:\tAdding driver %#08lx\n",
                                listEntry->DriverObject));

                ASSERT(listEntry->DriverObject);
                ASSERT(listEntry->DriverObject->DriverExtension);
                ASSERT(listEntry->DriverObject->DriverExtension->AddDevice);

                //
                // Invoke the driver's AddDevice() entry point.
                //
                addDeviceRoutine =
                    listEntry->DriverObject->DriverExtension->AddDevice;

                status = PpvUtilCallAddDevice(
                    DeviceNode->PhysicalDeviceObject,
                    listEntry->DriverObject,
                    addDeviceRoutine,
                    VerifierTypeFromServiceType(serviceType)
                    );

                IopDbgPrint((   IOP_ENUMERATION_TRACE_LEVEL,
                                "PipCallDriverAddDevice:\t\tRoutine returned "
                                "%#08lx\n", status));

                if (NT_SUCCESS(status)) {

                   //
                   // If this is a service, mark the  it is legal for a filter to succeed AddDevice
                   // but fail to attach anything to the top of the stack.
                   //
                   if (serviceType == DeviceService) {

                       fdoDeviceObject = topOfLowerFilterStack->AttachedDevice;
                       ASSERT(fdoDeviceObject);
                   }

                   PipSetDevNodeState(DeviceNode, DeviceNodeDriversAdded, NULL);

                } else if (serviceType == DeviceService) {

                    //
                    // Mark the stack appropriately.
                    //
                    IovUtilMarkStack(
                        DeviceNode->PhysicalDeviceObject,
                        topOfPdoStack->AttachedDevice,
                        fdoDeviceObject,
                        FALSE
                        );

                    //
                    // If service fails, then add failed. (Alternately, if
                    // filter drivers return failure, we keep going.)
                    //
                    PipRequestDeviceRemoval(DeviceNode, FALSE, CM_PROB_FAILED_ADD);
                    goto Cleanup;
                }

                if (IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject)->Flags & DO_DEVICE_INITIALIZING) {
                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                    "***************** DO_DEVICE_INITIALIZING not cleared on %#08lx\n",
                                    IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject)));
                }

                ASSERT_INITED(IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject));
            }
        }

        //
        // Mark the stack appropriately. We tell the verifier the stack is raw
        // if the fdo is NULL and we made it this far.
        //
        IovUtilMarkStack(
            DeviceNode->PhysicalDeviceObject,
            topOfPdoStack->AttachedDevice,
            fdoDeviceObject,
            ((fdoDeviceObject == NULL) || deviceRaw)
            );

        //
        // change PDO and all attached objects
        // to have properties specified in the registry
        //

        PipChangeDeviceObjectFromRegistryProperties(DeviceNode->PhysicalDeviceObject, classPropsKey, instanceKey, usePdoCharacteristics);

        //
        // CapabilityFlags are refreshed with call to IopSaveDeviceCapabilities after device is started
        //

    } else {

        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipCallDriverAddDevice: Error %#08lx while building "
                        "driver load list\n", status));

        goto Cleanup;
    }

    deviceObject = DeviceNode->PhysicalDeviceObject;

    status = IopQueryLegacyBusInformation(
                 deviceObject,
                 NULL,
                 &DeviceNode->InterfaceType,
                 &DeviceNode->BusNumber
             );

    if (NT_SUCCESS(status)) {

        IopInsertLegacyBusDeviceNode(DeviceNode, DeviceNode->InterfaceType, DeviceNode->BusNumber);

    } else {

        DeviceNode->InterfaceType = InterfaceTypeUndefined;
        DeviceNode->BusNumber = 0xfffffff0;
    }

    status = STATUS_SUCCESS;

    ASSERT(DeviceNode->State == DeviceNodeDriversAdded);

Cleanup:
    {

        UCHAR i;

        IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                        "PipCallDriverAddDevice: DevNode flags leaving = %#08lx\n",
                        DeviceNode->Flags));

        IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                        "PipCallDriverAddDevice: Cleaning up\n"));

        //
        // Free the entries in the driver load list & release the references on
        // their driver objects.
        //

        for (i = 0; i < MaximumAddStage; i++) {

            PDRIVER_LIST_ENTRY listHead = queryContext.DriverLists[i];

            while(listHead != NULL) {

                PDRIVER_LIST_ENTRY tmp = listHead;

                listHead = listHead->NextEntry;

                ASSERT(tmp->DriverObject != NULL);

                //
                // Let the driver unload if it hasn't created any device
                // objects. We only do this if the paging stack is already
                // online (the same filter may be needed by more than one card).
                // IopInitializeBootDrivers will take care of cleaning up any
                // leftover drivers after boot.
                //
                if (PnPBootDriversInitialized) {

                    IopUnloadAttachedDriver(tmp->DriverObject);
                }

                ObDereferenceObject(tmp->DriverObject);

                ExFreePool(tmp);
            }
        }
    }

    ZwClose(instanceKey);

    if (classKey != NULL) {
        ZwClose(classKey);
    }

    if (classPropsKey != NULL) {
        ZwClose(classPropsKey);
    }

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipCallDriverAddDevice: Returning status %#08lx\n", status));

    return status;
}

NTSTATUS
PipCallDriverAddDeviceQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PWCHAR ValueData,
    IN ULONG ValueLength,
    IN PQUERY_CONTEXT Context,
    IN ULONG ServiceType
    )

/*++

Routine Description:

    This routine is called to build a list of driver objects which need to
    be Added to a physical device object.  Each time it is called with a
    service name it will locate a driver object for that device and append
    it to the proper driver list for the device node.

    In the event a driver object cannot be located or that it cannot be loaded
    at this time, this routine will return an error and will set the flags
    in the device node in the context appropriately.

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - a structure which contains the device node, the context passed
              to PipCallDriverAddDevice and the driver lists for the device
              node.

    EntryContext - the index of the driver list the routine should append
                   nodes to.

Return Value:

    STATUS_SUCCESS if the driver was located and added to the list
    successfully or if there was a non-fatal error while handling the
    driver.

    an error value indicating why the driver could not be added to the list.

--*/

{
    UNICODE_STRING unicodeServiceName;
    UNICODE_STRING unicodeDriverName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG i;
    ULONG loadType;
    PWSTR prefixString = L"\\Driver\\";
    BOOLEAN madeupService;
    USHORT groupIndex;
    PDRIVER_OBJECT driverObject = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS driverEntryStatus;
    BOOLEAN freeDriverName = FALSE;
    HANDLE handle, serviceKey;
#if DBG
    PDRIVER_OBJECT tempDrvObj;
#endif

    //
    // Preinit
    //
    serviceKey = NULL;

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipCallDriverAddDevice:\t\tValue %ws [Type %d, Len %d] @ "
                    "%#08lx\n",
                    ValueName, ValueType, ValueLength, ValueData));

    //
    // First check and make sure that the value type is okay.  An invalid type
    // is not a fatal error.
    //

    if (ValueType != REG_SZ) {

        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipCallDriverAddDevice:\t\tValueType %d invalid for "
                        "ServiceType %d\n",
                        ValueType,ServiceType));

        return STATUS_SUCCESS;
    }

    //
    // Make sure the string is a reasonable length.
    //

    if (ValueLength <= sizeof(WCHAR)) {

        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipCallDriverAddDevice:\t\tValueLength %d is too short\n",
                        ValueLength));

        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&unicodeServiceName, ValueData);

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipCallDriverAddDevice:\t\t\tService Name %wZ\n",
                    &unicodeServiceName));

    //
    // Check the service name to see if it should be used directly to reference
    // the driver object.  If the string begins with "\Driver", make sure the
    // madeupService flag is set.
    //

    madeupService = TRUE;
    i = 0;

    while(*prefixString != L'\0') {

        if (unicodeServiceName.Buffer[i] != *prefixString) {

            madeupService = FALSE;
            break;
        }

        i++;
        prefixString++;
    }

    //
    // Get the driver name from the service key. We need this to figure out
    // if the driver is already in memory.
    //
    if (madeupService) {

        RtlInitUnicodeString(&unicodeDriverName, unicodeServiceName.Buffer);

    } else {

        //
        // BUGBUG - (RBN) Hack to set the service name in the devnode if it
        //      isn't already set.
        //
        //      This probably should be done earlier somewhere else after the
        //      INF is run, but if we don't do it now we'll blow up when we
        //      call IopGetDriverLoadType below.
        //

        if (Context->DeviceNode->ServiceName.Length == 0) {

            Context->DeviceNode->ServiceName = unicodeServiceName;
            Context->DeviceNode->ServiceName.Buffer = ExAllocatePool( NonPagedPool,
                                                                      unicodeServiceName.MaximumLength );

            if (Context->DeviceNode->ServiceName.Buffer != NULL) {
                RtlCopyMemory( Context->DeviceNode->ServiceName.Buffer,
                               unicodeServiceName.Buffer,
                               unicodeServiceName.MaximumLength );
            } else {
                PiWstrToUnicodeString( &Context->DeviceNode->ServiceName, NULL );

                IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                                "PipCallDriverAddDevice:\t\t\tCannot allocate memory for service name in devnode\n"));

                status = STATUS_UNSUCCESSFUL;

                goto Cleanup;
            }
        }

        //
        // Check in the registry to find the name of the driver object
        // for this device.
        //
        status = PipOpenServiceEnumKeys(&unicodeServiceName,
                                        KEY_READ,
                                        &serviceKey,
                                        NULL,
                                        FALSE);

        if (!NT_SUCCESS(status)) {

            //
            // Cannot open the service key for this driver.  This is a
            // fatal error.
            //

            IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                            "PipCallDriverAddDevice:\t\t\tStatus %#08lx "
                            "opening service key\n",
                            status));

            PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_REGISTRY);

            goto Cleanup;
        }

        status = IopGetDriverNameFromKeyNode(serviceKey, &unicodeDriverName);

        if (!NT_SUCCESS(status)) {

            //
            // Can't get the driver name from the service key.  This is a
            // fatal error.
            //

            IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                            "PipCallDriverAddDevice:\t\t\tStatus %#08lx "
                            "getting driver name\n",
                            status));

            PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_REGISTRY);
            goto Cleanup;

        } else {

            freeDriverName = TRUE;
        }

        //
        // Note that we don't close the service key here. We may need it later.
        //
    }

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipCallDriverAddDevice:\t\t\tDriverName is %wZ\n",
                    &unicodeDriverName));

    driverObject = IopReferenceDriverObjectByName(&unicodeDriverName);

    if (driverObject == NULL) {

        //
        // We couldn't find a driver object.  It's possible the driver isn't
        // loaded & initialized so check to see if we can try to load it
        // now.
        //
        if (madeupService) {

            //
            // The madeup service's driver doesn't seem to exist yet.
            // We will fail the request without setting a problem code so
            // we will try it again later.  (Root Enumerated devices...)
            //
            IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                            "PipCallDriverAddDevice:\t\t\tCannot find driver "
                            "object for madeup service\n"));

            status = STATUS_UNSUCCESSFUL;

            goto Cleanup;
        }

        //
        // Get the start type. We always need this in case the service is
        // disabled. Default to SERVICE_DISABLED if the service's start type
        // is missing or corrupted.
        //
        loadType = SERVICE_DISABLED;

        status = IopGetRegistryValue(serviceKey, L"Start", &keyValueInformation);
        if (NT_SUCCESS(status)) {
            if (keyValueInformation->Type == REG_DWORD) {
                if (keyValueInformation->DataLength == sizeof(ULONG)) {
                    loadType = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                }
            }
            ExFreePool(keyValueInformation);
        }

        if (ServiceType != DeviceService && !PnPBootDriversInitialized) {

            //
            // Get the group index. We need this because PipLoadBootFilterDriver
            // uses the group index as an index into it's internally sorted
            // list of loaded boot drivers.
            //
            groupIndex = PpInitGetGroupOrderIndex(serviceKey);

            //
            // If we are in BootDriverInitialization phase and trying to load a
            // filter driver
            //
            status = PipLoadBootFilterDriver(
                &unicodeDriverName,
                groupIndex,
                &driverObject
                );

            if (NT_SUCCESS(status)) {

                ASSERT(driverObject);
#if DBG
                tempDrvObj = IopReferenceDriverObjectByName(&unicodeDriverName);
                ASSERT(tempDrvObj == driverObject);
#else
                ObReferenceObject(driverObject);
#endif
            } else if (status != STATUS_DRIVER_BLOCKED &&
                       status != STATUS_DRIVER_BLOCKED_CRITICAL) {

                goto Cleanup;
            }

        } else {

            if (!Context->LoadDriver) {

                //
                // We're not supposed to try and load a driver - most likely our
                // disk drivers aren't initialized yet.  We need to stop the add
                // process but we can't mark the devnode as failed or we won't
                // be called again when we can load the drivers.
                //

                IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                                "PipCallDriverAddDevice:\t\t\tNot allowed to load "
                                "drivers yet\n"));

                status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }

            if (loadType > Context->AddContext->DriverStartType) {

                if (loadType == SERVICE_DISABLED &&
                    !PipDoesDevNodeHaveProblem(Context->DeviceNode)) {
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DISABLED_SERVICE);
                }

                //
                // The service is either disabled or we are not at the right
                // time to load it.  Don't load it, but make sure we can get
                // called again.  If a service is marked as demand start, we
                // always load it.
                //

                IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                                "PipCallDriverAddDevice:\t\t\tService is disabled or not at right time to load it\n"));
                status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }

            //
            // Check in the registry to find the name of the driver object
            // for this device.
            //
            status = PipOpenServiceEnumKeys(&unicodeServiceName,
                                            KEY_READ,
                                            &handle,
                                            NULL,
                                            FALSE);

            if (!NT_SUCCESS(status)) {

                //
                // Cannot open the service key for this driver.  This is a
                // fatal error.
                //
                IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                                "PipCallDriverAddDevice:\t\t\tStatus %#08lx "
                                "opening service key\n",
                                status));

                //
                // Convert the status values into something more definite.
                //
                if (status != STATUS_INSUFFICIENT_RESOURCES) {

                    status = STATUS_ILL_FORMED_SERVICE_ENTRY;
                }

            } else {

                //
                // The handle we pass in here will be closed by IopLoadDriver.
                // Note that IopLoadDriver return success without actually
                // loading the driver. This happens in the safe mode boot case.
                //
                status = IopLoadDriver(
                    handle,
                    FALSE,
                    (ServiceType != DeviceService)? TRUE : FALSE,
                    &driverEntryStatus);

                //
                // Convert the status values into something more definite.
                //
                if (!NT_SUCCESS(status)) {

                    if (status == STATUS_FAILED_DRIVER_ENTRY) {

                        //
                        // Preserve insufficient resources return by the driver
                        //
                        if (driverEntryStatus == STATUS_INSUFFICIENT_RESOURCES) {

                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }

                    } else if ((status != STATUS_INSUFFICIENT_RESOURCES) &&
                               (status != STATUS_PLUGPLAY_NO_DEVICE) &&
                               (status != STATUS_DRIVER_FAILED_PRIOR_UNLOAD) &&
                               (status != STATUS_DRIVER_BLOCKED) &&
                               (status != STATUS_DRIVER_BLOCKED_CRITICAL)) {

                        //
                        // Assume this happened because the driver could not be
                        // loaded.
                        //
                        status = STATUS_DRIVER_UNABLE_TO_LOAD;
                    }
                }

                if (PnPInitialized) {

                    IopCallDriverReinitializationRoutines();
                }
            }
            //
            // Try and get a pointer to the driver object for the service.
            //
            driverObject = IopReferenceDriverObjectByName(&unicodeDriverName);
            if (driverObject) {

                if (!NT_SUCCESS(status)) {
                    //
                    // The driver should not be in memory upon failure.
                    //
                    ASSERT(!driverObject);
                    ObDereferenceObject(driverObject);
                    driverObject = NULL;
                }
            } else {

                if (NT_SUCCESS(status)) {
                    //
                    // Driver was probably not loaded because of safe mode.
                    //
                    ASSERT(InitSafeBootMode);
                    status = STATUS_NOT_SAFE_MODE_DRIVER;
                }
            }
        }
    }
    //
    // If we still dont have a driver object, then something failed.
    //
    if (driverObject == NULL) {
        //
        // Apparently the load didn't work out very well.
        //
        ASSERT(!NT_SUCCESS(status));
        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PipCallDriverAddDevice:\t\t\tUnable to reference "
                     "driver %wZ (%x)\n", &unicodeDriverName, status));
        if (!PipDoesDevNodeHaveProblem(Context->DeviceNode)) {

            switch(status) {

                case STATUS_ILL_FORMED_SERVICE_ENTRY:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DRIVER_SERVICE_KEY_INVALID);
                    break;

                case STATUS_INSUFFICIENT_RESOURCES:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_OUT_OF_MEMORY);
                    break;

                case STATUS_PLUGPLAY_NO_DEVICE:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_LEGACY_SERVICE_NO_DEVICES);
                    break;

                case STATUS_DRIVER_FAILED_PRIOR_UNLOAD:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD);
                    break;

                case STATUS_DRIVER_UNABLE_TO_LOAD:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DRIVER_FAILED_LOAD);
                    break;

                case STATUS_FAILED_DRIVER_ENTRY:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_FAILED_DRIVER_ENTRY);
                    break;

                case STATUS_DRIVER_BLOCKED_CRITICAL:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DRIVER_BLOCKED);
                    Context->DeviceNode->Flags |= DNF_DRIVER_BLOCKED;
                    break;

                case STATUS_DRIVER_BLOCKED:
                    Context->DeviceNode->Flags |= DNF_DRIVER_BLOCKED;
                    status = STATUS_SUCCESS;
                    break;

                default:
                case STATUS_NOT_SAFE_MODE_DRIVER:
                    ASSERT(0);
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_FAILED_ADD);
                    break;
            }

            SAVE_FAILURE_INFO(Context->DeviceNode, status);

        } else {

            //
            // We're very curious - when does this happen?
            //
            ASSERT(0);
        }
        goto Cleanup;
    }

    if (!(driverObject->Flags & DRVO_INITIALIZED)) {
        ObDereferenceObject(driverObject);
        status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                    "PipCallDriverAddDevice:\t\t\tDriver Reference %#08lx\n",
                    driverObject));

    //
    // Check to see if the driver is a legacy driver rather than a Pnp one.
    //
    if (IopIsLegacyDriver(driverObject)) {

        //
        // It is.  Since the legacy driver may have already obtained a
        // handle to the device object, we need to assume this device
        // has been added and started.
        //

        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice:\t\t\tDriver is a legacy "
                        "driver\n"));

        if (ServiceType == DeviceService) {
            Context->DeviceNode->Flags |= DNF_LEGACY_DRIVER;

            PipSetDevNodeState(Context->DeviceNode, DeviceNodeStarted, NULL);

            status = STATUS_UNSUCCESSFUL;
        } else {

            //
            // We allow someone to plug in a legacy driver as a filter driver.
            // In this case, the legacy driver will be loaded but will not be part
            // of our pnp driver stack.
            //

            status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // There's a chance the driver detected this PDO during it's driver entry
    // routine.  If it did then just bail out.
    //
    if (Context->DeviceNode->State != DeviceNodeInitialized &&
        Context->DeviceNode->State != DeviceNodeDriversAdded) {

        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice\t\t\tDevNode was reported "
                        "as detected during driver entry\n"));
        status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Add the driver to the list.
    //

    {
        PDRIVER_LIST_ENTRY listEntry;
        PDRIVER_LIST_ENTRY *runner = &(Context->DriverLists[ServiceType]);

        status = STATUS_SUCCESS;

        //
        // Allocate a new list entry to queue this driver object for the caller
        //

        listEntry = ExAllocatePool(PagedPool, sizeof(DRIVER_LIST_ENTRY));

        if (listEntry == NULL) {

            IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                            "PipCallDriverAddDevice:\t\t\tUnable to allocate list "
                            "entry\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        listEntry->DriverObject = driverObject;
        listEntry->NextEntry = NULL;

        while(*runner != NULL) {
            runner = &((*runner)->NextEntry);
        }

        *runner = listEntry;
    }

Cleanup:

    if (serviceKey) {

        ZwClose(serviceKey);
    }

    if (freeDriverName) {
        RtlFreeUnicodeString(&unicodeDriverName);
    }
    return status;
}

NTSTATUS
PiRestartDevice(
    IN PPI_DEVICE_REQUEST  Request
    )
{
    ADD_CONTEXT addContext;
    NTSTATUS status;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;

    } else if (PipDoesDevNodeHaveProblem(deviceNode)) {

        return STATUS_UNSUCCESSFUL;
    }

    switch(deviceNode->State) {

        case DeviceNodeStartPending:
            //
            // Not wired up today, but if the device is starting then we should
            // in theory defer completing this request until the IRP is
            // completed.
            //
            ASSERT(0);

            //
            // Fall through
            //

        case DeviceNodeStarted:
        case DeviceNodeQueryStopped:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
        case DeviceNodeEnumeratePending:
            return STATUS_SUCCESS;

        case DeviceNodeInitialized:

            //
            // ISSUE - 2000/08/23 - AdriaO: Question,
            //     When this happens, isn't it a bug in user mode?
            //
            // Anyway, fall on through...
            //
            //ASSERT(0);

        case DeviceNodeRemoved:
            ASSERT(!(deviceNode->UserFlags & DNUF_WILL_BE_REMOVED));
            IopRestartDeviceNode(deviceNode);
            break;

        case DeviceNodeUninitialized:
        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
            //
            // ISSUE - 2000/08/23 - AdriaO: Question,
            //     When this happens, isn't it a bug in user mode?
            //
            //ASSERT(0);
            break;

        case DeviceNodeAwaitingQueuedDeletion:
        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeQueryRemoved:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeDeletePendingCloses:
            return STATUS_UNSUCCESSFUL;

        case DeviceNodeDeleted:
        case DeviceNodeUnspecified:
        default:
            ASSERT(0);
            return STATUS_UNSUCCESSFUL;
    }

    if (Request->RequestType == StartDevice) {

        addContext.DriverStartType = SERVICE_DEMAND_START;

        ObReferenceObject(deviceNode->PhysicalDeviceObject);
        status = PipProcessDevNodeTree(
            deviceNode,
            PnPBootDriversInitialized,          // LoadDriver
            FALSE,                              // ReallocateResources
            EnumTypeNone,
            Request->CompletionEvent != NULL,   // Synchronous
            FALSE,
            &addContext,
            Request);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PipQueryDeviceCapabilities(
    IN PDEVICE_NODE DeviceNode,
    OUT PDEVICE_CAPABILITIES Capabilities
    )

/*++

Routine Description:

    This routine will issue an irp to the DeviceObject to retrieve the
    pnp device capabilities.
    Should only be called twice - first from PipProcessNewDeviceNode,
    and second from IopQueryAndSaveDeviceNodeCapabilities, called after
    device is started. If you consider calling this device, see if
    DeviceNode->CapabilityFlags does what you need instead (accessed
    via IopDeviceNodeFlagsToCapabilities(...).

Arguments:

    DeviceNode - the device object the request should be sent to.

    Capabilities - a capabilities structure to be filled in by the driver.

Return Value:

    status

--*/

{
    IO_STACK_LOCATION irpStack;

    NTSTATUS status;

    //
    // Initialize the capabilities structure.
    //

    RtlZeroMemory(Capabilities, sizeof(DEVICE_CAPABILITIES));
    Capabilities->Size = sizeof(DEVICE_CAPABILITIES);
    Capabilities->Version = 1;
    Capabilities->Address = Capabilities->UINumber = (ULONG)-1;

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpStack, sizeof(IO_STACK_LOCATION));

    //
    // Query the device's capabilities
    //

    irpStack.MajorFunction = IRP_MJ_PNP;
    irpStack.MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpStack.Parameters.DeviceCapabilities.Capabilities = Capabilities;

    status = IopSynchronousCall(DeviceNode->PhysicalDeviceObject,
                                &irpStack,
                                NULL);

    ASSERT(status != STATUS_PENDING);

    return status;
}

NTSTATUS
PipMakeGloballyUniqueId(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PWCHAR           UniqueId,
    OUT PWCHAR         *GloballyUniqueId
    )
{
    NTSTATUS status;
    ULONG length;
    PWSTR id, Prefix = NULL;
    HANDLE enumKey;
    HANDLE instanceKey;
    UCHAR keyBuffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION keyValue, stringValueBuffer = NULL;
    UNICODE_STRING valueName;
    ULONG uniqueIdValue, Hash, hashInstance;
    PDEVICE_NODE parentNode;

    PAGED_CODE();

    id = NULL;

    //
    // We need to build an instance id to uniquely identify this
    // device.  We will accomplish this by producing a prefix that will be
    // prepended to the non-unique device id supplied.
    //

    //
    // To 'unique-ify' the child's instance ID, we will retrieve
    // the unique "UniqueParentID" number that has been assigned
    // to the parent and use it to construct a prefix.  This is
    // the legacy mechanism supported here so that existing device
    // settings are not lost on upgrade.
    //

    PiLockPnpRegistry(FALSE);

    parentNode = ((PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode)->Parent;

    status = IopOpenRegistryKeyEx( &enumKey,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ | KEY_WRITE
                                   );

    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipMakeGloballyUniqueId:\tUnable to open HKLM\\SYSTEM\\CCS\\ENUM (status %08lx)\n",
                        status));
        goto clean0;
    }

    //
    // Open the instance key for this devnode
    //
    status = IopOpenRegistryKeyEx( &instanceKey,
                                   enumKey,
                                   &parentNode->InstancePath,
                                   KEY_READ | KEY_WRITE
                                   );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipMakeGloballyUniqueId:\tUnable to open registry key for %wZ (status %08lx)\n",
                        &parentNode->InstancePath,
                        status));
        goto clean1;
    }

    //
    // Attempt to retrieve the "UniqueParentID" value from the device
    // instance key.
    //
    keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)keyBuffer;
    PiWstrToUnicodeString(&valueName, REGSTR_VALUE_UNIQUE_PARENT_ID);

    status = ZwQueryValueKey(instanceKey,
                             &valueName,
                             KeyValuePartialInformation,
                             keyValue,
                             sizeof(keyBuffer),
                             &length
                             );

    if (NT_SUCCESS(status)) {
        ASSERT(keyValue->Type == REG_DWORD);
        ASSERT(keyValue->DataLength == sizeof(ULONG));
        if ((keyValue->Type != REG_DWORD) ||
            (keyValue->DataLength != sizeof(ULONG))) {
            status = STATUS_INVALID_PARAMETER;
            goto clean2;
        }

        uniqueIdValue = *(PULONG)(keyValue->Data);

        //
        // OK, we have a unique parent ID number to prefix to the
        // instance ID.
        Prefix = (PWSTR)ExAllocatePool(PagedPool, 9 * sizeof(WCHAR));
        if (!Prefix) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto clean2;
        }
        swprintf(Prefix, L"%x", uniqueIdValue);
    } else {

        //
        // This is the current mechanism for finding existing
        // device instance prefixes and calculating new ones if
        // required.
        //

        //
        // Attempt to retrieve the "ParentIdPrefix" value from the device
        // instance key.
        //

        PiWstrToUnicodeString(&valueName, REGSTR_VALUE_PARENT_ID_PREFIX);
        length = (MAX_PARENT_PREFIX + 1) * sizeof(WCHAR) +
            FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
        stringValueBuffer = ExAllocatePool(PagedPool,
                                           length);
        if (stringValueBuffer) {
            status = ZwQueryValueKey(instanceKey,
                                     &valueName,
                                     KeyValuePartialInformation,
                                     stringValueBuffer,
                                     length,
                                     &length);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto clean2;
        }

        if (NT_SUCCESS(status)) {

            ASSERT(stringValueBuffer->Type == REG_SZ);
            if (stringValueBuffer->Type != REG_SZ) {
                status = STATUS_INVALID_PARAMETER;
                goto clean2;
            }

            //
            // Parent has already been assigned a "ParentIdPrefix".
            //

            Prefix = (PWSTR) ExAllocatePool(PagedPool,
                                            stringValueBuffer->DataLength);
            if (!Prefix)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean2;
            }
            wcscpy(Prefix, (PWSTR) stringValueBuffer->Data);
        }
        else
        {
            //
            // Parent has not been assigned a "ParentIdPrefix".
            // Compute the prefix:
            //    * Compute Hash
            //    * Look for value of the form:
            //        NextParentId.<level>.<hash>:REG_DWORD: <NextInstance>
            //      under CCS\Enum.  If not present, create it.
            //    * Assign the new "ParentIdPrefix" which will be of
            //      of the form:
            //        <level>&<hash>&<instance>
            //

            // Allocate a buffer once for the NextParentId... value
            // and for the prefix.
            length = (ULONG)(max(wcslen(REGSTR_VALUE_NEXT_PARENT_ID) + 2 + 8 + 8,
                         MAX_PARENT_PREFIX) + 1);

            // Device instances are case in-sensitive.  Upcase before
            // performing hash to ensure that the hash is case-insensitve.
            status = RtlUpcaseUnicodeString(&valueName,
                                            &parentNode->InstancePath,
                                            TRUE);
            if (!NT_SUCCESS(status))
            {
                goto clean2;
            }
            HASH_UNICODE_STRING(&valueName, &Hash);
            RtlFreeUnicodeString(&valueName);

            Prefix = (PWSTR) ExAllocatePool(PagedPool,
                                            length * sizeof(WCHAR));
            if (!Prefix) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean2;
            }

            // Check for existence of "NextParentId...." value and update.
            swprintf(Prefix, L"%s.%x.%x", REGSTR_VALUE_NEXT_PARENT_ID,
                     Hash, parentNode->Level);
            RtlInitUnicodeString(&valueName, Prefix);
            keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)keyBuffer;
            status = ZwQueryValueKey(enumKey,
                                     &valueName,
                                     KeyValuePartialInformation,
                                     keyValue,
                                     sizeof(keyBuffer),
                                     &length
                                     );
            if (NT_SUCCESS(status) && (keyValue->Type == REG_DWORD) &&
                (keyValue->DataLength == sizeof(ULONG))) {
                hashInstance = *(PULONG)(keyValue->Data);
            }
            else {
                hashInstance = 0;
            }

            hashInstance++;

            status = ZwSetValueKey(enumKey,
                                   &valueName,
                                   TITLE_INDEX_VALUE,
                                   REG_DWORD,
                                   &hashInstance,
                                   sizeof(hashInstance)
                                   );

            if (!NT_SUCCESS(status)) {
                goto clean2;
            }

            hashInstance--;

            // Create actual ParentIdPrefix string
            PiWstrToUnicodeString(&valueName, REGSTR_VALUE_PARENT_ID_PREFIX);
            length = swprintf(Prefix, L"%x&%x&%x", parentNode->Level,
                     Hash, hashInstance) + 1;
            status = ZwSetValueKey(instanceKey,
                                   &valueName,
                                   TITLE_INDEX_VALUE,
                                   REG_SZ,
                                   Prefix,
                                   length * sizeof(WCHAR)
                                   );
            if (!NT_SUCCESS(status))
            {
                goto clean2;
            }
        }
    }

    // Construct the instance id from the non-unique id (if any)
    // provided by the child and the prefix we've constructed.
    length = (ULONG)(wcslen(Prefix) + (UniqueId ? wcslen(UniqueId) : 0) + 2);
    id = (PWSTR)ExAllocatePool(PagedPool, length * sizeof(WCHAR));
    if (!id) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    } else if (UniqueId) {
        swprintf(id, L"%s&%s", Prefix, UniqueId);
    } else {
        wcscpy(id, Prefix);
    }

clean2:
    ZwClose(instanceKey);

clean1:
    ZwClose(enumKey);

clean0:
    PiUnlockPnpRegistry();

    if (stringValueBuffer) {
        ExFreePool(stringValueBuffer);
    }

    if (Prefix) {
        ExFreePool(Prefix);
    }

    *GloballyUniqueId = id;
    return status;
}

BOOLEAN
PipProcessCriticalDevice(
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine will check whether the device is a "critical" one (see the
    top of this file for a description of critical).  If the device is critical
    then it will be assigned a service based on the contents of
    IopCriticalDeviceList.

Arguments:

    DeviceNode - the device node to process

Return Value:

    TRUE if the device is critical
    FALSE otherwise

--*/

{
    HANDLE enumKey;
    HANDLE instanceKey;

    UNICODE_STRING service, classGuid, driver, lowerFilters, upperFilters;
    UNICODE_STRING serviceValue, guidValue, driverValue, lowerFiltersValue, upperFiltersValue;
    BOOLEAN foundMatch = FALSE;

    NTSTATUS status;

#if DBG_SCOPE
    PWCHAR str;
    ULONG length;
#endif

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipIsCriticalPnpDevice called for devnode %#08lx\n", DeviceNode));

    //
    // Open the HKLM\System\CCS\Enum key.
    //
    status = IopOpenRegistryKeyEx( &enumKey,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );
    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipIsCriticalPnpDevice: couldn't open enum key %#08lx\n", status));
        return FALSE;
    }

    //
    // Open the instance key for this devnode
    //
    status = IopOpenRegistryKeyEx( &instanceKey,
                                   enumKey,
                                   &DeviceNode->InstancePath,
                                   KEY_ALL_ACCESS
                                   );
    ZwClose(enumKey);

    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipIsCriticalPnpDevice: couldn't open instance path key %wZ [%#08lx]\n",
                        &(DeviceNode->InstancePath), status));
        return FALSE;
    }

    //
    // Call IopProcessCriticalDeviceRoutine to
    // enumerate entries in the CriticalDeviceDatabase
    // and compare with HardwareId and CompatibleIds
    // value data from instanceKey.
    //
    PiWstrToUnicodeString(&service, NULL);
    PiWstrToUnicodeString(&classGuid, NULL);
    PiWstrToUnicodeString(&driver, NULL);
    PiWstrToUnicodeString(&lowerFilters, NULL);
    PiWstrToUnicodeString(&upperFilters, NULL);
    status = PipProcessCriticalDeviceRoutine(instanceKey,
                                             &foundMatch,
                                             &service,
                                             &classGuid,
                                             &driver,
                                             &lowerFilters,
                                             &upperFilters);
    if (!NT_SUCCESS(status) || !foundMatch) {
        IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                        "PipProcessCriticalDevice: No match found for devnode %wZ [%#08lx]\n",
                        &DeviceNode->InstancePath, status));
        ZwClose(instanceKey);
        return FALSE;
    }

    //
    // If we get here then this is a "critical" device and we know the service
    // to setup for it.  Set the service value in the registry.
    //

    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                    "PipProcessCriticalDevice: Setting up critical service\n"));

    PiWstrToUnicodeString(&serviceValue, REGSTR_VALUE_SERVICE);
    PiWstrToUnicodeString(&guidValue, REGSTR_VALUE_CLASSGUID);
    PiWstrToUnicodeString(&driverValue, REGSTR_VALUE_DRIVER);
    PiWstrToUnicodeString(&lowerFiltersValue, REGSTR_VALUE_LOWERFILTERS);
    PiWstrToUnicodeString(&upperFiltersValue, REGSTR_VALUE_UPPERFILTERS);

    if (classGuid.Buffer) {

        IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                        "PipProcessCriticalDevice: classGuid is %wZ\n",
                        &classGuid));

        status = ZwSetValueKey(instanceKey,
                               &guidValue,
                               0L,
                               REG_SZ,
                               classGuid.Buffer,
                               classGuid.Length + sizeof(UNICODE_NULL));
    }

    if (driver.Buffer) {
        IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                        "PipProcessCriticalDevice: driver is %wZ\n",
                        &driver));

        status = ZwSetValueKey(instanceKey,
                               &driverValue,
                               0L,
                               REG_SZ,
                               driver.Buffer,
                               driver.Length + sizeof(UNICODE_NULL));
    }

    if (lowerFilters.Buffer) {
#if DBG_SCOPE
        str = lowerFilters.Buffer;
        while ((length = (ULONG)wcslen(str)) != 0) {
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipProcessCriticalDevice: lower filter is %ws\n",
                            str));
            str += (length + 1);
        }
#endif
        status = ZwSetValueKey(instanceKey,
                               &lowerFiltersValue,
                               0L,
                               REG_MULTI_SZ,
                               lowerFilters.Buffer,
                               lowerFilters.Length); // + sizeof(UNICODE_NULL));
    }

    if (upperFilters.Buffer) {
#if DBG_SCOPE
        str = upperFilters.Buffer;
        while ((length = (ULONG)wcslen(str)) != 0) {
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipProcessCriticalDevice: upper filter is %ws\n",
                            str));
            str += (length + 1);
        }
#endif
        status = ZwSetValueKey(instanceKey,
                               &upperFiltersValue,
                               0L,
                               REG_MULTI_SZ,
                               upperFilters.Buffer,
                               upperFilters.Length); // + sizeof(UNICODE_NULL));
    }

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipProcessCriticalDevice: service is %wZ\n",
                    &service));
    status = ZwSetValueKey(instanceKey,
                           &serviceValue,
                           0L,
                           REG_SZ,
                           service.Buffer,
                           service.Length + sizeof(UNICODE_NULL));

    //
    // If the service was set properly set the CONFIGFLAG_FINISH_INSTALL so
    // we will still get a new hw found popup and go through the class
    // installer.
    //

    if (NT_SUCCESS(status)) {

        UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
        UNICODE_STRING valueName;
        PKEY_VALUE_PARTIAL_INFORMATION keyInfo =
            (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ULONG flags = 0;

        ULONG valueLength;

        NTSTATUS tmpStatus;

        PiWstrToUnicodeString(&valueName, REGSTR_VALUE_CONFIG_FLAGS);

        tmpStatus = ZwQueryValueKey(instanceKey,
                                    &valueName,
                                    KeyValuePartialInformation,
                                    keyInfo,
                                    sizeof(buffer),
                                    &valueLength);

        if (NT_SUCCESS(tmpStatus) && (keyInfo->Type == REG_DWORD)) {

            flags = *(PULONG)keyInfo->Data;
        }

        flags &= ~(CONFIGFLAG_REINSTALL | CONFIGFLAG_FAILEDINSTALL);
        flags |= CONFIGFLAG_FINISH_INSTALL;

        ZwSetValueKey(instanceKey,
                      &valueName,
                      0L,
                      REG_DWORD,
                      &flags,
                      sizeof(ULONG));

        ASSERT(!PipDoesDevNodeHaveProblem(DeviceNode) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_NOT_CONFIGURED) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_FAILED_INSTALL) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_REINSTALL));

        PipClearDevNodeProblem(DeviceNode);
    }
    ZwClose(instanceKey);

    RtlFreeUnicodeString(&service);
    RtlFreeUnicodeString(&classGuid);
    RtlFreeUnicodeString(&driver);
    RtlFreeUnicodeString(&lowerFilters);
    RtlFreeUnicodeString(&upperFilters);

    return (BOOLEAN)NT_SUCCESS(status);
}


NTSTATUS
PipProcessCriticalDeviceRoutine(
    IN  HANDLE HDevInstance,
    IN  PBOOLEAN FoundMatch,
    IN  PUNICODE_STRING ServiceName,
    IN  PUNICODE_STRING ClassGuid,
    IN  PUNICODE_STRING Driver,
    IN  PUNICODE_STRING LowerFilters,
    IN  PUNICODE_STRING UpperFilters
    )

/*++


Routine Description:

    This routine will enumerate all values of the CriticalDeviceDatabase
    registry key, and compare each with entries within
    the HardwareId and CompatibleIds values of key associated
    with the current device instance.

Arguments:

    HDevInstance - HANDLE to device instance.

    FoundMatch   - receives TRUE if a match was found.

    ServiceName  - receives name of service to be assigned to
                   the device instance pointed to by HDevInstance.

    ClassGuid    - receives name of class GUID to be assigned to
                   the device instance pointed to by HDevInstance.

    Driver       - receives name of "class GUID\InstanceID" to be assigned to
                   the device instance pointed to by HDevInstance.

    LowerFilters - receives name of lower filters to be assigned to
                   the device instance pointed to by HDevInstance.

    UpperFilters - receives name of upper filters to be assigned to
                   the device instance pointed to by HDevInstance.

Return Value:

    NTSTATUS code

--*/

{
    NTSTATUS                    status;
    HANDLE                      hRegistryMachine, hCriticalDeviceKey,
                                hCriticalEntry;
    PWSTR                       keyValueInfoTag[2];
    PKEY_VALUE_FULL_INFORMATION keyValueInfo[2];
    BUFFER_INFO                 infoBuffer;
    ULONG                       enumIndex, idIndex, resultSize, stringLength;
    UNICODE_STRING              tmpUnicodeString, unicodeCriticalEntry,
                                unicodeCriticalDeviceKeyName;
    PWCHAR                      stringStart, bufferEnd, ptr, ids;
    PRTL_QUERY_REGISTRY_TABLE   parameters = NULL;

#define INITIAL_INFOBUFFER_SIZE sizeof(KEY_VALUE_FULL_INFORMATION) + 8*sizeof(WCHAR) + 255*sizeof(WCHAR)

    infoBuffer.Buffer = NULL;
    keyValueInfo[0] = NULL;
    keyValueInfo[1] = NULL;
    ids = NULL;

    //
    // Get handle to \REGISTRY\MACHINE registry key.
    //
    status = IopOpenRegistryKeyEx( &hRegistryMachine,
                                   NULL,
                                   &CmRegistryMachineName,
                                   KEY_READ
                                   );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Open CriticalDeviceDatabase registry key to enumerate through.
    //
    // This key contains hardware id's for so called "critical" devices.  These
    // are devices for which, for one reason or another, we cannot wait for
    // config manager to bring them on line.  These are primarily devices which
    // are necessary in order to bring the system up into user mode so that
    // config manager can be run (disks, keyboards, video, etc...)
    //
    PiWstrToUnicodeString(&unicodeCriticalDeviceKeyName, REGSTR_PATH_CRITICALDEVICEDATABASE);
    status = IopOpenRegistryKeyEx( &hCriticalDeviceKey,
                                   hRegistryMachine,
                                   &unicodeCriticalDeviceKeyName,
                                   KEY_READ
                                   );
    //
    // Close handle to \REGISTRY\MACHINE.
    //
    ZwClose(hRegistryMachine);

    //
    // Check success in opening CriticalDeviceDatabase key.
    //
    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipProcessCriticalDeviceRoutine: Unable to open %wZ key, status = %#08lx\n",
                        &unicodeCriticalDeviceKeyName, status));
        return status;
    }

    //
    // Allocate a buffer to store KeyValueFullInformation
    // of values from CriticalDeviceDatabase key.
    //
    status = IopAllocateBuffer( &infoBuffer,
                                INITIAL_INFOBUFFER_SIZE );
    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipProcessCriticalDeviceRoutine: Unable to allocate buffer to hold key values, status = %\n"));
        goto cleanup;
    }

    //
    // Retrieve the HardwareId and CompatibleIds device instance registry key
    // values.
    //
    keyValueInfoTag[0] = REGSTR_VALUE_HARDWAREID;
    keyValueInfoTag[1] = REGSTR_VALUE_COMPATIBLEIDS;

    for (idIndex=0; idIndex < 2; idIndex++) {

        IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                        "PipProcessCriticalDeviceRoutine: Processing %ws entries\n",
                        keyValueInfoTag[idIndex]));

        //
        //  Read Key Value Information from HardwareId and CompatibleIds
        //
        status = IopGetRegistryValue(HDevInstance,
                                     keyValueInfoTag[idIndex],
                                     &keyValueInfo[idIndex]);
        if (!NT_SUCCESS(status)) {

            //
            // Error retrieving the registry value, skip it and move on.
            //
            IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                            "PipProcessCriticalDeviceRoutine: Error retrieving %ws value, status = %#08lx\n",
                            keyValueInfoTag[idIndex], status));
            status = STATUS_SUCCESS;
            continue;

        } else if ((keyValueInfo[idIndex]->Type != REG_MULTI_SZ) ||
                   (keyValueInfo[idIndex]->DataLength == 0)) {

            //
            // The registry value is not valid, skip it and move on.
            //
            ExFreePool(keyValueInfo[idIndex]);
            keyValueInfo[idIndex] = NULL;
            IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                            "PipProcessCriticalDeviceRoutine: Invalid %ws registry value, skipping.\n",
                            keyValueInfoTag[idIndex]));
            continue;

        } else {

            ASSERT(keyValueInfo[idIndex]);

            ids = (PWCHAR)KEY_VALUE_DATA(keyValueInfo[idIndex]);
            //
            // Make sure all of the IDs match '\' replacement policy.
            //
            tmpUnicodeString.Buffer = ids;
            tmpUnicodeString.Length = (USHORT)keyValueInfo[idIndex]->DataLength;
            tmpUnicodeString.MaximumLength = tmpUnicodeString.Length;

            IopReplaceSeperatorWithPound(&tmpUnicodeString,
                                         &tmpUnicodeString);
            //
            // Find start and end of this REG_MULTI_SZ
            //
            ptr = ids;
            stringStart = ptr;
            bufferEnd = (PWCHAR)((PUCHAR)ptr + keyValueInfo[idIndex]->DataLength);

            while(ptr != bufferEnd) {

                if (!*ptr) {

                    //
                    // Found null-terminated end of a single SZ within the MULTI_SZ.
                    //
                    stringLength = (ULONG)((PUCHAR)ptr - (PUCHAR)stringStart);
                    tmpUnicodeString.Buffer = stringStart;
                    tmpUnicodeString.Length = (USHORT)stringLength;
                    tmpUnicodeString.MaximumLength = (USHORT)stringLength  + sizeof(UNICODE_NULL);

                    IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                                    "PipProcessCriticalDeviceRoutine: Searching for %ws entry: %wZ\n",
                                    keyValueInfoTag[idIndex], &tmpUnicodeString));

                    //
                    // Enumerate through Critical Device entries.
                    //
                    // For each CriticalDeviceDatabase value entry compare with all entries of HardwareId
                    // and CompatibleIds REG_MULTI_SZ for a match
                    //
                    enumIndex = 0;
                    while (((status = ZwEnumerateKey( hCriticalDeviceKey,
                                                      enumIndex,
                                                      KeyBasicInformation,
                                                      (PVOID) infoBuffer.Buffer,
                                                      infoBuffer.MaxSize,
                                                      &resultSize)) != STATUS_NO_MORE_ENTRIES)) {
                        if (status == STATUS_BUFFER_OVERFLOW) {
                            //
                            // Buffer allocated to hold value was too small;
                            // resize to specified length, and try again.
                            //
                            IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                                            "PipProcessCriticalDeviceRoutine: Resizing buffer...\n"));
                            status = IopResizeBuffer( &infoBuffer,
                                                      resultSize,
                                                      FALSE );
                            if (!NT_SUCCESS(status)) {
                                //
                                // If we can't resize the buffer to the required
                                // size, we can't do much more.
                                //
                                IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                                "PipProcessCriticalDeviceRoutine: Error resizing buffer, status = %#08lx\n",
                                                status));
                                goto cleanup;
                            }
                            continue;

                        } else if (!NT_SUCCESS(status)) {
                            //
                            // ZwEnumerateKey returned failure status other than
                            // STATUS_NO_MORE_ENTRIES or STATUS_BUFFER_OVERFLOW.
                            //
                            IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                            "PipProcessCriticalDeviceRoutine: Failed to enumerate critical device, status = %#08lx\n",
                                            status));
                            goto cleanup;
                        }

                        //
                        // Store CriticalDeviceDatabase entry in a unicode string to do
                        // case-insensitive comparisons with HardwareId/CompatibleIds entries
                        // from the new device's instance key.
                        //

                        unicodeCriticalEntry.Buffer = ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->Name;
                        unicodeCriticalEntry.Length = (USHORT) ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->NameLength;
                        unicodeCriticalEntry.MaximumLength = unicodeCriticalEntry.Length;

                        IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                                        "PipProcessCriticalDeviceRoutine: \t key (%u) enumerated: %wZ\n",
                                        enumIndex,
                                        &unicodeCriticalEntry));

                        //
                        // Check for a case-insenitive unicode string match.
                        //
                        if (RtlEqualUnicodeString(&tmpUnicodeString,
                                                  &unicodeCriticalEntry,
                                                  TRUE)) {

                            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                                            "PipProcessCriticalDeviceRoutine: ***** Critical Device %wZ: Matched to Device %wZ.\n",
                                            &tmpUnicodeString,
                                            &unicodeCriticalEntry));

                            //
                            // Query registry values of the critical device match.
                            //
                            #define NUM_QUERIES 5
                            status = IopOpenRegistryKeyEx( &hCriticalEntry,
                                                           hCriticalDeviceKey,
                                                           &unicodeCriticalEntry,
                                                           KEY_READ
                                                           );

                            if (!NT_SUCCESS(status)) {
                                goto cleanup;
                            }

                            parameters = (PRTL_QUERY_REGISTRY_TABLE)
                                ExAllocatePool(NonPagedPool,
                                               sizeof(RTL_QUERY_REGISTRY_TABLE)*(NUM_QUERIES+1));

                            if (!parameters) {
                                ZwClose(hCriticalEntry);
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                goto cleanup;
                            }

                            //
                            // RTL_QUERY_REGISTRY_DIRECT uses system provided QueryRoutine.
                            // Look at the DDK documentation for more details on this flag.
                            //
                            RtlZeroMemory(parameters,
                                          sizeof(RTL_QUERY_REGISTRY_TABLE) * (NUM_QUERIES + 1));

                            parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
                            parameters[0].Name = REGSTR_VALUE_SERVICE;
                            parameters[0].EntryContext = ServiceName;
                            parameters[0].DefaultType = REG_SZ;
                            parameters[0].DefaultData = L"";
                            parameters[0].DefaultLength = 0;

                            parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
                            parameters[1].Name = REGSTR_VALUE_CLASSGUID;
                            parameters[1].EntryContext = ClassGuid;
                            parameters[1].DefaultType = REG_SZ;
                            parameters[1].DefaultData = L"";
                            parameters[1].DefaultLength = 0;

                            parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
                            parameters[2].Name = REGSTR_VALUE_LOWERFILTERS;
                            parameters[2].EntryContext = LowerFilters;
                            parameters[2].DefaultType = REG_MULTI_SZ;
                            parameters[2].DefaultData = L"";
                            parameters[2].DefaultLength = 0;

                            parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
                            parameters[3].Name = REGSTR_VALUE_UPPERFILTERS;
                            parameters[3].EntryContext = UpperFilters;
                            parameters[3].DefaultType = REG_MULTI_SZ;
                            parameters[3].DefaultData = L"";
                            parameters[3].DefaultLength = 0;

                            parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
                            parameters[4].Name = REGSTR_VALUE_DRIVER;
                            parameters[4].EntryContext = Driver;
                            parameters[4].DefaultType = REG_SZ;
                            parameters[4].DefaultData = L"";
                            parameters[4].DefaultLength = 0;

                            status = RtlQueryRegistryValues(
                                         RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                         (PWSTR) hCriticalEntry,
                                         parameters,
                                         NULL,
                                         NULL
                                         );

                            ExFreePool(parameters);
                            ZwClose(hCriticalEntry);

                            if (NT_SUCCESS(status)) {
                                //
                                // Sanity check all of the values...
                                // 1)  There is a service name
                                // 2)  If there is a class guid, it is of the proper length
                                //
                                if (ServiceName->Buffer &&
                                    ServiceName->Length &&
                                    ((ClassGuid->Length == 0) || (ClassGuid->Length >= 38*sizeof(WCHAR))) &&
                                    ((Driver->Length == 0) || (Driver->Length >= 38*sizeof(WCHAR)))) {

                                    //
                                    // Caller expects XxxFilters->Buffer == NULL, so make
                                    // the default case look like that
                                    //
                                    if (UpperFilters->Length <= 2 && UpperFilters->Buffer) {
                                        RtlFreeUnicodeString(UpperFilters);
                                    }
                                    if (LowerFilters->Length <= 2 && LowerFilters->Buffer) {
                                        RtlFreeUnicodeString(LowerFilters);
                                    }
                                    if (ClassGuid->Length == 0 && ClassGuid->Buffer) {
                                        RtlFreeUnicodeString(ClassGuid);
                                    }

                                    if (Driver->Length == 0 && Driver->Buffer) {
                                        RtlFreeUnicodeString(Driver);
                                    }

                                    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                                                    "PipProcessCriticalDeviceRoutine: ***** Using ServiceName %wZ.\n",
                                                    ServiceName));

                                    if (ClassGuid->Buffer) {
                                        IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                                                        "PipProcessCriticalDeviceRoutine: ***** Using ClassGuid %wZ.\n",
                                                        ClassGuid));
                                    }

                                    if (Driver->Buffer) {
                                        IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                                                        "PipProcessCriticalDeviceRoutine: ***** Using Driver %wZ.\n",
                                                        Driver));
                                    }

                                    //
                                    // We have a ServiceName match from the
                                    // CriticalDeviceDatabase, so we're done.
                                    //
                                    *FoundMatch = TRUE;
                                    goto cleanup;
                                }

                            } else {
                                //
                                // Just continue searching the database.
                                //
                                status = STATUS_SUCCESS;
                            }

                            //
                            // Free any strings that may have been allocated by
                            // RtlQueryRegistryValues
                            //
                            RtlFreeUnicodeString(ServiceName);
                            RtlFreeUnicodeString(ClassGuid);
                            RtlFreeUnicodeString(Driver);
                            RtlFreeUnicodeString(LowerFilters);
                            RtlFreeUnicodeString(UpperFilters);
                            IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                                            "PipProcessCriticalDeviceRoutine: Found no ServiceName for %wZ\n",
                                            &unicodeCriticalEntry));
                        }

                        //
                        // enumerate next key value.
                        //
                        enumIndex++;
                    }

                    //
                    // See if we're at the end of the MULTI_SZ
                    //
                    if (((ptr + 1) == bufferEnd) || !*(ptr + 1)) {
                        break;
                    } else {
                        stringStart = ptr + 1;
                    }

                }
                //
                // advance to next character.
                //
                ptr++;
            }
            ids = NULL;
        }
    }

    //
    // No match with a ServiceName was found.
    //
    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipProcessCriticalDeviceRoutine: No match found for this device.\n"));
    *FoundMatch = FALSE;
    status = STATUS_SUCCESS;

cleanup:
    if (infoBuffer.Buffer) {
        IopFreeBuffer(&infoBuffer);
    }
    if (hCriticalDeviceKey) {
        ZwClose(hCriticalDeviceKey);
    }
    if (keyValueInfo[0]) {
        ExFreePool(keyValueInfo[0]);
    }
    if (keyValueInfo[1]) {
        ExFreePool(keyValueInfo[1]);
    }
    return status;
}

BOOLEAN
PipGetRegistryDwordWithFallback(
    IN     PUNICODE_STRING valueName,
    IN     HANDLE PrimaryKey,
    IN     HANDLE SecondaryKey,
    IN OUT PULONG Value
    )
/*++

Routine Description:

    If
        (1) Primary key has a value named "ValueName" that is REG_DWORD, return it
    Else If
        (2) Secondary key has a value named "ValueName" that is REG_DWORD, return it
    Else
        (3) Leave Value untouched and return error

Arguments:

    ValueName          - Unicode name of value to query
    PrimaryKey         - If non-null, check this first
    SecondaryKey       - If non-null, check this second
    Value              - IN = default value, OUT = actual value

Return Value:

    TRUE if value found

--*/
{
    PKEY_VALUE_FULL_INFORMATION info;
    PUCHAR data;
    NTSTATUS status;
    HANDLE Keys[3];
    int count = 0;
    int index;
    BOOLEAN set = FALSE;

    if (PrimaryKey != NULL) {
        Keys[count++] = PrimaryKey;
    }
    if (SecondaryKey != NULL) {
        Keys[count++] = SecondaryKey;
    }
    Keys[count] = NULL;

    for (index = 0; index < count && !set; index ++) {
        info = NULL;
        try {
            status = IopGetRegistryValue(Keys[index],
                                         valueName->Buffer,
                                         &info);
            if (NT_SUCCESS(status) && info->Type == REG_DWORD) {
                data = ((PUCHAR) info) + info->DataOffset;
                *Value = *((PULONG) data);
                set = TRUE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // do nothing
            //
        }
        if (info) {
            ExFreePool(info);
        }
    }
    return set;
}

PSECURITY_DESCRIPTOR
PipGetRegistrySecurityWithFallback(
    IN     PUNICODE_STRING valueName,
    IN     HANDLE PrimaryKey,
    IN     HANDLE SecondaryKey
    )
/*++

Routine Description:

    If
        (1) Primary key has a binary value named "ValueName" that is
        REG_BINARY and appears to be a valid security descriptor, return it
    Else
        (2) do same for Secondary key
    Else
        (3) Return NULL

Arguments:

    ValueName          - Unicode name of value to query
    PrimaryKey         - If non-null, check this first
    SecondaryKey       - If non-null, check this second

Return Value:

    Security Descriptor if found, else NULL

--*/
{
    PKEY_VALUE_FULL_INFORMATION info;
    PUCHAR data;
    NTSTATUS status;
    HANDLE Keys[3];
    int count = 0;
    int index;
    BOOLEAN set = FALSE;
    PSECURITY_DESCRIPTOR secDesc = NULL;
    PSECURITY_DESCRIPTOR allocDesc = NULL;

    if (PrimaryKey != NULL) {
        Keys[count++] = PrimaryKey;
    }
    if (SecondaryKey != NULL) {
        Keys[count++] = SecondaryKey;
    }
    Keys[count] = NULL;

    for (index = 0; index < count && !set; index ++) {
        info = NULL;
        try {
            status = IopGetRegistryValue(Keys[index],
                                         valueName->Buffer,
                                         &info);
            if (NT_SUCCESS(status) && info->Type == REG_BINARY) {
                data = ((PUCHAR) info) + info->DataOffset;
                secDesc = (PSECURITY_DESCRIPTOR)data;
                /*if (SeValidSecurityDescriptor( SECURITY_DESCRIPTOR_MIN_LENGTH,
                                               secDesc)) {*/
                    status = SeCaptureSecurityDescriptor(secDesc,
                                                 KernelMode,
                                                 PagedPool,
                                                 TRUE,
                                                 &allocDesc);
                    if (NT_SUCCESS(status)) {
                        set = TRUE;
                    }
                /*} else {
                    //
                    // Perhaps this happened due to a corrupted registry entry?
                    //
                    IopDbgPrint(( IOP_ENUMERATION_ERROR_LEVEL,
                                  "PipChangeDeviceObjectFromRegistryProperties: Security descriptor not valid!\n"));
                    ASSERT(0);
                }*/
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // do nothing
            //
        }
        if (info) {
            ExFreePool(info);
        }
    }
    if (set) {
        return allocDesc;
    }
    return NULL;
}

NTSTATUS
PipChangeDeviceObjectFromRegistryProperties(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN HANDLE DeviceClassPropKey,
    IN HANDLE DevicePropKey,
    IN BOOLEAN UsePdoCharacteristics
    )
/*++

Routine Description:

    This routine will obtain settings from either
    (1) DevNode settings (via DevicePropKey) or
    (2) Class settings (via DeviceClassPropKey)
    applying to PDO and all attached device objects

    Properties set/ changed are:

        * DeviceType - the I/O system type for the device object
        * DeviceCharacteristics - the I/O system characteristic flags to be
                                  set for the device object
        * Exclusive - the device can only be accessed exclusively
        * Security - security for the device

    The routine will then use the DeviceType and DeviceCharacteristics specified
    to determine whether a VPB should be allocated as well as to set default
    security if none is specified in the registry.

Arguments:

    PhysicalDeviceObject - the PDO we are to configure

    DeviceClassPropKey - a handle to Control\<Class>\Properties protected key
    DevicePropKey      - a handle to Enum\<Instance>  protected key

Return Value:

    status

--*/
{
    UNICODE_STRING valueName;
    NTSTATUS status;

    BOOLEAN deviceTypeSpec = FALSE;
    BOOLEAN characteristicsSpec = FALSE;
    BOOLEAN exclusiveSpec = FALSE;
    BOOLEAN securityForce = FALSE;
    UCHAR buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    SECURITY_INFORMATION securityInformation = 0;

    PSECURITY_DESCRIPTOR securityDescriptor = NULL;
    PACL allocatedAcl = NULL;
    ULONG deviceType = 0;
    ULONG characteristics = 0;
    ULONG exclusive = 0;
    ULONG prevCharacteristics = 0;
    PDEVICE_OBJECT StackIterator = NULL;
    PDEVICE_NODE deviceNode = NULL;

    ASSERT(PhysicalDeviceObject);
    deviceNode = PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);

    IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                    "PipChangeDeviceObjectFromRegistryProperties: Modifying device stack for PDO: %08x\n",PhysicalDeviceObject));

    //
    // Iterate through all device objects to get our starting settings (OR everyone together)
    // generally, a PDO should take on the characteristics of whoever is above the PDO, and not used in the equation
    // the exception being if it's being used RAW
    // we detect this by absense of service name, or it's the only Device Object.
    //
    StackIterator = PhysicalDeviceObject;
    if (UsePdoCharacteristics || StackIterator->AttachedDevice == NULL) {
        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipChangeDeviceObjectFromRegistryProperties: Assuming PDO is being used RAW\n"));
    } else {
        StackIterator = StackIterator->AttachedDevice;
        IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                        "PipChangeDeviceObjectFromRegistryProperties: Ignoring PDO's settings\n"));
    }
    //
    // we can't propagate DO_EXCLUSIVE, since it happens to break some devices (eg, Serial)
    // but we do propagage certain characteristics flags
    //
    for ( ; StackIterator != NULL; StackIterator = StackIterator->AttachedDevice) {
        prevCharacteristics |= StackIterator->Characteristics;
    }

    //
    // 1) Get Device type, DevicePropKey preferred over DeviceClassPropKey
    //
    PiWstrToUnicodeString(&valueName, REGSTR_VAL_DEVICE_TYPE);
    deviceTypeSpec = PipGetRegistryDwordWithFallback(&valueName,DevicePropKey,DeviceClassPropKey,&deviceType);
    PiWstrToUnicodeString(&valueName, REGSTR_VAL_DEVICE_CHARACTERISTICS);
    characteristicsSpec = PipGetRegistryDwordWithFallback(&valueName,DevicePropKey,DeviceClassPropKey,&characteristics);
    PiWstrToUnicodeString(&valueName, REGSTR_VAL_DEVICE_EXCLUSIVE);
    exclusiveSpec = PipGetRegistryDwordWithFallback(&valueName,DevicePropKey,DeviceClassPropKey,&exclusive);

    if (!characteristicsSpec) {
        characteristics = 0;
    }
    characteristics = (characteristics | prevCharacteristics) & FILE_CHARACTERISTICS_PROPAGATED; // mask only applicable characteristics

    PiWstrToUnicodeString(&valueName, REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR);
    securityDescriptor = PipGetRegistrySecurityWithFallback(&valueName,DevicePropKey,DeviceClassPropKey);

    if (securityDescriptor == NULL) {
        //
        // determine if we should create internal default
        //
        if (deviceTypeSpec) {
            BOOLEAN hasName = (PhysicalDeviceObject->Flags & DO_DEVICE_HAS_NAME) ? TRUE : FALSE;

            securityDescriptor = IopCreateDefaultDeviceSecurityDescriptor(
                                    (DEVICE_TYPE)deviceType,
                                    characteristics,
                                    hasName,
                                    &buffer[0],
                                    &allocatedAcl,
                                    &securityInformation
                                    );
            if (securityDescriptor) {
                securityForce = TRUE; // forced default security descriptor
            } else {
                IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                "PipChangeDeviceObjectFromRegistryProperties: Was not able to get default security descriptor\n"));
            }
        }
    } else {
        //
        // further process the security information we're given to set "securityInformation"
        //
        PSID sid;
        PACL acl;
        BOOLEAN present, tmp;

        securityInformation = 0;

        //
        // See what information is in the captured descriptor so we can build
        // up a securityInformation block to go with it.
        //

        status = RtlGetOwnerSecurityDescriptor(securityDescriptor, &sid, &tmp);

        if (NT_SUCCESS(status) && (sid != NULL)) {
            securityInformation |= OWNER_SECURITY_INFORMATION;
        }

        status = RtlGetGroupSecurityDescriptor(securityDescriptor, &sid, &tmp);

        if (NT_SUCCESS(status) && (sid != NULL)) {
            securityInformation |= GROUP_SECURITY_INFORMATION;
        }

        status = RtlGetSaclSecurityDescriptor(securityDescriptor,
                                              &present,
                                              &acl,
                                              &tmp);

        if (NT_SUCCESS(status) && (present)) {
            securityInformation |= SACL_SECURITY_INFORMATION;
        }

        status = RtlGetDaclSecurityDescriptor(securityDescriptor,
                                              &present,
                                              &acl,
                                              &tmp);

        if (NT_SUCCESS(status) && (present)) {
            securityInformation |= DACL_SECURITY_INFORMATION;
        }

    }

#if DBG
    if (deviceTypeSpec == FALSE && characteristicsSpec == FALSE && exclusiveSpec == FALSE && securityDescriptor == NULL) {
        IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                        "PipChangeDeviceObjectFromRegistryProperties: No property changes\n"));
    } else {
        if (deviceTypeSpec) {
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipChangeDeviceObjectFromRegistryProperties: Overide DeviceType=%08x\n",
                            deviceType));
        }
        if (characteristicsSpec) {
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipChangeDeviceObjectFromRegistryProperties: Overide DeviceCharacteristics=%08x\n",
                            characteristics));
        }
        if (exclusiveSpec) {
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipChangeDeviceObjectFromRegistryProperties: Overide Exclusive=%d\n",(exclusive?1:0)));
        }
        if (securityForce) {
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipChangeDeviceObjectFromRegistryProperties: Overide Security based on DeviceType & DeviceCharacteristics\n"));
        }
        if (securityDescriptor == NULL) {
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipChangeDeviceObjectFromRegistryProperties: Overide Security\n"));
        }
    }
#endif
    //
    // modify apropriate characteristics of PDO to be the same as those of rest of stack
    // eg, PDO may be initialized as Raw-Capable Secure Open, but then be modified to be more lax
    //
    PhysicalDeviceObject->Characteristics = (PhysicalDeviceObject->Characteristics & ~FILE_CHARACTERISTICS_PROPAGATED) | characteristics;
    ASSERT((PhysicalDeviceObject->Characteristics & FILE_CHARACTERISTICS_PROPAGATED) == characteristics); // sanity (checks bit bounds)
    //
    // exclusivity flag applies only to PDO
    // if someone is relying on this flag, they better not name the FDO or any filter DO's
    // otherwise the device can be opened via two handles.
    //
    if (exclusiveSpec && exclusive) {
        PhysicalDeviceObject->Flags |= DO_EXCLUSIVE;
    }

    //
    // iterate through rest of objects
    // these flags were used to create characteristics & deviceType, so
    // we will only end up setting flags, not clearing them
    //
    for (StackIterator = PhysicalDeviceObject->AttachedDevice;
         StackIterator != NULL;
         StackIterator = StackIterator->AttachedDevice) {

        //
        // modify characteristics (set only)
        //
        StackIterator->Characteristics |= characteristics;
        ASSERT((StackIterator->Characteristics & FILE_CHARACTERISTICS_PROPAGATED) == characteristics); // sanity (checks we only needed to set)
    }

    if (deviceTypeSpec) {
        //
        // modify device type - PDO only
        //
        PhysicalDeviceObject->DeviceType = deviceType;
    }

    if (securityDescriptor != NULL) {

        //
        // modify security (applied to whole stack)
        //
        status = ObSetSecurityObjectByPointer(PhysicalDeviceObject,
                                              securityInformation,
                                              securityDescriptor);
        if (NT_SUCCESS(status) == FALSE) {
            IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                            "PipChangeDeviceObjectFromRegistryProperties: Set security failed (%08x)\n",status));
        }
    }

    //
    // cleanup
    //
    if ((securityDescriptor != NULL) && !securityForce) {
        ExFreePool(securityDescriptor);
    }

    if (allocatedAcl) {
        ExFreePool(allocatedAcl);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PipProcessDevNodeTree(
    IN  PDEVICE_NODE        SubtreeRootDeviceNode,
    IN  BOOLEAN             LoadDriver,
    IN  BOOLEAN             ReallocateResources,
    IN  ENUM_TYPE           EnumType,
    IN  BOOLEAN             Synchronous,
    IN  BOOLEAN             ProcessOnlyIntermediateStates,
    IN  PADD_CONTEXT        AddContext,
    IN PPI_DEVICE_REQUEST   Request
    )
/*--

Routine Description:

    This function is called to handle state transitions related to starting
    Devnodes.  The basic sequence of operations is inheritted from the previous
    implementation.

    Resources freed
        1)  Allocate resources to all candidates in the tree.
        2)  Traverse the tree searching for a Devnodes ready to be started.
        3)  Start the Devnode.
        4)  Enumerate its children.
        5)  Initialize all the children up to the point of resource allocation.
        6)  Continue searching for DevNodes to start, if one is found return to
            step 3.
        7)  Once the entire tree is processed start over at step 1 until either
            no children are enumerated or no resources are allocated.

    A Devnode's resource requirements change
        If the Devnode wasn't started then treat it the same as the Resources
        freed case.  If it was started then it would have been handled directly
        by our caller.


    Start Devnodes during boot
        1)  Allocate resources to all candidates in the tree (based on
            IopBootConfigsReserved).
        2)  Traverse the tree searching for Devnodes ready to be started.
        3)  Start the Devnode.
        4)  Enumerate its children.
        5)  Initialize all the children up to the point of resource allocation.
        6)  Continue searching for DevNodes to start, if one is found return to
            step 3.

    Devnode newly created by user-mode.
        1)  Reset Devnode to uninitialized state.
        2)  Process Devnode to DeviceNodeDriversAdded state.
        3)  Allocate resources to this Devnode.
        4)  Start the Devnode.
        5)  Enumerate its children.
        6)  Initialize any children up to the point of resource allocation.
        7)  Allocate resources to all candidates in the tree below the initial
            Devnode.
        8)  Traverse the tree starting at the initial Devnode searching for
            a Devnode ready to be started.
        9)  Start the Devnode.
        10) Enumerate its children.
        11) Initialize all the children up to the point of resource allocation.
        12) Start over at step 7 until either no children are enumerated or no
            resources are allocated.

    Device node newly created by IoReportDetectedDevice.
        1)  Do post start IRP processing
        2)  Continue from step 5 of the process for Devnodes newly created by
            user-mode.

    Reenumeration of a single Devnode (and processing of changes resulting from
    that enumeration)

        1)  Enumerate Devnode's children
        2)  Initialize any children up to the point of resource allocation.
        3)  Allocate resources to all candidates in the tree below the initial
            Devnode.
        4)  Traverse the tree starting at the initial Devnode searching for
            a Devnode ready to be started.
        5)  Start the Devnode.
        6)  Enumerate its children.
        7)  Initialize all the children up to the point of resource allocation.
        8)  Start over at step 3 until either no children are enumerated or no
            resources are allocated.

    Reenumeration of a subtree.




Parameters:

    SubtreeRootDeviceNode - Root of this tree walk. Depending on the
                            ProcessOnlyIntermediaryStates parameter, the
                            PDO for this devnode may need to be referenced.

    LoadDriver - Indicates whether drivers should be loaded on this pass
                 (typically TRUE unless boot drivers aren't yet ready)

    ReallocateResources - TRUE iff resource reallocation should be attempted.

    EnumType - Specifies type of enumeration.

    Synchronous - TRUE iff the operation should be performed synchronously
                  (always TRUE currently)

    ProcessOnlyIntermediateStates - TRUE if only intermediary states should be
                                    processed. If FALSE, the caller places
                                    a reference on the PDO that this routine
                                    will drop.

    AddContext - Constraints for AddDevice

    Request - Device action worker that triggered this processing.

Return Value:

    NTSTATUS - Note: Always successful if ProcessOnlyIntermediaryStates is TRUE.

++*/
{
    PDEVICE_NODE    currentNode;
    PDEVICE_NODE    startRoot;
    PDEVICE_NODE    enumeratedBus;
    PDEVICE_NODE    originalSubtree;
    BOOLEAN         processComplete;
    BOOLEAN         newDevice;
    BOOLEAN         rebalancePerformed;
    NTSTATUS        status;
    ULONG           reenumAttempts;

    enum {
        SameNode,
        SiblingNode,
        ChildNode
    } nextNode;

    PAGED_CODE();

    originalSubtree     = SubtreeRootDeviceNode;
    //
    // Collapse enum requests if appropriate.
    //
    if (Request && !Request->ReorderingBarrier &&
        EnumType != EnumTypeShallow && !ProcessOnlyIntermediateStates) {

        if (PiCollapseEnumRequests(&Request->ListEntry)) {

            SubtreeRootDeviceNode = IopRootDeviceNode;
        }
    }

    reenumAttempts      = 0;
    startRoot           = NULL;
    enumeratedBus       = NULL;
    processComplete     = FALSE;
    newDevice           = TRUE;

    while (newDevice) {

        newDevice = FALSE;
        if (!ProcessOnlyIntermediateStates) {

            //
            // Process the whole device tree to assign resources to those devices
            // who have been successfully added to their drivers.
            //

            rebalancePerformed = FALSE;
            newDevice = IopProcessAssignResources( SubtreeRootDeviceNode,
                                                   ReallocateResources,
                                                   &rebalancePerformed);
            if (rebalancePerformed == TRUE) {

                //
                // Before we do any other processing, we need to restart
                // all rebalance participants.
                //

                status = PipProcessDevNodeTree(  IopRootDeviceNode,
                                                 LoadDriver,
                                                 FALSE,
                                                 EnumType,
                                                 Synchronous,
                                                 TRUE,
                                                 AddContext,
                                                 Request);

                ASSERT(NT_SUCCESS(status));
            }
        }

        if (processComplete && !newDevice) {

            break;
        }

        //
        // Process the entire subtree.
        //

        currentNode = SubtreeRootDeviceNode;
        processComplete = FALSE;
        while (!processComplete) {

            //
            // Dont process devnodes with problem.
            //

            status      = STATUS_SUCCESS;
            nextNode    = SiblingNode;
            if (!PipDoesDevNodeHaveProblem(currentNode)) {

                switch (currentNode->State) {

                case DeviceNodeUninitialized:

                    if (!ProcessOnlyIntermediateStates) {

                        if (currentNode->Parent == enumeratedBus && startRoot == NULL) {

                            startRoot = currentNode;
                        }
                        if((!ReallocateResources && EnumType == EnumTypeNone) || startRoot) {

                            status = PipProcessNewDeviceNode(currentNode);
                            if (NT_SUCCESS(status)) {

                                nextNode = SameNode;
                            }
                        }
                    }
                    break;

                case DeviceNodeInitialized:

                    if (!ProcessOnlyIntermediateStates) {

                        if (!ReallocateResources || startRoot) {

                            status = PipCallDriverAddDevice( currentNode,
                                                             LoadDriver,
                                                             AddContext);
                            if (NT_SUCCESS(status)) {

                                nextNode = SameNode;
                                newDevice = TRUE;
                            } else {

                                //
                                // ISSUE - 2000/08/31 - ADRIAO: Not draining
                                //     We should really drain the removes here.
                                // We don't because we cannot distinguish
                                // AddDevice's that fail due to non-present
                                // boot drivers from AddDevice's that fail due
                                // to a problem requiring remove.
                                //
                                //status = STATUS_PNP_RESTART_ENUMERATION;
                            }
                        }
                    }
                    break;

                case DeviceNodeResourcesAssigned:

                    if (!ProcessOnlyIntermediateStates) {

                        if (ReallocateResources && startRoot == NULL) {

                            //
                            // If we assigned resources to this previously
                            // conflicting devnode, remember him so that we will
                            // initial processing on devices in that subtree.
                            //

                            startRoot = currentNode;
                        }

                        status = PipProcessStartPhase1(currentNode, Synchronous);

                        if (NT_SUCCESS(status)) {
                            nextNode = SameNode;
                        } else {

                            //
                            // Cleanup is currently handled in the
                            // DeviceNodeStartCompletion phase, thus
                            // PipProcessStartPhase1 should always succeed.
                            //
                            ASSERT(0);
                            nextNode = SiblingNode;
                        }

                    } else {
                        nextNode = SiblingNode;
                    }
                    break;

                case DeviceNodeStartCompletion:

                    status = PipProcessStartPhase2(currentNode);

                    if (NT_SUCCESS(status)) {
                        nextNode = SameNode;
                    } else {
                        status = STATUS_PNP_RESTART_ENUMERATION;
                        ASSERT(currentNode->State != DeviceNodeStartCompletion);
                    }
                    break;

                case DeviceNodeStartPostWork:

                    status = PipProcessStartPhase3(currentNode);

                    if (NT_SUCCESS(status)) {
                        nextNode = SameNode;
                    } else {
                        status = STATUS_PNP_RESTART_ENUMERATION;
                        ASSERT(!ProcessOnlyIntermediateStates);
                    }
                    break;

                case DeviceNodeStarted:

                    nextNode = ChildNode;
                    if (!ProcessOnlyIntermediateStates) {

                        if ((currentNode->Flags & DNF_REENUMERATE)) {

                            status = PipEnumerateDevice(currentNode, Synchronous);
                            if (NT_SUCCESS(status)) {

                                //
                                // Remember the bus we just enumerated.
                                //

                                enumeratedBus = currentNode;
                                nextNode = SameNode;

                            } else if (status == STATUS_PENDING) {

                                nextNode = SiblingNode;
                            }
                        }
                    }
                    break;

                case DeviceNodeEnumerateCompletion:

                    status = PipEnumerateCompleted(currentNode);
                    nextNode = ChildNode;
                    break;

                case DeviceNodeStopped:
                    status = PipProcessRestartPhase1(currentNode, Synchronous);
                    if (NT_SUCCESS(status)) {
                        nextNode = SameNode;
                    } else {
                        //
                        // Cleanup is currently handled in the
                        // DeviceNodeStartCompletion phase, thus
                        // PipProcessRestartPhase1 should always succeed.
                        //
                        ASSERT(0);
                        nextNode = SiblingNode;
                    }
                    break;

                case DeviceNodeRestartCompletion:

                    status = PipProcessRestartPhase2(currentNode);
                    if (NT_SUCCESS(status)) {
                        nextNode = SameNode;
                    } else {
                        status = STATUS_PNP_RESTART_ENUMERATION;
                        ASSERT(currentNode->State != DeviceNodeRestartCompletion);
                    }
                    break;

                case DeviceNodeDriversAdded:
                case DeviceNodeAwaitingQueuedDeletion:
                case DeviceNodeAwaitingQueuedRemoval:
                case DeviceNodeRemovePendingCloses:
                case DeviceNodeRemoved:
                    nextNode = SiblingNode;
                    break;

                case DeviceNodeStartPending:
                case DeviceNodeEnumeratePending:
                case DeviceNodeQueryStopped:
                case DeviceNodeQueryRemoved:
                case DeviceNodeDeletePendingCloses:
                case DeviceNodeDeleted:
                case DeviceNodeUnspecified:
                default:
                    ASSERT(0);
                    nextNode = SiblingNode;
                    break;
                }
            }

            //
            // If we need to wait for the queued removals to complete before
            // we progress,we need to do the following:
            // 1. capture the instance paths for all the parents of the current
            // node upto the subtree root where we started
            // 2. drop the reference to the subtree root allowing it to be
            // deleted (if required)
            // 3. drop the tree lock
            // 4. wait for the removal queue to empty
            // 5. re-acquire the tree lock
            // 6. resume processing
            //

            if (status == STATUS_PNP_RESTART_ENUMERATION &&
                !ProcessOnlyIntermediateStates) {

                PDEVICE_OBJECT  entryDeviceObject;
                UNICODE_STRING  unicodeName;
                PWCHAR          devnodeList;
                PWCHAR          currentEntry;
                PWCHAR          rootEntry;
                WCHAR           buffer[MAX_INSTANCE_PATH_LENGTH];

                status = PipProcessDevNodeTree( IopRootDeviceNode,
                                                LoadDriver,
                                                ReallocateResources,
                                                EnumType,
                                                Synchronous,
                                                TRUE,
                                                AddContext,
                                                Request);

                ASSERT(NT_SUCCESS(status));

                PipAssertDevnodesInConsistentState();

                if (++reenumAttempts < MAX_REENUMERATION_ATTEMPTS) {

                    devnodeList = ExAllocatePool( PagedPool,
                                                  (currentNode->Level + 1) * MAX_INSTANCE_PATH_LENGTH * sizeof(WCHAR));
                    if (devnodeList) {

                        currentEntry = devnodeList;

                        for ( ; ; ) {

                            rootEntry = currentEntry;

                            ASSERT(currentNode->InstancePath.Length < MAX_INSTANCE_PATH_LENGTH);

                            memcpy( currentEntry,
                                    currentNode->InstancePath.Buffer,
                                    currentNode->InstancePath.Length );

                            currentEntry += currentNode->InstancePath.Length / sizeof(WCHAR);
                            *currentEntry++ = UNICODE_NULL;

                            if (currentNode == SubtreeRootDeviceNode) {
                                break;
                            }

                            currentNode = currentNode->Parent;
                        }
                    } else {

                        ASSERT(SubtreeRootDeviceNode->InstancePath.Length < MAX_INSTANCE_PATH_LENGTH);
                        memcpy( buffer,
                                SubtreeRootDeviceNode->InstancePath.Buffer,
                                SubtreeRootDeviceNode->InstancePath.Length );
                        rootEntry = buffer;
                    }
                } else {

                    rootEntry = NULL;
                    devnodeList = NULL;
                }
                ObDereferenceObject(originalSubtree->PhysicalDeviceObject);

                PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
                PpSynchronizeDeviceEventQueue();
                PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

                if (reenumAttempts >= MAX_REENUMERATION_ATTEMPTS) {

                    IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                                 "Restarted reenumeration %d times, giving up!\n", reenumAttempts));
                    ASSERT(reenumAttempts < MAX_REENUMERATION_ATTEMPTS);
                    return STATUS_UNSUCCESSFUL;
                }
                RtlInitUnicodeString(&unicodeName, rootEntry);
                entryDeviceObject = IopDeviceObjectFromDeviceInstance(&unicodeName);
                if (entryDeviceObject == NULL) {

                    if (devnodeList) {

                        ExFreePool(devnodeList);
                    }
                    return STATUS_UNSUCCESSFUL;
                }

                SubtreeRootDeviceNode = entryDeviceObject->DeviceObjectExtension->DeviceNode;
                originalSubtree = currentNode = SubtreeRootDeviceNode;

                //
                // Try to start processing where we left off.
                //
                if (devnodeList) {

                    for(currentEntry = devnodeList;
                        currentEntry != rootEntry;
                        currentEntry += ((unicodeName.Length / sizeof(WCHAR))+1)) {

                        RtlInitUnicodeString(&unicodeName, currentEntry);

                        entryDeviceObject = IopDeviceObjectFromDeviceInstance(&unicodeName);

                        if (entryDeviceObject != NULL) {

                            currentNode = entryDeviceObject->DeviceObjectExtension->DeviceNode;
                            ObDereferenceObject(entryDeviceObject);
                            break;
                        }
                    }

                    ExFreePool(devnodeList);

                }
                nextNode = SameNode;
            }

            //
            // This code advances the current node based on nextNode.
            //

            switch (nextNode) {
            case SameNode:
                break;

            case ChildNode:

                if (currentNode->Child != NULL) {

                    currentNode = currentNode->Child;
                    break;
                }
                // FALLTHRU - No more children so advance to sibling

            case SiblingNode:

                while (currentNode != SubtreeRootDeviceNode) {

                    if (currentNode == startRoot) {

                        //
                        // We completed processing of the new subtree.
                        //

                        if (EnumType != EnumTypeNone) {

                            enumeratedBus   = startRoot->Parent;
                        }
                        startRoot       = NULL;
                    } else if (currentNode == enumeratedBus) {

                        enumeratedBus   = enumeratedBus->Parent;
                    }

                    if (currentNode->Sibling != NULL) {
                        currentNode = currentNode->Sibling;
                        break;
                    }

                    if (currentNode->Parent != NULL) {
                        currentNode = currentNode->Parent;
                    }
                }

                if (currentNode == SubtreeRootDeviceNode) {

                    processComplete = TRUE;
                }
                break;
            }
        }
    }

    if (!ProcessOnlyIntermediateStates) {

         PipAssertDevnodesInConsistentState();
         ObDereferenceObject(originalSubtree->PhysicalDeviceObject);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PipProcessStartPhase1(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN      Synchronous
    )
{
    PDEVICE_OBJECT  deviceObject;
    NTSTATUS        status = STATUS_SUCCESS;
    PNP_VETO_TYPE   vetoType;

    PAGED_CODE();

    ASSERT(DeviceNode->State == DeviceNodeResourcesAssigned);

    deviceObject = DeviceNode->PhysicalDeviceObject;

    IopUncacheInterfaceInformation(deviceObject);

    if (DeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

        //
        // This is a dock so we a little bit of work before starting it.
        // Take the profile change semaphore. We do this whenever a dock
        // is in our list, even if no query is going to occur.
        //
        PpProfileBeginHardwareProfileTransition(FALSE);

        //
        // Tell the profile code what dock device object may be bringing the
        // new hardware profile online.
        //
        PpProfileIncludeInHardwareProfileTransition(DeviceNode, DOCK_ARRIVING);

        //
        // Ask everyone if this is really a good idea right now.
        //
        status = PpProfileQueryHardwareProfileChange(
            FALSE,
            PROFILE_PERHAPS_IN_PNPEVENT,
            &vetoType,
            NULL
            );
    }

    if (NT_SUCCESS(status)) {

        status = IopStartDevice(deviceObject);
    }

    //
    // Failure cleanup is handled in PipProcessStartPhase2, thus we write away
    // the failure code and always succeed.
    //
    PipSetDevNodeState(DeviceNode, DeviceNodeStartCompletion, NULL);
    DeviceNode->CompletionStatus = status;
    return STATUS_SUCCESS;
}

NTSTATUS
PipProcessStartPhase2(
    IN PDEVICE_NODE     DeviceNode
    )
{
    ULONG       problem = CM_PROB_FAILED_START;
    NTSTATUS    status;

    PAGED_CODE();

    status = DeviceNode->CompletionStatus;
    if (DeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

        if (NT_SUCCESS(status)) {

            //
            // Commit the current Hardware Profile as necessary.
            //
            PpProfileCommitTransitioningDock(DeviceNode, DOCK_ARRIVING);

        } else {

            PpProfileCancelHardwareProfileTransition();
        }
    }

    if (!NT_SUCCESS(status)) {

        SAVE_FAILURE_INFO(DeviceNode, DeviceNode->CompletionStatus);

        //
        // Handle certain problems determined by the status code
        //
        switch(status) {

            case STATUS_PNP_REBOOT_REQUIRED:
                problem = CM_PROB_NEED_RESTART;
                break;

            default:
                problem = CM_PROB_FAILED_START;
                break;
        }

        PipRequestDeviceRemoval(DeviceNode, FALSE, problem);

        if (DeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

            ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT);
            IoRequestDeviceEject(DeviceNode->PhysicalDeviceObject);
        }

    } else {

        IopDoDeferredSetInterfaceState(DeviceNode);

        //
        // Reserve legacy resources for the legacy interface and bus number.
        //
        if (!IopBootConfigsReserved && DeviceNode->InterfaceType != InterfaceTypeUndefined) {

            //
            // ISA = EISA.
            //
            if (DeviceNode->InterfaceType == Isa) {

                IopAllocateLegacyBootResources(Eisa, DeviceNode->BusNumber);

            }

            IopAllocateLegacyBootResources(DeviceNode->InterfaceType, DeviceNode->BusNumber);
        }

        //
        // This code path currently doesn't expect any of the above functions
        // to fail. If they do, a removal should be queued and failure should
        // be returned.
        //
        ASSERT(DeviceNode->State == DeviceNodeStartCompletion);

        PipSetDevNodeState(DeviceNode, DeviceNodeStartPostWork, NULL);
    }

    return status;
}

NTSTATUS
PipProcessStartPhase3(
    IN PDEVICE_NODE     DeviceNode
    )
{
    NTSTATUS        status;
    PDEVICE_OBJECT  deviceObject;
    HANDLE          handle;
    PWCHAR          ids;
    UNICODE_STRING  unicodeName;

    PAGED_CODE();

    deviceObject = DeviceNode->PhysicalDeviceObject;

    if (!(DeviceNode->Flags & DNF_IDS_QUERIED)) {

        PWCHAR compatibleIds, hwIds;
        ULONG hwIdLength, compatibleIdLength;

        //
        // If the DNF_NEED_QUERY_IDS is set, the device is a reported device.
        // It should already be started.  We need to enumerate its children and ask
        // the HardwareId and the Compatible ids of the detected device.
        //

        status = IopDeviceObjectToDeviceInstance (deviceObject,
                                                  &handle,
                                                  KEY_READ
                                                  );
        if (NT_SUCCESS(status)) {

            PpQueryHardwareIDs( 
                DeviceNode,
                &hwIds,
                &hwIdLength);

            PpQueryCompatibleIDs(   
                DeviceNode,
                &compatibleIds,
                &compatibleIdLength);

            if (hwIds || compatibleIds) {

                UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
                PKEY_VALUE_PARTIAL_INFORMATION keyInfo =
                    (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
                PKEY_VALUE_FULL_INFORMATION keyValueInformation;
                ULONG flags, length;
                PWCHAR  oldID, newID;

                PiLockPnpRegistry(FALSE);

                //
                // Read the current config flags.
                //

                PiWstrToUnicodeString (&unicodeName, REGSTR_VALUE_CONFIG_FLAGS);
                status = ZwQueryValueKey(handle,
                                         &unicodeName,
                                         KeyValuePartialInformation,
                                         keyInfo,
                                         sizeof(buffer),
                                         &length
                                         );
                if (NT_SUCCESS(status) && (keyInfo->Type == REG_DWORD)) {

                    flags = *(PULONG)keyInfo->Data;
                } else {

                    flags = 0;
                }
                if (hwIds) {

                    if (!(flags & CONFIGFLAG_FINISH_INSTALL)) {

                        status = IopGetRegistryValue (handle,
                                                      REGSTR_VALUE_HARDWAREID,
                                                      &keyValueInformation);
                        if (NT_SUCCESS(status)) {

                            if (keyValueInformation->Type == REG_MULTI_SZ) {

                                ids = (PWCHAR)KEY_VALUE_DATA(keyValueInformation);
                                //
                                // Check if the old and new IDs are identical.
                                //
                                for (oldID = ids, newID = hwIds;
                                    *oldID && *newID;
                                    oldID += wcslen(oldID) + 1, newID += wcslen(newID) + 1) {
                                    if (_wcsicmp(oldID, newID)) {

                                        break;
                                    }
                                }
                                if (*oldID || *newID) {

                                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                                    "IopStartAndEnumerateDevice: Hardware ID has changed for %wZ\n", &DeviceNode->InstancePath));
                                    flags |= CONFIGFLAG_FINISH_INSTALL;
                                }
                            }
                            ExFreePool(keyValueInformation);
                        }
                    }
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_HARDWAREID);
                    ZwSetValueKey(handle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_MULTI_SZ,
                                  hwIds,
                                  hwIdLength);
                    ExFreePool(hwIds);
                }
                //
                // create CompatibleId value name.  It is a MULTI_SZ,
                //
                if (compatibleIds) {

                    if (!(flags & CONFIGFLAG_FINISH_INSTALL)) {
                        status = IopGetRegistryValue (handle,
                                                      REGSTR_VALUE_COMPATIBLEIDS,
                                                      &keyValueInformation);
                        if (NT_SUCCESS(status)) {

                            if (keyValueInformation->Type == REG_MULTI_SZ) {

                                ids = (PWCHAR)KEY_VALUE_DATA(keyValueInformation);
                                //
                                // Check if the old and new IDs are identical.
                                //
                                for (oldID = ids, newID = compatibleIds;
                                     *oldID && *newID;
                                     oldID += wcslen(oldID) + 1, newID += wcslen(newID) + 1) {
                                    if (_wcsicmp(oldID, newID)) {

                                        break;
                                    }
                                }
                                if (*oldID || *newID) {

                                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                                    "IopStartAndEnumerateDevice: Compatible ID has changed for %wZ\n", &DeviceNode->InstancePath));
                                    flags |= CONFIGFLAG_FINISH_INSTALL;
                                }
                            }
                            ExFreePool(keyValueInformation);
                        }
                    }
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_COMPATIBLEIDS);
                    ZwSetValueKey(handle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_MULTI_SZ,
                                  compatibleIds,
                                  compatibleIdLength);
                    ExFreePool(compatibleIds);
                }

                //
                // If we set the finish install flag, then write out the flags.
                //

                if (flags & CONFIGFLAG_FINISH_INSTALL) {

                    PiWstrToUnicodeString (&unicodeName, REGSTR_VALUE_CONFIG_FLAGS);
                    ZwSetValueKey(handle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_DWORD,
                                  &flags,
                                  sizeof(flags)
                                  );
                }

                PiUnlockPnpRegistry();
            }
            ZwClose(handle);

            DeviceNode->Flags |= DNF_IDS_QUERIED;
        }
    }

    if (PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA)) {

        return STATUS_UNSUCCESSFUL;
    }

    DeviceNode->Flags |= DNF_REENUMERATE;

    IopQueryAndSaveDeviceNodeCapabilities(DeviceNode);
    status = PiProcessQueryDeviceState(deviceObject);

    //
    // The device has been started, attempt to enumerate the device.
    //
    PpSetPlugPlayEvent( &GUID_DEVICE_ARRIVAL,
                        DeviceNode->PhysicalDeviceObject);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    PpvUtilTestStartedPdoStack(deviceObject);
    PipSetDevNodeState( DeviceNode, DeviceNodeStarted, NULL );

    return STATUS_SUCCESS;
}

NTSTATUS
PiProcessQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_NODE deviceNode;
    PNP_DEVICE_STATE deviceState;
    NTSTATUS status;
    ULONG problem;

    PAGED_CODE();

    //
    // If the device was removed or surprised removed while the work
    // item was queued then ignore it.
    //
    status = IopQueryDeviceState(DeviceObject, &deviceState);

    //
    // Now perform the appropriate action based on the returned state
    //
    if (!NT_SUCCESS(status)) {

        return STATUS_SUCCESS;
    }

    deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode;

    if (deviceState & PNP_DEVICE_DONT_DISPLAY_IN_UI) {

        deviceNode->UserFlags |= DNUF_DONT_SHOW_IN_UI;

    } else {

        deviceNode->UserFlags &= ~DNUF_DONT_SHOW_IN_UI;
    }

    if (deviceState & PNP_DEVICE_NOT_DISABLEABLE) {

        if ((deviceNode->UserFlags & DNUF_NOT_DISABLEABLE)==0) {

            //
            // this node itself is not disableable
            //
            deviceNode->UserFlags |= DNUF_NOT_DISABLEABLE;

            //
            // propagate up tree
            //
            IopIncDisableableDepends(deviceNode);
        }

    } else {

        if (deviceNode->UserFlags & DNUF_NOT_DISABLEABLE) {

            //
            // this node itself is now disableable
            //
            //
            // check tree
            //
            IopDecDisableableDepends(deviceNode);

            deviceNode->UserFlags &= ~DNUF_NOT_DISABLEABLE;
        }
    }

    //
    // everything here can only be turned on (state set)
    //
    if (deviceState & (PNP_DEVICE_DISABLED | PNP_DEVICE_REMOVED)) {

        problem = (deviceState & PNP_DEVICE_DISABLED) ?
            CM_PROB_HARDWARE_DISABLED : CM_PROB_DEVICE_NOT_THERE;

        PipRequestDeviceRemoval(deviceNode, FALSE, problem);

        status = STATUS_UNSUCCESSFUL;

    } else if (deviceState & PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED) {

        if (deviceState & PNP_DEVICE_FAILED) {

            IopResourceRequirementsChanged(DeviceObject, TRUE);

        } else {

            IopResourceRequirementsChanged(DeviceObject, FALSE);
        }

    } else if (deviceState & PNP_DEVICE_FAILED) {

        PipRequestDeviceRemoval(deviceNode, FALSE, CM_PROB_FAILED_POST_START);
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
PipProcessRestartPhase1(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    )
{
    NTSTATUS status;
    PAGED_CODE();

    ASSERT(DeviceNode->State == DeviceNodeStopped);

    status = IopStartDevice(DeviceNode->PhysicalDeviceObject);

    //
    // Failure cleanup is handled in PipProcessRestartPhase2, thus we write away
    // the failure code and always succeed.
    //
    DeviceNode->CompletionStatus = status;
    PipSetDevNodeState(DeviceNode, DeviceNodeRestartCompletion, NULL);
    return STATUS_SUCCESS;
}

NTSTATUS
PipProcessRestartPhase2(
    IN PDEVICE_NODE     DeviceNode
    )
{
    ULONG       problem;
    NTSTATUS    status;

    PAGED_CODE();

    status = DeviceNode->CompletionStatus;

    if (!NT_SUCCESS(status)) {

        SAVE_FAILURE_INFO(DeviceNode, status);

        //
        // Handle certain problems determined by the status code
        //
        switch (status) {

            case STATUS_PNP_REBOOT_REQUIRED:
                problem = CM_PROB_NEED_RESTART;
                break;

            default:
                problem = CM_PROB_FAILED_START;
                break;
        }

        PipRequestDeviceRemoval(DeviceNode, FALSE, problem);

        if (DeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

            ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT);
            IoRequestDeviceEject(DeviceNode->PhysicalDeviceObject);
        }

    } else {

        PipSetDevNodeState(DeviceNode, DeviceNodeStarted, NULL);
    }

    return status;
}


NTSTATUS
PiProcessHaltDevice(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This routine simulates a surprise removal scenario on the passed in device
    node.

Arguments:

    DeviceNode - DeviceNode to halt

    Flags - PNP_HALT_ALLOW_NONDISABLEABLE_DEVICES - Allows halt on nodes
                                                    marked non-disableable.

Return Value:

    NTSTATUS.

--*/
{
    ULONG flags = (ULONG)Request->RequestArgument;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;
    }

    if (flags & (~PNP_HALT_ALLOW_NONDISABLEABLE_DEVICES)) {

        return STATUS_INVALID_PARAMETER_2;
    }

    if (deviceNode->Flags & (DNF_MADEUP | DNF_LEGACY_DRIVER)) {

        //
        // Sending surprise removes to legacy devnodes would be a bad idea.
        // Today, if a legacy devnode fails it is manually taken to the removed
        // state rather than being put through the engine.
        //
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ((!(deviceNode->Flags & PNP_HALT_ALLOW_NONDISABLEABLE_DEVICES)) &&
        deviceNode->DisableableDepends) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (deviceNode->State != DeviceNodeStarted) {

        return STATUS_INVALID_DEVICE_STATE;
    }

    PipRequestDeviceRemoval(deviceNode, FALSE, CM_PROB_HALTED);

    return STATUS_SUCCESS;
}


VOID
PpResetProblemDevices(
    IN  PDEVICE_NODE    DeviceNode,
    IN  ULONG           Problem
    )
/*++

Routine Description:

    This routine resets all non-configured devices *beneath* the passed in
    devnode so a subsequent enum will kick off new hardware installation
    on them.

Arguments:

    DeviceNode - DeviceNode to halt

Return Value:

    None.

--*/
{
    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    PipForDeviceNodeSubtree(
        DeviceNode,
        PiResetProblemDevicesWorker,
        (PVOID)(ULONG_PTR)Problem
        );

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
}


NTSTATUS
PiResetProblemDevicesWorker(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This is a worker routine for PiResetNonConfiguredDevices. If the devnode
    has the problem CM_PROB_NOT_CONFIGURED, the devnode is reset so a
    subsequent reenumeration will bring it back.

Arguments:

    DeviceNode - Device to reset if it has the correct problem.

    Context - Not used.

Return Value:

    NTSTATUS, non-successful statuses terminate the tree walk.

--*/
{
    PAGED_CODE();

    if (PipIsDevNodeProblem(DeviceNode, (ULONG)(ULONG_PTR)Context)) {

        //
        // We only need to queue it as an enumeration will drop behind it soon
        // afterwards...
        //
        PipRequestDeviceAction(
            DeviceNode->PhysicalDeviceObject,
            ClearDeviceProblem,
            TRUE,
            0,
            NULL,
            NULL
            );
    }

    return STATUS_SUCCESS;
}

VOID
PiMarkDeviceTreeForReenumeration(
    IN  PDEVICE_NODE DeviceNode,
    IN  BOOLEAN Subtree
    )
/*++

Routine Description:

    This routine marks the devnode for reenumeration.

Arguments:

    DeviceNode  - DeviceNode to mark for re-enumeration

    Subtree     - If TRUE, the entire subtree is marked for re-enumeration.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(PPL_TREEOP_ALLOW_READS);

    PiMarkDeviceTreeForReenumerationWorker(DeviceNode, NULL);

    if (Subtree) {

        PipForDeviceNodeSubtree(
            DeviceNode,
            PiMarkDeviceTreeForReenumerationWorker,
            NULL
            );
    }
}

NTSTATUS
PiMarkDeviceTreeForReenumerationWorker(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This is a worker routine for PiMarkDeviceTreeForReenumeration. It marks all
    started devnodes with DNF_REENUMERATE so that the subsequent tree
    processing will reenumerate the device.

Arguments:

    DeviceNode - Device to mark if started.

    Context - Not used.

Return Value:

    NTSTATUS, non-successful statuses terminate the tree walk.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(Context);

    if (DeviceNode->State == DeviceNodeStarted) {

        if (DeviceNode->Flags & DNF_REENUMERATE) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PiMarkDeviceTreeForReenumerationWorker: Collapsed enum request on %wZ\n", &DeviceNode->InstancePath));
        } else {

            IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                         "PiMarkDeviceTreeForReenumerationWorker: Reenumerating %wZ\n", &DeviceNode->InstancePath));
        }
        DeviceNode->Flags |= DNF_REENUMERATE;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
PiCollapseEnumRequests(
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    This function collapses reenumeration requests in the device action queue.

Parameters:

    ListHead - The collapses requests get added to the end of this list.

ReturnValue:

    None.

--*/
{
    KIRQL oldIrql;
    PPI_DEVICE_REQUEST  request;
    PLIST_ENTRY entry, next, last;
    PDEVICE_NODE deviceNode;

    ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);
    last = ListHead->Blink;
    //
    // Walk the list and build the list of collapsed requests.
    //
    for (entry = IopPnpEnumerationRequestList.Flink;
         entry != &IopPnpEnumerationRequestList;
         entry = next) {

        next = entry->Flink;
        request = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
        if (request->ReorderingBarrier) {
            break;
        }
        switch(request->RequestType) {
        case ReenumerateRootDevices:
        case ReenumerateDeviceTree:
        case RestartEnumeration:
            //
            // Add it to our request list and mark the subtree.
            //
            RemoveEntryList(entry);
            InsertTailList(ListHead, entry);
            break;

        default:
            break;
        }
    }
    ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
    if (last == ListHead) {

        entry = ListHead->Flink;
    } else {

        entry = last;
    }
    while (entry != ListHead) {

        request = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
        deviceNode = (PDEVICE_NODE)request->DeviceObject->DeviceObjectExtension->DeviceNode;
        PiMarkDeviceTreeForReenumeration(deviceNode, TRUE);
        ObDereferenceObject(request->DeviceObject);
        request->DeviceObject = NULL;
        entry = entry->Flink;
    }

    return (last != ListHead->Blink)? TRUE : FALSE;
}

NTSTATUS
PiProcessAddBootDevices(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the AddBootDevices device action.

Parameters:

    Request - AddBootDevices device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_NODE deviceNode;
    ADD_CONTEXT addContext;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    //
    // If the device has been added (or failed) skip it.
    //
    // If we know the device is a duplicate of another device which
    // has been enumerated at this point. we will skip this device.
    //
    if (deviceNode->State == DeviceNodeInitialized &&
        !PipDoesDevNodeHaveProblem(deviceNode) &&
        !(deviceNode->Flags & DNF_DUPLICATE) &&
        deviceNode->DuplicatePDO == NULL) {

        //
        // Invoke driver's AddDevice Entry for the device.
        //
        addContext.DriverStartType = SERVICE_BOOT_START;

        PipCallDriverAddDevice(deviceNode, PnPBootDriversInitialized, &addContext);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PiProcessClearDeviceProblem(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the ClearDeviceProblem device action.

Parameters:

    Request - ClearDeviceProblem device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER_2.

--*/
{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (deviceNode->State == DeviceNodeUninitialized ||
        deviceNode->State == DeviceNodeInitialized ||
        deviceNode->State == DeviceNodeRemoved) {

        if (PipDoesDevNodeHaveProblem(deviceNode)) {

            if ((Request->RequestType == ClearDeviceProblem) &&
                (PipIsProblemReadonly(deviceNode->Problem))) {

                //
                // ClearDeviceProblem is a user mode request, and we don't let
                // user mode clear readonly problems!
                //
                status = STATUS_INVALID_PARAMETER_2;

            } else if ((Request->RequestType == ClearEjectProblem) &&
                       (!PipIsDevNodeProblem(deviceNode, CM_PROB_HELD_FOR_EJECT))) {

                //
                // Clear eject problem means clear CM_PROB_HELD_FOR_EJECT. If
                // it received another problem, we leave it alone.
                //
                status = STATUS_INVALID_DEVICE_REQUEST;

            } else {

                deviceNode->Flags &= ~(DNF_HAS_PROBLEM | DNF_HAS_PRIVATE_PROBLEM);
                deviceNode->Problem = 0;
                if (deviceNode->State != DeviceNodeUninitialized) {

                    IopRestartDeviceNode(deviceNode);
                }

                ASSERT(status == STATUS_SUCCESS);
            }
        }
    } else if (PipIsDevNodeDeleted(deviceNode)) {

        status = STATUS_DELETE_PENDING;
    }

    return status;
}

NTSTATUS
PiProcessRequeryDeviceState(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the RequeryDeviceState device action.

Parameters:

    Request - RequeryDeviceState device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_NODE deviceNode;
    NTSTATUS status;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (deviceNode->State == DeviceNodeStarted) {

        PiProcessQueryDeviceState(Request->DeviceObject);
        //
        // PCMCIA driver uses this when switching between Cardbus and R2 cards.
        //
        IopUncacheInterfaceInformation(Request->DeviceObject);

    } else if (PipIsDevNodeDeleted(deviceNode)) {

        status = STATUS_DELETE_PENDING;
    }

    return status;
}

NTSTATUS
PiProcessResourceRequirementsChanged(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the ResourceRequirementsChanged device action.

Parameters:

    Request - ResourceRequirementsChanged device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS or STATUS_UNSUCCESSFUL.

--*/
{
    NTSTATUS status;
    ADD_CONTEXT addContext;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;
    }
    //
    // Clear the NO_RESOURCE_REQUIRED flags.
    //
    deviceNode->Flags &= ~DNF_NO_RESOURCE_REQUIRED;
    //
    // If for some reason this device did not start, we need to clear some flags
    // such that it can be started later.  In this case, we call IopRequestDeviceEnumeration
    // with NULL device object, so the devices will be handled in non-started case.  They will
    // be assigned resources, started and enumerated.
    //
    deviceNode->Flags |= DNF_RESOURCE_REQUIREMENTS_CHANGED;
    PipClearDevNodeProblem(deviceNode);
    //
    // If the device is already started, we call IopRequestDeviceEnumeration with
    // the device object.
    //
    if (deviceNode->State == DeviceNodeStarted) {

        if (Request->RequestArgument == FALSE) {

            deviceNode->Flags |= DNF_NON_STOPPED_REBALANCE;

        } else {
            //
            // Explicitly clear it.
            //
            deviceNode->Flags &= ~DNF_NON_STOPPED_REBALANCE;
        }
        //
        // Reallocate resources for this devNode.
        //
        IopReallocateResources(deviceNode);

        addContext.DriverStartType = SERVICE_DEMAND_START;

        status = PipProcessDevNodeTree( IopRootDeviceNode,
                                        PnPBootDriversInitialized,          // LoadDriver
                                        FALSE,                              // ReallocateResources
                                        EnumTypeNone,                       // ShallowReenumeration
                                        Request->CompletionEvent != NULL,   // Synchronous
                                        TRUE,                               // ProcessOnlyIntermediateStates
                                        &addContext,
                                        Request);
        ASSERT(NT_SUCCESS(status));
        if (!NT_SUCCESS(status)) {

            status = STATUS_SUCCESS;
        }
    } else {

        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
PiProcessReenumeration(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the RestartEnumeration\ReenumerateRootDevices\
    ReenumerateDeviceTree\ReenumerateDeviceOnly device action.

Parameters:

    RequestList - List of reenumeration requests.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_NODE deviceNode;
    ADD_CONTEXT addContext;
    ENUM_TYPE enumType;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;
    }
    enumType = (Request->RequestType == ReenumerateDeviceOnly)? EnumTypeShallow : EnumTypeDeep;
    PiMarkDeviceTreeForReenumeration(
        deviceNode,
        enumType != EnumTypeShallow);

    addContext.DriverStartType = SERVICE_DEMAND_START;

    PipProcessDevNodeTree(
        deviceNode,
        PnPBootDriversInitialized,  // LoadDriver
        FALSE,                      // ReallocateResources
        enumType,
        TRUE,                       // Synchronous
        FALSE,
        &addContext,
        Request);

    return STATUS_SUCCESS;
}

NTSTATUS
PiProcessSetDeviceProblem(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the SetDeviceProblem device action.

Parameters:

    Request - SetDeviceProblem device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER_2.

--*/
{
    PPLUGPLAY_CONTROL_STATUS_DATA statusData;
    ULONG   flags, userFlags;
    NTSTATUS status;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;
    }
    status = STATUS_SUCCESS;
    statusData = (PPLUGPLAY_CONTROL_STATUS_DATA)Request->RequestArgument;
    userFlags = 0;
    flags = 0;
    if (statusData->DeviceStatus & DN_WILL_BE_REMOVED) {

        userFlags |= DNUF_WILL_BE_REMOVED;
    }
    if (statusData->DeviceStatus & DN_NEED_RESTART) {

        userFlags |= DNUF_NEED_RESTART;
    }
    if (statusData->DeviceStatus & DN_PRIVATE_PROBLEM) {

        flags |= DNF_HAS_PRIVATE_PROBLEM;
    }
    if (statusData->DeviceStatus & DN_HAS_PROBLEM) {

        flags |= DNF_HAS_PROBLEM;
    }
    if (statusData->DeviceProblem == CM_PROB_NEED_RESTART) {

        flags       &= ~DNF_HAS_PROBLEM;
        userFlags   |= DNUF_NEED_RESTART;
    }
    if (flags & (DNF_HAS_PROBLEM | DNF_HAS_PRIVATE_PROBLEM)) {

        ASSERT(!PipIsDevNodeDNStarted(deviceNode));
        //
        // ISSUE - 2000/12/07 - ADRIAO:
        //     This set of code allows you to clear read only
        // problems by first changing it to a resetable problem,
        // then clearing. This is not intentional.
        //
        if ( ((deviceNode->State == DeviceNodeInitialized) ||
              (deviceNode->State == DeviceNodeRemoved)) &&
                !PipIsProblemReadonly(statusData->DeviceProblem)) {

            deviceNode->Problem     = statusData->DeviceProblem;
            deviceNode->Flags       |= flags;
            deviceNode->UserFlags   |= userFlags;

        } else {

            status = STATUS_INVALID_PARAMETER_2;
        }
    } else {

        deviceNode->Flags |= flags;
        deviceNode->UserFlags |= userFlags;
    }

    return status;
}

NTSTATUS
PiProcessShutdownPnpDevices(
    IN OUT PDEVICE_NODE        DeviceNode
    )
/*++

Routine Description:

    This function processes the ShutdownPnpDevices device action. Walks the tree
    issuing IRP_MN_QUERY_REMOVE \ IRP_MN_REMOVE_DEVICE to each stack.

Parameters:

    DeviceNode - Root devnode.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    KEVENT          userEvent;
    ULONG           eventResult;
    WCHAR           vetoName[80];
    UNICODE_STRING  vetoNameString = { 0, sizeof(vetoName), vetoName };
    PNP_VETO_TYPE   vetoType;
    NTSTATUS        status;

    PAGED_CODE();

    ASSERT(DeviceNode == IopRootDeviceNode);
    status = STATUS_SUCCESS;
    if (PipTearDownPnpStacksOnShutdown ||
        (PoCleanShutdownEnabled() & PO_CLEAN_SHUTDOWN_PNP)) {

        DeviceNode->UserFlags |= DNUF_SHUTDOWN_QUERIED;

        for ( ; ; ) {

            //
            // Acquire the registry lock to prevent in process removals causing
            // Devnodes to be unlinked from the tree.
            //

            PiLockPnpRegistry(FALSE);

            //
            // Walk the tree looking for devnodes we haven't QueryRemoved yet.
            //

            DeviceNode = DeviceNode->Child;
            while (DeviceNode != NULL) {

                if (DeviceNode->UserFlags & DNUF_SHUTDOWN_SUBTREE_DONE) {
                    if (DeviceNode == IopRootDeviceNode) {
                        //
                        // We've processed the entire devnode tree - we're done
                        //
                        DeviceNode = NULL;
                        break;
                    }

                    if (DeviceNode->Sibling == NULL) {

                        DeviceNode = DeviceNode->Parent;

                        DeviceNode->UserFlags |= DNUF_SHUTDOWN_SUBTREE_DONE;

                    } else {

                        DeviceNode = DeviceNode->Sibling;
                    }

                    continue;
                }

                if (DeviceNode->UserFlags & DNUF_SHUTDOWN_QUERIED) {

                    if (DeviceNode->Child == NULL) {

                        DeviceNode->UserFlags |= DNUF_SHUTDOWN_SUBTREE_DONE;

                        if (DeviceNode->Sibling == NULL) {

                            DeviceNode = DeviceNode->Parent;

                            DeviceNode->UserFlags |= DNUF_SHUTDOWN_SUBTREE_DONE;

                        } else {

                            DeviceNode = DeviceNode->Sibling;
                        }
                    } else {

                        DeviceNode = DeviceNode->Child;
                    }

                    continue;
                }
                break;
            }

            if (DeviceNode != NULL) {

                DeviceNode->UserFlags |= DNUF_SHUTDOWN_QUERIED;

                //
                // Queue this device event
                //

                KeInitializeEvent(&userEvent, NotificationEvent, FALSE);

                vetoNameString.Length = 0;
                //
                // Queue the event, this call will return immediately. Note that status
                // is the status of the PpSetTargetDeviceChange while result is the
                // outcome of the actual event.
                //

                status = PpSetTargetDeviceRemove(DeviceNode->PhysicalDeviceObject,
                                                 FALSE,         // KernelInitiated
                                                 TRUE,          // NoRestart
                                                 FALSE,         // DoEject
                                                 CM_PROB_SYSTEM_SHUTDOWN,
                                                 &userEvent,
                                                 &eventResult,
                                                 &vetoType,
                                                 &vetoNameString);
            } else {

                status = STATUS_UNSUCCESSFUL;
            }

            PiUnlockPnpRegistry();

            if (DeviceNode == NULL) {
                //
                // We've processed the entire tree.
                //
                break;
            }

            //
            // Let the removes drain...
            //
            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

            if (NT_SUCCESS(status)) {

                //
                // Wait for the event we just queued to finish since synchronous
                // operation was requested (non alertable wait).
                //
                // FUTURE ITEM - Use a timeout here?
                //

                status = KeWaitForSingleObject( &userEvent,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

                if (NT_SUCCESS(status)) {
                    status = eventResult;
                }
            }

            //
            // Require lock, start on the next
            //
            PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);
        }
    }

    //
    // Prevent any more events or action worker items from being queued
    //
    PpPnpShuttingDown = TRUE;

    //
    // Drain the event queue
    //
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
    PpSynchronizeDeviceEventQueue();
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    return status;
}

NTSTATUS
PiProcessStartSystemDevices(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the StartSystemDevices device action.

Parameters:

    RequestList - List of reenumeration requests.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_NODE deviceNode;
    ADD_CONTEXT addContext;

    PAGED_CODE();

    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;

    addContext.DriverStartType = SERVICE_DEMAND_START;

    PipProcessDevNodeTree(
        deviceNode,
        PnPBootDriversInitialized,          // LoadDriver
        FALSE,                              // ReallocateResources
        EnumTypeNone,
        Request->CompletionEvent != NULL,   // Synchronous
        FALSE,
        &addContext,
        Request);

    return STATUS_SUCCESS;
}

VOID
PpRemoveDeviceActionRequests(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    KIRQL oldIrql;
    PPI_DEVICE_REQUEST request;
    PLIST_ENTRY entry, next;

    ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);
    //
    // Walk the list and build the list of collapsed requests.
    //
    for (entry = IopPnpEnumerationRequestList.Flink;
         entry != &IopPnpEnumerationRequestList;
         entry = next) {

        next = entry->Flink;
        request = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
        if (request->DeviceObject == DeviceObject) {

            RemoveEntryList(entry);
            if (request->CompletionStatus) {

                *request->CompletionStatus = STATUS_NO_SUCH_DEVICE;
            }
            if (request->CompletionEvent) {

                KeSetEvent(request->CompletionEvent, 0, FALSE);
            }
            ObDereferenceObject(request->DeviceObject);
            ExFreePool(request);
        }
    }
    ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
}

#if DBG
VOID
PipAssertDevnodesInConsistentState(
    VOID
    )
{
    PDEVICE_NODE deviceNode;

    deviceNode = IopRootDeviceNode;

    do {

        ASSERT(deviceNode->State == DeviceNodeUninitialized ||
               deviceNode->State == DeviceNodeInitialized ||
               deviceNode->State == DeviceNodeDriversAdded ||
               deviceNode->State == DeviceNodeResourcesAssigned ||
               deviceNode->State == DeviceNodeStarted ||
               deviceNode->State == DeviceNodeStartPostWork ||
               deviceNode->State == DeviceNodeAwaitingQueuedDeletion ||
               deviceNode->State == DeviceNodeAwaitingQueuedRemoval ||
               deviceNode->State == DeviceNodeRemovePendingCloses ||
               deviceNode->State == DeviceNodeRemoved);

        if (deviceNode->Child != NULL) {

            deviceNode = deviceNode->Child;

        } else {

            while (deviceNode->Sibling == NULL) {

                if (deviceNode->Parent != NULL) {
                    deviceNode = deviceNode->Parent;
                } else {
                    break;
                }
            }

            if (deviceNode->Sibling != NULL) {
                deviceNode = deviceNode->Sibling;
            }
        }

    } while (deviceNode != IopRootDeviceNode);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpevent.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    pnpevent.c

Abstract:

    Routines dealing with Plug and Play event management/notification.

Author:

    Lonny McMichael (lonnym) 02/14/95
    Paula Tomlinson (paulat) 07/01/96

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop
#include <wdmguid.h>
#include <pnpmgr.h>
#include <pnpsetup.h>

/*
 * Design notes:
 *
 *     When UmPnpMgr needs to initiate an action (which it might do to complete
 * a CmXxx API), it calls NtPlugPlayControl. NtPlugPlayControl then usually
 * invokes one of the PpSetXxx functions. Similarly, if Io routines need to
 * initiate such an action (say due a hardware initiated eject), they call one
 * of the following PpSetXxx functions (or an intermediate):
 *
 * Operations synchronized via the queue
 *     PpSetDeviceClassChange           (async)
 *     PpSetTargetDeviceRemove          (optional event)
 *     PpSetCustomTargetEvent           (optional event)
 *     PpSetHwProfileChangeEvent        (optional event)
 *     PpSetPowerEvent                  (optional event)
 *     PpSetPlugPlayEvent               (async)
 *     PpSetDeviceRemovalSafe           (optional event)
 *     PpSetBlockedDriverEvent          (async)
 *     PpSynchronizeDeviceEventQueue    (sync, enqueues a noop to flush queue)
 *
 * The PpSetXxx functions enqueue items to be processed into the Pnp event
 * queue (via PiInsertEventInQueue). Whenever one of these events are inserted
 * into the queue a worker routine is ensured to be available to process it
 * (PiWalkDeviceList).
 *
 * In general, events processed in PiWalkDeviceList fall into two categories -
 * those that are notifications for user mode (queued by kernel mode), and those
 * that are queued operations.
 *
 * User mode notifications are sent by invoking PiNotifyUserMode. That routine
 * gets UmPnpMgr's attention and copies up a buffer for it to digest. This
 * operation is synchronous, PiNotifyUserMode waits until UmPnpMgr.Dll signals
 * it is done (NtPlugPlayControl calls PiUserResponse) before returning.
 *
 * Queued operations (such as PiProcessQueryRemoveAndEject) may be very involved
 * and could generate other events solely for user mode (via calls to
 * PiNotifyUserMode, PiNotifyUserModeRemoveVetoed). These operations may also
 * need to synchronously call kernel and user mode code that registered for the
 * appropriate events (via the IopNotifyXxx functions).
 *
 */

//
// Pool Tags
//
#define PNP_DEVICE_EVENT_LIST_TAG  'LEpP'
#define PNP_DEVICE_EVENT_ENTRY_TAG 'EEpP'
#define PNP_USER_BLOCK_TAG         'BUpP'
#define PNP_DEVICE_WORK_ITEM_TAG   'IWpP'
#define PNP_POOL_EVENT_BUFFER      'BEpP'

//
// PNP_USER_BLOCK
//
//  The caller block contains info describing the caller of
//  NtGetPlugPlayEvent. There's only one caller block.
//

typedef struct _PNP_USER_BLOCK {
    NTSTATUS                Status;
    ULONG                   Result;
    PPNP_VETO_TYPE          VetoType;
    PUNICODE_STRING         VetoName;
    ERESOURCE               Lock;
    KEVENT                  Registered;
    KEVENT                  NotifyUserEvent;
    KEVENT                  UserResultEvent;
    PPLUGPLAY_EVENT_BLOCK   EventBuffer;
    ULONG                   EventBufferSize;
    PVOID                   PoolBuffer;
    ULONG                   PoolUsed;
    ULONG                   PoolSize;
    BOOLEAN                 Deferred;

} PNP_USER_BLOCK, *PPNP_USER_BLOCK;

//
// Local (private) function prototypes
//

NTSTATUS
PiInsertEventInQueue(
    IN PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    );

VOID
PiWalkDeviceList(
    IN PVOID Context
    );

NTSTATUS
PiNotifyUserMode(
    PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    );

NTSTATUS
PiNotifyUserModeDeviceRemoval(
    IN  PPNP_DEVICE_EVENT_ENTRY TemplateDeviceEvent,
    IN  CONST GUID              *EventGuid,
    OUT PPNP_VETO_TYPE          VetoType                OPTIONAL,
    OUT PUNICODE_STRING         VetoName                OPTIONAL
    );

NTSTATUS
PiNotifyUserModeRemoveVetoed(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PNP_VETO_TYPE            VetoType,
    IN PUNICODE_STRING          VetoName        OPTIONAL
    );

NTSTATUS
PiNotifyUserModeRemoveVetoedByList(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PNP_VETO_TYPE            VetoType,
    IN PWSTR                    MultiSzVetoList
    );

NTSTATUS
PiNotifyUserModeKernelInitiatedEject(
    IN  PDEVICE_OBJECT          DeviceObject,
    OUT PNP_VETO_TYPE          *VetoType,
    OUT PUNICODE_STRING         VetoName
    );

NTSTATUS
PiProcessQueryRemoveAndEject(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    );

NTSTATUS
PiProcessTargetDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    );

NTSTATUS
PiProcessCustomDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    );

NTSTATUS
PiResizeTargetDeviceBlock(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent,
    IN PLUGPLAY_DEVICE_DELETE_TYPE DeleteType,
    IN PRELATION_LIST RelationsList,
    IN BOOLEAN ExcludeIndirectRelations
    );

VOID
PiBuildUnsafeRemovalDeviceBlock(
    IN  PPNP_DEVICE_EVENT_ENTRY     OriginalDeviceEvent,
    IN  PRELATION_LIST              RelationsList,
    OUT PPNP_DEVICE_EVENT_ENTRY    *AllocatedDeviceEvent
    );

VOID
PiFinalizeVetoedRemove(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PNP_VETO_TYPE            VetoType,
    IN PUNICODE_STRING          VetoName        OPTIONAL
    );

#if DBG
VOID
LookupGuid(
    IN CONST GUID *Guid,
    IN OUT PCHAR String,
    IN ULONG StringLength
    );

VOID
DumpMultiSz(
    IN PWCHAR MultiSz
    );

VOID
DumpPnpEvent(
    IN PPLUGPLAY_EVENT_BLOCK EventBlock
    );

VOID
PiDumpPdoHandlesToDebugger(
    IN  PDEVICE_OBJECT  *DeviceObjectArray,
    IN  ULONG           ArrayCount,
    IN  BOOLEAN         KnownHandleFailure
    );

BOOLEAN
PiDumpPdoHandlesToDebuggerCallBack(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PEPROCESS       Process,
    IN  PFILE_OBJECT    FileObject,
    IN  HANDLE          HandleId,
    IN  PVOID           Context
    );

#define DUMP_PDO_HANDLES(array, count, knownfailure) \
    PiDumpPdoHandlesToDebugger(array, count, knownfailure)

#else // DBG

#define DUMP_PDO_HANDLES(array, count, knownfailure)

#endif // DBG

#ifdef ALLOC_PRAGMA

#if DBG
#pragma alloc_text(PAGE, DumpMultiSz)
#pragma alloc_text(PAGE, DumpPnpEvent)
#pragma alloc_text(PAGE, LookupGuid)
#pragma alloc_text(PAGE, PiDumpPdoHandlesToDebugger)
#pragma alloc_text(PAGE, PiDumpPdoHandlesToDebuggerCallBack)
#endif

#pragma alloc_text(PAGE, NtGetPlugPlayEvent)

#pragma alloc_text(PAGE, PiCompareGuid)
#pragma alloc_text(PAGE, PiInsertEventInQueue)
#pragma alloc_text(PAGE, PiNotifyUserMode)
#pragma alloc_text(PAGE, PiNotifyUserModeDeviceRemoval)
#pragma alloc_text(PAGE, PiNotifyUserModeKernelInitiatedEject)
#pragma alloc_text(PAGE, PiNotifyUserModeRemoveVetoed)
#pragma alloc_text(PAGE, PiNotifyUserModeRemoveVetoedByList)
#pragma alloc_text(PAGE, PiProcessCustomDeviceEvent)
#pragma alloc_text(PAGE, PiProcessQueryRemoveAndEject)
#pragma alloc_text(PAGE, PiProcessTargetDeviceEvent)
#pragma alloc_text(PAGE, PiResizeTargetDeviceBlock)
#pragma alloc_text(PAGE, PiBuildUnsafeRemovalDeviceBlock)
#pragma alloc_text(PAGE, PiUserResponse)
#pragma alloc_text(PAGE, PiWalkDeviceList)
#pragma alloc_text(PAGE, PiFinalizeVetoedRemove)

#pragma alloc_text(PAGE, PpCompleteDeviceEvent)
#pragma alloc_text(PAGE, PpInitializeNotification)
#pragma alloc_text(PAGE, PpNotifyUserModeRemovalSafe)
#pragma alloc_text(PAGE, PpSetCustomTargetEvent)
#pragma alloc_text(PAGE, PpSetDeviceClassChange)
#pragma alloc_text(PAGE, PpSetDeviceRemovalSafe)
#pragma alloc_text(PAGE, PpSetHwProfileChangeEvent)
#pragma alloc_text(PAGE, PpSetBlockedDriverEvent)
#pragma alloc_text(PAGE, PpSetPlugPlayEvent)
#pragma alloc_text(PAGE, PpSetPowerEvent)
#pragma alloc_text(PAGE, PpSetPowerVetoEvent)
#pragma alloc_text(PAGE, PpSetTargetDeviceRemove)
#pragma alloc_text(PAGE, PpSynchronizeDeviceEventQueue)
#pragma alloc_text(PAGE, PiAllocateCriticalMemory)
#endif

//
// Global Data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif
PPNP_DEVICE_EVENT_LIST  PpDeviceEventList = NULL;
PPNP_USER_BLOCK         PpUserBlock = NULL;
BOOLEAN                 UserModeRunning = FALSE;
BOOLEAN                 PiNotificationInProgress = FALSE;
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif
FAST_MUTEX              PiNotificationInProgressLock;

#if DBG
BOOLEAN                 PiDumpVetoedHandles = FALSE;
#endif


NTSTATUS
NtGetPlugPlayEvent(
    IN  HANDLE EventHandle,
    IN  PVOID Context                       OPTIONAL,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferSize
    )

/*++

Routine Description:

    FRONT-END

    This Plug and Play Manager API allows the user-mode PnP manager to
    receive notification of a (kernel-mode) PnP hardware event.

    THIS API IS ONLY CALLABLE BY THE USER-MODE PNP MANAGER. IF ANY OTHER
    COMPONENT CALLS THIS API, THE DELIVERED EVENT WILL BE LOST TO THE REST
    OF THE OPERATING SYSTEM. FURTHERMORE, THERE IS COMPLEX SYNCHRONIZATION
    BETWEEN THE USER-MODE AND KERNEL-MODE PNP MANAGERS, ANYONE ELSE CALLING
    THIS API WILL EVENTUALLY DEADLOCK THE SYSTEM.

Arguments:

    EventHandle - Supplies an event handle that is signalled when an event
                  is ready to be delivered to user-mode.

    EventBlock - Pointer to a PLUGPLAY_EVENT_BLOCK structure that will receive
                 information on the hardware event that has occurred.

    EventBufferLength - Specifies the size, in bytes, of the EventBuffer field
                        in the PLUGPLAY_EVENT_BLOCK pointed to by EventBlock.

Return Value:

    NTSTATUS code indicating whether or not the function was successful

--*/

{
    NTSTATUS  status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( EventHandle );

    PAGED_CODE();

    //
    // This routine only supports user-mode callers.
    //

    if (KeGetPreviousMode() != UserMode) {
        IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                   "NtGetPlugPlayEvent: Only allows user-mode callers\n"));

        return STATUS_ACCESS_DENIED;
    }

    //
    // Does the caller have "trusted computer base" privilge?
    //

    if (!SeSinglePrivilegeCheck(SeTcbPrivilege, UserMode)) {
        IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                   "NtGetPlugPlayEvent: SecurityCheck failed\n"));

        return STATUS_PRIVILEGE_NOT_HELD;
    }

    UserModeRunning = TRUE;

    try {
        //
        // Probe user buffer parameters.
        //

        ProbeForWrite(EventBlock,
                      EventBufferSize,
                      sizeof(ULONG)
                      );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                   "NtGetPlugPlayEvent: Exception 0x%08X\n",
                   status));
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    PpUserBlock->EventBuffer = EventBlock;
    PpUserBlock->EventBufferSize = EventBufferSize;

    //
    // Wait for the NotifyUserEvent (signalled when there's a device event
    // ready to be delivered to user-mode.
    //
    if (!PpUserBlock->Deferred) {
        //
        // Make it a UserMode wait so the terminate APC will unblock us,
        // and we can leave, which cleans up the thread
        //
        PpUserBlock->PoolUsed = 0;

        //
        // Tell kernel we have a waiter.
        //
        KeSetEvent(&PpUserBlock->Registered, 0, FALSE);

        //
        // Wait for kernel to fill in data for us to copy.
        //
        status = KeWaitForSingleObject(&PpUserBlock->NotifyUserEvent,
                                       Executive,
                                       UserMode,
                                       FALSE,
                                       NULL);
    }
    //
    // On deferral, we know we've returned STATUS_BUFFER_TOO_SMALL
    // so, the PpUserBlock->PoolBuffer still points to a valid block
    // check that the new event buffer is big enough.
    // copy the data out, (w/o waiting for a kernel event)
    //
    if (NT_SUCCESS(status) && (status != STATUS_USER_APC) ) {

        //
        // Validate user buffer size.
        //
        //
        // DON'T do this
        // ASSERT (PpUserBlock->EventBufferSize >= PpUserBlock->PoolSize);
        //
        // Because the user block might just still be too small!
        //
        if (PpUserBlock->EventBufferSize < PpUserBlock->PoolUsed) {

            PpUserBlock->Deferred=TRUE;

            IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                       "NtGetPlugPlayEvent: User-mode buffer too small for event\n"));

            status = STATUS_BUFFER_TOO_SMALL;
        } else {

            status = PpUserBlock->Status;
            PpUserBlock->Deferred = FALSE;

            if (PpUserBlock->PoolBuffer != NULL && NT_SUCCESS (status)) {

                RtlCopyMemory(PpUserBlock->EventBuffer,
                              PpUserBlock->PoolBuffer,
                              PpUserBlock->PoolUsed);


            } else {
                IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                           "NtGetPlugPlayEvent: Invalid event buffer\n"));

                status = STATUS_UNSUCCESSFUL;
            }
        }


    }

    KeClearEvent(&PpUserBlock->Registered);

#if DBG
    {
        CHAR    guidString[256];

        LookupGuid(&PpUserBlock->EventBuffer->EventGuid, guidString, sizeof(guidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "NtGetPlugPlayEvent: Returning event - EventGuid = %s\n",
                   guidString));
    }
#endif

    return status;

} // NtGetPlugPlayEvent



NTSTATUS
PpInitializeNotification(
    VOID
    )

/*++

Routine Description:

    This routine performs initialization required before any of the notification
    events can be processed.  This routine performs init for the master device
    event queue processing.

Parameters:

    None

Return Value:

    Returns a STATUS_Xxx value that indicates whether the function succeeded
    or not.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Allocate and initialize the master device event list.
    //

    PpDeviceEventList = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(PNP_DEVICE_EVENT_LIST),
                                              PNP_DEVICE_EVENT_LIST_TAG);
    if (PpDeviceEventList == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }

    KeInitializeMutex(&PpDeviceEventList->EventQueueMutex, 0);
    ExInitializeFastMutex(&PpDeviceEventList->Lock);
    InitializeListHead(&(PpDeviceEventList->List));
    PpDeviceEventList->Status = STATUS_PENDING;

    //
    // Intialize the PpUserBlock buffer - this buffer contains info about
    // the user-mode caller for NtGetPlugPlayEvent and describes who in user
    // mode we pass the events to.
    //

    PpUserBlock = ExAllocatePoolWithTag(NonPagedPool,
                                        sizeof(PNP_USER_BLOCK),
                                        PNP_USER_BLOCK_TAG);
    if (PpUserBlock == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }

    RtlZeroMemory(PpUserBlock, sizeof(PNP_USER_BLOCK));

    PpUserBlock->PoolSize = sizeof (PLUGPLAY_EVENT_BLOCK)+
                            sizeof (PNP_DEVICE_EVENT_ENTRY);
    PpUserBlock->PoolBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                                    PpUserBlock->PoolSize,
                                                    PNP_USER_BLOCK_TAG);
    if (PpUserBlock->PoolBuffer == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        PpUserBlock->PoolSize = 0;
        goto Clean0;
    }

    KeInitializeEvent(&PpUserBlock->Registered, SynchronizationEvent, FALSE);
    KeInitializeEvent(&PpUserBlock->NotifyUserEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&PpUserBlock->UserResultEvent, SynchronizationEvent, FALSE);
    ExInitializeResourceLite(&PpUserBlock->Lock);
    // PpUserBlock->Status = STATUS_SUCCESS;
    // PpUserBlock->Result = 0;
    // PpUserBlock->EventBuffer = NULL;
    // PpUserBlock->EventBufferSize = 0;
    // PpUserBlock->PoolUsed = 0;

    ExInitializeFastMutex(&PiNotificationInProgressLock);

Clean0:

    return status;

} // PpInitializeNotification


NTSTATUS
PiInsertEventInQueue(
    IN PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    )
{
    PWORK_QUEUE_ITEM workItem;
    NTSTATUS status;

    PAGED_CODE();

    workItem = NULL;
    status = STATUS_SUCCESS;

#if DBG
    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiInsertEventInQueue: Event queued\n"));
    DumpPnpEvent(&DeviceEvent->Data);
#endif

    //
    // Check if a new work item needs to be kicked off. A new work item gets
    // kicked off iff this is the first event in the list.
    //
    ExAcquireFastMutex(&PpDeviceEventList->Lock);
    ExAcquireFastMutex(&PiNotificationInProgressLock);

    if (!PiNotificationInProgress) {

        workItem = ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(WORK_QUEUE_ITEM),
                                         PNP_DEVICE_WORK_ITEM_TAG);
        if (workItem) {

            PiNotificationInProgress = TRUE;
            KeClearEvent(&PiEventQueueEmpty);
        } else {

            IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                       "PiInsertEventInQueue: Could not allocate memory to kick off a worker thread\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiInsertEventInQueue: Worker thread already running\n"));
    }
    //
    // Insert the event iff successfull so far.
    //
    InsertTailList(&PpDeviceEventList->List, &DeviceEvent->ListEntry);

    ExReleaseFastMutex(&PiNotificationInProgressLock);
    ExReleaseFastMutex(&PpDeviceEventList->Lock);
    //
    // Queue the work item if any.
    //
    if (workItem) {

        ExInitializeWorkItem(workItem, PiWalkDeviceList, workItem);
        ExQueueWorkItem(workItem, DelayedWorkQueue);

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiInsertEventInQueue: Kicked off worker thread\n"));
    }

    return status;
}


NTSTATUS
PpSetDeviceClassChange(
    IN CONST GUID *EventGuid,
    IN CONST GUID *ClassGuid,
    IN PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine is called by user-mode pnp manager and drivers (indirectly) to
    submit device interface change events into a serialized asynchronous queue.
    This queue is processed by a work item.

Arguments:

    EventGuid - Indicates what event is triggered has occured.

    ClassGuid - Indicates the class of the device interface that changed.

    SymbolicLinkName - Specifies the symbolic link name associated with the
                interface device.


Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

#if DBG
    {
        CHAR    eventGuidString[80];
        CHAR    classGuidString[80];

        LookupGuid(EventGuid, eventGuidString, sizeof(eventGuidString));
        LookupGuid(ClassGuid, classGuidString, sizeof(classGuidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PpSetDeviceClassChange: Entered\n    EventGuid = %s\n    ClassGuid = %s\n    SymbolicLinkName = %wZ\n",
                   eventGuidString,
                   classGuidString,
                   SymbolicLinkName));

    }
#endif

    try {

        ASSERT(EventGuid != NULL);
        ASSERT(ClassGuid != NULL);
        ASSERT(SymbolicLinkName != NULL);

        //
        // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
        // we record in the TotalSize field later (the length doesn't count the
        // terminating null but we're already counting the first index into the
        // SymbolicLinkName field so it works out.
        //

        dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) + SymbolicLinkName->Length;
        totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

        deviceEvent = ExAllocatePoolWithTag( PagedPool,
                                             totalSize,
                                             PNP_DEVICE_EVENT_ENTRY_TAG);
        if (deviceEvent == NULL) {
            status = STATUS_NO_MEMORY;
            goto Clean0;
        }

        RtlZeroMemory((PVOID)deviceEvent, totalSize);
        RtlCopyMemory(&deviceEvent->Data.EventGuid, EventGuid, sizeof(GUID));

        deviceEvent->Data.EventCategory = DeviceClassChangeEvent;
        //deviceEvent->Data.Result = NULL;
        //deviceEvent->Data.Flags = 0;
        deviceEvent->Data.TotalSize = dataSize;

        RtlCopyMemory(&deviceEvent->Data.u.DeviceClass.ClassGuid, ClassGuid, sizeof(GUID));
        RtlCopyMemory(&deviceEvent->Data.u.DeviceClass.SymbolicLinkName,
                      SymbolicLinkName->Buffer,
                      SymbolicLinkName->Length);
        deviceEvent->Data.u.DeviceClass.SymbolicLinkName[SymbolicLinkName->Length/sizeof(WCHAR)] = 0x0;

        status = PiInsertEventInQueue(deviceEvent);

Clean0:
            ;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                   "PpSetDeviceClassChange: Exception 0x%08X\n", GetExceptionCode()));
    }

    return status;

} // PpSetDeviceClassChange


NTSTATUS
PpSetCustomTargetEvent(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PKEVENT SyncEvent                           OPTIONAL,
    OUT PULONG Result                               OPTIONAL,
    IN  PDEVICE_CHANGE_COMPLETE_CALLBACK Callback   OPTIONAL,
    IN  PVOID Context                               OPTIONAL,
    IN  PTARGET_DEVICE_CUSTOM_NOTIFICATION NotificationStructure
    )

/*++

Routine Description:

    This routine is called by user-mode pnp manager and drivers (indirectly) to
    submit target device change events into a serialized asynchronous queue.
    This queue is processed by a work item.

Arguments:

    DeviceObject - Indicates the device object for the device that changed.

    SyncEvent - Optionally, specifies a kernel-mode event that will be set when the
            event is finished processing.

    Result - Supplies a pointer to a ULONG that will be filled in with the status
            after the event has actual completed (notification finished and the
            event processed). This value is not used when SyncEvent is NULL and
            is REQUIRED when SyncEvent is supplied.

    NotificationStructure - Specifies the custom Notification to be processed.

Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(NotificationStructure != NULL);
    ASSERT(DeviceObject != NULL);

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpSetCustomTargetEvent: DeviceObject = 0x%p, SyncEvent = 0x%p, Result = 0x%p\n",
               DeviceObject,
               SyncEvent,
               Result));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    Callback = 0x%p, Context = 0x%p, NotificationStructure = 0x%p\n",
               Callback,
               Context,
               NotificationStructure));

    if (SyncEvent) {
        ASSERT(Result);
        *Result = STATUS_PENDING;
    }

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);

    //
    // This is a custom event block, so build up the PLUGPLAY_EVENT_BLOCK
    // but copy the Notification Structure and put that in the EventBlock
    // so we can dig it out in the handler later
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) + deviceNode->InstancePath.Length + sizeof(UNICODE_NULL);

    //
    // We need to ensure that the Notification structure remains aligned
    // so round up dataSize to a multiple of sizeof(PVOID).
    //

    dataSize += sizeof(PVOID) - 1;
    dataSize &= ~(sizeof(PVOID) - 1);
    dataSize += NotificationStructure->Size;

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    deviceEvent->CallerEvent = SyncEvent;
    deviceEvent->Callback = Callback;
    deviceEvent->Context = Context;
    deviceEvent->Data.EventGuid = GUID_PNP_CUSTOM_NOTIFICATION;
    deviceEvent->Data.EventCategory = CustomDeviceEvent;
    deviceEvent->Data.Result = Result;
    deviceEvent->Data.Flags = 0;
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.CustomNotification.DeviceIds,
                      (PVOID)deviceNode->InstancePath.Buffer,
                      deviceNode->InstancePath.Length);

        //
        // No need to NUL terminate this string since we initially zeroed the
        // buffer after allocation.
        //
    }

    //
    // Point the custom notification block to the extra space at the
    // end of the allocation
    //

    deviceEvent->Data.u.CustomNotification.NotificationStructure =
         (PVOID)((PUCHAR)deviceEvent + totalSize - NotificationStructure->Size);

    RtlCopyMemory(deviceEvent->Data.u.CustomNotification.NotificationStructure,
                  NotificationStructure,
                  NotificationStructure->Size);

    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetCustomTargetEvent

NTSTATUS
PpSetTargetDeviceRemove(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  BOOLEAN KernelInitiated,
    IN  BOOLEAN NoRestart,
    IN  BOOLEAN DoEject,
    IN  ULONG Problem,
    IN  PKEVENT SyncEvent           OPTIONAL,
    OUT PULONG Result               OPTIONAL,
    OUT PPNP_VETO_TYPE VetoType     OPTIONAL,
    OUT PUNICODE_STRING VetoName    OPTIONAL
    )

/*++

Routine Description:

    This routine is called by user-mode pnp manager and drivers (indirectly) to
    submit target device change events into a serialized asynchronous queue.
    This queue is processed by a work item.

Arguments:

    EventGuid - Indicates what event is triggered has occured.

    DeviceObject - Indicates the device object for the device that changed.

    SyncEvent - Optionally, specifies a kernel-mode event that will be set when the
            event is finished processing.

    Result - Supplies a pointer to a ULONG that will be filled in with the status
            after the event has actual completed (notification finished and the
            event processed). This value is not used when SyncEvent is NULL and
            is REQUIRED when SyncEvent is supplied.

    Flags - Current can be set to the following flags (bitfields)
                TDF_PERFORMACTION
                TDF_DEVICEEJECTABLE.

    NotificationStructure - If present, implies that EventGuid is NULL, and specifies
            a custom Notification to be processed. By definition it cannot be an event of
            type GUID_TARGET_DEVICE_QUERY_REMOVE, GUID_TARGET_DEVICE_REMOVE_CANCELLED, or
            GUID_TARGET_DEVICE_REMOVE_COMPLETE.


Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    if (SyncEvent) {
        ASSERT(Result);
        *Result = STATUS_PENDING;
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpSetTargetDeviceRemove: Entered\n"));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    DeviceObject = 0x%p, NoRestart = %d, Problem = %d\n",
               DeviceObject,
               NoRestart,
               Problem));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    SyncEvent = 0x%p, Result = 0x%p\n",
               SyncEvent,
               Result));

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);


    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field so it works out. Add one more for double-null term.
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    dataSize += deviceNode->InstancePath.Length + sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory((PVOID)deviceEvent, totalSize);

    deviceEvent->CallerEvent = SyncEvent;
    deviceEvent->Argument = Problem;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;
    deviceEvent->Data.EventGuid = DoEject ? GUID_DEVICE_EJECT : GUID_DEVICE_QUERY_AND_REMOVE;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = Result;

    if (NoRestart) {
        deviceEvent->Data.Flags |= TDF_NO_RESTART;
    }

    if (KernelInitiated) {
        deviceEvent->Data.Flags |= TDF_KERNEL_INITIATED;
    }

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.TargetDevice.DeviceIds,
                    (PVOID)deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length);
    }

    i = deviceNode->InstancePath.Length/sizeof(WCHAR);
    deviceEvent->Data.u.TargetDevice.DeviceIds[i] = L'\0';

    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetTargetDeviceRemove


NTSTATUS
PpSetDeviceRemovalSafe(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PKEVENT SyncEvent           OPTIONAL,
    OUT PULONG Result               OPTIONAL
    )

/*++

Routine Description:

    This routine is called to notify user mode a device can be removed. The IO
    system may queue this event when a hardware initiated eject has completed.

Arguments:

    DeviceObject - Indicates the device object for the device that changed.

    SyncEvent - Optionally, specifies a kernel-mode event that will be set when the
            event is finished processing.

    Result - Supplies a pointer to a ULONG that will be filled in with the status
            after the event has actual completed (notification finished and the
            event processed). This value is not used when SyncEvent is NULL and
            is REQUIRED when SyncEvent is supplied.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    if (SyncEvent) {
        ASSERT(Result);
        *Result = STATUS_PENDING;
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpSetDeviceRemovalSafe: Entered\n"));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    DeviceObject = 0x%p, SyncEvent = 0x%p, Result = 0x%p\n",
               DeviceObject,
               SyncEvent,
               Result));

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);


    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field so it works out. Add one more for double-null term.
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    dataSize += deviceNode->InstancePath.Length + sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory((PVOID)deviceEvent, totalSize);

    deviceEvent->CallerEvent = SyncEvent;
    deviceEvent->Argument = 0;
    deviceEvent->VetoType = NULL;
    deviceEvent->VetoName = NULL;
    deviceEvent->Data.EventGuid = GUID_DEVICE_SAFE_REMOVAL;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = Result;
    deviceEvent->Data.Flags = 0;

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.TargetDevice.DeviceIds,
                    (PVOID)deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length);
    }

    i = deviceNode->InstancePath.Length/sizeof(WCHAR);
    deviceEvent->Data.u.TargetDevice.DeviceIds[i] = L'\0';

    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetDeviceRemovalSafe


NTSTATUS
PpSetHwProfileChangeEvent(
    IN   GUID CONST *EventTypeGuid,
    IN   PKEVENT CompletionEvent    OPTIONAL,
    OUT  PNTSTATUS CompletionStatus OPTIONAL,
    OUT  PPNP_VETO_TYPE VetoType    OPTIONAL,
    OUT  PUNICODE_STRING VetoName   OPTIONAL
    )
{
    ULONG dataSize,totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

#if DBG
    {
        CHAR    eventGuidString[80];

        LookupGuid(EventTypeGuid, eventGuidString, sizeof(eventGuidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PpSetHwProfileChangeEvent: Entered\n    EventGuid = %s\n\n",
                   eventGuidString));
    }
#endif

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    dataSize =  sizeof(PLUGPLAY_EVENT_BLOCK);

    totalSize = dataSize + FIELD_OFFSET (PNP_DEVICE_EVENT_ENTRY,Data);



    deviceEvent = ExAllocatePoolWithTag (PagedPool,
                                          totalSize,
                                          PNP_DEVICE_EVENT_ENTRY_TAG);

    if (NULL == deviceEvent) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent,totalSize);
    deviceEvent->CallerEvent = CompletionEvent;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;

    deviceEvent->Data.EventCategory = HardwareProfileChangeEvent;
    RtlCopyMemory(&deviceEvent->Data.EventGuid, EventTypeGuid, sizeof(GUID));
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.Result = (PULONG)CompletionStatus;

    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetHwProfileChangeEvent


NTSTATUS
PpSetBlockedDriverEvent(
    IN   GUID CONST *BlockedDriverGuid
    )

/*++

Routine Description:

    This routine is called to notify user mode of blocked driver events.

Arguments:

    BlockedDriverGuid - Specifies the GUID which identifies the blocked driver.

Return Value:

    Returns the status of inserting the event into the synchronized pnp event
    queue.

--*/

{
    ULONG dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    NTSTATUS status;

    PAGED_CODE();

    if (PpPnpShuttingDown) {
        return STATUS_TOO_LATE;
    }

    //
    // Allocate a device event entry.
    //
    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);
    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent, totalSize);
    deviceEvent->Data.EventGuid = GUID_DRIVER_BLOCKED;
    deviceEvent->Data.EventCategory = BlockedDriverEvent;
    deviceEvent->Data.TotalSize = dataSize;
    RtlCopyMemory(&deviceEvent->Data.u.BlockedDriverNotification.BlockedDriverGuid,
                  BlockedDriverGuid,
                  sizeof(GUID));

    //
    // Insert the event into the queue.
    //
    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetBlockedDriverEvent



NTSTATUS
PpSetPowerEvent(
    IN   ULONG EventCode,
    IN   ULONG EventData,
    IN   PKEVENT CompletionEvent    OPTIONAL,
    OUT  PNTSTATUS CompletionStatus OPTIONAL,
    OUT  PPNP_VETO_TYPE VetoType    OPTIONAL,
    OUT  PUNICODE_STRING VetoName   OPTIONAL
    )
/*++

Routine Description:

    This routine is called to notify user mode of system-wide power events.

Arguments:

    EventCode - Supplies the power event code that is to be communicated
            to user-mode components.

            (Specifically, this event code is actually one of the PBT_APM*
            user-mode power event ids, as defined in sdk\inc\winuser.h.  It is
            typically used as the WPARAM data associated with WM_POWERBROADCAST
            user-mode window messages.  It is supplied to kernel-mode PnP,
            directly from win32k, for the explicit purpose of user-mode power
            event notification.)

    EventData - Specifies additional event-specific data for the specified
            power event id.

            (Specifically, this event data is the LPARAM data for the
            corresponding PBT_APM* user-mode power event id, specified above.)

    CompletionEvent - Optionally, specifies a kernel-mode event that will be set when the
            event is finished processing.

    CompletionStatus - Supplies a pointer to a ULONG that will be filled in with the status
            after the event has actual completed (notification finished and the
            event processed). This value is not used when SyncEvent is NULL and
            is REQUIRED when SyncEvent is supplied.


    VetoType - Optionally, if the specified EventCode is a query-type operation,
            this argument supplies a pointer to an address that will receive the
            type of the vetoing user-mode component, in the event that the
            request is denied.

    VetoName - Optionally, if the specified EventCode is a query-type operation,
            this argument supplies a pointer to a UNICODE_STRING that will
            receive the name of the vetoing user-mode component, in the event
            that the request is denied.


Return Value:

    Returns the status of inserting the event into the synchronized pnp event
    queue.

    For the final status of a synchronous power event, check the value at the
    location specified by CompletionStatus, once the supplied CompletionEvent
    has been set.

--*/

{
    ULONG dataSize,totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    NTSTATUS status = STATUS_SUCCESS;



    PAGED_CODE();

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpSetPowerEvent: Entered\n\n") );

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    dataSize =  sizeof(PLUGPLAY_EVENT_BLOCK);

    totalSize = dataSize + FIELD_OFFSET (PNP_DEVICE_EVENT_ENTRY,Data);

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);

    if (NULL == deviceEvent) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    //Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent,totalSize);
    deviceEvent->CallerEvent = CompletionEvent;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;

    deviceEvent->Data.EventCategory = PowerEvent;
    deviceEvent->Data.EventGuid = GUID_PNP_POWER_NOTIFICATION;
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.Result = (PULONG)CompletionStatus;
    deviceEvent->Data.u.PowerNotification.NotificationCode = EventCode;
    deviceEvent->Data.u.PowerNotification.NotificationData = EventData;

    status = PiInsertEventInQueue(deviceEvent);

    return status;
} // PpSetPowerEvent

NTSTATUS
PpSetPowerVetoEvent(
    IN  POWER_ACTION    VetoedPowerOperation,
    IN  PKEVENT         CompletionEvent         OPTIONAL,
    OUT PNTSTATUS       CompletionStatus        OPTIONAL,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PNP_VETO_TYPE   VetoType,
    IN  PUNICODE_STRING VetoName                OPTIONAL
    )
/*++

--*/
{
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PDEVICE_NODE deviceNode;
    PWCHAR vetoData;
    NTSTATUS status;

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //
    ObReferenceObject(DeviceObject);

    //
    // Given the pdo, retrieve the devnode (the device instance string is
    // attached to the devnode in the InstancePath field).
    //

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {

        ObDereferenceObject(DeviceObject);
        return STATUS_INVALID_PARAMETER_2;
    }

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (because of the first index into
    // the DeviceIdVetoNameBuffer, this is double null terminated).
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) +
               deviceNode->InstancePath.Length +
               (VetoName ? VetoName->Length : 0) +
               sizeof(WCHAR)*2;

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);

    if (deviceEvent == NULL) {

        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    deviceEvent->CallerEvent = CompletionEvent;

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;
    deviceEvent->Data.Result = (PULONG)CompletionStatus;
    deviceEvent->Data.u.VetoNotification.VetoType = VetoType;

    //
    // You can think of this as a MultiSz string where the first entry is the
    // DeviceId for the device being removed, and the next Id's all corrospond
    // to the vetoers.
    //
    RtlCopyMemory(
        deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer,
        deviceNode->InstancePath.Buffer,
        deviceNode->InstancePath.Length
        );

    i = deviceNode->InstancePath.Length;
    deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)] = UNICODE_NULL;

    if (VetoName) {

        vetoData = (&deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)])+1;

        RtlCopyMemory(vetoData, VetoName->Buffer, VetoName->Length);
        vetoData[VetoName->Length/sizeof(WCHAR)] = UNICODE_NULL;
    }

    //
    // No need to NULL terminate the entry after the last one as we prezero'd
    // the buffer. Now set the appropriate GUID so the UI looks right.
    //
    if (VetoedPowerOperation == PowerActionWarmEject) {

        deviceEvent->Data.EventGuid = GUID_DEVICE_WARM_EJECT_VETOED;

    } else if (VetoedPowerOperation == PowerActionHibernate) {

        deviceEvent->Data.EventGuid = GUID_DEVICE_HIBERNATE_VETOED;

    } else {

        deviceEvent->Data.EventGuid = GUID_DEVICE_STANDBY_VETOED;
    }

    deviceEvent->Data.EventCategory = VetoEvent;

    status = PiInsertEventInQueue(deviceEvent);

    return status;
}

VOID
PpSetPlugPlayEvent(
    IN CONST GUID *EventGuid,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine allows kernel mode enumerator to inform Plug and Play Manager
    on the events triggered by enumeration, i.e., DeviceArrived and DeviceRemoved.
    The PnP manager can then inform user-mode about the event.

Arguments:

    EventId - Indicates what event is triggered by enumeration.


Return Value:

    None.

--*/

{
    ULONG       dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(EventGuid != NULL);
    ASSERT(DeviceObject != NULL);

#if DBG
    {
        CHAR    eventGuidString[80];

        LookupGuid(EventGuid, eventGuidString, sizeof(eventGuidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PpSetPlugPlayEvent: Entered\n    EventGuid = %s\n",
                   eventGuidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceObject = 0x%p\n",
                   DeviceObject));
    }
#endif

    if (PpPnpShuttingDown) {

        return;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    //
    // Given the pdo, retrieve the devnode (the device instance string is
    // attached to the devnode in the InstancePath field).
    //

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        ObDereferenceObject(DeviceObject);
        return;
    }

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field. also include a final terminating null, in case this is
    // a TargetDevice event, where DeviceIds is a multi-sz list).
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) + deviceNode->InstancePath.Length + sizeof(WCHAR);
    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    RtlCopyMemory(&deviceEvent->Data.EventGuid, EventGuid, sizeof(GUID));
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (PiCompareGuid(EventGuid, &GUID_DEVICE_ENUMERATED)) {
        //
        // GUID_DEVICE_ENUMERATED events are device installation requests for
        // user-mode, and are sent using the DeviceInstallEvent event type.
        //
        deviceEvent->Data.EventCategory = DeviceInstallEvent;
        RtlCopyMemory(&deviceEvent->Data.u.InstallDevice.DeviceId,
                      deviceNode->InstancePath.Buffer,
                      deviceNode->InstancePath.Length);
        deviceEvent->Data.u.InstallDevice.DeviceId[deviceNode->InstancePath.Length/sizeof(WCHAR)] = 0x0;
    } else {
        //
        // All other target events are sent using the TargetDeviceChangeEvent
        // event type, and are distinguished by the EventGuid.  Note that
        // DeviceIds is a multi-sz list.
        //
        deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
        RtlCopyMemory(&deviceEvent->Data.u.TargetDevice.DeviceIds,
                      deviceNode->InstancePath.Buffer,
                      deviceNode->InstancePath.Length);
        deviceEvent->Data.u.TargetDevice.DeviceIds[deviceNode->InstancePath.Length/sizeof(WCHAR)] = 0x0;
        deviceEvent->Data.u.TargetDevice.DeviceIds[deviceNode->InstancePath.Length/sizeof(WCHAR)+1] = 0x0;
    }

    PiInsertEventInQueue(deviceEvent);

    return;

} // PpSetPlugPlayEvent

NTSTATUS
PpSynchronizeDeviceEventQueue(
    VOID
    )
{
    NTSTATUS                status;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    KEVENT                  event;
    ULONG                   result;

    PAGED_CODE();

    //
    // Note this is the only queuing function which is valid when PpShuttingDown
    // is TRUE.
    //

    deviceEvent = ExAllocatePoolWithTag( PagedPool,
                                         sizeof(PNP_DEVICE_EVENT_ENTRY),
                                         PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        return STATUS_NO_MEMORY;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    RtlZeroMemory((PVOID)deviceEvent, sizeof(PNP_DEVICE_EVENT_ENTRY));

    deviceEvent->CallerEvent = &event;
    deviceEvent->Data.EventGuid = GUID_DEVICE_NOOP;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = &result;
    deviceEvent->Data.TotalSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    status = PiInsertEventInQueue(deviceEvent);

    if (NT_SUCCESS(status)) {
        status = KeWaitForSingleObject( &event,
                                        Executive,
                                        KernelMode,
                                        FALSE,       // not alertable
                                        0);          // infinite
    }

    return status;
}


VOID
PiWalkDeviceList(
    IN PVOID Context
    )

/*++

Routine Description:

    If the master device list contains any device events, empty the list now.
    This is a worker item thread routine (queued by PiPostNotify). We walk the
    list - this will cause the oldest device event on the list to be sent to
    all registered recipients and then the device event will be removed (if at
    least one recipient received it).

    Order Rules:
        Interface Devices - kernel mode first, user-mode second
        Hardware profile changes - user-mode first, kernel-mode second
        Target device changes (query remove, remove) : user-mode first, send
        (cancel remove)        : kernel-mode first, post
        (custom)               : kernel-mode first, post

Arguments:

    NONE.

Return Value:

    NONE.

--*/

{
    NTSTATUS  status;
    PPNP_DEVICE_EVENT_ENTRY  deviceEvent;
    PLIST_ENTRY current;
    UNICODE_STRING tempString;

    PAGED_CODE();

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiWalkDeviceList: Worker thread entered\n"));

    //
    // Empty the device event list, remove entries from the head of the list
    // (deliver oldest entries first).
    //

    status = KeWaitForSingleObject(&PpDeviceEventList->EventQueueMutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,       // not alertable
                                   0);          // infinite
    if (!NT_SUCCESS(status)) {
        ExAcquireFastMutex(&PiNotificationInProgressLock);
        KeSetEvent(&PiEventQueueEmpty, 0, FALSE);
        PiNotificationInProgress = FALSE;
        ExReleaseFastMutex(&PiNotificationInProgressLock);
        return;
    }

    for ( ; ; ) {
        ExAcquireFastMutex(&PpDeviceEventList->Lock);
        if (!IsListEmpty(&PpDeviceEventList->List)) {
            current = RemoveHeadList(&PpDeviceEventList->List);
            ExReleaseFastMutex(&PpDeviceEventList->Lock);

            deviceEvent = CONTAINING_RECORD(current,                // address
                                            PNP_DEVICE_EVENT_ENTRY, // type
                                            ListEntry);             // field

#if DBG
            {
                CHAR    guidString[256];

                LookupGuid(&deviceEvent->Data.EventGuid, guidString, sizeof(guidString));

                IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                           "PiWalkDeviceList: Processing queued event - EventGuid = %s\n",
                           guidString));
            }
#endif

            switch (deviceEvent->Data.EventCategory) {

                case DeviceClassChangeEvent: {

                    //
                    // Notify kernel-mode (synchronous).
                    //

                    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                               "PiWalkDeviceList: DeviceClassChangeEvent - notifying kernel-mode\n"));

                    RtlInitUnicodeString(&tempString, deviceEvent->Data.u.DeviceClass.SymbolicLinkName);
                    IopNotifyDeviceClassChange(&deviceEvent->Data.EventGuid,
                                               &deviceEvent->Data.u.DeviceClass.ClassGuid,
                                               &tempString);

                    //
                    // Notify user-mode (synchronous).
                    //

                    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                               "PiWalkDeviceList: DeviceClassChangeEvent - user kernel-mode\n"));

                    PiNotifyUserMode(deviceEvent);

                    status = STATUS_SUCCESS;
                    break;
                }


                case CustomDeviceEvent: {

                    status = PiProcessCustomDeviceEvent(&deviceEvent);
                    break;
                }

                case TargetDeviceChangeEvent: {

                    status = PiProcessTargetDeviceEvent(&deviceEvent);
                    break;
                }

                case DeviceInstallEvent: {

                    //
                    // Notify user-mode (synchronous).
                    //

                    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                               "PiWalkDeviceList: DeviceInstallEvent - notifying user-mode\n"));

                    PiNotifyUserMode(deviceEvent);

                    status = STATUS_SUCCESS;
                    break;
                }

                case HardwareProfileChangeEvent: {

                    //
                    // Notify user-mode (synchronous).
                    //
                    status = PiNotifyUserMode(deviceEvent);

                    if (NT_SUCCESS(status)) {

                        //
                        // Notify K-Mode
                        //
                        IopNotifyHwProfileChange(&deviceEvent->Data.EventGuid,
                                                 deviceEvent->VetoType,
                                                 deviceEvent->VetoName);
                    }
                    break;
                }
                case PowerEvent: {

                    //
                    // Notify user-mode (synchronous).
                    //
                    status = PiNotifyUserMode(deviceEvent);
                    break;
                }

                case VetoEvent: {

                    //
                    // Forward onto user-mode.
                    //
                    status = PiNotifyUserMode(deviceEvent);
                    break;
                }

                case BlockedDriverEvent: {

                    //
                    // Forward onto user-mode.
                    //
                    status = PiNotifyUserMode(deviceEvent);
                    break;
                }

                default: {

                    //
                    // These should never be queued to kernel mode. They are
                    // notifications for user mode, and should only be seen
                    // through the PiNotifyUserModeXxx functions.
                    //
                    ASSERT(0);
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }

            if (status != STATUS_PENDING) {

                PpCompleteDeviceEvent(deviceEvent, status);
            }

            //
            // Commit pending registrations after processing each event.
            //
            IopProcessDeferredRegistrations();

        } else {
            ExAcquireFastMutex(&PiNotificationInProgressLock);
            KeSetEvent(&PiEventQueueEmpty, 0, FALSE);
            PiNotificationInProgress = FALSE;

            //
            // Commit pending registrations after processing all queued events.
            //
            IopProcessDeferredRegistrations();

            ExReleaseFastMutex(&PiNotificationInProgressLock);
            ExReleaseFastMutex(&PpDeviceEventList->Lock);
            break;
        }
    }
    if (Context != NULL) {
        ExFreePool(Context);
    }
    KeReleaseMutex(&PpDeviceEventList->EventQueueMutex, FALSE);
    return;
} // PiWalkDeviceList


VOID
PpCompleteDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY  DeviceEvent,
    IN     NTSTATUS                 FinalStatus
    )

/*++

Routine Description:


Arguments:

    DeviceEvent     - Event to complete.
    FinalStatus     - Final status for this event.

Return Value:

    NONE.

--*/

{
#if DBG
    CHAR guidString[256];
#endif

    PAGED_CODE();

#if DBG
    LookupGuid(&DeviceEvent->Data.EventGuid, guidString, sizeof(guidString));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpCompleteDeviceEvent: Completing queued event - EventGuid = %s with %08lx\n",
               guidString,
               FinalStatus));
#endif

    //
    // If synchronous, signal the user-supplied event.
    //

    if (DeviceEvent->CallerEvent) {
        *DeviceEvent->Data.Result = FinalStatus;
        KeSetEvent(DeviceEvent->CallerEvent, 0, FALSE);
    }

    if (DeviceEvent->Callback) {
        DeviceEvent->Callback(DeviceEvent->Context);
    }

    //
    // Release the reference we took for this device object during
    // the PpSetCustomTargetEvent call.
    //
    if (DeviceEvent->Data.DeviceObject != NULL) {
        ObDereferenceObject(DeviceEvent->Data.DeviceObject);
    }

    //
    // Assume device event was delivered successfully, get rid of it.
    //

    ExFreePool(DeviceEvent);
    return;
} // PpCompleteDeviceEvent


NTSTATUS
PiNotifyUserMode(
    PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    )

/*++

Routine Description:

    This routine dispatches the device event to user-mode for processing.

Arguments:

    DeviceEvent - Data describing what change and how.

Return Value:

    Retuns an NTSTATUS value.

--*/

{
    NTSTATUS status = STATUS_SUCCESS, status1 = STATUS_SUCCESS;

    PAGED_CODE();

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiNotifyUserMode: Entered\n"));

    //
    // First make sure user-mode is up and running before attempting to deliver
    // an event. If not running yet, skip user-mode for this event.
    //

    if (UserModeRunning) {


        //
        // User-mode notification is a single-shot model, once user-mode is
        // running, I need to wait until user-mode is ready to take the next
        // event (i.e, wait until we're sitting in another NtGetPlugPlayEvent
        // call).
        //

        status1 = KeWaitForSingleObject(&PpUserBlock->Registered,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        ASSERT (PpUserBlock->Deferred == FALSE);


        //
        // Change the status after the wait.
        //
        PpUserBlock->Status = STATUS_SUCCESS;

        if (NT_SUCCESS(status1)) {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiNotifyUserMode: User-mode ready\n"));

            //
            // Make sure we can handle it in the pool buffer and copy it out
            //
            if (PpUserBlock->PoolSize <  DeviceEvent->Data.TotalSize) {
                //
                //Allocate a new block (well, conceptually grow the block)
                // only when it's not big enough, so that we know we've always got
                // room for normal events, and in the very low memory case, we can
                // fail custom events, but keep the system running
                //
                PVOID pHold;


                pHold = ExAllocatePoolWithTag(NonPagedPool,
                                              DeviceEvent->Data.TotalSize,
                                              PNP_POOL_EVENT_BUFFER);

                if (!pHold) {
                    IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                               "PiNotifyUserMode: Out of NonPagedPool!!\n"));

                    PpUserBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                PpUserBlock->PoolSize = DeviceEvent->Data.TotalSize;

                ExFreePool (PpUserBlock->PoolBuffer );
                PpUserBlock->PoolBuffer = pHold;

            }

            PpUserBlock->PoolUsed = DeviceEvent->Data.TotalSize;
            RtlCopyMemory(PpUserBlock->PoolBuffer,
                          &DeviceEvent->Data,
                          PpUserBlock->PoolUsed);

        }

        //
        // Veto information is only propogated where needed, ie
        // QUERY_REMOVE's, Profile change requests and PowerEvents.
        //
        if (PiCompareGuid(&DeviceEvent->Data.EventGuid,
                          &GUID_TARGET_DEVICE_QUERY_REMOVE) ||
            PiCompareGuid(&DeviceEvent->Data.EventGuid,
                          &GUID_HWPROFILE_QUERY_CHANGE) ||
            PiCompareGuid(&DeviceEvent->Data.EventGuid,
                          &GUID_DEVICE_KERNEL_INITIATED_EJECT) ||
            (DeviceEvent->Data.EventCategory == PowerEvent)) {

            PpUserBlock->VetoType = DeviceEvent->VetoType;
            PpUserBlock->VetoName = DeviceEvent->VetoName;
        } else {
            PpUserBlock->VetoType = NULL;
            PpUserBlock->VetoName = NULL;
        }

        //
        // Set the system event that causes NtGetPlugPlayEvent to return to caller.
        //

        KeSetEvent(&PpUserBlock->NotifyUserEvent, 0, FALSE);


        //
        // Wait until we get an answer back from user-mode.
        //

        status1 = KeWaitForSingleObject(&PpUserBlock->UserResultEvent,
                                        Executive,
                                        KernelMode,
                                        TRUE,
                                        NULL);

        //
        // Check the result from this user-mode notification.
        //

        if (status1 == STATUS_ALERTED || status1 == STATUS_SUCCESS) {
            if (!PpUserBlock->Result) {

                //
                // For query-remove case, any errors are treated as a
                // failure during notification (since it may result in our
                // inability to let a registered caller vote in the query-remove)
                // and the PpUserBlock->Result is set accordingly.
                //

                //
                // Note! User mode ONLY returns a 0 or !0 response.
                // if 1 then it succeeded.
                //

                status = STATUS_UNSUCCESSFUL;
            }
        }

        PpUserBlock->VetoType = NULL;
        PpUserBlock->VetoName = NULL;
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiNotifyUserMode: User-mode returned, status = 0x%08X, status1 = 0x%08X, Result = 0x%08X\n",
               status,
               status1,
               PpUserBlock->Result));

    return status;

} // PiNotifyUserMode



VOID
PiUserResponse(
    IN ULONG            Response,
    IN PNP_VETO_TYPE    VetoType,
    IN LPWSTR           VetoName,
    IN ULONG            VetoNameLength
    )

/*++

Routine Description:

    This routine is called when user-mode pnp manager is signalling that it's
    done processing an event; the result of the event processing is passed in
    the Response parameter.

Arguments:

    Response - Result of event processing in user-mode.

Return Value:

    None.

--*/

{
    UNICODE_STRING vetoString;

    PAGED_CODE();

    PpUserBlock->Result = Response;

    if (PpUserBlock->VetoType != NULL) {
        *PpUserBlock->VetoType = VetoType;
    }

    if (PpUserBlock->VetoName != NULL)  {
        ASSERT(VetoNameLength == (USHORT)VetoNameLength);

        vetoString.MaximumLength = (USHORT)VetoNameLength;
        vetoString.Length = (USHORT)VetoNameLength;
        vetoString.Buffer = VetoName;
        RtlCopyUnicodeString(PpUserBlock->VetoName, &vetoString);
    }

    KeSetEvent(&PpUserBlock->UserResultEvent, 0, FALSE);

} // PiUserResponse


NTSTATUS
PiNotifyUserModeDeviceRemoval(
    IN  PPNP_DEVICE_EVENT_ENTRY TemplateDeviceEvent,
    IN  CONST GUID              *EventGuid,
    OUT PPNP_VETO_TYPE          VetoType                OPTIONAL,
    OUT PUNICODE_STRING         VetoName                OPTIONAL
    )
/*++

Routine Description:

    This routine tells user mode to perform a specific device removal
    operation.

Arguments:

    TemplateDeviceEvent - Device event containing information about the
                          intended event (includes a list of devices.) The
                          event is temporarily used by this function, and is
                          restored before this function returns.

    EventGuid - Points to the event user mode should process:
        GUID_TARGET_DEVICE_QUERY_REMOVE
        GUID_TARGET_DEVICE_REMOVE_CANCELLED
        GUID_DEVICE_REMOVE_PENDING
        GUID_TARGET_DEVICE_REMOVE_COMPLETE
        GUID_DEVICE_SURPRISE_REMOVAL

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    GUID oldGuid;
    PPNP_VETO_TYPE oldVetoType;
    PUNICODE_STRING oldVetoName;
#if DBG
    CHAR guidString[256];
#endif

    PAGED_CODE();

#if DBG
    LookupGuid(EventGuid, guidString, sizeof(guidString));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiNotifyUserModeDeviceRemoval: %s - notifying user-mode\n",
               guidString));
#endif

    //
    // Save the old guid so we can use the template without making a copy. We
    // preserve it so that the removal veto UI can use the original event GUID
    // to let the UI differentiate disables from ejects, etc.
    //
    RtlCopyMemory(&oldGuid, &TemplateDeviceEvent->Data.EventGuid, sizeof(GUID));

    //
    // Do the same with the vetoname and vetobuffer.
    //
    oldVetoType = TemplateDeviceEvent->VetoType;
    oldVetoName = TemplateDeviceEvent->VetoName;

    //
    // Copy in the new data.
    //
    RtlCopyMemory(&TemplateDeviceEvent->Data.EventGuid, EventGuid, sizeof(GUID));
    TemplateDeviceEvent->VetoType = VetoType;
    TemplateDeviceEvent->VetoName = VetoName;

    //
    // Send it.
    //
    status = PiNotifyUserMode(TemplateDeviceEvent);

    //
    // Restore the old info.
    //
    RtlCopyMemory(&TemplateDeviceEvent->Data.EventGuid, &oldGuid, sizeof(GUID));
    TemplateDeviceEvent->VetoType = oldVetoType;
    TemplateDeviceEvent->VetoName = oldVetoName;

    return status;
}

NTSTATUS
PiNotifyUserModeKernelInitiatedEject(
    IN  PDEVICE_OBJECT          DeviceObject,
    OUT PNP_VETO_TYPE          *VetoType,
    OUT PUNICODE_STRING         VetoName
    )

/*++

Routine Description:

    This routine is called to notify user mode a device has a kenel-mode
    initated eject outstanding. UmPnpMgr might decide to veto the event if
    a user with the appropriate permissions hasn't logged on locally.

Arguments:

    DeviceObject - Indicates the device object is to be ejected.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field so it works out. Add one more for double-null term.
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    dataSize += deviceNode->InstancePath.Length + sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory((PVOID)deviceEvent, totalSize);

    deviceEvent->CallerEvent = NULL;
    deviceEvent->Argument = 0;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;
    deviceEvent->Data.EventGuid = GUID_DEVICE_KERNEL_INITIATED_EJECT;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = 0;
    deviceEvent->Data.Flags = 0;

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.TargetDevice.DeviceIds,
                    (PVOID)deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length);
    }

    i = deviceNode->InstancePath.Length/sizeof(WCHAR);

    deviceEvent->Data.u.TargetDevice.DeviceIds[i] = L'\0';

    status = PiNotifyUserMode(deviceEvent);

    ExFreePool(deviceEvent);

    ObDereferenceObject(DeviceObject);

    return status;

} // PiNotifyUserModeKernelInitiatedEject

NTSTATUS
PiNotifyUserModeRemoveVetoed(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PNP_VETO_TYPE            VetoType,
    IN PUNICODE_STRING          VetoName        OPTIONAL
    )
/*++

--*/
{
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PDEVICE_NODE deviceNode;
    PWCHAR vetoData;
    NTSTATUS status;

    //
    // This device should be locked during this operation, but all good designs
    // includes healthy doses of paranoia.
    //
    ObReferenceObject(DeviceObject);

    //
    // Given the pdo, retrieve the devnode (the device instance string is
    // attached to the devnode in the InstancePath field).
    //
    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (because of the first index into
    // the DeviceIdVetoNameBuffer, this is double null terminated).
    //
    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) +
               deviceNode->InstancePath.Length +
               (VetoName ? VetoName->Length : 0) +
               sizeof(WCHAR)*2;

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);

    if (deviceEvent == NULL) {

        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;
    deviceEvent->Data.u.VetoNotification.VetoType = VetoType;

    //
    // You can think of this as a MultiSz string where the first entry is the
    // DeviceId for the device being removed, and the next Id's all corrospond
    // to the vetoers.
    //
    RtlCopyMemory(
        deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer,
        deviceNode->InstancePath.Buffer,
        deviceNode->InstancePath.Length
        );

    i = deviceNode->InstancePath.Length;
    deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)] = UNICODE_NULL;

    if (VetoName) {

        vetoData = (&deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)])+1;

        RtlCopyMemory(vetoData, VetoName->Buffer, VetoName->Length);
        vetoData[VetoName->Length/sizeof(WCHAR)] = UNICODE_NULL;
    }

    //
    // No need to NULL terminate the entry after the last one as we prezero'd
    // the buffer. Now set the appropriate GUID so the UI looks right.
    //
    if (PiCompareGuid(&VetoedDeviceEvent->Data.EventGuid, &GUID_DEVICE_EJECT)) {

        deviceEvent->Data.EventGuid = GUID_DEVICE_EJECT_VETOED;

    } else {

        ASSERT(PiCompareGuid(&VetoedDeviceEvent->Data.EventGuid, &GUID_DEVICE_QUERY_AND_REMOVE));
        deviceEvent->Data.EventGuid = GUID_DEVICE_REMOVAL_VETOED;
    }

    deviceEvent->Data.EventCategory = VetoEvent;

    status = PiNotifyUserMode(deviceEvent);

    ExFreePool(deviceEvent);

    ObDereferenceObject(DeviceObject);
    return status;
}

NTSTATUS
PiNotifyUserModeRemoveVetoedByList(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PNP_VETO_TYPE            VetoType,
    IN PWSTR                    MultiSzVetoList
    )
/*++

--*/
{
    ULONG dataSize, totalSize, i, vetoListLength;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PDEVICE_NODE deviceNode;
    PWCHAR vetoData;
    NTSTATUS status;

    //
    // This device should be locked during this operation, but all good designs
    // includes healthy doses of paranoia.
    //
    ObReferenceObject(DeviceObject);

    //
    // Given the pdo, retrieve the devnode (the device instance string is
    // attached to the devnode in the InstancePath field).
    //

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (because of the first index into
    // the DeviceIdVetoNameBuffer, this is double null terminated).
    //

    for(vetoData = MultiSzVetoList; *vetoData; vetoData += vetoListLength) {

        vetoListLength = (ULONG)(wcslen(vetoData) + 1);
    }

    vetoListLength = ((ULONG)(vetoData - MultiSzVetoList))*sizeof(WCHAR);

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) +
               deviceNode->InstancePath.Length +
               vetoListLength +
               sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);

    if (deviceEvent == NULL) {

        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;
    deviceEvent->Data.u.VetoNotification.VetoType = VetoType;

    //
    // You can think of this as a MultiSz string where the first entry is the
    // DeviceId for the device being removed, and the next Id's all corrospond
    // to the vetoers.
    //
    RtlCopyMemory(
        deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer,
        deviceNode->InstancePath.Buffer,
        deviceNode->InstancePath.Length
        );

    i = deviceNode->InstancePath.Length;
    deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)] = UNICODE_NULL;

    vetoData = (&deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)])+1;

    RtlCopyMemory(vetoData, MultiSzVetoList, vetoListLength);
    vetoData[vetoListLength/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // No need to NULL terminate the entry after the last one as we prezero'd
    // the buffer. Now set the appropriate GUID so the UI looks right.
    //
    if (PiCompareGuid(&VetoedDeviceEvent->Data.EventGuid, &GUID_DEVICE_EJECT)) {

        deviceEvent->Data.EventGuid = GUID_DEVICE_EJECT_VETOED;

    } else {

        ASSERT(PiCompareGuid(&VetoedDeviceEvent->Data.EventGuid, &GUID_DEVICE_QUERY_AND_REMOVE));
        deviceEvent->Data.EventGuid = GUID_DEVICE_REMOVAL_VETOED;
    }

    deviceEvent->Data.EventCategory = VetoEvent;

    status = PiNotifyUserMode(deviceEvent);

    ExFreePool(deviceEvent);

    ObDereferenceObject(DeviceObject);
    return status;
}

NTSTATUS
PpNotifyUserModeRemovalSafe(
    IN  PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called to notify user mode a device can be removed. This
    is similar to PpSetDeviceRemovalSafe except that we are already in a
    kernel mode PnP device event we must complete, from which this function
    will piggyback a notification up to just user mode.

Arguments:

    DeviceObject - Indicates the device object is ready for removal.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);


    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field so it works out. Add one more for double-null term.
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    dataSize += deviceNode->InstancePath.Length + sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory((PVOID)deviceEvent, totalSize);

    deviceEvent->CallerEvent = NULL;
    deviceEvent->Argument = 0;
    deviceEvent->VetoType = NULL;
    deviceEvent->VetoName = NULL;
    deviceEvent->Data.EventGuid = GUID_DEVICE_SAFE_REMOVAL;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = 0;
    deviceEvent->Data.Flags = 0;

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.TargetDevice.DeviceIds,
                    (PVOID)deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length);
    }

    i = deviceNode->InstancePath.Length/sizeof(WCHAR);

    deviceEvent->Data.u.TargetDevice.DeviceIds[i] = L'\0';

    status = PiNotifyUserMode(deviceEvent);

    ExFreePool(deviceEvent);

    ObDereferenceObject(DeviceObject);

    return status;

} // PpNotifyUserModeRemovalSafe


NTSTATUS
PiProcessQueryRemoveAndEject(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    )

/*++

Routine Description:

    This routine processes the various flavours of remove: Eject, SurpriseRemove,
    Remove, and QueryRemove.

    Eject
        Retrieve bus, removal, and eject relations.
        Do queries on all relations
        Send IRP_MN_REMOVE_DEVICE to all the relations.
        Queue the pending eject

        Once the eject happens
            Reenumerate all the indirect relation's parents

    SurpriseRemove
        Retrieve bus, removal, and eject relations.
        Send IRP_MN_SURPRISE_REMOVAL to all the direct relations.
        Notify everyone that the device is gone.
        Reenumerate the parents of all the indirect relations.
        Remove the indirect relations from the relations list.
        Queue the pending surprise removal.

        Once the last handle is closed.

            Send IRP_MN_REMOVE_DEVICE to all the direct relations.

    RemoveFailedDevice
        Retrieve bus and removal relations.
        Notify everyone that the device is going.
        Reenumerate the parents of all the indirect relations.
        Remove the indirect relations from the relations list.
        Queue as a pending surprise removal.

        Once the last handle is closed.

            Send IRP_MN_REMOVE_DEVICE to all the direct relations.

    RemoveUnstartedFailedDevice
        Retrieve bus relations.
        Notify everyone that the device is going.
        Send IRP_MN_REMOVE_DEVICE to all the direct relations.

    Remove
        Use the relations from the last QueryRemove or retrieve new bus, removal,
        and eject relations if the device wasn't already QueryRemoved.
        Send IRP_MN_REMOVE_DEVICE to all the relations.

Arguments:

    Response - Result of event processing in user-mode.

Return Value:

    NTSTATUS code.

--*/

{
    PPNP_DEVICE_EVENT_ENTRY         deviceEvent, tempDeviceEvent;
    PPNP_DEVICE_EVENT_ENTRY         surpriseRemovalEvent;
    PLUGPLAY_DEVICE_DELETE_TYPE     deleteType;
    PPENDING_RELATIONS_LIST_ENTRY   pendingRelations;
    PNP_VETO_TYPE                   vetoType;
    PDEVICE_OBJECT                  deviceObject, relatedDeviceObject;
    PDEVICE_OBJECT                 *pdoList;
    PDEVICE_NODE                    deviceNode, relatedDeviceNode;
    PRELATION_LIST                  relationsList;
    ULONG                           relationCount;
    NTSTATUS                        status;
    ULONG                           marker;
    BOOLEAN                         directDescendant;
    PDEVICE_OBJECT                  vetoingDevice = NULL;
    PDRIVER_OBJECT                  vetoingDriver = NULL;
    LONG                            index;
    BOOLEAN                         possibleProfileChangeInProgress = FALSE;
    BOOLEAN                         subsumingProfileChange = FALSE;
    BOOLEAN                         hotEjectSupported;
    BOOLEAN                         warmEjectSupported;
    BOOLEAN                         excludeIndirectRelations;
    UNICODE_STRING                  singleVetoListItem;
    PWSTR                           vetoList;
    UNICODE_STRING                  internalVetoString;
    PWSTR                           internalVetoBuffer;
    PDOCK_INTERFACE                 dockInterface = NULL;

    PAGED_CODE();

    deviceEvent = *DeviceEvent;
    deviceObject = (PDEVICE_OBJECT)deviceEvent->Data.DeviceObject;
    deviceNode = deviceObject->DeviceObjectExtension->DeviceNode;
    surpriseRemovalEvent = NULL;

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    if (PiCompareGuid(&deviceEvent->Data.EventGuid, &GUID_DEVICE_EJECT)) {

        deleteType = EjectDevice;

    } else if (deviceEvent->Data.Flags & TDF_KERNEL_INITIATED) {

        if (!(deviceNode->Flags & DNF_ENUMERATED)) {

            ASSERT(deviceNode->State == DeviceNodeAwaitingQueuedDeletion);

            if ((deviceNode->PreviousState == DeviceNodeStarted) ||
                (deviceNode->PreviousState == DeviceNodeStopped) ||
                (deviceNode->PreviousState == DeviceNodeRestartCompletion)) {

                deleteType = SurpriseRemoveDevice;

            } else {
                deleteType = RemoveDevice;
            }
        } else {

            ASSERT(deviceNode->State == DeviceNodeAwaitingQueuedRemoval);

            if ((deviceNode->PreviousState == DeviceNodeStarted) ||
                (deviceNode->PreviousState == DeviceNodeStopped) ||
                (deviceNode->PreviousState == DeviceNodeRestartCompletion)) {

                deleteType = RemoveFailedDevice;
            } else {
                deleteType = RemoveUnstartedFailedDevice;
            }
        }

    } else {

        deleteType = QueryRemoveDevice;
    }

    if (deleteType == QueryRemoveDevice || deleteType == EjectDevice) {

        if (deviceNode->Flags & DNF_LEGACY_DRIVER) {

            PiFinalizeVetoedRemove(
                deviceEvent,
                PNP_VetoLegacyDevice,
                &deviceNode->InstancePath
                );

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }
    }

    if (deleteType == QueryRemoveDevice && deviceEvent->Argument == CM_PROB_DISABLED) {

        //
        // if we're trying to remove the device to disable the device
        //
        if (deviceNode->DisableableDepends > 0) {

            //
            // we should have caught this before (in usermode PnP)
            // but a rare scenario can exist where the device becomes non-disableable
            // There is still a potential gap, if the device hasn't got around
            // to marking itself as non-disableable yet
            //
            PiFinalizeVetoedRemove(
                deviceEvent,
                PNP_VetoNonDisableable,
                &deviceNode->InstancePath
                );

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }
    }

    //
    // Allocate room for a possible veto buffer.
    //
    internalVetoBuffer = (PWSTR) PiAllocateCriticalMemory(
        deleteType,
        PagedPool,
        MAX_VETO_NAME_LENGTH * sizeof(WCHAR),
        0
        );

    if (internalVetoBuffer == NULL) {

        PiFinalizeVetoedRemove(
            deviceEvent,
            PNP_VetoTypeUnknown,
            NULL
            );

        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        return STATUS_PLUGPLAY_QUERY_VETOED;
    }

    //
    // Preinit the veto information
    //
    vetoType = PNP_VetoTypeUnknown;
    internalVetoString.MaximumLength = MAX_VETO_NAME_LENGTH;
    internalVetoString.Length = 0;
    internalVetoString.Buffer = internalVetoBuffer;

    if (deleteType == EjectDevice) {

        if (deviceNode->Flags & DNF_LOCKED_FOR_EJECT) {

            //
            // Either this node or one of its ancestors is already being ejected.
            //
            ExFreePool(internalVetoBuffer);
            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_SUCCESS;
        }

        if (deviceEvent->Data.Flags & TDF_KERNEL_INITIATED) {

            //
            // Check permissions.
            //
            status = PiNotifyUserModeKernelInitiatedEject(
                deviceObject,
                &vetoType,
                &internalVetoString
                );

            if (!NT_SUCCESS(status)) {

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    vetoType,
                    &internalVetoString
                    );

                ExFreePool(internalVetoBuffer);
                PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
                return STATUS_PLUGPLAY_QUERY_VETOED;
            }
        }

        if ((deviceNode->DockInfo.DockStatus == DOCK_DEPARTING) ||
            (deviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED)) {

            //
            // We already have an eject queued against this device. Don't allow
            // another eject to break into the middle of a queue/cancel warm
            // eject sequence.
            //
            ExFreePool(internalVetoBuffer);
            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_SUCCESS;
        }

        //
        // What types of ejection can we do? (warm/hot)
        //
        if (!IopDeviceNodeFlagsToCapabilities(deviceNode)->Removable) {

            //
            // This device is neither ejectable, nor even removable.
            //
            PiFinalizeVetoedRemove(
                deviceEvent,
                PNP_VetoIllegalDeviceRequest,
                &deviceNode->InstancePath
                );

            ExFreePool(internalVetoBuffer);
            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }
    }

    if ((deleteType == QueryRemoveDevice) && (!PipAreDriversLoaded(deviceNode))) {

        //
        // The device doesn't have an FDO.
        //
        status = STATUS_SUCCESS;
        if ((deviceNode->State == DeviceNodeInitialized) ||
            (deviceNode->State == DeviceNodeRemoved)) {

            //
            // The rules are:
            // 1) !TDF_NO_RESTART means clear the devnode and get it ready
            //    as long as the problem is user resettable. Ignore the passed
            //    in problem code (probably either CM_PROB_WILL_BE_REMOVED or
            //    CM_PROB_DEVICE_NOT_THERE), as it means nothing.
            // 2) TDF_NO_RESTART means change the problem code over if you can.
            //    If the problem code is not user resettable, the problem code
            //    won't change.
            //

            //
            // In all cases we try to clear the problem.
            //
            if (PipDoesDevNodeHaveProblem(deviceNode)) {

                if (!PipIsProblemReadonly(deviceNode->Problem)) {

                    PipClearDevNodeProblem(deviceNode);
                }
            }

            if (!PipDoesDevNodeHaveProblem(deviceNode)) {

                if (!(deviceEvent->Data.Flags & TDF_NO_RESTART))  {

                    //
                    // This is a reset attempt. Mark the devnode so that it
                    // comes online next enumeration.
                    //
                    IopRestartDeviceNode(deviceNode);

                } else {

                    //
                    // We're changing or setting problem codes. Note that the
                    // device is still in DeviceNodeInitialized or
                    // DeviceNodeRemoved.
                    //
                    PipSetDevNodeProblem(deviceNode, deviceEvent->Argument);
                }

            } else {

                //
                // The problem is fixed, so the devnode state is immutable
                // as far as user mode is concerned. Here we fail the call
                // if we can't bring the devnode back online. We always succeed
                // the call if it was an attempt to change the code, as the
                // user either wants to prepare the device for ejection (done),
                // or wants to disable it (as good as done.)
                //
                if (!(deviceEvent->Data.Flags & TDF_NO_RESTART))  {

                    status = STATUS_INVALID_PARAMETER;
                }
            }
        }

        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        ExFreePool(internalVetoBuffer);
        return status;
    }

    status = IopBuildRemovalRelationList( deviceObject,
                                          deleteType,
                                          &vetoType,
                                          &internalVetoString,
                                          &relationsList);
    if (!NT_SUCCESS(status)) {

        PiFinalizeVetoedRemove(
            deviceEvent,
            vetoType,
            &internalVetoString
            );

        ExFreePool(internalVetoBuffer);
        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        return STATUS_PLUGPLAY_QUERY_VETOED;
    }

    ASSERT(relationsList != NULL);

    //
    // Resize the event buffer and add these device instance strings to the
    // list to notify.
    //
    relationCount = IopGetRelationsCount( relationsList );
    ASSERT(!IopGetRelationsTaggedCount( relationsList ));

    //
    // PdoList will become a list of devices that must be queried. This is
    // a subset of all the devices that might disappear, all of which appear
    // in the relations list.
    //
    pdoList = (PDEVICE_OBJECT *) PiAllocateCriticalMemory(
        deleteType,
        NonPagedPool,
        relationCount * sizeof(PDEVICE_OBJECT),
        0
        );

    if (pdoList != NULL) {

        relationCount = 0;
        marker = 0;
        while (IopEnumerateRelations( relationsList,
                                      &marker,
                                      &relatedDeviceObject,
                                      &directDescendant,
                                      NULL,
                                      TRUE)) {

            //
            // Here is a list of what operations retrieve what relations,
            // who they query, and who/how they notify.
            //
            // Operation                    Relations    Queries   Notifies
            // ---------                    ---------    -------   --------
            // EjectDevice                  Ejection     Everyone  Everyone (Remove)
            // SurpriseRemoveDevice         Ejection     NA        Descendants (SurpriseRemove)
            // RemoveDevice                 Ejection     NA        Descendants (Remove)
            // RemoveFailedDevice           Removal      NA        Descendants (SurpriseRemove)
            // RemoveUnstartedFailedDevice  Removal      NA        Descendants (Remove)
            // QueryRemoveDevice            Removal      Everyone  Everyone (Remove)
            //
            //
            // N.B.
            //     We do not send SurpriseRemove's to removal relations.
            // While doing so might seem to be the correct behavior, many
            // drivers do not handle this well. Simply reenumerating the
            // parents of the removal relations works much better. Similarly
            // ejection relations have their parents reenumerated (which
            // makes sense, as they are speculative in nature anyway).
            //
            //      If we get in a case where a *parent* of a dock gets
            // into the RemoveFailedDevice case (ie, failed restart,
            // responded to QueryDeviceState with Removed, etc), then we
            // will be shortly losing the children when we stop the parent.
            // However, we want to eject the dock child, not just remove it
            // as starting and ejecting are symmetric here. Note that
            // currently the only such parent would be the root ACPI devnode.
            //
            //      Ejection relations of a device (eg dock) that has been
            // surprise removed are not notified that they *may* have been
            // pulled (remember, ejection relations are speculative). We
            // will notify only DirectDescendants and queue an enumeration
            // on every parent of the ejection relations.  If they really
            // disappeared, they will get their notification, albeit a bit
            // later than some of the other devices in the tree.
            //
            if (directDescendant || deleteType == EjectDevice || deleteType == QueryRemoveDevice) {

                relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                //
                // PiProcessQueryRemoveAndEject will be called twice for
                // the dock during an eject. Once with EjectDevice, and
                // after the dock is listed as missing once more with
                // RemoveDevice. We don't want to start a profile change
                // for RemoveDevice as we are already in one, and we would
                // deadlock if we tried. We don't start one for QueryRemove
                // either as the dock isn't *physically* going away.
                //
                ASSERT(relatedDeviceNode->DockInfo.DockStatus != DOCK_ARRIVING);
                if (deleteType != RemoveDevice &&
                    deleteType != QueryRemoveDevice) {

                    if (relatedDeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT) {

                        possibleProfileChangeInProgress = TRUE;

                    } else if (relatedDeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

                        subsumingProfileChange = TRUE;
                    }
                }

                relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                if (deleteType == QueryRemoveDevice || deleteType == EjectDevice) {

                    if (relatedDeviceNode->Flags & DNF_LEGACY_DRIVER) {

                        PiFinalizeVetoedRemove(
                            deviceEvent,
                            PNP_VetoLegacyDevice,
                            &relatedDeviceNode->InstancePath
                            );

                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }

                    if (relatedDeviceNode->State == DeviceNodeRemovePendingCloses) {

                        PiFinalizeVetoedRemove(
                            deviceEvent,
                            PNP_VetoOutstandingOpen,
                            &relatedDeviceNode->InstancePath
                            );

                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }

                }

                pdoList[ relationCount++ ] = relatedDeviceObject;
            }
        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(status)) {

        excludeIndirectRelations =
            (deleteType == SurpriseRemoveDevice ||
             deleteType == RemoveFailedDevice ||
             deleteType == RemoveUnstartedFailedDevice ||
             deleteType == RemoveDevice);

        status = PiResizeTargetDeviceBlock( DeviceEvent,
                                            deleteType,
                                            relationsList,
                                            excludeIndirectRelations );

        deviceEvent = *DeviceEvent;


        if (deleteType == SurpriseRemoveDevice) {

            PiBuildUnsafeRemovalDeviceBlock(
                deviceEvent,
                relationsList,
                &surpriseRemovalEvent
                );
        }
    }

    if (!NT_SUCCESS(status)) {

        IopFreeRelationList(relationsList);

        if (pdoList) {

            ExFreePool(pdoList);
        }

        ExFreePool(internalVetoBuffer);

        PiFinalizeVetoedRemove(
            deviceEvent,
            PNP_VetoTypeUnknown,
            NULL
            );

        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        return status;
    }

    //
    // We may need to take the hardware profile change semaphore, and also
    // broadcast a hardware profile change request...
    //
    if (possibleProfileChangeInProgress) {

        PpProfileBeginHardwareProfileTransition(subsumingProfileChange);

        //
        // Walk the list of docks who are going to disappear and mark them as
        // in profile transition.
        //
        for (index = relationCount - 1; index >= 0; index--) {

            relatedDeviceObject = pdoList[ index ];
            relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            ASSERT(relatedDeviceNode->DockInfo.DockStatus != DOCK_ARRIVING);
            if (relatedDeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT) {

                PpProfileIncludeInHardwareProfileTransition(
                    relatedDeviceNode,
                    DOCK_DEPARTING
                    );
            }
        }

        //
        // We can only be in one of the following deleteType situations
        //
        // 1) EjectDevice          - Good, normal ejection request by our user
        //                           (we are using EjectionRelations)
        //
        // 2) SurpriseRemoveDevice - Someone yanked the dock out.
        //                           (we are using EjectionRelations)
        //
        // 3) RemoveFailedDevice   - A start failed after a stop on a parent or
        //                           even our device. This case is not handled
        //                           correctly. We assert for now, and we
        //                           maroon the dock, ie lose it's devnode but
        //                           the dock stays physically present and is
        //                           in the users eye's unejectable.
        //
        // 4) RemoveDevice         - This occurs in three cases:
        //                              a) A removed device is disappearing.
        //                              b) A device is being removed but has not
        //                                 been started.
        //                              c) A device has failed start.
        //
        //                           We pass through case a) during a normal
        //                           ejection and as part of a profile
        //                           transition begun earlier. c) is similar
        //                           to a) but the transition was begun by the
        //                           start code. For case b) we don't want to
        //                           turn it into an eject, as the OS might be
        //                           removing our parent as a normal part of
        //                           setup, and we wouldn't want to undock then
        //                           (and we probably aren't changing profiles
        //                           anyway).
        //
        // 5) QueryRemoveDevice      This should never be the case here per the
        //                           explicit veto in the IopEnumerateRelations
        //                           code above.
        //

        //
        // RemoveFailedDevice is a PathTrap - the only parent of a dock is
        // the ACPI root devnode right now. We shouldn't get into that case.
        //
        ASSERT(deleteType != QueryRemoveDevice &&
               deleteType != RemoveFailedDevice);

        if (deleteType == EjectDevice) {

            //
            // Are there any legacy drivers in the system?
            //
            status = IoGetLegacyVetoList(&vetoList, &vetoType);

            if (NT_SUCCESS(status) &&
                (vetoType != PNP_VetoTypeUnknown)) {

                //
                // Release any docks in profile transition
                //
                PpProfileCancelHardwareProfileTransition();

                IopFreeRelationList(relationsList);

                //
                // Failure occured, notify user mode as appropriate, or fill in
                // the veto buffer.
                //
                if (deviceEvent->VetoType != NULL) {

                    *deviceEvent->VetoType = vetoType;
                }

                if (deviceEvent->VetoName == NULL) {

                    //
                    // If there is not a VetoName passed in then call user mode
                    // to display the eject veto notification to the user.
                    //
                    PiNotifyUserModeRemoveVetoedByList(
                        deviceEvent,
                        deviceObject,
                        vetoType,
                        vetoList
                        );

                } else {

                    //
                    //     The veto data in the PNP_DEVICE_EVENT_ENTRY block is
                    // a UNICODE_STRING field. Since that type of data structure
                    // cannot handle Multi-Sz data, we cull the information down
                    // to one entry here.
                    //
                    RtlCopyUnicodeString(deviceEvent->VetoName, &singleVetoListItem);
                    RtlInitUnicodeString(&singleVetoListItem, vetoList);
                }

                ExFreePool(vetoList);
                ExFreePool(pdoList);
                ExFreePool(internalVetoBuffer);

                PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
                return STATUS_PLUGPLAY_QUERY_VETOED;
            }

            //
            // Broadcast the query for a profile change against our current
            // list of docks in transition...
            //
            status = PpProfileQueryHardwareProfileChange(
                subsumingProfileChange,
                PROFILE_IN_PNPEVENT,
                &vetoType,
                &internalVetoString
                );

            if (!NT_SUCCESS(status)) {

                //
                // Release any docks in profile transition
                //
                PpProfileCancelHardwareProfileTransition();

                IopFreeRelationList(relationsList);

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    vetoType,
                    &internalVetoString
                    );

                ExFreePool(pdoList);
                ExFreePool(internalVetoBuffer);

                PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
                return STATUS_PLUGPLAY_QUERY_VETOED;
            }
        }
    }

    if (deleteType == QueryRemoveDevice || deleteType == EjectDevice) {

        //
        // Send query notification to user-mode.
        //

        status = PiNotifyUserModeDeviceRemoval(
            deviceEvent,
            &GUID_TARGET_DEVICE_QUERY_REMOVE,
            &vetoType,
            &internalVetoString
            );

        if (NT_SUCCESS(status)) {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiProcessQueryRemoveAndEject: QUERY_REMOVE - notifying kernel-mode\n"));

            //
            // Send query notification to kernel-mode drivers.
            //

            for (index = 0; index < (LONG)relationCount; index++) {

                relatedDeviceObject = pdoList[ index ];

                status = IopNotifyTargetDeviceChange( &GUID_TARGET_DEVICE_QUERY_REMOVE,
                                                      relatedDeviceObject,
                                                      NULL,
                                                      &vetoingDriver);

                if (!NT_SUCCESS(status)) {

                    vetoType = PNP_VetoDriver;

                    if (vetoingDriver != NULL) {

                        RtlCopyUnicodeString(&internalVetoString, &vetoingDriver->DriverName);

                    } else {

                        RtlInitUnicodeString(&internalVetoString, NULL);
                    }

                    for (index--; index >= 0; index--) {
                        relatedDeviceObject = pdoList[ index ];

                        IopNotifyTargetDeviceChange( &GUID_TARGET_DEVICE_REMOVE_CANCELLED,
                                                     relatedDeviceObject,
                                                     NULL,
                                                     NULL);

                    }
                    break;
                }
            }

            if (NT_SUCCESS(status)) {
                //
                // If we haven't already performed the action yet (a query remove
                // to the target device, in this case), then do it now.
                //

                IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                           "PiProcessQueryRemoveAndEject: QueryRemove DevNodes\n"));

                status = IopDeleteLockedDeviceNodes(deviceObject,
                                                    relationsList,
                                                    QueryRemoveDevice,
                                                    TRUE,
                                                    0,
                                                    &vetoType,
                                                    &internalVetoString);
                if (NT_SUCCESS(status)) {
                    //
                    // Everyone has been notified and had a chance to close their handles.
                    // Since no one has vetoed it yet, let's see if there are any open
                    // references.
                    //

                    if (IopNotifyPnpWhenChainDereferenced( pdoList, relationCount, TRUE, &vetoingDevice )) {

                        DUMP_PDO_HANDLES(pdoList, relationCount, FALSE);

                        vetoType = PNP_VetoOutstandingOpen;
                        if (vetoingDevice != NULL) {

                            relatedDeviceNode = (PDEVICE_NODE)vetoingDevice->DeviceObjectExtension->DeviceNode;

                            ASSERT(relatedDeviceNode != NULL);

                            RtlCopyUnicodeString(&internalVetoString, &relatedDeviceNode->InstancePath);

                        } else {

                            RtlInitUnicodeString(&internalVetoString, NULL);
                        }

                        //
                        // Send cancel remove to the target devices.
                        //

                        IopDeleteLockedDeviceNodes(deviceObject,
                                                   relationsList,
                                                   CancelRemoveDevice,
                                                   TRUE,
                                                   0,
                                                   NULL,
                                                   NULL);

                        status = STATUS_UNSUCCESSFUL;
                    }

                } else {

                    DUMP_PDO_HANDLES(pdoList, relationCount, FALSE);
                }

                if (!NT_SUCCESS(status)) {

                    //
                    // Send cancel notification to kernel-mode drivers.
                    //

                    for (index = relationCount - 1; index >= 0; index--) {

                        relatedDeviceObject = pdoList[ index ];

                        IopNotifyTargetDeviceChange( &GUID_TARGET_DEVICE_REMOVE_CANCELLED,
                                                     relatedDeviceObject,
                                                     NULL,
                                                     NULL);
                    }
                }
            }

            if (!NT_SUCCESS(status)) {

                IopDbgPrint((IOP_IOEVENT_WARNING_LEVEL,
                           "PiProcessQueryRemoveAndEject: Vetoed by \"%wZ\" (type 0x%x)\n",
                           &internalVetoString,
                           vetoType));

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    vetoType,
                    &internalVetoString
                    );

                //
                // A driver vetoed the query remove, go back and send
                // cancels to user-mode (cancels already sent to drivers
                // that received the query).
                //
                PiNotifyUserModeDeviceRemoval(
                    deviceEvent,
                    &GUID_TARGET_DEVICE_REMOVE_CANCELLED,
                    NULL,
                    NULL
                    );
            }

        } else {

            PiFinalizeVetoedRemove(
                deviceEvent,
                vetoType,
                &internalVetoString
                );
        }

        if (!NT_SUCCESS(status)) {

            //
            // Broadcast a cancel HW profile change event if appropriate.
            //
            if (possibleProfileChangeInProgress) {

                //
                // Release any docks in profile transition. We also broadcast
                // the cancel.
                //
                PpProfileCancelHardwareProfileTransition();
            }

            //
            // User-mode vetoed the request (cancels already sent
            // to user-mode callers that received the query).
            //
            IopFreeRelationList(relationsList);

            ExFreePool(pdoList);
            ExFreePool(internalVetoBuffer);

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }

    } else if (deleteType == SurpriseRemoveDevice || deleteType == RemoveFailedDevice) {

        //
        // Send IRP_MN_SURPRISE_REMOVAL, IopDeleteLockDeviceNodes ignores
        // indirect descendants for SurpriseRemoveDevice.
        //
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiProcessQueryRemoveAndEject: QueryRemove DevNodes\n"));

        IopDeleteLockedDeviceNodes( deviceObject,
                                    relationsList,
                                    SurpriseRemoveDevice,
                                    FALSE,
                                    0,
                                    NULL,
                                    NULL);
    }

    //
    // Notify user-mode and drivers that a remove is happening. User-mode
    // sees this as a remove pending if it's user initiated, we don't give
    // them the "remove" until it's actually gone.
    //
    if (deleteType != SurpriseRemoveDevice) {

        //
        // ISSUE - 2000/08/20 - ADRIAO: Busted message path
        //     We send GUID_DEVICE_REMOVE_PENDING to devices that are already
        // dead in the case of RemoveFailedDevice.
        //
        PiNotifyUserModeDeviceRemoval(
            deviceEvent,
            &GUID_DEVICE_REMOVE_PENDING,
            NULL,
            NULL
            );

    } else {

        if (surpriseRemovalEvent) {

            PiNotifyUserModeDeviceRemoval(
                surpriseRemovalEvent,
                &GUID_DEVICE_SURPRISE_REMOVAL,
                NULL,
                NULL
                );

            ExFreePool(surpriseRemovalEvent);
        }

        PiNotifyUserModeDeviceRemoval(
            deviceEvent,
            &GUID_TARGET_DEVICE_REMOVE_COMPLETE,
            NULL,
            NULL
            );
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessQueryRemoveAndEject: REMOVE_COMPLETE - notifying kernel-mode\n"));

    for (index = 0; index < (LONG)relationCount; index++) {

        relatedDeviceObject = pdoList[ index ];

        status = IopNotifyTargetDeviceChange( &GUID_TARGET_DEVICE_REMOVE_COMPLETE,
                                              relatedDeviceObject,
                                              NULL,
                                              NULL);

        ASSERT(NT_SUCCESS(status));
    }

    if (deleteType == RemoveDevice ||
        deleteType == RemoveFailedDevice ||
        deleteType == SurpriseRemoveDevice) {

        //
        // For these operations indirect relations are speculative.
        //
        // So for each of the indirect relations, invalidate their parents and
        // remove them from the relations list.
        //

        IopInvalidateRelationsInList( relationsList, deleteType, TRUE, FALSE );

        IopRemoveIndirectRelationsFromList( relationsList );
    }

    if (deleteType == RemoveFailedDevice ||
        deleteType == SurpriseRemoveDevice) {

        //
        // We've sent the surprise remove IRP to the original device and all its
        // direct descendants.  We've also notified user-mode.
        //

        //
        // Unlock the device relations list.
        //
        // Note there could be a potential race condition here between
        // unlocking the devnodes in the relation list and completing the
        // execution of IopNotifyPnpWhenChainDereferenced.  If an enumeration
        // takes places (we've unlocked the devnode) before the eventual remove
        // is sent then problems could occur.
        //
        // This is prevented by the setting of DNF_REMOVE_PENDING_CLOSES when
        // we sent the IRP_MN_SURPRISE_REMOVAL.
        //
        // We do need to do it prior to calling IopQueuePendingSurpriseRemoval
        // since we lose ownership of the relation list in that call.  Also
        // IopNotifyPnpWhenChainDereferenced may cause the relation list to be
        // freed before it returns.
        //
        // If this is a RemoveFailedDevice then we don't want to remove the
        // device node from the tree but we do want to remove children without
        // resources.
        //

        IopUnlinkDeviceRemovalRelations( deviceObject,
                                         relationsList,
                                         deleteType == SurpriseRemoveDevice ?
                                             UnlinkAllDeviceNodesPendingClose :
                                             UnlinkOnlyChildDeviceNodesPendingClose);

        //
        // Add the relation list to a list of pending surprise removals.
        //
        IopQueuePendingSurpriseRemoval( deviceObject, relationsList, deviceEvent->Argument );

        //
        // Release the engine lock *before* IopNotifyPnpWhenChainDereferenced,
        // as it may call back into us...
        //
        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        IopNotifyPnpWhenChainDereferenced( pdoList, relationCount, FALSE, NULL );

        ExFreePool(pdoList);
        ExFreePool(internalVetoBuffer);

        return STATUS_SUCCESS;
    }

    if (deviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

        status = IopQueryDockRemovalInterface(
            deviceObject,
            &dockInterface
            );

        if (dockInterface) {

            //
            // Make sure updates don't occur on removes during an ejection.
            // We may change this to PDS_UPDATE_ON_EJECT *after* the remove
            // IRPs go through (as only then do we know our power
            // constraints)
            //
            dockInterface->ProfileDepartureSetMode(
                dockInterface->Context,
                PDS_UPDATE_ON_INTERFACE
                );
        }
    }

    //
    // Send the remove to the devnode tree.
    //

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessQueryRemoveAndEject: RemoveDevice DevNodes\n"));

    status = IopDeleteLockedDeviceNodes(deviceObject,
                                        relationsList,
                                        RemoveDevice,
                                        (BOOLEAN)(deleteType == QueryRemoveDevice || deleteType == EjectDevice),
                                        deviceEvent->Argument,
                                        NULL,
                                        NULL);

    hotEjectSupported =
        (BOOLEAN) IopDeviceNodeFlagsToCapabilities(deviceNode)->EjectSupported;

    warmEjectSupported =
        (BOOLEAN) IopDeviceNodeFlagsToCapabilities(deviceNode)->WarmEjectSupported;

    if (deleteType != EjectDevice) {

        if (!(deviceEvent->Data.Flags & TDF_NO_RESTART)) {

            //
            // Set a flag to let kernel-mode know we'll be wanting to
            // restart these devnodes, eventually.
            //

            marker = 0;
            while (IopEnumerateRelations( relationsList,
                                          &marker,
                                          &relatedDeviceObject,
                                          NULL,
                                          NULL,
                                          TRUE)) {

                relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                if (relatedDeviceNode &&
                    relatedDeviceNode->State == DeviceNodeRemoved &&
                    PipIsDevNodeProblem(relatedDeviceNode, CM_PROB_WILL_BE_REMOVED)) {

                    PipClearDevNodeProblem(relatedDeviceNode);

                    IopRestartDeviceNode(relatedDeviceNode);
                }
            }
        }

        //
        // Unlock the device relations list.
        //
        IopUnlinkDeviceRemovalRelations( deviceObject,
                                         relationsList,
                                         UnlinkRemovedDeviceNodes );

        IopFreeRelationList(relationsList);

    } else if (hotEjectSupported || warmEjectSupported) {

        //
        // From this point on we cannot return any sort of failure without
        // going through IopEjectDevice or cancelling any outstanding profile
        // change.
        //

        //
        // Set a flag to let kernel-mode know we'll be wanting to
        // restart these devnodes, eventually.
        //

        marker = 0;
        while (IopEnumerateRelations( relationsList,
                                      &marker,
                                      &relatedDeviceObject,
                                      NULL,
                                      NULL,
                                      TRUE)) {

            relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            if (relatedDeviceNode)  {

                relatedDeviceNode->Flags |= DNF_LOCKED_FOR_EJECT;
            }
        }

        IopUnlinkDeviceRemovalRelations( deviceObject,
                                         relationsList,
                                         UnlinkRemovedDeviceNodes );

        //
        // Send the eject
        //
        pendingRelations = ExAllocatePool( NonPagedPool, sizeof(PENDING_RELATIONS_LIST_ENTRY) );

        if (pendingRelations == NULL) {

            //
            // It's cleanup time. Free up everything that matters
            //
            if (dockInterface) {

                dockInterface->ProfileDepartureSetMode(
                    dockInterface->Context,
                    PDS_UPDATE_DEFAULT
                    );

                dockInterface->InterfaceDereference(dockInterface->Context);
            }

            ExFreePool(pdoList);
            ExFreePool(internalVetoBuffer);

            if (possibleProfileChangeInProgress) {

                //
                // Release any docks in profile transition. We also broadcast
                // the cancel.
                //
                PpProfileCancelHardwareProfileTransition();
            }

            //
            // This will bring back online the devices that were held offline
            // for the duration of the undock.
            //
            IopInvalidateRelationsInList(relationsList, deleteType, FALSE, TRUE);

            //
            // Free the relations list
            //
            IopFreeRelationList(relationsList);

            //
            // Let the user know we were unable to process the request.
            //
            PiFinalizeVetoedRemove(
                deviceEvent,
                PNP_VetoTypeUnknown,
                NULL
                );

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }

        //
        // Fill out the pending eject information.
        //
        ObReferenceObject(deviceObject);
        pendingRelations->DeviceEvent = deviceEvent;
        pendingRelations->DeviceObject = deviceObject;
        pendingRelations->RelationsList = relationsList;
        pendingRelations->ProfileChangingEject = possibleProfileChangeInProgress;
        pendingRelations->DisplaySafeRemovalDialog =
            (BOOLEAN)(deviceEvent->VetoName == NULL);
        pendingRelations->DockInterface = dockInterface;

        //
        // Now that we've removed all the devices that won't be present
        // in the new hardware profile state (eg batteries, etc),
        //
        status = PoGetLightestSystemStateForEject(
            possibleProfileChangeInProgress,
            hotEjectSupported,
            warmEjectSupported,
            &pendingRelations->LightestSleepState
            );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_INSUFFICIENT_POWER) {

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    PNP_VetoInsufficientPower,
                    NULL
                    );

            } else {

                IopDbgPrint((IOP_IOEVENT_WARNING_LEVEL,
                           "PiProcessQueryRemoveAndEject: Vetoed by power system (%x)\n",
                           status));

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    PNP_VetoTypeUnknown,
                    NULL
                    );
            }

            //
            // We'll complete this one ourselves thank you.
            //
            pendingRelations->DeviceEvent = NULL;
            pendingRelations->DisplaySafeRemovalDialog = FALSE;

            //
            // Release any profile transitions.
            //
            InitializeListHead( &pendingRelations->Link );
            IopProcessCompletedEject((PVOID) pendingRelations);

            ExFreePool(pdoList);
            ExFreePool(internalVetoBuffer);

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }

        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

        //
        // Completion routine for the eject IRP handles display of the
        // safe removal dialog and completion of the event. Returning
        // STATUS_PENDING does let other events get processed though.
        //
        IopEjectDevice( deviceObject, pendingRelations );

        ExFreePool(pdoList);
        ExFreePool(internalVetoBuffer);

        return STATUS_PENDING;

    } else {

        //
        // All docks must be hot or warm ejectable.
        //
        ASSERT(!dockInterface);

        //
        // Unlock the device relations list.
        //
        IopUnlinkDeviceRemovalRelations( deviceObject,
                                         relationsList,
                                         UnlinkRemovedDeviceNodes );

        IopFreeRelationList(relationsList);

        //
        // This hardware supports neither hot nor warm eject, but it is
        // removable. It can therefore be thought of as a "user assisted" hot
        // eject. In this case we do *not* want to wait around for the user to
        // "complete the eject" and then put up the message. So we piggyback a
        // safe removal notification while UmPnPMgr is alert and waiting in
        // user mode, and the user gets the dialog now.
        //
        if (deviceEvent->VetoName == NULL) {

            PpNotifyUserModeRemovalSafe(deviceObject);
        }
    }

    if (deleteType == RemoveDevice) {

        //
        // Notify user-mode one last time that everything is actually done.
        //
        PiNotifyUserModeDeviceRemoval(
            deviceEvent,
            &GUID_TARGET_DEVICE_REMOVE_COMPLETE,
            NULL,
            NULL
            );
    }

    ExFreePool(pdoList);

    if (dockInterface) {

        dockInterface->ProfileDepartureSetMode(
            dockInterface->Context,
            PDS_UPDATE_DEFAULT
            );

        dockInterface->InterfaceDereference(dockInterface->Context);
    }

    ExFreePool(internalVetoBuffer);
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
    return STATUS_SUCCESS;
}


NTSTATUS
PiProcessTargetDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    )

/*++

Routine Description:

    This routine processes each type of event in the target device category.
    These events may have been initiated by either user-mode or kernel mode.

Arguments:

    deviceEvent - Data describing the type of target device event and the
            target device itself.


Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    deviceEvent = *DeviceEvent;

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessTargetDeviceEvent: Entered\n"));

    //-----------------------------------------------------------------
    // QUERY and REMOVE
    //-----------------------------------------------------------------

    if (PiCompareGuid(&deviceEvent->Data.EventGuid,
                      &GUID_DEVICE_QUERY_AND_REMOVE)) {

        status = PiProcessQueryRemoveAndEject(DeviceEvent);

    }

    //-----------------------------------------------------------------
    // EJECT
    //-----------------------------------------------------------------

    else if (PiCompareGuid(&deviceEvent->Data.EventGuid,
                           &GUID_DEVICE_EJECT)) {

        status = PiProcessQueryRemoveAndEject(DeviceEvent);

    }

    //-----------------------------------------------------------------
    // ARRIVAL
    //-----------------------------------------------------------------

    else if (PiCompareGuid(&deviceEvent->Data.EventGuid,
                           &GUID_DEVICE_ARRIVAL)) {

        //
        // Notify user-mode (not drivers) that an arrival just happened.
        //

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiProcessTargetDeviceEvent: ARRIVAL - notifying user-mode\n"));

        PiNotifyUserMode(deviceEvent);
    }

    //-----------------------------------------------------------------
    // NO-OP REQUEST (to flush device event queue)
    //-----------------------------------------------------------------

    else if (PiCompareGuid(&deviceEvent->Data.EventGuid,
                           &GUID_DEVICE_NOOP)) {

        status = STATUS_SUCCESS;

    }

    //-----------------------------------------------------------------
    // SAFE REMOVAL NOTIFICATION
    //-----------------------------------------------------------------

    else if (PiCompareGuid(&deviceEvent->Data.EventGuid, &GUID_DEVICE_SAFE_REMOVAL)) {

        //
        // Notify user-mode (and nobody else) that it is now safe to remove
        // someone.
        //

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiProcessTargetDeviceEvent: SAFE_REMOVAL - notifying user-mode\n"));

        PiNotifyUserMode(deviceEvent);
    }

    return status;

} // PiProcessTargetDeviceEvent


NTSTATUS
PiProcessCustomDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    )

/*++

Routine Description:

    This routine processes each type of event in the custom device category.
    These events may have been initiated by either user-mode or kernel mode.

Arguments:

    deviceEvent - Data describing the type of custom device event and the
            target device itself.


Return Value:

    None.

--*/

{
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PTARGET_DEVICE_CUSTOM_NOTIFICATION  customNotification;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    deviceEvent = *DeviceEvent;

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessCustomDeviceEvent: Entered\n"));

    ASSERT(PiCompareGuid(&deviceEvent->Data.EventGuid,
                         &GUID_PNP_CUSTOM_NOTIFICATION));

    deviceObject = (PDEVICE_OBJECT)deviceEvent->Data.DeviceObject;
    customNotification = (PTARGET_DEVICE_CUSTOM_NOTIFICATION)deviceEvent->Data.u.CustomNotification.NotificationStructure;

    //
    // Notify user-mode that something just happened.
    //

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessCustomDeviceEvent: CUSTOM_NOTIFICATION - notifying user-mode\n"));

    PiNotifyUserMode(deviceEvent);

    //
    // Notify K-mode
    //

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessCustomDeviceEvent: CUSTOM_NOTIFICATION - notifying kernel-mode\n"));

    IopNotifyTargetDeviceChange( &customNotification->Event,
                                 deviceObject,
                                 customNotification,
                                 NULL);

    return STATUS_SUCCESS;

} // PiProcessCustomDeviceEvent


NTSTATUS
PiResizeTargetDeviceBlock(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent,
    IN PLUGPLAY_DEVICE_DELETE_TYPE DeleteType,
    IN PRELATION_LIST RelationsList,
    IN BOOLEAN ExcludeIndirectRelations
    )
/*++

Routine Description:

    This routine takes the passed in device event block and resizes it to
    hold a multisz list of device instance strings in the DeviceIds field.
    This list includes the original target device id plus the device id
    for all the device objects in the specified DeviceRelations struct.

Arguments:

    DeviceEvent - On entry, contains the original device event block, on
            return it contains the newly allocated device event block and
            a complete list of related device id strings.

    DeviceRelations - structure that contains a list of related device objects.

Return Value:

    NTSTATUS value.

--*/
{
    PDEVICE_NODE relatedDeviceNode;
    PDEVICE_OBJECT relatedDeviceObject;
    ULONG newSize, currentSize;
    PPNP_DEVICE_EVENT_ENTRY newDeviceEvent;
    LPWSTR targetDevice, p;
    ULONG marker;
    BOOLEAN directDescendant;

    PAGED_CODE();

    if (RelationsList == NULL) {
        return STATUS_SUCCESS;  // nothing to do
    }

    targetDevice = (*DeviceEvent)->Data.u.TargetDevice.DeviceIds;

    //
    // Calculate the size of the PNP_DEVICE_EVENT_ENTRY block
    //

    currentSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) +
                  (*DeviceEvent)->Data.TotalSize;

    newSize = currentSize;
    newSize -= (ULONG)((wcslen(targetDevice)+1) * sizeof(WCHAR));

    marker = 0;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  FALSE)) {

        if (!ExcludeIndirectRelations || directDescendant) {

            relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            if (relatedDeviceNode != NULL) {
                if (relatedDeviceNode->InstancePath.Length != 0) {
                    newSize += relatedDeviceNode->InstancePath.Length + sizeof(WCHAR);
                }
            }
        }
    }

    ASSERT(newSize >= currentSize);

    if (newSize == currentSize) {

        return STATUS_SUCCESS;

    } else if (newSize < currentSize) {

        newSize = currentSize;
    }

    newDeviceEvent = (PPNP_DEVICE_EVENT_ENTRY) PiAllocateCriticalMemory(
        DeleteType,
        PagedPool,
        newSize,
        PNP_DEVICE_EVENT_ENTRY_TAG
        );

    if (newDeviceEvent == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)newDeviceEvent, newSize);

    //
    // Copy the old buffer into the new buffer, it's only the new stuff at the
    // end that changes.
    //

    RtlCopyMemory(newDeviceEvent, *DeviceEvent, currentSize);

    //
    // Update the size of the PLUGPLAY_EVENT_BLOCK
    //
    newDeviceEvent->Data.TotalSize = newSize - FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data);

    //
    // Add device instance string for each device relation to the list.
    // Leave the target device first in the list, and skip it during the
    // enumeration below.
    //

    marker = 0;
    p = newDeviceEvent->Data.u.TargetDevice.DeviceIds + wcslen(targetDevice) + 1;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  FALSE)) {

        if ((relatedDeviceObject != newDeviceEvent->Data.DeviceObject) &&
            (!ExcludeIndirectRelations || directDescendant)) {

            relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            if (relatedDeviceNode != NULL) {
                if (relatedDeviceNode->InstancePath.Length != 0) {
                    RtlCopyMemory(p,
                                  relatedDeviceNode->InstancePath.Buffer,
                                  relatedDeviceNode->InstancePath.Length);
                    p += relatedDeviceNode->InstancePath.Length / sizeof(WCHAR) + 1;
                }
            }
        }
    }

    *p = UNICODE_NULL;

    ExFreePool(*DeviceEvent);
    *DeviceEvent = newDeviceEvent;

    return STATUS_SUCCESS;

} // PiResizeTargetDeviceBlock


VOID
PiBuildUnsafeRemovalDeviceBlock(
    IN  PPNP_DEVICE_EVENT_ENTRY     OriginalDeviceEvent,
    IN  PRELATION_LIST              RelationsList,
    OUT PPNP_DEVICE_EVENT_ENTRY    *AllocatedDeviceEvent
    )
/*++

Routine Description:

    This routine builds a device event block to send to user mode in case of
    unsafe removal.

Arguments:

    OriginalDeviceEvent - Contains the original device event block.

    RelationList - structure that contains a list of related device objects.

    AllocatedDeviceEvent - Receives the new device event, NULL on error or
                           no entries.

Return Value:

    None.

--*/
{
    PDEVICE_NODE relatedDeviceNode;
    PDEVICE_OBJECT relatedDeviceObject;
    ULONG dataSize, eventSize, headerSize;
    PPNP_DEVICE_EVENT_ENTRY newDeviceEvent;
    LPWSTR targetDevice, p;
    ULONG marker;
    BOOLEAN directDescendant;

    PAGED_CODE();

    //
    // Preinit
    //
    *AllocatedDeviceEvent = NULL;

    if (RelationsList == NULL) {

        return;  // nothing to do
    }

    targetDevice = OriginalDeviceEvent->Data.u.TargetDevice.DeviceIds;

    //
    // Calculate the size of the PNP_DEVICE_EVENT_ENTRY block
    //
    dataSize = 0;

    marker = 0;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  FALSE)) {

        if (!directDescendant) {

            continue;
        }

        relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

        if ((relatedDeviceNode == NULL) ||
            PipIsBeingRemovedSafely(relatedDeviceNode)) {

            continue;
        }

        if (relatedDeviceNode->InstancePath.Length != 0) {
            dataSize += relatedDeviceNode->InstancePath.Length + sizeof(WCHAR);
        }
    }

    if (dataSize == 0) {

        //
        // No entries, bail.
        //
        return;
    }

    //
    // Add the terminating MultiSz NULL.
    //
    dataSize += sizeof(WCHAR);

    headerSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) +
                 FIELD_OFFSET(PLUGPLAY_EVENT_BLOCK, u);

    eventSize = dataSize + headerSize;

    //
    // If we can't get memory, there simply won't be a message sent.
    //
    newDeviceEvent = ExAllocatePoolWithTag(
        PagedPool,
        eventSize,
        PNP_DEVICE_EVENT_ENTRY_TAG
        );

    if (newDeviceEvent == NULL) {

        return;
    }

    RtlZeroMemory((PVOID)newDeviceEvent, eventSize);

    //
    // Copy the header into the new buffer.
    //
    RtlCopyMemory(newDeviceEvent, OriginalDeviceEvent, headerSize);

    //
    // Update the size of the PLUGPLAY_EVENT_BLOCK
    //
    newDeviceEvent->Data.TotalSize = dataSize + FIELD_OFFSET(PLUGPLAY_EVENT_BLOCK, u);

    //
    // Add device instance string for each device relation to the list.
    //

    marker = 0;
    p = newDeviceEvent->Data.u.TargetDevice.DeviceIds;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  FALSE)) {

        if (!directDescendant) {

            continue;
        }

        relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

        if ((relatedDeviceNode == NULL) ||
            PipIsBeingRemovedSafely(relatedDeviceNode)) {

            continue;
        }

        if (relatedDeviceNode->InstancePath.Length != 0) {

            RtlCopyMemory(p,
                          relatedDeviceNode->InstancePath.Buffer,
                          relatedDeviceNode->InstancePath.Length);
            p += relatedDeviceNode->InstancePath.Length / sizeof(WCHAR) + 1;
        }
    }

    *p = UNICODE_NULL;

    *AllocatedDeviceEvent = newDeviceEvent;

    return;

} // PiBuildUnsafeRemovalDeviceBlock


VOID
PiFinalizeVetoedRemove(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PNP_VETO_TYPE            VetoType,
    IN PUNICODE_STRING          VetoName        OPTIONAL
    )
/*++

Routine Description:

    This routine takes care of updating the event results with the veto
    information, puts up UI if neccessary, and dumps failure information to
    the debugger for debugging purposes.

Arguments:

    VetoedDeviceEvent - Data describing the device event failed.

    VetoType - The veto code best describing why the operation failed.

    VetoName - A unicode string appropriate to the veto code that describes
               the vetoer.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject;
#if DBG
    PUNICODE_STRING devNodeName;
    const char *failureReason;
#endif

    deviceObject = (PDEVICE_OBJECT) VetoedDeviceEvent->Data.DeviceObject;

#if DBG
    devNodeName = &((PDEVICE_NODE) deviceObject->DeviceObjectExtension->DeviceNode)->InstancePath;

    switch(VetoType) {

        case PNP_VetoTypeUnknown:
            failureReason = "for unspecified reason";
            break;

        case PNP_VetoLegacyDevice:
            failureReason = "due to legacy device";
            break;

        case PNP_VetoPendingClose:

            //
            // ADRIAO N.B. 07/10/2000 - I believe this case is vestigal...
            //
            ASSERT(0);
            failureReason = "due to pending close";
            break;

        case PNP_VetoWindowsApp:
            failureReason = "due to windows application";
            break;

        case PNP_VetoWindowsService:
            failureReason = "due to service";
            break;

        case PNP_VetoOutstandingOpen:
            failureReason = "due to outstanding handles on device";
            break;

        case PNP_VetoDevice:
            failureReason = "by device";
            break;

        case PNP_VetoDriver:
            failureReason = "by driver";
            break;

        case PNP_VetoIllegalDeviceRequest:
            failureReason = "as the request was invalid for the device";
            break;

        case PNP_VetoInsufficientPower:
            failureReason = "because there would be insufficient system power to continue";
            break;

        case PNP_VetoNonDisableable:
            failureReason = "due to non-disableable device";
            break;

        case PNP_VetoLegacyDriver:
            failureReason = "due to legacy driver";
            break;

        case PNP_VetoInsufficientRights:
            failureReason = "insufficient permissions";
            break;

        default:
            ASSERT(0);
            failureReason = "due to uncoded reason";
            break;
    }

    if (VetoName != NULL) {

        IopDbgPrint((IOP_IOEVENT_WARNING_LEVEL,
            "PiFinalizeVetoedRemove: Removal of %wZ vetoed %s %wZ.\n",
            devNodeName,
            failureReason,
            VetoName
            ));

    } else {

        IopDbgPrint((IOP_IOEVENT_WARNING_LEVEL,
            "PiFinalizeVetoedRemove: Removal of %wZ vetoed %s.\n",
            devNodeName,
            failureReason
            ));
    }

#endif

    //
    // Update the vetoType field if the caller is interested.
    //
    if (VetoedDeviceEvent->VetoType != NULL) {

        *VetoedDeviceEvent->VetoType = VetoType;
    }

    //
    // The VetoName field tells us whether UI should be displayed (if NULL,
    // kernel mode UI is implicitely requested.)
    //
    if (VetoedDeviceEvent->VetoName != NULL) {

        if (VetoName != NULL) {

            RtlCopyUnicodeString(VetoedDeviceEvent->VetoName, VetoName);
        }

    } else {

        //
        // If there is not a VetoName passed in then call user mode to display the
        // eject veto notification to the user
        //
        PiNotifyUserModeRemoveVetoed(
            VetoedDeviceEvent,
            deviceObject,
            VetoType,
            VetoName
            );
    }
}


BOOLEAN
PiCompareGuid(
    CONST GUID *Guid1,
    CONST GUID *Guid2
    )
/*++

Routine Description:

    This routine compares two guids.

Arguments:

    Guid1 - First guid to compare

    Guid2 - Second guid to compare

Return Value:

    Returns TRUE if the guids are equal and FALSE if they're different.

--*/
{
    PAGED_CODE();

    if (RtlCompareMemory((PVOID)Guid1, (PVOID)Guid2, sizeof(GUID)) == sizeof(GUID)) {
        return TRUE;
    }
    return FALSE;

} // PiCompareGuid


PVOID
PiAllocateCriticalMemory(
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     DeleteType,
    IN  POOL_TYPE                       PoolType,
    IN  SIZE_T                          Size,
    IN  ULONG                           Tag
    )
/*++

Routine Description:

    This function allocates memory and never fails if the DeleteType isn't
    QueryRemoveDevice or EjectDevice. This function will disappear in the next
    version of the PnP engine as we will instead requeue failed operations
    (which will also result in a second attempt to allocate the memory) or
    preallocate the required memory when bringing new devnode's into the world.

Arguments:

    DeleteType - Operation (EjectDevice, SurpriseRemoveDevice, ...)

    PoolType - PagedPool, NonPagedPool

    Size - Size

    Tag - Allocation tag

Return Value:

    Allocation, NULL due to insufficient resources.

--*/
{
    PVOID memory;
    LARGE_INTEGER timeOut;

    PAGED_CODE();

    //
    // Retries only have a hope of succeeding if we are at PASSIVE_LEVEL
    //
    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    while(1) {

        memory = ExAllocatePoolWithTag(PoolType, Size, Tag);

        if (memory ||
            (DeleteType == QueryRemoveDevice) ||
            (DeleteType == EjectDevice)) {

            //
            // Either we got memory or the op was failable. Get out of here.
            //
            break;
        }

        //
        // We're stuck until more memory comes along. Let some other
        // threads run before we get another shot...
        //
        timeOut.QuadPart = Int32x32To64( 1, -10000 );
        KeDelayExecutionThread(KernelMode, FALSE, &timeOut);
    }

    return memory;
}


#if DBG
struct  {
    CONST GUID *Guid;
    PCHAR   Name;
}   EventGuidTable[] =  {
    { &GUID_HWPROFILE_QUERY_CHANGE,         "GUID_HWPROFILE_QUERY_CHANGE" },
    { &GUID_HWPROFILE_CHANGE_CANCELLED,     "GUID_HWPROFILE_CHANGE_CANCELLED" },
    { &GUID_HWPROFILE_CHANGE_COMPLETE,      "GUID_HWPROFILE_CHANGE_COMPLETE" },
    { &GUID_DEVICE_INTERFACE_ARRIVAL,       "GUID_DEVICE_INTERFACE_ARRIVAL" },
    { &GUID_DEVICE_INTERFACE_REMOVAL,       "GUID_DEVICE_INTERFACE_REMOVAL" },
    { &GUID_TARGET_DEVICE_QUERY_REMOVE,     "GUID_TARGET_DEVICE_QUERY_REMOVE" },
    { &GUID_TARGET_DEVICE_REMOVE_CANCELLED, "GUID_TARGET_DEVICE_REMOVE_CANCELLED" },
    { &GUID_TARGET_DEVICE_REMOVE_COMPLETE,  "GUID_TARGET_DEVICE_REMOVE_COMPLETE" },
    { &GUID_PNP_CUSTOM_NOTIFICATION,        "GUID_PNP_CUSTOM_NOTIFICATION" },
    { &GUID_DEVICE_ARRIVAL,                 "GUID_DEVICE_ARRIVAL" },
    { &GUID_DEVICE_ENUMERATED,              "GUID_DEVICE_ENUMERATED" },
    { &GUID_DEVICE_ENUMERATE_REQUEST,       "GUID_DEVICE_ENUMERATE_REQUEST" },
    { &GUID_DEVICE_START_REQUEST,           "GUID_DEVICE_START_REQUEST" },
    { &GUID_DEVICE_REMOVE_PENDING,          "GUID_DEVICE_REMOVE_PENDING" },
    { &GUID_DEVICE_QUERY_AND_REMOVE,        "GUID_DEVICE_QUERY_AND_REMOVE" },
    { &GUID_DEVICE_EJECT,                   "GUID_DEVICE_EJECT" },
    { &GUID_DEVICE_NOOP,                    "GUID_DEVICE_NOOP" },
    { &GUID_DEVICE_SURPRISE_REMOVAL,        "GUID_DEVICE_SURPRISE_REMOVAL" },
    { &GUID_DEVICE_SAFE_REMOVAL,            "GUID_DEVICE_SAFE_REMOVAL" },
    { &GUID_DEVICE_EJECT_VETOED,            "GUID_DEVICE_EJECT_VETOED" },
    { &GUID_DEVICE_REMOVAL_VETOED,          "GUID_DEVICE_REMOVAL_VETOED" },
};
#define EVENT_GUID_TABLE_SIZE   (sizeof(EventGuidTable) / sizeof(EventGuidTable[0]))

VOID
LookupGuid(
    IN CONST GUID *Guid,
    IN OUT PCHAR String,
    IN ULONG StringLength
    )
{
    int    i;

    PAGED_CODE();

    for (i = 0; i < EVENT_GUID_TABLE_SIZE; i++) {
        if (PiCompareGuid(Guid, EventGuidTable[i].Guid)) {
            strncpy(String, EventGuidTable[i].Name, StringLength - 1);
            String[StringLength - 1] = '\0';
            return;
        }
    }

    _snprintf( String, StringLength, "%08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X",
               Guid->Data1,
               Guid->Data2,
               Guid->Data3,
               Guid->Data4[0],
               Guid->Data4[1],
               Guid->Data4[2],
               Guid->Data4[3],
               Guid->Data4[4],
               Guid->Data4[5],
               Guid->Data4[6],
               Guid->Data4[7] );
}

VOID
DumpMultiSz(
    IN PWCHAR MultiSz
    )
{
    PWCHAR  p = MultiSz;
    ULONG   length;

    PAGED_CODE();

    while (*p) {
        length = (ULONG)wcslen(p);
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "        %S\n", p));

        p += length + 1;
    }
}

VOID
DumpPnpEvent(
    IN PPLUGPLAY_EVENT_BLOCK EventBlock
    )
{
    CHAR    guidString[256];

    PAGED_CODE();

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PlugPlay Event Block @ 0x%p\n", EventBlock));

    LookupGuid(&EventBlock->EventGuid, guidString, sizeof(guidString));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    EventGuid = %s\n", guidString));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    DeviceObject = 0x%p\n", EventBlock->DeviceObject));

    switch (EventBlock->EventCategory) {
    case HardwareProfileChangeEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    HardwareProfileChangeEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        break;

    case TargetDeviceChangeEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    TargetDeviceChangeEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceIds:\n"));

        DumpMultiSz( EventBlock->u.TargetDevice.DeviceIds );
        break;

    case DeviceClassChangeEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceClassChangeEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        LookupGuid(&EventBlock->u.DeviceClass.ClassGuid, guidString, sizeof(guidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    ClassGuid = %s\n",
                   guidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    SymbolicLinkName = %S\n",
                   EventBlock->u.DeviceClass.SymbolicLinkName));
        break;

    case CustomDeviceEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    CustomDeviceEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    NotificationStructure = 0x%p\n    DeviceIds:\n",
                   EventBlock->u.CustomNotification.NotificationStructure));

        DumpMultiSz( EventBlock->u.CustomNotification.DeviceIds );
        break;

    case DeviceInstallEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceInstallEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceId = %S\n", EventBlock->u.InstallDevice.DeviceId));

        break;

    case DeviceArrivalEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceArrivalEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));
        break;
    }

}


VOID
PiDumpPdoHandlesToDebugger(
    IN  PDEVICE_OBJECT  *DeviceObjectArray,
    IN  ULONG           ArrayCount,
    IN  BOOLEAN         KnownHandleFailure
    )
/*++

Routine Description:

    This helper routine dumps any handles opened against the passed in array of
    device objects to the debugger console.

Arguments:

    DeviceObjectArray - Array of Physical Device Objects.

    ArrayCount - Number of device objects in the passed in array

    KnownHandleFailure - TRUE if the removal was vetoed due to open handles,
                         FALSE if not.

Return Value:

    None.

--*/
{
    ULONG i, handleCount;

    //
    // If we have enabled the dumping flag, or the user ran oh.exe, spit all
    // handles on a veto to the debugger.
    //
    if (!(PiDumpVetoedHandles || (NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))) {

        return;
    }

    DbgPrint("Beginning handle dump:\n");

    if (!KnownHandleFailure) {

        DbgPrint("  (Failed Query-Remove - *Might* by due to leaked handles)\n");
    }

    for(i=handleCount=0; i<ArrayCount; i++) {

        PpHandleEnumerateHandlesAgainstPdoStack(
            DeviceObjectArray[i],
            PiDumpPdoHandlesToDebuggerCallBack,
            (PVOID) &handleCount
            );
    }
    DbgPrint("Dump complete - %d total handles found.\n", handleCount);
}


BOOLEAN
PiDumpPdoHandlesToDebuggerCallBack(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PEPROCESS       Process,
    IN  PFILE_OBJECT    FileObject,
    IN  HANDLE          HandleId,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This helper routine for PiDumpPdoHandlesToDebuggerCallBack. It gets called
    back for each handle opened against a given device object.

Arguments:

    DeviceObject - Device Object handle was against. Will be valid (referenced)

    Process - Process handle was against. Will be valid (referenced)

    FileObject - File object pertaining to handle - might not be valid

    HandleId - Handle relating to open device - might not be valid

    Context - Context passed in to PpHandleEnumerateHandlesAgainstPdoStack.

Return Value:

    TRUE if the enumeration should be stopped, FALSE otherwise.

--*/
{
    PULONG handleCount;

    //
    // Display the handle.
    //
    DbgPrint(
        "  DeviceObject:%p ProcessID:%dT FileObject:%p Handle:%dT\n",
        DeviceObject,
        Process->UniqueProcessId,
        FileObject,
        HandleId
        );

    handleCount = (PULONG) Context;

    (*handleCount)++;

    return FALSE;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpinit.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpsubs.c

Abstract:

    This module contains the plug-and-play initialization
    subroutines for the I/O system.


Author:

    Shie-Lin Tzong (shielint) 30-Jan-1995

Environment:

    Kernel mode


Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

#define SYSTEM_HIVE_LOW     80
#define SYSTEM_HIVE_HIGH    90

#include <inbv.h>
#include <hdlsblk.h>
#include <hdlsterm.h>

#include <initguid.h>
#include <ntddramd.h>

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'nipP')
#endif

//
// Define the type for driver group name entries in the group list so that
// load order dependencies can be tracked.
//

typedef struct _TREE_ENTRY {
    struct _TREE_ENTRY *Left;
    struct _TREE_ENTRY *Right;
    struct _TREE_ENTRY *Sibling;
    ULONG DriversThisType;
    ULONG DriversLoaded;
    UNICODE_STRING GroupName;
} TREE_ENTRY, *PTREE_ENTRY;

typedef struct _DRIVER_INFORMATION {
    LIST_ENTRY              Link;
    PDRIVER_OBJECT          DriverObject;
    PBOOT_DRIVER_LIST_ENTRY DataTableEntry;
    HANDLE                  ServiceHandle;
    USHORT                  TagPosition;
    BOOLEAN                 Failed;
    BOOLEAN                 Processed;
    NTSTATUS                Status;
} DRIVER_INFORMATION, *PDRIVER_INFORMATION;

PTREE_ENTRY IopGroupListHead;

#define ALLOW_WORLD_READ_OF_ENUM        1

PTREE_ENTRY
PipCreateEntry(
    IN PUNICODE_STRING GroupName
    );

VOID
PipFreeGroupTree(
    IN PTREE_ENTRY TreeEntry
    );

USHORT
PipGetDriverTagPriority(
    IN HANDLE Servicehandle
    );

NTSTATUS
PipPnPDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
PipAddDevicesToBootDriver(
   IN PDRIVER_OBJECT DriverObject
   );

BOOLEAN
PipAddDevicesToBootDriverWorker(
    IN HANDLE DeviceInstanceHandle,
    IN PUNICODE_STRING DeviceInstancePath,
    IN OUT PVOID Context
    );

BOOLEAN
PipCheckDependencies(
    IN HANDLE KeyHandle
    );

INTERFACE_TYPE
PipDetermineDefaultInterfaceType(
    VOID
    );

VOID
PipInsertDriverList(
    IN PLIST_ENTRY ListHead,
    IN PDRIVER_INFORMATION DriverInfo
    );

PTREE_ENTRY
PipLookupGroupName(
    IN PUNICODE_STRING GroupName,
    IN BOOLEAN Insert
    );

VOID
PipNotifySetupDevices(
    PDEVICE_NODE DeviceNode
    );

BOOLEAN
PipWaitForBootDevicesDeleted(
    IN VOID
    );

BOOLEAN
PipWaitForBootDevicesStarted(
    IN VOID
    );

BOOLEAN
PiInitPhase0(
    VOID
    );

NTSTATUS
RawInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
PiInitCacheGroupInformation(
    VOID
    );

VOID
PiInitReleaseCachedGroupInformation(
    VOID
    );

NTSTATUS
IopStartRamdisk(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

//
// Group order table
//

ULONG IopGroupIndex;
PLIST_ENTRY IopGroupTable;

//
// Group order cache list.
//
UNICODE_STRING *PiInitGroupOrderTable      = NULL;
USHORT          PiInitGroupOrderTableCount = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IopInitializeBootDrivers)
#pragma alloc_text(INIT, IopInitializePlugPlayServices)
#pragma alloc_text(INIT, IopInitializeSystemDrivers)

#pragma alloc_text(INIT, PipAddDevicesToBootDriver)
#pragma alloc_text(INIT, PipAddDevicesToBootDriverWorker)
#pragma alloc_text(INIT, PipCheckDependencies)
#pragma alloc_text(INIT, PipCreateEntry)
#pragma alloc_text(INIT, PipDetermineDefaultInterfaceType)
#pragma alloc_text(INIT, PipFreeGroupTree)
#pragma alloc_text(INIT, PipGetDriverTagPriority)
#pragma alloc_text(INIT, PipInsertDriverList)
#pragma alloc_text(INIT, PipLoadBootFilterDriver)
#pragma alloc_text(INIT, PipLookupGroupName)
#pragma alloc_text(INIT, PipNotifySetupDevices)
#pragma alloc_text(INIT, PipPnPDriverEntry)
#pragma alloc_text(INIT, PipWaitForBootDevicesDeleted)
#pragma alloc_text(INIT, PipWaitForBootDevicesStarted)

#pragma alloc_text(INIT, PiInitPhase0)
#pragma alloc_text(INIT, PpInitSystem)
#pragma alloc_text(INIT, PiInitCacheGroupInformation)
#pragma alloc_text(INIT, PiInitReleaseCachedGroupInformation)
#pragma alloc_text(INIT, PpInitGetGroupOrderIndex)

#pragma alloc_text(INIT, IopStartRamdisk)

#endif

NTSTATUS
IopInitializePlugPlayServices(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG Phase
    )

/*++

Routine Description:

    This routine initializes kernel mode Plug and Play services.

Arguments:

    LoaderBlock - supplies a pointer to the LoaderBlock passed in from the
        OS Loader.

Returns:

    NTSTATUS code for sucess or reason of failure.

--*/
{
    NTSTATUS status;
    HANDLE hTreeHandle, parentHandle, handle, hCurrentControlSet = NULL;
    UNICODE_STRING unicodeName;
    PKEY_VALUE_FULL_INFORMATION detectionInfo;
    PDEVICE_OBJECT deviceObject;
    ULONG disposition;
    INTERFACE_TYPE interface;

    if (Phase == 0) {

        PnPInitialized = FALSE;

        //
        // Register with CM so we get called when the system hive becomes too
        // large.
        //
        PpSystemHiveLimits.Low = SYSTEM_HIVE_LOW;
        PpSystemHiveLimits.High = SYSTEM_HIVE_HIGH;
        CmRegisterSystemHiveLimitCallback(
            SYSTEM_HIVE_LOW,
            SYSTEM_HIVE_HIGH,
            (PVOID)&PpSystemHiveLimits,
            (PCM_HYSTERESIS_CALLBACK)PpSystemHiveLimitCallback
            );
        PpSystemHiveTooLarge = FALSE;

        //
        // Initialize the blocked driver database.
        //

        PpInitializeBootDDB(LoaderBlock);

        //
        // Build up the group order cache list. This is the MultiSz string that
        // tells us what order to start legacy drivers in. Drivers belonging to
        // an earlier group get started first (within the group Tag ordering is
        // used)
        //
        status = PiInitCacheGroupInformation();
        if (!NT_SUCCESS(status)) {

            return FALSE;
        }

        //
        // Initialize the registry access semaphore.
        //

        KeInitializeSemaphore( &PpRegistrySemaphore, 1, 1 );

        //
        // Initialize the Legacy Bus information table.
        //

        for (interface = Internal; interface < MaximumInterfaceType; interface++) {

            InitializeListHead(&IopLegacyBusInformationTable[interface]);
        }

        //
        // Initialize the resource map
        //

        IopInitializeResourceMap (LoaderBlock);

        //
        // Allocate two one-page scratch buffers to be used by our
        // initialization code.  This avoids constant pool allocations.
        //

        IopPnpScratchBuffer1 = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
        if (!IopPnpScratchBuffer1) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        IopPnpScratchBuffer2 = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
        if (!IopPnpScratchBuffer2) {
            ExFreePool(IopPnpScratchBuffer1);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IopInitReservedResourceList = NULL;

        IopAllocateBootResourcesRoutine = IopReportBootResources;

        //
        // Determine the PnpDefaultInterfaceType.  For root enumerated devices if the Interface
        // type of their resource list or resource requirements list are undefined.  We will use
        // the default type instead.
        //

        PnpDefaultInterfaceType = PipDetermineDefaultInterfaceType();

        //
        // Initialize root arbiters
        //

        status = IopPortInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopMemInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopDmaInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopIrqInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopBusNumberInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopOpenRegistryKeyEx( &hCurrentControlSet,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSet,
                                       KEY_ALL_ACCESS
                                       );
        if (!NT_SUCCESS(status)) {
            hCurrentControlSet = NULL;
            goto init_Exit0;
        }
        //
        // Open HKLM\System\CurrentControlSet\Control\Pnp
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_PATH_CONTROL_PNP);
        status = IopCreateRegistryKeyEx( &handle,
                                         hCurrentControlSet,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        if (NT_SUCCESS(status)) {
            //
            // HACK: Since it was too late to make the change in XP, we target
            // this behaviour at machines with MATROX G100. The inf sets this 
            // flag in the registry.
            //
            status = IopGetRegistryValue(handle,
                                         REGSTR_VAL_WIN2000STARTORDER,
                                         &detectionInfo
                                         );
            if (NT_SUCCESS(status)) {

                if (detectionInfo->Type == REG_DWORD && detectionInfo->DataLength == sizeof(ULONG)) {

                    PpCallerInitializesRequestTable = (BOOLEAN) *(KEY_VALUE_DATA(detectionInfo));
                }
                ExFreePool(detectionInfo);
            }
            NtClose(handle);
        }
        
        //
        // Next open/create System\CurrentControlSet\Enum\Root key.
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_ENUM);
        status = IopCreateRegistryKeyEx( &handle,
                                         hCurrentControlSet,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         &disposition
                                         );
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        if (disposition == REG_CREATED_NEW_KEY) {
            SECURITY_DESCRIPTOR     newSD;
            PACL                    newDacl;
            ULONG                   sizeDacl;

            status = RtlCreateSecurityDescriptor( &newSD,
                                                  SECURITY_DESCRIPTOR_REVISION );
            ASSERT( NT_SUCCESS( status ) );

            //
            // calculate the size of the new DACL
            //
            sizeDacl = sizeof(ACL);
            sizeDacl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(SeLocalSystemSid) - sizeof(ULONG);

#if ALLOW_WORLD_READ_OF_ENUM
            sizeDacl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(SeWorldSid) - sizeof(ULONG);
#endif

            //
            // create and initialize the new DACL
            //
            newDacl = ExAllocatePool(PagedPool, sizeDacl);

            if (newDacl != NULL) {

                status = RtlCreateAcl(newDacl, sizeDacl, ACL_REVISION);

                ASSERT( NT_SUCCESS( status ) );

                //
                // Add just the local system full control ace to this new DACL
                //
                status = RtlAddAccessAllowedAceEx( newDacl,
                                                   ACL_REVISION,
                                                   CONTAINER_INHERIT_ACE,
                                                   KEY_ALL_ACCESS,
                                                   SeLocalSystemSid
                                                   );
                ASSERT( NT_SUCCESS( status ) );

#if ALLOW_WORLD_READ_OF_ENUM
                //
                // Add just the local system full control ace to this new DACL
                //
                status = RtlAddAccessAllowedAceEx( newDacl,
                                                   ACL_REVISION,
                                                   CONTAINER_INHERIT_ACE,
                                                   KEY_READ,
                                                   SeWorldSid
                                                   );
                ASSERT( NT_SUCCESS( status ) );

#endif
                //
                // Set the new DACL in the absolute security descriptor
                //
                status = RtlSetDaclSecurityDescriptor( (PSECURITY_DESCRIPTOR) &newSD,
                                                       TRUE,
                                                       newDacl,
                                                       FALSE
                                                       );

                ASSERT( NT_SUCCESS( status ) );

                //
                // validate the new security descriptor
                //
                status = RtlValidSecurityDescriptor(&newSD);

                ASSERT( NT_SUCCESS( status ) );

                status = ZwSetSecurityObject( handle,
                                              DACL_SECURITY_INFORMATION,
                                              &newSD
                                              );
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IopInitializePlugPlayServices: ZwSetSecurityObject on Enum key failed, status = %8.8X\n", status));
                }

                ExFreePool(newDacl);
            } else {

                IopDbgPrint((   IOP_ERROR_LEVEL,
                                "IopInitializePlugPlayServices: ExAllocatePool failed allocating DACL for Enum key\n"));
            }
        }

        parentHandle = handle;
        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_ROOTENUM);
        status = IopCreateRegistryKeyEx( &handle,
                                         parentHandle,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        NtClose(parentHandle);
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }
        NtClose(handle);

        //
        // Create the registry entry for the root of the hardware tree (HTREE\ROOT\0).
        //

        status = IopOpenRegistryKeyEx( &handle,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetEnumName,
                                       KEY_ALL_ACCESS
                                       );
        if (NT_SUCCESS(status)) {
            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_ROOT_DEVNODE);
            status = IopCreateRegistryKeyEx( &hTreeHandle,
                                             handle,
                                             &unicodeName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );
            NtClose(handle);
            if (NT_SUCCESS(status)) {
                NtClose(hTreeHandle);
            }
        }

        //
        // Before creating device node tree, we need to initialize the device
        // tree lock.
        //

        InitializeListHead(&IopPendingEjects);
        InitializeListHead(&IopPendingSurpriseRemovals);
        InitializeListHead(&IopPnpEnumerationRequestList);
        ExInitializeResourceLite(&IopDeviceTreeLock);
        ExInitializeResourceLite(&IopSurpriseRemoveListLock);
        PiInitializeEngineLock();
        KeInitializeEvent(&PiEventQueueEmpty, NotificationEvent, TRUE );
        KeInitializeEvent(&PiEnumerationLock, NotificationEvent, TRUE );
        KeInitializeSpinLock(&IopPnPSpinLock);

        //
        // Initialize the hardware profile/docking support.
        //
        PpProfileInit();

        //
        // Initialize warm docking variables.
        //
        IopWarmEjectPdo = NULL;
        KeInitializeEvent(&IopWarmEjectLock, SynchronizationEvent, TRUE );

        //
        // Create a PnP manager's driver object to own all the detected PDOs.
        //

        PiWstrToUnicodeString(&unicodeName, PNPMGR_STR_PNP_DRIVER);
        status = IoCreateDriver (&unicodeName, PipPnPDriverEntry);
        if (NT_SUCCESS(status)) {

            //
            // Create empty device node tree, i.e., only contains only root device node
            //     (No need to initialize Parent, Child and Sibling links.)

            status = IoCreateDevice( IoPnpDriverObject,
                                     sizeof(IOPNP_DEVICE_EXTENSION),
                                     NULL,
                                     FILE_DEVICE_CONTROLLER,
                                     0,
                                     FALSE,
                                     &deviceObject );

            if (NT_SUCCESS(status)) {
                deviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;
                status = PipAllocateDeviceNode(
                    deviceObject,
                    &IopRootDeviceNode);

                if (!IopRootDeviceNode) {

                    IoDeleteDevice(deviceObject);
                    IoDeleteDriver(IoPnpDriverObject);
                } else {

                    IopRootDeviceNode->Flags |= DNF_MADEUP |
                                                DNF_ENUMERATED |
                                                DNF_IDS_QUERIED |
                                                DNF_NO_RESOURCE_REQUIRED;

                    IopRootDeviceNode->InstancePath.Buffer = ExAllocatePool( PagedPool,
                                                                             sizeof(REGSTR_VAL_ROOT_DEVNODE));

                    if (IopRootDeviceNode->InstancePath.Buffer != NULL) {
                        IopRootDeviceNode->InstancePath.MaximumLength = sizeof(REGSTR_VAL_ROOT_DEVNODE);
                        IopRootDeviceNode->InstancePath.Length = sizeof(REGSTR_VAL_ROOT_DEVNODE) - sizeof(WCHAR);

                        RtlCopyMemory( IopRootDeviceNode->InstancePath.Buffer,
                                       REGSTR_VAL_ROOT_DEVNODE,
                                       sizeof(REGSTR_VAL_ROOT_DEVNODE));
                    } else {
                        ASSERT(IopRootDeviceNode->InstancePath.Buffer);
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto init_Exit0;
                    }
                    status = IopMapDeviceObjectToDeviceInstance(
                        IopRootDeviceNode->PhysicalDeviceObject,
                        &IopRootDeviceNode->InstancePath);
                    if (!NT_SUCCESS(status)) {
                        goto init_Exit0;
                    }
                    PipSetDevNodeState(IopRootDeviceNode, DeviceNodeStarted, NULL);
                }
            }
        }

        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        //
        // Initialize the kernel mode pnp notification system
        //

        status = PpInitializeNotification();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        IopInitializePlugPlayNotification();

        //
        // Initialize table for holding bus type guid list.
        //

        status = PpBusTypeGuidInitialize();
        if (!NT_SUCCESS(status)) {

            goto init_Exit0;
        }

        //
        // Enumerate the ROOT bus synchronously.
        //

        PipRequestDeviceAction( IopRootDeviceNode->PhysicalDeviceObject,
                                ReenumerateRootDevices,
                                FALSE,
                                0,
                                NULL,
                                NULL);

init_Exit0:

        //
        // If we managed to open the Current Control Set close it
        //

        if (hCurrentControlSet) {
            NtClose(hCurrentControlSet);
        }

        if (!NT_SUCCESS(status)) {
            ExFreePool(IopPnpScratchBuffer1);
            ExFreePool(IopPnpScratchBuffer2);
        }

    } else if (Phase == 1) {

        BOOLEAN legacySerialPortMappingOnly = FALSE;

        //
        // Next open/create System\CurrentControlSet\Enum\Root key.
        //

        status = IopOpenRegistryKeyEx( &hCurrentControlSet,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSet,
                                       KEY_ALL_ACCESS
                                       );
        if (!NT_SUCCESS(status)) {
            hCurrentControlSet = NULL;
            goto init_Exit1;
        }

        //
        // Open HKLM\System\CurrentControlSet\Control\Pnp
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_PATH_CONTROL_PNP);
        status = IopCreateRegistryKeyEx( &handle,
                                         hCurrentControlSet,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        if (!NT_SUCCESS(status)) {
            goto init_Exit1;
        }

        //
        // Check the "DisableFirmwareMapper" value entry to see whether we
        // should skip mapping ntdetect/firmware reported devices (except for
        // COM ports, which we always map).
        //

        status = IopGetRegistryValue(handle,
                                     REGSTR_VALUE_DISABLE_FIRMWARE_MAPPER,
                                     &detectionInfo
                                     );

        if (NT_SUCCESS(status)) {

            if (detectionInfo->Type == REG_DWORD && detectionInfo->DataLength == sizeof(ULONG)) {
                legacySerialPortMappingOnly = (BOOLEAN) *(KEY_VALUE_DATA(detectionInfo));
            }

            ExFreePool(detectionInfo);

        }
        NtClose(handle);

        //
        // Collect the necessary firmware tree information.
        //

        MapperProcessFirmwareTree(legacySerialPortMappingOnly);

        //
        // Map this into the root enumerator tree
        //

        MapperConstructRootEnumTree(legacySerialPortMappingOnly);

#if i386
        if (!legacySerialPortMappingOnly) {

            //
            // Now do the PnP BIOS enumerated devnodes.
            //
            extern NTSTATUS PnPBiosMapper(VOID);

            status = PnPBiosMapper();

            //
            // If the previous call succeeds, we have a PNPBios, turn any newly
            // created ntdetect COM ports into phantoms
            //
            if (NT_SUCCESS(status)) {
                MapperPhantomizeDetectedComPorts();
            }
        }
        EisaBuildEisaDeviceNode();
#endif

        //
        // We're done with the firmware mapper device list.
        //

        MapperFreeList();


        //
        // Enumerate the ROOT bus synchronously.
        //

        PipRequestDeviceAction( IopRootDeviceNode->PhysicalDeviceObject,
                                ReenumerateRootDevices,
                                FALSE,
                                0,
                                NULL,
                                NULL);

init_Exit1:

        //
        // If we managed to open the Current Control Set close it
        //

        if(hCurrentControlSet) {
            NtClose(hCurrentControlSet);
        }

        //
        // Free our scratch buffers and exit.
        //

        ExFreePool(IopPnpScratchBuffer1);
        ExFreePool(IopPnpScratchBuffer2);
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INVALID_PARAMETER_1;
    }

    return status;
}

NTSTATUS
PipPnPDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    PnP Driver Object.  In this function, we need to remember the DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER( RegistryPath );

    //
    // File the pointer to our driver object away
    //

    IoPnpDriverObject = DriverObject;

    //
    // Fill in the driver object
    //

    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)IopPnPAddDevice;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = IopPnPDispatch;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = IopPowerDispatch;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = IopSystemControlDispatch;

    return STATUS_SUCCESS;

}

INTERFACE_TYPE
PipDetermineDefaultInterfaceType (
    VOID
    )

/*++

Routine Description:

    This routine checks if detection flag is set to enable driver detection.
    The detection will be enabled if there is no PCI bus in the machine and only
    on ALPHA machine.

Parameters:

    None.

Return Value:

    BOOLEAN value to indicate if detection is enabled.

--*/

{
    NTSTATUS status;
    PVOID p;
    PHAL_BUS_INFORMATION pBusInfo;
    ULONG length, i;
    INTERFACE_TYPE interfaceType = Isa;

    pBusInfo = IopPnpScratchBuffer1;
    length = PNP_LARGE_SCRATCH_BUFFER_SIZE;
    status = HalQuerySystemInformation (
                HalInstalledBusInformation,
                length,
                pBusInfo,
                &length
                );

    if (!NT_SUCCESS(status)) {

        return interfaceType;
    }

    //
    // Check installed bus information to make sure there is no existing Pnp Isa
    // bus extender.
    //

    p = pBusInfo;
    for (i = 0; i < length / sizeof(HAL_BUS_INFORMATION); i++, pBusInfo++) {
        if (pBusInfo->BusType == Isa || pBusInfo->BusType == Eisa) {
            interfaceType = Isa;
            break;
        } else if (pBusInfo->BusType == MicroChannel) {
            interfaceType = MicroChannel;
        }
    }

    return interfaceType;
}

BOOLEAN
PipCheckDependencies(
    IN HANDLE KeyHandle
    )

/*++

Routine Description:

    This routine gets the "DependOnGroup" field for the specified key node
    and determines whether any driver in the group(s) that this entry is
    dependent on has successfully loaded.

Arguments:

    KeyHandle - Supplies a handle to the key representing the driver in
        question.

Return Value:

    The function value is TRUE if the driver should be loaded, otherwise
    FALSE

--*/

{
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING groupName;
    BOOLEAN load;
    ULONG length;
    PWSTR source;
    PTREE_ENTRY treeEntry;

    //
    // Attempt to obtain the "DependOnGroup" key for the specified driver
    // entry.  If one does not exist, then simply mark this driver as being
    // one to attempt to load.  If it does exist, then check to see whether
    // or not any driver in the groups that it is dependent on has loaded
    // and allow it to load.
    //

    if (!NT_SUCCESS( IopGetRegistryValue( KeyHandle, L"DependOnGroup", &keyValueInformation ))) {
        return TRUE;
    }

    length = keyValueInformation->DataLength;

    source = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
    load = TRUE;

    while (length) {
        RtlInitUnicodeString( &groupName, source );
        groupName.Length = groupName.MaximumLength;
        treeEntry = PipLookupGroupName( &groupName, FALSE );
        if (treeEntry) {
            if (!treeEntry->DriversLoaded) {
                load = FALSE;
                break;
            }
        }
        length -= groupName.MaximumLength;
        source = (PWSTR) ((PUCHAR) source + groupName.MaximumLength);
    }

    ExFreePool( keyValueInformation );
    return load;
}

PTREE_ENTRY
PipCreateEntry(
    IN PUNICODE_STRING GroupName
    )

/*++

Routine Description:

    This routine creates an entry for the specified group name suitable for
    being inserted into the group name tree.

Arguments:

    GroupName - Specifies the name of the group for the entry.

Return Value:

    The function value is a pointer to the created entry.


--*/

{
    PTREE_ENTRY treeEntry;

    //
    // Allocate and initialize an entry suitable for placing into the group
    // name tree.
    //

    treeEntry = ExAllocatePool( PagedPool,
                                sizeof( TREE_ENTRY ) + GroupName->Length );

    //
    // We return NULL here and what this really implies that
    // we won't be able to determine if drivers for this group
    // was loaded.
    //
    if (!treeEntry) {
        return NULL;
    }

    RtlZeroMemory( treeEntry, sizeof( TREE_ENTRY ) );
    treeEntry->GroupName.Length = GroupName->Length;
    treeEntry->GroupName.MaximumLength = GroupName->Length;
    treeEntry->GroupName.Buffer = (PWCHAR) (treeEntry + 1);
    RtlCopyMemory( treeEntry->GroupName.Buffer,
                   GroupName->Buffer,
                   GroupName->Length );

    return treeEntry;
}

VOID
PipFreeGroupTree(
    PTREE_ENTRY TreeEntry
    )

/*++

Routine Description:

    This routine is invoked to free a node from the group dependency tree.
    It is invoked the first time with the root of the tree, and thereafter
    recursively to walk the tree and remove the nodes.

Arguments:

    TreeEntry - Supplies a pointer to the node to be freed.

Return Value:

    None.

--*/

{
    //
    // Simply walk the tree in ascending order from the bottom up and free
    // each node along the way.
    //

    if (TreeEntry->Left) {
        PipFreeGroupTree( TreeEntry->Left );
    }

    if (TreeEntry->Sibling) {
        PipFreeGroupTree( TreeEntry->Sibling );
    }

    if (TreeEntry->Right) {
        PipFreeGroupTree( TreeEntry->Right );
    }

    //
    // All of the children and siblings for this node have been freed, so
    // now free this node as well.
    //

    ExFreePool( TreeEntry );
}

BOOLEAN
IopInitializeBootDrivers(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    OUT PDRIVER_OBJECT *PreviousDriver
    )

/*++

Routine Description:

    This routine is invoked to initialize the boot drivers that were loaded
    by the OS Loader.  The list of drivers is provided as part of the loader
    parameter block.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block, created
        by the OS Loader.

    Previous Driver - Supplies a variable to receive the address of the
        driver object chain created by initializing the drivers.

Return Value:

    The function value is a BOOLEAN indicating whether or not the boot
    drivers were successfully initialized.

--*/

{
    UNICODE_STRING completeName;
    UNICODE_STRING rawFsName;
    NTSTATUS status;
    PLIST_ENTRY nextEntry;
    PBOOT_DRIVER_LIST_ENTRY bootDriver;
    HANDLE keyHandle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PDRIVER_OBJECT driverObject;
    USHORT i, j;
    PKLDR_DATA_TABLE_ENTRY driverEntry;
    PKLDR_DATA_TABLE_ENTRY dllEntry;
    UNICODE_STRING groupName;
    PTREE_ENTRY treeEntry;
    PDRIVER_INFORMATION driverInfo;
    BOOLEAN textModeSetup = FALSE;
    BOOLEAN bootReinitDriversFound;
    ULONG remotebootcount = 0;

    UNREFERENCED_PARAMETER( PreviousDriver );

    //
    // Initialize the built-in RAW file system driver.
    //

    PiWstrToUnicodeString( &rawFsName, L"\\FileSystem\\RAW" );
    PiWstrToUnicodeString( &completeName, L"" );
    IopInitializeBuiltinDriver(&rawFsName,
                               &completeName,
                               RawInitialize,
                               NULL,
                               FALSE,
                               &driverObject);
    if (!driverObject) {
#if DBG
        DbgPrint( "IOINIT: Failed to initialize RAW filsystem \n" );

#endif

        return FALSE;
    }

    //
    // Determine number of group orders and build a list_entry array to link all the drivers
    // together based on their groups.
    //

    IopGroupIndex = PpInitGetGroupOrderIndex(NULL);
    if (IopGroupIndex == NO_MORE_GROUP) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_FIND_GROUPS_FAILED, NULL);
        return FALSE;
    }

    IopGroupTable = (PLIST_ENTRY) ExAllocatePool(PagedPool, IopGroupIndex * sizeof (LIST_ENTRY));
    if (IopGroupTable == NULL) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_OUT_OF_MEMORY, NULL);
        return FALSE;
    }
    for (i = 0; i < IopGroupIndex; i++) {
        InitializeListHead(&IopGroupTable[i]);
    }

    PnpAsyncOk = FALSE;

    //
    // Call DllInitialize for driver dependent DLLs.
    //

    nextEntry = LoaderBlock->LoadOrderListHead.Flink;
    while (nextEntry != &LoaderBlock->LoadOrderListHead) {
        dllEntry = CONTAINING_RECORD(nextEntry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (dllEntry->Flags & LDRP_DRIVER_DEPENDENT_DLL) {
            (VOID)MmCallDllInitialize(dllEntry, &LoaderBlock->LoadOrderListHead);
        }
        nextEntry = nextEntry->Flink;
    }

    //
    // Allocate pool to store driver's start information.
    // All the driver info records with the same group value will be linked into a list.
    //

    nextEntry = LoaderBlock->BootDriverListHead.Flink;
    while (nextEntry != &LoaderBlock->BootDriverListHead) {
        bootDriver = CONTAINING_RECORD( nextEntry,
                                        BOOT_DRIVER_LIST_ENTRY,
                                        Link );
        driverEntry = bootDriver->LdrEntry;
        driverInfo = (PDRIVER_INFORMATION) ExAllocatePool(
                        PagedPool, sizeof(DRIVER_INFORMATION));
        if (driverInfo) {
            RtlZeroMemory(driverInfo, sizeof(DRIVER_INFORMATION));
            InitializeListHead(&driverInfo->Link);
            driverInfo->DataTableEntry = bootDriver;

            //
            // Open the driver's registry key to find out if this is a
            // filesystem or a driver.
            //

            status = IopOpenRegistryKeyEx( &keyHandle,
                                           (HANDLE)NULL,
                                           &bootDriver->RegistryPath,
                                           KEY_READ
                                           );
            if (!NT_SUCCESS( status )) {
                ExFreePool(driverInfo);
            } else {
                driverInfo->ServiceHandle = keyHandle;
                j = PpInitGetGroupOrderIndex(keyHandle);
                if (j == SETUP_RESERVED_GROUP) {

                    textModeSetup = TRUE;

                    //
                    // Special handling for setupdd.sys
                    //

                    status = IopGetDriverNameFromKeyNode( keyHandle,
                                                          &completeName );
                    if (NT_SUCCESS(status)) {

                        driverInfo->Status = IopInitializeBuiltinDriver(
                                           &completeName,
                                           &bootDriver->RegistryPath,
                                           (PDRIVER_INITIALIZE) driverEntry->EntryPoint,
                                           driverEntry,
                                           FALSE,
                                           &driverObject);
                        ExFreePool(completeName.Buffer);
                        NtClose(keyHandle);
                        ExFreePool(driverInfo);
                        if (driverObject) {

                            //
                            // Once we successfully initialized the setupdd.sys, we are ready
                            // to notify it all the root enumerated devices.
                            //

                            PipNotifySetupDevices(IopRootDeviceNode);
                        } else {
                            ExFreePool(IopGroupTable);
                            return FALSE;
                        }
                    }

                } else {
                    driverInfo->TagPosition = PipGetDriverTagPriority(keyHandle);
                    PipInsertDriverList(&IopGroupTable[j], driverInfo);
                }
            }
        }
        nextEntry = nextEntry->Flink;
    }

    //
    // Process each driver base on its group.  The group with lower index number (higher
    // priority) is processed first.
    //

    for (i = 0; i < IopGroupIndex; i++) {
        nextEntry = IopGroupTable[i].Flink;
        while (nextEntry != &IopGroupTable[i]) {

            driverInfo = CONTAINING_RECORD(nextEntry, DRIVER_INFORMATION, Link);
            keyHandle = driverInfo->ServiceHandle;
            bootDriver = driverInfo->DataTableEntry;
            driverEntry = bootDriver->LdrEntry;
            driverInfo->Processed = TRUE;

            //
            // call the driver's driver entry
            //
            // See if this driver has an ObjectName value.  If so, this value
            // overrides the default ("\Driver" or "\FileSystem").
            //

            status = IopGetDriverNameFromKeyNode( keyHandle,
                                                  &completeName );
            if (!NT_SUCCESS( status )) {

#if DBG
                DbgPrint( "IOINIT: Could not get driver name for %wZ\n",
                          &bootDriver->RegistryPath );
#endif // DBG

                driverInfo->Failed = TRUE;
            } else {

                status = IopGetRegistryValue( keyHandle,
                                              REGSTR_VALUE_GROUP,
                                              &keyValueInformation );
                if (NT_SUCCESS( status )) {

                    if (keyValueInformation->DataLength) {
                        groupName.Length = (USHORT) keyValueInformation->DataLength;
                        groupName.MaximumLength = groupName.Length;
                        groupName.Buffer = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
                        treeEntry = PipLookupGroupName( &groupName, TRUE );
                    } else {
                        treeEntry = (PTREE_ENTRY) NULL;
                    }
                    ExFreePool( keyValueInformation );
                } else {
                    treeEntry = (PTREE_ENTRY) NULL;
                }

                driverObject = NULL;
                if (PipCheckDependencies( keyHandle )) {
                    //
                    // The driver may already be initialized by IopInitializeBootFilterDriver
                    // if it is boot filter driver.
                    // If not, initialize it.
                    //

                    driverObject = driverInfo->DriverObject;
                    if (driverObject == NULL && !driverInfo->Failed) {

                        driverInfo->Status = IopInitializeBuiltinDriver(
                                           &completeName,
                                           &bootDriver->RegistryPath,
                                           (PDRIVER_INITIALIZE) driverEntry->EntryPoint,
                                           driverEntry,
                                           FALSE,
                                           &driverObject);
                        //
                        // Pnp might unload the driver before we get a chance to look at this. So take an extra
                        // reference.
                        //
                        if (driverObject) {
                            ObReferenceObject(driverObject);

                            //
                            // If we load the driver because we think it is a legacy driver and
                            // it does not create any device object in its DriverEntry.  We will
                            // unload this driver.
                            //

                            if (!IopIsLegacyDriver(driverObject)) {
                                if (driverObject->DeviceObject == NULL     &&
                                    driverObject->DriverExtension->ServiceKeyName.Buffer &&
                                    !IopIsAnyDeviceInstanceEnabled(&driverObject->DriverExtension->ServiceKeyName, NULL, FALSE)) {
                                    if (textModeSetup && !(driverObject->Flags & DRVO_REINIT_REGISTERED)) {

                                        //
                                        // Clean up but leave driver object.  Because it may be needed later.
                                        // After boot driver phase completes, we will process all the driver objects
                                        // which still have no device to control.
                                        //

                                        IopDriverLoadingFailed(NULL, &driverObject->DriverExtension->ServiceKeyName);
                                    }
                                } else {

                                    //
                                    // Start the devices controlled by the driver and enumerate them
                                    // At this point, we know there is at least one device controlled by the driver.
                                    //

                                    IopDeleteLegacyKey(driverObject);
                                }
                            }
                        }
                    }
                }
                if (driverObject) {
                    if (treeEntry) {
                        treeEntry->DriversLoaded++;
                    }
                    driverInfo->DriverObject = driverObject;

                } else {
                    driverInfo->Failed = TRUE;
                }
                ExFreePool( completeName.Buffer );
            }
            if (!driverInfo->Failed) {

                PipAddDevicesToBootDriver(driverObject);

                //
                // Scan the hardware tree looking for devices which need
                // resources or starting.
                //

                PipRequestDeviceAction( NULL,
                                        ReenumerateBootDevices,
                                        FALSE,
                                        0,
                                        NULL,
                                        NULL);

            }

            //
            // Before processing next boot driver, wait for IoRequestDeviceRemoval complete.
            // The driver to be processed may need the resources being released by
            // IoRequestDeviceRemoval.  (For drivers report detected BOOT device if they fail to
            // get the resources in their DriverEntry.  They will fail and we will bugcheck with
            // inaccessible boot device.)
            //

            if (!PipWaitForBootDevicesDeleted()) {
                HeadlessKernelAddLogEntry(HEADLESS_LOG_WAIT_BOOT_DEVICES_DELETE_FAILED, NULL);
                return FALSE;
            }

            nextEntry = nextEntry->Flink;
        }

        //
        // If we are done with Bus driver group, then it's time to reserved the Hal resources
        // and reserve boot resources
        //

        if (i == BUS_DRIVER_GROUP) {
            if (textModeSetup == FALSE) {
                //
                // ISSUE - 2000/08/23 - SantoshJ - There are problems with Async ops, disable for now.
                //
                // PnpAsyncOk = TRUE;
            }

            //
            // Reserve BOOT configs on Internal bus 0.
            //

            IopAllocateLegacyBootResources(Internal, 0);
            IopAllocateBootResourcesRoutine = IopAllocateBootResources;
            ASSERT(IopInitHalResources == NULL);
            ASSERT(IopInitReservedResourceList == NULL);
            IopBootConfigsReserved = TRUE;

        }
    }

    //
    // If we started a network boot driver, then imitate what DHCP does
    // in sending IOCTLs.
    //

    if (IoRemoteBootClient) {
        //
        // try a hack since TCPIP may not be initialized.  (There is no
        // guarantee that if a device is initialized that the protocols are
        // finished binding.)  So if the call fails, we just sleep for a bit
        // and try again until it works or we fall out of this loop.
        //
        remotebootcount = 0;
        status = IopStartTcpIpForRemoteBoot(LoaderBlock);
        while ( status == STATUS_DEVICE_DOES_NOT_EXIST && remotebootcount < 20) {

            LARGE_INTEGER Delay;

            //
            // sleep for a second and try again.
            //
            Delay.LowPart  = 0xff676980 ;
            Delay.HighPart = 0xffffffff ;

            NtDelayExecution( FALSE, &Delay );

            remotebootcount += 1;
            status = IopStartTcpIpForRemoteBoot(LoaderBlock);
        }

        if (!NT_SUCCESS(status)) {
            KeBugCheckEx( NETWORK_BOOT_INITIALIZATION_FAILED,
                          3,
                          status,
                          0,
                          0 );
        }
    }

    //
    // Scan the hardware tree looking for devices which need
    // resources or starting.
    //
    PnPBootDriversLoaded = TRUE;

    PipRequestDeviceAction(NULL, AssignResources, FALSE, 0, NULL, NULL);

    //
    // If start irps are handled asynchronously, we need to make sure all the boot devices
    // started before continue.
    //

    if (!PipWaitForBootDevicesStarted()) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_WAIT_BOOT_DEVICES_START_FAILED, NULL);
        return FALSE;
    }

    bootReinitDriversFound = IopCallBootDriverReinitializationRoutines();

    //
    // If there were any drivers that registered for boot reinitialization, then
    // we need to wait one more time to make sure we catch any additional
    // devices that were created in response to the reinitialization callback.
    //

    if (bootReinitDriversFound && !PipWaitForBootDevicesStarted()) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_WAIT_BOOT_DEVICES_REINIT_FAILED, NULL);
        return FALSE;
    }

    //
    // Link NT device names to ARC names now that all of the boot drivers
    // have intialized.
    //

    IopCreateArcNames( LoaderBlock );

    //
    // If we're booting from a RAM disk, initialize it now.
    //

    if ( _memicmp( LoaderBlock->ArcBootDeviceName, "ramdisk(0)", 10 ) == 0 ) {

        status = IopStartRamdisk(LoaderBlock);

        // IopStartRamdisk will bugcheck on any failure.
        ASSERT( NT_SUCCESS(status) );

        if (!PipWaitForBootDevicesStarted()) {
            HeadlessKernelAddLogEntry(HEADLESS_LOG_WAIT_BOOT_DEVICES_START_FAILED, NULL);
            return FALSE;
        }
    }

    //
    // Find and mark the boot partition device object so that if a subsequent
    // access or mount of the device during initialization occurs, an more
    // bugcheck can be produced that helps the user understand why the system
    // is failing to boot and run properly.  This occurs when either one of the
    // device drivers or the file system fails to load, or when the file system
    // cannot mount the device for some other reason.
    //

    if (!IopMarkBootPartition( LoaderBlock )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_MARK_BOOT_PARTITION_FAILED, NULL);
        return FALSE;
    }

    PnPBootDriversInitialized = TRUE;

    //
    // Go thru every driver that we initialized. If it supports AddDevice yet
    // did not create any device objects after we started it, we should unload
    // it (this is the counterpart to the code in pnpenum that unloads
    // unneccessary filters *after* the paging stack is online).
    //
    // We also mark it as failure so text mode setup knows this driver is not
    // actually needed.
    //

    for (i = 0; i < IopGroupIndex; i++) {
        while (IsListEmpty(&IopGroupTable[i]) == FALSE) {

            nextEntry = RemoveHeadList(&IopGroupTable[i]);
            driverInfo = CONTAINING_RECORD(nextEntry, DRIVER_INFORMATION, Link);
            driverObject = driverInfo->DriverObject;

            if (textModeSetup                    &&
                (driverInfo->Failed == FALSE)    &&
                !IopIsLegacyDriver(driverObject) &&
                (driverObject->DeviceObject == NULL) &&
                !(driverObject->Flags & DRVO_REINIT_REGISTERED)) {

                //
                // If failed is not set and it's not a legacy driver and it has no device object
                // tread it as failure case.
                //

                driverInfo->Failed = TRUE;

                if (!(driverObject->Flags & DRVO_UNLOAD_INVOKED)) {
                    driverObject->Flags |= DRVO_UNLOAD_INVOKED;
                    if (driverObject->DriverUnload) {
                        driverObject->DriverUnload(driverObject);
                    }
                    ObMakeTemporaryObject( driverObject );  // Reference taken while inserting into the object table.
                    ObDereferenceObject(driverObject);      // Reference taken when getting driver object pointer.
                }
            }
            if (driverObject) {
                ObDereferenceObject(driverObject);          // Reference taken specifically for text mode setup.
            }

            if (driverInfo->Failed) {
                driverInfo->DataTableEntry->LdrEntry->Flags |= LDRP_FAILED_BUILTIN_LOAD;
            }
            NtClose(driverInfo->ServiceHandle);
            ExFreePool(driverInfo);
        }
    }

    ExFreePool(IopGroupTable);

    //
    // Initialize the drivers necessary to dump all of physical memory to the
    // disk if the system is configured to do so.
    //


    return TRUE;
}

NTSTATUS
PipAddDevicesToBootDriver(
   IN PDRIVER_OBJECT DriverObject
   )

/*++

Routine Description:

    This functions is used by Pnp manager to inform a boot device driver of
    all the devices it can possibly control.  This routine is for boot
    drivers only.

Parameters:

    DriverObject - Supplies a driver object to receive its boot devices.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status;


    //
    // For each device instance in the driver's service/enum key, we will
    // invoke the driver's AddDevice routine and perform enumeration on
    // the device.
    // Note, we don't acquire registry lock before calling IopApplyFunction
    // routine.  We know this code is for boot driver initialization.  No
    // one else would access the registry Enum key at this time and most
    // important we need the registry lock in other down level routines.
    //

    status = PipApplyFunctionToServiceInstances(
                                NULL,
                                &DriverObject->DriverExtension->ServiceKeyName,
                                KEY_ALL_ACCESS,
                                TRUE,
                                PipAddDevicesToBootDriverWorker,
                                DriverObject,
                                NULL
                                );

    return status;
}

BOOLEAN
PipAddDevicesToBootDriverWorker(
    IN HANDLE DeviceInstanceHandle,
    IN PUNICODE_STRING DeviceInstancePath,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToServiceInstances.
    It is called for each device instance key referenced by a service instance
    value under the specified service's volatile Enum subkey. The purpose of this
    routine is to invoke the AddDevice() entry of a boot driver with the device
    object.

    Note this routine is also used for the devices controlled by a legacy driver.
    If the specified device instance is controlled by a legacy driver this routine
    sets the device node flags.

Arguments:

    DeviceInstanceHandle - Supplies a handle to the registry path (relative to
        HKLM\CCS\System\Enum) to this device instance.

    DeviceInstancePath - Supplies the registry path (relative to HKLM\CCS\System\Enum)
        to this device instance.

    Context - Supplies a pointer to a DRIVER_OBJECT structure.

Return Value:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/

{
//  PDRIVER_OBJECT driverObject = (PDRIVER_OBJECT)Context;
    PDEVICE_OBJECT physicalDevice;
    PDEVICE_NODE deviceNode;

    ADD_CONTEXT addContext;

    UNREFERENCED_PARAMETER( Context );

    //
    // Reference the physical device object associated with the device instance.
    //

    physicalDevice = IopDeviceObjectFromDeviceInstance(DeviceInstancePath);
    if (!physicalDevice) {
        return TRUE;
    }

    PipRequestDeviceAction( physicalDevice, AddBootDevices, FALSE, 0, NULL, NULL );

    ObDereferenceObject(physicalDevice);
    return TRUE;
}

BOOLEAN
IopInitializeSystemDrivers(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to load and initialize all of the drivers that
    are supposed to be loaded during Phase 1 initialization of the I/O
    system.  This is accomplished by calling the Configuration Manager to
    get a NULL-terminated array of handles to the open keys for each driver
    that is to be loaded, and then loading and initializing the driver.

Arguments:

    None.

Return Value:

    The function value is a BOOLEAN indicating whether or not the drivers
    were successfully loaded and initialized.

--*/

{
    BOOLEAN  newDevice, moreProcessing;
    NTSTATUS status, driverEntryStatus;
    PHANDLE driverList;
    PHANDLE savedList;
    HANDLE enumHandle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING groupName, enumName;
    PTREE_ENTRY treeEntry;
    UNICODE_STRING driverName;
    PDRIVER_OBJECT driverObject;
    START_CONTEXT startContext;
    KEVENT completionEvent;

//    PpReleaseBootDDB();

    KeInitializeEvent( &completionEvent, NotificationEvent, FALSE );

    status = PipRequestDeviceAction( IopRootDeviceNode->PhysicalDeviceObject,
                                     StartSystemDevices,
                                     FALSE,
                                     0,
                                     &completionEvent,
                                     NULL);

    if (NT_SUCCESS(status)) {

        status = KeWaitForSingleObject( &completionEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
    }

    //
    // Walk thru the service list to load the remaining system start drivers.
    // (Most likely these drivers are software drivers.)
    //

    //
    // Get the list of drivers that are to be loaded during this phase of
    // system initialization, and invoke each driver in turn.  Ensure that
    // the list really exists, otherwise get out now.
    //

    driverList = CmGetSystemDriverList();

    if (driverList != NULL) {

        //
        // Walk the entire list, loading each of the drivers if not already loaded,
        // until there are no more drivers in the list.
        //

        for (savedList = driverList; *driverList; driverList++) {

            //
            // Now check if the driver has been loaded already.
            // get the name of the driver object first ...
            //

            status = IopGetDriverNameFromKeyNode( *driverList,
                                                  &driverName );
            if (NT_SUCCESS( status )) {

                driverObject = IopReferenceDriverObjectByName(&driverName);
                RtlFreeUnicodeString(&driverName);
                if (driverObject) {

                    //
                    // Driver was loaded already.  Dereference the driver object
                    // and skip it.
                    //

                    ObDereferenceObject(driverObject);
                    ZwClose(*driverList);
                    continue;
                }
            }

            //
            // Open registry ServiceKeyName\Enum branch to check if the driver was
            // loaded before but failed.
            //

            PiWstrToUnicodeString(&enumName, REGSTR_KEY_ENUM);
            status = IopOpenRegistryKeyEx( &enumHandle,
                                           *driverList,
                                           &enumName,
                                           KEY_READ
                                           );

            if (NT_SUCCESS( status )) {

                ULONG startFailed = 0;

                status = IopGetRegistryValue(enumHandle, L"INITSTARTFAILED", &keyValueInformation);

                if (NT_SUCCESS( status )) {
                    if (keyValueInformation->DataLength) {
                        startFailed = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                    }
                    ExFreePool( keyValueInformation );
                }
                ZwClose(enumHandle);
                if (startFailed != 0) {
                    ZwClose(*driverList);
                    continue;
                }
            }

            //
            // The driver is not loaded yet.  Load it ...
            //

            status = IopGetRegistryValue( *driverList,
                                          REGSTR_VALUE_GROUP,
                                          &keyValueInformation );
            if (NT_SUCCESS( status )) {
                if (keyValueInformation->DataLength) {
                    groupName.Length = (USHORT) keyValueInformation->DataLength;
                    groupName.MaximumLength = groupName.Length;
                    groupName.Buffer = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
                    treeEntry = PipLookupGroupName( &groupName, TRUE );
                } else {
                    treeEntry = (PTREE_ENTRY) NULL;
                }
                ExFreePool( keyValueInformation );
            } else {
                treeEntry = (PTREE_ENTRY) NULL;
            }

            if (PipCheckDependencies( *driverList )) {
                if (NT_SUCCESS( IopLoadDriver( *driverList, TRUE, FALSE, &driverEntryStatus ) )) {
                    if (treeEntry) {
                        treeEntry->DriversLoaded++;
                    }
                }
            } else {
                ZwClose(*driverList);
            }

            //
            // The boot process takes a while loading drivers.   Indicate that
            // progress is being made.
            //

            InbvIndicateProgress();

        }

        //
        // Finally, free the pool that was allocated for the list and return
        // an indicator the load operation worked.
        //

        ExFreePool( (PVOID) savedList );
    }

    PipRequestDeviceAction( IopRootDeviceNode->PhysicalDeviceObject,
                            StartSystemDevices,
                            FALSE,
                            0,
                            NULL,
                            NULL);

    //
    // Mark pnp has completed the driver loading for both system and
    // autoload drivers.
    //
    PnPInitialized = TRUE;

    //
    // We don't need the group order list anymore. Release the cached data
    // associated with it.
    //
    PiInitReleaseCachedGroupInformation();

    //
    // Release the Boot Driver Database information.
    //
    PpReleaseBootDDB();

    //
    // Free the memory allocated to contain the group dependency list.
    //
    if (IopGroupListHead) {
        PipFreeGroupTree( IopGroupListHead );
    }

    return TRUE;
}

PTREE_ENTRY
PipLookupGroupName(
    IN PUNICODE_STRING GroupName,
    IN BOOLEAN Insert
    )

/*++

Routine Description:

    This routine looks up a group entry in the group load tree and either
    returns a pointer to it, or optionally creates the entry and inserts
    it into the tree.

Arguments:

    GroupName - The name of the group to look up, or insert.

    Insert - Indicates whether or not an entry is to be created and inserted
        into the tree if the name does not already exist.

Return Value:

    The function value is a pointer to the entry for the specified group
    name, or NULL.

--*/

{
    PTREE_ENTRY treeEntry;
    PTREE_ENTRY previousEntry;

    //
    // Begin by determining whether or not there are any entries in the tree
    // whatsoever.  If not, and it is OK to insert, then insert this entry
    // into the tree.
    //

    if (!IopGroupListHead) {
        if (!Insert) {
            return (PTREE_ENTRY) NULL;
        } else {
            IopGroupListHead = PipCreateEntry( GroupName );
            return IopGroupListHead;
        }
    }

    //
    // The tree is not empty, so actually attempt to do a lookup.
    //

    treeEntry = IopGroupListHead;

    for (;;) {
        if (GroupName->Length < treeEntry->GroupName.Length) {
            if (treeEntry->Left) {
                treeEntry = treeEntry->Left;
            } else {
                if (!Insert) {
                    return (PTREE_ENTRY) NULL;
                } else {
                    treeEntry->Left = PipCreateEntry( GroupName );
                    return treeEntry->Left;
                }

            }
        } else if (GroupName->Length > treeEntry->GroupName.Length) {
            if (treeEntry->Right) {
                treeEntry = treeEntry->Right;
            } else {
                if (!Insert) {
                    return (PTREE_ENTRY) NULL;
                } else {
                    treeEntry->Right = PipCreateEntry( GroupName );
                    return treeEntry->Right;
                }
            }
        } else {
            if (!RtlEqualUnicodeString( GroupName, &treeEntry->GroupName, TRUE )) {
                previousEntry = treeEntry;
                while (treeEntry->Sibling) {
                    treeEntry = treeEntry->Sibling;
                    if (RtlEqualUnicodeString( GroupName, &treeEntry->GroupName, TRUE )) {
                        return treeEntry;
                    }
                    previousEntry = previousEntry->Sibling;
                }
                if (!Insert) {
                    return (PTREE_ENTRY) NULL;
                } else {
                    previousEntry->Sibling = PipCreateEntry( GroupName );
                    return previousEntry->Sibling;
                }
            } else {
                return treeEntry;
            }
        }
    }
}

USHORT
PipGetDriverTagPriority (
    IN HANDLE ServiceHandle
    )

/*++

Routine Description:

    This routine reads the Tag value of a driver and determine the tag's priority
    among its driver group.

Arguments:

    ServiceHandle - specifies the handle of the driver's service key.

Return Value:

    USHORT for priority.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation1;
    UNICODE_STRING groupName;
    HANDLE handle;
    USHORT index = (USHORT) -1;
    PULONG groupOrder;
    ULONG count, tag;

    //
    // Open System\CurrentControlSet\Control\GroupOrderList
    //

    PiWstrToUnicodeString(&groupName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\GroupOrderList");
    status = IopOpenRegistryKeyEx( &handle,
                                   NULL,
                                   &groupName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS( status )) {
        return index;
    }

    //
    // Read service key's Group value
    //

    status = IopGetRegistryValue (ServiceHandle,
                                  REGSTR_VALUE_GROUP,
                                  &keyValueInformation);
    if (NT_SUCCESS(status)) {

        //
        // Try to read what caller wants.
        //

        if ((keyValueInformation->Type == REG_SZ) &&
            (keyValueInformation->DataLength != 0)) {
            IopRegistryDataToUnicodeString(&groupName,
                                           (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                           keyValueInformation->DataLength
                                           );
        }
    } else {

        //
        // If we failed to read the Group value, or no Group value...
        //

        NtClose(handle);
        return index;
    }

    //
    // Read service key's Tag value
    //

    status = IopGetRegistryValue (ServiceHandle,
                                  L"Tag",
                                  &keyValueInformation1);
    if (NT_SUCCESS(status)) {

        //
        // Try to read what caller wants.
        //

        if ((keyValueInformation1->Type == REG_DWORD) &&
            (keyValueInformation1->DataLength != 0)) {
            tag = *(PULONG)KEY_VALUE_DATA(keyValueInformation1);
        } else {
            status = STATUS_UNSUCCESSFUL;
        }

        ExFreePool(keyValueInformation1);
    }

    if (!NT_SUCCESS(status))  {

        //
        // If we failed to read the Group value, or no Group value...
        //

        ExFreePool(keyValueInformation);
        NtClose(handle);
        return index;
    }

    //
    // Read group order list value for the driver's Group
    //

    status = IopGetRegistryValue (handle,
                                  groupName.Buffer,
                                  &keyValueInformation1);
    ExFreePool(keyValueInformation);
    NtClose(handle);
    if (NT_SUCCESS(status)) {

        //
        // Try to read what caller wants.
        //

        if ((keyValueInformation1->Type == REG_BINARY) &&
            (keyValueInformation1->DataLength != 0)) {
            groupOrder = (PULONG)KEY_VALUE_DATA(keyValueInformation1);
            count = *groupOrder;
            ASSERT((count + 1) * sizeof(ULONG) <= keyValueInformation1->DataLength);
            groupOrder++;
            for (index = 1; index <= count; index++) {
                if (tag == *groupOrder) {
                    break;
                } else {
                    groupOrder++;
                }
            }
        }
        ExFreePool(keyValueInformation1);
    } else {

        //
        // If we failed to read the Group value, or no Group value...
        //

        return index;
    }
    return index;
}

VOID
PipInsertDriverList (
    IN PLIST_ENTRY ListHead,
    IN PDRIVER_INFORMATION DriverInfo
    )

/*++

Routine Description:

    This routine reads the Tag value of a driver and determine the tag's priority
    among its driver group.

Arguments:

    ServiceHandle - specifies the handle of the driver's service key.

Return Value:

    USHORT for priority.

--*/

{
    PLIST_ENTRY nextEntry;
    PDRIVER_INFORMATION info;

    nextEntry = ListHead->Flink;
    while (nextEntry != ListHead) {
        info = CONTAINING_RECORD(nextEntry, DRIVER_INFORMATION, Link);

        //
        // Scan the driver info list to find the driver whose priority is
        // lower than current driver's.
        // (Lower TagPosition value means higher Priority)
        //

        if (info->TagPosition > DriverInfo->TagPosition) {
            break;
        }
        nextEntry = nextEntry->Flink;
    }

    //
    // Insert the Driver info to the front of the nextEntry
    //

    nextEntry = nextEntry->Blink;
    InsertHeadList(nextEntry, &DriverInfo->Link);
}

VOID
PipNotifySetupDevices (
    PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine notifies setupdd.sys for all the enumerated devices whose
    service have not been setup.

    This routine only gets executed on textmode setup phase.

Parameters:

    DeviceNode - specifies the root of the subtree to be processed.

Return Value:

    None.

--*/

{
    PDEVICE_NODE deviceNode = DeviceNode->Child;
    PDEVICE_OBJECT deviceObject;
    HANDLE handle;
    UNICODE_STRING unicodeString;
    NTSTATUS status;

    while (deviceNode) {
        PipNotifySetupDevices(deviceNode);
        if (deviceNode->ServiceName.Length == 0) {

            //
            // We only notify setupdd the device nodes which do not have service setup yet.
            // It is impossible that at this point, a device has a service setup and
            // setupdd has to change it.
            //

            deviceObject = deviceNode->PhysicalDeviceObject;
            status = IopDeviceObjectToDeviceInstance(deviceObject, &handle, KEY_ALL_ACCESS);
            if (NT_SUCCESS(status)) {

                //
                // Notify setup about the device.
                //

                IopNotifySetupDeviceArrival(deviceObject, handle, TRUE);

                //
                // Finally register the device
                //

                status = PpDeviceRegistration(
                             &deviceNode->InstancePath,
                             TRUE,
                             &unicodeString       // registered ServiceName
                             );

                if (NT_SUCCESS(status)) {
                    deviceNode->ServiceName = unicodeString;
                    if (PipIsDevNodeProblem(deviceNode, CM_PROB_NOT_CONFIGURED)) {
                        PipClearDevNodeProblem(deviceNode);
                    }
                }
                ZwClose(handle);
            }
        }
        deviceNode = deviceNode->Sibling;
    }
}

BOOLEAN
PipWaitForBootDevicesStarted (
    IN VOID
    )

/*++

Routine Description:

    This routine waits for enumeration lock to be released for ALL devices.

Arguments:

    None.

Return Value:

    BOOLEAN.

--*/

{
    PDEVICE_NODE deviceNode;
    NTSTATUS status;
    KIRQL oldIrql;

    //
    // Wait on IoInvalidateDeviceRelations event to make sure all the devcies are enumerated
    // before progressing to mark boot partitions.
    //

    status = KeWaitForSingleObject( &PiEnumerationLock,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    if (PnpAsyncOk) {

#if 0 // BUGBUG
        //
        // Perform top-down check to make sure all the devices with Async start and Async Query
        // Device Relations are done.
        //

        deviceNode = IopRootDeviceNode;
        for (; ;) {

            ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

            if (PipIsRequestPending(deviceNode)) {

                KeClearEvent(&PiEnumerationLock);
                ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

                //
                // Wait on PiEnumerationLock to be signaled before proceeding.
                // At this point if a device node is marked ASYNC request pending,  this
                // must be an ASYNC start or enumeration which will queue an enumeration
                // request and once the enumeration completes, the PiEnumerationLock
                // will be signaled.
                //

                status = KeWaitForSingleObject( &PiEnumerationLock,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL );
                if (!NT_SUCCESS(status)) {
                    return FALSE;
                }
                continue;   // Make sure this device is done.
            } else {
                ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
            }

            if (deviceNode->Child) {
                deviceNode = deviceNode->Child;
                continue;
            }
            if (deviceNode->Sibling) {
                deviceNode = deviceNode->Sibling;
                continue;
            }

            for (; ;) {
                deviceNode = deviceNode->Parent;

                //
                // If that was the last node to check, then exit loop
                //

                if (deviceNode == IopRootDeviceNode) {
                    goto exit;
                }
                if (deviceNode->Sibling) {
                    deviceNode = deviceNode->Sibling;
                    break;
                }
            }
        }
    exit:
        ;
#endif
    }
    return TRUE;
}

BOOLEAN
PipWaitForBootDevicesDeleted (
    IN VOID
    )

/*++

Routine Description:

    This routine waits for IoRequestDeviceRemoval to be completed.

Arguments:

    None.

Return Value:

    BOOLEAN.

--*/

{
    NTSTATUS status;

    //
    // Wait on device removal event to make sure all the deleted devcies are processed
    // before moving on to process next boot driver.
    //

    status = KeWaitForSingleObject( &PiEventQueueEmpty,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL );
    return (BOOLEAN)NT_SUCCESS(status);
}

NTSTATUS
PipLoadBootFilterDriver (
    IN PUNICODE_STRING DriverName,
    IN ULONG GroupIndex,
    OUT PDRIVER_OBJECT *LoadedFilter
    )

/*++

Routine Description:

    This initializes boot filter drivers.

Arguments:

    DriverName - specifies the name of the driver to be initialized.

    GroupIndex - specifies the Driver's group index (could be anything)

Return Value:

    PDRIVER_OBJECT

--*/

{
    PDRIVER_OBJECT driverObject;
    PLIST_ENTRY nextEntry;
    PDRIVER_INFORMATION driverInfo;
    UNICODE_STRING completeName;
    PBOOT_DRIVER_LIST_ENTRY bootDriver;
    PKLDR_DATA_TABLE_ENTRY driverEntry;
    HANDLE keyHandle;
    NTSTATUS status, retStatus;

    retStatus = STATUS_UNSUCCESSFUL;
    *LoadedFilter = NULL;
    if (IopGroupTable == NULL || GroupIndex >= IopGroupIndex) {

        //
        // If we have not reached the boot driver initialization phase or
        // the filter driver is not a boot driver.
        //

        return retStatus;
    }

    //
    // Go thru every driver that we initialized.  If it supports AddDevice entry and
    // did not create any device object after we start it.  We mark it as failure so
    // text mode setup knows this driver is not needed.
    //

    nextEntry = IopGroupTable[GroupIndex].Flink;
    while (nextEntry != &IopGroupTable[GroupIndex]) {

        driverInfo = CONTAINING_RECORD(nextEntry, DRIVER_INFORMATION, Link);
        keyHandle = driverInfo->ServiceHandle;
        status = IopGetDriverNameFromKeyNode(
            keyHandle,
            &completeName);
        if (NT_SUCCESS(status)) {

            if (RtlEqualUnicodeString(DriverName,
                                      &completeName,
                                      TRUE)) {    // case-insensitive
                if (driverInfo->Processed == FALSE) {

                    bootDriver = driverInfo->DataTableEntry;
                    driverEntry = bootDriver->LdrEntry;

                    driverInfo->Status = IopInitializeBuiltinDriver(
                                       &completeName,
                                       &bootDriver->RegistryPath,
                                       (PDRIVER_INITIALIZE) driverEntry->EntryPoint,
                                       driverEntry,
                                       TRUE,
                                       &driverObject);
                    retStatus = driverInfo->Status;
                    driverInfo->DriverObject = driverObject;
                    driverInfo->Processed = TRUE;
                    //
                    // Pnp might unload the driver before we get a chance to
                    // look at this. So take an extra reference.
                    //
                    if (driverObject) {

                        ObReferenceObject(driverObject);
                        *LoadedFilter = driverObject;
                    } else {

                        driverInfo->Failed = TRUE;
                    }
                } else {

                    retStatus = driverInfo->Status;
                }

                ExFreePool(completeName.Buffer);
                break;
            }
            ExFreePool(completeName.Buffer);
        }
        nextEntry = nextEntry->Flink;
    }

    return retStatus;
}

VOID
IopMarkHalDeviceNode(
    )
{
    PDEVICE_NODE deviceNode;

    deviceNode = IopRootDeviceNode->Child;

    while (deviceNode) {

        if ((deviceNode->State == DeviceNodeStarted ||
             deviceNode->State == DeviceNodeStartPostWork ) &&
            !(deviceNode->Flags & DNF_LEGACY_DRIVER)) {

            IopInitHalDeviceNode = deviceNode;
            deviceNode->Flags |= DNF_HAL_NODE;
            break;
        }

        deviceNode = deviceNode->Sibling;
    }
}

NTSTATUS
IopPnpDriverStarted(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ServiceName
    )
{
    NTSTATUS    status = STATUS_SUCCESS;

    if (DriverObject->DeviceObject == NULL && ServiceName->Buffer &&
        !IopIsAnyDeviceInstanceEnabled(ServiceName, NULL, FALSE) &&
        !(DriverObject->Flags & DRVO_REINIT_REGISTERED)) {

        IopDriverLoadingFailed(KeyHandle, NULL);
        status = STATUS_PLUGPLAY_NO_DEVICE;

    } else {

        //
        // Start the devices controlled by the driver and enumerate them
        // At this point, we know there is at least one device controlled by the driver.
        //

        IopDeleteLegacyKey(DriverObject);

#if 0
        if (PnPInitialized) {
            status = PipStartDriverDevices(DriverObject);
        }
#endif
    }

    return status;
}

NTSTATUS
PiInitCacheGroupInformation(
    VOID
    )
/*++

Routine Description:

    This routine caches the service group order list. We only need this list
    while we are processing boot start and system start legacy drivers.

Parameters:

    None.

Return Value:

    NTSTATUS.

--*/
{
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING *groupTable, group;
    NTSTATUS status;
    HANDLE handle;
    ULONG count;

    //
    // Open System\CurrentControlSet\Control\ServiceOrderList
    //
    PiWstrToUnicodeString(
        &group,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ServiceGroupOrder"
        );

    status = IopOpenRegistryKeyEx(
        &handle,
        NULL,
        &group,
        KEY_READ
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Read and build a unicode string array containing all the group names.
    //
    status = IopGetRegistryValue(
        handle,
        L"List",
        &keyValueInformation
        );

    ZwClose(handle);

    if (NT_SUCCESS(status)) {

        if ((keyValueInformation->Type == REG_MULTI_SZ) &&
            (keyValueInformation->DataLength != 0)) {

            status = PipRegMultiSzToUnicodeStrings(keyValueInformation, &groupTable, &count);
        } else {
            status = STATUS_UNSUCCESSFUL;
        }
        ExFreePool(keyValueInformation);
    }

    if (!NT_SUCCESS(status)) {

        return status;
    }

    PiInitGroupOrderTable = groupTable;
    PiInitGroupOrderTableCount = (USHORT) count;
    return STATUS_SUCCESS;
}

VOID
PiInitReleaseCachedGroupInformation(
    VOID
    )
/*++

Routine Description:

    This routine releases the service group order list cache. It should be
    called just after the system start legacy drivers have been loaded.

Parameters:

    None.

Return Value:

    None.

--*/
{
    ASSERT(PnPInitialized);

    if (PiInitGroupOrderTable) {

        PipFreeUnicodeStringList(
            PiInitGroupOrderTable,
            PiInitGroupOrderTableCount
            );

        PiInitGroupOrderTable = NULL;
        PiInitGroupOrderTableCount = 0;
    }
}

USHORT
PpInitGetGroupOrderIndex(
    IN HANDLE ServiceHandle
    )
/*++

Routine Description:

    This routine reads the Group value of the service key, finds its position
    in the ServiceOrderList. If ServiceHandle is NULL or unrecognized group
    value, it returns a value with max group order + 1.

Parameters:

    ServiceHandle - supplies a handle to the service key.

Return Value:

    group order index.

--*/
{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING group;
    USHORT index;

    PAGED_CODE();

    ASSERT(!PnPInitialized);

    if (PiInitGroupOrderTable == NULL) {

        return NO_MORE_GROUP;
    }

    if (ServiceHandle == NULL) {

        return PiInitGroupOrderTableCount + 1;
    }

    //
    // Read service key's Group value
    //
    status = IopGetRegistryValue(
        ServiceHandle,
        REGSTR_VALUE_GROUP,
        &keyValueInformation
        );

    if (!NT_SUCCESS(status)) {

        //
        // If we failed to read the Group value, or no Group value...
        //
        return PiInitGroupOrderTableCount;
    }

    //
    // Verify type information
    //
    if ((keyValueInformation->Type != REG_SZ) ||
        (keyValueInformation->DataLength == 0)) {

        ASSERT(0);
        ExFreePool(keyValueInformation);
        return PiInitGroupOrderTableCount;
    }

    IopRegistryDataToUnicodeString(
        &group,
        (PWSTR)KEY_VALUE_DATA(keyValueInformation),
        keyValueInformation->DataLength
        );

    for (index = 0; index < PiInitGroupOrderTableCount; index++) {

        if (RtlEqualUnicodeString(&group, &PiInitGroupOrderTable[index], TRUE)) {

            break;
        }
    }

    ExFreePool(keyValueInformation);

    return index;
}

BOOLEAN
PpInitSystem (
    VOID
    )

/*++

Routine Description:

    This function performs initialization of the kernel-mode Plug and Play
    Manager.  It is called during phase 0 and phase 1 initialization.  Its
    function is to dispatch to the appropriate phase initialization routine.

Arguments:

    None.

Return Value:

    TRUE  - Initialization succeeded.

    FALSE - Initialization failed.

--*/

{

    switch ( InitializationPhase ) {

    case 0 :
        return PiInitPhase0();

    case 1 :
#if defined(_X86_)
        PnPBiosInitializePnPBios() ;
#endif
        return TRUE;
    default:
        KeBugCheckEx(UNEXPECTED_INITIALIZATION_CALL, 2, InitializationPhase, 0, 0);
    }
}

BOOLEAN
PiInitPhase0(
    VOID
    )

/*++

Routine Description:

    This function performs Phase 0 initializaion of the Plug and Play Manager
    component of the NT system. It initializes the PnP registry and bus list
    resources, and initializes the bus list head to empty.

Arguments:

    None.

Return Value:

    TRUE  - Initialization succeeded.

    FALSE - Initialization failed.

--*/

{
    //
    // Initialize the device-specific, Plug and Play registry resource.
    //
    ExInitializeResourceLite( &PpRegistryDeviceResource );

    PpInitializeDeviceReferenceTable();

    return TRUE;
}

NTSTATUS
IopStartRamdisk(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    ULONG code;
    NTSTATUS status;
    WCHAR buffer[ RAMDISK_MAX_DEVICE_NAME ];
    UNICODE_STRING guidString;
    PLIST_ENTRY listEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR memoryDescriptor = NULL;
    UNICODE_STRING ustring;
    UNICODE_STRING ustring2;
    UNICODE_STRING string;
    RAMDISK_CREATE_INPUT create;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    HANDLE handle = NULL;
    PCHAR options;

    RtlInitUnicodeString( &string, RAMDISK_DEVICENAME );

    //
    // Find the descriptor for the memory block into which the loader read the
    // disk image.
    //

    for ( listEntry = LoaderBlock->MemoryDescriptorListHead.Flink;
          listEntry != &LoaderBlock->MemoryDescriptorListHead;
          listEntry = listEntry->Flink ) {

        memoryDescriptor = CONTAINING_RECORD(listEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        if (memoryDescriptor->MemoryType == LoaderXIPRom) {
            break;
        }
    }

    if ( listEntry == &LoaderBlock->MemoryDescriptorListHead ) {

        KdPrint(( "IopStartRamdisk: Couldn't find LoaderXIPRom descriptor\n" ));

        code = 1;
        status = STATUS_INVALID_PARAMETER;
        goto failed;
    }

    //
    // Build the IOCTL parameter block.
    //

    RtlZeroMemory( &create, sizeof(create) );

    create.Version = sizeof(RAMDISK_CREATE_INPUT);
    create.DiskType = RAMDISK_TYPE_BOOT_DISK;
    create.BasePage = memoryDescriptor->BasePage;
    create.DriveLetter = L'C';           // ISSUE: Does this need to be configurable?
    create.Options.Fixed = (BOOLEAN)TRUE;
    create.Options.Readonly = (BOOLEAN)FALSE;
    create.Options.NoDriveLetter = (BOOLEAN)FALSE;
    create.Options.Hidden = (BOOLEAN)FALSE;
    create.Options.NoDosDevice = (BOOLEAN)FALSE;

    //
    // Use the well-known boot disk GUID.
    //

    create.DiskGuid = RamdiskBootDiskGuid;

    //
    // Look for RDIMAGEOFFSET and RDIMAGELENGTH load options.
    //

    create.DiskOffset = 0;
    create.DiskLength = memoryDescriptor->PageCount * PAGE_SIZE;
    
    options = LoaderBlock->LoadOptions;
    if ( options != NULL ) {

        PCHAR option;

        _strupr( options );

        option = strstr( options, "RDIMAGEOFFSET" );
        if ( option != NULL ) {

            option = strstr( option, "=" );
            if ( option != NULL ) {

                create.DiskOffset = atol( option + 1 );
            }
        }

        create.DiskLength -= create.DiskOffset;

        option = strstr( options, "RDIMAGELENGTH" );
        if ( option != NULL ) {

            option = strstr( option, "=" );
            if ( option != NULL ) {

                ULONGLONG length = _atoi64( option + 1 );
                ASSERT( length <= create.DiskLength );

                create.DiskLength = length;
            }
        }
    }

    //
    // Send an IOCTL to ramdisk.sys telling it to create the RAM disk.
    //

    InitializeObjectAttributes( &obja, &string, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &handle,
                GENERIC_READ | GENERIC_WRITE,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if ( NT_SUCCESS(status) ) {
        status = iosb.Status;
    }
    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "IopStartRamdisk: Error opening %wZ. Error: %x\n", &string, status ));

        code = 2;
        goto failed;
    }

    status = NtDeviceIoControlFile(
                handle,
                NULL,
                NULL,
                NULL,
                &iosb,
                FSCTL_CREATE_RAM_DISK,
                &create,
                sizeof(create),
                NULL,
                0
                );

    NtClose( handle );

    if ( NT_SUCCESS(status) ) {
        status = iosb.Status;
    }
    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "IopStartRamdisk: Error creating RAM disk: %x\n", status ));

        code = 3;
        goto failed;
    }

    //
    // Create an ARC name pointing ramdisk(0) to the RAM disk.
    //

    status = RtlStringFromGUID( &create.DiskGuid, &guidString);

    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "IopStartRamdisk: Error creating disk GUID string: %x\n", status ));

        code = 4;
        goto failed;
    }

    _snwprintf( buffer, RAMDISK_MAX_DEVICE_NAME, L"\\Device\\Ramdisk%wZ", &guidString);

    RtlInitUnicodeString( &ustring, L"\\ArcName\\ramdisk(0)" );
    RtlInitUnicodeString( &ustring2, buffer );

    status = IoCreateSymbolicLink( &ustring, &ustring2 );

    RtlFreeUnicodeString( &guidString );

    if (!NT_SUCCESS(status)) {

        KdPrint(( "IopStartRamdisk: Failed to create arcname symbolic link (%wZ --> %wZ). %x\n",
                    &ustring, &ustring2, status ));

        code = 5;
        goto failed;
    }

    return STATUS_SUCCESS;

failed:

    KeBugCheckEx( INACCESSIBLE_BOOT_DEVICE,
                  (ULONG_PTR)&string,
                  status,
                  code,
                  0
                  );

} // IopStartRamdisk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpioapi.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpioapi.c

Abstract:

    This module contains the plug-and-play IO system APIs.

Author:

    Shie-Lin Tzong (shielint) 3-Jan-1995
    Andrew Thornton (andrewth) 5-Sept-1996
    Paula Tomlinson (paulat) 1-May-1997

Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop
#include <stddef.h>
#include <wdmguid.h>

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'oipP')
#endif


//
// Define device state work item.
//

typedef struct _DEVICE_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PDEVICE_OBJECT DeviceObject;
    PVOID Context;
} DEVICE_WORK_ITEM, *PDEVICE_WORK_ITEM;

NTSTATUS
IopQueueDeviceWorkItem(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN VOID (*WorkerRoutine)(PVOID),
    IN PVOID Context
    );

VOID
IopRequestDeviceEjectWorker(
    PVOID Context
    );

BOOLEAN
IopIsReportedAlready(
    IN HANDLE Handle,
    IN PUNICODE_STRING ServiceName,
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PBOOLEAN MatchingKey
    );

//
// Definitions for IoOpenDeviceRegistryKey
//

#define PATH_CURRENTCONTROLSET_HW_PROFILE_CURRENT TEXT("\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet")
#define PATH_CURRENTCONTROLSET                    TEXT("\\Registry\\Machine\\System\\CurrentControlSet")
#define PATH_ENUM                                 TEXT("Enum\\")
#define PATH_CONTROL_CLASS                        TEXT("Control\\Class\\")
#define PATH_CCS_CONTROL_CLASS                    PATH_CURRENTCONTROLSET TEXT("\\") REGSTR_KEY_CONTROL TEXT("\\") REGSTR_KEY_CLASS
#define MAX_RESTPATH_BUF_LEN            512

//
// Definitions for PpCreateLegacyDeviceIds
//

#define LEGACY_COMPATIBLE_ID_BASE           TEXT("DETECTED")

NTSTATUS
PpCreateLegacyDeviceIds(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DriverName,
    IN PCM_RESOURCE_LIST Resources
    );

//
// An IO_GET_LEGACY_VETO_LIST_CONTEXT structure.
//

typedef struct {
    PWSTR *                     VetoList;
    ULONG                       VetoListLength;
    PPNP_VETO_TYPE              VetoType;
    NTSTATUS *                  Status;
} IO_GET_LEGACY_VETO_LIST_CONTEXT, *PIO_GET_LEGACY_VETO_LIST_CONTEXT;

BOOLEAN
IopAppendLegacyVeto(
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context,
    IN PUNICODE_STRING VetoName
    );
BOOLEAN
IopGetLegacyVetoListDevice(
    IN PDEVICE_NODE DeviceNode,
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    );
BOOLEAN
IopGetLegacyVetoListDeviceNode(
    IN PDEVICE_NODE DeviceNode,
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    );
VOID
IopGetLegacyVetoListDrivers(
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoForwardAndCatchIrp)
#pragma alloc_text(PAGE, IoGetDeviceProperty)
#pragma alloc_text(PAGE, IoGetDmaAdapter)
#pragma alloc_text(PAGE, IoGetLegacyVetoList)
#pragma alloc_text(PAGE, IoIsWdmVersionAvailable)
#pragma alloc_text(PAGE, IoOpenDeviceRegistryKey)
#pragma alloc_text(PAGE, IoReportDetectedDevice)
#pragma alloc_text(PAGE, IoSynchronousInvalidateDeviceRelations)
#pragma alloc_text(PAGE, PpCreateLegacyDeviceIds)
#pragma alloc_text(PAGE, IopAppendLegacyVeto)
#pragma alloc_text(PAGE, IopGetLegacyVetoListDevice)
#pragma alloc_text(PAGE, IopGetLegacyVetoListDeviceNode)
#pragma alloc_text(PAGE, IopGetLegacyVetoListDrivers)
#pragma alloc_text(PAGE, IopIsReportedAlready)
#pragma alloc_text(PAGE, IopOpenDeviceParametersSubkey)
#pragma alloc_text(PAGE, IopRequestDeviceEjectWorker)
#pragma alloc_text(PAGE, IopResourceRequirementsChanged)
#pragma alloc_text(PAGE, PiGetDeviceRegistryProperty)
#endif // ALLOC_PRAGMA

NTSTATUS
IoGetDeviceProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
    IN ULONG BufferLength,
    OUT PVOID PropertyBuffer,
    OUT PULONG ResultLength
    )

/*++

Routine Description:

    This routine lets drivers query the registry properties associated with the
    specified device.

Parameters:

    DeviceObject - Supplies the device object whoes registry property is to be
                   returned.  This device object should be the one created by
                   a bus driver.

    DeviceProperty - Specifies what device property to get.

    BufferLength - Specifies the length, in byte, of the PropertyBuffer.

    PropertyBuffer - Supplies a pointer to a buffer to receive property data.

    ResultLength - Supplies a pointer to a variable to receive the size of the
                   property data returned.

ReturnValue:

    Status code that indicates whether or not the function was successful.  If
    PropertyBuffer is not big enough to hold requested data, STATUS_BUFFER_TOO_SMALL
    will be returned and ResultLength will be set to the number of bytes actually
    required.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    DEVICE_CAPABILITIES capabilities;
    PWSTR valueName, keyName = NULL;
    ULONG valueType, length, instance, configFlags;
    DEVICE_INSTALL_STATE deviceInstallState;
    POBJECT_NAME_INFORMATION deviceObjectName;
    PWSTR deviceInstanceName;
    PWCHAR enumeratorNameEnd, ids;
    UNICODE_STRING unicodeString, guidString;
    HANDLE classHandle, classGuidHandle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    WCHAR   classGuid[GUID_STRING_LEN];
    GUID busTypeGuid;

    PAGED_CODE();

    //
    // Initialize out parameters
    //
    *ResultLength = 0;

    if (!IS_PDO(DeviceObject)) {

        if ((DeviceProperty != DevicePropertyInstallState) &&
            ((DeviceProperty != DevicePropertyEnumeratorName) ||
             (NULL == DeviceObject->DeviceObjectExtension->DeviceNode))) {

            //
            // We'll use the verifier to fail anyone who passes in something
            // that is not a PDO *except* for the DevicePropertyInstallState.
            // This is because our check for if something is a PDO really means
            // is this a PDO that PNP knows about.  For the most part these are
            // the same, but the DevicePropertyInstallState will get called by
            // classpnp, for device objects that *it* thinks it reported as
            // PDOs, but PartMgr actually swallowed.  This is a gross exception
            // to make, so PartMgr really should be fixed.
            //
            // The arbiters attempt to retrieve the Enumerator Name property
            // in determining whether "driver shared" resource allocations may
            // be accommodated.  The PDO used may be of the "legacy resource
            // devnode" placeholder variety.  The IS_PDO() macro explicitly
            // disallows these devnodes, so we must special-case this as well,
            // in order to avoid a verifier failure.  Note that our behavior
            // here is correct--we want the get-property call to fail for these
            // legacy resource devnodes.
            //
            PpvUtilFailDriver(
                PPVERROR_DDI_REQUIRES_PDO,
                (PVOID) _ReturnAddress(),
                DeviceObject,
                NULL
                );
        }

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;

    //
    // Map Device Property to registry value name and value type.
    //
    switch(DeviceProperty) {

    case DevicePropertyPhysicalDeviceObjectName:

        ASSERT (0 == (1 & BufferLength));  // had better be an even length
        //
        // Create a buffer for the Obj manager.
        //
        length = BufferLength + sizeof (OBJECT_NAME_INFORMATION);
        deviceObjectName = (POBJECT_NAME_INFORMATION)ExAllocatePool(
            PagedPool,
            length);
        if (NULL == deviceObjectName) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        status = ObQueryNameString (DeviceObject,
                                    deviceObjectName,
                                    length,
                                    ResultLength);
        if (STATUS_INFO_LENGTH_MISMATCH == status) {

            status = STATUS_BUFFER_TOO_SMALL;
        }
        if (NT_SUCCESS (status)) {

            if (deviceObjectName->Name.Length == 0)  {
                //
                // PDO has no NAME, probably it's been deleted
                //
                *ResultLength = 0;
            } else {

                *ResultLength = deviceObjectName->Name.Length + sizeof(UNICODE_NULL);
                if (*ResultLength > BufferLength) {
                    status = STATUS_BUFFER_TOO_SMALL;
                } else {

                    RtlCopyMemory(PropertyBuffer,
                                  deviceObjectName->Name.Buffer,
                                  deviceObjectName->Name.Length);
                    //
                    // NULL terminate.
                    //
                    *(PWCHAR)(((PUCHAR)PropertyBuffer) + deviceObjectName->Name.Length) = L'\0';
                }
            }
        } else {

            *ResultLength -= sizeof(OBJECT_NAME_INFORMATION);
        }

        ExFreePool (deviceObjectName);
        return status;

    case DevicePropertyBusTypeGuid:

        status = PpBusTypeGuidGet(deviceNode->ChildBusTypeIndex, &busTypeGuid);
        if (NT_SUCCESS(status)) {

            *ResultLength = sizeof(GUID);
            if(*ResultLength <= BufferLength) {

                RtlCopyMemory(PropertyBuffer,
                              &busTypeGuid,
                              sizeof(GUID));
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        }

        return status;

    case DevicePropertyLegacyBusType:

        if (deviceNode->ChildInterfaceType != InterfaceTypeUndefined) {

            *ResultLength = sizeof(INTERFACE_TYPE);
            if(*ResultLength <= BufferLength) {

                *(PINTERFACE_TYPE)PropertyBuffer = deviceNode->ChildInterfaceType;
                status = STATUS_SUCCESS;
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        return status;

    case DevicePropertyBusNumber:
        //
        // Retrieve the property from the parent's devnode field.
        //
        if ((deviceNode->ChildBusNumber & 0x80000000) != 0x80000000) {

            *ResultLength = sizeof(ULONG);
            if(*ResultLength <= BufferLength) {

                *(PULONG)PropertyBuffer = deviceNode->ChildBusNumber;
                status = STATUS_SUCCESS;
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        return status;

    case DevicePropertyEnumeratorName:

        ASSERT (0 == (1 & BufferLength));  // had better be an even length
        deviceInstanceName = deviceNode->InstancePath.Buffer;
        //
        // There should always be a string here, except for (possibly)
        // HTREE\Root\0, but no one should ever be calling us with that PDO
        // anyway.
        //
        ASSERT (deviceInstanceName);
        //
        // We know we're going to find a separator character (\) in the string,
        // so the fact that unicode strings may not be null-terminated isn't
        // a problem.
        //
        enumeratorNameEnd = wcschr(deviceInstanceName, OBJ_NAME_PATH_SEPARATOR);
        ASSERT (enumeratorNameEnd);
        //
        // Compute required length, minus null terminating character.
        //
        length = (ULONG)((PUCHAR)enumeratorNameEnd - (PUCHAR)deviceInstanceName);
        //
        // Store required length in caller-supplied OUT parameter.
        //
        *ResultLength = length + sizeof(UNICODE_NULL);
        if(*ResultLength > BufferLength) {

            status = STATUS_BUFFER_TOO_SMALL;
        } else {

            memcpy((PUCHAR)PropertyBuffer, (PUCHAR)deviceInstanceName, length);
            *(PWCHAR)((PUCHAR)PropertyBuffer + length) = UNICODE_NULL;
            status = STATUS_SUCCESS;
        }

        return status;

    case DevicePropertyAddress:

        status = PipQueryDeviceCapabilities(deviceNode, &capabilities);
        if (NT_SUCCESS(status) && (capabilities.Address != 0xFFFFFFFF)) {

            *ResultLength = sizeof(ULONG);
            if(*ResultLength <= BufferLength) {

                *(PULONG)PropertyBuffer = capabilities.Address;
                status = STATUS_SUCCESS;
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        return status;

    case DevicePropertyRemovalPolicy:

        *ResultLength = sizeof(ULONG);
        if(*ResultLength <= BufferLength) {

            PpHotSwapGetDevnodeRemovalPolicy(
                deviceNode,
                TRUE, // Include Registry Override
                (PDEVICE_REMOVAL_POLICY) PropertyBuffer
                );
            status = STATUS_SUCCESS;
        } else {

            status = STATUS_BUFFER_TOO_SMALL;
        }

        return status;

    case DevicePropertyUINumber:

        valueName = REGSTR_VALUE_UI_NUMBER;
        valueType = REG_DWORD;
        break;

    case DevicePropertyLocationInformation:

        valueName = REGSTR_VALUE_LOCATION_INFORMATION;
        valueType = REG_SZ;
        break;

    case DevicePropertyDeviceDescription:

        valueName = REGSTR_VALUE_DEVICE_DESC;
        valueType = REG_SZ;
        break;

    case DevicePropertyHardwareID:

        valueName = REGSTR_VALUE_HARDWAREID;
        valueType = REG_MULTI_SZ;
        break;

    case DevicePropertyCompatibleIDs:

        valueName = REGSTR_VALUE_COMPATIBLEIDS;
        valueType = REG_MULTI_SZ;
        break;

    case DevicePropertyBootConfiguration:

        keyName   = REGSTR_KEY_LOG_CONF;
        valueName = REGSTR_VAL_BOOTCONFIG;
        valueType = REG_RESOURCE_LIST;
        break;

    case DevicePropertyBootConfigurationTranslated:

        return STATUS_NOT_SUPPORTED;
        break;

    case DevicePropertyClassName:

        valueName = REGSTR_VALUE_CLASS;
        valueType = REG_SZ;
        break;

    case DevicePropertyClassGuid:
        valueName = REGSTR_VALUE_CLASSGUID;
        valueType = REG_SZ;
        break;

    case DevicePropertyDriverKeyName:

        valueName = REGSTR_VALUE_DRIVER;
        valueType = REG_SZ;
        break;

    case DevicePropertyManufacturer:

        valueName = REGSTR_VAL_MFG;
        valueType = REG_SZ;
        break;

    case DevicePropertyFriendlyName:

        valueName = REGSTR_VALUE_FRIENDLYNAME;
        valueType = REG_SZ;
        break;

    case DevicePropertyInstallState:

        if (deviceNode == IopRootDeviceNode) {
            //
            // The root devnode is always installed, by definition.  We
            // specifically set it's InstallState here because the
            // CONFIGFLAG_REINSTALL flag will wunfortunately still exist on the
            // root devnode reg key on a running system (we should fix that
            // later).
            //
            deviceInstallState = InstallStateInstalled;
            status = STATUS_SUCCESS;

        } else {
            //
            // For all other devnodes, walk up the devnode tree, retrieving the
            // install state of all ancestors up to (but not including) the root
            // devnode.  We'll stop when we've reached the top of the tree, or
            // when some intermediate device has an "uninstalled" install state.
            //

            valueName = REGSTR_VALUE_CONFIG_FLAGS;
            valueType = REG_DWORD;

            do {
                //
                // Get the ConfigFlags registry value.
                //
                length = sizeof(ULONG);
                status = PiGetDeviceRegistryProperty(
                    deviceNode->PhysicalDeviceObject,
                    valueType,
                    valueName,
                    keyName,
                    (PVOID)&configFlags,
                    &length
                    );

                if (NT_SUCCESS(status)) {
                    //
                    // The install state is just a subset of the device's ConfigFlags
                    //
                    if (configFlags & CONFIGFLAG_REINSTALL) {

                        deviceInstallState = InstallStateNeedsReinstall;

                    } else if (configFlags & CONFIGFLAG_FAILEDINSTALL) {

                        deviceInstallState = InstallStateFailedInstall;

                    } else if (configFlags & CONFIGFLAG_FINISH_INSTALL) {

                        deviceInstallState = InstallStateFinishInstall;
                    } else {

                        deviceInstallState = InstallStateInstalled;
                    }
                }

                deviceNode = deviceNode->Parent;

            } while ((NT_SUCCESS(status)) &&
                     (deviceInstallState == InstallStateInstalled) &&
                     (deviceNode != IopRootDeviceNode));
        }

        if (NT_SUCCESS(status)) {

            *ResultLength = sizeof(ULONG);
            if(*ResultLength <= BufferLength) {
                *(PDEVICE_INSTALL_STATE)PropertyBuffer = deviceInstallState;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
        }

        return status;

    default:

        return STATUS_INVALID_PARAMETER_2;
    }
    //
    // Get the registry value.
    //
    *ResultLength = BufferLength;
    status = PiGetDeviceRegistryProperty(
        DeviceObject,
        valueType,
        valueName,
        keyName,
        PropertyBuffer,
        ResultLength
        );

    return status;
}

NTSTATUS
PiGetDeviceRegistryProperty(
    IN      PDEVICE_OBJECT   DeviceObject,
    IN      ULONG            ValueType,
    IN      PWSTR            ValueName,
    IN      PWSTR            KeyName,
    OUT     PVOID            Buffer,
    IN OUT  PULONG           BufferLength
    )
{
    NTSTATUS status;
    HANDLE handle, subKeyHandle;
    UNICODE_STRING unicodeKey;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulatio
    // portion solves this problem
    //
    PiLockPnpRegistry(TRUE);
    //
    // Based on the PDO specified by caller, find the handle of its device
    // instance registry key.
    //
    status = IopDeviceObjectToDeviceInstance(DeviceObject, &handle, KEY_READ);
    if (NT_SUCCESS(status)) {
        //
        // If the data is stored in a subkey then open this key and close the old one
        //
        if (KeyName) {

            RtlInitUnicodeString(&unicodeKey, KeyName);
            status = IopOpenRegistryKeyEx( &subKeyHandle,
                                           handle,
                                           &unicodeKey,
                                           KEY_READ
                                           );
            if(NT_SUCCESS(status)){

                ZwClose(handle);
                handle = subKeyHandle;
            }
        }
        if (NT_SUCCESS(status)) {
            //
            // Read the registry value of the desired value name
            //
            status = IopGetRegistryValue (handle,
                                          ValueName,
                                          &keyValueInformation);
        }
        //
        // We have finished using the registry so clean up and release our resources
        //
        ZwClose(handle);
    }
    PiUnlockPnpRegistry();
    //
    // If we have been sucessfull in finding the info hand it back to the caller
    //
    if (NT_SUCCESS(status)) {
        //
        // Check that the buffer we have been given is big enough and that the value returned is
        // of the correct registry type
        //
        if (*BufferLength >= keyValueInformation->DataLength) {

            if (keyValueInformation->Type == ValueType) {

                RtlCopyMemory(  Buffer,
                                KEY_VALUE_DATA(keyValueInformation),
                                keyValueInformation->DataLength);
            } else {

               status = STATUS_INVALID_PARAMETER_2;
            }
        } else {

            status = STATUS_BUFFER_TOO_SMALL;
        }
        *BufferLength = keyValueInformation->DataLength;
        ExFreePool(keyValueInformation);
    }

    return status;
}

NTSTATUS
IoOpenDeviceRegistryKey(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN ULONG DevInstKeyType,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DevInstRegKey
    )

/*++

Routine Description:

    This routine returns a handle to an opened registry key that the driver
    may use to store/retrieve configuration information specific to a particular
    device instance.

    The driver must call ZwClose to close the handle returned from this api
    when access is no longer required.

Parameters:

    DeviceObject   - Supples the device object of the physical device instance to
                     open a registry storage key for.  Normally it is a device object
                     created by the hal bus extender.

    DevInstKeyType - Supplies flags specifying which storage key associated with
                     the device instance is to be opened.  May be a combination of
                     the following value:

                     PLUGPLAY_REGKEY_DEVICE - Open a key for storing device specific
                         (driver-independent) information relating to the device instance.
                         The flag may not be specified with PLUGPLAY_REGKEY_DRIVER.

                     PLUGPLAY_REGKEY_DRIVER - Open a key for storing driver-specific
                         information relating to the device instance,  This flag may
                         not be specified with PLUGPLAY_REGKEY_DEVICE.

                     PLUGPLAY_REGKEY_CURRENT_HWPROFILE - If this flag is specified,
                         then a key in the current hardware profile branch will be
                         opened for the specified storage type.  This allows the driver
                         to access configuration information that is hardware profile
                         specific.

    DesiredAccess - Specifies the access mask for the key to be opened.

    DevInstRegKey - Supplies the address of a variable that receives a handle to the
                    opened key for the specified registry storage location.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{

    NTSTATUS status, appendStatus;
    HANDLE hBasePath;
    UNICODE_STRING unicodeBasePath, unicodeRestPath;
    WCHAR   drvInst[GUID_STRING_LEN + 5];
    ULONG   drvInstLength;

    PAGED_CODE();

    //
    // Until SCSIPORT stops passing non PDOs allow the system to boot.
    //
    // ASSERT_PDO(PhysicalDeviceObject);
    //

    //
    // Initialise out parameters
    //

    *DevInstRegKey = NULL;

    //
    // Allocate a buffer to build the RestPath string in
    //

    unicodeRestPath.Buffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, MAX_RESTPATH_BUF_LEN);

    if (unicodeRestPath.Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto clean0;
    }

    unicodeRestPath.Length=0;
    unicodeRestPath.MaximumLength=MAX_RESTPATH_BUF_LEN;

    //
    // Select the base path to the CurrentControlSet based on if we are dealing with
    // a hardware profile or not
    //

    if (DevInstKeyType & PLUGPLAY_REGKEY_CURRENT_HWPROFILE) {
        PiWstrToUnicodeString(&unicodeBasePath, PATH_CURRENTCONTROLSET_HW_PROFILE_CURRENT);

    } else {
        PiWstrToUnicodeString(&unicodeBasePath, PATH_CURRENTCONTROLSET);
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //
    PiLockPnpRegistry(TRUE);

    //
    // Open the base registry key
    //

    status = IopOpenRegistryKeyEx( &hBasePath,
                                   NULL,
                                   &unicodeBasePath,
                                   KEY_READ
                                   );

    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Build the RestPath string
    //

    switch (DevInstKeyType) {

    case PLUGPLAY_REGKEY_DEVICE:
    case PLUGPLAY_REGKEY_DEVICE + PLUGPLAY_REGKEY_CURRENT_HWPROFILE:
        {
            PDEVICE_NODE pDeviceNode;

            //
            // Initialise the rest path with Enum\
            //

            appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, PATH_ENUM);
            ASSERT(NT_SUCCESS( appendStatus ));
            //
            // Get the Enumerator\DeviceID\InstanceID path from the DeviceNode
            //

            pDeviceNode = (PDEVICE_NODE) PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

            //
            // Ensure this is a PDO and not an FDO (only PDO's have a DeviceNode)
            //

            if (pDeviceNode) {
                appendStatus = RtlAppendUnicodeStringToString(&unicodeRestPath, &(pDeviceNode->InstancePath));
                ASSERT(NT_SUCCESS( appendStatus ));
            } else {
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

            break;
        }

    case PLUGPLAY_REGKEY_DRIVER:
    case PLUGPLAY_REGKEY_DRIVER + PLUGPLAY_REGKEY_CURRENT_HWPROFILE:
        {

            HANDLE hDeviceKey;

            //
            // Initialise the rest path with Control\Class\
            //

            appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, PATH_CONTROL_CLASS);
            ASSERT(NT_SUCCESS( appendStatus ));

            //
            // Open the device instance key for this device
            //

            status = IopDeviceObjectToDeviceInstance(PhysicalDeviceObject, &hDeviceKey, KEY_READ);

            if(!NT_SUCCESS(status)){
                goto clean1;
            }

            //
            // See if we have a driver value
            //

            status = IoGetDeviceProperty(PhysicalDeviceObject, DevicePropertyDriverKeyName, sizeof(drvInst), drvInst, &drvInstLength);
            if(NT_SUCCESS(status)){
                //
                // Append <DevInstClass>\<ClassInstanceOrdinal>
                //
                appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, drvInst);
                ASSERT(NT_SUCCESS( appendStatus ));
            }

            ZwClose(hDeviceKey);

            break;
        }
    default:

        //
        // ISSUE 2001/02/08 ADRIAO - This is parameter #2, not parameter #3!
        //
        status = STATUS_INVALID_PARAMETER_3;
        goto clean2;
    }


    //
    // If we succeeded in building the rest path then open the key and hand it back to the caller
    //

    if (NT_SUCCESS(status)){
        if (DevInstKeyType == PLUGPLAY_REGKEY_DEVICE) {

            status = IopOpenDeviceParametersSubkey(DevInstRegKey,
                                                   hBasePath,
                                                   &unicodeRestPath,
                                                   DesiredAccess);
        } else {

            status = IopCreateRegistryKeyEx( DevInstRegKey,
                                             hBasePath,
                                             &unicodeRestPath,
                                             DesiredAccess,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );
        }
    }

    //
    // Free up resources
    //

clean2:
    ZwClose(hBasePath);
clean1:
    PiUnlockPnpRegistry();
    ExFreePool(unicodeRestPath.Buffer);
clean0:
    return status;

}

NTSTATUS
IoSynchronousInvalidateDeviceRelations(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  DEVICE_RELATION_TYPE    Type
    )

/*++

Routine Description:

    This API notifies the system that changes have occurred in the device
    relations of the specified type for the supplied DeviceObject.   All
    cached information concerning the relationships must be invalidated,
    and if needed re-obtained via IRP_MN_QUERY_DEVICE_RELATIONS.

    This routine performs device enumeration synchronously.
    Note, A driver can NOT call this IO api while processing pnp irps AND
    A driver can NOT call this api from any system thread except the system
    threads created by the driver itself.

Parameters:

    DeviceObject - the PDEVICE_OBJECT for which the specified relation type
                   information has been invalidated.  This pointer is valid
                   for the duration of the call.

    Type - specifies the type of the relation being invalidated.

ReturnValue:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_NODE deviceNode;
    NTSTATUS status = STATUS_SUCCESS;
    KEVENT completionEvent;

    PAGED_CODE();

    ASSERT_PDO(DeviceObject);

    switch (Type) {
    case BusRelations:

        if (PnPInitialized) {

            deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

            if (deviceNode->State == DeviceNodeStarted) {

                KeInitializeEvent( &completionEvent, NotificationEvent, FALSE );

                status = PipRequestDeviceAction( DeviceObject,
                                                 ReenumerateDeviceTree,
                                                 FALSE,
                                                 0,
                                                 &completionEvent,
                                                 NULL );

                if (NT_SUCCESS(status)) {

                    status = KeWaitForSingleObject( &completionEvent,
                                                    Executive,
                                                    KernelMode,
                                                    FALSE,
                                                    NULL);
                }
            } else {
                status = STATUS_UNSUCCESSFUL;
            }
        } else {
            status = STATUS_UNSUCCESSFUL;
        }
        break;

    case EjectionRelations:

        //
        // For Ejection relation change, we will ignore it.  We don't keep track
        // the Ejection relation.  We will query the Ejection relation only when
        // we are requested to eject a device.
        //

        status = STATUS_NOT_SUPPORTED;
        break;

    case PowerRelations:


        //
        // Call off to Po code, which will do the right thing
        //
        PoInvalidateDevicePowerRelations(DeviceObject);
        break;
    }
    return status;
}

VOID
IoInvalidateDeviceRelations(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  DEVICE_RELATION_TYPE    Type
    )

/*++

Routine Description:

    This API notifies the system that changes have occurred in the device
    relations of the specified type for the supplied DeviceObject.   All
    cached information concerning the relationships must be invalidated,
    and if needed re-obtained via IRP_MN_QUERY_DEVICE_RELATIONS.

Parameters:

    DeviceObject - the PDEVICE_OBJECT for which the specified relation type
                   information has been invalidated.  This pointer is valid
                   for the duration of the call.

    Type - specifies the type of the relation being invalidated.

ReturnValue:

    none.

--*/

{

    PDEVICE_NODE deviceNode;
    KIRQL        oldIrql;

    ASSERT_PDO(DeviceObject);

    switch (Type) {
    case BusRelations:
    case SingleBusRelations:

        //
        // If the call was made before PnP completes device enumeration
        // we can safely ignore it.  PnP manager will do it without
        // driver's request.
        //

        deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;
        if (deviceNode) {

            PipRequestDeviceAction( DeviceObject,
                                    Type == BusRelations ?
                                        ReenumerateDeviceTree : ReenumerateDeviceOnly,
                                    FALSE,
                                    0,
                                    NULL,
                                    NULL );
        }
        break;

    case EjectionRelations:

        //
        // For Ejection relation change, we will ignore it.  We don't keep track
        // the Ejection relation.  We will query the Ejection relation only when
        // we are requested to eject a device.

        break;

    case PowerRelations:

        //
        // Call off to Po code, which will do the right thing
        //
        PoInvalidateDevicePowerRelations(DeviceObject);
        break;
    }
}

VOID
IoRequestDeviceEject(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This API notifies that the device eject button has been pressed. This API must
    be called at IRQL <= DISPATCH_LEVEL.

    This API informs PnP that a device eject has been requested, the device will
    not necessarily be ejected as a result of this API.  The device will only be
    ejected if the drivers associated with it agree to stop and the device is
    successfully powered down.  Note that eject in this context refers to device
    eject, not to media (floppies, cds, tapes) eject.  For example, eject of a
    cd-rom disk drive, not ejection of a cd-rom disk.

Arguments:

    DeviceObject - the PDEVICE_OBJECT for the device whose eject button has
                   been pressed.  This pointer is valid for the duration of
                   the call, if the API wants to keep a copy of it, it
                   should obtain its own reference to the object
                   (ObReferenceObject).

ReturnValue:

    None.

--*/

{
    ASSERT_PDO(DeviceObject);

    IopQueueDeviceWorkItem(DeviceObject, IopRequestDeviceEjectWorker, NULL);
}

VOID
IopRequestDeviceEjectWorker(
    IN PVOID Context
    )
{
    PDEVICE_WORK_ITEM deviceWorkItem = (PDEVICE_WORK_ITEM)Context;
    PDEVICE_OBJECT deviceObject = deviceWorkItem->DeviceObject;

    ExFreePool(deviceWorkItem);

    //
    // Queue the event, we'll return immediately after it's queued.
    //

    PpSetTargetDeviceRemove( deviceObject,
                             TRUE,
                             TRUE,
                             TRUE,
                             CM_PROB_HELD_FOR_EJECT,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    ObDereferenceObject(deviceObject);
}


NTSTATUS
IoReportDetectedDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements OPTIONAL,
    IN BOOLEAN ResourceAssigned,
    IN OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    PnP device drivers call this API to report any device detected.  This routine
    creates a Physical Device object, reference the Physical Device object and
    returns back to the callers.  Once the detected device is reported, the Pnp manager
    considers the device has been fully controlled by the reporting drivers.  Thus it
    will not invoke AddDevice entry and send StartDevice irp to the driver.

    The driver needs to report the resources it used to detect this device such that
    pnp manager can perform duplicates detection on this device.

    The caller must dereference the DeviceObject once it no longer needs it.

Parameters:

    DriverObject - Supplies the driver object of the driver who detected
                   this device.

    ResourceList - Supplies a pointer to the resource list which the driver used
                   to detect the device.

    ResourceRequirements - supplies a pointer to the resource requirements list
                   for the detected device.  This is optional.

    ResourceAssigned - if TRUE, the driver already called IoReportResourceUsage or
                   IoAssignResource to get the ownership of the resources.  Otherwise,
                   the PnP manager will call IoReportResourceUsage to allocate the
                   resources for the driver.

    DeviceObject - if NULL, this routine will create a PDO and return it thru this variable.
                   Otherwise, a PDO is already created and this routine will simply use the supplied
                   PDO.

Return Value:

    Status code that indicates whether or not the function was successful.


--*/

{
    WCHAR buffer[MAX_DEVICE_ID_LEN];
    NTSTATUS status;
    UNICODE_STRING deviceName, instanceName, unicodeName, *serviceName, driverName;
    PDEVICE_NODE deviceNode;
    ULONG length, i = 0, disposition, tmpValue, listSize = 0;
    HANDLE handle = NULL, handle1, logConfHandle = NULL, controlHandle = NULL, enumHandle;
    PCM_RESOURCE_LIST cmResource;
    PWSTR p;
    LARGE_INTEGER tickCount;
    PDEVICE_OBJECT deviceObject;
    BOOLEAN newlyCreated = FALSE;

    PAGED_CODE();

    if (*DeviceObject) {

        deviceObject = *DeviceObject;

        //
        // The PDO is already known. simply handle the resourcelist and resreq list.
        // This is a hack for NDIS drivers.
        //
        deviceNode = (PDEVICE_NODE)(*DeviceObject)->DeviceObjectExtension->DeviceNode;
        if (!deviceNode) {
            return STATUS_NO_SUCH_DEVICE;
        }
        PiLockPnpRegistry(FALSE);

        //
        // Write ResourceList and ResReq list to the device instance
        //

        status = IopDeviceObjectToDeviceInstance (*DeviceObject,
                                                  &handle,
                                                  KEY_ALL_ACCESS
                                                  );
        if (!NT_SUCCESS(status)) {
            PiUnlockPnpRegistry();
            return status;
        }
        if (ResourceAssigned) {
            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_NO_RESOURCE_AT_INIT);
            tmpValue = 1;
            ZwSetValueKey(handle,
                          &unicodeName,
                          TITLE_INDEX_VALUE,
                          REG_DWORD,
                          &tmpValue,
                          sizeof(tmpValue)
                          );
        }
        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
        status = IopCreateRegistryKeyEx( &logConfHandle,
                                         handle,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        ZwClose(handle);
        if (NT_SUCCESS(status)) {

            //
            // Write the ResourceList and and ResourceRequirements to the logconf key under
            // device instance key.
            //

            if (ResourceList) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_BOOTCONFIG);
                ZwSetValueKey(
                          logConfHandle,
                          &unicodeName,
                          TITLE_INDEX_VALUE,
                          REG_RESOURCE_LIST,
                          ResourceList,
                          listSize = IopDetermineResourceListSize(ResourceList)
                          );
            }
            if (ResourceRequirements) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_BASIC_CONFIG_VECTOR);
                ZwSetValueKey(
                          logConfHandle,
                          &unicodeName,
                          TITLE_INDEX_VALUE,
                          REG_RESOURCE_REQUIREMENTS_LIST,
                          ResourceRequirements,
                          ResourceRequirements->ListSize
                          );
            }
            ZwClose(logConfHandle);
        }
        PiUnlockPnpRegistry();
        if (NT_SUCCESS(status)) {
            goto checkResource;
        } else {
            return status;
        }
    }

    //
    // Normal case: *DeviceObject is NULL
    //

    *DeviceObject = NULL;
    serviceName = &DriverObject->DriverExtension->ServiceKeyName;

    //
    // Special handling for driver object created thru IoCreateDriver.
    // When a builtin driver calls IoReportDetectedDevice, the ServiceKeyName of
    // the driver object is set to \Driver\DriverName.  To create a detected device
    // instance key, we will take only the DriverName.
    //

    if (DriverObject->Flags & DRVO_BUILTIN_DRIVER) {
        p = serviceName->Buffer + (serviceName->Length / sizeof(WCHAR)) - 1;
        driverName.Length = 0;
        while (*p != '\\' && (p != serviceName->Buffer)) {
            p--;
            driverName.Length += sizeof(WCHAR);
        }
        if (p == serviceName->Buffer) {
            return STATUS_UNSUCCESSFUL;
        } else {
            p++;
            driverName.Buffer = p;
            driverName.MaximumLength = driverName.Length + sizeof(WCHAR);
        }
    } else {

        //
        // Before doing anything first perform duplicate detection
        //

        status = IopDuplicateDetection( LegacyBusType,
                                        BusNumber,
                                        SlotNumber,
                                        &deviceNode
                                        );

        if (NT_SUCCESS(status) && deviceNode) {

            deviceObject = deviceNode->PhysicalDeviceObject;

            if (PipAreDriversLoaded(deviceNode) ||
                (PipDoesDevNodeHaveProblem(deviceNode) &&
                 deviceNode->Problem != CM_PROB_NOT_CONFIGURED &&
                 deviceNode->Problem != CM_PROB_REINSTALL &&
                 deviceNode->Problem != CM_PROB_FAILED_INSTALL)) {

                ObDereferenceObject(deviceObject);

                return STATUS_NO_SUCH_DEVICE;
            }

            deviceNode->Flags &= ~DNF_HAS_PROBLEM;
            deviceNode->Problem = 0;

            IopDeleteLegacyKey(DriverObject);
            goto checkResource;
        }

    }

    //
    // Create a PDO
    //

    status = IoCreateDevice( IoPnpDriverObject,
                             sizeof(IOPNP_DEVICE_EXTENSION),
                             NULL,
                             FILE_DEVICE_CONTROLLER,
                             FILE_AUTOGENERATED_DEVICE_NAME,
                             FALSE,
                             &deviceObject );

    if (NT_SUCCESS(status)) {
        deviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;   // Mark this is a PDO
        status = PipAllocateDeviceNode(deviceObject, &deviceNode);
        if (status != STATUS_SYSTEM_HIVE_TOO_LARGE && deviceNode) {

            //
            // First delete the Legacy_DriverName key and subkeys from Enum\Root, if exits.
            //

            if (!(DriverObject->Flags & DRVO_BUILTIN_DRIVER)) {
                IopDeleteLegacyKey(DriverObject);
            }

            //
            // Create the compatible id list we'll use for this made-up device.
            //

            status = PpCreateLegacyDeviceIds(
                        deviceObject,
                        ((DriverObject->Flags & DRVO_BUILTIN_DRIVER) ?
                            &driverName : serviceName),
                        ResourceList);

            PiLockPnpRegistry(FALSE);
            if(!NT_SUCCESS(status)) {
                goto exit;
            }

            //
            // Create/Open a registry key for the device instance and
            // write the addr of the device object to registry
            //

            if (DriverObject->Flags & DRVO_BUILTIN_DRIVER) {
                length = _snwprintf(buffer, sizeof(buffer) / sizeof(WCHAR), L"ROOT\\%s", driverName.Buffer);
            } else {
                length = _snwprintf(buffer, sizeof(buffer) / sizeof(WCHAR), L"ROOT\\%s", serviceName->Buffer);
            }
            length *= sizeof(WCHAR);
            deviceName.MaximumLength = sizeof(buffer);
            ASSERT(length <= sizeof(buffer) - 10);
            deviceName.Length = (USHORT)length;
            deviceName.Buffer = buffer;

            status = IopOpenRegistryKeyEx( &enumHandle,
                                           NULL,
                                           &CmRegistryMachineSystemCurrentControlSetEnumName,
                                           KEY_ALL_ACCESS
                                           );
            if (!NT_SUCCESS(status)) {
                goto exit;
            }

            status = IopCreateRegistryKeyEx( &handle1,
                                             enumHandle,
                                             &deviceName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_NON_VOLATILE,
                                             &disposition
                                             );

            if (NT_SUCCESS(status)) {

                deviceName.Buffer[deviceName.Length / sizeof(WCHAR)] =
                           OBJ_NAME_PATH_SEPARATOR;
                deviceName.Length += sizeof(UNICODE_NULL);
                length += sizeof(UNICODE_NULL);
                if (disposition != REG_CREATED_NEW_KEY) {

                    for ( ; ; ) {

                        deviceName.Length = (USHORT)length;
                        PiUlongToInstanceKeyUnicodeString(&instanceName,
                                                          buffer + deviceName.Length / sizeof(WCHAR),
                                                          sizeof(buffer) - deviceName.Length,
                                                          i
                                                          );
                        deviceName.Length += instanceName.Length;
                        status = IopCreateRegistryKeyEx( &handle,
                                                         handle1,
                                                         &instanceName,
                                                         KEY_ALL_ACCESS,
                                                         REG_OPTION_NON_VOLATILE,
                                                         &disposition
                                                         );
                        if (NT_SUCCESS(status)) {

                            if (disposition == REG_CREATED_NEW_KEY) {
                                ZwClose(handle1);
                                break;
                            } else {
                                PKEY_VALUE_FULL_INFORMATION keyValueInformation = NULL;
                                BOOLEAN migratedKey = FALSE, matchingKey = FALSE;

                                //
                                // Check if the key exists because it was
                                // explicitly migrated during textmode setup.
                                //
                                status = IopGetRegistryValue(handle,
                                                             REGSTR_VALUE_MIGRATED,
                                                             &keyValueInformation);
                                if (NT_SUCCESS(status)) {
                                    if ((keyValueInformation->Type == REG_DWORD) &&
                                        (keyValueInformation->DataLength == sizeof(ULONG)) &&
                                        ((*(PULONG)KEY_VALUE_DATA(keyValueInformation)) != 0)) {
                                        migratedKey = TRUE;
                                    }
                                    ExFreePool(keyValueInformation);
                                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_MIGRATED);
                                    ZwDeleteValueKey(handle, &unicodeName);
                                }

                                if (IopIsReportedAlready(handle, serviceName, ResourceList, &matchingKey)) {

                                    ASSERT(matchingKey);

                                    //
                                    // Write the reported resources to registry in case the irq changed
                                    //

                                    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
                                    status = IopCreateRegistryKeyEx( &logConfHandle,
                                                                     handle,
                                                                     &unicodeName,
                                                                     KEY_ALL_ACCESS,
                                                                     REG_OPTION_NON_VOLATILE,
                                                                     NULL
                                                                     );
                                    if (NT_SUCCESS(status)) {

                                        //
                                        // Write the ResourceList and and ResourceRequirements to the device instance key
                                        //

                                        if (ResourceList) {
                                            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_BOOTCONFIG);
                                            ZwSetValueKey(
                                                      logConfHandle,
                                                      &unicodeName,
                                                      TITLE_INDEX_VALUE,
                                                      REG_RESOURCE_LIST,
                                                      ResourceList,
                                                      listSize = IopDetermineResourceListSize(ResourceList)
                                                      );
                                        }
                                        if (ResourceRequirements) {
                                            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_BASIC_CONFIG_VECTOR);
                                            ZwSetValueKey(
                                                      logConfHandle,
                                                      &unicodeName,
                                                      TITLE_INDEX_VALUE,
                                                      REG_RESOURCE_REQUIREMENTS_LIST,
                                                      ResourceRequirements,
                                                      ResourceRequirements->ListSize
                                                      );
                                        }
                                        ZwClose(logConfHandle);
                                    }

                                    PiUnlockPnpRegistry();
                                    IoDeleteDevice(deviceObject);
                                    ZwClose(handle1);
                                    deviceObject = IopDeviceObjectFromDeviceInstance(&deviceName);  // Add a reference
                                    ZwClose(handle);
                                    ZwClose(enumHandle);
                                    ASSERT(deviceObject);
                                    if (deviceObject == NULL) {
                                        status = STATUS_UNSUCCESSFUL;
                                        return status;
                                    }
                                    deviceNode = (PDEVICE_NODE)
                                                  deviceObject->DeviceObjectExtension->DeviceNode;

                                    if (PipAreDriversLoaded(deviceNode) ||
                                        (PipDoesDevNodeHaveProblem(deviceNode) &&
                                         deviceNode->Problem != CM_PROB_NOT_CONFIGURED &&
                                         deviceNode->Problem != CM_PROB_REINSTALL &&
                                         deviceNode->Problem != CM_PROB_FAILED_INSTALL)) {

                                        ObDereferenceObject(deviceObject);

                                        return STATUS_NO_SUCH_DEVICE;
                                    }
                                    goto checkResource;

                                } else if (matchingKey && migratedKey) {
                                    //
                                    // We opened an existing key whose Service
                                    // and Resources match those being reported
                                    // for this device. No device is yet
                                    // reported as using this instance, so we'll
                                    // use it, and treat is as a new key.
                                    //
                                    disposition = REG_CREATED_NEW_KEY;
                                    ZwClose(handle1);
                                    break;

                                } else {
                                    i++;
                                    ZwClose(handle);
                                    continue;
                                }
                            }
                        } else {
                            ZwClose(handle1);
                            ZwClose(enumHandle);
                            goto exit;
                        }
                    }
                } else {

                    //
                    // This is a new device key.  So, instance is 0.  Create it.
                    //

                    PiUlongToInstanceKeyUnicodeString(&instanceName,
                                                      buffer + deviceName.Length / sizeof(WCHAR),
                                                      sizeof(buffer) - deviceName.Length,
                                                      i
                                                      );
                    deviceName.Length += instanceName.Length;
                    status = IopCreateRegistryKeyEx( &handle,
                                                     handle1,
                                                     &instanceName,
                                                     KEY_ALL_ACCESS,
                                                     REG_OPTION_NON_VOLATILE,
                                                     &disposition
                                                     );
                    ZwClose(handle1);
                    if (!NT_SUCCESS(status)) {
                        ZwClose(enumHandle);
                        goto exit;
                    }
                    ASSERT(disposition == REG_CREATED_NEW_KEY);
                }
            } else {
                ZwClose(enumHandle);
                goto exit;
            }

            ASSERT(disposition == REG_CREATED_NEW_KEY);
            newlyCreated = TRUE;

            //
            // Initialize new device instance registry key
            //

            if (ResourceAssigned) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_NO_RESOURCE_AT_INIT);
                tmpValue = 1;
                ZwSetValueKey(handle,
                              &unicodeName,
                              TITLE_INDEX_VALUE,
                              REG_DWORD,
                              &tmpValue,
                              sizeof(tmpValue)
                              );
            }
            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
            logConfHandle = NULL;
            status = IopCreateRegistryKeyEx( &logConfHandle,
                                             handle,
                                             &unicodeName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );

            ASSERT(status == STATUS_SUCCESS);

            if (NT_SUCCESS(status)) {

                //
                // Write the ResourceList and and ResourceRequirements to the logconf key under
                // device instance key.
                //

                if (ResourceList) {
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_BOOTCONFIG);
                    ZwSetValueKey(
                              logConfHandle,
                              &unicodeName,
                              TITLE_INDEX_VALUE,
                              REG_RESOURCE_LIST,
                              ResourceList,
                              listSize = IopDetermineResourceListSize(ResourceList)
                              );
                }
                if (ResourceRequirements) {
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_BASIC_CONFIG_VECTOR);
                    ZwSetValueKey(
                              logConfHandle,
                              &unicodeName,
                              TITLE_INDEX_VALUE,
                              REG_RESOURCE_REQUIREMENTS_LIST,
                              ResourceRequirements,
                              ResourceRequirements->ListSize
                              );
                }
                //ZwClose(logConfHandle);
            }

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_CONFIG_FLAGS);
            tmpValue = CONFIGFLAG_FINISH_INSTALL;
            ZwSetValueKey(handle,
                          &unicodeName,
                          TITLE_INDEX_VALUE,
                          REG_DWORD,
                          &tmpValue,
                          sizeof(tmpValue)
                          );

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_LEGACY);
            tmpValue = 0;
            ZwSetValueKey(
                        handle,
                        &unicodeName,
                        TITLE_INDEX_VALUE,
                        REG_DWORD,
                        &tmpValue,
                        sizeof(ULONG)
                        );

            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
            controlHandle = NULL;
            IopCreateRegistryKeyEx( &controlHandle,
                                    handle,
                                    &unicodeName,
                                    KEY_ALL_ACCESS,
                                    REG_OPTION_VOLATILE,
                                    NULL
                                    );

            ASSERT(status == STATUS_SUCCESS);

            if (NT_SUCCESS(status)) {

                PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_DEVICE_REPORTED);
                tmpValue = 1;
                status = ZwSetValueKey(controlHandle,
                                       &unicodeName,
                                       TITLE_INDEX_VALUE,
                                       REG_DWORD,
                                       &tmpValue,
                                       sizeof(ULONG)
                                       );
                status = ZwSetValueKey(handle,
                                       &unicodeName,
                                       TITLE_INDEX_VALUE,
                                       REG_DWORD,
                                       &tmpValue,
                                       sizeof(ULONG)
                                       );

                //ZwClose(controlHandle);
            }

            ZwClose(enumHandle);

            //
            // Create Service value name and set it to the calling driver's service
            // key name.
            //

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_SERVICE);
            p = (PWSTR)ExAllocatePool(PagedPool, serviceName->Length + sizeof(UNICODE_NULL));
            if (!p) {
                PiUnlockPnpRegistry();
                goto CleanupRegistry;
            }
            RtlCopyMemory(p, serviceName->Buffer, serviceName->Length);
            p[serviceName->Length / sizeof (WCHAR)] = UNICODE_NULL;
            ZwSetValueKey(
                        handle,
                        &unicodeName,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        p,
                        serviceName->Length + sizeof(UNICODE_NULL)
                        );
            if (DriverObject->Flags & DRVO_BUILTIN_DRIVER) {
                deviceNode->ServiceName = *serviceName;
            } else {
                ExFreePool(p);
            }

            PiUnlockPnpRegistry();
            //ZwClose(logConfHandle);
            //ZwClose(controlHandle);
            //ZwClose(handle);

            //
            // Register the device for the driver and save the device
            // instance path in device node.
            //

            if (!(DriverObject->Flags & DRVO_BUILTIN_DRIVER)) {
                PpDeviceRegistration( &deviceName,
                                      TRUE,
                                      &deviceNode->ServiceName
                                      );
            }

            if (PipConcatenateUnicodeStrings(&deviceNode->InstancePath, &deviceName, NULL)) {

                deviceNode->Flags = DNF_MADEUP | DNF_ENUMERATED;

                PipSetDevNodeState(deviceNode, DeviceNodeInitialized, NULL);

                PpDevNodeInsertIntoTree(IopRootDeviceNode, deviceNode);

                //
                // Add an entry into the table to set up a mapping between the DO
                // and the instance path.
                //

                status = IopMapDeviceObjectToDeviceInstance(deviceObject, &deviceNode->InstancePath);
                ASSERT(NT_SUCCESS(status));

                //
                // Add a reference to the DeviceObject for ourself
                //

                ObReferenceObject(deviceObject);

                IopNotifySetupDeviceArrival(deviceObject, NULL, FALSE);

                goto checkResource;
            }
        }
        IoDeleteDevice(deviceObject);
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return status;
checkResource:


    //
    // At this point the *DeviceObject is established.  Check if we need to report resources for
    // the detected device.  If we failed to
    //

    if (ResourceAssigned) {
        //ASSERT(deviceNode->ResourceList == NULL);      // make sure we have not reported resources yet.

        //
        // If the driver specifies it already has acquired the resource.  We will put a flag
        // in the device instance path to not to allocate resources at boot time.  The Driver
        // may do detection and report it again.
        //

        deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED; // do not need resources for this boot.
        if (ResourceList) {

            //
            // Write the resource list to the reported device instance key.
            //

            listSize = IopDetermineResourceListSize(ResourceList);
            IopWriteAllocatedResourcesToRegistry (deviceNode, ResourceList, listSize);
        }
    } else {
        BOOLEAN conflict;

        if (ResourceList && ResourceList->Count && ResourceList->List[0].PartialResourceList.Count) {
            if (listSize == 0) {
                listSize = IopDetermineResourceListSize(ResourceList);
            }
            cmResource = (PCM_RESOURCE_LIST) ExAllocatePool(PagedPool, listSize);
            if (cmResource) {
                RtlCopyMemory(cmResource, ResourceList, listSize);
                PiWstrToUnicodeString(&unicodeName, PNPMGR_STR_PNP_MANAGER);
                status = IoReportResourceUsageInternal(
                             ArbiterRequestLegacyReported,
                             &unicodeName,                  // DriverClassName OPTIONAL,
                             deviceObject->DriverObject,    // DriverObject,
                             NULL,                          // DriverList OPTIONAL,
                             0,                             // DriverListSize OPTIONAL,
                             deviceNode->PhysicalDeviceObject,
                                                            // DeviceObject OPTIONAL,
                             cmResource,                    // DeviceList OPTIONAL,
                             listSize,                      // DeviceListSize OPTIONAL,
                             FALSE,                         // OverrideConflict,
                             &conflict                      // ConflictDetected
                             );
                ExFreePool(cmResource);
                if (!NT_SUCCESS(status) || conflict) {
                    status = STATUS_CONFLICTING_ADDRESSES;
                    PipSetDevNodeProblem(deviceNode, CM_PROB_NORMAL_CONFLICT);
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
                PipSetDevNodeProblem(deviceNode, CM_PROB_OUT_OF_MEMORY);
            }
        } else {
            ASSERT(ResourceRequirements == NULL);
            deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED; // do not need resources for this boot.
        }
    }

    if (NT_SUCCESS(status)) {

        IopDoDeferredSetInterfaceState(deviceNode);

        PipSetDevNodeState(deviceNode, DeviceNodeStartPostWork, NULL);

        *DeviceObject = deviceObject;
        if (newlyCreated) {
            if (controlHandle) {
                ZwClose(controlHandle);
            }
            if (logConfHandle) {
                ZwClose(logConfHandle);
            }
            ZwClose(handle);
        }

        //
        // Make sure we enumerate and process this device's children.
        //

        PipRequestDeviceAction(deviceObject, ReenumerateDeviceOnly, FALSE, 0, NULL, NULL);

        return status;

    }
CleanupRegistry:
    IopReleaseDeviceResources(deviceNode, FALSE);
    if (newlyCreated) {
        IoDeleteDevice(deviceObject);
        if (controlHandle) {
            ZwDeleteKey(controlHandle);
        }
        if (logConfHandle) {
            ZwDeleteKey(logConfHandle);
        }
        if (handle) {
            ZwDeleteKey(handle);
        }
    }
    return status;
exit:
    PiUnlockPnpRegistry();
    IoDeleteDevice(*DeviceObject);
    return status;
}

BOOLEAN
IopIsReportedAlready(
    IN HANDLE Handle,
    IN PUNICODE_STRING ServiceName,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PBOOLEAN MatchingKey
    )

/*++

Routine Description:

    This routine determines if the reported device instance is already reported
    or not.

Parameters:

    Handle - Supplies a handle to the reported device instance key.

    ServiceName - supplies a pointer to the unicode service key name.

    ResourceList - supplies a pointer to the reported Resource list.

    MatchingKey - supplies a pointer to a variable to receive whether the
        ServiceName and ResourceList properties for this key match those
        reported.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PKEY_VALUE_FULL_INFORMATION keyValueInfo1 = NULL, keyValueInfo2 = NULL;
    NTSTATUS status;
    UNICODE_STRING unicodeName;
    HANDLE logConfHandle, controlHandle = NULL;
    BOOLEAN returnValue = FALSE;
    PCM_RESOURCE_LIST cmResource = NULL;
    ULONG tmpValue;

    PAGED_CODE();

    //
    // Assume no match unless we determine otherwise.
    //
    *MatchingKey = FALSE;

    //
    // Check if "Service" value matches what the caller passed in.
    //

    status = IopGetRegistryValue(Handle, REGSTR_VALUE_SERVICE, &keyValueInfo1);
    if (NT_SUCCESS(status)) {
        if ((keyValueInfo1->Type == REG_SZ) &&
            (keyValueInfo1->DataLength != 0)) {
            unicodeName.Buffer = (PWSTR)KEY_VALUE_DATA(keyValueInfo1);
            unicodeName.MaximumLength = unicodeName.Length = (USHORT)keyValueInfo1->DataLength;
            if (unicodeName.Buffer[(keyValueInfo1->DataLength / sizeof(WCHAR)) - 1] == UNICODE_NULL) {
                unicodeName.Length -= sizeof(WCHAR);
            }
            if (RtlEqualUnicodeString(ServiceName, &unicodeName, TRUE)) {

                //
                // Next check if resources are the same
                //

                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
                status = IopOpenRegistryKeyEx( &logConfHandle,
                                               Handle,
                                               &unicodeName,
                                               KEY_READ
                    );
                if (NT_SUCCESS(status)) {
                    status = IopGetRegistryValue(logConfHandle,
                                                 REGSTR_VAL_BOOTCONFIG,
                                                 &keyValueInfo2);
                    ZwClose(logConfHandle);
                    if (NT_SUCCESS(status)) {
                        if ((keyValueInfo2->Type == REG_RESOURCE_LIST) &&
                            (keyValueInfo2->DataLength != 0)) {
                            cmResource = (PCM_RESOURCE_LIST)KEY_VALUE_DATA(keyValueInfo2);
                            if (ResourceList && cmResource &&
                                PipIsDuplicatedDevices(ResourceList, cmResource, NULL, NULL)) {
                                *MatchingKey = TRUE;
                            }
                        }
                    }
                }
                if (!ResourceList && !cmResource) {
                    *MatchingKey = TRUE;
                }
            }
        }
    }

    //
    // If this registry key is for a device reported during the same boot
    // this is not a duplicate.
    //

    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &controlHandle,
                                   Handle,
                                   &unicodeName,
                                   KEY_ALL_ACCESS
                                   );
    if (NT_SUCCESS(status)) {
        status = IopGetRegistryValue(controlHandle,
                                     REGSTR_VALUE_DEVICE_REPORTED,
                                     &keyValueInfo1);
        if (NT_SUCCESS(status)) {
            goto exit;
        }

        if (*MatchingKey == TRUE) {

            returnValue = TRUE;

            //
            // Mark this key has been used.
            //

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_DEVICE_REPORTED);
            tmpValue = 1;
            status = ZwSetValueKey(controlHandle,
                                   &unicodeName,
                                   TITLE_INDEX_VALUE,
                                   REG_DWORD,
                                   &tmpValue,
                                   sizeof(ULONG)
                                   );
            if (!NT_SUCCESS(status)) {
                returnValue = FALSE;
            }
        }
    }

exit:
    if (controlHandle) {
        ZwClose(controlHandle);
    }

    if (keyValueInfo1) {
        ExFreePool(keyValueInfo1);
    }
    if (keyValueInfo2) {
        ExFreePool(keyValueInfo2);
    }
    return returnValue;
}




VOID
IoInvalidateDeviceState(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This API will cause the PnP manager to send the specified PDO an IRP_MN_QUERY_PNP_DEVICE_STATE
    IRP.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO who's state is to be invalidated.

Return Value:

    none.

--*/
{
    PDEVICE_NODE deviceNode;

    ASSERT_PDO(PhysicalDeviceObject);

    //
    // If the call was made before PnP completes device enumeration
    // we can safely ignore it.  PnP manager will do it without
    // driver's request.  If the device was already removed or surprised
    // removed then ignore it as well since this is only valid for started
    // devices.
    //

    deviceNode = (PDEVICE_NODE)PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

    if (deviceNode->State != DeviceNodeStarted) {
        return;
    }

    PipRequestDeviceAction( PhysicalDeviceObject,
                            RequeryDeviceState,
                            FALSE,
                            0,
                            NULL,
                            NULL);
}


NTSTATUS
IopQueueDeviceWorkItem(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN VOID (*WorkerRoutine)(PVOID),
    IN PVOID Context
    )

/*++

Routine Description:

    This API will cause the PnP manager to send the specified PDO an
    IRP_MN_QUERY_PNP_DEVICE_STATE IRP.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO who's state is to be
    invalidated.

Return Value:

    none.

--*/

{
    PDEVICE_WORK_ITEM deviceWorkItem;

    //
    // Since this routine can be called at DPC level we need to queue
    // a work item and process it when the irql drops.
    //

    deviceWorkItem = ExAllocatePool(NonPagedPool, sizeof(DEVICE_WORK_ITEM));
    if (deviceWorkItem == NULL) {

        //
        // Failed to allocate memory for work item.  Nothing we can do ...
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ObReferenceObject(PhysicalDeviceObject);
    deviceWorkItem->DeviceObject = PhysicalDeviceObject;
    deviceWorkItem->Context = Context;

    ExInitializeWorkItem( &deviceWorkItem->WorkItem,
                          WorkerRoutine,
                          deviceWorkItem);

    //
    // Queue a work item to do the enumeration
    //

    ExQueueWorkItem( &deviceWorkItem->WorkItem, DelayedWorkQueue );

    return STATUS_SUCCESS;
}

//
// Private routines
//
VOID
IopResourceRequirementsChanged(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN StopRequired
    )

/*++

Routine Description:

    This routine handles request of device resource requirements list change.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO who's state is to be invalidated.

    StopRequired - Supplies a BOOLEAN value to indicate if the resources reallocation needs
                   to be done after device stopped.

Return Value:

    none.

--*/

{
    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT device = NULL;

    PAGED_CODE();

    PipRequestDeviceAction( PhysicalDeviceObject,
                            ResourceRequirementsChanged,
                            FALSE,
                            StopRequired,
                            NULL,
                            NULL );
}

BOOLEAN
IoIsWdmVersionAvailable(
    IN UCHAR MajorVersion,
    IN UCHAR MinorVersion
    )

/*++

Routine Description:

    This routine reports whether WDM functionality is available that
    is greater than or equal to the specified major and minor version.

Parameters:

    MajorVersion - Supplies the WDM major version that is required.

    MinorVersion - Supplies the WDM minor version that is required.

Return Value:

    If WDM support is available at _at least_ the requested level, the
    return value is TRUE, otherwise it is FALSE.

--*/

{
    return ((MajorVersion < WDM_MAJORVERSION) ||
            ((MajorVersion == WDM_MAJORVERSION) && (MinorVersion <= WDM_MINORVERSION)));
}

NTKERNELAPI
PDMA_ADAPTER
IoGetDmaAdapter(
    IN PDEVICE_OBJECT PhysicalDeviceObject    OPTIONAL,
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function returns the appropriate DMA adapter object for the device
    defined in the device description structure.  This code is a wrapper
    which queries the bus interface standard and then calls the returned
    get DMA adapter function.   If an adapter object was not retrieved then
    a legecy function is attempted.

Arguments:

    PhysicalDeviceObject - Optionally, supplies the PDO for the device
        requesting the DMA adapter.  If not supplied, this routine performs the
        function of the non-PnP HalGetDmaAdapter routine.

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adapter object or NULL if an adapter could not
    be created.

--*/

{
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;
    BUS_INTERFACE_STANDARD busInterface;
    PDMA_ADAPTER dmaAdapter = NULL;
    PDEVICE_DESCRIPTION deviceDescriptionToUse;
    DEVICE_DESCRIPTION privateDeviceDescription;
    ULONG resultLength;
    PDEVICE_OBJECT targetDevice;

    PAGED_CODE();

    if (PhysicalDeviceObject != NULL) {

        ASSERT_PDO(PhysicalDeviceObject);

        //
        // First off, determine whether or not the caller has requested that we
        // automatically fill in the proper InterfaceType value into the
        // DEVICE_DESCRIPTION structure used in retrieving the DMA adapter object.
        // If so, then retrieve that interface type value into our own copy of
        // the DEVICE_DESCRIPTION buffer.
        //
        if ((DeviceDescription->InterfaceType == InterfaceTypeUndefined) ||
            (DeviceDescription->InterfaceType == PNPBus)) {
            //
            // Make a copy of the caller-supplied device description, so
            // we can modify it to fill in the correct interface type.
            //
            RtlCopyMemory(&privateDeviceDescription,
                          DeviceDescription,
                          sizeof(DEVICE_DESCRIPTION)
                         );

            status = IoGetDeviceProperty(PhysicalDeviceObject,
                                         DevicePropertyLegacyBusType,
                                         sizeof(privateDeviceDescription.InterfaceType),
                                         (PVOID)&(privateDeviceDescription.InterfaceType),
                                         &resultLength
                                        );

            if (!NT_SUCCESS(status)) {

                ASSERT(status == STATUS_OBJECT_NAME_NOT_FOUND);

                //
                // Since the enumerator didn't tell us what interface type to
                // use for this PDO, we'll fall back to our default.  This is
                // ISA for machines where the legacy bus is ISA or EISA, and it
                // is MCA for machines whose legacy bus is MicroChannel.
                //
                privateDeviceDescription.InterfaceType = PnpDefaultInterfaceType;
            }

            //
            // Use our private device description buffer from now on.
            //
            deviceDescriptionToUse = &privateDeviceDescription;

        } else {
            //
            // Use the caller-supplied device description.
            //
            deviceDescriptionToUse = DeviceDescription;
        }

        //
        // Now, query for the BUS_INTERFACE_STANDARD interface from the PDO.
        //
        KeInitializeEvent( &event, NotificationEvent, FALSE );

        targetDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);

        irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                            targetDevice,
                                            NULL,
                                            0,
                                            NULL,
                                            &event,
                                            &ioStatusBlock );

        if (irp == NULL) {
            return NULL;
        }

        RtlZeroMemory( &busInterface, sizeof( BUS_INTERFACE_STANDARD ));

        irpStack = IoGetNextIrpStackLocation( irp );
        irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
        irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
        irpStack->Parameters.QueryInterface.Size = sizeof( BUS_INTERFACE_STANDARD );
        irpStack->Parameters.QueryInterface.Version = 1;
        irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) &busInterface;
        irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        //
        // Initialize the status to error in case the ACPI driver decides not to
        // set it correctly.
        //

        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = IoCallDriver(targetDevice, irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
            status = ioStatusBlock.Status;

        }

        ObDereferenceObject(targetDevice);

        if (NT_SUCCESS( status)) {

            if (busInterface.GetDmaAdapter != NULL) {


                dmaAdapter = busInterface.GetDmaAdapter( busInterface.Context,
                                                         deviceDescriptionToUse,
                                                         NumberOfMapRegisters );

            }

            //
            // Dereference the interface
            //

            busInterface.InterfaceDereference( busInterface.Context );
        }

    } else {
        //
        // The caller didn't specify the PDO, so we'll just use the device
        // description exactly as they specified it (i.e., we can't attempt to
        // make our own determination of what interface type to use).
        //
        deviceDescriptionToUse = DeviceDescription;
    }

    //
    // If there is no DMA adapter, try the legacy mode code.
    //

#if !defined(NO_LEGACY_DRIVERS)

    if (dmaAdapter == NULL) {

        dmaAdapter = HalGetDmaAdapter( PhysicalDeviceObject,
                                       deviceDescriptionToUse,
                                       NumberOfMapRegisters );

    }

#endif // NO_LEGACY_DRIVERS

    return( dmaAdapter );
}

NTSTATUS
IopOpenDeviceParametersSubkey(
    OUT HANDLE *ParamKeyHandle,
    IN  HANDLE ParentKeyHandle,
    IN  PUNICODE_STRING SubKeyString,
    IN  ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine reports whether WDM functionality is available that
    is greater than or equal to the specified major and minor version.

Parameters:

    MajorVersion - Supplies the WDM major version that is required.

    MinorVersion - Supplies the WDM minor version that is required.

Return Value:

    If WDM support is available at _at least_ the requested level, the
    return value is TRUE, otherwise it is FALSE.

--*/

{
    NTSTATUS                    status;
    ULONG                       disposition;
    ULONG                       lengthSD;
    PSECURITY_DESCRIPTOR        oldSD = NULL;
    SECURITY_DESCRIPTOR         newSD;
    ACL_SIZE_INFORMATION        aclSizeInfo;
    PACL                        oldDacl;
    PACL                        newDacl = NULL;
    ULONG                       sizeDacl;
    BOOLEAN                     daclPresent, daclDefaulted;
    PACCESS_ALLOWED_ACE         ace;
    ULONG                       aceIndex;
    HANDLE                      deviceKeyHandle;
    UNICODE_STRING              deviceParamString;

    //
    // First try and open the device key
    //
    status = IopOpenRegistryKeyEx( &deviceKeyHandle,
                                   ParentKeyHandle,
                                   SubKeyString,
                                   KEY_WRITE
                                   );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    PiWstrToUnicodeString(&deviceParamString, REGSTR_KEY_DEVICEPARAMETERS);

    status = IopCreateRegistryKeyEx( ParamKeyHandle,
                                     deviceKeyHandle,
                                     &deviceParamString,
                                     DesiredAccess | READ_CONTROL | WRITE_DAC,
                                     REG_OPTION_NON_VOLATILE,
                                     &disposition
                                     );

    ZwClose(deviceKeyHandle);

    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                        "IopOpenDeviceParametersSubkey: IopCreateRegistryKeyEx failed, status = %8.8X\n", status));
        return status;
    }

    if (disposition == REG_CREATED_NEW_KEY) {

        //
        // Need to set an ACL on the key if it was created
        //
        //
        // Get the security descriptor from the key so we can add the
        // administrator.
        //
        status = ZwQuerySecurityObject(*ParamKeyHandle,
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       0,
                                       &lengthSD);

        if (status == STATUS_BUFFER_TOO_SMALL) {
            oldSD = ExAllocatePool( PagedPool, lengthSD );

            if (oldSD != NULL) {

                status = ZwQuerySecurityObject(*ParamKeyHandle,
                                               DACL_SECURITY_INFORMATION,
                                               oldSD,
                                               lengthSD,
                                               &lengthSD);
                if (!NT_SUCCESS(status)) {
                    IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                    "IopOpenDeviceParametersSubkey: ZwQuerySecurityObject failed, status = %8.8X\n", status));
                    goto Cleanup0;
                }
            } else  {

                IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                "IopOpenDeviceParametersSubkey: Failed to allocate memory, status = %8.8X\n", status));
                status = STATUS_NO_MEMORY;
                goto Cleanup0;
            }
        } else {
           IopDbgPrint((    IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: ZwQuerySecurityObject failed %8.8X\n",status));
           status = STATUS_UNSUCCESSFUL;
           goto Cleanup0;
        }

        status = RtlCreateSecurityDescriptor( (PSECURITY_DESCRIPTOR) &newSD,
                                              SECURITY_DESCRIPTOR_REVISION );
        ASSERT( NT_SUCCESS( status ) );

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlCreateSecurityDescriptor failed, status = %8.8X\n", status));
            goto Cleanup0;
        }
        //
        // get the current DACL
        //
        status = RtlGetDaclSecurityDescriptor(oldSD, &daclPresent, &oldDacl, &daclDefaulted);

        ASSERT( NT_SUCCESS( status ) );

        //
        // calculate the size of the new DACL
        //

        if (daclPresent) {

            status = RtlQueryInformationAcl( oldDacl,
                                             &aclSizeInfo,
                                             sizeof(ACL_SIZE_INFORMATION),
                                             AclSizeInformation);


            if (!NT_SUCCESS(status)) {

                IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                "IopOpenDeviceParametersSubkey: RtlQueryInformationAcl failed, status = %8.8X\n", status));
                goto Cleanup0;
            }

            sizeDacl = aclSizeInfo.AclBytesInUse;
        } else {
            sizeDacl = sizeof(ACL);
        }

        sizeDacl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(SeAliasAdminsSid) - sizeof(ULONG);

        //
        // create and initialize the new DACL
        //
        newDacl = ExAllocatePool(PagedPool, sizeDacl);

        if (newDacl == NULL) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: ExAllocatePool failed\n"));
            goto Cleanup0;
        }

        status = RtlCreateAcl(newDacl, sizeDacl, ACL_REVISION);

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlCreateAcl failed, status = %8.8X\n", status));
            goto Cleanup0;
        }

        //
        // copy the current (original) DACL into this new one
        //
        if (daclPresent) {

            for (aceIndex = 0; aceIndex < aclSizeInfo.AceCount; aceIndex++) {

                status = RtlGetAce(oldDacl, aceIndex, (PVOID *)&ace);

                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                    "IopOpenDeviceParametersSubkey: RtlGetAce failed, status = %8.8X\n", status));
                    goto Cleanup0;
                }

                //
                // We need to skip copying any ACEs which refer to the Administrator
                // to ensure that our full control ACE is the one and only.
                //
                if ((ace->Header.AceType != ACCESS_ALLOWED_ACE_TYPE &&
                     ace->Header.AceType != ACCESS_DENIED_ACE_TYPE) ||
                     !RtlEqualSid((PSID)&ace->SidStart, SeAliasAdminsSid)) {

                    status = RtlAddAce( newDacl,
                                        ACL_REVISION,
                                        ~0U,
                                        ace,
                                        ace->Header.AceSize
                                        );

                    if (!NT_SUCCESS(status)) {

                        IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                        "IopOpenDeviceParametersSubkey: RtlAddAce failed, status = %8.8X\n", status));
                        goto Cleanup0;
                    }
                }
            }
        }

        //
        // and my new admin-full ace to this new DACL
        //
        status = RtlAddAccessAllowedAceEx( newDacl,
                                           ACL_REVISION,
                                           CONTAINER_INHERIT_ACE,
                                           KEY_ALL_ACCESS,
                                           SeAliasAdminsSid
                                           );
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlAddAccessAllowedAceEx failed, status = %8.8X\n", status));
            goto Cleanup0;
        }

        //
        // Set the new DACL in the absolute security descriptor
        //
        status = RtlSetDaclSecurityDescriptor( (PSECURITY_DESCRIPTOR) &newSD,
                                               TRUE,
                                               newDacl,
                                               FALSE
                                               );

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlSetDaclSecurityDescriptor failed, status = %8.8X\n", status));
            goto Cleanup0;
        }

        //
        // validate the new security descriptor
        //
        status = RtlValidSecurityDescriptor(&newSD);

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlValidSecurityDescriptor failed, status = %8.8X\n", status));
            goto Cleanup0;
        }


        status = ZwSetSecurityObject( *ParamKeyHandle,
                                      DACL_SECURITY_INFORMATION,
                                      &newSD
                                      );
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: ZwSetSecurityObject failed, status = %8.8X\n", status));
            goto Cleanup0;
        }
    }

    //
    // If we encounter an error updating the DACL we still return success.
    //

Cleanup0:

    if (oldSD != NULL) {
        ExFreePool(oldSD);
    }

    if (newDacl != NULL) {
        ExFreePool(newDacl);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PpCreateLegacyDeviceIds(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DriverName,
    IN PCM_RESOURCE_LIST Resources
    )
{
    PIOPNP_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PWCHAR buffer;

    ULONG length = 0;

    INTERFACE_TYPE interface;
    static const WCHAR* interfaceNames[] ={L"",
                              L"Internal",
                              L"Isa",
                              L"Eisa",
                              L"MicroChannel",
                              L"TurboChannel",
                              L"PCIBus",
                              L"VMEBus",
                              L"NuBus",
                              L"PCMCIABus",
                              L"CBus",
                              L"MPIBus",
                              L"MPSABus",
                              L"ProcessorInternal",
                              L"InternalPowerBus",
                              L"PNPISABus",
                              L"PNPBus",
                              L"Other",
                              L"Root"};


    PAGED_CODE();

    if(Resources != NULL) {

        interface = Resources->List[0].InterfaceType;

        if((interface > MaximumInterfaceType) ||
           (interface < InterfaceTypeUndefined)) {
            interface = MaximumInterfaceType;
        }
    } else {
        interface = Internal;
    }

    interface++;

    //
    // The compatible ID generated will be
    // DETECTED<InterfaceName>\<Driver Name>
    //

    length = (ULONG)(wcslen(LEGACY_COMPATIBLE_ID_BASE) * sizeof(WCHAR));
    length += (ULONG)(wcslen(interfaceNames[interface]) * sizeof(WCHAR));
    length += sizeof(L'\\');
    length += DriverName->Length;
    length += sizeof(UNICODE_NULL);

    length += (ULONG)(wcslen(LEGACY_COMPATIBLE_ID_BASE) * sizeof(WCHAR));
    length += sizeof(L'\\');
    length += DriverName->Length;
    length += sizeof(UNICODE_NULL) * 2;

    buffer = ExAllocatePool(PagedPool, length);
    deviceExtension->CompatibleIdList = buffer;

    if(buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(buffer, length);

    swprintf(buffer, L"%ws%ws\\%wZ", LEGACY_COMPATIBLE_ID_BASE,
                                     interfaceNames[interface],
                                     DriverName);

    //
    // Adjust the buffer to point to the end and generate the second
    // compatible id string.
    //

    buffer += wcslen(buffer) + 1;

    swprintf(buffer, L"%ws\\%wZ", LEGACY_COMPATIBLE_ID_BASE, DriverName);

    deviceExtension->CompatibleIdListSize = length;

    return STATUS_SUCCESS;
}


BOOLEAN
IopAppendLegacyVeto(
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context,
    IN PUNICODE_STRING VetoName
    )
/*++

Routine Description:

    This routine appends a veto (driver name or device instance path) to the
    veto list.

Parameters:

    Context - An IO_GET_LEGACY_VETO_LIST_CONTEXT pointer.

    VetoName - The name of the driver/device to append to the veto list.

ReturnValue:

    A BOOLEAN which indicates whether the append operation was successful.

--*/
{
    ULONG Length;
    PWSTR Buffer;

    //
    // Compute the length of the (new) veto list.  This is the length of
    // the old veto list + the size of the new veto + the size of the
    // terminating '\0'.
    //

    Length = Context->VetoListLength + VetoName->Length + sizeof (WCHAR);

    //
    // Allocate the new veto list.
    //

    Buffer = ExAllocatePool(
                 NonPagedPool,
                 Length
             );

    //
    // If we succeeded in allocating the new veto list, copy the old
    // veto list to the new list, append the new veto, and finally,
    // append a terminating '\0'.  Otherwise, update the status to
    // indicate an error; IopGetLegacyVetoList will free the veto list
    // before it returns.
    //

    if (Buffer != NULL) {

        if (*Context->VetoList != NULL) {

            RtlCopyMemory(
                Buffer,
                *Context->VetoList,
                Context->VetoListLength
            );

            ExFreePool(*Context->VetoList);

        }

        RtlCopyMemory(
            &Buffer[Context->VetoListLength / sizeof (WCHAR)],
            VetoName->Buffer,
            VetoName->Length
        );

        Buffer[Length / sizeof (WCHAR) - 1] = L'\0';

        *Context->VetoList = Buffer;
        Context->VetoListLength = Length;

        return TRUE;

    } else {

        *Context->Status = STATUS_INSUFFICIENT_RESOURCES;

        return FALSE;

    }
}

BOOLEAN
IopGetLegacyVetoListDevice(
    IN PDEVICE_NODE DeviceNode,
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    )
/*++

Routine Description:

    This routine determines whether the specified device node should be added to
    the veto list, and if so, calls IopAppendLegacyVeto to add it.

Parameters:

    DeviceNode - The device node to be added.

    Context - An IO_GET_LEGACY_VETO_LIST_CONTEXT pointer.

ReturnValue:

    A BOOLEAN value which indicates whether the device node enumeration
    process should be terminated or not.

--*/
{
    PDEVICE_CAPABILITIES DeviceCapabilities;

    //
    // A device node should be added added to the veto list, if it has the
    // NonDynamic capability.
    //

    DeviceCapabilities = IopDeviceNodeFlagsToCapabilities(DeviceNode);

    if (DeviceCapabilities->NonDynamic) {

        //
        // Update the veto type.  If an error occurrs while adding the device
        // node to the veto list, or the caller did not provide a veto list
        // pointer, terminate the enumeration process now.
        //

        *Context->VetoType = PNP_VetoLegacyDevice;

        if (Context->VetoList != NULL) {

            if (!IopAppendLegacyVeto(Context, &DeviceNode->InstancePath)) {
                return FALSE;
            }

        } else {

            return FALSE;

        }

    }

    return TRUE;
}

BOOLEAN
IopGetLegacyVetoListDeviceNode(
    IN PDEVICE_NODE DeviceNode,
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    )
/*++

Routine Description:

    This routine recusively walks the device tree, invoking
    IopGetLegacyVetoListDevice to add device nodes to the veto list
    (as appropriate).

Parameters:

    DeviceNode - The device node.

    Context - An IO_GET_LEGACY_VETO_LIST_CONTEXT pointer.


ReturnValue:

    A BOOLEAN value which indicates whether the device tree enumeration
    process should be terminated or not.

--*/
{
    PDEVICE_NODE Child;

    //
    // Determine whether the device node should be added to the veto
    // list and add it.  If an operation is unsuccessful or we determine
    // the veto type but the caller doesn't need the veto list, then we
    // terminate our search now.
    //

    if (!IopGetLegacyVetoListDevice(DeviceNode, Context)) {
        return FALSE;
    }

    //
    // Call ourselves recursively to enumerate our children.  If while
    // enumerating our children we determine we can terminate the search
    // prematurely, do so.
    //

    for (Child = DeviceNode->Child;
         Child != NULL;
         Child = Child->Sibling) {

        if (!IopGetLegacyVetoListDeviceNode(Child, Context)) {
            return FALSE;
        }

    }

    return TRUE;
}

VOID
IopGetLegacyVetoListDrivers(
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    )
{
    PDRIVER_OBJECT driverObject;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING driverString;
    POBJECT_DIRECTORY_INFORMATION dirInfo;
    HANDLE directoryHandle;
    ULONG dirInfoLength, neededLength, dirContext;
    NTSTATUS status;
    BOOLEAN restartScan;

    dirInfoLength = 0;
    dirInfo = NULL;
    restartScan = TRUE;

    //
    // Get handle to \\Driver directory
    //

    PiWstrToUnicodeString(&driverString, L"\\Driver");

    InitializeObjectAttributes(&attributes,
                               &driverString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL
                               );

    status = ZwOpenDirectoryObject(&directoryHandle,
                                   DIRECTORY_QUERY,
                                   &attributes
                                   );
    if (!NT_SUCCESS(status)) {
        *Context->Status = status;
        return;
    }

    for (;;) {

        //
        // Get info on next object in directory.  If the buffer is too
        // small, reallocate it and try again.  Otherwise, any failure
        // including STATUS_NO_MORE_ENTRIES breaks us out.
        //

        status = ZwQueryDirectoryObject(directoryHandle,
                                        dirInfo,
                                        dirInfoLength,
                                        TRUE,           // force one at a time
                                        restartScan,
                                        &dirContext,
                                        &neededLength);
        if (status == STATUS_BUFFER_TOO_SMALL) {
            dirInfoLength = neededLength;
            if (dirInfo != NULL) {
                ExFreePool(dirInfo);
            }
            dirInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, dirInfoLength);
            if (dirInfo == NULL) {
                *Context->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            status = ZwQueryDirectoryObject(directoryHandle,
                                            dirInfo,
                                            dirInfoLength,
                                            TRUE,       // force one at a time
                                            restartScan,
                                            &dirContext,
                                            &neededLength);
        }
        restartScan = FALSE;

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Have name of object.  Create object path and use
        // ObReferenceObjectByName() to get DriverObject.  This may
        // fail non-fatally if DriverObject has gone away in the interim.
        //

        driverString.MaximumLength = sizeof(L"\\Driver\\") +
            dirInfo->Name.Length;
        driverString.Length = driverString.MaximumLength - sizeof(WCHAR);
        driverString.Buffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION,
                                             driverString.MaximumLength);
        if (driverString.Buffer == NULL) {
            *Context->Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        swprintf(driverString.Buffer, L"\\Driver\\%ws", dirInfo->Name.Buffer);
        status = ObReferenceObjectByName(&driverString,
                                         OBJ_CASE_INSENSITIVE,
                                         NULL,                 // access state
                                         0,                    // access mask
                                         IoDriverObjectType,
                                         KernelMode,
                                         NULL,                 // parse context
                                         &driverObject);

        ExFreePool(driverString.Buffer);

        if (NT_SUCCESS(status)) {
            ASSERT(driverObject->Type == IO_TYPE_DRIVER);
            if (driverObject->Flags & DRVO_LEGACY_RESOURCES) {
                //
                // Update the veto type.  If the caller provided a
                // veto list pointer, add the driver to the veto list.
                // If an error occurs while adding the driver to the
                // veto list, or the caller did not provide a veto
                // list pointer, terminate the driver enumeration now.
                //
                // NOTE: Driver may be loaded but not running,
                // distinction is not made here.


                *Context->VetoType = PNP_VetoLegacyDriver;

                if (Context->VetoList != NULL) {
                    IopAppendLegacyVeto(Context, &dirInfo->Name);
                }
            }
            ObDereferenceObject(driverObject);

            //
            // Early out if we have a veto and the caller didn't want a list or
            // we hit some error already
            //
            if (((*Context->VetoType == PNP_VetoLegacyDriver) &&
                (Context->VetoList == NULL)) ||
                !NT_SUCCESS(*Context->Status)) {
                break;
            }
        }
    }
    if (dirInfo != NULL) {
        ExFreePool(dirInfo);
    }

    ZwClose(directoryHandle);
}

NTSTATUS
IoGetLegacyVetoList(
    OUT PWSTR *VetoList OPTIONAL,
    OUT PPNP_VETO_TYPE VetoType
    )
/*++

Routine Description:

    This routine is used by PNP and PO to determine whether legacy drivers and
    devices are installed in the system.  This routine is conceptually a
    QUERY_REMOVE_DEVICE and QUERY_POWER-like interface for legacy drivers
    and devices.

Parameters:

    VetoList - A pointer to a PWSTR. (Optional)  If specified,
        IoGetLegacyVetoList will allocate a veto list, and return a
        pointer to the veto list in VetoList.

    VetoType - A pointer to a PNP_VETO_TYPE.  If no legacy drivers
        or devices are found in the system, VetoType is assigned
        PNP_VetoTypeUnknown.  If one or more legacy drivers are installed,
        VetoType is assigned PNP_VetoLegacyDriver.  If one or more
        legacy devices are installed, VetoType is assigned
        PNP_VetoLegacyDevice.  VetoType is assigned independent of
        whether a VetoList is created.

ReturnValue:

    An NTSTATUS value indicating whether the IoGetLegacyVetoList() operation
    was successful.

--*/
{
    NTSTATUS Status;
    IO_GET_LEGACY_VETO_LIST_CONTEXT Context;
    UNICODE_STRING UnicodeString;

    PAGED_CODE();

    //
    // Initialize the veto list.
    //

    if (VetoList != NULL) {
        *VetoList = NULL;
    }

    //
    // Initialize the veto type.
    //

    ASSERT(VetoType != NULL);

    *VetoType = PNP_VetoTypeUnknown;

    //
    // Initialize the status.
    //

    Status = STATUS_SUCCESS;

    if (PnPInitialized == FALSE) {

        //
        // Can't touch anything, but nothing is really started either.
        //
        return Status;
    }

    //
    // Initialize our local context.
    //

    Context.VetoList = VetoList;
    Context.VetoListLength = 0;
    Context.VetoType = VetoType;
    Context.Status = &Status;

    //
    // Enumerate all driver objects.  This process can: (1) modify
    // the veto list, (2) modify the veto type and/or (3) modify the
    // status.
    //

    IopGetLegacyVetoListDrivers(&Context);

    //
    // If the driver enumeration process was successful and no legacy
    // drivers were detected, enumerate all device nodes.  The same
    // context values as above may be modified during device enumeration.
    //

    if (NT_SUCCESS(Status)) {

        if (*VetoType == PNP_VetoTypeUnknown) {

            PpDevNodeLockTree(PPL_SIMPLE_READ);

            IopGetLegacyVetoListDeviceNode(
                IopRootDeviceNode,
                &Context
            );

            PpDevNodeUnlockTree(PPL_SIMPLE_READ);
        }

    }

    //
    // If the previous operation(s) was/were successful, and the caller
    // provided a veto list pointer and we have constructed a veto
    // list, terminate the veto list with an empty string, i.e. MULTI_SZ.
    //

    if (NT_SUCCESS(Status)) {

        if (*VetoType != PNP_VetoTypeUnknown) {

            if (VetoList != NULL) {

                PiWstrToUnicodeString(
                    &UnicodeString,
                    L""
                );

                IopAppendLegacyVeto(
                    &Context,
                    &UnicodeString
                );

            }

        }

    }

    //
    // If a previous operation was unsuccessful, free any veto list we may have
    // allocated along the way.
    //

    if (!NT_SUCCESS(Status)) {

        if (VetoList != NULL && *VetoList != NULL) {
            ExFreePool(*VetoList);
            *VetoList = NULL;
        }

    }

    return Status;
}

NTSTATUS
PnpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This function is used to stop further processing on an Irp which has been
    passed to IoForwardAndCatchIrp. It signals a event which has been passed
    in the context parameter to indicate that the Irp processing is complete.
    It then returns STATUS_MORE_PROCESSING_REQUIRED in order to stop processing
    on this Irp.

Arguments:

    DeviceObject -
        Contains the device which set up this completion routine.

    Irp -
        Contains the Irp which is being stopped.

    Event -
        Contains the event which is used to signal that this Irp has been
        completed.

Return Value:

    Returns STATUS_MORE_PROCESSING_REQUIRED in order to stop processing on the
    Irp.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    //
    // This will allow the ForwardAndCatchIrp call to continue on its way.
    //
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    //
    // This will ensure that nothing else touches the Irp, since the original
    // caller has now continued, and the Irp may not exist anymore.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTKERNELAPI
BOOLEAN
IoForwardAndCatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used with devices which may be stacked, and may not use
    file objects to communicate.

    Forwards an IRP to the specified driver after initializing the next
    stack location, and regains control of the Irp on completion from that
    driver.

Arguments:

    DeviceObject -
        Contains the device to forward the Irp to.

    Irp -
        Contains the Irp which is being forwarded to the specified driver.

Return Value:

    Returns TRUE if the IRP was forwarded, else FALSE if no stack space
    was available.

--*/
{
    KEVENT Event;

    PAGED_CODE();
    //
    // Ensure that there is another stack location before copying parameters.
    //
    ASSERT(Irp->CurrentLocation > 1);
    if (Irp->CurrentLocation == 1) {
        return FALSE;
    }
    IoCopyCurrentIrpStackLocationToNext(Irp);
    //
    // Set up a completion routine so that the Irp is not actually
    // completed. Thus the caller can get control of the Irp back after
    // this next driver is done with it.
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);
    IoSetCompletionRoutine(Irp, PnpCompletionRoutine, &Event, TRUE, TRUE, TRUE);
    if (IoCallDriver(DeviceObject, Irp) == STATUS_PENDING) {
        //
        // Wait for completion which will occur when the CompletionRoutine
        // signals this event. Wait in KernelMode so that the current stack
        // is not paged out, since there is an event object on this stack.
        //
        KeWaitForSingleObject(
            &Event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }
    return TRUE;
}

NTSTATUS
IoGetDeviceInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PUNICODE_STRING InstanceName
    )
{
    PDEVICE_NODE deviceNode;

    ASSERT_PDO(PhysicalDeviceObject);

    deviceNode = PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

    if (PipConcatenateUnicodeStrings( InstanceName,
                                      &deviceNode->InstancePath,
                                      NULL))  {

        return STATUS_SUCCESS;

    } else {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpi.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the kernel-mode Plug and Play manager.

Author:

    Lonny McMichael (lonnym) 02/08/1995


Revision History:


--*/

#ifndef _KERNEL_PNPI_
#define _KERNEL_PNPI_

#include <wdmguid.h>
#include "regstrp.h"

typedef struct _DEVICE_NODE DEVICE_NODE, *PDEVICE_NODE;
//
// Extract DeviceNode from DeviceObject.
//
#define PP_DO_TO_DN(DO)                \
    ((PDEVICE_NODE)((DO)? (DO)->DeviceObjectExtension->DeviceNode : NULL))

//
// Macros to save useful information into memory dumps.
//

#define PP_SAVE_DEVNODE_TO_TRIAGE_DUMP(dn) {                                                                        \
    if((dn)) {                                                                                                      \
        IoAddTriageDumpDataBlock(dn, sizeof(DEVICE_NODE));                                                          \
        if ((dn)->InstancePath.Length != 0) {                                                                       \
            IoAddTriageDumpDataBlock(&(dn)->InstancePath.Length, sizeof((dn)->InstancePath.Length));                \
            IoAddTriageDumpDataBlock((dn)->InstancePath.Buffer, (dn)->InstancePath.Length);                         \
        }                                                                                                           \
        if ((dn)->ServiceName.Length != 0) {                                                                        \
            IoAddTriageDumpDataBlock(&(dn)->ServiceName.Length, sizeof((dn)->ServiceName.Length));                  \
            IoAddTriageDumpDataBlock((dn)->ServiceName.Buffer, (dn)->ServiceName.Length);                           \
        }                                                                                                           \
        if ((dn)->Parent && (dn)->Parent->ServiceName.Length != 0) {                                                \
            IoAddTriageDumpDataBlock(&(dn)->Parent->ServiceName.Length, sizeof((dn)->Parent->ServiceName.Length));  \
            IoAddTriageDumpDataBlock((dn)->Parent->ServiceName.Buffer, (dn)->Parent->ServiceName.Length);           \
        }                                                                                                           \
    }                                                                                                               \
}

#define PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP(drvo) {                                                                 \
    if(drvo) {                                                                                                      \
        IoAddTriageDumpDataBlock(drvo, (drvo)->Size);                                                               \
        if((drvo)->DriverName.Length != 0) {                                                                        \
            IoAddTriageDumpDataBlock(&(drvo)->DriverName.Length, sizeof((drvo)->DriverName.Length));                \
            IoAddTriageDumpDataBlock((drvo)->DriverName.Buffer, (drvo)->DriverName.Length);                         \
        }                                                                                                           \
    }                                                                                                               \
}

#define PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(do) {                                                                   \
    if((do)) {                                                                                                      \
        IoAddTriageDumpDataBlock(do, (do)->Size);                                                                   \
        PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP((do)->DriverObject);                                                    \
        PP_SAVE_DEVNODE_TO_TRIAGE_DUMP(PP_DO_TO_DN(do));                                                            \
    }                                                                                                               \
}    

#define GUID_STRING_LEN         39
#define MAX_DEVICE_ID_LEN       200     // size in chars
#define MAX_SERVICE_NAME_LEN    256     // in characters
//
// PNP_EVENT_LIST
//
//  This is the head of the master device event list for both user-mode and
//  kernel-mode.
//

typedef struct _PNP_DEVICE_EVENT_LIST {
    NTSTATUS    Status;
    KMUTEX      EventQueueMutex;
    FAST_MUTEX  Lock;
    LIST_ENTRY  List;
} PNP_DEVICE_EVENT_LIST, *PPNP_DEVICE_EVENT_LIST;

//
// PNP_DEVICE_EVENT_ENTRY
//
// One of these structures is allocated for each dynamic device event and
// is removed after the event has been posted to all waiting recipients.
// The notify block contains a pointer to this list.
//

typedef struct _PNP_DEVICE_EVENT_ENTRY {
    LIST_ENTRY                          ListEntry;
    ULONG                               Argument;
    PKEVENT                             CallerEvent;
    PDEVICE_CHANGE_COMPLETE_CALLBACK    Callback;
    PVOID                               Context;
    PPNP_VETO_TYPE                      VetoType;
    PUNICODE_STRING                     VetoName;
    PLUGPLAY_EVENT_BLOCK                Data;
} PNP_DEVICE_EVENT_ENTRY, *PPNP_DEVICE_EVENT_ENTRY;

//
// Defines the enum type to distinguish between REMOVE device
// and EJECT device.
//

typedef enum _PLUGPLAY_DEVICE_DELETE_TYPE {
    QueryRemoveDevice,
    CancelRemoveDevice,
    RemoveDevice,
    SurpriseRemoveDevice,
    EjectDevice,
    RemoveFailedDevice,
    RemoveUnstartedFailedDevice,
    MaxDeviceDeleteType
} PLUGPLAY_DEVICE_DELETE_TYPE, *PPLUGPLAY_DEVICE_DELETE_TYPE;


//++
//
// VOID
// PiWstrToUnicodeString(
//     OUT PUNICODE_STRING u,
//     IN  PCWSTR p
//     )
//
//--
#define PiWstrToUnicodeString(u, p) {                                       \
    if (p) {                                                                \
        (u)->Length = ((u)->MaximumLength = sizeof((p))) - sizeof(WCHAR);   \
    } else {                                                                \
        (u)->Length = (u)->MaximumLength = 0;                               \
    }                                                                       \
    (u)->Buffer = (p);                                                      \
}

//++
//
// VOID
// PiUlongToUnicodeString(
//     OUT    PUNICODE_STRING u,
//     IN OUT PWCHAR ub,
//     IN     ULONG ubl,
//     IN     ULONG i
//     )
//
//--
#define PiUlongToUnicodeString(u, ub, ubl, i)                                                  \
    {                                                                                          \
        LONG len;                                                                               \
                                                                                               \
        len = _snwprintf((PWCHAR)(ub), (ubl) / sizeof(WCHAR), REGSTR_VALUE_STANDARD_ULONG_FORMAT, (i)); \
        (u)->MaximumLength = (USHORT)(ubl);                                                    \
        (u)->Length = (len == -1) ? (USHORT)(ubl) : (USHORT)len * sizeof(WCHAR);               \
        (u)->Buffer = (PWSTR)(ub);                                                             \
    }

//++
//
// VOID
// PiUlongToInstanceKeyUnicodeString(
//     OUT    PUNICODE_STRING u,
//     IN OUT PWCHAR ub,
//     IN     ULONG ubl,
//     IN     ULONG i
//     )
//
//--
#define PiUlongToInstanceKeyUnicodeString(u, ub, ubl, i)                                     \
    {                                                                                        \
        LONG len;                                                                             \
                                                                                             \
        len = _snwprintf((PWCHAR)(ub), (ubl) / sizeof(WCHAR), REGSTR_KEY_INSTANCE_KEY_FORMAT, (i)); \
        (u)->MaximumLength = (USHORT)(ubl);                                                  \
        (u)->Length = (len == -1) ? (USHORT)(ubl) : (USHORT)len * sizeof(WCHAR);             \
        (u)->Buffer = (PWSTR)(ub);                                                           \
    }

//
// The following macros convert between a Count of Wide Characters (CWC) and a Count
// of Bytes (CB).
//
#define CWC_TO_CB(c)    ((c) * sizeof(WCHAR))
#define CB_TO_CWC(c)    ((c) / sizeof(WCHAR))

//
// Macro to determine the number of elements in a statically
// initialized array.
//
#define ELEMENT_COUNT(x) (sizeof(x)/sizeof((x)[0]))

//
// Block write access to Pnp portion of registry.
//
#define PiLockPnpRegistry(Exclusive) {  \
    KeEnterCriticalRegion();            \
    if (Exclusive) {                    \
        ExAcquireResourceExclusiveLite(     \
            &PpRegistryDeviceResource,  \
            TRUE);                      \
    } else {                            \
        ExAcquireResourceSharedLite(        \
            &PpRegistryDeviceResource,  \
            TRUE);                      \
    }                                   \
}
//
// Unblock write access to Pnp portion of registry.
//
#define PiUnlockPnpRegistry() {                     \
    ExReleaseResourceLite(&PpRegistryDeviceResource);   \
    KeLeaveCriticalRegion();                        \
}
//
// Function to complete an event asynchronously.
//
VOID
PpCompleteDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY  DeviceEvent,
    IN     NTSTATUS                 FinalStatus
    );

//
// Global PnP Manager initialization data.
//

extern PVOID PiScratchBuffer;

//
// Private Entry Points
//
BOOLEAN
PiRegSzToString(
    IN  PWCHAR RegSzData,
    IN  ULONG  RegSzLength,
    OUT PULONG StringLength  OPTIONAL,
    OUT PWSTR  *CopiedString OPTIONAL
    );

VOID
PiUserResponse(
    IN ULONG            Response,
    IN PNP_VETO_TYPE    VetoType,
    IN LPWSTR           VetoName,
    IN ULONG            VetoNameLength
    );

NTSTATUS
PiDeviceRegistration(
    IN PUNICODE_STRING DeviceInstancePath,
    IN BOOLEAN Add,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL
    );

BOOLEAN
PiCompareGuid(
    CONST GUID *Guid1,
    CONST GUID *Guid2
    );

VOID
PnPBiosShutdownSystem (
    IN ULONG Phase,
    IN OUT PVOID *Context
    );

NTSTATUS
PnPBiosInitializePnPBios (
    VOID
    );

NTSTATUS
PiGetDeviceRegistryProperty(
    IN      PDEVICE_OBJECT   DeviceObject,
    IN      ULONG            ValueType,
    IN      PWSTR            ValueName,
    IN      PWSTR            KeyName,
    OUT     PVOID            Buffer,
    IN OUT  PULONG           BufferLength
    );

VOID
PpInitializeDeviceReferenceTable(
    VOID
    );

PVOID
NTAPI
PiAllocateGenericTableEntry (
    PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    );

VOID
NTAPI
PiFreeGenericTableEntry (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

VOID
PpRemoveDeviceActionRequests(
    IN PDEVICE_OBJECT DeviceObject
    );

typedef struct _SYSTEM_HIVE_LIMITS {
    ULONG Low;
    ULONG High;
} SYSTEM_HIVE_LIMITS, *PSYSTEM_HIVE_LIMITS;

VOID
PpSystemHiveLimitCallback(
    PSYSTEM_HIVE_LIMITS HiveLimits,
    ULONG Level
    );

extern SYSTEM_HIVE_LIMITS PpSystemHiveLimits;
extern BOOLEAN PpSystemHiveTooLarge;

extern BOOLEAN PpCallerInitializesRequestTable;

NTSTATUS
PpBusTypeGuidInitialize(
    VOID
    );

USHORT
PpBusTypeGuidGetIndex(
    IN LPGUID BusTypeGuid
    );

NTSTATUS
PpBusTypeGuidGet(
    IN USHORT Index,
    IN OUT LPGUID BusTypeGuid
    );

VOID
PiMarkDeviceStackStartPending(
    IN PDEVICE_OBJECT   DeviceObject,
    IN BOOLEAN          Set
    );

NTSTATUS
PpIrpQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
   );

NTSTATUS
PpQueryDeviceID(
    IN PDEVICE_NODE DeviceNode,
    OUT PWCHAR *BusID,
    OUT PWCHAR *DeviceID
    );

NTSTATUS
PpQueryID(
    IN PDEVICE_NODE DeviceNode,
    IN BUS_QUERY_ID_TYPE IDType,
    OUT PWCHAR *ID,
    OUT PULONG IDLength
    );

NTSTATUS
PpIrpQueryID(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IDType,
    OUT PWCHAR *ID
    );

#define PpQueryInstanceID(dn, id, l)    PpQueryID(dn, BusQueryInstanceID, id, l)
#define PpQueryHardwareIDs(dn, id, l)   PpQueryID(dn, BusQueryHardwareIDs, id, l)
#define PpQueryCompatibleIDs(dn, id, l) PpQueryID(dn, BusQueryCompatibleIDs, id, l)
#define IopQueryDeviceSerialNumber(do, id)     PpIrpQueryID(do, BusQueryDeviceSerialNumber, id)

#endif // _KERNEL_PNPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpiop.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpiop.h

Abstract:

    This module contains the plug-and-play macros and constants.

Author:

    Shie-Lin Tzong (shielint) 29-Jan-1995
    Andrew Thornton (andrewth) 5-Sept-1996

Environment:

    Kernel mode


Revision History:


--*/

//
// Pool tags
//

#define IOP_DNOD_TAG    'donD'
#define IOP_DNDT_TAG    'tdnD'
#define IOP_DPWR_TAG    'rwPD'

//
// The DEVICE_NODE is really just some extra stuff that we'd like to keep around
// for each physical device object.
// It is seperated from DEVOBJ_EXTENSION because these fields only apply to
// PDO.
//

typedef enum {

    DOCK_NOTDOCKDEVICE,
    DOCK_QUIESCENT,
    DOCK_ARRIVING,
    DOCK_DEPARTING,
    DOCK_EJECTIRP_COMPLETED

} PROFILE_STATUS;

typedef enum {

    PROFILE_IN_PNPEVENT,
    PROFILE_NOT_IN_PNPEVENT,
    PROFILE_PERHAPS_IN_PNPEVENT

} PROFILE_NOTIFICATION_TIME;

typedef struct _PENDING_SET_INTERFACE_STATE {
    LIST_ENTRY      List;
    UNICODE_STRING  LinkName;
} PENDING_SET_INTERFACE_STATE, *PPENDING_SET_INTERFACE_STATE;


typedef enum _UNLOCK_UNLINK_ACTION {
    UnlinkRemovedDeviceNodes,
    UnlinkAllDeviceNodesPendingClose,
    UnlinkOnlyChildDeviceNodesPendingClose
}   UNLOCK_UNLINK_ACTION, *PUNLOCK_UNLINK_ACTION;

typedef enum _PNP_DEVNODE_STATE {
    DeviceNodeUnspecified       = 0x300, // 768
    DeviceNodeUninitialized,             // 769
    DeviceNodeInitialized,               // 770
    DeviceNodeDriversAdded,              // 771
    DeviceNodeResourcesAssigned,         // 772 - Operational state for Added
    DeviceNodeStartPending,              // 773 - Operational state for Added
    DeviceNodeStartCompletion,           // 774 - Operational state for Added
    DeviceNodeStartPostWork,             // 775 - Operational state for Added
    DeviceNodeStarted,                   // 776
    DeviceNodeQueryStopped,              // 777
    DeviceNodeStopped,                   // 778
    DeviceNodeRestartCompletion,         // 779 - Operational state for Stopped
    DeviceNodeEnumeratePending,          // 780 - Operational state for Started
    DeviceNodeEnumerateCompletion,       // 781 - Operational state for Started
    DeviceNodeAwaitingQueuedDeletion,    // 782
    DeviceNodeAwaitingQueuedRemoval,     // 783
    DeviceNodeQueryRemoved,              // 784
    DeviceNodeRemovePendingCloses,       // 785
    DeviceNodeRemoved,                   // 786
    DeviceNodeDeletePendingCloses,       // 787
    DeviceNodeDeleted                    // 788
}   PNP_DEVNODE_STATE, *PPNP_DEVNODE_STATE;

#define STATE_HISTORY_SIZE  20

typedef struct _DEVICE_NODE *PDEVICE_NODE;
typedef struct _DEVICE_NODE {

    //
    // Pointer to another DEVICE_NODE with the same parent as this one.
    //

    PDEVICE_NODE Sibling;

    //
    // Pointer to the first child of this DEVICE_NODE.
    //

    PDEVICE_NODE Child;

    //
    // Pointer to this DEVICE_NODE's parent.
    //

    PDEVICE_NODE Parent;

    //
    // Pointer to the last child of the device node
    //

    PDEVICE_NODE LastChild;

    //
    // Depth of DEVICE_NODE in the tree, root is 0
    //

    ULONG Level;

    //
    // Power notification order list entry for this device node
    //

    PPO_DEVICE_NOTIFY Notify;

    //
    // State
    //
    PNP_DEVNODE_STATE State;

    //
    // Previous State
    //
    PNP_DEVNODE_STATE PreviousState;

    //
    // Previous State
    //
    PNP_DEVNODE_STATE StateHistory[STATE_HISTORY_SIZE];

    ULONG StateHistoryEntry;

    //
    // Completion status
    //
    NTSTATUS CompletionStatus;

    //
    // Completion status
    //
    PIRP PendingIrp;

    //
    // General flags.
    //

    ULONG Flags;

    //
    // Flags used by user-mode for volatile state which should go away on a
    // reboot or when the device is removed.
    //

    ULONG UserFlags;

    //
    // Problem.  This is set if DNF_HAS_PROBLEM is set in Flags.  Indicates
    // which problem exists and uses the same values as the config manager
    // CM_PROB_*
    //

    ULONG Problem;

    //
    // Pointer to the physical device object that this DEVICE_NODE is associated
    // with.
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Pointer to the list of resources assigned to the PhysicalDeviceObject.
    // This is the Resource list which is passed to driver's start routine.
    //

    PCM_RESOURCE_LIST ResourceList;

    PCM_RESOURCE_LIST ResourceListTranslated;

    //
    // InstancePath is the path of the instance node in the registry,
    // i.e. <EnumBus>\<DeviceId>\<uniqueid>
    //

    UNICODE_STRING InstancePath;

    //
    // ServiceName is the name of the driver who controls the device. (Not the
    // driver who enumerates/creates the PDO.)  This field is mainly for
    // convenience.
    //

    UNICODE_STRING ServiceName;

    //
    // DuplicatePDO - if the flags have DNF_DUPLICATE set then this fields indicates
    // the duplicate PDO which is enumerated by a bus driver.  N.B. It is possible
    // that DNF_DUPLICATE is set but this field is NULL.  In this case, it means that
    // we know the device is a duplicate of another device and we have not enumerated
    // the DuplicatePDO yet.
    //

    PDEVICE_OBJECT DuplicatePDO;

    //
    // ResourceRequirements
    //

    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements;

    //
    // Information queried from the LEGACY_BUS_INFORMATION irp.
    //

    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;

    //
    // Information queried from the BUS_INFORMATION irp.
    //

    INTERFACE_TYPE ChildInterfaceType;
    ULONG ChildBusNumber;
    USHORT ChildBusTypeIndex;

    //
    // Describes the current removal policy for the device node. This is
    // actually type DEVICE_REMOVAL_POLICY.
    //

    UCHAR RemovalPolicy;

    //
    // Similar to above, but doesn't reflect any registry overrides.
    //

    UCHAR HardwareRemovalPolicy;

    //
    // Linked list of entries that represent each driver that has registered
    // for notification on this devnode. Note: drivers (and user-mode) actually
    // register based on a FILE_OBJECT handle, which is translated into a PDO
    // by sending an IRP_MN_QUERY_DEVICE_RELATIONS for TargetDeviceRelation.
    //

    LIST_ENTRY TargetDeviceNotify;

    //
    // DeviceArbiterList - A list of arbiters registered for this physical device object
    // Note: The Arbiters must be dereferenced when the device node is going away.
    //

    LIST_ENTRY DeviceArbiterList;

    //
    // DeviceTranslatorList - A list of translator for this physical device object
    // NOTE: the Translator must be dereferenced when the devic node is going away.
    //

    LIST_ENTRY DeviceTranslatorList;

    //
    // NoTranslatorMask - the bit position corresponds to resource type
    //   if bit is set, there is no translator for the resource type in this devnode
    //

    USHORT NoTranslatorMask;

    //
    // QueryTranslatorMask - The bit position corresponds to resource type.
    //   if bit is set, the translator for the resource type is queried.
    //

    USHORT QueryTranslatorMask;

    //
    // NoArbiterMask - the bit position corresponds to resource type
    //   if bit is set, there is no arbiter for the resource type in this devnode
    //

    USHORT NoArbiterMask;

    //
    // QueryArbiterMask - The bit position corresponds to resource type.
    //   if bit is set, the arbiter for the resource type is queried.
    //

    USHORT QueryArbiterMask;

    //
    // The following fields are used to track  legacy resource allocation
    // LegacyDeviceNode - The real legacy device node.
    // NextResourceDeviceNode - link all the made-up device nodes which own part of
    //   the resources from LegacyDeviceNode.
    //

    union {
        PDEVICE_NODE LegacyDeviceNode;
        PDEVICE_RELATIONS PendingDeviceRelations;
    } OverUsed1;

    union {
        PDEVICE_NODE NextResourceDeviceNode;
    } OverUsed2;

    //
    // Remember the BootResources for the device
    //

    PCM_RESOURCE_LIST BootResources;

    //
    // When Capabilities have been queried for a device (twice, once before
    // start and once after start) the flags are stored here in the same format
    // as the query capabilities IRP - use IopDeviceNodeFlagsToCapabilities to
    // access.
    //
    ULONG CapabilityFlags;

    //
    // Maintain a list of current dock devices and their SerialNumbers
    //
    struct {
        PROFILE_STATUS  DockStatus;
        LIST_ENTRY      ListEntry;
        PWCHAR          SerialNumber;
    } DockInfo;

    //
    // Maintain a count to determine if either ourselves or any of
    // our children are stopping us from being disableable
    // count = myself (DNUF_NOT_DISABLEABLE) + 1 for each immediate
    // child that has DisableableDepends > 0
    //
    ULONG DisableableDepends;

    //
    // List of pended IoSetDeviceInterfaceState calls.
    // IoSetDeviceInterfaceState adds an entry to this list whenever it is
    // called and we haven't been started yet.  Once we do the start we'll
    // run down the list.
    //
    LIST_ENTRY PendedSetInterfaceState;

    //
    // List of device nodes with same interface type and different bus numbers.
    //
    LIST_ENTRY LegacyBusListEntry;

#if DBG_SCOPE
    ULONG FailureStatus;
    PCM_RESOURCE_LIST PreviousResourceList;
    PIO_RESOURCE_REQUIREMENTS_LIST PreviousResourceRequirements;
#endif

} DEVICE_NODE;


//
// A device Object is a PDO iff it has a non NULL device node (aka set by
// plug and play during a query device relations.
//
#define IS_PDO(d) \
    ((NULL != (d)->DeviceObjectExtension->DeviceNode) && \
    (!(((PDEVICE_NODE)(d)->DeviceObjectExtension->DeviceNode)->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)))

#define ASSERT_PDO(d) \
    do { \
        if (    NULL == (d)->DeviceObjectExtension->DeviceNode || \
                (((PDEVICE_NODE)(d)->DeviceObjectExtension->DeviceNode)->Flags & DNF_LEGACY_RESOURCE_DEVICENODE))  { \
            KeBugCheckEx(PNP_DETECTED_FATAL_ERROR, PNP_ERR_INVALID_PDO, (ULONG_PTR)d, 0, 0); \
        } \
    } \
    while (0)

//
// DNF_MAKEUP - this devnode's device is created and owned by PnP manager
//

#define DNF_MADEUP                                  0x00000001

//
// DNF_DUPLICATE - this devnode's device is a duplicate of another enumerate PDO
//

#define DNF_DUPLICATE                               0x00000002

//
// DNF_HAL_NODE - a flag to indicate which device node is the root node created by
// the hal
//

#define DNF_HAL_NODE                                0x00000004

//
// DNF_REENUMERATE - needs to be reenumerated
//

#define DNF_REENUMERATE                             0x00000008

//
// DNF_ENUMERATED - used to track enumeration in IopEnumerateDevice()
//

#define DNF_ENUMERATED                              0x00000010

//
// Singal that we need to send driver query id irps
//

#define DNF_IDS_QUERIED                             0x00000020

//
// DNF_HAS_BOOT_CONFIG - the device has resource assigned by BIOS.  It is considered
//    pseudo-started and need to participate in rebalance.
//

#define DNF_HAS_BOOT_CONFIG                         0x00000040

//
// DNF_BOOT_CONFIG_RESERVED - Indicates the BOOT resources of the device are reserved.
//

#define DNF_BOOT_CONFIG_RESERVED                    0x00000080

//
// DNF_NO_RESOURCE_REQUIRED - this devnode's device does not require resource.
//

#define DNF_NO_RESOURCE_REQUIRED                    0x00000100

//
// DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED - to distinguished the
//      DeviceNode->ResourceRequirements is a filtered list or not.
//

#define DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED     0x00000200

//
// DNF_RESOURCE_REQUIREMENTS_CHANGED - Indicates the device's resource
//      requirements list has been changed.
//

#define DNF_RESOURCE_REQUIREMENTS_CHANGED           0x00000400

//
// DNF_NON_STOPPED_REBALANC - indicates the device can be restarted with new
//      resources without being stopped.
//

#define DNF_NON_STOPPED_REBALANCE                   0x00000800

//
// The device's controlling driver is a legacy driver
//

#define DNF_LEGACY_DRIVER                           0x00001000

//
// This corresponds to the user-mode CM_PROB_WILL_BE_REMOVED problem value and
// the DN_WILL_BE_REMOVED status flag.
//

#define DNF_HAS_PROBLEM                             0x00002000

//
// DNF_HAS_PRIVATE_PROBLEM - indicates this device reported PNP_DEVICE_FAILED
//  to a IRP_MN_QUERY_PNP_DEVICE_STATE without also reporting
//  PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED.
//

#define DNF_HAS_PRIVATE_PROBLEM                     0x00004000

//
// DNF_HARDWARE_VERIFICATION is set on device nodes that have hardware
// verification (probably via WHQL applet).
//

#define DNF_HARDWARE_VERIFICATION                   0x00008000

//
// DNF_DEVICE_GONE is set when a pdo is no longer returned in a query bus
// relations.  It will then be processed as a surprise remove if started.
// This flag is used to better detect when a device is resurrected, and when
// processing surprise remove, to determine if the devnode should be removed
// from the tree.
//

#define DNF_DEVICE_GONE                             0x00010000

//
// DNF_LEGACY_RESOURCE_DEVICENODE is set for device nodes created for legacy
// resource allocation.
//

#define DNF_LEGACY_RESOURCE_DEVICENODE              0x00020000

//
// DNF_NEEDS_REBALANCE is set for device nodes that trigger rebalance.
//

#define DNF_NEEDS_REBALANCE                         0x00040000

//
// DNF_LOCKED_FOR_EJECT is set on device nodes that are being ejected or are
// related to a device being ejected.
//

#define DNF_LOCKED_FOR_EJECT                        0x00080000

//
// DNF_DRIVER_BLOCKED is set on device nodes that use one or more drivers that
// have been blocked from loading.
//

#define DNF_DRIVER_BLOCKED                          0x00100000

//
// DNF_CHILD_WITH_INVALID_ID is set on device nodes that has one or more children             
// that have invalid id(s).
//

#define DNF_CHILD_WITH_INVALID_ID                   0x00200000

//
// This corresponds to the user-mode the DN_WILL_BE_REMOVED status flag.
//

#define DNUF_WILL_BE_REMOVED                        0x00000001

//
// This corresponds to the user-mode DN_NO_SHOW_IN_DM status flag.
//

#define DNUF_DONT_SHOW_IN_UI                        0x00000002

//
// This flag is set when user-mode lets us know that a reboot is required
// for this device.
//

#define DNUF_NEED_RESTART                           0x00000004

//
// This flag is set to let the user-mode know when a device can be disabled
// it is still possible for this to be TRUE, yet disable to fail, as it's
// a polled flag (see also PNP_DEVICE_NOT_DISABLEABLE)
//

#define DNUF_NOT_DISABLEABLE                        0x00000008

//
// Flags used during shutdown when the IO Verifier is trying to remove all
// PNP devices.
//
// DNUF_SHUTDOWN_QUERIED is set when we issue the QueryRemove to a devnode.
//
// DNUF_SHUTDOWN_SUBTREE_DONE is set once we've issued the QueryRemove to all
// a Devnodes descendants.
//
#define DNUF_SHUTDOWN_QUERIED                       0x00000010
#define DNUF_SHUTDOWN_SUBTREE_DONE                  0x00000020

//
// PNP Bugcheck Subcodes
//
#define PNP_ERR_DUPLICATE_PDO                   1
#define PNP_ERR_INVALID_PDO                     2
#define PNP_ERR_BOGUS_ID                        3
#define PNP_ERR_PDO_ENUMERATED_AFTER_DELETION   4
#define PNP_ERR_ACTIVE_PDO_FREED                5

#define PNP_ERR_DEVICE_MISSING_FROM_EJECT_LIST  6
#define PNP_ERR_UNEXPECTED_ADD_RELATION_ERR     7

#define MAX_INSTANCE_PATH_LENGTH    260

typedef NTSTATUS (*PENUM_CALLBACK)(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    );

//
// Define callback routine for PipApplyFunctionToSubKeys &
// PipApplyFunctionToServiceInstances
//
typedef BOOLEAN (*PIOP_SUBKEY_CALLBACK_ROUTINE) (
    IN     HANDLE,
    IN     PUNICODE_STRING,
    IN OUT PVOID
    );

//
// Define context structures for Start and Add device services
//

#define NO_MORE_GROUP ((USHORT) -1)
#define SETUP_RESERVED_GROUP      0
#define BUS_DRIVER_GROUP          1

typedef struct _ADD_CONTEXT {
    ULONG DriverStartType;
} ADD_CONTEXT, *PADD_CONTEXT;

typedef struct _START_CONTEXT {
    BOOLEAN LoadDriver;
    BOOLEAN NewDevice;
    ADD_CONTEXT AddContext;
} START_CONTEXT, *PSTART_CONTEXT;

//
// Resource translation and allocation related structures
//

typedef enum _RESOURCE_HANDLER_TYPE {
    ResourceHandlerNull,
    ResourceTranslator,
    ResourceArbiter,
    ResourceLegacyDeviceDetection
} RESOURCE_HANDLER_TYPE;

#define PI_MAXIMUM_RESOURCE_TYPE_TRACKED 15

//
// Internal Arbiters tracking structures
// Note the first three fields of PI_RESOURCE_ARBITER_ENTRY and PI_RESOURCE_TRANSLATOR_ENTRY
// must be the same.
//

typedef struct _PI_RESOURCE_ARBITER_ENTRY {
    LIST_ENTRY          DeviceArbiterList;         // Link all the arbiters of a PDO.
    UCHAR               ResourceType;
    PARBITER_INTERFACE  ArbiterInterface;
    ULONG               Level;                     // Level of the owning device.
    LIST_ENTRY          ResourceList;
    LIST_ENTRY          BestResourceList;
    LIST_ENTRY          BestConfig;                // Link all the arbiters which produces the best logconf
    LIST_ENTRY          ActiveArbiterList;         // Link all the arbiters under testing
    UCHAR               State;
    BOOLEAN             ResourcesChanged;
} PI_RESOURCE_ARBITER_ENTRY, *PPI_RESOURCE_ARBITER_ENTRY;

//
// Define PI_RESOURCE_ARBITER_ENTRY state
//

#define PI_ARBITER_HAS_SOMETHING 1
#define PI_ARBITER_TEST_FAILED   2

//
// Internal Translator tracking structures
//

typedef struct _PI_RESOURCE_TRANSLATOR_ENTRY {
    LIST_ENTRY              DeviceTranslatorList;
    UCHAR                   ResourceType;
    PTRANSLATOR_INTERFACE   TranslatorInterface;
    PDEVICE_NODE            DeviceNode;
} PI_RESOURCE_TRANSLATOR_ENTRY, *PPI_RESOURCE_TRANSLATOR_ENTRY;

//
// IOP_RESOURCE_REQUEST
//

#define QUERY_RESOURCE_LIST                0
#define QUERY_RESOURCE_REQUIREMENTS        1

#define REGISTRY_ALLOC_CONFIG              1
#define REGISTRY_FORCED_CONFIG             2
#define REGISTRY_BOOT_CONFIG               4
#define REGISTRY_OVERRIDE_CONFIGVECTOR     1
#define REGISTRY_BASIC_CONFIGVECTOR        2

//
// An array of IOP_RESOURCE_REQUEST structures is used to anchor all the
// devices for which resource rerquirement is being attempted.
//

#define IOP_ASSIGN_RETRY              0x00000008    // Retry resource allocation later
#define IOP_ASSIGN_EXCLUDE            0x00000010    // internal IopAssign flag
#define IOP_ASSIGN_IGNORE             0x00000020    // ignore this request
#define IOP_ASSIGN_NO_REBALANCE       0x00000080    // no rebal if assign fails
#define IOP_ASSIGN_RESOURCES_RELEASED 0x00000100    // resources are released for rebalancing
#define IOP_ASSIGN_KEEP_CURRENT_CONFIG 0x00000200   // Indicate non-stopped rebalance.  We need to
                                                    //   preserved the current config.
#define IOP_ASSIGN_CLEAR_RESOURCE_REQUIREMENTS_CHANGE_FLAG \
                                      0x00000400

typedef struct _IOP_RESOURCE_REQUEST {
    PDEVICE_OBJECT                 PhysicalDevice;
    ULONG                          Flags;
    ARBITER_REQUEST_SOURCE         AllocationType;
    ULONG                          Priority;                   // 0 is highest priority
    ULONG                          Position;                   // used for sorting of entries with same priority
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements;
    PVOID                          ReqList;                    // PREQ_LIST
    PCM_RESOURCE_LIST              ResourceAssignment;
    PCM_RESOURCE_LIST              TranslatedResourceAssignment;
    NTSTATUS                       Status;
} IOP_RESOURCE_REQUEST, *PIOP_RESOURCE_REQUEST;

//
// Misc
//

//
// Enumeration request type
//

typedef enum _DEVICE_REQUEST_TYPE {
    AddBootDevices,
    AssignResources,
    ClearDeviceProblem,
    ClearEjectProblem,
    HaltDevice,
    ReenumerateBootDevices,
    ReenumerateDeviceOnly,
    ReenumerateDeviceTree,
    ReenumerateRootDevices,
    RequeryDeviceState,
    ResetDevice,
    ResourceRequirementsChanged,
    RestartEnumeration,
    SetDeviceProblem,
    ShutdownPnpDevices,
    StartDevice,
    StartSystemDevices
} DEVICE_REQUEST_TYPE;

#define CmResourceTypeReserved  0xf0



//
// This macro returns the pointer to the beginning of the data
// area of KEY_VALUE_FULL_INFORMATION structure.
// In the macro, k is a pointer to KEY_VALUE_FULL_INFORMATION structure.
//

#define KEY_VALUE_DATA(k) ((PCHAR)(k) + (k)->DataOffset)

//
// Save failure status info.
//

#if DBG_SCOPE
#define SAVE_FAILURE_INFO(DeviceNode, Status) (DeviceNode)->FailureStatus = (Status)
#else
#define SAVE_FAILURE_INFO(DeviceNode, Status)
#endif

BOOLEAN
PipAreDriversLoaded(
    IN PDEVICE_NODE DeviceNode
    );

BOOLEAN
PipIsDevNodeDNStarted(
    IN PDEVICE_NODE DeviceNode
    );

VOID
PipClearDevNodeProblem(
    IN PDEVICE_NODE DeviceNode
    );

VOID
PipSetDevNodeProblem(
    IN PDEVICE_NODE DeviceNode,
    IN ULONG        Problem
    );

#define PipIsRequestPending(devnode)   FALSE

#define PipDoesDevNodeHaveResources(devnode)                        \
        ((devnode)->ResourceList != NULL || (devnode)->BootResources != NULL || \
        ((devnode)->Flags & DNF_HAS_BOOT_CONFIG) != 0)


#define PipDoesDevNodeHaveProblem(devnode)                          \
        ((devnode)->Flags & (DNF_HAS_PROBLEM | DNF_HAS_PRIVATE_PROBLEM))

#define PipIsDevNodeProblem(devnode, problem)                       \
        (((devnode)->Flags & DNF_HAS_PROBLEM) && (devnode)->Problem == (problem))

#define PipIsDevNodeDeleted(d)                                      \
    ((d)->State == DeviceNodeDeletePendingCloses ||(d)->State == DeviceNodeDeleted)

VOID
PipSetDevNodeState(
    IN  PDEVICE_NODE        DeviceNode,
    IN  PNP_DEVNODE_STATE   State,
    OUT PNP_DEVNODE_STATE  *OldState    OPTIONAL
    );

VOID
PipRestoreDevNodeState(
    IN PDEVICE_NODE DeviceNode
    );

BOOLEAN
PipIsProblemReadonly(
    IN  ULONG   Problem
    );

//++
//
// VOID
// IopRegistryDataToUnicodeString(
//     OUT PUNICODE_STRING u,
//     IN  PWCHAR p,
//     IN  ULONG l
//     )
//
//--
#define IopRegistryDataToUnicodeString(u, p, l)  \
    {                                            \
        ULONG len;                               \
                                                 \
        PiRegSzToString((p), (l), &len, NULL);   \
        (u)->Length = (USHORT)len;               \
        (u)->MaximumLength = (USHORT)(l);        \
        (u)->Buffer = (p);                       \
    }

//
// Size of scratch buffer used in this module.
//

#define PNP_SCRATCH_BUFFER_SIZE 512
#define PNP_LARGE_SCRATCH_BUFFER_SIZE (PNP_SCRATCH_BUFFER_SIZE * 8)

//
// Define Device Instance Flags (used by IoQueryDeviceConfiguration apis)
//

#define DEVINSTANCE_FLAG_HWPROFILE_DISABLED 0x1
#define DEVINSTANCE_FLAG_PNP_ENUMERATED 0x2

//
// Define Enumeration Control Flags (used by PipApplyFunctionToSubKeys)
//

#define FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS  0x1
#define FUNCTIONSUBKEY_FLAG_DELETE_SUBKEYS              0x2

//
// The following definitions are used in IoOpenDeviceInstanceKey
//

#define PLUGPLAY_REGKEY_DEVICE  1
#define PLUGPLAY_REGKEY_DRIVER  2
#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE 4

//
// Define device extension for devices reported with IoReportDetectedDevice.
//

typedef struct _IOPNP_DEVICE_EXTENSION {
    PWCHAR CompatibleIdList;
    ULONG CompatibleIdListSize;
} IOPNP_DEVICE_EXTENSION, *PIOPNP_DEVICE_EXTENSION;

//
// Reserve Boot Resources
//

typedef struct _IOP_RESERVED_RESOURCES_RECORD IOP_RESERVED_RESOURCES_RECORD, *PIOP_RESERVED_RESOURCES_RECORD;

struct _IOP_RESERVED_RESOURCES_RECORD {
    PIOP_RESERVED_RESOURCES_RECORD  Next;
    PDEVICE_OBJECT                  DeviceObject;
    PCM_RESOURCE_LIST               ReservedResources;
};

//
// External References
//

//
// Init data
//
extern PVOID IopPnpScratchBuffer1;
extern PVOID IopPnpScratchBuffer2;
extern PCM_RESOURCE_LIST IopInitHalResources;
extern PDEVICE_NODE IopInitHalDeviceNode;
extern PIOP_RESERVED_RESOURCES_RECORD IopInitReservedResourceList;

//
// Regular data
//

//
// IopRootDeviceNode - the head of the PnP manager's device node tree.
//

extern PDEVICE_NODE IopRootDeviceNode;

//
// IopPnPDriverObject - the madeup driver object for pnp manager
//

extern PDRIVER_OBJECT IopPnPDriverObject;

//
// IopPnPSpinLock - spinlock for Pnp code.
//

extern KSPIN_LOCK IopPnPSpinLock;

//
// IopPnpEnumerationRequestList - a link list of device enumeration requests to worker thread.
//

extern LIST_ENTRY IopPnpEnumerationRequestList;

//
// PiEngineLock - Synchronizes the start/enum and remove engines.
//     (Note that this is a resource as certain acquisition paths are reentrant,
//      specifically those that call IopNotifyPnpWhenChainDereferenced.)
//

extern ERESOURCE PiEngineLock;

//
// IopDeviceTreeLock - performs syncronization on the whole device node tree.
//      IopAcquireEnumerationLock acquires this lock shared then optionally
//                                acquires an exclusive lock on a devnode.
//      IopAcquireDeviceTreeLock acquires this lock exclusive
//

extern ERESOURCE IopDeviceTreeLock;

//
// IopSurpriseRemoveListLock - synchronizes access to the surprise remove list.
//

extern ERESOURCE IopSurpriseRemoveListLock;

//
// PiEventQueueEmpty - Manual reset event which is set when the queue is empty
//

extern KEVENT PiEventQueueEmpty;

//
// PiEnumerationLock - to synchronize IoInvalidateDeviceRelations in boot phase.
//

extern KEVENT PiEnumerationLock;

//
// IopNumberDeviceNodes - Number of outstanding device nodes in the system
//

extern ULONG IopNumberDeviceNodes;

//
// PnPInitialized - A flag to indicate if PnP initialization is completed.
//

extern BOOLEAN PnPInitialized;

//
// PnPBootDriverInitialied
//

extern BOOLEAN PnPBootDriversInitialized;

//
// PnPBootDriverLoaded
//

extern BOOLEAN PnPBootDriversLoaded;

//
// IopBootConfigsReserved - Indicates whether we have reserved BOOT configs or not.
//

extern BOOLEAN IopBootConfigsReserved;

//
// PnpDefaultInterfaceTYpe - Use this if the interface type of resource list is unknown.
//

extern INTERFACE_TYPE PnpDefaultInterfaceType;

//
// PnpStartAsynOk - control how start irp should be handled. Synchronously or Asynchronously?
//

extern BOOLEAN PnpAsyncOk;

//
// IopPendingEjects - List of pending eject requests
//
extern LIST_ENTRY  IopPendingEjects;

//
// IopPendingSurpriseRemovals - List of pending surprise removal requests
//
extern LIST_ENTRY   IopPendingSurpriseRemovals;

extern KSEMAPHORE   PpRegistrySemaphore;

extern BOOLEAN      PpPnpShuttingDown;

BOOLEAN
PipIsDuplicatedDevices(
    IN PCM_RESOURCE_LIST Configuration1,
    IN PCM_RESOURCE_LIST Configuration2,
    IN PHAL_BUS_INFORMATION BusInfo1 OPTIONAL,
    IN PHAL_BUS_INFORMATION BusInfo2 OPTIONAL
    );

BOOLEAN
PipConcatenateUnicodeStrings(
    OUT PUNICODE_STRING Destination,
    IN  PUNICODE_STRING String1,
    IN  PUNICODE_STRING String2  OPTIONAL
    );

NTSTATUS
PipServiceInstanceToDeviceInstance(
    IN  HANDLE ServiceKeyHandle OPTIONAL,
    IN  PUNICODE_STRING ServiceKeyName OPTIONAL,
    IN  ULONG ServiceInstanceOrdinal,
    OUT PUNICODE_STRING DeviceInstanceRegistryPath OPTIONAL,
    OUT PHANDLE DeviceInstanceHandle OPTIONAL,
    IN  ACCESS_MASK DesiredAccess
    );

NTSTATUS
PipCreateMadeupNode(
    IN PUNICODE_STRING ServiceKeyName,
    OUT PHANDLE ReturnedHandle,
    OUT PUNICODE_STRING KeyName,
    OUT PULONG InstanceOrdinal,
    IN BOOLEAN ResourceOwned
    );

NTSTATUS
PipOpenServiceEnumKeys(
    IN PUNICODE_STRING ServiceKeyName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ServiceHandle OPTIONAL,
    OUT PHANDLE ServiceEnumHandle OPTIONAL,
    IN BOOLEAN CreateEnum
    );

NTSTATUS
IopOpenCurrentHwProfileDeviceInstanceKey(
    OUT PHANDLE Handle,
    IN  PUNICODE_STRING ServiceKeyName,
    IN  ULONG Instance,
    IN  ACCESS_MASK DesiredAccess,
    IN  BOOLEAN Create
    );

NTSTATUS
IopGetDeviceInstanceCsConfigFlags(
    IN PUNICODE_STRING DeviceInstance,
    OUT PULONG CsConfigFlags
    );

NTSTATUS
PipGetServiceInstanceCsConfigFlags(
    IN PUNICODE_STRING ServiceKeyName,
    IN ULONG Instance,
    OUT PULONG CsConfigFlags
    );

NTSTATUS
PipApplyFunctionToSubKeys(
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Flags,
    IN PIOP_SUBKEY_CALLBACK_ROUTINE SubKeyCallbackRoutine,
    IN OUT PVOID Context
    );

NTSTATUS
PipRegMultiSzToUnicodeStrings(
    IN PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    IN PUNICODE_STRING *UnicodeStringList,
    OUT PULONG UnicodeStringCount
    );


NTSTATUS
PipApplyFunctionToServiceInstances(
    IN HANDLE ServiceKeyHandle OPTIONAL,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN IgnoreNonCriticalErrors,
    IN PIOP_SUBKEY_CALLBACK_ROUTINE DevInstCallbackRoutine,
    IN OUT PVOID Context,
    OUT PULONG ServiceInstanceOrdinal OPTIONAL
    );

VOID
PipFreeUnicodeStringList(
    IN PUNICODE_STRING UnicodeStringList,
    IN ULONG StringCount
    );

NTSTATUS
PipReadDeviceConfiguration(
    IN HANDLE Handle,
    IN ULONG Flags,
    OUT PCM_RESOURCE_LIST *CmResource,
    OUT PULONG Length
    );

BOOLEAN
PipIsFirmwareMapperDevicePresent(
    IN HANDLE KeyHandle
    );

#define PiInitializeEngineLock() \
    ExInitializeResourceLite(&PiEngineLock)

typedef enum {

    PPL_SIMPLE_READ,
    PPL_TREEOP_ALLOW_READS,
    PPL_TREEOP_BLOCK_READS,
    PPL_TREEOP_BLOCK_READS_FROM_ALLOW

} PNP_LOCK_LEVEL;

VOID
PpDevNodeLockTree(
    IN  PNP_LOCK_LEVEL  LockLevel
    );

VOID
PpDevNodeUnlockTree(
    IN  PNP_LOCK_LEVEL  LockLevel
    );

#if DBG
VOID
PpDevNodeAssertLockLevel(
    IN  PNP_LOCK_LEVEL  LockLevel,
    IN  PCSTR           File,
    IN  ULONG           Line
    );

#define PPDEVNODE_ASSERT_LOCK_HELD(Level) \
    PpDevNodeAssertLockLevel(Level, __FILE__, __LINE__)

#else
#define PPDEVNODE_ASSERT_LOCK_HELD(Level)
#endif

VOID
PpDevNodeInsertIntoTree(
    IN PDEVICE_NODE     ParentNode,
    IN PDEVICE_NODE     DeviceNode
    );

VOID
PpDevNodeRemoveFromTree(
    IN PDEVICE_NODE     DeviceNode
    );

NTSTATUS
PipAllocateDeviceNode(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PDEVICE_NODE *DeviceNode
    );

NTSTATUS
PipForAllDeviceNodes(
    IN PENUM_CALLBACK Callback,
    IN PVOID Context
    );

NTSTATUS
PipForDeviceNodeSubtree(
    IN PDEVICE_NODE     DeviceNode,
    IN PENUM_CALLBACK   Callback,
    IN PVOID            Context
    );

ULONG
IopDetermineResourceListSize(
    IN PCM_RESOURCE_LIST ResourceList
    );

PDEVICE_OBJECT
IopDeviceObjectFromDeviceInstance(
    IN PUNICODE_STRING  DeviceInstance
    );

NTSTATUS
IopMapDeviceObjectToDeviceInstance(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PUNICODE_STRING  DeviceInstance
    );

NTSTATUS
IopDeviceObjectToDeviceInstance(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHANDLE DeviceInstanceHandle,
    IN  ACCESS_MASK DesiredAccess
    );

BOOLEAN
IopIsDeviceInstanceEnabled(
    IN HANDLE DeviceInstanceHandle,
    IN PUNICODE_STRING DeviceInstance,
    IN BOOLEAN DisableIfEnabled
    );

BOOLEAN
IopProcessAssignResources(
   IN PDEVICE_NODE DeviceNode,
   IN BOOLEAN Reallocation,
   OUT PBOOLEAN RebalancePerformed
   );

NTSTATUS
IopStartDevice (
    IN PDEVICE_OBJECT TargetDevice
    );

NTSTATUS
IopEjectDevice(
    IN PDEVICE_OBJECT DeviceObject,
    PPENDING_RELATIONS_LIST_ENTRY PendingEntry
    );

NTSTATUS
IopRemoveDevice(
    IN PDEVICE_OBJECT TargetDevice,
    IN ULONG IrpMinorCode
    );

NTSTATUS
IopQueryDeviceRelations(
    IN DEVICE_RELATION_TYPE Relations,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Synchronous,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
IopQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PPNP_DEVICE_STATE DeviceState
    );

NTSTATUS
PipForAllChildDeviceNodes(
    IN PDEVICE_NODE Parent,
    IN PENUM_CALLBACK Callback,
    IN PVOID Context
    );

NTSTATUS
IopCleanupDeviceRegistryValues(
    IN PUNICODE_STRING InstancePath
    );

NTSTATUS
IopQueryDeviceResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ResourceType,
    OUT PVOID *Resource,
    OUT ULONG *Length
    );

NTSTATUS
IopGetDeviceResourcesFromRegistry (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ResourceType,
    IN ULONG Preference,
    OUT PVOID *Resource,
    OUT PULONG Length
    );

VOID
IopResourceRequirementsChanged(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN StopRequired
    );

NTSTATUS
IopReleaseDeviceResources(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN  ReserveResources
    );

NTSTATUS
IopPnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
PipProcessCriticalDevice(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopPnPDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IopPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
IopNewDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopFilterResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList,
    IN PCM_RESOURCE_LIST CmList,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *FilteredList,
    OUT PBOOLEAN ExactMatch
    );

NTSTATUS
IopMergeFilteredResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList1,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList2,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *MergedList
    );

NTSTATUS
IopMergeCmResourceLists (
    IN PCM_RESOURCE_LIST List1,
    IN PCM_RESOURCE_LIST List2,
    IN OUT PCM_RESOURCE_LIST *MergedList
    );

PIO_RESOURCE_REQUIREMENTS_LIST
IopCmResourcesToIoResources (
    IN ULONG SlotNumber,
    IN PCM_RESOURCE_LIST CmResourceList,
    IN ULONG Priority
    );

NTSTATUS
IopReportResourceListToPnp(
    IN PDRIVER_OBJECT DriverObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG ListSize,
    IN BOOLEAN Translated
    );

NTSTATUS
IopAllocateResources(
    IN PULONG DeviceCountP,
    IN OUT PIOP_RESOURCE_REQUEST *AssignTablePP,
    IN BOOLEAN Locked,
    IN BOOLEAN DoBootConfigs,
    OUT PBOOLEAN RebalancePerformed
    );

VOID
IopInitializeResourceMap (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
IopReallocateResources(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopWriteResourceList(
    IN HANDLE ResourceMapKey,
    IN PUNICODE_STRING ClassName,
    IN PUNICODE_STRING DriverName,
    IN PUNICODE_STRING DeviceName,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG ResourceListSize
    );

VOID
IopRemoveResourceListFromPnp(
    IN PLIST_ENTRY ResourceList
    );

NTSTATUS
IopWriteAllocatedResourcesToRegistry (
    IN PDEVICE_NODE DeviceNode,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG Length
    );

USHORT
PpInitGetGroupOrderIndex(
    IN HANDLE ServiceHandle
    );

VOID
IopDeleteLegacyKey(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IopOpenDeviceParametersSubkey(
    OUT HANDLE *ParamKeyHandle,
    IN  HANDLE ParentKeyHandle,
    IN  PUNICODE_STRING SubKeyString,
    IN  ACCESS_MASK DesiredAccess
    );

NTSTATUS
PipRequestDeviceAction(
    IN PDEVICE_OBJECT DeviceObject              OPTIONAL,
    IN DEVICE_REQUEST_TYPE RequestType,
    IN BOOLEAN ReorderingBarrier,
    IN ULONG_PTR Argument,
    IN PKEVENT CompletionEvent                  OPTIONAL,
    IN PNTSTATUS CompletionStatus               OPTIONAL
    );

VOID
PipRequestDeviceRemoval(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN      TreeDeletion,
    IN ULONG        Problem
    );

BOOLEAN
PipIsBeingRemovedSafely(
    IN  PDEVICE_NODE    DeviceNode
    );

NTSTATUS
IopRestartDeviceNode(
    IN PDEVICE_NODE DeviceNode
    );

VOID
PpResetProblemDevices(
    IN  PDEVICE_NODE    DeviceNode,
    IN  ULONG           Problem
    );

NTSTATUS
IopDeleteKeyRecursive(
    IN HANDLE SubKeyHandle,
    IN PWCHAR SubKeyName
    );

NTSTATUS
IopQueryPnpBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    OUT LPGUID InterfaceGuid           OPTIONAL,
    OUT INTERFACE_TYPE *InterfaceType  OPTIONAL,
    OUT ULONG *BusNumber               OPTIONAL
    );

NTSTATUS
IopQueryLegacyBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    OUT LPGUID InterfaceGuid           OPTIONAL,
    OUT INTERFACE_TYPE *InterfaceType  OPTIONAL,
    OUT ULONG *BusNumber               OPTIONAL
    );

NTSTATUS
IopGetRootDevices (
    PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
IopBuildRemovalRelationList(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    OUT PNP_VETO_TYPE                  *VetoType,
    OUT PUNICODE_STRING                 VetoName,
    OUT PRELATION_LIST                 *RelationsList
    );

NTSTATUS
IopDeleteLockedDeviceNodes(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PRELATION_LIST                  RelationsList,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN  BOOLEAN                         ProcessIndirectDescendants,
    IN  ULONG                           Problem,
    OUT PNP_VETO_TYPE                  *VetoType                    OPTIONAL,
    OUT PUNICODE_STRING                 VetoName                    OPTIONAL
    );

VOID
IopUnlinkDeviceRemovalRelations(
    IN      PDEVICE_OBJECT          RemovedDeviceObject,
    IN OUT  PRELATION_LIST          RelationsList,
    IN      UNLOCK_UNLINK_ACTION    UnlinkAction
    );

NTSTATUS
IopInvalidateRelationsInList(
    IN  PRELATION_LIST              RelationsList,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE OperationCode,
    IN  BOOLEAN                     OnlyIndirectDescendants,
    IN  BOOLEAN                     RestartDevNode
    );

BOOLEAN
IopQueuePendingEject(
    PPENDING_RELATIONS_LIST_ENTRY Entry
    );

VOID
IopProcessCompletedEject(
    IN PVOID Context
    );

VOID
IopQueuePendingSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRELATION_LIST List,
    IN ULONG Problem
    );

NTSTATUS
IopUnloadAttachedDriver(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
IopIsAnyDeviceInstanceEnabled(
    IN PUNICODE_STRING ServiceKeyName,
    IN HANDLE ServiceHandle,
    IN BOOLEAN LegacyIncluded
    );

NTSTATUS
IopQueryResourceHandlerInterface(
    IN RESOURCE_HANDLER_TYPE HandlerType,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR ResourceType,
    IN OUT PVOID *Interface
    );

NTSTATUS
IopQueryReconfiguration(
    IN UCHAR Request,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopLegacyResourceAllocation (
    IN ARBITER_REQUEST_SOURCE AllocationType,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources OPTIONAL
    );

NTSTATUS
IoReportResourceUsageInternal(
    IN ARBITER_REQUEST_SOURCE AllocationType,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    );

NTSTATUS
IopDuplicateDetection (
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_NODE *DeviceNode
    );

#if 0
NTSTATUS
IopTranslateResourceList(
    IN PDEVICE_NODE DeviceNode   OPTIONAL,
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PCM_RESOURCE_LIST *TranslatedList
    );
#endif

NTSTATUS
PipLoadBootFilterDriver(
    IN PUNICODE_STRING DriverName,
    IN ULONG GroupIndex,
    OUT PDRIVER_OBJECT *LoadedFilter
    );

NTSTATUS
IopQueryAndSaveDeviceNodeCapabilities (
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopSaveDeviceCapabilities (
    IN PDEVICE_NODE DeviceNode,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
PipQueryDeviceCapabilities(
    IN PDEVICE_NODE DeviceNode,
    OUT PDEVICE_CAPABILITIES Capabilities
    );

VOID
IopIncDisableableDepends(
    IN OUT PDEVICE_NODE DeviceNode
    );

VOID
IopDecDisableableDepends(
    IN OUT PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopQueryDockRemovalInterface(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PDOCK_INTERFACE *DockInterface
    );

#ifndef FIELD_SIZE
#define FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

#define IopDeviceNodeFlagsToCapabilities(DeviceNode) \
     ((PDEVICE_CAPABILITIES) (((PUCHAR) (&(DeviceNode)->CapabilityFlags)) - \
                              FIELD_OFFSET(DEVICE_CAPABILITIES, Version) - \
                              FIELD_SIZE(DEVICE_CAPABILITIES, Version)))

//
// BOOT allocation related declarations.
//

typedef
NTSTATUS
(*PIO_ALLOCATE_BOOT_RESOURCES_ROUTINE) (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    );

NTSTATUS
IopAllocateBootResources (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    );

NTSTATUS
IopReportBootResources (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    );

NTSTATUS
IopAllocateLegacyBootResources (
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber
    );

extern PIO_ALLOCATE_BOOT_RESOURCES_ROUTINE IopAllocateBootResourcesRoutine;

//
// Legacy Bus information related declarations.
//

extern LIST_ENTRY  IopLegacyBusInformationTable[];

VOID
IopInsertLegacyBusDeviceNode (
    IN PDEVICE_NODE BusDeviceNode,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber
    );

#define IopRemoveLegacyBusDeviceNode(d) RemoveEntryList(&((PDEVICE_NODE)d)->LegacyBusListEntry)

//
// Conflict detection declarations
//

NTSTATUS
IopQueryConflictList(
    PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN      PCM_RESOURCE_LIST               ResourceList,
    IN      ULONG                           ResourceListSize,
    OUT     PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN      ULONG                           ConflictListSize,
    IN      ULONG                           Flags
    );

//
// Firmware mapper external declarations.
//

VOID
MapperProcessFirmwareTree(
    IN BOOLEAN OnlyProcessSerialPorts
    );

VOID
MapperConstructRootEnumTree(
    IN BOOLEAN CreatePhantomDevices
    );

VOID
MapperFreeList(
    VOID
    );

NTSTATUS
EisaBuildEisaDeviceNode(
    VOID
    );

VOID
MapperPhantomizeDetectedComPorts(
    VOID
    );

//
// General utility macros
//

//
// This macros calculates the size in bytes of a constant string
//
//  ULONG
//  IopConstStringSize(
//      IN CONST PWSTR String
//      );
//

#define IopConstStringSize(String)          ( sizeof(String) - sizeof(UNICODE_NULL) )

//
// This macros calculates the number of characters of a constant string
//
//  ULONG
//  IopConstStringLength(
//      IN CONST PWSTR String
//      );
//

#define IopConstStringLength(String)        ( ( sizeof(String) - sizeof(UNICODE_NULL) ) / sizeof(WCHAR) )

//
// Kernel mode notification
//

//
// This macros maps a guid to a hash value based on the number of hash
// buckets we are using.  It does this by treating the  guid as an array of
// 4 ULONGs, suming them and MOD by the number of hash buckets we are using.
//
//  ULONG
//  IopHashGuid(
//      LPGUID Guid
//      );
//

#define IopHashGuid(_Guid) \
            ( ( ((PULONG)_Guid)[0] + ((PULONG)_Guid)[1] + ((PULONG)_Guid)[2] \
                + ((PULONG)_Guid)[3]) % NOTIFY_DEVICE_CLASS_HASH_BUCKETS)



//  This macros abstracts
//
//  VOID
//  IopAcquireNotifyLock(
//      PFAST_MUTEX Lock
//      )

#define IopAcquireNotifyLock(Lock)     ExAcquireFastMutex(Lock);

/*
VOID
IopReleaseNotifyLock(
    PFAST_MUTEX Lock
    )
*/
#define IopReleaseNotifyLock(Lock)     ExReleaseFastMutex(Lock);


//  BOOLEAN
//  IopCompareGuid(
//      IN LPGUID guid1,
//      IN LPGUID guid2
//      );

#define IopCompareGuid(g1, g2)  ( (g1) == (g2) \
                                    ? TRUE \
                                    : RtlCompareMemory( (g1), (g2), sizeof(GUID) ) == sizeof(GUID) \
                                    )

VOID
IopInitializePlugPlayNotification(
    VOID
    );

NTSTATUS
IopNotifySetupDeviceArrival(
        PDEVICE_OBJECT PhysicalDeviceObject,    // PDO of the device
        HANDLE EnumEntryKey,                    // Handle into the enum branch of the registry for this device
        BOOLEAN InstallDriver                   // Should setup attempt to install a driver
);

NTSTATUS
IopRequestHwProfileChangeNotification(
    IN   LPGUID                      EventGuid,
    IN   PROFILE_NOTIFICATION_TIME   NotificationTime,
    OUT  PPNP_VETO_TYPE              VetoType           OPTIONAL,
    OUT  PUNICODE_STRING             VetoName           OPTIONAL
    );

NTSTATUS
IopNotifyTargetDeviceChange(
    IN  LPCGUID                             EventGuid,
    IN  PDEVICE_OBJECT                      DeviceObject,
    IN  PTARGET_DEVICE_CUSTOM_NOTIFICATION  NotificationStructure   OPTIONAL,
    OUT PDRIVER_OBJECT                     *VetoingDriver
    );

NTSTATUS
IopGetRelatedTargetDevice(
    IN PFILE_OBJECT FileObject,
    OUT PDEVICE_NODE *DeviceNode
    );

NTSTATUS
IopNotifyDeviceClassChange(
    LPGUID EventGuid,
    LPGUID ClassGuid,
    PUNICODE_STRING SymbolicLinkName
    );

NTSTATUS
IopRegisterDeviceInterface(
    IN PUNICODE_STRING DeviceInstanceName,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    IN BOOLEAN UserModeFormat,
    OUT PUNICODE_STRING SymbolicLinkName
    );

NTSTATUS
IopUnregisterDeviceInterface(
    IN PUNICODE_STRING SymbolicLinkName
    );

NTSTATUS
IopRemoveDeviceInterfaces(
    IN PUNICODE_STRING DeviceInstancePath
    );

NTSTATUS
IopDisableDeviceInterfaces(
    IN PUNICODE_STRING DeviceInstancePath
    );

NTSTATUS
IopGetDeviceInterfaces(
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING DevicePath   OPTIONAL,
    IN ULONG Flags,
    IN BOOLEAN UserModeFormat,
    OUT PWSTR *SymbolicLinkList,
    OUT PULONG SymbolicLinkListSize OPTIONAL
    );

NTSTATUS
IopDoDeferredSetInterfaceState(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopProcessSetInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable,
    IN BOOLEAN DeferNotStarted
    );

NTSTATUS
IopReplaceSeperatorWithPound(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
IopNotifyHwProfileChange(
    IN  LPGUID           EventGuid,
    OUT PPNP_VETO_TYPE   VetoType    OPTIONAL,
    OUT PUNICODE_STRING  VetoName    OPTIONAL
    );

VOID
IopUncacheInterfaceInformation(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// Notify entry header - all notify entries have these
//

typedef struct _NOTIFY_ENTRY_HEADER {

    //
    // List Entry structure
    //

    LIST_ENTRY ListEntry;

    //
    // Notification event category for this notification entry.
    //

    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;

    //
    // SessionId.
    //
    ULONG SessionId;

    //
    // Session space object to attach to for sending notification.
    //
    PVOID OpaqueSession;

    //
    // Callback routine passed in at registration
    //

    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;

    //
    // Context passed in at registration
    //

    PVOID Context;

    //
    // Driver object of the driver that registered for notifications.  Required
    // so we can dereference it when it unregisters
    //

    PDRIVER_OBJECT DriverObject;

    //
    // RefCount is the number of outstanding pointers to the node and avoids
    // deletion while another notification is taking place
    //

    USHORT RefCount;

    //
    // Unregistered is set if this notification has been unregistered but cannot
    // be removed from the list because other entities are using it
    //

    BOOLEAN Unregistered;

    //
    // Lock is a pointer to the fast mutex which is used to synchronise access
    // to the list this node is a member of and is required so that the correct
    // list can be locked during IoUnregisterPlugPlayNotification.  If no locking
    // is required it is NULL
    //

    PFAST_MUTEX Lock;

} NOTIFY_ENTRY_HEADER, *PNOTIFY_ENTRY_HEADER;


//
// Data to store for each target device registration
//

typedef struct _TARGET_DEVICE_NOTIFY_ENTRY {

    //
    // Header entries
    //

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    PVOID OpaqueSession;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PFAST_MUTEX Lock;

    //
    // FileObject - the file object of the target device we are interested in
    //

    PFILE_OBJECT FileObject;

    //
    // PhysicalDeviceObject -- the PDO upon which this notification is hooked.
    // We need to keep this here, so we can dereference it when the refcount
    // on this notification entry drops to zero.
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

} TARGET_DEVICE_NOTIFY_ENTRY, *PTARGET_DEVICE_NOTIFY_ENTRY;

//
// Data to store for each device class registration
//

typedef struct _DEVICE_CLASS_NOTIFY_ENTRY {

    //
    // Header entries
    //

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    PVOID OpaqueSession;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PFAST_MUTEX Lock;

    //
    // ClassGuid - the guid of the device class we are interested in
    //

    GUID ClassGuid;

} DEVICE_CLASS_NOTIFY_ENTRY, *PDEVICE_CLASS_NOTIFY_ENTRY;

//
// Data to store for registration of the Reserved (ie setupdd.sys) variety
//

typedef struct _SETUP_NOTIFY_DATA {

    //
    // Header entries
    //

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    PVOID OpaqueSession;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PFAST_MUTEX Lock;

} SETUP_NOTIFY_DATA, *PSETUP_NOTIFY_DATA;


//
// Data to store for registration for HardwareProfileChange Events
//

typedef struct _HWPROFILE_NOTIFY_ENTRY {

    //
    // Header entries
    //

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    PVOID OpaqueSession;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PFAST_MUTEX Lock;

} HWPROFILE_NOTIFY_ENTRY, *PHWPROFILE_NOTIFY_ENTRY;

#define PNP_NOTIFICATION_VERSION            1
#define NOTIFY_DEVICE_CLASS_HASH_BUCKETS    13

//
// IopMaxDeviceNodeLevel - Level number of the DeviceNode deepest in the tree
//
extern ULONG       IopMaxDeviceNodeLevel;
extern ULONG       IoDeviceNodeTreeSequence;

//
// Global notification data
//

extern FAST_MUTEX IopDeviceClassNotifyLock;
extern LIST_ENTRY IopDeviceClassNotifyList[];
extern PSETUP_NOTIFY_DATA IopSetupNotifyData;
extern FAST_MUTEX IopTargetDeviceNotifyLock;
extern LIST_ENTRY IopProfileNotifyList;
extern FAST_MUTEX IopHwProfileNotifyLock;

VOID
IopProcessDeferredRegistrations(
    VOID
    );

//
// Generic buffer management
//

typedef struct _BUFFER_INFO {

    //
    // Buffer - pointer to the start of the buffer
    //

    PCHAR Buffer;

    //
    // Current - Pointer to the current position in the buffer
    //

    PCHAR Current;

    //
    // MaxSize - Maximum size of the buffer in bytes
    //

    ULONG MaxSize;

} BUFFER_INFO, *PBUFFER_INFO;

typedef struct _BUS_TYPE_GUID_LIST {

    //
    // Number of allocated guid slots in the table.
    //
    ULONG Count;

    //
    // Number of entries used so far.
    //
    FAST_MUTEX Lock;

    //
    // Array of bus type guids
    //
    GUID Guid[1];

} BUS_TYPE_GUID_LIST, *PBUS_TYPE_GUID_LIST;

//
// Arbiter entry points
//

NTSTATUS
IopPortInitialize(
    VOID
    );

NTSTATUS
IopMemInitialize(
    VOID
    );

NTSTATUS
IopIrqInitialize(
    VOID
    );

NTSTATUS
IopDmaInitialize(
    VOID
    );

NTSTATUS
IopBusNumberInitialize(
    VOID
    );

//
// Arbiter state
//

extern ARBITER_INSTANCE IopRootPortArbiter;
extern ARBITER_INSTANCE IopRootMemArbiter;
extern ARBITER_INSTANCE IopRootIrqArbiter;
extern ARBITER_INSTANCE IopRootDmaArbiter;
extern ARBITER_INSTANCE IopRootBusNumberArbiter;

//
// Buffer management routines.
//

NTSTATUS
IopAllocateBuffer(
    IN PBUFFER_INFO Info,
    IN ULONG Size
    );

NTSTATUS
IopResizeBuffer(
    IN PBUFFER_INFO Info,
    IN ULONG NewSize,
    IN BOOLEAN CopyContents
    );

VOID
IopFreeBuffer(
    IN PBUFFER_INFO Info
    );


//
// UnicodeString management routines.
//

NTSTATUS
IopAllocateUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT Length
    );

VOID
IopFreeAllocatedUnicodeString(
    PUNICODE_STRING String
    );

//
// Misc.
//

NTSTATUS
PnPBiosGetBiosInfo(
    OUT PVOID *BiosInfo,
    OUT ULONG *BiosInfoLength
    );

VOID
IopOrphanNotification (
    PDEVICE_NODE DeviceNode
    );

PVOID
PiAllocateCriticalMemory(
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     DeleteType,
    IN  POOL_TYPE                       PoolType,
    IN  SIZE_T                          Size,
    IN  ULONG                           Tag
    );

//
// Warm eject externs and function prototypes
//
extern KEVENT IopWarmEjectLock;
extern PDEVICE_OBJECT IopWarmEjectPdo;

NTSTATUS
IopWarmEjectDevice(
    IN PDEVICE_OBJECT      DeviceToEject,
    IN SYSTEM_POWER_STATE  LightestSleepState
    );

NTSTATUS
IopSystemControlDispatch(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    );

VOID
PiLockDeviceActionQueue(
    VOID
    );

VOID
PiUnlockDeviceActionQueue(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpirp.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    pnpirp.c

Abstract:

    This module contains IRP related routines.

Author:

    Shie-Lin Tzong (shielint) 13-Sept-1996

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#if DBG_SCOPE

#define PnpIrpStatusTracking(Status, IrpCode, Device)                    \
    if (PnpIrpMask & (1 << IrpCode)) {                                   \
        if (!NT_SUCCESS(Status) || Status == STATUS_PENDING) {           \
            DbgPrint(" ++ %s Driver ( %wZ ) return status %08lx\n",      \
                     IrpName[IrpCode],                                   \
                     &Device->DriverObject->DriverName,                  \
                     Status);                                            \
        }                                                                \
    }

ULONG PnpIrpMask;
PCHAR IrpName[] = {
    "IRP_MN_START_DEVICE - ",                 // 0x00
    "IRP_MN_QUERY_REMOVE_DEVICE - ",          // 0x01
    "IRP_MN_REMOVE_DEVICE - ",                // 0x02
    "IRP_MN_CANCEL_REMOVE_DEVICE - ",         // 0x03
    "IRP_MN_STOP_DEVICE - ",                  // 0x04
    "IRP_MN_QUERY_STOP_DEVICE - ",            // 0x05
    "IRP_MN_CANCEL_STOP_DEVICE - ",           // 0x06
    "IRP_MN_QUERY_DEVICE_RELATIONS - ",       // 0x07
    "IRP_MN_QUERY_INTERFACE - ",              // 0x08
    "IRP_MN_QUERY_CAPABILITIES - ",           // 0x09
    "IRP_MN_QUERY_RESOURCES - ",              // 0x0A
    "IRP_MN_QUERY_RESOURCE_REQUIREMENTS - ",  // 0x0B
    "IRP_MN_QUERY_DEVICE_TEXT - ",            // 0x0C
    "IRP_MN_FILTER_RESOURCE_REQUIREMENTS - ", // 0x0D
    "INVALID_IRP_CODE - ",                    //
    "IRP_MN_READ_CONFIG - ",                  // 0x0F
    "IRP_MN_WRITE_CONFIG - ",                 // 0x10
    "IRP_MN_EJECT - ",                        // 0x11
    "IRP_MN_SET_LOCK - ",                     // 0x12
    "IRP_MN_QUERY_ID - ",                     // 0x13
    "IRP_MN_QUERY_PNP_DEVICE_STATE - ",       // 0x14
    "IRP_MN_QUERY_BUS_INFORMATION - ",        // 0x15
    "IRP_MN_DEVICE_USAGE_NOTIFICATION - ",    // 0x16
    NULL
};
#else
#define PnpIrpStatusTracking(Status, IrpCode, Device)
#endif

//
// Internal definitions
//

typedef struct _DEVICE_COMPLETION_CONTEXT {
    PDEVICE_NODE DeviceNode;
    ERESOURCE_THREAD Thread;
    ULONG IrpMinorCode;
#if DBG
    PVOID Id;
#endif
} DEVICE_COMPLETION_CONTEXT, *PDEVICE_COMPLETION_CONTEXT;

typedef struct _LOCK_MOUNTABLE_DEVICE_CONTEXT{
    PDEVICE_OBJECT MountedDevice;
    PDEVICE_OBJECT FsDevice;
} LOCK_MOUNTABLE_DEVICE_CONTEXT, *PLOCK_MOUNTABLE_DEVICE_CONTEXT;

//
// Internal references
//

NTSTATUS
IopAsynchronousCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION TopStackLocation,
    IN PDEVICE_COMPLETION_CONTEXT CompletionContext,
    IN NTSTATUS (*CompletionRoutine)(PDEVICE_OBJECT, PIRP, PVOID)
    );

NTSTATUS
IopDeviceEjectComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
IopDeviceStartComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PDEVICE_OBJECT
IopFindMountableDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

PDEVICE_OBJECT
IopLockMountedDeviceForRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IrpMinorCode,
    OUT PLOCK_MOUNTABLE_DEVICE_CONTEXT Context
    );

VOID
IopUnlockMountedDeviceForRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IrpMinorCode,
    IN PLOCK_MOUNTABLE_DEVICE_CONTEXT Context
    );

NTSTATUS
IopFilterResourceRequirementsCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResReqList,
    OUT PVOID *Information
    );

//
// External reference
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopAsynchronousCall)
#pragma alloc_text(PAGE, IopSynchronousCall)
#pragma alloc_text(PAGE, IopStartDevice)
#pragma alloc_text(PAGE, IopEjectDevice)
#pragma alloc_text(PAGE, IopRemoveDevice)
//#pragma alloc_text(PAGE, IopQueryDeviceRelations)
#pragma alloc_text(PAGE, IopQueryDeviceResources)
#pragma alloc_text(PAGE, IopQueryDockRemovalInterface)
#pragma alloc_text(PAGE, IopQueryLegacyBusInformation)
#pragma alloc_text(PAGE, IopQueryPnpBusInformation)
#pragma alloc_text(PAGE, IopQueryResourceHandlerInterface)
#pragma alloc_text(PAGE, IopQueryReconfiguration)
#pragma alloc_text(PAGE, IopFindMountableDevice)
#pragma alloc_text(PAGE, IopFilterResourceRequirementsCall)
#pragma alloc_text(PAGE, IopQueryDeviceState)
#pragma alloc_text(PAGE, IopIncDisableableDepends)
#pragma alloc_text(PAGE, IopDecDisableableDepends)
#pragma alloc_text(PAGE, PpIrpQueryResourceRequirements)
#pragma alloc_text(PAGE, PpIrpQueryID)
#endif  // ALLOC_PRAGMA

#if 0
NTSTATUS
IopAsynchronousCall(
    IN PDEVICE_OBJECT TargetDevice,
    IN PIO_STACK_LOCATION TopStackLocation,
    IN PDEVICE_COMPLETION_CONTEXT CompletionContext,
    IN NTSTATUS (*CompletionRoutine)(PDEVICE_OBJECT, PIRP, PVOID)
    )

/*++

Routine Description:

    This function sends an  Asynchronous irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

    TopStackLocation - Supplies a pointer to the parameter block for the irp.

    CompletionContext -

    CompletionRoutine -

Return Value:

    NTSTATUS code.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDevice(TargetDevice);

    //
    // Allocate an I/O Request Packet (IRP) for this device removal operation.
    //

    irp = IoAllocateIrp( (CCHAR) (deviceObject->StackSize), FALSE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SPECIALIRP_WATERMARK_IRP(irp, IRP_SYSTEM_RESTRICTED);

    //
    // Initialize it to failure.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Fill in the IRP according to this request.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;
    irp->UserIosb = NULL;
    irp->UserEvent = NULL;

    //
    // Copy in the caller-supplied stack location contents
    //

    *irpSp = *TopStackLocation;
#if DBG
    CompletionContext->Id = irp;
#endif
    IoSetCompletionRoutine(irp,
                           CompletionRoutine,
                           CompletionContext,  /* Completion context */
                           TRUE,               /* Invoke on success  */
                           TRUE,               /* Invoke on error    */
                           TRUE                /* Invoke on cancel   */
                           );

    return IoCallDriver( deviceObject, irp );
}
#endif

NTSTATUS
IopSynchronousCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION TopStackLocation,
    OUT PULONG_PTR Information
    )

/*++

Routine Description:

    This function sends a synchronous irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

    TopStackLocation - Supplies a pointer to the parameter block for the irp.

    Information - Supplies a pointer to a variable to receive the returned
                  information of the irp.

Return Value:

    NTSTATUS code.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK statusBlock;
    KEVENT event;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDevice(DeviceObject);

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SPECIALIRP_WATERMARK_IRP(irp, IRP_SYSTEM_RESTRICTED);

    //
    // Initialize it to failure.
    //

    irp->IoStatus.Status = statusBlock.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = statusBlock.Information = 0;

    //
    // Set the pointer to the status block and initialized event.
    //

    KeInitializeEvent( &event,
                       SynchronizationEvent,
                       FALSE );

    irp->UserIosb = &statusBlock;
    irp->UserEvent = &event;

    //
    // Set the address of the current thread
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Queue this irp onto the current thread
    //

    IopQueueThreadIrp(irp);

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Copy in the caller-supplied stack location contents
    //

    *irpSp = *TopStackLocation;

    //
    // Call the driver
    //

    status = IoCallDriver(deviceObject, irp);

    PnpIrpStatusTracking(status, TopStackLocation->MinorFunction, deviceObject);

    //
    // If a driver returns STATUS_PENDING, we will wait for it to complete
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = statusBlock.Status;
    }

    if (Information != NULL) {
        *Information = statusBlock.Information;
    }

    return status;
}

NTSTATUS
IopStartDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function sends a start device irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the pointer to the device object of the device
                   being removed.

Return Value:

    NTSTATUS code.

--*/

{
    IO_STACK_LOCATION irpSp;
    PDEVICE_NODE deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    PDEVICE_COMPLETION_CONTEXT completionContext;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_START_DEVICE;

    //
    // Set the pointers for the raw and translated resource lists
    //

    irpSp.Parameters.StartDevice.AllocatedResources = deviceNode->ResourceList;
    irpSp.Parameters.StartDevice.AllocatedResourcesTranslated = deviceNode->ResourceListTranslated;

    status = IopSynchronousCall(DeviceObject, &irpSp, NULL);

    return status;
}

NTSTATUS
IopEjectDevice(
    IN      PDEVICE_OBJECT                  DeviceObject,
    IN OUT  PPENDING_RELATIONS_LIST_ENTRY   PendingEntry
    )

/*++

Routine Description:

    This function sends an eject device irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies a pointer to the device object of the device being
                   removed.

Return Value:

    NTSTATUS code.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PIRP irp;

    PAGED_CODE();

    if (PendingEntry->LightestSleepState != PowerSystemWorking) {

        //
        // We have to warm eject.
        //
        if (PendingEntry->DockInterface) {

            PendingEntry->DockInterface->ProfileDepartureSetMode(
                PendingEntry->DockInterface->Context,
                PDS_UPDATE_ON_EJECT
                );
        }

        PendingEntry->EjectIrp = NULL;

        InitializeListHead( &PendingEntry->Link );

        IopQueuePendingEject(PendingEntry);

        ExInitializeWorkItem( &PendingEntry->WorkItem,
                              IopProcessCompletedEject,
                              PendingEntry);

        ExQueueWorkItem( &PendingEntry->WorkItem, DelayedWorkQueue );
        return STATUS_SUCCESS;
    }

    if (PendingEntry->DockInterface) {

        //
        // Notify dock that now is a good time to update it's hardware profile.
        //
        PendingEntry->DockInterface->ProfileDepartureSetMode(
            PendingEntry->DockInterface->Context,
            PDS_UPDATE_ON_INTERFACE
            );

        PendingEntry->DockInterface->ProfileDepartureUpdate(
            PendingEntry->DockInterface->Context
            );

        if (PendingEntry->DisplaySafeRemovalDialog) {

            PpNotifyUserModeRemovalSafe(DeviceObject);
            PendingEntry->DisplaySafeRemovalDialog = FALSE;
        }
    }

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDeviceReference(DeviceObject);

    //
    // Allocate an I/O Request Packet (IRP) for this device removal operation.
    //

    irp = IoAllocateIrp( (CCHAR) (deviceObject->StackSize), FALSE );
    if (!irp) {

        PendingEntry->EjectIrp = NULL;

        InitializeListHead( &PendingEntry->Link );

        IopQueuePendingEject(PendingEntry);

        ExInitializeWorkItem( &PendingEntry->WorkItem,
                              IopProcessCompletedEject,
                              PendingEntry);

        ExQueueWorkItem( &PendingEntry->WorkItem, DelayedWorkQueue );

        ObDereferenceObject(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SPECIALIRP_WATERMARK_IRP(irp, IRP_SYSTEM_RESTRICTED);

    //
    // Initialize it to failure.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_EJECT;

    //
    // Fill in the IRP according to this request.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;
    irp->UserIosb = NULL;
    irp->UserEvent = NULL;

    PendingEntry->EjectIrp = irp;

    IopQueuePendingEject(PendingEntry);

    IoSetCompletionRoutine(irp,
                           IopDeviceEjectComplete,
                           PendingEntry,       /* Completion context */
                           TRUE,               /* Invoke on success  */
                           TRUE,               /* Invoke on error    */
                           TRUE                /* Invoke on cancel   */
                           );

    status = IoCallDriver( deviceObject, irp );

    ObDereferenceObject(deviceObject);
    return status;
}

NTSTATUS
IopDeviceEjectComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PPENDING_RELATIONS_LIST_ENTRY entry = (PPENDING_RELATIONS_LIST_ENTRY)Context;
    PIRP ejectIrp;

    UNREFERENCED_PARAMETER( DeviceObject );

    ejectIrp = InterlockedExchangePointer(&entry->EjectIrp, NULL);

    ASSERT(ejectIrp == NULL || ejectIrp == Irp);

    //
    // Queue a work item to finish up the eject.  We queue a work item because
    // we are probably running at dispatch level in some random context.
    //

    ExInitializeWorkItem( &entry->WorkItem,
                          IopProcessCompletedEject,
                          entry);

    ExQueueWorkItem( &entry->WorkItem, DelayedWorkQueue );

    IoFreeIrp( Irp );

    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
IopRemoveDevice (
    IN PDEVICE_OBJECT TargetDevice,
    IN ULONG IrpMinorCode
    )

/*++

Routine Description:

    This function sends a requested DeviceRemoval related irp to the top level device
    object which roots on TargetDevice.  If there is a VPB associated with the
    TargetDevice, the corresponding filesystem's VDO will be used.  Otherwise
    the irp will be sent directly to the target device/ or its assocated device
    object.

Parameters:

    TargetDevice - Supplies the device object of the device being removed.

    Operation - Specifies the operation requested.
        The following IRP codes are used with IRP_MJ_DEVICE_CHANGE for removing
        devices:
            IRP_MN_QUERY_REMOVE_DEVICE
            IRP_MN_CANCEL_REMOVE_DEVICE
            IRP_MN_REMOVE_DEVICE
            IRP_MN_EJECT
Return Value:

    NTSTATUS code.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;

    BOOLEAN isMountable = FALSE;
    PDEVICE_OBJECT mountedDevice;

    LOCK_MOUNTABLE_DEVICE_CONTEXT lockContext;

    PAGED_CODE();

    ASSERT(IrpMinorCode == IRP_MN_QUERY_REMOVE_DEVICE ||
           IrpMinorCode == IRP_MN_CANCEL_REMOVE_DEVICE ||
           IrpMinorCode == IRP_MN_REMOVE_DEVICE ||
           IrpMinorCode == IRP_MN_SURPRISE_REMOVAL ||
           IrpMinorCode == IRP_MN_EJECT);

    if (IrpMinorCode == IRP_MN_REMOVE_DEVICE ||
        IrpMinorCode == IRP_MN_QUERY_REMOVE_DEVICE) {
        IopUncacheInterfaceInformation(TargetDevice);
    }

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = (UCHAR)IrpMinorCode;

    //
    // Check to see if there's a VPB anywhere in the device stack.  If there
    // is then we'll have to lock the stack. This is to make sure that the VPB
    // does not go away while the operation is in the file system and that no
    // one new can mount on the device if the FS decides to bail out.
    //

    mountedDevice = IopFindMountableDevice(TargetDevice);

    if (mountedDevice != NULL) {

        //
        // This routine will cause any mount operations on the VPB to fail.
        // It will also release the VPB spinlock.
        //

        mountedDevice = IopLockMountedDeviceForRemove(TargetDevice,
                                                      IrpMinorCode,
                                                      &lockContext);

        isMountable = TRUE;

    } else {
        ASSERTMSG("Mass storage device does not have VPB - this is odd",
                  !((TargetDevice->Type == FILE_DEVICE_DISK) ||
                    (TargetDevice->Type == FILE_DEVICE_CD_ROM) ||
                    (TargetDevice->Type == FILE_DEVICE_TAPE) ||
                    (TargetDevice->Type == FILE_DEVICE_VIRTUAL_DISK)));

        mountedDevice = TargetDevice;
    }

    //
    // Make the call and return.
    //

    if (IrpMinorCode == IRP_MN_SURPRISE_REMOVAL || IrpMinorCode == IRP_MN_REMOVE_DEVICE) {
        //
        // if device was not disableable, we cleanup the tree
        // and debug-trace that we surprise-removed a non-disableable device
        //
        PDEVICE_NODE deviceNode = TargetDevice->DeviceObjectExtension->DeviceNode;

        if (deviceNode->UserFlags & DNUF_NOT_DISABLEABLE) {
            //
            // this device was marked as disableable, update the depends
            // before this device disappears
            // (by momentarily marking this node as disableable)
            //
            deviceNode->UserFlags &= ~DNUF_NOT_DISABLEABLE;
            IopDecDisableableDepends(deviceNode);
        }
    }

    status = IopSynchronousCall(mountedDevice, &irpSp, NULL);

    if (isMountable) {

        IopUnlockMountedDeviceForRemove(TargetDevice,
                                        IrpMinorCode,
                                        &lockContext);

        //
        // Successful query should follow up with invalidation of all volumes
        // which have been on this device but which are not currently mounted.
        //

        if ((IrpMinorCode == IRP_MN_QUERY_REMOVE_DEVICE || 
                IrpMinorCode == IRP_MN_SURPRISE_REMOVAL) && 
            NT_SUCCESS(status)) {

            status = IopInvalidateVolumesForDevice(TargetDevice);
        }
    }

    if (IrpMinorCode == IRP_MN_REMOVE_DEVICE) {
        ((PDEVICE_NODE)TargetDevice->DeviceObjectExtension->DeviceNode)->Flags &=
            ~(DNF_LEGACY_DRIVER | DNF_REENUMERATE);
    }

    return status;
}


PDEVICE_OBJECT
IopLockMountedDeviceForRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IrpMinorCode,
    OUT PLOCK_MOUNTABLE_DEVICE_CONTEXT Context
    )

/*++

Routine Description:

    This routine will scan up the device stack and mark each unmounted VPB it
    finds with the VPB_REMOVE_PENDING bit (or clear it in the case of cancel)
    and increment (or decrement in the case of cancel) the reference count
    in the VPB.  This is to ensure that no new file system can get mounted on
    the device stack while the remove operation is in place.

    The search will terminate once all the attached device objects have been
    marked, or once a mounted device object has been marked.

Arguments:

    DeviceObject - the PDO we are attempting to remove

    IrpMinorCode - the remove-type operation we are going to perform

    Context - a context block which must be passed in to the unlock operation

Return Value:

    A pointer to the device object stack which the remove request should be
    sent to.  If a mounted file system was found, this will be the lowest
    file system device object in the mounted stack.  Otherwise this will be
    the PDO which was passed in.

--*/

{
    PVPB vpb;

    PDEVICE_OBJECT device = DeviceObject;
    PDEVICE_OBJECT fsDevice = NULL;

    KIRQL oldIrql;

    RtlZeroMemory(Context, sizeof(LOCK_MOUNTABLE_DEVICE_CONTEXT));
    Context->MountedDevice = DeviceObject;

    do {

        //
        // Walk up each device object in the stack.  For each one, if a VPB
        // exists, grab the database resource exclusive followed by the
        // device lock.  Then acquire the Vpb spinlock and perform the
        // appropriate magic on the device object.
        //

        //
        // NOTE - Its unfortunate that the locking order includes grabbing
        // the device specific lock first followed by the global lock.
        //

        if(device->Vpb != NULL) {

            //
            // Grab the device lock.  This will ensure that there are no mount
            // or verify operations in progress.
            //

            KeWaitForSingleObject(&(device->DeviceLock),
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            //
            // Now set the remove pending flag, which will prevent new mounts
            // from occuring on this stack once the current (if existant)
            // filesystem dismounts. Filesystems will preserve the flag across
            // vpb swaps.
            //

            IoAcquireVpbSpinLock(&oldIrql);

            vpb = device->Vpb;

            ASSERT(vpb != NULL);

            switch(IrpMinorCode) {

                case IRP_MN_QUERY_REMOVE_DEVICE:
                case IRP_MN_SURPRISE_REMOVAL:
                case IRP_MN_REMOVE_DEVICE: {

                    vpb->Flags |= VPB_REMOVE_PENDING;
                    break;
                }

                case IRP_MN_CANCEL_REMOVE_DEVICE: {

                    vpb->Flags &= ~VPB_REMOVE_PENDING;
                    break;
                }

                default:
                    break;
            }

            //
            // Note the device object that has the filesystem stack attached.
            // We must remember the vpb we referenced that had the fs because
            // it may be swapped off of the storage device during a dismount
            // operation.
            //

            if(vpb->Flags & VPB_MOUNTED) {

                Context->MountedDevice = device;
                fsDevice = vpb->DeviceObject;
            }

            Context->FsDevice = fsDevice;

            IoReleaseVpbSpinLock(oldIrql);

            //
            // Bump the fs device handle count. This prevent the filesystem filter stack 
            // from being torn down while a PNP IRP is in progress.
            //

            if (fsDevice) {
                IopIncrementDeviceObjectHandleCount(fsDevice);
            }

            KeSetEvent(&(device->DeviceLock), IO_NO_INCREMENT, FALSE);

            //
            // Stop if we hit a device with a mounted filesystem.
            //

            if (NULL != fsDevice) {

                //
                // We found and setup a mounted device.  Time to return.
                //

                break;
            }
        }

        oldIrql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
        device = device->AttachedDevice;
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, oldIrql );

    } while (device != NULL);

    if(fsDevice != NULL) {

        return fsDevice;
    }

    return Context->MountedDevice;
}

VOID
IopUnlockMountedDeviceForRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IrpMinorCode,
    IN PLOCK_MOUNTABLE_DEVICE_CONTEXT Context
    )
{
    PDEVICE_OBJECT device = DeviceObject;

    do {

        KIRQL oldI