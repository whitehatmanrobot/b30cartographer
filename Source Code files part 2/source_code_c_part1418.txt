KEY(hKey);
        return (dwError==ERROR_SUCCESS);
    }
    return FALSE;
}



DWORD
CreateMimeExclusionTableForCache()
{
    INET_ASSERT(lpvrgszMimeExclusionTable == NULL);
    INET_ASSERT(vszMimeExclusionList == NULL);

    return (CreateTableFromRegistryList("MimeExclusionListForCache",
                                        &vszMimeExclusionList,
                                        &lpvrgszMimeExclusionTable,
                                        &lpvrgdwMimeExclusionTableOfSizes,
                                        &vdwMimeExclusionTableCount));
}

VOID
DestroyMimeExclusionTableForCache()
{
    if (lpvrgszMimeExclusionTable) {

        INET_ASSERT(vszMimeExclusionList != NULL);

        FREE_MEMORY(lpvrgszMimeExclusionTable);
        FREE_MEMORY(lpvrgdwMimeExclusionTableOfSizes);
        FREE_MEMORY(vszMimeExclusionList);

        lpvrgszMimeExclusionTable = NULL;
        vszMimeExclusionList = NULL;
        vdwMimeExclusionTableCount = 0;
    }
}


DWORD
CreateHeaderExclusionTableForCache()
{
    INET_ASSERT(lpvrgszHeaderExclusionTable == NULL);
    INET_ASSERT(vszHeaderExclusionList == NULL);

    return (CreateTableFromRegistryList("HeaderExclusionListForCache",
                                        &vszHeaderExclusionList,
                                        &lpvrgszHeaderExclusionTable,
                                        NULL,
                                        &vdwHeaderExclusionTableCount));

}

VOID
DestroyHeaderExclusionTableForCache()
{
    if (lpvrgszHeaderExclusionTable) {

        INET_ASSERT(vszHeaderExclusionList != NULL);

        FREE_MEMORY(lpvrgszHeaderExclusionTable);
        FREE_MEMORY(vszHeaderExclusionList);

        lpvrgszHeaderExclusionTable = NULL;
        vszHeaderExclusionList = NULL;
        vdwHeaderExclusionTableCount = 0;
    }
}


PRIVATE
DWORD
CreateTableFromRegistryList(
    IN LPSTR   lpszParameter,       // wininet registry parameter
    OUT LPSTR   *lplpszList,        // Delimited List
    OUT LPSTR   **lplprgszTable,    // Pointer table pointing into the list
    OUT DWORD   **lplpdwTableSizes, // Pointer to table containing sizes of string elements
    OUT LPDWORD lpdwCount           // count of elements in the table
    )

/*++

Routine Description:

    Creates argv array from registry string

Arguments:

    lpszParameter       - wininet registry parameter

    lplpszList          - delimited List

    lplprgszTable       - pointer table pointing into the list

    lplpdwTableSizes    - pointer to table containing sizes of string elements

    lpdwCount           - count of elements in the table

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                  ERROR_INVALID_PARAMETER

--*/

{
    INET_ASSERT(lplpszList != NULL);
    INET_ASSERT(lplprgszTable != NULL);

    DWORD dwLen = 0;
    DWORD error;

    //
    // let us find out the length of this string
    //

    error = InternetReadRegistryString(lpszParameter, NULL, &dwLen);
    if ((error != ERROR_SUCCESS) && (error != ERROR_MORE_DATA)) {
        return error;
    }

    dwLen += 2; // for good measure
    if (!(*lplpszList = (LPSTR)ALLOCATE_MEMORY(LPTR, dwLen))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    error = InternetReadRegistryString(lpszParameter, *lplpszList, &dwLen);

    //
    // if it fails now, we need to bailout
    //

    if (error != ERROR_SUCCESS) {
        goto bailout;
    }

    //
    // now let us see how many elements are there in this list
    //

    error = CreateStringArrayFromDelimitedList(*lplpszList,
                                               vszDelimiters,
                                               NULL,
                                               lpdwCount
                                               );
    if (!*lpdwCount) {
        error = ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    //
    // let us allocate an array of pointers
    //

    if (!(*lplprgszTable = (LPSTR *)ALLOCATE_MEMORY(LPTR, *lpdwCount * sizeof(LPSTR)))) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto bailout;
    }

    error = CreateStringArrayFromDelimitedList(*lplpszList,
                                               vszDelimiters,
                                               *lplprgszTable,
                                               lpdwCount
                                               );

    INET_ASSERT(*lpdwCount);

    if ((lplpdwTableSizes == NULL) || (error != ERROR_SUCCESS)) {
        goto bailout;
    }

    *lplpdwTableSizes = (LPDWORD)ALLOCATE_MEMORY(LPTR, (sizeof(DWORD)*(*lpdwCount)));

    if (*lplpdwTableSizes == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto bailout;
    }

    DWORD i;

    for (i = 0; i < *lpdwCount; i++) {

        INET_ASSERT((*lplprgszTable)[i]);

        (*lplpdwTableSizes)[i] = lstrlen((*lplprgszTable)[i]);
    }

bailout:

    if (error != ERROR_SUCCESS) {
        if (*lplpszList) {
            FREE_MEMORY(*lplpszList);
            *lplpszList = NULL;
        }
        if (*lplprgszTable) {
            FREE_MEMORY(*lplprgszTable);
            *lplprgszTable = NULL;
        }
    }

    return error;
}


PRIVATE
DWORD
CreateStringArrayFromDelimitedList(
    IN  LPSTR   lpszDelimitedList,
    IN  LPSTR   lpszDelimiters,
    IN  LPSTR   *lprgszStringArray,
    OUT LPDWORD lpdwCount
    )
{

    LPSTR   lpStart, lpEnd, lpTmp;
    DWORD   dwError = ERROR_INVALID_PARAMETER;

    *lpdwCount = 0;

    lpStart = lpszDelimitedList;
    lpEnd = lpStart + strlen(lpszDelimitedList);    // points to null

    // strip out the trailing spaces
    for(;(lpStart<lpEnd);--lpEnd) {
        int c;
        c = (int)*(lpEnd-1);
        if (!isspace(c)) {
            *lpEnd = '\0';
            break;
        }
    }

    // bailout if this is an empty string
    if (lpStart == lpEnd) {
        goto done;
    }

    dwError = ERROR_SUCCESS;

    for (lpTmp = lpStart;(lpTmp && (lpEnd > lpStart)); lpStart = lpTmp+1) {
        int c;

        lpTmp = lpStart;

        c = (int)*lpStart;
        if (isspace(c)) {
             continue;
        }

        // when we come here there is a non space character
        INET_ASSERT(!isspace(*lpStart));

        lpTmp = strpbrk(lpStart, lpszDelimiters);

        if (lprgszStringArray) {

            if (lpTmp) {
                *lpTmp = 0; // create a string out of it
            }
            // plug the start pointer into the array
            lprgszStringArray[*lpdwCount] = lpStart;
        }

        ++*lpdwCount;

    }
done:
    return (dwError);
}

#if INET_DEBUG

typedef struct {
    LIST_ENTRY entry;
    HKEY hkey;
    char * file;
    int line;
    char name[1];
} DBGREGKEYINFO;

SERIALIZED_LIST DbgRegKeyList;

VOID DbgRegKey_Init(VOID) {
    InitializeSerializedList(&DbgRegKeyList);
}

VOID DbgRegKey_Terminate(VOID) {
    TerminateSerializedList(&DbgRegKeyList);
}

void regkey_add(const char * name, HKEY hkey, char * file, int line) {

    if (!name) {
        name = "";
    }

    int len = lstrlen(name);
    DBGREGKEYINFO * p = (DBGREGKEYINFO *)ALLOCATE_FIXED_MEMORY(sizeof(DBGREGKEYINFO) + len);

    if (p) {
//dprintf("Wininet.DbgRegKey: adding %q\n", name);
        memcpy(p->name, name, len + 1);
        p->line = line;
        p->file = file;
        p->hkey = hkey;
        InsertAtHeadOfSerializedList(&DbgRegKeyList, &p->entry);
    }
}

void regkey_remove(HKEY hkey) {
    LockSerializedList(&DbgRegKeyList);

    DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

    while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
        if (p->hkey == hkey) {
            RemoveFromSerializedList(&DbgRegKeyList, (PLIST_ENTRY)p);
//dprintf("Wininet.DbgRegKey: removing %q\n", p->name);
            FREE_MEMORY(p);
            break;
        }
        p = (DBGREGKEYINFO *)p->entry.Flink;
    }
    UnlockSerializedList(&DbgRegKeyList);
}

char * regkey_name(HKEY hkey, const char * subname) {
    switch ((INT_PTR)hkey) {
    case (INT_PTR)HKEY_CLASSES_ROOT:
        return NEW_STRING("HKEY_CLASSES_ROOT");

    case (INT_PTR)HKEY_CURRENT_USER:
        return NEW_STRING("HKEY_CURRENT_USER");

    case (INT_PTR)HKEY_LOCAL_MACHINE:
        return NEW_STRING("HKEY_LOCAL_MACHINE");

    case (INT_PTR)HKEY_USERS:
        return NEW_STRING("HKEY_USERS");

    case (INT_PTR)HKEY_PERFORMANCE_DATA:
        return NEW_STRING("HKEY_PERFORMANCE_DATA");

    case (INT_PTR)HKEY_CURRENT_CONFIG:
        return NEW_STRING("HKEY_CURRENT_CONFIG");

    case (INT_PTR)HKEY_DYN_DATA:
        return NEW_STRING("HKEY_DYN_DATA");
    }

    char * name = NULL;

    LockSerializedList(&DbgRegKeyList);

    DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

    while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
        if (p->hkey == hkey) {

            int len = lstrlen(p->name);
            int slen = lstrlen(subname);

            name = (char *)ALLOCATE_FIXED_MEMORY(len + 1 + slen + 1);
            if (name) {
                memcpy(name, p->name, len);
                name[len] = '\\';
                memcpy(name + len + 1, subname, slen + 1);
            }
            break;
        }
        p = (DBGREGKEYINFO *)p->entry.Flink;
    }
    UnlockSerializedList(&DbgRegKeyList);

    return name;
}

void regkey_freename(char * name) {
    if (name) {
        FREE_MEMORY(name);
    }
}

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpszSubKey);
    LONG rc = RegOpenKey(hKey, lpszSubKey, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCloseKey(
    IN HKEY hKey
    )
{
    LONG rc = RegCloseKey(hKey);

    if (rc == 0) {
        regkey_remove(hKey);
    }
    return rc;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\strtodbl.c ===
#ifndef _CRTBLD
#define _CRTBLD
#endif

#include <windows.h>
#include <shlwapi.h>

/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/

double __cdecl StrToDbl(const char *str, char **strStop)
{
    double dbl = 0;
    char *psz;
    int iMult = 1;
    int iKB = 1;
    int iVal = 0;
    BOOL bHaveDot = FALSE;

    psz = (char*)str;
    while(*psz)
    {
        if((*psz >= '0') && (*psz <= '9'))
        {
            iVal = (iVal * 10) + (*psz - '0');
            if(bHaveDot)
                iMult *= 10;
        }
        else if((*psz == '.') && !bHaveDot)
        {
            bHaveDot = TRUE;
        }
        else if((*psz == 'k') || (*psz == 'K'))
        {
            iKB = 1024;
            psz++;
            break;
        }
        else
        {
            break;
        }
        psz++;
    }
    *strStop = psz;

    dbl = (double) (iVal * iKB) / iMult;
    
    return(dbl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\readhtml.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    readhtml.cxx

Abstract:

    Contains functions for returning files and directory listings (gopher and
    FTP) as HTML documents

    Contents:
        ReadHtmlUrlData
        QueryHtmlDataAvailable
        (MakeHtmlDirEntry)

Author:

    Richard L Firth (rfirth) 23-Jun-1995

Environment:

    Win32 user-mode

Revision History:

    23-Jun-1995 rfirth
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

//
// HTML encapsulation strings - we generate HTML documents using the following
// strings. Although we don't need carriage-return, line-feed at the end of each
// line, we add them anyway since it allows View Source and Save As commands in
// the viewer to create human-sensible documents
//

//
// HTML_DOCUMENT_HEADER - every HTML document should have a header. It must have
// a title. This string defines the header, title and start of the document body
//

#define HTML_DOCUMENT_HEADER        "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n" \
                                    "<HTML>\r\n" \
                                    "<HEAD>\r\n" \
                                    "<TITLE>%s</TITLE>\r\n" \
                                    "</HEAD>\r\n" \
                                    "<BODY>\r\n" \
                                    "<H2>%s</H2>\r\n"

#ifdef EXTENDED_ERROR_HTML

//
// HTML_ERROR_DOCUMENT_HEADER - error variant of standard document header
//

#define HTML_ERROR_DOCUMENT_HEADER  "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n" \
                                    "<HTML>\r\n" \
                                    "<HEAD>\r\n" \
                                    "<TITLE>%s</TITLE>\r\n" \
                                    "</HEAD>\r\n" \
                                    "<BODY>\r\n" \
                                    "<H2>%s</H2>\r\n" \
                                    "<HR>\r\n"

#endif

//
// HTML_DOCUMENT_PREFORMAT - directory entries are preformatted to stop the HTML
// viewer putting its own interpretation on the listing
//

#define HTML_DOCUMENT_PREFORMAT     "<PRE>\r\n"

//
// HTML_DOCUMENT_END_PREFORMAT - this is required after the last directory entry
// to allow the viewer to resume HTML formatting
//

#define HTML_DOCUMENT_END_PREFORMAT "</PRE>\r\n"

//
// HTML_HORIZONTAL_RULE - we separate each part of the document with a horizontal
// rule line
//

#define HTML_HORIZONTAL_RULE        "<HR>\r\n"

//
// HTML_FTP_WELCOME_START - for FTP directories, we display the FTP welcome
// message
//

#define HTML_FTP_WELCOME_START      HTML_HORIZONTAL_RULE \
                                    "<H4><PRE>\r\n"

//
// HTML_FTP_WELCOME_END - finish off at end of FTP welcome message
//

#define HTML_FTP_WELCOME_END        "</PRE></H4>\r\n"

//
// HTML_DOCUMENT_DIR_START - when creating a directory listing document, we
// follow the header with a Horizontal Rule (<HR>)
//

#define HTML_DOCUMENT_DIR_START     HTML_HORIZONTAL_RULE \
                                    HTML_DOCUMENT_PREFORMAT

//
// HTML_DOCUMENT_FTP_DIR_START - same as HTML_DOCUMENT_DIR_START, but used to
// add an additional "back up one level" if FTP and not the root
//

#define HTML_DOCUMENT_FTP_DIR_START HTML_HORIZONTAL_RULE \
                                    "%s" \
                                    HTML_DOCUMENT_PREFORMAT

//
// HTML_DOCUMENT_DIR_END - string that appears at the end of the preformatted
// directory list, but before the end of the document
//

#define HTML_DOCUMENT_DIR_END       HTML_DOCUMENT_END_PREFORMAT \
                                    HTML_HORIZONTAL_RULE

//
// HTML_ISINDEX - string that causes browser to display search form
//
#define HTML_ISINDEX                "<ISINDEX>"

//
// HTML_DOCUMENT_FOOTER - this goes at the end of every HTML document we create
//

#define HTML_DOCUMENT_FOOTER        "</BODY>\r\n" \
                                    "</HTML>\r\n"

//
// HTML_DOCUMENT_DIR_ENTRY - each directory entry is formatted using the
// following string. Directories are bold
//

#define HTML_DOCUMENT_DIR_ENTRY     "%s %s <A HREF=\"%s\"><B>%s</B></A>\r\n"

//
// HTML_DOCUMENT_FILE_ENTRY - same as HTML_DOCUMENT_DIR_ENTRY, except link is
// not bold
//

#define HTML_DOCUMENT_FILE_ENTRY    "%s %s <A HREF=\"%s\">%s</A>\r\n"

#define SCRATCH_PAD_SIZE            1024

#define FTP_WELCOME_INTRO           "230-"
#define FTP_WELCOME_INTRO_LENGTH    (sizeof(FTP_WELCOME_INTRO) - 1)

#define MAX_FMT_BUF 200 // size of buffer for loading title format string resource
char szDir[32];
char szSearch[32];

//
// private prototypes
//

PRIVATE
DWORD
MakeHtmlDirEntry(
    IN HINTERNET_HANDLE_TYPE HandleType,
    IN LPSTR PathPrefix,
    IN LPVOID DirBuffer,
    IN LPBYTE EntryBuffer,
    IN OUT LPDWORD BufferLength,
    OUT LPSTR* DirEntry
    );

//
// functions
//


BOOL
ReadHtmlUrlData(
    IN HINTERNET hInternet,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwBytesReturned
    )

/*++

Routine Description:

    Converts an FTP or gopher file or directory listing to a HTML document. This
    function is a wrapper for InternetReadFile() and InternetFindNext(), and so
    returns BOOL: the error code proper is set by the appropriate API

Arguments:

    hInternet           - handle of file or find object

    lpBuffer            - pointer to caller's buffer

    dwBufferLength      - size of lpBuffer on input

    lpdwBytesReturned   - pointer to returned number of bytes read into lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_INET,
                Bool,
                "ReadHtmlUrlData",
                "%#x, %#x, %d, %#x",
                hInternet,
                lpBuffer,
                dwBufferLength,
                lpdwBytesReturned
                ));

    DWORD error;
    HINTERNET_HANDLE_TYPE handleType;
    BOOL success;
    LPSTR url;
    DWORD charsCopied;
    LPBYTE buffer;
    BYTE dirBuffer[max(sizeof(WIN32_FIND_DATA), sizeof(GOPHER_FIND_DATA))];
    BOOL done;
    HTML_STATE htmlState;
    HTML_STATE previousHtmlState;
    BYTE scratchPad[SCRATCH_PAD_SIZE];
    BOOL dataCopied;
    LPSTR lastDirEntry;
    LPSTR urlCopy;

    //
    // initialize variables in case we quit early
    //

    htmlState = previousHtmlState = HTML_STATE_INVALID;
    urlCopy = NULL;

    //
    // retrieve some information from the file/find handle - the handle type,
    // URL string, current HTML document state and previous failed dir entry
    //

    error = RGetHandleType(hInternet, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    error = RGetUrl(hInternet, &url);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    error = RGetHtmlState(hInternet, &htmlState);
    previousHtmlState = htmlState;
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    error = RGetDirEntry(hInternet, &lastDirEntry);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // initialize variables for loop
    //

    *lpdwBytesReturned = dwBufferLength;
    charsCopied = 0;
    buffer = (LPBYTE)lpBuffer;
    done = FALSE;
    success = TRUE;
    dataCopied = FALSE;

    //
    // first, maybe we already have data available from a previous
    // QueryDataAvailable operation
    //

#ifdef EXTENDED_ERROR_HTML
    INET_ASSERT((handleType == TypeFtpFindHandleHtml)
                || (handleType == TypeFtpFileHandleHtml)
                || (handleType == TypeGopherFindHandleHtml));
#else
    INET_ASSERT((handleType == TypeFtpFindHandleHtml)
                || (handleType == TypeGopherFindHandleHtml));
#endif

    if (handleType == TypeFtpFindHandleHtml) {

        FTP_FIND_HANDLE_OBJECT * pObject = (FTP_FIND_HANDLE_OBJECT *)hInternet;

        if (pObject->HaveQueryData()) {
            dwBufferLength -= pObject->CopyQueriedData(lpBuffer, dwBufferLength);
            goto quit;
        }
    }
#ifdef EXTENDED_ERROR_HTML
    else if (handleType == TypeFtpFileHandleHtml) {

        FTP_ERROR_HANDLE_OBJECT * pObject = (FTP_ERROR_HANDLE_OBJECT *)hInternet;

        if (pObject->HaveQueryData()) {
            dwBufferLength -= pObject->CopyQueriedData(lpBuffer, dwBufferLength);
            goto quit;
        }
    }
#endif
    else
    {
        GOPHER_FIND_HANDLE_OBJECT * pObject = (GOPHER_FIND_HANDLE_OBJECT *)hInternet;

        if (pObject->HaveQueryData()) {
            dwBufferLength -= pObject->CopyQueriedData(lpBuffer, dwBufferLength);
            goto quit;
        }
    }

    //
    // loop round, writing as much data as we are able to the caller's buffer
    //

    do {
        switch (htmlState) {
        case HTML_STATE_START:

            //
            // if we are dealing with files then we go straight to copying the
            // file contents - we don't encapsulate files in HTML
            //

#ifdef EXTENDED_ERROR_HTML
            if (handleType == TypeFtpFileHandleHtml) {

                //
                // FTP file handle is used for FTP errors
                //

                charsCopied = (DWORD)wsprintf((LPSTR)scratchPad,
                                              HTML_ERROR_DOCUMENT_HEADER,
                                              "FTP Error",
                                              "FTP Error"
                                              );
                if (charsCopied > dwBufferLength) {

                    //
                    // caller's buffer not large enough to fit header - clean up
                    // and allow the caller to retry
                    //

                    success = FALSE;
                    error = ERROR_INSUFFICIENT_BUFFER;
                    done = TRUE;
                } else {

                    //
                    // copy the header to the caller's buffer
                    //

                    memcpy(buffer, scratchPad, charsCopied);
                    dataCopied = TRUE;
                }
                htmlState = HTML_STATE_ERROR_BODY;
            } else if (handleType == TypeGopherFileHandleHtml)
#else
            if ((handleType == TypeFtpFileHandleHtml)
            || (handleType == TypeGopherFileHandleHtml))
#endif
            {
                htmlState = HTML_STATE_BODY;
            }
            else
            {
                htmlState = (HTML_STATE)((int)htmlState + 1);
            }
            break;

        case HTML_STATE_HEADER: {

            //
            // crack the URL for the info we need (i) for the header (ii) for
            // FTP file paths
            //

            DWORD urlLength;
            LPSTR host;
            DWORD hostLength;
            char title[MAX_FMT_BUF + INTERNET_MAX_PATH_LENGTH + 1];
            char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

            //
            // first, make a copy of the URL, reserving 2 extra characters in
            // case this is an FTP request and we need to add a root directory
            // path
            //

            urlLength = strlen(url);
            urlCopy = NEW_MEMORY(urlLength + 2, char);
            if (urlCopy == NULL) {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            memcpy(urlCopy, url, urlLength + 1);

            //
            // get the start of the URL path and the host name. CrackUrl() will
            // destroy url but leave urlCopy intact
            //

            error = CrackUrl(urlCopy,
                             0,     // dwUrlLength
                             FALSE, // decode the url-path
                             NULL,  // we don't care about the scheme
                             NULL,  // or scheme name
                             NULL,
                             &host, // we want the host name (for title)
                             &hostLength,
                             NULL,  // or the port
                             NULL,  // or the user name
                             NULL,
                             NULL,  // or the password
                             NULL,
                             &url,  // we want the url-path
                             &urlLength,
                             NULL,
                             NULL,
                             NULL
                             );
            if (error != ERROR_SUCCESS) {

                //
                // handle still has previous URL pointer, but it will be deleted
                // when the handle is closed
                //

                goto quit;
            }

            //
            // ensure the host name is zero-terminated
            //

            hostLength = (DWORD)min(hostLength, sizeof(hostName) - 1);
            memcpy(hostName, host, hostLength);
            hostName[hostLength] = '\0';

            //
            // same for the URL-path
            //

            url[urlLength] = '\0';

            //
            // create the header/title
            //

            char szFmt[MAX_FMT_BUF];
            szFmt[0] = 0; // guard against LoadString failing (why would it?)

            if (handleType == TypeGopherFindHandleHtml) {

                GOPHER_FIND_HANDLE_OBJECT* pGopherFind =
                    (GOPHER_FIND_HANDLE_OBJECT *) hInternet;

                switch (pGopherFind->GetFixedType()) {

                    case GOPHER_TYPE_CSO:
                        LoadString (GlobalDllHandle, IDS_GOPHER_CSO,
                            szFmt, sizeof(szFmt));
                        wsprintf (title, szFmt, hostName);
                        break;

                    case GOPHER_TYPE_INDEX_SERVER:
                        LoadString (GlobalDllHandle, IDS_GOPHER_INDEX,
                            szFmt, sizeof(szFmt));
                        wsprintf (title, szFmt, hostName);
                        break;

                    default:
                        if ((*url == '\0') || (memcmp(url, "/", 2) == 0)) {
                            LoadString (GlobalDllHandle, IDS_GOPHER_ROOT,
                                szFmt, sizeof(szFmt));
                            wsprintf(title, szFmt, hostName);
                        } else {
                            LoadString (GlobalDllHandle, IDS_GOPHER_DIR,
                                szFmt, sizeof(szFmt));
                            wsprintf(title, szFmt, hostName);
                        }
                }

            } else if (handleType == TypeFtpFindHandleHtml) {
                if ((*url == '\0') || (memcmp(url, "/", 2) == 0)) {
                    LoadString (GlobalDllHandle, IDS_FTP_ROOT,
                        szFmt, sizeof(szFmt));
                    wsprintf(title, szFmt, hostName);
                } else {
                    LoadString (GlobalDllHandle, IDS_FTP_DIR,
                        szFmt, sizeof(szFmt));
                    wsprintf(title, szFmt, url, hostName);
                }
            } else {
                title[0] = '\0';
            }
            charsCopied = (DWORD)wsprintf((LPSTR)scratchPad,
                                          HTML_DOCUMENT_HEADER,
                                          title,
                                          title
                                          );
            if (charsCopied > dwBufferLength) {

                //
                // caller's buffer not large enough to fit header - clean up
                // and allow the caller to retry
                //

                success = FALSE;
                error = ERROR_INSUFFICIENT_BUFFER;
                done = TRUE;
            } else {

                //
                // copy the header to the caller's buffer
                //

                memcpy(buffer, scratchPad, charsCopied);
                dataCopied = TRUE;

                //
                // if the URL contains a NULL path then point it at the FTP
                // root. Likewise, end any and all directory paths with '/'
                //

                if (handleType == TypeFtpFindHandleHtml) {
                    if (urlLength == 0) {
                        *url = '/';
                        ++urlLength;
                    } else if ((url[urlLength - 1] != '/')
                    && (url[urlLength - 1] != '\\')) {
                        url[urlLength++] = '/';
                    }
                    url[urlLength] = '\0';
                } else {
                    url = NULL;
                }

                //
                // free the URL in the handle object if gopher, else (FTP) set
                // it to be the path part of the URL. The previous string will
                // be deleted, and a new one allocated
                //

                RSetUrl(hInternet, url);

                //
                // we can now start on the dir header
                //

                htmlState = (HTML_STATE)((int)htmlState + 1);
            }
            break;
        }

        case HTML_STATE_WELCOME: {

            LPSTR lastInfo;
            DWORD lastInfoLength;
            INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
            BOOL freeLastResponseInfo;

            if (  handleType == TypeGopherFindHandleHtml
               && ((GOPHER_FIND_HANDLE_OBJECT *) hInternet)->GetFixedType()) {

                //
                // BUGBUG - wimp out on CSO searches for now.
                //

                if (((GOPHER_FIND_HANDLE_OBJECT *) hInternet)->GetFixedType()
                         == GOPHER_TYPE_CSO) {
                    success = TRUE;
                    dataCopied = FALSE;
                    htmlState = HTML_STATE_FOOTER;
                    break;
                }


                charsCopied = sizeof(HTML_ISINDEX);
                if (dwBufferLength < charsCopied) {

                    success = FALSE;

                } else {

                    memcpy (buffer, HTML_ISINDEX, charsCopied);
                    dataCopied = TRUE;
                    success = TRUE;
                    htmlState = HTML_STATE_FOOTER;
                }
                break;
            }

            pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)
                            ((HANDLE_OBJECT *)hInternet)->GetParent();
            lastInfo = pConnect->GetLastResponseInfo(&lastInfoLength);

            //
            // if not an FTP find operation then we don't check for any welcome
            // message, or other text from the server. Just go to the next state
            //

            if ((handleType == TypeFtpFindHandleHtml) && (lastInfo != NULL)) {

                //
                // find the welcome message. This starts with "230-" and can
                // continue over multiple lines, each of which may start with
                // "230-", or each may start with a line beginning only with a
                // space
                //

                LPSTR p = strstr(lastInfo, FTP_WELCOME_INTRO);

                if (p != NULL) {

                    //
                    // first, copy the separator
                    //

                    LPBYTE pBuffer = buffer;
                    DWORD bufferLeft = dwBufferLength;

                    if (bufferLeft >= (sizeof(HTML_FTP_WELCOME_START) - 1)) {
                        memcpy(pBuffer,
                               HTML_FTP_WELCOME_START,
                               sizeof(HTML_FTP_WELCOME_START) - 1
                               );
                        pBuffer += sizeof(HTML_FTP_WELCOME_START) - 1;
                        bufferLeft -= sizeof(HTML_FTP_WELCOME_START) - 1;
                        charsCopied = sizeof(HTML_FTP_WELCOME_START) - 1;
                    } else {

                        //
                        // caller's buffer not large enough to fit header -
                        // clean up and allow the caller to retry
                        //

                        success = FALSE;
                        error = ERROR_INSUFFICIENT_BUFFER;
                        done = TRUE;
                        freeLastResponseInfo = FALSE;
                        goto quit_welcome;
                    }

                    //
                    // then copy each welcome message line, dropping the "230-"
                    // from each
                    //

                    do {
                        if (!strncmp(p, FTP_WELCOME_INTRO, FTP_WELCOME_INTRO_LENGTH)) {
                            p += FTP_WELCOME_INTRO_LENGTH;
                        } else if (*p != ' ') {

                            //
                            // line doesn't start with "230-" or a space. We're
                            // done
                            //

                            break;
                        }

                        LPSTR lastChar;
                        DWORD len;

                        lastChar = strchr(p, '\n');
                        if (lastChar != NULL) {
                            len = (DWORD)(lastChar - p) + 1;
                        } else {
                            len = strlen(p);
                        }

                        if (bufferLeft >= len) {
                            memcpy(pBuffer, p, len);
                            pBuffer += len;
                            p += len;
                            bufferLeft -= len;
                            charsCopied += len;

                            //
                            // find start of next line, or end of buffer, in
                            // case there are multiple line terminators
                            //

                            while ((*p == '\r') || (*p == '\n')) {
                                ++p;
                            }
                        } else {

                            //
                            // caller's buffer not large enough to fit header -
                            // clean up and allow the caller to retry
                            //

                            success = FALSE;
                            error = ERROR_INSUFFICIENT_BUFFER;
                            done = TRUE;
                            freeLastResponseInfo = FALSE;
                            break;
                        }
                    } while (TRUE);

                    //
                    // finish off
                    //

                    if (bufferLeft >= (sizeof(HTML_FTP_WELCOME_END) - 1)) {
                        memcpy(pBuffer,
                               HTML_FTP_WELCOME_END,
                               sizeof(HTML_FTP_WELCOME_END) - 1
                               );
                        pBuffer += sizeof(HTML_FTP_WELCOME_END) - 1;
                        bufferLeft -= sizeof(HTML_FTP_WELCOME_END) - 1;
                        charsCopied += sizeof(HTML_FTP_WELCOME_END) - 1;

                        //
                        // successfully completed welcome message part
                        //

                        dataCopied = TRUE;
                        freeLastResponseInfo = TRUE;
                        htmlState = (HTML_STATE)((int)htmlState + 1);
                    } else {

                        //
                        // caller's buffer not large enough to fit header -
                        // clean up and allow the caller to retry
                        //

                        success = FALSE;
                        error = ERROR_INSUFFICIENT_BUFFER;
                        done = TRUE;
                        freeLastResponseInfo = FALSE;
                    }
                } else {

                    //
                    // last response info, but no welcome text. Continue
                    //

                    htmlState = (HTML_STATE)((int)htmlState + 1);
                    freeLastResponseInfo = TRUE;
                    charsCopied = 0;
                }
            } else {

                //
                // no info from server. Continue
                //

                htmlState = (HTML_STATE)((int)htmlState + 1);
                freeLastResponseInfo = FALSE;
                charsCopied = 0;
            }

quit_welcome:

            if (freeLastResponseInfo) {
                pConnect->FreeLastResponseInfo();
            }
            break;
        }

        case HTML_STATE_DIR_HEADER:

            //
            // copy the directory listing introduction. N.B. this is mainly here
            // from the time when we had directory listings AND files being HTML
            // encapsulated. This is no longer true, so I could change things
            // somewhat
            //

            //
            // if FTP directory AND not root directory, display link to higher
            // level
            //

            DWORD cbTotal;
            char szUp[64];
            LPSTR lpszHtml;

            szUp[0] = 0;

            if (handleType == TypeFtpFindHandleHtml) {
                lpszHtml = HTML_DOCUMENT_FTP_DIR_START;
                cbTotal = sizeof(HTML_DOCUMENT_FTP_DIR_START);
                if ((*url != '\0') && (memcmp(url, "/", 2) != 0)) {
                    cbTotal += LoadString(GlobalDllHandle,
                                          IDS_FTP_UPLEVEL,
                                          szUp,
                                          sizeof(szUp)
                                          );
                }
            } else {
                lpszHtml = HTML_DOCUMENT_DIR_START;
                cbTotal = sizeof(HTML_DOCUMENT_DIR_START);
            }
            if (dwBufferLength >= cbTotal) {
                charsCopied = wsprintf((char *)buffer, lpszHtml, szUp);
                dataCopied = TRUE;
                htmlState = (HTML_STATE)((int)htmlState + 1);
            } else {
                error = ERROR_INSUFFICIENT_BUFFER;
                success = FALSE;
            }
            break;

        case HTML_STATE_BODY:

            //
            // if we already have a formatted dir entry from last time (it
            // wouldn't fit in the buffer), then copy it now
            //

            if (lastDirEntry != NULL) {
                charsCopied = strlen(lastDirEntry);
                if (dwBufferLength >= charsCopied) {
                    memcpy(buffer, lastDirEntry, charsCopied);

                    //
                    // we no longer require the string
                    //

                    RSetDirEntry(hInternet, NULL);
                    lastDirEntry = NULL;
                    success = TRUE;
                } else {

                    //
                    // still not enough room
                    //

                    error = ERROR_INSUFFICIENT_BUFFER;
                    success = FALSE;
                    done = TRUE;
                }

                //
                // in both cases fall out of the switch()
                //

                break;
            }

            //
            // read the next part of the HTML document
            //

            switch (handleType) {
            case TypeFtpFindHandleHtml:
                success = FtpFindNextFileA(hInternet,
                                           (LPWIN32_FIND_DATA)dirBuffer
                                           );
                goto create_dir_entry;

            case TypeGopherFindHandleHtml:

                //
                // Check if we simply can return fixed text for a search
                //

                success = GopherFindNextA(hInternet,
                                          (LPGOPHER_FIND_DATA)dirBuffer
                                          );

                //
                // directory listing - get the next directory entry, convert
                // to HTML and write to the caller's buffer. If there's not
                // enough space, return an error
                //

create_dir_entry:

                if (success) {
                    charsCopied = dwBufferLength;
                    error = MakeHtmlDirEntry(handleType,
                                             url,
                                             dirBuffer,
                                             buffer,
                                             &charsCopied,
                                             &lastDirEntry
                                             );
                    if (error != ERROR_SUCCESS) {

                        //
                        // if MakeHtmlDirEntry() created a copy of the directory
                        // entry then store it in the handle object for next
                        // time
                        //

                        if (lastDirEntry != NULL) {
                            RSetDirEntry(hInternet, lastDirEntry);

                            //
                            // no longer need our copy of the string -
                            // RSetLastDirEntry() also makes a copy and adds it
                            // to the handle object
                            //

                            DEL_STRING(lastDirEntry);
                        }

                        //
                        // probably out of buffer space - we're done
                        //

                        success = FALSE;
                        done = TRUE;
                    } else {
                        dataCopied = TRUE;
                    }
                } else if (GetLastError() == ERROR_NO_MORE_FILES) {

                    //
                    // change the error to success - ReadFile() doesn't return
                    // ERROR_NO_MORE_FILES
                    //

                    SetLastError(ERROR_SUCCESS);

                    //
                    // reached the end of the directory listing - time to
                    // add the footer
                    //

                    charsCopied = 0;
                    success = TRUE;
                    htmlState = (HTML_STATE)((int)htmlState + 1);
                }
                break;

            case TypeFtpFileHandleHtml:
            case TypeGopherFileHandleHtml:

                //
                // BUGBUG - this path never taken because we do not encapsulate
                //          files?
                //

                //
                // file data - just read the next chunk
                //

                success = InternetReadFile(hInternet,
                                           (LPVOID)buffer,
                                           dwBufferLength,
                                           &charsCopied
                                           );
                if (success) {
                    if (charsCopied == 0) {

                        //
                        // read all of file - we're done (no HTML to add for
                        // files)
                        //

                        htmlState = HTML_STATE_END;
                    } else {
                        buffer += charsCopied;
                        dwBufferLength -= charsCopied;
                        dataCopied = TRUE;
                    }
                }
                break;
            }
            break;

        case HTML_STATE_DIR_FOOTER:
            if (dwBufferLength >= sizeof(HTML_DOCUMENT_DIR_END) - 1) {
                memcpy(buffer,
                       HTML_DOCUMENT_DIR_END,
                       sizeof(HTML_DOCUMENT_DIR_END) - 1
                       );
                charsCopied = sizeof(HTML_DOCUMENT_DIR_END) - 1;
                dataCopied = TRUE;
                htmlState = (HTML_STATE)((int)htmlState + 1);
            } else {
                error = ERROR_INSUFFICIENT_BUFFER;
                success = FALSE;
            }
            break;

        case HTML_STATE_FOOTER:

            //
            // copy the HTML document footer - don't copy the end-of-string
            // character ('\0')
            //

            if (dwBufferLength >= sizeof(HTML_DOCUMENT_FOOTER) - 1) {
                memcpy(buffer,
                       HTML_DOCUMENT_FOOTER,
                       sizeof(HTML_DOCUMENT_FOOTER) - 1
                       );
                charsCopied = sizeof(HTML_DOCUMENT_FOOTER) - 1;

                //
                // the document is done
                //

                htmlState = (HTML_STATE)((int)htmlState + 1);
                dataCopied = TRUE;
                done = TRUE;
            } else if (charsCopied==0) {
                error = ERROR_INSUFFICIENT_BUFFER;
                success = FALSE;
            } else {
                // We're out of buffer space. but we've got everything else
                // so we'll just leave
                done = TRUE;
            }
            break;

        case HTML_STATE_END:
            done = TRUE;
            break;

#ifdef EXTENDED_ERROR_HTML
        case HTML_STATE_ERROR_BODY:
            htmlState = HTML_STATE_FOOTER;
            break;
#endif

        default:

            INET_ASSERT(FALSE);

            break;
        }

        if (success) {

            //
            // update the buffer pointer and remaining length by the number of
            // bytes read this time round the loop
            //

            buffer += charsCopied;
            dwBufferLength -= charsCopied;
        }
    } while ((dwBufferLength != 0) && success && !done);

    //
    // if we succeeded, update the amount of data returned, else set the last
    // error, which may be different from the last error set by the underlying
    // API (if any were called)
    //

quit:

    //
    // remember the current state
    //

    if (htmlState != previousHtmlState) {
        RSetHtmlState(hInternet, htmlState);
    }

    //
    // if we quit because we ran out of buffer then only return an error if we
    // didn't copy *any* data
    //

    if ((error == ERROR_INSUFFICIENT_BUFFER) && dataCopied) {
        error = ERROR_SUCCESS;
        success = TRUE;
    }

    //
    // if we succeeded then return the amount of data read, else reset the last
    // error
    //

    if (error == ERROR_SUCCESS) {
        *lpdwBytesReturned -= dwBufferLength;
    } else {
        *lpdwBytesReturned = 0;
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(INET, error);

    }

    //
    // clean up
    //

    if (urlCopy != NULL) {
        DEL(urlCopy);
    }

    //
    // return API-level success or failure indication
    //

    DEBUG_LEAVE(success);

    return success;
}


DWORD
QueryHtmlDataAvailable(
    IN HINTERNET hInternet,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    This function is called when the app is querying available data for a cooked
    (HTML) find handle. Because we have to cook the data before we can determine
    how much there is, we need to allocate a buffer and cook the data there

Arguments:

    hInternet                   - MAPPED address of handle object

    lpdwNumberOfBytesAvailable  - pointer to returned bytes available

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                    Can only handle TypeFtpFindHandleHtml and
                    TypeGopherFindHandleHtml

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating HTML buffer

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "QueryHtmlDataAvailable",
                "%#x, %#x",
                hInternet,
                lpdwNumberOfBytesAvailable
                ));

    DWORD error;

    switch (((HANDLE_OBJECT *)hInternet)->GetHandleType()) {
    case TypeFtpFindHandleHtml:
        error = ((FTP_FIND_HANDLE_OBJECT *)hInternet)->
                    QueryHtmlDataAvailable(lpdwNumberOfBytesAvailable);
        break;

#ifdef EXTENDED_ERROR_HTML
    case TypeFtpFileHandleHtml:
        error = ((FTP_ERROR_HANDLE_OBJECT *)hInternet)->
                    QueryHtmlDataAvailable(lpdwNumberOfBytesAvailable);
        break;
#endif

    case TypeGopherFindHandleHtml:
        error = ((GOPHER_FIND_HANDLE_OBJECT *)hInternet)->
                    QueryHtmlDataAvailable(lpdwNumberOfBytesAvailable);
        break;

    default:
        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private functions
//


PRIVATE
DWORD
MakeHtmlDirEntry(
    IN HINTERNET_HANDLE_TYPE HandleType,
    IN LPSTR PathPrefix,
    IN LPVOID DirBuffer,
    IN LPBYTE EntryBuffer,
    IN OUT LPDWORD BufferLength,
    OUT LPSTR* DirEntry
    )

/*++

Routine Description:

    Creates a single-line directory entry for a HTML document. The line is
    formatted thus (e.g.):

    "   12,345,678 Fri Jun 23 95  4:43pm pagefile.sys                   "
    "    Directory Fri Jun 23 95 10:00am foobar.directory               "
    "                                    unknown.filesize               "

Arguments:

    HandleType      - type of the handle - gopher or FTP (find + HTML)

    PathPrefix      - string used to build (FTP) absolute paths

    DirBuffer       - pointer to buffer containing GOPHER_FIND_DATA or
                      WIN32_FIND_DATA

    EntryBuffer     - pointer to buffer where HTML dir entry will be written

    BufferLength    - IN: number of bytes available in EntryBuffer
                      OUT: number of bytes written to EntryBuffer

    DirEntry        - if we couldn't copy the directory entry to the HTML buffer
                      then we return a pointer to a copy of the formatted
                      directory entry. The caller should remember this and use
                      it the next time the function is called, before getting
                      the next dir entry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    EntryBuffer is not large enough to hold this entry

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "MakeHtmlDirEntry",
                "%s (%d), %q, %#x, %#x, %#x [%d], %#x",
                InternetMapHandleType(HandleType),
                HandleType,
                PathPrefix,
                DirBuffer,
                EntryBuffer,
                BufferLength,
                *BufferLength,
                DirEntry
                ));

    BOOL isDir;
    BOOL isSearch;
    LPSTR entryName;
    DWORD entrySize;
    FILETIME entryTime;
    SYSTEMTIME systemTime;
    char timeBuf[80];
    char sizeBuf[15];   // 4,294,967,295
    char entryBuf[sizeof(HTML_DOCUMENT_DIR_ENTRY) + INTERNET_MAX_PATH_LENGTH];
    char urlBuf[INTERNET_MAX_URL_LENGTH];
    LPSTR url;
    LPSTR pSizeDir;
    DWORD nPrinted;
    DWORD error;
    BOOL haveTimeAndSize;
    DWORD urlLength;

    //
    // ensure we are dealing with the correct handle type
    //

    INET_ASSERT((HandleType == TypeFtpFindHandleHtml)
                || (HandleType == TypeGopherFindHandleHtml));

    //
    // get the common information we will use to create a directory entry line
    //

    if (HandleType == TypeFtpFindHandleHtml) {
        isDir = ((LPWIN32_FIND_DATA)DirBuffer)->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        isSearch = FALSE;
        entryName = ((LPWIN32_FIND_DATA)DirBuffer)->cFileName;
        entryTime = ((LPWIN32_FIND_DATA)DirBuffer)->ftLastWriteTime;
        entrySize = ((LPWIN32_FIND_DATA)DirBuffer)->nFileSizeLow;
        haveTimeAndSize = TRUE;

        DWORD slen = strlen(PathPrefix);
        DWORD len = (DWORD)min(slen, sizeof(urlBuf) - 1);

        memcpy(urlBuf, PathPrefix, len);
        slen = strlen(entryName);
        slen = (DWORD)min(slen, (sizeof(urlBuf) - 1) - len);
        memcpy(&urlBuf[len], entryName, slen);
        len += slen;
        if (isDir && (len < sizeof(urlBuf) - 1)) {
            urlBuf[len] = '/';
            ++len;
        }
        urlBuf[len] = '\0';
        url = urlBuf;
    } else {
        isDir = IS_GOPHER_DIRECTORY(((LPGOPHER_FIND_DATA)DirBuffer)->GopherType);
        isSearch = IS_GOPHER_INDEX_SERVER(((LPGOPHER_FIND_DATA)DirBuffer)->GopherType);
        entryName = ((LPGOPHER_FIND_DATA)DirBuffer)->DisplayString;
        GopherLocatorToUrl(((LPGOPHER_FIND_DATA)DirBuffer)->Locator,
                           urlBuf,
                           sizeof(urlBuf),
                           &urlLength
                           );
        url = urlBuf;
        if (IS_GOPHER_PLUS(((LPGOPHER_FIND_DATA)DirBuffer)->GopherType)) {
            haveTimeAndSize = TRUE;
            entryTime = ((LPGOPHER_FIND_DATA)DirBuffer)->LastModificationTime;
            entrySize = ((LPGOPHER_FIND_DATA)DirBuffer)->SizeLow;
        } else {
            haveTimeAndSize = FALSE;
            entryTime.dwLowDateTime = 0;
            entryTime.dwHighDateTime = 0;
            entrySize = 0;
        }
    }

    //
    // if we have a non-zero entry time AND we can convert it to a system time
    // then create an internationalized time string
    //

    if ((entryTime.dwLowDateTime != 0)
    && (entryTime.dwHighDateTime != 0)
    && FileTimeToSystemTime(&entryTime, &systemTime)) {

        int n;

        //
        // BUGBUG - if either of these fail for any reason, we should fill the
        //          string with the requisite-t-t-t-t-t number of spaces
        //

        n = GetDateFormat(0,    // lcid
                          0,    // dwFlags
                          &systemTime,
                          "MM/dd/yyyy ",
                          timeBuf,
                          sizeof(timeBuf)
                          );
        if (n > 0) {

            //
            // number of characters written to string becomes index in string
            // at which to write time string
            //

            --n;
        }
        GetTimeFormat(0,    // lcid
                      TIME_NOSECONDS,
                      &systemTime,
                      "hh:mmtt",
                      &timeBuf[n],
                      sizeof(timeBuf) - n
                      );

        //
        // convert any non-ANSI characters to the OEM charset
        //

        CharToOem(timeBuf, timeBuf);
    } else {
        memcpy(timeBuf, "                ", 17);
    }

    //
    // convert the entry size to a human-readable form
    //

    if (isDir) {

        //
        // directories show up as DOS-style <DIR> entries, except we use the
        // full "Directory" text
        //

        //
        // BUGBUG - needs to be in a resource. Also, if we are adding images
        //          <IMG> then we don't need to specify dir - it will be obvious
        //          from the display (but what about text-only? what about
        //          viewers that don't care to/can't load the image?)
        //

        if (!szDir[0]) {
            LoadString(GlobalDllHandle, IDS_TAG_DIRECTORY, szDir, sizeof(szDir));
        }
        pSizeDir = szDir;
    } else if (isSearch) {

        //
        // if this is a gopher item and it is an index server (7) then indicate
        // the fact using this string
        //

        if (!szSearch[0]) {
            LoadString(GlobalDllHandle, IDS_TAG_SEARCH, szSearch, sizeof(szSearch));
        }
        pSizeDir = szSearch;
    } else if (haveTimeAndSize) {
        pSizeDir = NiceNum(sizeBuf, entrySize, 14);
    } else {
        pSizeDir = "              ";
    }

    //
    // now create the HTML directory entry
    //

    //
    // BUGBUG - at this point we need to call the MIME function to retrieve the
    //          URL for the image file that goes with this file type
    //

    nPrinted = wsprintf(entryBuf,
                        isDir
                            ? HTML_DOCUMENT_DIR_ENTRY
                            : HTML_DOCUMENT_FILE_ENTRY,
                        timeBuf,
                        pSizeDir,
                        url,
                        entryName
                        );
    if (nPrinted <= *BufferLength) {
        memcpy(EntryBuffer, entryBuf, nPrinted);
        *BufferLength = nPrinted;
        error = ERROR_SUCCESS;
    } else {

        //
        // there is not enough space in the buffer to store this formatted
        // directory entry. So since we've gone to the trouble of creating
        // the string, we make a copy of it and return it to the caller. If
        // NEW_STRING fails, then we will lose this directory entry, but it's
        // not really a problem. (The alternative would be to return e.g.
        // ERROR_NOT_ENOUGH_MEMORY and probably fail the entire request)
        //

        DEBUG_PRINT(INET,
                    WARNING,
                    ("failed to copy %q\n",
                    entryBuf
                    ));

        *DirEntry = NEW_STRING(entryBuf);

        if (*DirEntry == NULL) {

            DEBUG_PRINT(INET,
                        WARNING,
                        ("failed to make copy of %q!\n",
                        entryBuf
                        ));

        }
        error = ERROR_INSUFFICIENT_BUFFER;
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\strtokex.c ===
/***
*strtokex.c - tokenize a string with given delimiters
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines strtok() - breaks string into series of token
*       via repeated calls.
*
*******************************************************************************/
#if defined(unix)
#define __cdecl
#endif
#include <string.h>
/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/
char * __cdecl StrTokEx (char ** pstring, const char * control)
{
        /*unsigned*/ char *str;
        const /*unsigned*/ char *ctrl = control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = *pstring;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) )
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = str;

        /* Determine if a token has been found. */
        if ( tokenstr == str )
            return NULL;
        else
            return tokenstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\test\asyncdl\asyncdl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    asyncdl.c

Abstract:

    Asynchronous download. Tests reading an URL entirely asynchronously

Author:

    Richard L Firth (rfirth) 19-Nov-1995

Revision History:

    19-Nov-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#define DEFAULT_URL         "http://www.microsoft.com"
#define URL_SIGN            (DWORD)'UrlX'
#define DEFAULT_BUFLEN      1024
#define BUFFER_INCREMENT    DEFAULT_BUFLEN

typedef enum {
    STATE_OPEN,
    STATE_READ,
    STATE_CLOSE,
    STATE_ERROR
} URL_STATE;

typedef struct {
    DWORD Signature;
    URL_STATE State;
    LPVOID Buffer;
    DWORD BufferLength;
    DWORD BytesRead;
    DWORD NumRead;
    HINTERNET Handle;
} URL_CONTEXT, * LPURL_CONTEXT;

void _CRTAPI1 main(int, char**);
void usage(void);
void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);
void data_handler(LPURL_CONTEXT, LPINTERNET_ASYNC_RESULT);

BOOL Verbose = FALSE;
BOOL Completed = FALSE;
BOOL UseQuery = FALSE;

HANDLE AsyncEvent;
DWORD AsyncResult;
DWORD AsyncError;

LPURL_CONTEXT UrlContext;

void _CRTAPI1 main(int argc, char** argv) {

    LPSTR url = NULL;
    DWORD accessMode = PRE_CONFIG_INTERNET_ACCESS;
    LPURL_CONTEXT lpContext;
    INTERNET_STATUS_CALLBACK cbres;
    HINTERNET hInternet;
    HINTERNET hUrl;
    BOOL displayData = FALSE;
    LPSTR filename = NULL;
    DWORD openFlags = 0;
    LPSTR proxy = NULL;
    BOOL expectingProxy = FALSE;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'a':
                switch (*++*argv) {
                case 'l':
                case 'd':
                    accessMode = INTERNET_OPEN_TYPE_DIRECT;
                    break;

                case 'p':
                    accessMode = INTERNET_OPEN_TYPE_PROXY;
                    proxy = ++*argv;
                    if (!*proxy) {
                        expectingProxy = TRUE;
                    }
                    break;

                default:
                    printf("error: unrecognized access mode flag: '%c'\n", **argv);
                    usage();
                }
                break;

            case 'd':
                displayData = TRUE;
                break;

            case 'f':
                if (*++*argv) {
                    filename = *argv;
                } else {
                    printf("error: no filename found for -f flag\n");
                    usage();
                }
                break;

            case 'n':
                openFlags |= INTERNET_FLAG_NO_CACHE_WRITE;
                break;

            case 'q':
                UseQuery = TRUE;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else if (!url) {
            url = *argv;
        } else if (expectingProxy) {
            proxy = *argv;
            expectingProxy = FALSE;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (proxy != NULL) {
        if (!*proxy) {
            printf("error: expecting proxy server name\n");
            usage();
        }
    }

    AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!AsyncEvent) {
        print_error("asyncdl", "CreateEvent()");
        exit(1);
    }

    lpContext = (LPURL_CONTEXT)calloc(1, sizeof(URL_CONTEXT));
    if (!lpContext) {
        printf("error: calloc() failed\n");
        exit(1);
    }
    lpContext->Buffer = malloc(DEFAULT_BUFLEN);
    if (!lpContext->Buffer) {
        printf("error: malloc(%d) failed\n", DEFAULT_BUFLEN);
        exit(1);
    }
    lpContext->BufferLength = DEFAULT_BUFLEN;
    lpContext->Signature = URL_SIGN;
    lpContext->State = STATE_OPEN;
    UrlContext = lpContext;

    if (Verbose) {
        printf("opening Internet handle\n");
    }

    hInternet = InternetOpen("Async Read Test",
                             accessMode,
                             proxy,
                             NULL,
                             INTERNET_FLAG_ASYNC
                             );
    if (!hInternet) {
        print_error("asyncdl", "InternetOpen()");
        exit(1);
    } else if (Verbose) {
        printf("InternetOpen() returns handle %x\n", hInternet);
    }

    if (Verbose) {
        printf("installing callback\n");
    }

    cbres = InternetSetStatusCallback(hInternet, my_callback);
    if (cbres == INTERNET_INVALID_STATUS_CALLBACK) {
        print_error("asyncdl", "InternetSetStatusCallback()");
        exit(1);
    }

    if (Verbose) {
        printf("opening URL %s\n", url);
    }

    hUrl = InternetOpenUrl(hInternet,
                           url,
                           NULL,    // lpHeaders
                           0,       // dwHeadersLength
                           openFlags,
                           (DWORD)lpContext
                           );
    if (hUrl == NULL) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("asyncdl", "InternetOpenUrl()");
            exit(1);
        }
        if (Verbose) {
            printf("waiting for async InternetOpenUrl()...\n");
        }
        WaitForSingleObject(AsyncEvent, INFINITE);
        hUrl = (HINTERNET)AsyncResult;
        SetLastError(AsyncError);
    } else {
        printf("warning: InternetOpenUrl() returns synchronous result\n");
    }

    if (!hUrl) {
        if (!Completed) {
            print_error("asyncdl", "InternetOpenUrl()");
            exit(1);
        } else if (Verbose) {
            printf("Download completed OK!\n");
        }
    } else {
        printf("error: unexpected hUrl = %x\n", hUrl);
    }

    if (displayData) {

        int fh;
        int mode;

        if (filename) {
            fh = _open(filename, _O_CREAT|_O_TRUNC|_O_WRONLY|_O_BINARY, _S_IREAD|_S_IWRITE);
            if (fh == -1) {
                printf("error: cannot open file \"%s\" for writing\n", filename);
                filename = NULL;
            }
        }
        if (!filename) {
            if (Verbose) {
                printf("%d bytes data received:\n", lpContext->BytesRead);
            }
            mode = _setmode(1, _O_BINARY);
            fh = 1;
        }
        _write(fh, lpContext->Buffer, lpContext->BytesRead);
        if (filename) {
            _close(fh);
        } else {
            _setmode(1, mode);
        }
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("\n"
           "usage: asyncdl [-a<l|g|p>[<server>[:<port>]]] [-d] [-f<file>] [-n] [-v] <url>\n"
           "\n"
           "where: -a  = access mode. Default is pre-configured\n"
           "       -al = local internet access (same as -ad)\n"
           "       -ap = CERN proxy internet access. <server> is required\n"
           "       -d  = Display received data\n"
           "       -f  = Write data to <file>. Only if -d set\n"
           "       -n  = Don't write data to cache\n"
           "       -v  = Verbose mode\n"
           "\n"
           "If no URL is supplied, " DEFAULT_URL " will be used\n"
           );
    exit(1);
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: Hndl %x [Ctxt %x [%s]] %s ",
                Handle,
                Context,
                (Context == (DWORD)UrlContext) ? "Url"
                : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {

                DWORD handleType;
                DWORD handleTypeSize = sizeof(handleType);
                LPSTR typeStr;

                printf("%x", *(LPHINTERNET)Info);

                if (InternetQueryOption(*(LPHINTERNET)Info,
                                        INTERNET_OPTION_HANDLE_TYPE,
                                        &handleType,
                                        &handleTypeSize
                                        )) {
                    switch (handleType) {
                    case INTERNET_HANDLE_TYPE_INTERNET:
                        typeStr = "Internet";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_FTP:
                        typeStr = "FTP Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
                        typeStr = "Gopher Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
                        typeStr = "HTTP Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FIND:
                        typeStr = "FTP Find";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
                        typeStr = "FTP Find HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FILE:
                        typeStr = "FTP File";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
                        typeStr = "FTP File HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FIND:
                        typeStr = "Gopher Find";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
                        typeStr = "Gopher Find HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FILE:
                        typeStr = "Gopher File";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
                        typeStr = "Gopher File HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
                        typeStr = "HTTP Request";
                        break;

                    default:
                        typeStr = "???";
                        break;
                    }
                    ((LPURL_CONTEXT)Context)->Handle = *(LPHINTERNET)Info;
                } else {
                    typeStr = "<error>";
                }
                printf(" [%s]", typeStr);
            } else if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {

                //
                // nothing
                //

            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else {
                printf(Info);
            }
        }
        putchar('\n');
    }

    if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
        data_handler((LPURL_CONTEXT)Context,
                     (LPINTERNET_ASYNC_RESULT)Info
                     );
    }
}

void
data_handler(
    LPURL_CONTEXT lpContext,
    LPINTERNET_ASYNC_RESULT Results
    )
{
    BOOL ok;
    DWORD len;
    int retcode;
    DWORD available;
    HINTERNET hInternet = lpContext->Handle;

    if (lpContext->Signature != URL_SIGN) {
        printf("fatal: unrecognized context block %x\n", lpContext);
        exit(1);
    }

    while (1) {
        switch (lpContext->State) {
        case STATE_OPEN:
            if (!Results->dwResult) {
                SetLastError(Results->dwError);
                print_error("data_handler", "async InternetOpenUrl()");
                exit(1);
            }
            len = sizeof(retcode);
            ok = HttpQueryInfo(hInternet,
                               HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                               (LPVOID)&retcode,
                               &len,
                               NULL
                               );
            if (!ok) {
                print_error("data_handler", "HttpQueryInfo()");
                goto error_exit;
            }
            if (retcode != 200) {
                printf("error: server returns error %d\n", retcode);
                goto error_exit;
            } else if (Verbose) {
                printf("async InternetOpenUrl(): HTTP result code %d\n", retcode);
            }
            do {
                if (UseQuery) {
                    ok = InternetQueryDataAvailable(
                            hInternet,
                            &available,
                            0,
                            0
                            );
                } else {
                    ok = InternetReadFile(
                            hInternet,
                            (LPBYTE)lpContext->Buffer + lpContext->BytesRead,
                            lpContext->BufferLength - lpContext->BytesRead,
                            &lpContext->NumRead
                            );
                }

            } while (ok);
            if (!ok) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("initial read started...\n");
                    }
                    lpContext->State = STATE_READ;
                    return;
                } else {
                    print_error("data_handler", "InternetReadFile()");
                    exit(1);
                }
            }
            return;

        case STATE_READ:
            if (!Results->dwResult) {
                SetLastError(Results->dwError);
                print_error("data_handler", "async InternetReadFile()");
                exit(1);
            }
            if (lpContext->NumRead == 0) {
                if (Verbose) {
                    printf("finished\n");
                    lpContext->State = STATE_CLOSE;
                    continue;
                }
            } else if (Verbose) {
                printf("InternetReadFile() returns %d bytes\n", lpContext->NumRead);
            }
            lpContext->BytesRead += lpContext->NumRead;
            if (Verbose) {
                printf("reallocating buffer %x from %d (%x) to %d (%x)\n",
                        lpContext->Buffer,
                        lpContext->BufferLength,
                        lpContext->BufferLength,
                        lpContext->BufferLength + BUFFER_INCREMENT,
                        lpContext->BufferLength + BUFFER_INCREMENT
                        );
            }
            lpContext->Buffer = realloc(lpContext->Buffer,
                                        lpContext->BufferLength + BUFFER_INCREMENT
                                        );
            if (lpContext->Buffer == NULL) {
                printf("error: data_handler: realloc() failed\n");
                exit(1);
            }
            lpContext->BufferLength += BUFFER_INCREMENT;
            ok = InternetReadFile(hInternet,
                                  (LPBYTE)lpContext->Buffer + lpContext->BytesRead,
                                  lpContext->BufferLength - lpContext->BytesRead,
                                  &lpContext->NumRead
                                  );
            if (!ok) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    return;
                } else {
                    print_error("data_handler", "InternetReadFile()");
                    exit(1);
                }
            }
            return;

        case STATE_CLOSE:
            InternetCloseHandle(hInternet);
            AsyncResult = 0;
            AsyncError = 0;
            Completed = TRUE;
            SetEvent(AsyncEvent);
            return;

        case STATE_ERROR:
            return;

        default:
            printf("fatal: unrecognized state %x in context %x\n",
                lpContext->State,
                lpContext
                );
            exit(1);
        }
    }

    printf("\aerror: data_handler: didn't expect to reach here\n");

    return;

error_exit:

    AsyncResult = Results->dwResult;
    AsyncError = Results->dwError;
    InternetCloseHandle(hInternet);
    SetEvent(AsyncEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\test\cernprox\cernprox.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cernprox.c

Abstract:

    Tests CERN proxy support

Author:

    Richard L Firth (rfirth) 28-Jun-1995

Revision History:

    28-Jun-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <io.h>
#include <fcntl.h>
#include <windows.h>
#include <wininet.h>
#include <winsock.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

//
// prototypes
//

void _CRTAPI1 main(int, char**);
void usage(void);
void _CRTAPI1 my_cleanup(void);
void my_callback(DWORD, DWORD, LPVOID, DWORD);
void default_url_test(void);
void open_urls(LPSTR*, int);
void get_url_data(HINTERNET);
void ftp_find(HINTERNET);
void gopher_find(HINTERNET);
void read_data(HINTERNET);
void print_error(char*, char*, ...);
char* map_error(DWORD);
void get_last_internet_error(void);

//
// data
//

BOOL Verbose = FALSE;
HINTERNET InternetHandle = NULL;
INTERNET_STATUS_CALLBACK PreviousCallback;
LPSTR default_urls[] = {

    //
    // WEB
    //

    "http://www.microsoft.com",
    "http://www.microsoft.com/pages/misc/whatsnew.htm",

    //
    // gopher
    //

    "gopher://gopher.microsoft.com",
    "gopher://gopher.microsoft.com/11/msft/",
    "gopher://gopher.microsoft.com/00\\welcome.txt",
    "gopher://gopher.tc.umn.edu/11Information%20About%20Gopher%09%09%2B",
    "gopher://spinaltap.micro.umn.edu/11/computer",
    "gopher://mudhoney.micro.umn.edu:4325/7",
    "gopher://mudhoney.micro.umn.edu:4325/7%09gopher",
    "gopher://spinaltap.micro.umn.edu/7mindex:lotsoplaces%09gopher%09%2b",

    //
    // FTP
    //

    "ftp://ftp.microsoft.com",
    "ftp://ftp.microsoft.com/MSNBRO.TXT",
    "ftp://ftp.microsoft.com/Services/"
};

#define NUMBER_OF_DEFAULT_URLS  (sizeof(default_urls)/sizeof(default_urls[0]))

//
// functions
//

void _CRTAPI1 main(int argc, char** argv) {

    BOOL ok;
    LPSTR urls[64];
    int numberOfUrls = 0;
    BOOL fCallback = FALSE;
    INTERNET_PORT proxyPort = 0;
    LPSTR proxy = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case 'c':
                fCallback = TRUE;
                break;

            case 'p':
                proxyPort = (INTERNET_PORT)atoi(++*argv);
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("unknown command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (proxy == NULL) {
            proxy = *argv;
        } else {
            if (numberOfUrls == sizeof(urls)/sizeof(urls[0]) - 1) {
                break;
            }
            urls[numberOfUrls++] = *argv;
        }
    }

    //
    // exit function
    //

    atexit(my_cleanup);

    //
    // let's have a status callback
    //

    if (fCallback) {
        PreviousCallback = InternetSetStatusCallback(my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    //
    // open gateway
    //

    InternetHandle = InternetOpen("cernprox",
                                  CERN_PROXY_INTERNET_ACCESS,
                                  proxy,
                                  proxyPort,
                                  0
                                  );
    if (InternetHandle == NULL) {
        printf("error: cernprox: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    }

    if (numberOfUrls == 0) {
        default_url_test();
    } else {
        open_urls(urls, numberOfUrls);
    }

    ok = InternetCloseHandle(InternetHandle);
    if (!ok) {
        printf("error: cernprox: InternetClose(InternetHandle) returns %d\n", GetLastError());
        exit(1);
    } else {
        InternetHandle = NULL;
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: cernprox [-c] [-v] <proxy> [-p#] [url]*\n"
           "where:  -c = enable status call-backs\n"
           "        -p = port for CERN proxy\n"
           "        -v = Verbose mode\n"
           "     proxy = CERN proxy server\n"
           "       url = one or more URLs to open\n"
           );
    exit(1);
}

void _CRTAPI1 my_cleanup() {
    if (InternetHandle != NULL) {
        printf("closing Internet handle %x\n", InternetHandle);
        if (!InternetCloseHandle(InternetHandle)) {
            print_error("my_cleanup", "InternetCloseHandle()");
        }
    }
}

VOID
my_callback(
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    default:
        type$ = "???";
        break;
    }
    printf("callback: %s ", type$);
    if (Info) {
        printf(Info);
    }
    putchar('\n');
}

void default_url_test() {
    open_urls(default_urls, NUMBER_OF_DEFAULT_URLS);
}

void open_urls(LPSTR* purls, int nurls) {

    HINTERNET handle;

    while (nurls--) {
        printf("\nopening URL \"%s\"\n\n", *purls);
        handle = InternetOpenUrl(InternetHandle,
                                 *purls,
                                 NULL,
                                 0,
                                 0,
                                 0
                                 );
        if (handle == NULL) {
            print_error("open_urls", "InternetOpenUrl(%s)", *purls);
        } else {
            get_url_data(handle);
        }
        ++purls;
    }
}

void get_url_data(HINTERNET handle) {

    DWORD handleType;
    DWORD handleTypeLen;

    handleTypeLen = sizeof(handleType);
    if (InternetQueryOption(handle,
                            INTERNET_OPTION_HANDLE_TYPE,
                            (LPVOID)&handleType,
                            &handleTypeLen
                            )) {

        if (handleType != INTERNET_HANDLE_TYPE_HTTP_REQUEST) {
            printf("error: get_url_data: handle type %d returned, should be %d\n",
                    handleType,
                    INTERNET_HANDLE_TYPE_HTTP_REQUEST
                    );
        }

        switch (handleType) {
        case INTERNET_HANDLE_TYPE_INTERNET:
            printf("error: get_url_data: HANDLE_TYPE_INTERNET?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_FTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_FTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_GOPHER?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_HTTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND:
            ftp_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND:
            gopher_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
        case INTERNET_HANDLE_TYPE_FTP_FILE:
        case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
        case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
        case INTERNET_HANDLE_TYPE_GOPHER_FILE:
        case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
        case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
            read_data(handle);
            break;

        default:
            printf("error: get_url_data: handleType == %d?\n", handleType);
            break;
        }
        if (!InternetCloseHandle(handle)) {
            print_error("get_url_data", "InternetCloseHandle()");
        }
    } else {
        print_error("get_url_data", "InternetQueryOption()");
    }
}

void ftp_find(HINTERNET handle) {

    WIN32_FIND_DATA ffd;

    while (InternetFindNextFile(handle, (LPVOID)&ffd)) {

        SYSTEMTIME stDbg;

        if (!FileTimeToSystemTime(&ffd.ftLastWriteTime, &stDbg)) {
            printf("| ftLastWriteTime = ERROR\n");
        }

        printf("%2d-%02d-%04d %2d:%02d:%02d  %15d bytes %-s%-s%-s %s\n",
               stDbg.wMonth, stDbg.wDay, stDbg.wYear,
               stDbg.wHour, stDbg.wMinute, stDbg.wSecond,
               ffd.nFileSizeLow,
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)    ? "Normal    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)  ? "ReadOnly  " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? "Directory " : "",
               ffd.cFileName
               );
    }
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("ftp_find", "InternetFindNextFile()");
    }
}

void gopher_find(HINTERNET handle) {

    GOPHER_FIND_DATA data;
    int i;

    i = 0;
    while (InternetFindNextFile(handle, (LPVOID)&data)) {

        LPGOPHER_FIND_DATA p;
        SYSTEMTIME systemTime;
        char timeBuf[9];
        char sizeBuf[32];

        p = (LPGOPHER_FIND_DATA)&data;
        if ((p->LastModificationTime.dwLowDateTime != 0)
        && (p->LastModificationTime.dwHighDateTime != 0)) {
            FileTimeToSystemTime(&p->LastModificationTime, &systemTime);
            sprintf(timeBuf,
                    "%02d-%02d-%02d",
                    systemTime.wMonth,
                    systemTime.wDay,
                    systemTime.wYear % 100
                    );
            sprintf(sizeBuf, "%d", p->SizeLow);
        } else {
            timeBuf[0] = '\0';
            sizeBuf[0] = '\0';
        }
        printf("%5d %c %7s %10s %8s %s\n",
                i,
                (p->GopherType & GOPHER_TYPE_GOPHER_PLUS) ? '+' : ' ',
                (p->GopherType & GOPHER_TYPE_TEXT_FILE)         ? "Text"
                : (p->GopherType & GOPHER_TYPE_DIRECTORY)       ? "Dir"
                : (p->GopherType & GOPHER_TYPE_CSO)             ? "Phone"
                : (p->GopherType & GOPHER_TYPE_ERROR)           ? "Error"
                : (p->GopherType & GOPHER_TYPE_MAC_BINHEX)      ? "MAC"
                : (p->GopherType & GOPHER_TYPE_DOS_ARCHIVE)     ? "Archive"
                : (p->GopherType & GOPHER_TYPE_UNIX_UUENCODED)  ? "UNIX"
                : (p->GopherType & GOPHER_TYPE_INDEX_SERVER)    ? "Index"
                : (p->GopherType & GOPHER_TYPE_TELNET)          ? "Telnet"
                : (p->GopherType & GOPHER_TYPE_BINARY)          ? "Binary"
                : (p->GopherType & GOPHER_TYPE_REDUNDANT)       ? "Backup"
                : (p->GopherType & GOPHER_TYPE_TN3270)          ? "TN3270"
                : (p->GopherType & GOPHER_TYPE_GIF)             ? "GIF"
                : (p->GopherType & GOPHER_TYPE_IMAGE)           ? "Image"
                : (p->GopherType & GOPHER_TYPE_BITMAP)          ? "Bitmap"
                : (p->GopherType & GOPHER_TYPE_MOVIE)           ? "Movie"
                : (p->GopherType & GOPHER_TYPE_SOUND)           ? "Sound"
                : (p->GopherType & GOPHER_TYPE_HTML)            ? "HTML"
                : (p->GopherType & GOPHER_TYPE_PDF)             ? "PDF"
                : (p->GopherType & GOPHER_TYPE_CALENDAR)        ? "Cal"
                : (p->GopherType & GOPHER_TYPE_INLINE)          ? "Inline"
                : (p->GopherType & GOPHER_TYPE_UNKNOWN)         ? "Unknown"
                : "\a????",
                sizeBuf,
                timeBuf,
                p->DisplayString
                );
        ++i;
    }
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("gopher_find", "InternetFindNextFile()");
    }
}

void read_data(HINTERNET handle) {

    char buf[1021]; // odd number for fun!
    DWORD nread;

    while (InternetReadFile(handle, buf, sizeof(buf), &nread)) {
        if (!nread) {
            printf("=== end of file ===\n");
            break;
        } else {
            setmode(1, _O_BINARY);
            write(1, buf, nread);
        }
    }
    if (GetLastError() != ERROR_SUCCESS) {
        print_error("read_file", "InternetReadFile()");
    }
}

void print_error(char* func, char* format, ...) {

    va_list argptr;
    char buf[256];
    DWORD error;

    error = GetLastError();
    va_start(argptr, format);
    vsprintf(buf, format, argptr);
    printf("error: %s: %s returns %d [%s]\n", func, buf, error, map_error(error));
    va_end(argptr);
    if (error == ERROR_INTERNET_EXTENDED_ERROR) {
        get_last_internet_error();
    }
}

#define ERROR_CASE(error)  case error: return # error

char* map_error(DWORD error) {
    switch (error) {

    //
    // Windows base errors
    //

    ERROR_CASE(ERROR_SUCCESS);
    ERROR_CASE(ERROR_INVALID_FUNCTION);
    ERROR_CASE(ERROR_FILE_NOT_FOUND);
    ERROR_CASE(ERROR_PATH_NOT_FOUND);
    ERROR_CASE(ERROR_ACCESS_DENIED);
    ERROR_CASE(ERROR_INVALID_HANDLE);
    ERROR_CASE(ERROR_NOT_ENOUGH_MEMORY);
    ERROR_CASE(ERROR_NO_MORE_FILES);
    ERROR_CASE(ERROR_INVALID_PASSWORD);
    ERROR_CASE(ERROR_INVALID_PARAMETER);
    ERROR_CASE(ERROR_BUFFER_OVERFLOW);
    ERROR_CASE(ERROR_NO_MORE_SEARCH_HANDLES);
    ERROR_CASE(ERROR_INVALID_TARGET_HANDLE);
    ERROR_CASE(ERROR_CALL_NOT_IMPLEMENTED);
    ERROR_CASE(ERROR_INSUFFICIENT_BUFFER);
    ERROR_CASE(ERROR_INVALID_NAME);
    ERROR_CASE(ERROR_INVALID_LEVEL);
    ERROR_CASE(ERROR_BAD_PATHNAME);
    ERROR_CASE(ERROR_BUSY);
    ERROR_CASE(ERROR_ALREADY_EXISTS);
    ERROR_CASE(ERROR_FILENAME_EXCED_RANGE);
    ERROR_CASE(ERROR_MORE_DATA);
    ERROR_CASE(ERROR_NO_MORE_ITEMS);
    ERROR_CASE(ERROR_INVALID_ADDRESS);
    ERROR_CASE(ERROR_OPERATION_ABORTED);
    ERROR_CASE(RPC_S_INVALID_STRING_BINDING);
    ERROR_CASE(RPC_S_WRONG_KIND_OF_BINDING);
    ERROR_CASE(RPC_S_INVALID_BINDING);
    ERROR_CASE(RPC_S_PROTSEQ_NOT_SUPPORTED);
    ERROR_CASE(RPC_S_INVALID_RPC_PROTSEQ);
    ERROR_CASE(RPC_S_INVALID_STRING_UUID);
    ERROR_CASE(RPC_S_INVALID_ENDPOINT_FORMAT);
    ERROR_CASE(RPC_S_INVALID_NET_ADDR);
    ERROR_CASE(RPC_S_NO_ENDPOINT_FOUND);
    ERROR_CASE(RPC_S_INVALID_TIMEOUT);
    ERROR_CASE(RPC_S_OBJECT_NOT_FOUND);
    ERROR_CASE(RPC_S_ALREADY_REGISTERED);
    ERROR_CASE(RPC_S_TYPE_ALREADY_REGISTERED);
    ERROR_CASE(RPC_S_ALREADY_LISTENING);
    ERROR_CASE(RPC_S_NO_PROTSEQS_REGISTERED);
    ERROR_CASE(RPC_S_NOT_LISTENING);
    ERROR_CASE(RPC_S_UNKNOWN_MGR_TYPE);
    ERROR_CASE(RPC_S_UNKNOWN_IF);
    ERROR_CASE(RPC_S_NO_BINDINGS);
    ERROR_CASE(RPC_S_NO_PROTSEQS);
    ERROR_CASE(RPC_S_CANT_CREATE_ENDPOINT);
    ERROR_CASE(RPC_S_OUT_OF_RESOURCES);
    ERROR_CASE(RPC_S_SERVER_UNAVAILABLE);
    ERROR_CASE(RPC_S_SERVER_TOO_BUSY);
    ERROR_CASE(RPC_S_INVALID_NETWORK_OPTIONS);
    ERROR_CASE(RPC_S_NO_CALL_ACTIVE);
    ERROR_CASE(RPC_S_CALL_FAILED);
    ERROR_CASE(RPC_S_CALL_FAILED_DNE);
    ERROR_CASE(RPC_S_PROTOCOL_ERROR);
    ERROR_CASE(RPC_S_UNSUPPORTED_TRANS_SYN);
    ERROR_CASE(RPC_S_UNSUPPORTED_TYPE);
    ERROR_CASE(RPC_S_INVALID_TAG);
    ERROR_CASE(RPC_S_INVALID_BOUND);
    ERROR_CASE(RPC_S_NO_ENTRY_NAME);
    ERROR_CASE(RPC_S_INVALID_NAME_SYNTAX);
    ERROR_CASE(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    ERROR_CASE(RPC_S_UUID_NO_ADDRESS);
    ERROR_CASE(RPC_S_DUPLICATE_ENDPOINT);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_TYPE);
    ERROR_CASE(RPC_S_MAX_CALLS_TOO_SMALL);
    ERROR_CASE(RPC_S_STRING_TOO_LONG);
    ERROR_CASE(RPC_S_PROTSEQ_NOT_FOUND);
    ERROR_CASE(RPC_S_PROCNUM_OUT_OF_RANGE);
    ERROR_CASE(RPC_S_BINDING_HAS_NO_AUTH);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_SERVICE);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_LEVEL);
    ERROR_CASE(RPC_S_INVALID_AUTH_IDENTITY);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    ERROR_CASE(EPT_S_INVALID_ENTRY);
    ERROR_CASE(EPT_S_CANT_PERFORM_OP);
    ERROR_CASE(EPT_S_NOT_REGISTERED);
    ERROR_CASE(RPC_S_NOTHING_TO_EXPORT);
    ERROR_CASE(RPC_S_INCOMPLETE_NAME);
    ERROR_CASE(RPC_S_INVALID_VERS_OPTION);
    ERROR_CASE(RPC_S_NO_MORE_MEMBERS);
    ERROR_CASE(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    ERROR_CASE(RPC_S_INTERFACE_NOT_FOUND);
    ERROR_CASE(RPC_S_ENTRY_ALREADY_EXISTS);
    ERROR_CASE(RPC_S_ENTRY_NOT_FOUND);
    ERROR_CASE(RPC_S_NAME_SERVICE_UNAVAILABLE);
    ERROR_CASE(RPC_S_INVALID_NAF_ID);
    ERROR_CASE(RPC_S_CANNOT_SUPPORT);
    ERROR_CASE(RPC_S_NO_CONTEXT_AVAILABLE);
    ERROR_CASE(RPC_S_INTERNAL_ERROR);
    ERROR_CASE(RPC_S_ZERO_DIVIDE);
    ERROR_CASE(RPC_S_ADDRESS_ERROR);
    ERROR_CASE(RPC_S_FP_DIV_ZERO);
    ERROR_CASE(RPC_S_FP_UNDERFLOW);
    ERROR_CASE(RPC_S_FP_OVERFLOW);
    ERROR_CASE(RPC_X_NO_MORE_ENTRIES);
    ERROR_CASE(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    ERROR_CASE(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    ERROR_CASE(RPC_X_SS_IN_NULL_CONTEXT);
    ERROR_CASE(RPC_X_SS_CONTEXT_DAMAGED);
    ERROR_CASE(RPC_X_SS_HANDLES_MISMATCH);
    ERROR_CASE(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    ERROR_CASE(RPC_X_NULL_REF_POINTER);
    ERROR_CASE(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    ERROR_CASE(RPC_X_BYTE_COUNT_TOO_SMALL);
    ERROR_CASE(RPC_X_BAD_STUB_DATA);


    //
    // WinInet errors
    //

    ERROR_CASE(ERROR_INTERNET_OUT_OF_HANDLES);
    ERROR_CASE(ERROR_INTERNET_TIMEOUT);
    ERROR_CASE(ERROR_INTERNET_EXTENDED_ERROR);
    ERROR_CASE(ERROR_INTERNET_INTERNAL_ERROR);
    ERROR_CASE(ERROR_INTERNET_INVALID_URL);
    ERROR_CASE(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    ERROR_CASE(ERROR_INTERNET_NAME_NOT_RESOLVED);
    ERROR_CASE(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    ERROR_CASE(ERROR_INTERNET_INVALID_OPTION);
    ERROR_CASE(ERROR_INTERNET_BAD_OPTION_LENGTH);
    ERROR_CASE(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    ERROR_CASE(ERROR_INTERNET_SHUTDOWN);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_USER_NAME);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_PASSWORD);
    ERROR_CASE(ERROR_INTERNET_LOGIN_FAILURE);
    ERROR_CASE(ERROR_INTERNET_INVALID_OPERATION);
    ERROR_CASE(ERROR_INTERNET_OPERATION_CANCELLED);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    ERROR_CASE(ERROR_INTERNET_NOT_LOCAL_HANDLE);
    ERROR_CASE(ERROR_INTERNET_NOT_PROXY_REQUEST);
    ERROR_CASE(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    ERROR_CASE(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    ERROR_CASE(ERROR_FTP_TRANSFER_IN_PROGRESS);
    ERROR_CASE(ERROR_FTP_CONNECTED);
    ERROR_CASE(ERROR_FTP_DROPPED);
    ERROR_CASE(ERROR_GOPHER_PROTOCOL_ERROR);
    ERROR_CASE(ERROR_GOPHER_NOT_FILE);
    ERROR_CASE(ERROR_GOPHER_DATA_ERROR);
    ERROR_CASE(ERROR_GOPHER_END_OF_DATA);
    ERROR_CASE(ERROR_GOPHER_INVALID_LOCATOR);
    ERROR_CASE(ERROR_GOPHER_INCORRECT_LOCATOR_TYPE);
    ERROR_CASE(ERROR_GOPHER_NOT_GOPHER_PLUS);
    ERROR_CASE(ERROR_GOPHER_ATTRIBUTE_NOT_FOUND);
    ERROR_CASE(ERROR_GOPHER_UNKNOWN_LOCATOR);
    ERROR_CASE(ERROR_HTTP_HEADER_NOT_FOUND);
    ERROR_CASE(ERROR_HTTP_DOWNLEVEL_SERVER);
    ERROR_CASE(ERROR_HTTP_INVALID_SERVER_RESPONSE);


    //
    // Windows sockets errors
    //

    ERROR_CASE(WSAEINTR);
    ERROR_CASE(WSAEBADF);
    ERROR_CASE(WSAEACCES);
    ERROR_CASE(WSAEFAULT);
    ERROR_CASE(WSAEINVAL);
    ERROR_CASE(WSAEMFILE);
    ERROR_CASE(WSAEWOULDBLOCK);
    ERROR_CASE(WSAEINPROGRESS);
    ERROR_CASE(WSAEALREADY);
    ERROR_CASE(WSAENOTSOCK);
    ERROR_CASE(WSAEDESTADDRREQ);
    ERROR_CASE(WSAEMSGSIZE);
    ERROR_CASE(WSAEPROTOTYPE);
    ERROR_CASE(WSAENOPROTOOPT);
    ERROR_CASE(WSAEPROTONOSUPPORT);
    ERROR_CASE(WSAESOCKTNOSUPPORT);
    ERROR_CASE(WSAEOPNOTSUPP);
    ERROR_CASE(WSAEPFNOSUPPORT);
    ERROR_CASE(WSAEAFNOSUPPORT);
    ERROR_CASE(WSAEADDRINUSE);
    ERROR_CASE(WSAEADDRNOTAVAIL);
    ERROR_CASE(WSAENETDOWN);
    ERROR_CASE(WSAENETUNREACH);
    ERROR_CASE(WSAENETRESET);
    ERROR_CASE(WSAECONNABORTED);
    ERROR_CASE(WSAECONNRESET);
    ERROR_CASE(WSAENOBUFS);
    ERROR_CASE(WSAEISCONN);
    ERROR_CASE(WSAENOTCONN);
    ERROR_CASE(WSAESHUTDOWN);
    ERROR_CASE(WSAETOOMANYREFS);
    ERROR_CASE(WSAETIMEDOUT);
    ERROR_CASE(WSAECONNREFUSED);
    ERROR_CASE(WSAELOOP);
    ERROR_CASE(WSAENAMETOOLONG);
    ERROR_CASE(WSAEHOSTDOWN);
    ERROR_CASE(WSAEHOSTUNREACH);
    ERROR_CASE(WSAENOTEMPTY);
    ERROR_CASE(WSAEPROCLIM);
    ERROR_CASE(WSAEUSERS);
    ERROR_CASE(WSAEDQUOT);
    ERROR_CASE(WSAESTALE);
    ERROR_CASE(WSAEREMOTE);
    ERROR_CASE(WSAEDISCON);
    ERROR_CASE(WSASYSNOTREADY);
    ERROR_CASE(WSAVERNOTSUPPORTED);
    ERROR_CASE(WSANOTINITIALISED);
    ERROR_CASE(WSAHOST_NOT_FOUND);
    ERROR_CASE(WSATRY_AGAIN);
    ERROR_CASE(WSANO_RECOVERY);
    ERROR_CASE(WSANO_DATA);

    default:
        return "?";
    }
}

void get_last_internet_error() {

    DWORD bufLength;
    char buffer[256];
    DWORD category;

    bufLength = sizeof(buffer);
    if (InternetGetLastResponseInfo(&category, buffer, &bufLength)) {
        printf("InternetGetLastResponseInfo() returns %d bytes\n", bufLength);
        if (bufLength != 0) {
            printf("Text = \"%s\"\n", buffer);
        }
        if (strlen(buffer) != bufLength) {
            printf("\aerror: get_last_internet_error: InternetGetLastResponseInfo() returns %d bytes; strlen(buffer) = %d\n",
                    bufLength,
                    strlen(buffer)
                    );
        }
    } else {

        LPSTR errbuf;

        printf("InternetGetLastResponseInfo() returns error %d (bufLength = %d)\n",
               GetLastError(),
               bufLength
               );
        if ((errbuf = malloc(bufLength)) == NULL) {
            printf("error: get_last_internet_error: malloc(%d) failed\n", bufLength);
            return;
        }
        if (InternetGetLastResponseInfo(&category, errbuf, &bufLength)) {
            printf("InternetGetLastResponseInfo() returns %d bytes\n", bufLength);
            if (bufLength != 0) {
                printf("Text = \"%s\"\n", errbuf);
            }
            if (strlen(buffer) != bufLength) {
                printf("\aerror: get_last_internet_error: InternetGetLastResponseInfo() returns %d bytes; strlen(buffer) = %d\n",
                        bufLength,
                        strlen(buffer)
                        );
            }
        } else {
            printf("error: get_last_internet_error: InternetGetLastResponseInfo() returns error %d (bufLength = %d)\n",
               GetLastError(),
               bufLength
               );
        }
        free(errbuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\thrdinfo.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.cxx

Abstract:

    Functions to manipulate an INTERNET_THREAD_INFO

    Contents:
        InternetCreateThreadInfo
        InternetDestroyThreadInfo
        InternetTerminateThreadInfo
        InternetGetThreadInfo
        InternetSetThreadInfo
        InternetIndicateStatusAddress
        InternetIndicateStatusString
        InternetIndicateStatusNewHandle
        InternetIndicateStatus
        InternetSetLastError
        _InternetSetLastError
        InternetLockErrorText
        InternetUnlockErrorText
        InternetSetContext
        InternetSetObjectHandle
        InternetGetObjectHandle
        InternetFreeThreadInfo

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win32 user-level DLL

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// manifests
//

#define BAD_TLS_INDEX   0xffffffff  // according to online win32 SDK documentation
#ifdef SPX_SUPPORT
#define GENERIC_SPX_NAME   "SPX Server"
#endif //SPX_SUPPORT
//
// macros
//

#ifdef ENABLE_DEBUG

#define InitializeInternetThreadInfo(lpThreadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->Signature = INTERNET_THREAD_INFO_SIGNATURE; \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#else

#define InitializeInternetThreadInfo(threadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#endif // ENABLE_DEBUG

//
// private data
//

PRIVATE DWORD InternetTlsIndex = BAD_TLS_INDEX;
PRIVATE SERIALIZED_LIST ThreadInfoList;



INTERNETAPI_(BOOL) ResumeSuspendedDownload(
    IN HINTERNET hRequest,
    IN DWORD dwResultCode
    )
/*++

Routine Description:

    Attempts to restart a stalled FSM that is blocked on UI interaction,

Arguments:

    hRequest - handle to open HTTP request

    dwResultCode  - the result of InternetErrorDlg, passed back into Wininet via this API

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                  ERROR_IO_PENDING

        Failure - 

--*/

{
    HINTERNET hRequestMapped = NULL;
    BOOL fResumed = FALSE;
    DWORD error;

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hRequestMapped == NULL)) {
        goto quit;
    }

    //
    // Call internal to do the work
    //

    error = ResumeAfterUserInput(
        hRequestMapped,
        dwResultCode,
        &fResumed
        );

    if ( error != ERROR_SUCCESS) 
    {
        goto quit;
    }

    if ( error == ERROR_SUCCESS )
    {
        error = ERROR_IO_PENDING; // remap to pending
    }


    //
    // If we failed to resume, the handle must have been canceled
    //

    if (!fResumed)
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }

quit:

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    SetLastError(error);

    return (error == ERROR_SUCCESS) ? TRUE : FALSE;
}


//
// functions
//


DWORD 
ResumeAfterUserInput(
    IN HINTERNET hRequestMapped,
    IN DWORD     dwResultCode,
    OUT LPBOOL   pfItemResumed
    )
/*++

Routine Description:

    
     Internal version of Resume API that 
       unblocks an FSM after the UI has been shown, user prompted, and the FSM should now continue.

Arguments:

    hRequestMapped - 
    dwResultCode -
    pfItemResumed - 

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/
{
    HTTP_REQUEST_HANDLE_OBJECT *pRequest;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    INTERNET_HANDLE_OBJECT * pInternet;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "ResumeAfterUserInput",
                "%x, %u, %x",
                hRequestMapped,
                dwResultCode,
                pfItemResumed
                ));

    *pfItemResumed = FALSE;

    //
    // Now round up the objects that are involved 
    //

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent();

    INET_ASSERT(pConnect != NULL);
    INET_ASSERT(pConnect->IsValid(TypeHttpConnectHandle) == ERROR_SUCCESS);

    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);

    //
    // Lock us while we attempt to unblock the FSM
    //
        
    pInternet->LockPopupInfo();      

    //
    // Can only resume if we're blocked on both request and internet handles
    // 

    if ( pInternet->IsBlockedOnUserInput() && 
         pRequest->IsBlockedOnUserInput() ) 
    {
        DWORD dwCntUnBlocked;

        INET_ASSERT(pInternet->GetBlockId() == pRequest->GetBlockId());

        dwCntUnBlocked = UnblockWorkItems(
                            pInternet->GetBlockedUiCount(),
                            pRequest->GetBlockId(), // blocked on FSM
                            ERROR_SUCCESS,
                            TP_NO_PRIORITY_CHANGE
                            );

        if ( dwCntUnBlocked > 0 )
        {
            *pfItemResumed = TRUE;
            pInternet->SetBlockedResultCode(dwResultCode);
        }

    }

    INET_ASSERT( ! (pRequest->IsBlockedOnUserInput() && !pInternet->IsBlockedOnUserInput()) );

//quit: -- not used

    pInternet->UnlockPopupInfo();

    DEBUG_LEAVE(error);

    return error;
}




DWORD
ChangeUIBlockingState(
    IN HINTERNET hRequestMapped,
    IN DWORD     dwError,
    OUT LPDWORD  lpdwActionTaken,
    OUT LPDWORD  lpdwResultCode,
    IN OUT LPVOID * lplpResultData
    )

/*++

Routine Description:

    Attempts to determine the best way of putting up UI for a given error.  This allows 
        us to back out of the Asyncronous FSM thread while popping up UI.

    How it works: 
        We attempt to prevent more than one dialog per InternetOpen handle

Arguments:

  hRequestHandle - mapped handle to open request

    dwError - error code to pass back to client and ultimately to InternetErrorDlg to generate UI

    lpdwActionTaken - returns one of several values, used to tell caller what UI action has been taken
                        UI_ACTION_CODE_NONE_TAKEN                   0
                        UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE  1
                        UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT       2
                        UI_ACTION_CODE_USER_ACTION_COMPLETED        3

    lpdwResultCode  - returns the result of InternetErrorDlg, passed through ResumeSuspendedDownload

    lplpResultData  - a void pointer allocated and owned by callee until after a thread has been resumed
                        used to pass extra data through client to InternetErrorDlg

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                  ERROR_IO_PENDING

        Failure - 

--*/

{
    HTTP_REQUEST_HANDLE_OBJECT *pRequest;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "ChangeUIBlockingState",
                "%x, %u, %x, %x [%x]",
                hRequestMapped,
                dwError,
                lpdwActionTaken,
                lpdwResultCode,
                lplpResultData,
                (lplpResultData ? *lplpResultData : NULL )
                ));


    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_SUCCESS;
    DWORD_PTR dwBlockId;
    BOOL fLocked = FALSE;
    BOOL fDoAsyncCallback = FALSE; // TRUE if we need to callback to the app
    LPVOID lpResultData = NULL;
   

    *lpdwActionTaken = UI_ACTION_CODE_NONE_TAKEN;

    if ( lplpResultData ) {
        lpResultData = *lplpResultData; // save off
    }

    //
    // Gather various sundry elements, objects, thread info, etc,
    //  validate, and if proper continue with the process
    //

    if (lpThreadInfo != NULL) {

        if ( lpThreadInfo->Fsm == NULL )
        {
            goto quit;
        }

        if ( ! lpThreadInfo->IsAsyncWorkerThread )
        {
            goto quit;
        }

        INET_ASSERT(lpThreadInfo->hObject != NULL);
        INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);

        if ( hRequestMapped == NULL )
        {
            hRequestMapped = lpThreadInfo->Fsm->GetMappedHandle();
        }

        INET_ASSERT(hRequestMapped == lpThreadInfo->Fsm->GetMappedHandle());

        //
        // if the context value in the thread info block is 0 then we use the
        // context from the handle object
        //

        DWORD_PTR context;

        context = _InternetGetContext(lpThreadInfo);
        if (context == INTERNET_NO_CALLBACK) {
            context = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetContext();
        }

        INTERNET_STATUS_CALLBACK appCallback;

        appCallback = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        //
        // No callback, no FSM means no special UI callback can be done.
        //

        if ((appCallback == NULL) || (context == INTERNET_NO_CALLBACK)) 
        {
            //
            // For the sync return error
            //

            error = dwError;
            goto quit;
        }

    }
    else
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    //
    // Make sure our handle isn't invalidated before proceeding
    //
    if (((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->IsInvalidated())
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // Now get the objects that are involved 
    //

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent();

    INET_ASSERT(pConnect != NULL);
    INET_ASSERT(pConnect->IsValid(TypeHttpConnectHandle) == ERROR_SUCCESS);

    INTERNET_HANDLE_OBJECT * pInternet;

    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);
    
    pInternet->LockPopupInfo();      
    fLocked = TRUE;

    //
    // We check whether we're blocked on the HTTP handle and the 
    //  Internet handle.   Basically we have a little matrix here
    //  based on which one is blocked (or if neither is blocked)
    //
    //  So: 
    //      InternetHandle(blocked)/RequestHandle(not-blocked) -
    //          indicates we are not the request blocking the UI,
    //          we will need to block the FSM until the other dialog
    //          has completed
    //
    //      InternetHandle(blocked)/RequestHandle(blocked) - 
    //          indicates that we have blocked and have now been 
    //          woken up, we need return the result of the UI
    //          to the caller.
    //
    //      InternetHandle(not-blocked)/RequestHandle(blocked) - 
    //          ASSERT, we shouldn't have this happen
    //
    //      InternetHandle(not-blocked)/RequestHandle(not-blocked) - 
    //          We've just entered with no-blocking handles,
    //          so we block both and wait till UI has completed
    //

    if (!pInternet->IsBlockedOnUserInput())
    {
        //
        // Indicate to the caller via callback
        //   that we need to generate UI, then block
        //

        DEBUG_PRINT(THRDINFO,
                    INFO,
                    ("Blocking on UI, notifing client via callback\n"
                    ));

        fDoAsyncCallback = TRUE;

        INET_ASSERT(!pRequest->IsBlockedOnUserInput());

        dwBlockId = (DWORD_PTR) lpThreadInfo->Fsm;
        pInternet->BlockOnUserInput(dwError, dwBlockId, lpResultData); // IncrementBlockedUiCount() is implied here.
        pRequest->BlockOnUserInput(dwBlockId);
        *lpdwActionTaken = UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT;
    }
    else if (pRequest->IsBlockedOnUserInput() )
    {

        DEBUG_PRINT(THRDINFO,
                    INFO,
                    ("UnBlocking on UI, returning UI result\n"
                    ));

        INET_ASSERT(pInternet->IsBlockedOnUserInput());

        //
        // Retrieve the result of the UI and return
        //   to caller.
        //

        // save off block id in case need it later
        DWORD_PTR dwSavedBlockedId = pRequest->GetBlockId();
        
        INET_ASSERT(pInternet->GetBlockId() == pRequest->GetBlockId());

        pInternet->UnBlockOnUserInput(lpdwResultCode, &lpResultData);
        pRequest->UnBlockOnUserInput();

        if ( lplpResultData ) {
            *lplpResultData = lpResultData;
        }

        *lpdwActionTaken = UI_ACTION_CODE_USER_ACTION_COMPLETED;

        //
        // If others are still blocked, then wake them up too
        //

        if (pInternet->IsBlockedOnUserInput())
        {
            DWORD dwCntUnBlocked;

            dwCntUnBlocked = UnblockWorkItems(
                                pInternet->GetBlockedUiCount(),
                                dwSavedBlockedId,
                                ERROR_SUCCESS,
                                TP_NO_PRIORITY_CHANGE
                                );

            DEBUG_PRINT(THRDINFO,
                        INFO,
                        ("Unblocked %u work items, expected %u\n",
                        dwCntUnBlocked,
                        pInternet->GetBlockedUiCount()
                        ));

            pInternet->ClearBlockedUiCount();
        }

        goto quit;
    }
    else
    {
        DEBUG_PRINT(THRDINFO,
                    INFO,
                    ("Blocking on another FSM (that is busy doing UI) until their completeion\n"
                    ));

        INET_ASSERT(pInternet->IsBlockedOnUserInput());
        INET_ASSERT(!pRequest->IsBlockedOnUserInput());

        //
        // not blocked on the request handle
        // but blocked on internet handle, so we need
        //  to wait until this internet handle is ours
        //   so we do nothing
        //

        pInternet->IncrementBlockedUiCount();

        dwBlockId = pInternet->GetBlockId();        
        *lpdwActionTaken = UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE;
    }

    //
    // Now do the actual blocking of the FSM here.
    //

    lpThreadInfo->Fsm->SetState(FSM_STATE_CONTINUE);
    lpThreadInfo->Fsm->SetNextState(FSM_STATE_CONTINUE);

    error = BlockWorkItem(
        lpThreadInfo->Fsm,
        dwBlockId,               // block the FSM on FSM that created this
        INFINITE                 // we block foreever
        );

    if ( error == ERROR_SUCCESS )
    { 
        error = ERROR_IO_PENDING;
        //goto quit;
    }

quit:

    if (fLocked)
    {
        INET_ASSERT(hRequestMapped);

        pInternet->UnlockPopupInfo();
    }

    if (fDoAsyncCallback)
    {
        INTERNET_ASYNC_RESULT asyncResult;

        //
        // Pass the result Data pointer back to the caller,
        //  this is needed to pass extra info to InternetErrorDlg,
        //  once this pointer is passed, the caller must not free,
        //  until his/her FSM is restarted.
        //

        INET_ASSERT(*lpdwActionTaken == UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT);

        asyncResult.dwResult = (DWORD_PTR)lpResultData;
        asyncResult.dwError  = dwError;

        SetLastError(dwError);

        error = InternetIndicateStatus(
                    INTERNET_STATUS_USER_INPUT_REQUIRED,
                    (LPVOID)&asyncResult,
                    sizeof(asyncResult)
                    );

        if ( error == ERROR_SUCCESS || error == ERROR_INTERNET_OPERATION_CANCELLED )
        {
            error = ERROR_IO_PENDING;
        }
        else
        {
            INET_ASSERT(FALSE);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    )

/*++

Routine Description:

    Creates, initializes an INTERNET_THREAD_INFO. Optionally (allocates and)
    sets this thread's Internet TLS

    Assumes: 1. The first time this function is called is in the context of the
                process attach library call, so we allocate the TLS index once

Arguments:

    SetTls  - TRUE if we are to set the INTERNET_THREAD_INFO TLS for this thread

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to allocated INTERNET_THREAD_INFO structure which has
                  been set as this threads value in its InternetTlsIndex slot

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    BOOL ok = FALSE;

    if (InDllCleanup) {
        goto quit;
    }
    if (InternetTlsIndex == BAD_TLS_INDEX) {

        //
        // first time through, initialize serialized list
        //

        InitializeSerializedList(&ThreadInfoList);

        //
        // we assume that if we are allocating the TLS index, then this is the
        // one and only thread in this process that can call into this DLL
        // right now - i.e. this thread is loading the DLL
        //

        InternetTlsIndex = TlsAlloc();
    }
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        lpThreadInfo = NEW(INTERNET_THREAD_INFO);
        if (lpThreadInfo != NULL) {
            InitializeInternetThreadInfo(lpThreadInfo);
            if (SetTls) {
                ok = TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo);
                if (!ok) {

                    DEBUG_PUT(("InternetCreateThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                             InternetTlsIndex,
                             lpThreadInfo,
                             GetLastError()
                             ));

                    DEBUG_BREAK(THRDINFO);

                }
            } else {
                ok = TRUE;
            }
        } else {

            DEBUG_PUT(("InternetCreateThreadInfo(): NEW(INTERNET_THREAD_INFO) returned NULL\n"));

            DEBUG_BREAK(THRDINFO);

        }
    } else {

        DEBUG_PUT(("InternetCreateThreadInfo(): TlsAlloc() returns %#x, error %d\n",
                 BAD_TLS_INDEX,
                 GetLastError()
                 ));

        DEBUG_BREAK(THRDINFO);
    }
    if (ok) {
        InsertAtHeadOfSerializedList(&ThreadInfoList, &lpThreadInfo->List);
    } else {
        if (lpThreadInfo != NULL) {
            DEL(lpThreadInfo);
            lpThreadInfo = NULL;
        }
        if (InternetTlsIndex != BAD_TLS_INDEX) {
            TlsFree(InternetTlsIndex);
            InternetTlsIndex = BAD_TLS_INDEX;
        }
    }

quit:

    return lpThreadInfo;
}


VOID
InternetDestroyThreadInfo(
    VOID
    )

/*++

Routine Description:

    Cleans up the INTERNET_THREAD_INFO - deletes any memory it owns and deletes
    it

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    IF_DEBUG(NOTHING) {
        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: Deleting INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));
    }

    //
    // don't call InternetGetThreadInfo() - we don't need to create the
    // INTERNET_THREAD_INFO if it doesn't exist in this case
    //

    lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    if (lpThreadInfo != NULL) {

#if INET_DEBUG

        //
        // there shouldn't be anything in the debug record stack. On Win95, we
        // ignore this check if this is the async scheduler (nee worker) thread
        // AND there are entries in the debug record stack. The async thread
        // gets killed off before it has chance to DEBUG_LEAVE, then comes here,
        // causing this assert to be over-active
        //

        if (IsPlatformWin95() && lpThreadInfo->IsAsyncWorkerThread) {
            if (lpThreadInfo->CallDepth != 0) {

                DEBUG_PUT(("InternetDestroyThreadInfo(): "
                            "Thread %#x: "
                            "%d records in debug stack\n",
                            lpThreadInfo->CallDepth
                            ));
            }
        } else {

            INET_ASSERT(lpThreadInfo->Stack == NULL);

        }

#endif // INET_DEBUG

        InternetFreeThreadInfo(lpThreadInfo);

        INET_ASSERT(InternetTlsIndex != BAD_TLS_INDEX);

        TlsSetValue(InternetTlsIndex, NULL);
    } else {

        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: no INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));

    }
}


VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Removes the INTERNET_THREAD_INFO from the list and frees all allocated
    blocks

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO to remove and free

Return Value:

    None.

--*/

{
    RemoveFromSerializedList(&ThreadInfoList, &lpThreadInfo->List);

    if (lpThreadInfo->hErrorText != NULL) {
        FREE_MEMORY(lpThreadInfo->hErrorText);
    }

    //if (lpThreadInfo->lpResolverInfo != NULL) {
    //    if (lpThreadInfo->lpResolverInfo->DnrSocketHandle != NULL) {
    //        lpThreadInfo->lpResolverInfo->DnrSocketHandle->Dereference();
    //    }
    //    DEL(lpThreadInfo->lpResolverInfo);
    //}

    DEL(lpThreadInfo);
}


VOID
InternetTerminateThreadInfo(
    VOID
    )

/*++

Routine Description:

    Destroy all INTERNET_THREAD_INFO structures and terminate the serialized
    list. This funciton called at process detach time.

    At DLL_PROCESS_DETACH time, there may be other threads in the process for
    which we created an INTERNET_THREAD_INFO that aren't going to get the chance
    to delete the structure, so we do it here.

    Code in this module assumes that it is impossible for a new thread to enter
    this DLL while we are terminating in DLL_PROCESS_DETACH

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // get rid of this thread's info structure. No more debug output after this!
    //

    InternetDestroyThreadInfo();

    //
    // get rid of the thread info structures left by other threads
    //

    LockSerializedList(&ThreadInfoList);

    LPINTERNET_THREAD_INFO lpThreadInfo;

    while (lpThreadInfo = (LPINTERNET_THREAD_INFO)SlDequeueHead(&ThreadInfoList)) {

        //
        // already dequeued, no need to call InternetFreeThreadInfo()
        //

        FREE_MEMORY(lpThreadInfo);
    }

    UnlockSerializedList(&ThreadInfoList);

    //
    // no more need for list
    //

    TerminateSerializedList(&ThreadInfoList);

    //
    // or TLS index
    //

    TlsFree(InternetTlsIndex);
    InternetTlsIndex = BAD_TLS_INDEX;
}


LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    )

/*++

Routine Description:

    Gets the pointer to the INTERNET_THREAD_INFO for this thread and checks
    that it still looks good.

    If this thread does not have an INTERNET_THREAD_INFO then we create one,
    presuming that this is a new thread

Arguments:

    None.

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to INTERNET_THREAD_INFO block

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD lastError;

    //
    // this is pretty bad - TlsGetValue() can destroy the per-thread last error
    // variable if it returns NULL (to indicate that NULL was actually set, and
    // that NULL does not indicate an error). So we have to read it before it is
    // potentially destroyed, and reset it before we quit.
    //
    // We do this here because typically, other functions will be completely
    // unsuspecting of this behaviour, and it is better to fix it once here,
    // than in several dozen other places, even though it is slightly
    // inefficient
    //

    lastError = GetLastError();
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    }

    //
    // we may be in the process of creating the INTERNET_THREAD_INFO, in
    // which case its okay for this to be NULL. According to online SDK
    // documentation, a threads TLS value will be initialized to NULL
    //

    if (lpThreadInfo == NULL) {

        //
        // we presume this is a new thread. Create an INTERNET_THREAD_INFO
        //

        IF_DEBUG(NOTHING) {
            DEBUG_PUT(("InternetGetThreadInfo(): Thread %#x: Creating INTERNET_THREAD_INFO\n",
                      GetCurrentThreadId()
                      ));
        }

        lpThreadInfo = InternetCreateThreadInfo(TRUE);
    }
    if (lpThreadInfo != NULL) {

        INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE);
        INET_ASSERT(lpThreadInfo->ThreadId == GetCurrentThreadId());

    } else {

        DEBUG_PUT(("InternetGetThreadInfo(): Failed to get/create INTERNET_THREAD_INFO\n"));

    }

    //
    // as above - reset the last error variable in case TlsGetValue() trashed it
    //

    SetLastError(lastError);

    //
    // actual success/failure indicated by non-NULL/NULL pointer resp.
    //

    return lpThreadInfo;
}


VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Sets lpThreadInfo as the current thread's INTERNET_THREAD_INFO. Used within
    fibers

Arguments:

    lpThreadInfo    - new INTERNET_THREAD_INFO to set

Return Value:

    None.

--*/

{
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        if (!TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo)) {

            DEBUG_PUT(("InternetSetThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                     InternetTlsIndex,
                     lpThreadInfo,
                     GetLastError()
                     ));

            INET_ASSERT(FALSE);

        }
    } else {

        DEBUG_PUT(("InternetSetThreadInfo(): InternetTlsIndex = %d\n",
                 InternetTlsIndex
                 ));

        INET_ASSERT(FALSE);
    }
}


DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a network address that we
    need to convert to a string

Arguments:

    dwInternetStatus    - INTERNET_STATUS_ value

    lpSockAddr          - pointer to full socket address

    dwSockAddrLength    - length of lpSockAddr in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    LPSTR lpAddress;

    INET_ASSERT(lpSockAddr != NULL);

    switch (lpSockAddr->sa_family) {
    case AF_INET:
        lpAddress = _I_inet_ntoa(
                        ((struct sockaddr_in*)lpSockAddr)->sin_addr
                        );
        break;

    case AF_IPX:

        //
        // BUGBUG - this should be a call to WSAAddressToString, but that's not implemented yet
        //
#ifdef SPX_SUPPORT
        lpAddress = GENERIC_SPX_NAME;
#else
        lpAddress = NULL;
#endif //SPX_SUPPORT
        break;

    default:
        lpAddress = NULL;
        break;
    }
    return InternetIndicateStatusString(dwInternetStatus, lpAddress);
}


DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo OPTIONAL
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a string

Arguments:

    dwInternetStatus    - INTERNET_STATUS_ value

    lpszStatusInfo      - string status data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusString",
                "%d, %q",
                dwInternetStatus,
                lpszStatusInfo
                ));

    DWORD length;

    if (ARGUMENT_PRESENT(lpszStatusInfo)) {
        length = strlen(lpszStatusInfo) + 1;
    } else {
        length = 0;
    }

    DWORD error;

    error = InternetIndicateStatus(dwInternetStatus, lpszStatusInfo, length);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    )

/*++

Routine Description:

    Indicates to the app a new handle

Arguments:

    hInternetMapped - mapped address of new handle being indicated

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OPERATION_CANCELLED
                    The app closed the either the new object handle or the
                    parent object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusNewHandle",
                "%#x",
                hInternetMapped
                ));

    HANDLE_OBJECT * hObject = (HANDLE_OBJECT *)hInternetMapped;

    //
    // reference the new request handle, in case the app closes it in the
    // callback. The new handle now has a reference count of 2
    //

    hObject->Reference();

    //INET_ASSERT(hObject->ReferenceCount() == 3);

    //
    // we indicate the pseudo handle to the app
    //

    HINTERNET hInternet = hObject->GetPseudoHandle();

    DWORD error = InternetIndicateStatus(INTERNET_STATUS_HANDLE_CREATED,
                                         (LPVOID)&hInternet,
                                         sizeof(hInternet)
                                         );

    //
    // dereference the new request handle. If this returns TRUE then the new
    // handle has been deleted (the app called InternetCloseHandle() against
    // it which dereferenced it to 1, and now we've dereferenced it to zero)
    //

    if (hObject->Dereference()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (error == ERROR_INTERNET_OPERATION_CANCELLED) {

        //
        // the parent handle was deleted. Kill off the new handle too
        //

        BOOL ok;

        ok = hObject->Dereference();

        INET_ASSERT(ok);

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatus(
    IN DWORD dwStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwLength
    )

/*++

Routine Description:

    If the app has registered a callback function for the object that this
    thread is operating on, call it with the arguments supplied

Arguments:

    dwStatus    - INTERNET_STATUS_ value

    lpBuffer    - pointer to variable data buffer

    dwLength    - length of *lpBuffer in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatus",
                "%s, %#x, %d",
                InternetMapStatus(dwStatus),
                lpBuffer,
                dwLength
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_SUCCESS;

    //
    // the app can affect callback operation by specifying a zero context value
    // meaning no callbacks will be generated for this API
    //

    if (lpThreadInfo != NULL) {

        INET_ASSERT(lpThreadInfo->hObject != NULL);
        INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);

        //
        // if the context value in the thread info block is 0 then we use the
        // context from the handle object
        //

        DWORD_PTR context;

        context = _InternetGetContext(lpThreadInfo);
        if (context == INTERNET_NO_CALLBACK) {
            context = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetContext();
        }

        INTERNET_STATUS_CALLBACK appCallback;

        appCallback = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        IF_DEBUG(THRDINFO) {

            if (dwStatus == INTERNET_STATUS_REQUEST_COMPLETE) {

                DEBUG_PRINT(THRDINFO,
                            INFO,
                            ("REQUEST_COMPLETE: dwResult = %#x, dwError = %d [%s]\n",
                            ((LPINTERNET_ASYNC_RESULT)lpBuffer)->dwResult,
                            ((LPINTERNET_ASYNC_RESULT)lpBuffer)->dwError,
                            InternetMapError(((LPINTERNET_ASYNC_RESULT)lpBuffer)->dwError)
                            ));

            }
        }

        if ((appCallback != NULL) && (context != INTERNET_NO_CALLBACK)) {

            LPVOID pInfo;
            DWORD infoLength;
            BOOL isAsyncWorkerThread;
            BYTE buffer[256];

            //
            // we make a copy of the info to remove the app's opportunity to
            // change it. E.g. if we were about to resolve host name "foo" and
            // passed the pointer to our buffer containing "foo", the app could
            // change the name to "bar", changing the intended server
            //

            if (lpBuffer != NULL) {
                if (dwLength <= sizeof(buffer)) {
                    pInfo = buffer;
                } else {
                    pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(dwLength);
                }

                if (pInfo != NULL) {
                    memcpy(pInfo, lpBuffer, dwLength);
                    infoLength = dwLength;
                } else {
                    infoLength = 0;

                    DEBUG_PRINT(THRDINFO,
                                ERROR,
                                ("Failed to allocate %d bytes for info\n",
                                dwLength
                                ));

                }
            } else {
                pInfo = NULL;
                infoLength = 0;
            }

            //
            // we're about to call into the app. We may be in the context of an
            // async worker thread, and if the callback submits an async request
            // then we'll execute it synchronously. To avoid this, we will reset
            // the async worker thread indicator in the INTERNET_THREAD_INFO and
            // restore it when the app returns control to us. This way, if the
            // app makes an API request during the callback, on a handle that
            // has async I/O semantics, then we will simply queue it, and not
            // try to execute it synchronously
            //

            isAsyncWorkerThread = lpThreadInfo->IsAsyncWorkerThread;
            lpThreadInfo->IsAsyncWorkerThread = FALSE;

            BOOL bInCallback = lpThreadInfo->InCallback;

            lpThreadInfo->InCallback = TRUE;

            INET_ASSERT(!IsBadCodePtr((FARPROC)appCallback));

            DEBUG_ENTER((DBG_THRDINFO,
                         None,
                         "(*callback)",
                         "%#x, %#x, %s (%d), %#x [%#x], %d",
                         lpThreadInfo->hObject,
                         context,
                         InternetMapStatus(dwStatus),
                         dwStatus,
                         pInfo,
                         ((dwStatus == INTERNET_STATUS_HANDLE_CREATED)
                         || (dwStatus == INTERNET_STATUS_HANDLE_CLOSING))
                            ? (DWORD_PTR)*(LPHINTERNET)pInfo
                            : (((dwStatus == INTERNET_STATUS_REQUEST_SENT)
                            || (dwStatus == INTERNET_STATUS_RESPONSE_RECEIVED)
                            || (dwStatus == INTERNET_STATUS_INTERMEDIATE_RESPONSE)
                            || (dwStatus == INTERNET_STATUS_STATE_CHANGE))
                                ? *(LPDWORD)pInfo
                                : 0),
                         infoLength
                         ));

            PERF_LOG(PE_APP_CALLBACK_START,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            HINTERNET hObject = lpThreadInfo->hObject;
            LPVOID hObjectMapped = lpThreadInfo->hObjectMapped;

            appCallback(lpThreadInfo->hObject,
                        context,
                        dwStatus,
                        pInfo,
                        infoLength
                        );

            lpThreadInfo->hObject = hObject;
            lpThreadInfo->hObjectMapped = hObjectMapped;

            PERF_LOG(PE_APP_CALLBACK_END,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_LEAVE(0);

            lpThreadInfo->InCallback = bInCallback;
            lpThreadInfo->IsAsyncWorkerThread = isAsyncWorkerThread;

            //
            // free the buffer
            //

            if (pInfo != NULL) {
                if (dwLength > sizeof(buffer))
                    FREE_FIXED_MEMORY(pInfo);
            }

            //
            // if the object is now invalid then the app closed the handle in
            // the callback, and the entire operation is cancelled
            //

            if (((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->IsInvalidated()) {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
            }
        } else {

            DEBUG_PRINT(THRDINFO,
                        ERROR,
                        ("%#x: callback = %#x, context = %#x\n",
                        lpThreadInfo->hObject,
                        appCallback,
                        context
                        ));

            //
            // if we're completing a request then we shouldn't be here - it
            // means we lost the context or callback address somewhere along the
            // way
            //

            INET_ASSERT(dwStatus != INTERNET_STATUS_REQUEST_COMPLETE);

#ifdef DEBUG
            if ( dwStatus == INTERNET_STATUS_REQUEST_COMPLETE)
            {
                INET_ASSERT(appCallback != NULL);
                INET_ASSERT(context != INTERNET_NO_CALLBACK);
                INET_ASSERT(_InternetGetContext(lpThreadInfo) != INTERNET_NO_CALLBACK);
            }
#endif


        }
    } else {

        //
        // this is catastrophic if the indication was async request completion
        //

        DEBUG_PUT(("InternetIndicateStatus(): no INTERNET_THREAD_INFO?\n"));

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Copies the error text to the per-thread error buffer (moveable memory)

Arguments:

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetSetLastError",
                "%d, %.80q, %d, %#x",
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {
        error = _InternetSetLastError(lpThreadInfo,
                                      ErrorNumber,
                                      ErrorText,
                                      ErrorTextLength,
                                      Flags
                                      );
    } else {

        DEBUG_PUT(("InternetSetLastError(): no INTERNET_THREAD_INFO\n"));

        error = ERROR_INTERNET_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Sets or resets the last error text in an INTERNET_THREAD_INFO block

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "_InternetSetLastError",
                "%#x, %d, %.80q, %d, %#x",
                lpThreadInfo,
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD currentLength;
    DWORD newTextLength;
    DWORD error;

    newTextLength = ErrorTextLength;

    //
    // if we are appending text, then account for the '\0' currently at the end
    // of the buffer (if it exists)
    //

    if (Flags & SLE_APPEND) {
        currentLength = lpThreadInfo->ErrorTextLength;
        if (currentLength != 0) {
            --currentLength;
        }
        newTextLength += currentLength;
    }

    if (Flags & SLE_ZERO_TERMINATE) {
        ++newTextLength;
    }

    //
    // expect success (and why not?)
    //

    error = ERROR_SUCCESS;

    //
    // allocate, grow or shrink the buffer to fit. The buffer is moveable. If
    // the buffer is being shrunk to zero size then NULL will be returned as
    // the buffer handle from ResizeBuffer()
    //

    lpThreadInfo->hErrorText = ResizeBuffer(lpThreadInfo->hErrorText,
                                            newTextLength,
                                            FALSE
                                            );
    if (lpThreadInfo->hErrorText != NULL) {

        LPSTR lpErrorText;

        lpErrorText = (LPSTR)LOCK_MEMORY(lpThreadInfo->hErrorText);

        INET_ASSERT(lpErrorText != NULL);

        if (lpErrorText != NULL) {
            if (Flags & SLE_APPEND) {
                lpErrorText += currentLength;
            }
            memcpy(lpErrorText, ErrorText, ErrorTextLength);
            if (Flags & SLE_ZERO_TERMINATE) {
                lpErrorText[ErrorTextLength++] = '\0';
            }

            //
            // the text should always be zero-terminated. We expect this in
            // InternetGetLastResponseInfo()
            //

            INET_ASSERT(lpErrorText[ErrorTextLength - 1] == '\0');

            UNLOCK_MEMORY(lpThreadInfo->hErrorText);

        } else {

            //
            // real error occurred - failed to lock memory?
            //

            error = GetLastError();
        }
    } else {

        INET_ASSERT(newTextLength == 0);

        newTextLength = 0;
    }

    //
    // set the error code and text length
    //

    lpThreadInfo->ErrorTextLength = newTextLength;
    lpThreadInfo->ErrorNumber = ErrorNumber;

    DEBUG_LEAVE(error);

    return error;
}


LPSTR
InternetLockErrorText(
    VOID
    )

/*++

Routine Description:

    Returns a pointer to the locked per-thread error text buffer

Arguments:

    None.

Return Value:

    LPSTR
        Success - pointer to locked buffer

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {

        HLOCAL lpErrorText;

        lpErrorText = lpThreadInfo->hErrorText;
        if (lpErrorText != (HLOCAL)NULL) {
            return (LPSTR)LOCK_MEMORY(lpErrorText);
        }
    }
    return NULL;
}

//
//VOID
//InternetUnlockErrorText(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Unlocks the per-thread error text buffer locked by InternetLockErrorText()
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    LPINTERNET_THREAD_INFO lpThreadInfo;
//
//    lpThreadInfo = InternetGetThreadInfo();
//
//    //
//    // assume that if we locked the error text, there must be an
//    // INTERNET_THREAD_INFO when we come to unlock it
//    //
//
//    INET_ASSERT(lpThreadInfo != NULL);
//
//    if (lpThreadInfo != NULL) {
//
//        HLOCAL hErrorText;
//
//        hErrorText = lpThreadInfo->hErrorText;
//
//        //
//        // similarly, there must be a handle to the error text buffer
//        //
//
//        INET_ASSERT(hErrorText != NULL);
//
//        if (hErrorText != (HLOCAL)NULL) {
//            UNLOCK_MEMORY(hErrorText);
//        }
//    }
//}


VOID
InternetSetContext(
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sets the context value in the INTERNET_THREAD_INFO for status callbacks

Arguments:

    dwContext   - context value to remember

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        _InternetSetContext(lpThreadInfo, dwContext);
    }
}


VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    )

/*++

Routine Description:

    Sets the hObject field in the INTERNET_THREAD_INFO structure so we can get
    at the handle contents, even when we're in a function that does not take
    the hInternet as a parameter

Arguments:

    hInternet       - handle of object we may need info from

    hInternetMapped - mapped handle of object we may need info from

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }
}


HINTERNET
InternetGetObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObject value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObject;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}


HINTERNET
InternetGetMappedObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObjectMapped value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObjectMapped;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\unixwrap.cxx ===
/*
 * unixwrap.cxx
 *
 * Purpose:
 *          Implementation of Functions, to overcome following problems
 *          On Unix:
 *
 *          1. Unix map files do not support statments such as
 *              InternetTimeFromSystemTimeA
 *              InternetTimeFromSystemTimeW
 *              InternetTimeFromSystemTime=InternetTimeFromSystemTimeA
 *          2. Delay loading of functions.
 *
 * Functions:
 *          InternetTimeFromSystemTime
 *          InternetTimeToSystemTime
 *          InternetSetStatusCallback
 *          InternetConfirmZoneCrossing
 *          UnlockUrlCacheEntryFile
 *          DeleteUrlCacheEntry
 *          SetUrlCacheEntryGroup
 *          InternetShowSecurityInfoByURL
 *          InternetDial
 *          InternetSetDialState
 *          InternetGoOnline
 *          InternetGetConnectedStateEx
 *          InternetGetCertByURL
 *
 * ----- CRYPT32 Wrappers -------------------
 *          CryptDecodeObject
 *          CertFindRDNAttr
 *          CertFreeCertificateContext
 *          CryptGetProvParam
 *          CertCreateCertificateContext
 *          CertSetCertificateContextProperty
 *          CertGetCertificateContextProperty
 *          CertNameToStrA
 *          CryptSetProvParam
 *          CertRDNValueToStrA
 *          CryptReleaseContext
 *          CertDuplicateCertificateContext
 *          CertCloseStore
 *          CertControlStore
 *          CertOpenSystemStoreA
 *          CryptAcquireContextA
 *          CertFindCertificateInStore
 */ 

#include <wininetp.h>

/*****************************************************************************/
/*================= Begin of the delay loading definitions ==================*/
/*****************************************************************************/

/*
 * Delay loading mechanism.  This allows you to write code as if you are
 * calling implicitly linked APIs, and yet have these APIs really be
 * explicitly linked.  You can reduce the initial number of DLLs that 
 * are loaded (load on demand) using this technique.
 *
 * Use the following macros to indicate which APIs/DLLs are delay-linked
 * and -loaded.
 *
 *      DELAY_LOAD
 *      DELAY_LOAD_HRESULT
 *      DELAY_LOAD_SAFEARRAY
 *      DELAY_LOAD_UINT
 *      DELAY_LOAD_INT
 *      DELAY_LOAD_VOID
 *
 */

#define ENSURE_LOADED(_hmod, _dll, _ext, pszfn)         \
    (_hmod ? (_hmod) : (_hmod = LoadLibraryA(#_dll "." #_ext)))

void _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    /*
     * If it's already loaded, return.
     */
    if (*ppfn) {
        return;
    }

    if (*phmod == NULL)
    {
       *phmod = LoadLibraryA(pszDLL);
       if (*phmod == NULL)
       {
          return;
       }
    }

    *ppfn = GetProcAddress(*phmod, pszProc);
}

/*
 * NOTE: this takes two parameters that are the function name.
 * the First (_fn) is the name that the function will be called in 
 * this DLL and the other (_fni) is the name of the function we 
 * will GetProcAddress. This helps get around functions that
 * are defined in the header files with _declspec...
 * 
 *  HMODULE _hmod - where we cache the HMODULE (aka HINSTANCE)
 *           _dll - Basename of the target DLL, not quoted
 *           _ext - Extension of the target DLL, not quoted (usually DLL)
 *           _ret - Data type of return value
 *        _fnpriv - Local name for the function
 *            _fn - Exported name for the function
 *          _args - Argument list in the form (TYPE1 arg1, TYPE2 arg2, ...)
 *         _nargs - Argument list in the form (arg1, arg2, ...)
 *           _err - Return value if we can't call the actual function
 */
#define DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hmod, #_dll "." #_ext, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_NAME_ERR(_hmod, _dll,       _ret, _fnpriv, _fn, _args, _nargs, _err) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll,  DLL, _ret, _fnpriv, _fn, _args, _nargs, _err)

#define DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn,      _args, _nargs, _err) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hmod, _dll, _ret, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn, _args, _nargs, 0)

#define DELAY_LOAD_HRESULT(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)

#define DELAY_LOAD_SAFEARRAY(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)

#define DELAY_LOAD_UINT(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, UINT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_INT(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_BOOL(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, BOOL, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_BOOLEAN(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, BOOLEAN, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_DWORD(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_WNET(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, WN_NOT_SUPPORTED)

/*
 * the NAME variants allow the local function to be called something different from the imported
 * function to avoid dll linkage problems.
 */
#define DELAY_LOAD_NAME(_hmod, _dll, _ret, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_HRESULT(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, HRESULT, _fn, _fni, _args, _nargs, E_FAIL)

#define DELAY_LOAD_NAME_SAFEARRAY(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, SAFEARRAY *, _fn, _fni, _args, _nargs, NULL)

#define DELAY_LOAD_NAME_UINT(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, UINT, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_BOOL(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, BOOL, _fn, _fni, _args, _nargs, FALSE)

#define DELAY_LOAD_NAME_DWORD(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, DWORD, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fni, _args, _nargs)                             \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (__stdcall *_pfn##_fni) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hmod, _dll, DLL, TEXT(#_fni)))                                       \
    {                                                                                   \
        AssertMsg(BOOLFROMPTR(_hmod), TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fni == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fni) = GetProcAddress(_hmod, #_fni);                         \
        AssertMsg(BOOLFROMPTR(_pfn##_fni), TEXT("GetProcAddress failed on ") ## TEXT(#_fni));    \
        if (_pfn##_fni == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fni _nargs;                                                                   \
}

#define DELAY_LOAD_VOID(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fn, _args, _nargs)

#define DELAY_LOAD_EXT(_hmod, _dll, _ext, _ret, _fn, _args, _nargs) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fn, _fn, _args, _nargs, 0)

/*****************************************************************************/
/*================= End   of the delay loading definitions ==================*/
/*****************************************************************************/

/*************************************/
/*=== Begin: Wrappers for CRYPT32 ===*/
/*************************************/

HINSTANCE g_hinstCRYPT32 = NULL;

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE* pbEncoded, DWORD cbEncoded, DWORD dwFlags, void* pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo ))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName), (pszObjId, pName))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext), (pCertContext))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptGetProvParam,
    (HCRYPTPROV hProv, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags), (hProv, dwParam, pbData, pdwDataLen, dwFlags))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, PCCERT_CONTEXT, CertCreateCertificateContext,
    (DWORD dwCertEncodingType, const BYTE* pbCertEncoded, DWORD cbCertEncoded),
    (dwCertEncodingType, pbCertEncoded, cbCertEncoded))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertSetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void* pvData), (pCertContext, dwPropId, dwFlags, pvData))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void* pvData, DWORD* pcbData),
    (pCertContext, dwPropId, pvData, pcbData))

#ifdef UNICODE
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, DWORD, CertNameToStrW,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz))
#else
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, DWORD, CertNameToStrA,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz))
#endif /* UNICODE */

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptSetProvParam,
    (HCRYPTPROV hProv, DWORD dwParam, BYTE* pbData, DWORD dwFlags),
    (hProv, dwParam, pbData, dwFlags))

#ifdef UNICODE
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, DWORD, CertRDNValueToStrW,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz),
    (dwValueType, pValue, psz, csz))
#else
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, DWORD, CertRDNValueToStrA,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz),
    (dwValueType, pValue, psz, csz))
#endif /* UNICODE */

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags), (hProv, dwFlags))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext), (pCertContext))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags), (hCertStore, dwFlags))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertControlStore,
    (HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, void const* pvCtrlPara),
    (hCertStore, dwFlags, dwCtrlType, pvCtrlPara))

#ifdef UNICODE
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, HCERTSTORE, CertOpenSystemStoreW,
    (HCRYPTPROV hProv, LPCWSTR szSubsystemProtocol),
    (hProv, szSubsystemProtocol))
#else
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, HCERTSTORE, CertOpenSystemStoreA,
    (HCRYPTPROV hProv, LPCSTR szSubsystemProtocol),
    (hProv, szSubsystemProtocol))
#endif /* UNICODE */

#ifdef UNICODE
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptAcquireContextW,
    (HCRYPTPROV* phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags))
#else
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptAcquireContextA,
    (HCRYPTPROV* phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags))
#endif /* UNICODE */

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void* pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext))

/*************************************/
/*=== End:   Wrappers for CRYPT32 ===*/
/*************************************/

/* In wininet.def, we don't support statements like
 * InternetTimeFromSystemTime=InternetTimeFromSystemTimeA
 * So, on Unix, we create a wrapper for InternetTimeFromSystemTime which will
 * call the corresponding ANSI function.
 *
 * The following are all such wrappers ----
 */

extern "C" {

#ifdef InternetTimeFromSystemTime
#undef InternetTimeFromSystemTime
#endif

INTERNETAPI_(BOOL) InternetTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    ) {
    return InternetTimeFromSystemTimeA(pst, dwRFC, lpszTime, cbTime);
}

#ifdef InternetTimeToSystemTime
#undef InternetTimeToSystemTime
#endif

INTERNETAPI_(BOOL) InternetTimeToSystemTime(
    IN  LPCSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved )
{
    return InternetTimeToSystemTimeA(lpcszTimeString, lpSysTime, dwReserved);
}

#ifdef InternetSetStatusCallback
#undef InternetSetStatusCallback
#endif

INTERNETAPI_(BOOL) InternetSetStatusCallback(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )
{
    return InternetSetStatusCallbackA(hInternet, lpfnInternetCallback);
}

#ifdef InternetConfirmZoneCrossing
#undef InternetConfirmZoneCrossing
#endif

INTERNETAPI_(BOOL) InternetConfirmZoneCrossing(
    IN HWND hWnd,
    IN LPSTR szUrlPrev,
    IN LPSTR szUrlNew,
    BOOL bPost
    )
{
    return InternetConfirmZoneCrossingA(hWnd, szUrlPrev, szUrlNew, bPost);
}

#ifdef UnlockUrlCacheEntryFile
#undef UnlockUrlCacheEntryFile
#endif

URLCACHEAPI_(BOOL) UnlockUrlCacheEntryFile(
    LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
{
    return UnlockUrlCacheEntryFileA(lpszUrlName,dwReserved);
}

#ifdef DeleteUrlCacheEntry
#undef DeleteUrlCacheEntry
#endif

URLCACHEAPI_(BOOL) DeleteUrlCacheEntry(
    IN LPCSTR lpszUrlName
    )
{
    return DeleteUrlCacheEntryA(lpszUrlName);
}

#ifdef SetUrlCacheEntryGroup
#undef SetUrlCacheEntryGroup
#endif

BOOLAPI SetUrlCacheEntryGroup(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    return SetUrlCacheEntryGroupA(lpszUrlName, dwFlags, GroupId, pbGroupAttributes,
                                  cbGroupAttributes, lpReserved);
}

#ifdef InternetShowSecurityInfoByURL
#undef InternetShowSecurityInfoByURL
#endif

INTERNETAPI_(BOOL) InternetShowSecurityInfoByURL(
    IN LPSTR     lpszURL,
    IN HWND      hwndRootWindow
    )
{
    return InternetShowSecurityInfoByURLA(lpszURL, hwndRootWindow);
}

#ifdef InternetDial
#undef InternetDial
#endif

DWORD InternetDial(HWND hwndParent, LPSTR pszConnectoid, DWORD dwFlags,
    LPDWORD lpdwConnection, DWORD dwReserved)
{
    return InternetDialA(hwndParent, pszConnectoid, dwFlags, lpdwConnection, dwReserved);
}

#ifdef InternetSetDialState
#undef InternetSetDialState
#endif

BOOLAPI InternetSetDialState(LPCSTR lpszConnectoid, DWORD dwState, DWORD dwReserved)
{
        return InternetSetDialStateA(lpszConnectoid, dwState, dwReserved);
}

#ifdef InternetGoOnline
#undef InternetGoOnline
#endif

BOOLAPI InternetGoOnline(LPSTR lpszURL, HWND hwndParent, DWORD dwFlags)
{
        return InternetGoOnlineA(lpszURL, hwndParent, dwFlags);
}

#ifdef InternetGetConnectedStateEx
#undef InternetGetConnectedStateEx
#endif

BOOL InternetGetConnectedStateEx(
    LPDWORD lpdwFlags,
    LPSTR lpszConnectionName,
    DWORD dwBufLen,
    DWORD dwReserved)
{
    return InternetGetConnectedStateExA(lpdwFlags, lpszConnectionName, dwBufLen, dwReserved);
}

#ifdef InternetGetCertByURL
#undef InternetGetCertByURL
#endif

INTERNETAPI_(BOOL) InternetGetCertByURLA(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    );

INTERNETAPI_(BOOL) InternetGetCertByURL(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
{
    return InternetGetCertByURLA(lpszURL, lpszCertText, dwcbCertText);
}


#ifdef HttpCheckDavCompliance
#undef HttpCheckDavCompliance
#endif

INTERNETAPI_(BOOL) HttpCheckDavComplianceA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszComplianceToken,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    );

INTERNETAPI_(BOOL) HttpCheckDavCompliance(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszComplianceToken,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    )
{
    return HttpCheckDavComplianceA(lpszUrl,
                                   lpszComplianceToken,
                                   lpfFound,
                                   hWnd,
                                   lpvReserved);
}

#ifdef DAVCACHING // commenting out as per bug 15696

#ifdef HttpCheckCachedDavStatus
#undef HttpCheckCachedDavStatus
#endif

INTERNETAPI_(BOOL) HttpCheckCachedDavStatusA(
    IN LPCSTR lpszUrl,
    IN OUT LPDWORD lpdwStatus
    );

INTERNETAPI_(BOOL) HttpCheckCachedDavStatus(
    IN LPCSTR lpszUrl,
    IN OUT LPDWORD lpdwStatus
    )
{
    return HttpCheckCachedDavStatusA(lpszUrl, lpdwStatus);
}

#endif /* DAVCACHING */

#ifndef UNIX_BUILDS_AUTOPROXY_DETECT
/* Stub function if apdetect is not included in build */
STDAPI_(BOOL)
DetectAutoProxyUrl(
    IN OUT LPSTR lpszAutoProxyUrl,
    IN DWORD dwAutoProxyUrlLength,
    IN DWORD dwDetectFlags
    )
{
    return FALSE;
}
#endif /* UNIX_BUIDS_AUTOPROXY_DETECT */


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\test\dbginfo\dbginfo.c ===
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <windows.h>
#include <wininet.h>
#include <wininetd.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
LPVOID get_and_dump_debug_info(LPDWORD);
void dump_internet_debug_info(LPINTERNET_DEBUG_INFO);

void _CRTAPI1 main(int argc, char** argv) {

    BOOL ok;
    DWORD length;
    LPVOID buf;
    DWORD inlength;
    LPVOID buf2;
    HINTERNET hInternet;
    HINTERNET hGopher;
    char locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
    HINTERNET hFind;
    GOPHER_FIND_DATA data;

    buf = get_and_dump_debug_info(&length);
    inlength = length;
    length += sizeof("mydebug.log");
    buf2 = malloc(length);
    if (!buf2) {
        printf("error: failed to allocate %d bytes\n", length);
        exit(1);
    }

    memcpy(buf2, buf, inlength);
    free(buf);

    ((LPINTERNET_DEBUG_INFO)buf2)->CategoryFlags = 0xffffffff;
    ((LPINTERNET_DEBUG_INFO)buf2)->ControlFlags = 0x7df;
    strcpy(((LPINTERNET_DEBUG_INFO)buf2)->Filename, "mydebug.log");

    ok = InternetSetOption(NULL,
                           INTERNET_OPTION_SET_DEBUG_INFO,
                           buf2,
                           length
                           );
    if (!ok) {
        printf("error: InternetSetOption() returns %d\n", GetLastError());
        exit(1);
    }

    //
    // make sure we set it
    //

    buf = get_and_dump_debug_info(&length);
    free(buf);

    //
    // try generating some debug info
    //

    hInternet = InternetOpen("dbginfo",
                             PRE_CONFIG_INTERNET_ACCESS,
                             NULL,
                             0,
                             0
                             );
    if (!hInternet) {
        printf("error: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    }

    hGopher = InternetConnect(hInternet,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              INTERNET_SERVICE_GOPHER,
                              0,
                              0
                              );
    if (!hGopher) {
        printf("error: InternetConnect() returns %d\n", GetLastError());
    }

    length = sizeof(locator);
    if (!GopherCreateLocator("rfirthmips",
                             0,
                             NULL,
                             NULL,
                             GOPHER_TYPE_DIRECTORY,
                             locator,
                             &length
                             )) {
        printf("error: GopherCreateLocator() returns %d\n", GetLastError());
        exit(1);
    }

    hFind = GopherFindFirstFile(hGopher,
                                locator,
                                NULL,
                                &data,
                                0
                                );
    if (!hFind) {
        printf("error: GopherFindFirstFile() returns %d\n", GetLastError());
    }

    free(buf2);
    exit(0);
}

LPVOID get_and_dump_debug_info(LPDWORD outLen) {

    BOOL ok;
    DWORD length;
    DWORD error;
    LPVOID buf;
    DWORD inlength;

    length = 0;
    ok = InternetQueryOption(NULL,
                             INTERNET_OPTION_GET_DEBUG_INFO,
                             (LPVOID)0x1234,
                             &length
                             );
    if (ok) {
        printf("error: InternetQueryOption() with zero length returns TRUE\n");
        exit(1);
    }

    error = GetLastError();
    if (error != ERROR_INSUFFICIENT_BUFFER) {
        printf("error: InternetQueryOption() with zero length returns %d\n", error);
    }

    printf("InternetQueryOption() with zero length returns %d\n", error);
    printf("length = %d\n", length);

    length = 65535;
    ok = InternetQueryOption(NULL,
                             INTERNET_OPTION_GET_DEBUG_INFO,
                             NULL,
                             &length
                             );
    if (ok) {
        printf("error: InternetQueryOption() with no buffer returns %d\n", error);
        exit(1);
    }

    error = GetLastError();
    if (error != ERROR_INSUFFICIENT_BUFFER) {
        printf("error: InternetQueryOption() with no buffer returns %d\n", error);
    }

    printf("InternetQueryOption() with no buffer returns %d\n", error);
    printf("length = %d\n", length);

    buf = malloc(length);
    if (!buf) {
        printf("error: failed to allocate %d bytes\n", length);
        exit(1);
    }

    inlength = length;
    ok = InternetQueryOption(NULL,
                             INTERNET_OPTION_GET_DEBUG_INFO,
                             buf,
                             &length
                             );
    if (!ok) {
        printf("error: InternetQueryOption() with %d byte buffer returns %d. Length = %d\n",
                inlength,
                GetLastError(),
                length
                );
        exit(1);
    }
    printf("InternetQueryOption() returns %d byte buffer\n", length);
    dump_internet_debug_info((LPINTERNET_DEBUG_INFO)buf);
    *outLen = length;
    return buf;
}

void dump_internet_debug_info(LPINTERNET_DEBUG_INFO info) {
    printf("ErrorLevel      = %d\n"
           "ControlFlags    = %x\n"
           "CategoryFlags   = %x\n"
           "BreakFlags      = %x\n"
           "IndentIncrement = %d\n"
           "Filename        = \"%s\"\n"
           "\n",
           info->ErrorLevel,
           info->ControlFlags,
           info->CategoryFlags,
           info->BreakFlags,
           info->IndentIncrement,
           info->Filename
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\test\contype\contype.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
void usage(void);

BOOL Verbose = FALSE;

void _CRTAPI1 main(int argc, char** argv) {

    LPSTR lpszUrl = NULL;
    HINTERNET hInternet;
    HINTERNET hRequest;
    char buf[256];
    DWORD buflen = sizeof(buf);

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else if (!lpszUrl) {
            lpszUrl = *argv;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    hInternet = InternetOpen("contype", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (!hInternet) {
        print_error("contype()", "InternetOpen()");
        exit(1);
    }
    hRequest = InternetOpenUrl(hInternet, lpszUrl, "Accept: */*", -1, 0, 0);
    if (!hRequest) {
        print_error("contype()", "InternetOpenUrl()");
        exit(1);
    }

    if (!HttpQueryInfo(hRequest, HTTP_QUERY_CONTENT_TYPE, buf, &buflen, NULL)) {
        print_error("contype()", "HttpQueryInfo()");
        exit(1);
    }

    printf("URL \"%s\": Content-Type: \"%s\"\n", lpszUrl, buf);

    InternetCloseHandle(hRequest);
    InternetCloseHandle(hInternet);
    exit(0);
}

void usage() {
    printf("usage: contype\n"
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\test\openurl\openurl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    openurl.c

Abstract:

    Tests InternetOpenUrl()

Author:

    Richard L Firth (rfirth) 29-May-1995

Revision History:

    29-May-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#define VERSION_STRING  "1.0"

#define URL_CONTEXT             0x55785875  // UxXu
#define DEFAULT_BUFFER_LENGTH   1021        // odd number for fun!

//
// prototypes
//

void _CRTAPI1 main(int, char**);
void usage(void);
void _CRTAPI1 my_cleanup(void);
void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);
void default_url_test(LPSTR, DWORD, DWORD);
void open_urls(LPSTR*, int, LPSTR, DWORD, DWORD);
void get_url_data(HINTERNET);
void ftp_find(HINTERNET);
void gopher_find(HINTERNET);
void read_data(HINTERNET);
void get_request_flags(HINTERNET);

//
// data
//

BOOL Verbose = FALSE;
HINTERNET InternetHandle = NULL;
INTERNET_STATUS_CALLBACK PreviousCallback;
HINTERNET hCancel;
BOOL AsyncMode = FALSE;
HANDLE AsyncEvent = NULL;
DWORD AsyncResult;
DWORD AsyncError;
BOOL UseQueryData = FALSE;
BOOL NoDump = FALSE;
DWORD BufferLength = DEFAULT_BUFFER_LENGTH;
DWORD ReadLength = DEFAULT_BUFFER_LENGTH;

LPSTR default_urls[] = {

    //
    // WEB
    //

    "http://www.microsoft.com",
    "http://www.microsoft.com/pages/misc/whatsnew.htm",

    //
    // gopher
    //

    "gopher://gopher.microsoft.com",
    "gopher://gopher.microsoft.com/11/msft/",
    "gopher://gopher.microsoft.com/00\\welcome.txt",
    "gopher://gopher.tc.umn.edu/11Information%20About%20Gopher%09%09%2B",
    "gopher://spinaltap.micro.umn.edu/11/computer",
    "gopher://mudhoney.micro.umn.edu:4325/7",
    "gopher://mudhoney.micro.umn.edu:4325/7%09gopher",
    "gopher://spinaltap.micro.umn.edu/7mindex:lotsoplaces%09gopher%09%2b",

    //
    // FTP
    //

    "ftp://ftp.microsoft.com",
    "ftp://ftp.microsoft.com/MSNBRO.TXT",
    "ftp://ftp.microsoft.com/Services/"
};

#define NUMBER_OF_DEFAULT_URLS  (sizeof(default_urls)/sizeof(default_urls[0]))

//
// functions
//

void _CRTAPI1 main(int argc, char** argv) {

    BOOL ok;
    LPSTR urls[64];
    int numberOfUrls = 0;
    BOOL fCallback = FALSE;
    LPSTR headers = NULL;
    BOOL expectingHeaders = FALSE;
    DWORD accessMethod = INTERNET_OPEN_TYPE_PRECONFIG;
    LPSTR proxyServer = NULL;
    BOOL expectingProxy = FALSE;
    DWORD context = 0;
    DWORD flags = 0;
    LPSTR endptr;

    printf("\n"
           "OpenUrl  Version " VERSION_STRING "  " __DATE__ "\n"
           "\n"
           );

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case '?':
                usage();
                break;

            case 'a':
                ++*argv;
                if (**argv == 'l') {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                    if (*++*argv) {
                        proxyServer = *argv;
                    } else {
                        expectingProxy = TRUE;
                    }
                } else {
                    printf("error: unrecognised access type: '%c'\n", **argv);
                    usage();
                }
                break;

            case 'b':
                BufferLength = (DWORD)strtol(++*argv, &endptr, 0);
                if (*endptr == 'K' || *endptr == 'k') {
                    BufferLength *= 1024;
                }
                break;

            case 'c':
                fCallback = TRUE;
                break;

            case 'd':
                NoDump = TRUE;
                break;

            case 'e':
                flags |= INTERNET_FLAG_EXISTING_CONNECT;
                break;

            case 'h':
                if (*++*argv) {
                    headers = *argv;
                } else {
                    expectingHeaders = TRUE;
                }
                break;

            case 'l':
                ReadLength = (DWORD)strtol(++*argv, &endptr, 0);
                if (*endptr == 'K' || *endptr == 'k') {
                    ReadLength *= 1024;
                }
                break;

            case 'n':
                flags |= INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE;
                break;

            case 'p':
                flags |= INTERNET_FLAG_PASSIVE;
                break;

            case 'q':
                UseQueryData = TRUE;
                break;

            case 'r':
                flags |= INTERNET_FLAG_RAW_DATA;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            case 'x':
                context = URL_CONTEXT;
                break;

            case 'y':
                AsyncMode = TRUE;
                break;

            default:
                printf("unknown command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxy) {
            proxyServer = *argv;
            expectingProxy = FALSE;
        } else if (expectingHeaders) {
            headers = *argv;
            expectingHeaders = FALSE;
        } else {
            if (numberOfUrls == sizeof(urls)/sizeof(urls[0]) - 1) {
                break;
            }
            urls[numberOfUrls++] = *argv;
        }
    }

    if (BufferLength < ReadLength) {
        BufferLength = ReadLength;
    }

    //
    // exit function
    //

    atexit(my_cleanup);

    if (AsyncMode) {

        //
        // create an auto-reset, initially unsignalled event
        //

        AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!AsyncEvent) {
            print_error("OpenUrl", "CreateEvent()");
            exit(1);
        }
    }

    //
    // get a handle to the internet - local, gateway or CERN proxy
    //

    InternetHandle = InternetOpen("OpenUrl",
                                  accessMethod,
                                  proxyServer,
                                  NULL,
                                  AsyncMode ? INTERNET_FLAG_ASYNC : 0
                                  );
    if (InternetHandle == NULL) {
        print_error("openurl()", "InternetOpen()");
        exit(1);
    }

    if (Verbose) {
        printf("InternetOpen() returns handle %x\n", InternetHandle);
    }

    //
    // let's have a status callback
    //

    if (fCallback) {
        PreviousCallback = InternetSetStatusCallback(InternetHandle, my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    if (numberOfUrls == 0) {
        default_url_test(headers, flags, context);
    } else {
        open_urls(urls, numberOfUrls, headers, flags, context);
    }

    if (Verbose) {
        printf("closing InternetHandle (%x)\n", InternetHandle);
    }
    ok = InternetCloseHandle(InternetHandle);
    if (!ok) {
        print_error("openurl()", "InternetClose(%x)", InternetHandle);
        exit(1);
    } else {
        InternetHandle = NULL;
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("\n"
           "usage: openurl [-a{l|p}[[ ]{server[:port]}] [-b#] [-c] [-d] [-h[ ]{headers}]\n"
           "               [-l#] [-n] [-p] [-q] [-r] [-v] [-x] [-y] [url]*\n"
           "\n"
           "where:  -al = local internet access\n"
           "        -ap = CERN proxy internet access\n"
           "         -b = buffer size\n"
           "         -c = enable status callbacks\n"
           "         -d = don't dump data\n"
           "         -e = use existing connection\n"
           "         -h = headers\n"
           "         -l = read length\n"
           "         -n = don't use cache\n"
           "         -p = PASSIVE mode (FTP transfers)\n"
           "         -q = use InternetQueryDataAvailable\n"
           "         -r = raw data. Default is HTML for FTP and gopher directories\n"
           "         -v = Verbose mode\n"
           "         -x = use context value when calling InternetOpenUrl()\n"
           "         -y = Async mode\n"
           "\n"
           "     server = gateway server or proxy server name\n"
           "      :port = (optional) CERN proxy port\n"
           "        url = one or more URLs to open\n"
           "\n"
           "Default internet access is pre-configured (i.e. use settings in registry)\n"
           );
    exit(1);
}

void _CRTAPI1 my_cleanup() {
    if (InternetHandle != NULL) {
        if (Verbose) {
            printf("closing Internet handle %x\n", InternetHandle);
        }
        if (!InternetCloseHandle(InternetHandle)) {
            print_error("my_cleanup", "InternetCloseHandle(%x)", InternetHandle);
        }
    }
}

VOID
my_callback(
    HINTERNET hInternet,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;
    DWORD handleType;
    DWORD size;

    size = sizeof(handleType);
    if (!InternetQueryOption(hInternet,
                             INTERNET_OPTION_HANDLE_TYPE,
                             (LPVOID)&handleType,
                             &size)) {
        print_error("my_callback", "InternetQueryOption(HANDLE_TYPE)");
    } else {
        switch (handleType) {
        case INTERNET_HANDLE_TYPE_INTERNET:
            type$ = "Internet";
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_FTP:
            type$ = "FTP Connect";
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
            type$ = "Gopher Connect";
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
            type$ = "HTTP Connect";
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND:
            type$ = "FTP Find";
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
            type$ = "FTP Find HTML";
            break;

        case INTERNET_HANDLE_TYPE_FTP_FILE:
            type$ = "FTP File";
            break;

        case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
            type$ = "FTP File HTML";
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND:
            type$ = "Gopher Find";
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
            type$ = "Gopher Find HTML";
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FILE:
            type$ = "Gopher File";
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
            type$ = "Gopher File HTML";
            type$ = "Internet";
            break;

        case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
            type$ = "HTTP Request";
            break;

        default:
            type$ = "???";
        }
        printf("callback: handle %x = %s\n", hInternet, type$);
    }

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        hCancel = *(LPHINTERNET)Info;
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                hInternet,
                Context,
                (Context == URL_CONTEXT) ? "UrlContext" : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {
                printf("%x", *(LPHINTERNET)Info);
            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else if (Status != INTERNET_STATUS_REQUEST_COMPLETE) {
                printf(Info);
            }
        }
        putchar('\n');
    }
    if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
        if (AsyncMode) {
            SetEvent(AsyncEvent);
        } else {
            printf("error: INTERNET_STATUS_REQUEST_COMPLETE received when not async\n");
        }
    }
}

void default_url_test(LPSTR headers, DWORD flags, DWORD context) {
    open_urls(default_urls, NUMBER_OF_DEFAULT_URLS, headers, flags, context);
}

void open_urls(LPSTR* purls, int nurls, LPSTR headers, DWORD flags, DWORD context) {

    HINTERNET handle;

    if (headers) {

        LPSTR h;

        for (h = headers; *h; ++h) {
            if (*h == '\\' && *(h + 1) == 'n') {
                *h++ = '\r';
                *h = '\n';
            }
        }
    }
    while (nurls--) {
        if (Verbose) {
            printf("\nopening URL \"%s\"\n\n", *purls);
        }
        handle = InternetOpenUrl(InternetHandle,
                                 *purls,
                                 headers,
                                 headers ? -1 : 0,
                                 flags,
                                 context
                                 );
        if ((handle == NULL) && AsyncMode) {

            DWORD err;

            err = GetLastError();
            if (err == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("waiting for async InternetOpenUrl()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                handle = (HINTERNET)AsyncResult;
                SetLastError(AsyncError);
            }
        } else if (AsyncMode && Verbose) {
            printf("async InternetOpenUrl() returns sync result\n");
        }

        if (handle == NULL) {
            print_error("open_urls", "InternetOpenUrl(%s)", *purls);
        } else {
            if (Verbose) {
                printf("InternetOpenUrl() returns handle %x\n", handle);
            }
            get_request_flags(handle);
            get_url_data(handle);
        }

        ++purls;
    }
}

void get_url_data(HINTERNET handle) {

    DWORD handleType;
    DWORD handleTypeLen;

    handleTypeLen = sizeof(handleType);
    if (InternetQueryOption(handle,
                            INTERNET_OPTION_HANDLE_TYPE,
                            (LPVOID)&handleType,
                            &handleTypeLen
                            )) {
        switch (handleType) {
        case INTERNET_HANDLE_TYPE_INTERNET:
            printf("error: get_url_data: HANDLE_TYPE_INTERNET?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_FTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_FTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_GOPHER?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_HTTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND:
            ftp_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND:
            gopher_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
        case INTERNET_HANDLE_TYPE_FTP_FILE:
        case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
        case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
        case INTERNET_HANDLE_TYPE_GOPHER_FILE:
        case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
        case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
            read_data(handle);
            break;

        default:
            printf("error: get_url_data: handleType == %d?\n", handleType);
            break;
        }
        if (Verbose) {
            printf("closing Internet handle %x\n", handle);
        }
        if (!InternetCloseHandle(handle)) {
            print_error("get_url_data", "InternetCloseHandle(%x)", handle);
        }
    } else {
        print_error("get_url_data", "InternetQueryOption()");
    }
}

void ftp_find(HINTERNET handle) {

    WIN32_FIND_DATA data;
    BOOL ok;

    do {

        SYSTEMTIME systemTime;

        ok = InternetFindNextFile(handle, (LPVOID)&data);
        if (!ok) {
            if (AsyncMode) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetFindNextFile()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    SetLastError(AsyncError);
                }
            }
        }
        if (ok && !NoDump) {
            if (!FileTimeToSystemTime(&data.ftLastWriteTime, &systemTime)) {
                print_error("ftp_find", "FileTimeToSystemTime()");
            }

            printf("%2d-%02d-%04d %2d:%02d:%02d  %15d bytes %-s%-s%-s %s\n",
                   systemTime.wMonth,
                   systemTime.wDay,
                   systemTime.wYear,
                   systemTime.wHour,
                   systemTime.wMinute,
                   systemTime.wSecond,
                   data.nFileSizeLow,
                   (data.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)
                    ? "Normal    " : "",
                   (data.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
                    ? "ReadOnly  " : "",
                   (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    ? "Directory " : "",
                   data.cFileName
                   );
        }
    } while (ok);

    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("ftp_find", "InternetFindNextFile()");
    }
}

void gopher_find(HINTERNET handle) {

    GOPHER_FIND_DATA data;
    BOOL ok;
    int i;

    i = 0;
    do {
        ok = InternetFindNextFile(handle, (LPVOID)&data);
        if (!ok) {
            if (AsyncMode) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetFindNextFile()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    SetLastError(AsyncError);
                }
            }
        }
        if (ok && !NoDump) {

            LPGOPHER_FIND_DATA p;
            SYSTEMTIME systemTime;
            char timeBuf[9];
            char sizeBuf[32];

            p = (LPGOPHER_FIND_DATA)&data;
            if ((p->LastModificationTime.dwLowDateTime != 0)
            && (p->LastModificationTime.dwHighDateTime != 0)) {
                FileTimeToSystemTime(&p->LastModificationTime, &systemTime);
                sprintf(timeBuf,
                        "%02d-%02d-%02d",
                        systemTime.wMonth,
                        systemTime.wDay,
                        systemTime.wYear % 100
                        );
                sprintf(sizeBuf, "%d", p->SizeLow);
            } else {
                timeBuf[0] = '\0';
                sizeBuf[0] = '\0';
            }
            printf("%5d %c %7s %10s %8s %s\n",
                    i,
                    (p->GopherType & GOPHER_TYPE_GOPHER_PLUS) ? '+' : ' ',
                    (p->GopherType & GOPHER_TYPE_TEXT_FILE)         ? "Text"
                    : (p->GopherType & GOPHER_TYPE_DIRECTORY)       ? "Dir"
                    : (p->GopherType & GOPHER_TYPE_CSO)             ? "Phone"
                    : (p->GopherType & GOPHER_TYPE_ERROR)           ? "Error"
                    : (p->GopherType & GOPHER_TYPE_MAC_BINHEX)      ? "MAC"
                    : (p->GopherType & GOPHER_TYPE_DOS_ARCHIVE)     ? "Archive"
                    : (p->GopherType & GOPHER_TYPE_UNIX_UUENCODED)  ? "UNIX"
                    : (p->GopherType & GOPHER_TYPE_INDEX_SERVER)    ? "Index"
                    : (p->GopherType & GOPHER_TYPE_TELNET)          ? "Telnet"
                    : (p->GopherType & GOPHER_TYPE_BINARY)          ? "Binary"
                    : (p->GopherType & GOPHER_TYPE_REDUNDANT)       ? "Backup"
                    : (p->GopherType & GOPHER_TYPE_TN3270)          ? "TN3270"
                    : (p->GopherType & GOPHER_TYPE_GIF)             ? "GIF"
                    : (p->GopherType & GOPHER_TYPE_IMAGE)           ? "Image"
                    : (p->GopherType & GOPHER_TYPE_BITMAP)          ? "Bitmap"
                    : (p->GopherType & GOPHER_TYPE_MOVIE)           ? "Movie"
                    : (p->GopherType & GOPHER_TYPE_SOUND)           ? "Sound"
                    : (p->GopherType & GOPHER_TYPE_HTML)            ? "HTML"
                    : (p->GopherType & GOPHER_TYPE_PDF)             ? "PDF"
                    : (p->GopherType & GOPHER_TYPE_CALENDAR)        ? "Cal"
                    : (p->GopherType & GOPHER_TYPE_INLINE)          ? "Inline"
                    : (p->GopherType & GOPHER_TYPE_UNKNOWN)         ? "Unknown"
                    : "\a????",
                    sizeBuf,
                    timeBuf,
                    p->DisplayString
                    );
            ++i;
        }
    } while (ok);

    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("gopher_find", "InternetFindNextFile()");
    }
}

void read_data(HINTERNET handle) {

    char* buf;
    DWORD nread;
    BOOL ok;
    int mode;

    buf = (char*)malloc(BufferLength);
    if (!buf) {
        printf("error: failed to allocate %d bytes for buffer\n", BufferLength);
        return;
    }

    mode = _setmode(1, _O_BINARY);

    do {

        DWORD avail;
        int i;

        if (UseQueryData) {
            ok = InternetQueryDataAvailable(handle, &avail, 0, 0);
            if (!ok) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetQueryDataAvailable()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    SetLastError(AsyncError);
                }
            }
            if (!ok) {
                print_error("read_file", "InternetQueryDataAvailable()");
                break;
            }

            if (Verbose) {
                printf("InternetQueryDataAvailable() returns %d bytes\n", avail);
            }
        } else {
            avail = BufferLength;
        }

        avail = min(avail, ReadLength);

        for (i = 0; i < 2; ++i) {
            memset(buf, '@', avail);
            ok = InternetReadFile(handle, buf, avail, &nread);
            if (!ok) {
                if (AsyncMode) {
                    if (GetLastError() == ERROR_IO_PENDING) {
                        if (Verbose) {
                            printf("waiting for async InternetFindNextFile()...\n");
                        }
                        WaitForSingleObject(AsyncEvent, INFINITE);
                        ok = (BOOL)AsyncResult;
                        SetLastError(AsyncError);
                    }
                } else {
                    break;
                }
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    if (i == 1) {
                        printf("error: failed to read %d bytes in 2 attempts\n",
                            nread);
                        goto quit;
                    }

                    //
                    // second attempt with all buffer
                    //

                    avail = BufferLength;
                } else {
                    break;
                }
            }
        }
        if (ok && !NoDump) {
            if (!nread) {
                printf("=== end of file ===\n");
            } else {
                _write(1, buf, nread);
            }
        } else if (ok && NoDump && Verbose) {
            printf("InternetReadFile() returns %d bytes\n", nread);
        }
    } while (ok && nread);

    if (GetLastError() != ERROR_SUCCESS) {
        print_error("read_file", "InternetReadFile()");
    }

quit:

    free(buf);

    _setmode(1, mode);
}

void get_request_flags(HINTERNET hInternet) {

    DWORD dwFlags;
    DWORD len = sizeof(dwFlags);

    if (InternetQueryOption(hInternet,
                            INTERNET_OPTION_REQUEST_FLAGS,
                            &dwFlags,
                            &len)) {

        char buf[256];
        char * p = buf;

        p += sprintf(p, "REQUEST_FLAGS = %08x\n", dwFlags);
        p += sprintf(p, "\tRetrieved from:  %s\n",
            (dwFlags & INTERNET_REQFLAG_FROM_CACHE) ? "Cache" : "Network");
        p += sprintf(p, "\tNo Headers:      %s\n",
            (dwFlags & INTERNET_REQFLAG_NO_HEADERS) ? "TRUE" : "FALSE");
        p += sprintf(p, "\tVia Proxy:       %s\n",
            (dwFlags & INTERNET_REQFLAG_VIA_PROXY) ? "YES" : "NO");
        printf(buf);
    } else {
        print_error("get_request_flags()", "InternetQueryOption()");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\exts\winidbg.cxx ===
/*++

Module Name:

    winidbg.cxx

Abstract:



Author:

    Jeff Roberts (jroberts)  13-May-1996

Revision History:

     13-May-1996     jroberts

        Created this module.
    Mazhar Mohammed (mazharm) 3-20-97 - changed it all for async RPC,
                                                added some cool stuff
                                                single dll for ntsd and kd

	Feroze Daud ( ferozed ) 1/21/98 - changed for Wininet.

--*/

#include <stddef.h>
#include <limits.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <malloc.h>
#include <stdlib.h>
#include <windows.h>
#include <stddef.h>
#include "wdbgexts.h"

#define private public
#define protected public

//#include <wininetp.h>
#include <wininetp.h>


#include "local.hxx"

WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ProcessHandle = 0;
BOOL fKD = 0;

#define ALLOC_SIZE 500
#define MAX_ARGS 4

// #include "rpcexts.hxx"

//
// stuff not common to kernel-mode and user-mode DLLs
//

void do_fsm (
			DWORD fsm );
#if INET_DEBUG
LPSTR
MapType(
    FSM_TYPE m_Type
    );
#endif // INET_DEBUG

LPSTR
MapState(
    DWORD m_Type
    );


#define CASE_OF(x) case x : return #x; break;

// VOID do_trans( DWORD dwAddr );

DECLARE_API( fsm );
DECLARE_API( ho );
DECLARE_API( iho );
DECLARE_API( icho );
DECLARE_API( hrho );
DECLARE_API( lste );
DECLARE_API( serialist );

DECLARE_API(badproxylste);
void do_BAD_PROXY_LIST_ENTRY( DWORD addr ); 

DECLARE_API(badproxylst);
void do_BAD_PROXY_LIST( DWORD addr ); 

DECLARE_API(proxybyplste);
void do_PROXY_BYPASS_LIST_ENTRY( DWORD addr ); 

DECLARE_API(proxybyplst);
void do_PROXY_BYPASS_LIST( DWORD addr ); 

DECLARE_API(proxysrvlste);
void do_PROXY_SERVER_LIST_ENTRY( DWORD addr ); 

DECLARE_API(proxysrvlst);
void do_PROXY_SERVER_LIST( DWORD addr ); 

DECLARE_API(ICSecureSocket);
void do_ICSecureSocket( DWORD addr ); 

#define OFFSET( x, y ) \
				((DWORD)addr + offsetof(x, y)) 


// define our own operators new and delete, so that we do not have to include the crt

void * _CRTAPI1
::operator new(unsigned int dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void _CRTAPI1
::operator delete (void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}

BOOL
GetData(IN DWORD dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    if (fKD == 0)
        {
        return ReadProcessMemory(ProcessHandle, (LPVOID) dwAddress, ptr, size, 0);
        }

    while( size > 0 )
        {
        count = MIN( size, 3000 );

        b = d_ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count )
            {
            if (NULL == type)
                {
                type = "unspecified" ;
                }
            return FALSE;
            }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
        }

    return TRUE;
}

#define MAX_MESSAGE_BLOCK_SIZE 1024
#define BLOCK_SIZE 16
/*
RPC_CHAR *
ReadProcessRpcChar(
    unsigned short * Address
    )
{
    DWORD dwAddr = (DWORD) Address;

    char       block[BLOCK_SIZE];
    RPC_CHAR   *RpcBlock  = (RPC_CHAR *)&block;
    char *string_block = new char[MAX_MESSAGE_BLOCK_SIZE];
    RPC_CHAR   *RpcString = (RPC_CHAR *)string_block;
    int  length = 0;
    int  i      = 0;
    BOOL b;
    BOOL end    = FALSE;

    if (dwAddr == NULL) {
        return (L'\0');
    }

    for (length = 0; length < MAX_MESSAGE_BLOCK_SIZE/2; ) {
        b = GetData( dwAddr, &block, BLOCK_SIZE, NULL);
        if (b == FALSE) {
            d_printf("couldn't read address %x\n", dwAddr);
            return (L'\0');
        }
        for (i = 0; i < BLOCK_SIZE/2; i++) {
            if (RpcBlock[i] == L'\0') {
                end = TRUE;
            }
            RpcString[length] = RpcBlock[i];
            length++;
        }
        if (end == TRUE) {
            break;
        }
        dwAddr += BLOCK_SIZE;
    }
    return (RpcString);
}
*/

long
myatol(char *string)
{
    int  i         = 0;
    BOOL minus     = FALSE;
    long number    = 0;
    long tmpnumber = 0 ;
    long chknum;

    if (string[0] == '-') {
        minus = TRUE;
        i++;
    }
    else
    if (string[0] == '+') {
        i++;
    }
    for (; string[i] != '\0'; i++) {
        if ((string[i] >= '0')&&(string[i] <= '9')) {
            tmpnumber = string[i] - '0';
            if (number != 0) {
                chknum = LONG_MAX/number;
            }
            if (chknum > 11) {
                number = number*10 + tmpnumber;
            }
        }
        else
            return 0;
    }
    if (minus == TRUE) {
        number = 0 - number;
    }
    return number;
}

PCHAR
MapSymbol(DWORD dwAddr)
{
    static CHAR Name[256];
    DWORD Displacement;

    d_GetSymbol((LPVOID)dwAddr, (UCHAR *)Name, &Displacement);
    strcat(Name, "+");
#if 0
	// nuked due to build break
    PCHAR p = strchr(Name, '\0');
    _ltoa(Displacement, p, 16);
#endif
    return(Name);
}

// checks the if the uuid is null, prints the uuid
/*
void
PrintUuid(UUID *Uuid)
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) Uuid;
    if (   (Vector[0] == 0)
         && (Vector[1] == 0)
         && (Vector[2] == 0)
         && (Vector[3] == 0))
    {
        d_printf("(Null Uuid)");
    }
    else
    {
        d_printf("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                       Uuid->Data1, Uuid->Data2, Uuid->Data3, Uuid->Data4[0], Uuid->Data4[1],
                       Uuid->Data4[2], Uuid->Data4[3], Uuid->Data4[4], Uuid->Data4[5],
                       Uuid->Data4[6], Uuid->Data4[7] );
    }
    return;
}
*/

/*
DWORD OSF_CCONNECTION_SIZE = sizeof(OSF_CCONNECTION);
DWORD OSF_SCONNECTION_SIZE = sizeof(OSF_SCONNECTION);
DWORD OSF_ADDRESS_SIZE = sizeof(OSF_ADDRESS);
DWORD DG_ADDRESS_SIZE = sizeof(DG_ADDRESS);
*/

VOID
do_sizes(
    )
{
	d_printf("BUGBUG .... Add stuff here \n");
   // d_printf("sizeof(ASSOCIATION_HANDLE) - 0x%x\n", sizeof(ASSOCIATION_HANDLE));
}

DECLARE_API( sizes )
{
   INIT_DPRINTF();
   do_sizes();
}

char *
GetError (DWORD dwError)
{
    DWORD   dwFlag = FORMAT_MESSAGE_FROM_SYSTEM;
    static CHAR   szErrorMessage[1024];
    static HANDLE  hSource = NULL;

    if ((dwError >= 2100) && (dwError < 6000))
    {
        if (hSource == NULL)
            {
            hSource = LoadLibrary("netmsg.dll");
            }

        if (hSource == NULL)
        {
            sprintf (szErrorMessage,
                      "Unable to load netmsg.dll. Error %d occured.\n",
                      dwError);
            return(szErrorMessage);
        }

        dwFlag = FORMAT_MESSAGE_FROM_HMODULE;
    }

    if (!FormatMessage (dwFlag,
                        hSource,
                        dwError,
                        0,
                        szErrorMessage,
                        1024,
                        NULL))
       {
        sprintf (szErrorMessage,
                  "An unknown error occured: 0x%x \n",
                  dwError);
       }

    return(szErrorMessage);
}

VOID
do_error (
    DWORD dwAddr
    )
{
    d_printf("0x%x: %s\n", dwAddr, GetError(dwAddr));
}


DECLARE_API( help )
{
    INIT_DPRINTF();

    if (lpArgumentString[0] == '\0') {
        d_printf("\n"
                "wininext help:\n\n"
                "\n"
                "!obj      <address>  - Dumps an RPC object \n"
                "\n"
                "!sizes - Prints sizes of the data structures\n"
                "!error - Translates and error value into the error message\n"
                "!symbol    (<address>|<symbol name>) - Returns symbol name/address\n"
				"!fsm		<address> - Dumps the CFsm object\n"
				"!ho		<address> - Dumps the HANDLE_OBJECT object\n"
				"!iho		<address> - Dumps the INTERNET_HANDLE_OBJECT object\n"
				"!icho		<address> - Dumps the INTERNET_CONNECT_HANDLE_OBJECT object\n"
				"!hrho		<address> - Dumps the /////////////////////////////////////////////////
//
//	HEADER_STRING structure
//
/////////////////////////////////////////////////

DECLARE_API( HEADER_STRING )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_HEADER_STRING(dwAddr);
}

VOID
do_HEADER_STRING(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( HEADER_STRING ) ];

	HEADER_STRING * obj  = (HEADER_STRING *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( HEADER_STRING ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read HEADER_STRING at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("HEADER_STRING @ 0x%x \n\n", addr);

	//DWORD  m_Hash
	d_printf("\tDWORD m_Hash %d\n", obj -> m_Hash);

	//LPSTR  value
	d_printf("\tLPSTR value %s\n", obj -> value);



	d_printf("\n");

}  // HEADER_STRING



/////////////////////////////////////////////////
//
//	HTTP_HEADERS structure
//
/////////////////////////////////////////////////

DECLARE_API( HTTP_HEADERS )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_HTTP_HEADERS(dwAddr);
}

VOID
do_HTTP_HEADERS(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( HTTP_HEADERS ) ];

	HTTP_HEADERS * obj  = (HTTP_HEADERS *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( HTTP_HEADERS ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read HTTP_HEADERS at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("HTTP_HEADERS @ 0x%x \n\n", addr);

#ifndef STRESS_BUG_DEBUG
#endif
#if INET_DEBUG
	//DWORD  _Signature
	d_printf("\tDWORD _Signature %d\n", obj -> _Signature);

#endif
	//HEADER_STRING * _lpHeaders
	d_printf("\tHEADER_STRING * _lpHeaders 0x%x\n", obj -> _lpHeaders);

	//DWORD  _TotalSlots
	d_printf("\tDWORD _TotalSlots %d\n", obj -> _TotalSlots);

	//DWORD  _NextOpenSlot
	d_printf("\tDWORD _NextOpenSlot %d\n", obj -> _NextOpenSlot);

	//DWORD  _FreeSlots
	d_printf("\tDWORD _FreeSlots %d\n", obj -> _FreeSlots);

	//DWORD  _HeadersLength
	d_printf("\tDWORD _HeadersLength %d\n", obj -> _HeadersLength);

	//BOOL  _IsRequestHeaders
	d_printf("\tBOOL _IsRequestHeaders %d\n", obj -> _IsRequestHeaders);

	//LPSTR  _lpszVerb
	d_printf("\tLPSTR _lpszVerb %s\n", obj -> _lpszVerb);

	//DWORD  _dwVerbLength
	d_printf("\tDWORD _dwVerbLength %d\n", obj -> _dwVerbLength);

	//LPSTR  _lpszObjectName
	d_printf("\tLPSTR _lpszObjectName %s\n", obj -> _lpszObjectName);

	//DWORD  _dwObjectNameLength
	d_printf("\tDWORD _dwObjectNameLength %d\n", obj -> _dwObjectNameLength);

	//LPSTR  _lpszVersion
	d_printf("\tLPSTR _lpszVersion %s\n", obj -> _lpszVersion);

	//DWORD  _dwVersionLength
	d_printf("\tDWORD _dwVersionLength %d\n", obj -> _dwVersionLength);

	//DWORD  _RequestVersionMajor
	d_printf("\tDWORD _RequestVersionMajor %d\n", obj -> _RequestVersionMajor);

	//DWORD  _RequestVersionMinor
	d_printf("\tDWORD _RequestVersionMinor %d\n", obj -> _RequestVersionMinor);

	//DWORD  _Error
	d_printf("\tDWORD _Error %d\n", obj -> _Error);

#ifdef STRESS_BUG_DEBUG
	//DWORD  _dwCritCount
	d_printf("\tDWORD _dwCritCount %d\n", obj -> _dwCritCount);

#endif
#ifdef STRESS_BUG_DEBUG
#endif
#if INET_DEBUG
#endif
#if INET_DEBUG
#endif
#ifdef STRESS_BUG_DEBUG
#endif
#ifdef STRESS_BUG_DEBUG
#endif
#ifdef COMPRESSED_HEADERS
#endif //COMPRESSED_HEADERS


	d_printf("\n");

}  // HTTP_HEADERS



/////////////////////////////////////////////////
//
//	HTTP_REQUEST_HANDLE_OBJECT structure
//
/////////////////////////////////////////////////

DECLARE_API( HTTP_REQUEST_HANDLE_OBJECT )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_HTTP_REQUEST_HANDLE_OBJECT(dwAddr);
}

VOID
do_HTTP_REQUEST_HANDLE_OBJECT(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( HTTP_REQUEST_HANDLE_OBJECT ) ];

	HTTP_REQUEST_HANDLE_OBJECT * obj  = (HTTP_REQUEST_HANDLE_OBJECT *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( HTTP_REQUEST_HANDLE_OBJECT ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read HTTP_REQUEST_HANDLE_OBJECT at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("HTTP_REQUEST_HANDLE_OBJECT @ 0x%x \n\n", addr);

	//LIST_ENTRY  m_PipelineList
	d_printf("\tLIST_ENTRY (*) m_PipelineList 0x%x\n", OFFSET( HTTP_REQUEST_HANDLE_OBJECT, m_PipelineList) );

	//LONG  m_lPriority
	d_printf("\tLONG m_lPriority %d\n", obj -> m_lPriority);

	//ICSocket * _Socket
	d_printf("\tICSocket * _Socket 0x%x\n", obj -> _Socket);

	//BOOL  _bKeepAliveConnection
	d_printf("\tBOOL _bKeepAliveConnection %d\n", obj -> _bKeepAliveConnection);

	//BOOL  _bNoLongerKeepAlive
	d_printf("\tBOOL _bNoLongerKeepAlive %d\n", obj -> _bNoLongerKeepAlive);

	//LPVOID  _QueryBuffer
	d_printf("\tLPVOID _QueryBuffer 0X%X\n", obj -> _QueryBuffer);

	//DWORD  _QueryBufferLength
	d_printf("\tDWORD _QueryBufferLength %d\n", obj -> _QueryBufferLength);

	//DWORD  _QueryOffset
	d_printf("\tDWORD _QueryOffset %d\n", obj -> _QueryOffset);

	//DWORD  _QueryBytesAvailable
	d_printf("\tDWORD _QueryBytesAvailable %d\n", obj -> _QueryBytesAvailable);

	//DWORD  _OpenFlags
	d_printf("\tDWORD _OpenFlags %d\n", obj -> _OpenFlags);

	//HTTPREQ_STATE  _State
	d_printf("\tHTTPREQ_STATE _State %d\n", obj -> _State);

	//HTTP_HEADERS  _RequestHeaders
	d_printf("\tHTTP_HEADERS _RequestHeaders 0X%X\n", obj -> _RequestHeaders);

	//HTTP_METHOD_TYPE  _RequestMethod
	d_printf("\tHTTP_METHOD_TYPE _RequestMethod %d\n", obj -> _RequestMethod);

	//DWORD  _dwOptionalSaved
	d_printf("\tDWORD _dwOptionalSaved %d\n", obj -> _dwOptionalSaved);

	//LPVOID  _lpOptionalSaved
	d_printf("\tLPVOID _lpOptionalSaved 0X%X\n", obj -> _lpOptionalSaved);

	//BOOL  _fOptionalSaved
	d_printf("\tBOOL _fOptionalSaved %d\n", obj -> _fOptionalSaved);

	//DWORD  _iSlotContentLength
	d_printf("\tDWORD _iSlotContentLength %d\n", obj -> _iSlotContentLength);

	//DWORD  _iSlotContentRange
	d_printf("\tDWORD _iSlotContentRange %d\n", obj -> _iSlotContentRange);

	//DWORD  _StatusCode
	d_printf("\tDWORD _StatusCode %d\n", obj -> _StatusCode);

	//LPBYTE  _ResponseBuffer
	d_printf("\tLPBYTE _ResponseBuffer 0X%X\n", obj -> _ResponseBuffer);

	//DWORD  _ResponseBufferLength
	d_printf("\tDWORD _ResponseBufferLength %d\n", obj -> _ResponseBufferLength);

	//DWORD  _BytesReceived
	d_printf("\tDWORD _BytesReceived %d\n", obj -> _BytesReceived);

	//DWORD  _ResponseScanned
	d_printf("\tDWORD _ResponseScanned %d\n", obj -> _ResponseScanned);

	//DWORD  _ResponseBufferDataReadyToRead
	d_printf("\tDWORD _ResponseBufferDataReadyToRead %d\n", obj -> _ResponseBufferDataReadyToRead);

	//DWORD  _DataOffset
	d_printf("\tDWORD _DataOffset %d\n", obj -> _DataOffset);

	//DWORD  _BytesRemaining
	d_printf("\tDWORD _BytesRemaining %d\n", obj -> _BytesRemaining);

	//DWORD  _ContentLength
	d_printf("\tDWORD _ContentLength %d\n", obj -> _ContentLength);

	//DWORD  _BytesInSocket
	d_printf("\tDWORD _BytesInSocket %d\n", obj -> _BytesInSocket);

	//FILETIME  _ftLastModified
	d_printf("\tFILETIME _ftLastModified %d\n", obj -> _ftLastModified);

	//FILETIME  _ftExpires
	d_printf("\tFILETIME _ftExpires %d\n", obj -> _ftExpires);

	//FILETIME  _ftPostCheck
	d_printf("\tFILETIME _ftPostCheck %d\n", obj -> _ftPostCheck);

	//CHUNK_TRANSFER  _ctChunkInfo
	d_printf("\tCHUNK_TRANSFER (*) _ctChunkInfo 0x%x\n", OFFSET( HTTP_REQUEST_HANDLE_OBJECT, _ctChunkInfo) );

	//BOOL  _fTalkingToSecureServerViaProxy
	d_printf("\tBOOL _fTalkingToSecureServerViaProxy %d\n", obj -> _fTalkingToSecureServerViaProxy);

	//BOOL  _fRequestUsingProxy
	d_printf("\tBOOL _fRequestUsingProxy %d\n", obj -> _fRequestUsingProxy);

	//BOOL  _bWantKeepAlive
	d_printf("\tBOOL _bWantKeepAlive %d\n", obj -> _bWantKeepAlive);

	//BOOL  _bRefresh
	d_printf("\tBOOL _bRefresh %d\n", obj -> _bRefresh);

	//HEADER_STRING  _RefreshHeader
	d_printf("\tHEADER_STRING (*) _RefreshHeader 0x%x\n", OFFSET( HTTP_REQUEST_HANDLE_OBJECT, _RefreshHeader) );

	//DWORD  _dwQuerySetCookieHeader
	d_printf("\tDWORD _dwQuerySetCookieHeader %d\n", obj -> _dwQuerySetCookieHeader);



	d_printf("\n");

}  // HTTP_REQUEST_HANDLE_OBJECT


#ifndef unix
#endif /* unix */
HANDLE_OBJECT object\n"
				"!tinf		<address> - Dumps the INTERNET_THREAD_INFO structure\n"
				"!lste		<address> - Dumps the LIST_ENTRY structure\n"
				"!serialist		<address> - Dumps the SERIALIZED_LIST structure\n"
				"!proxyinfo		<address> - Dumps the PROXY_INFO structure\n"
				"!proxysrvlst		<address> - Dumps the PROXY_INFO structure\n"
				"!proxysrvlste		<address> - Dumps the PROXY_INFO_LIST structure\n"
				"!proxybyplst	<address> - Dumps the PROXY_BYPASS_LIST structure\n"
				"!proxybyplste	<address> - Dumps the PROXY_BYPASS_LIST_ENTRY structure\n"
				);
    }
}

void do_symbol(DWORD dwAddr)
{
    CHAR Symbol[64];
    DWORD Displacement;

    d_GetSymbol((LPVOID)dwAddr,(unsigned char *)Symbol,&Displacement);
    d_printf("%lx   %s+%lx\n", dwAddr, Symbol, Displacement);
}

DECLARE_API( symbol )
{
    DWORD dwAddr;
    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
    do_symbol(dwAddr);
}



USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?
#define VER_PRODUCTBUILD 10
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    fKD = 1;
    ExtensionApis = *lpExtensionApis ;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    d_printf(
        "%s RPC Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}


VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

///////////////////////////////////
//
// Dump the FSM class structure
//
///////////////////////////////////

DECLARE_API( fsm )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_fsm(dwAddr);
}

VOID
do_fsm(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( CFsm ) ];

	CFsm * fsm  = (CFsm *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( CFsm ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read CFsm at 0x%x; sorry.\n", addr);
		return;
	}

	d_printf("\nCFsm at 0x%x \n", addr);

	// CFsm * m_Link;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	// DWORD m_dwError;
	d_printf("\tDWORD m_dwError = %d\n", fsm -> m_dwError );

	// LPINTERNET_THREAD_INFO m_lpThreadInfo;
	d_printf("\tm_lpThreadInfo = 0x%x\n", fsm -> m_lpThreadInfo );

	// DWORD m_dwContext;
	d_printf("\tDWORD_PTR m_dwContext = %d\n", fsm -> m_dwContext );

	// HINTERNET m_hObject;
	d_printf("\tHINTERNET m_hObject = 0x%x\n", fsm -> m_hObject );

	//INTERNET_HANDLE_OBJECT * m_hObjectMapped;
	d_printf("\tINTERNET_HANDLE_OBJECT * m_hObjectMapped = 0x%x\n", fsm -> m_hObjectMapped );

	//DWORD m_dwMappedErrorCode;
	d_printf("\tDWORD m_dwMappedErrorCode = %d\n", fsm -> m_dwMappedErrorCode );

	//FSM_STATE m_State;
	d_printf("\tFSM_STATE m_State = %d ( %s )\n", fsm -> m_State  , MapState( fsm -> m_NextState));

	//FSM_STATE m_NextState;
	d_printf("\tFSM_STATE m_NextState = %d ( %s ) \n", fsm -> m_NextState , MapState( fsm -> m_NextState));


	//FSM_STATE m_FunctionState;
	d_printf("\tFSM_STATE m_FunctionState = %d ( %s ) \n", fsm -> m_FunctionState , MapState( fsm -> m_FunctionState ));

#if INET_DEBUG
	//FSM_TYPE m_Type;
	d_printf("\tFSM_TYPE m_Type = %d(%s)\n", fsm -> m_Type, MapType( fsm -> m_Type ));
#endif

	/*
	DWORD (*m_lpfnHandler)(CFsm *);
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	LPVOID m_lpvContext;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	FSM_HINT m_Hint;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );
	*/

	//SOCKET m_Socket;
	d_printf("\tSOCKET m_Socket = 0x%x\n", fsm -> m_Socket );

	FSM_ACTION m_Action;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	/*
	DWORD m_dwBlockId;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	DWORD m_dwTimeout;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	DWORD m_dwTimer;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	BOOL m_bTimerStarted;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );
	*/

	//BOOL m_bIsApi;
	d_printf("\tBOOL m_bIsApi = %d\n", fsm -> m_bIsApi );

	//API_TYPE m_ApiType;
	d_printf("\tAPI_TYPE m_ApiType = %d\n", fsm -> m_ApiType );

	//DWORD m_dwApiData;
	d_printf("\tDWORD m_dwApiData = %d\n", fsm -> m_dwApiData );

	d_printf("\n");

	/*
	union {
		BOOL Bool;
		HINTERNET Handle;
	} m_ApiResult;
	*/


    


}


///////////////////////////////////
//
// Dump the HANDLE_OBJECT class structure
//
///////////////////////////////////
VOID
do_handle_object(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( HANDLE_OBJECT ) ];

	HANDLE_OBJECT * fsm  = (HANDLE_OBJECT *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( HANDLE_OBJECT ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read HANDLE_OBJECT at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("HANDLE_OBJECT @ 0x%x \n", addr);

    //LIST_ENTRY _List;
	//d_printf("\tLIST_ENTRY _List\n");
	d_printf("\tLIST_ENTRY (*) _List = 0x%x \n", ((DWORD) addr + offsetof(HANDLE_OBJECT,_List)) );
	/*
	d_printf("\t\tLIST_ENTY * Flink = 0x%x\n", (fsm -> _List).Flink);
	d_printf("\t\tLIST_ENTY * Blink = 0x%x\n", (fsm -> _List).Blink);
	*/


    //SERIALIZED_LIST _Children;
	d_printf("\tSERIALIZED_LIST (*) _Children = 0x%x \n", ((DWORD) addr + offsetof(HANDLE_OBJECT,_Children)) );

    //LIST_ENTRY _Siblings;
	d_printf("\tLIST_ENTRY (*) _Siblings = 0x%x \n", ((DWORD) addr + offsetof(HANDLE_OBJECT,_Siblings)) );

    //HANDLE_OBJECT* _Parent;

	d_printf("\tHANDLE_OBJECT * _Parent = 0x%x \n", fsm -> _Parent);

    //BOOL _DeleteWithChild;
	d_printf("\tBOOL _DeleteWithChild = %d \n", fsm -> _DeleteWithChild);

    //HINTERNET _Handle;
	d_printf("\tHINTERNET _Handle = 0x%x \n", fsm -> _Handle);

    //HINTERNET_HANDLE_TYPE _ObjectType;
	d_printf("\tHINTERNET_HANDLE_TYPE _ObjectType = %d \n", fsm -> _ObjectType);

    //LONG _ReferenceCount;
	d_printf("\tLONG _ReferenceCount = %ld \n", fsm -> _ReferenceCount);

    //BOOL _Invalid;
	d_printf("\tBOOL _Invalid = %d \n", fsm -> _Invalid);

    //DWORD _Error;
	d_printf("\tDWORD _Error = %d \n", fsm -> _Error);

    //DWORD _Signature;
	d_printf("\tDWORD _Signature = 0x%x \n", fsm -> _Signature);

    //DWORD _Context;
	d_printf("\tDWORD _Context = %d \n", fsm -> _Context);

    //DWORD _Status;
	d_printf("\tDWORD _Status = %d \n", fsm -> _Status);

	d_printf("\n");

}

DECLARE_API( ho )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_handle_object(dwAddr);
}

///////////////////////////////////
//
// Dump the Thread Info structure
//
///////////////////////////////////
VOID
do_thread_info(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( INTERNET_THREAD_INFO ) ];

	LPINTERNET_THREAD_INFO fsm  = (LPINTERNET_THREAD_INFO) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( INTERNET_THREAD_INFO ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read INTERNET_THREAD_INFO at 0x%x; sorry.\n", addr);
		return;
	}



	d_printf("INTERNET_THREAD_INFO @ 0x%x \n", addr );

    //LIST_ENTRY List;
	d_printf("\tLIST_ENTRY List = 0x%x \n", fsm -> List);


    //    DWORD ThreadId;
	d_printf("\tDWORD ThreadId = %d \n", fsm -> ThreadId);

    //DWORD ErrorNumber;
	d_printf("\tDWORD ErrorNumber = %d \n", fsm -> ErrorNumber);

    //DWORD Context;
	d_printf("\tDWORD Context = %d \n", fsm -> Context);

    //HINTERNET hObject;
	d_printf("\tHINTERNET hObject = 0x%x \n", fsm -> hObject);

     //HINTERNET hObjectMapped;
	d_printf("\tHINTERNET hObjectMapped = 0x%x \n", fsm -> hObjectMapped);

   //BOOL IsAsyncWorkerThread;
	d_printf("\tBOOL IsAsyncWorkerThread = %d \n", fsm -> IsAsyncWorkerThread);

   //BOOL InCallback;
	d_printf("\tBOOL InCallback = %d \n", fsm -> InCallback);

   //BOOL IsAutoProxyProxyThread;
	d_printf("\tBOOL IsAutoProxyProxyThread = %d \n", fsm -> IsAutoProxyProxyThread);

   //DWORD NestedRequests;
	d_printf("\tDWORD NestedRequests = %d \n", fsm -> NestedRequests);

   //DWORD dwMappedErrorCode;
	d_printf("\tDWORD dwMappedErrorCode = %d \n", fsm -> dwMappedErrorCode);

    //CFsm * Fsm;
	d_printf("\tCFsm * Fsm = 0x%x \n", fsm -> Fsm);

	d_printf("\n");
}

DECLARE_API( tinf )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_thread_info(dwAddr);
}

///////////////////////////////////
//
// Dump the INTERNET_HANDLE_OBJECT class structure
//
///////////////////////////////////
VOID
do_internet_handle_object(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( INTERNET_HANDLE_OBJECT ) ];

	INTERNET_HANDLE_OBJECT * obj  = (INTERNET_HANDLE_OBJECT *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( INTERNET_HANDLE_OBJECT ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read INTERNET_HANDLE_OBJECT at 0x%x; sorry.\n", addr);
		return;
	}


	//do_internet_handle_object( addr );

	d_printf("INTERNET_HANDLE_OBJECT @ 0x%x \n\n", addr);

	//HINTERNET  _INetHandle
	d_printf("\tHINTERNET _INetHandle = 0x%x\n", obj -> _INetHandle);

	//BOOL  _IsCopy
	d_printf("\tBOOL _IsCopy = %d\n", obj -> _IsCopy);

	//ICSTRING  _UserAgent
	d_printf("\tICSTRING _UserAgent = 0x%x\n", obj -> _UserAgent);

	//PROXY_INFO * _ProxyInfo
	d_printf("\tPROXY_INFO * _ProxyInfo = 0x%x\n", obj -> _ProxyInfo);

	//RESOURCE_LOCK  _ProxyInfoResourceLock
	d_printf("\tRESOURCE_LOCK (*) _ProxyInfoResourceLock = 0x%x\n", &(obj -> _ProxyInfoResourceLock));

	//DWORD  _dwInternetOpenFlags
	d_printf("\tDWORD _dwInternetOpenFlags = %d\n", obj -> _dwInternetOpenFlags);

	//BOOL  _WinsockLoaded
	d_printf("\tBOOL _WinsockLoaded = %d\n", obj -> _WinsockLoaded);

	//ICSocket * _pICSocket
	d_printf("\tICSocket * _pICSocket = 0x%x\n", obj -> _pICSocket);

	//DWORD  _ConnectTimeout
	d_printf("\tDWORD _ConnectTimeout = %d\n", obj -> _ConnectTimeout);

	//DWORD  _ConnectRetries
	d_printf("\tDWORD _ConnectRetries = %d\n", obj -> _ConnectRetries);

	//DWORD  _SendTimeout
	d_printf("\tDWORD _SendTimeout = %d\n", obj -> _SendTimeout);

	//DWORD  _DataSendTimeout
	d_printf("\tDWORD _DataSendTimeout = %d\n", obj -> _DataSendTimeout);

	//DWORD  _ReceiveTimeout
	d_printf("\tDWORD _ReceiveTimeout = %d\n", obj -> _ReceiveTimeout);

	//DWORD  _DataReceiveTimeout
	d_printf("\tDWORD _DataReceiveTimeout = %d\n", obj -> _DataReceiveTimeout);

	//DWORD  _SocketSendBufferLength
	d_printf("\tDWORD _SocketSendBufferLength = %d\n", obj -> _SocketSendBufferLength);

	//DWORD  _SocketReceiveBufferLength
	d_printf("\tDWORD _SocketReceiveBufferLength = %d\n", obj -> _SocketReceiveBufferLength);

	//BOOL  _Async
	d_printf("\tBOOL _Async = %d\n", obj -> _Async);

	//DWORD  _DataAvailable
	d_printf("\tDWORD _DataAvailable = %d\n", obj -> _DataAvailable);

	//BOOL  _EndOfFile
	d_printf("\tBOOL _EndOfFile = %d\n", obj -> _EndOfFile);

	d_printf("\n");

}

DECLARE_API( iho )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_internet_handle_object(dwAddr);
}

/////////////////////////////////////////////////
//
//	INTERNET_CONNECT_HANDLE_OBJECT structure
//
/////////////////////////////////////////////////

DECLARE_API( INTERNET_CONNECT_HANDLE_OBJECT )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_INTERNET_CONNECT_HANDLE_OBJECT(dwAddr);
}

VOID
do_INTERNET_CONNECT_HANDLE_OBJECT(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( INTERNET_CONNECT_HANDLE_OBJECT ) ];

	INTERNET_CONNECT_HANDLE_OBJECT * obj  = (INTERNET_CONNECT_HANDLE_OBJECT *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( INTERNET_CONNECT_HANDLE_OBJECT ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read INTERNET_CONNECT_HANDLE_OBJECT at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("INTERNET_CONNECT_HANDLE_OBJECT @ 0x%x \n\n", addr);

	//HINTERNET  _InternetConnectHandle
	d_printf("\tHINTERNET _InternetConnectHandle 0X%X\n", obj -> _InternetConnectHandle);

	//BOOL  _IsCopy
	d_printf("\tBOOL _IsCopy %d\n", obj -> _IsCopy);

	//DWORD  _ServiceType
	d_printf("\tDWORD _ServiceType %d\n", obj -> _ServiceType);

	//HINTERNET_HANDLE_TYPE  _HandleType
	d_printf("\tHINTERNET_HANDLE_TYPE _HandleType %d\n", obj -> _HandleType);

	//BOOL  _Flags
	d_printf("\tBOOL _Flags %d\n", obj -> _Flags);

	//BOOL  _InUse
	d_printf("\tBOOL _InUse %d\n", obj -> _InUse);

	//BOOL  _fDeleteDataFile
	d_printf("\tBOOL _fDeleteDataFile %d\n", obj -> _fDeleteDataFile);

	//LPSTR  _CacheCWD
	d_printf("\tLPSTR _CacheCWD %s\n", obj -> _CacheCWD);

	//LPSTR  _CacheUrlName
	d_printf("\tLPSTR _CacheUrlName %s\n", obj -> _CacheUrlName);

	//XSTRING  _xsPrimaryCacheKey
	d_printf("\tXSTRING (*) _xsPrimaryCacheKey 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsPrimaryCacheKey) );

	//XSTRING  _xsSecondaryCacheKey
	d_printf("\tXSTRING (*) _xsSecondaryCacheKey 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsSecondaryCacheKey) );

	//LPSTR  _CacheFileName
	d_printf("\tLPSTR _CacheFileName %s\n", obj -> _CacheFileName);

	//DWORD  _CacheHeaderLength
	d_printf("\tDWORD _CacheHeaderLength %d\n", obj -> _CacheHeaderLength);

	//BOOL  _CacheReadInProgress
	d_printf("\tBOOL _CacheReadInProgress %d\n", obj -> _CacheReadInProgress);

	//BOOL  _CacheWriteInProgress
	d_printf("\tBOOL _CacheWriteInProgress %d\n", obj -> _CacheWriteInProgress);

	//DWORD  _RealCacheFileSize
	d_printf("\tDWORD _RealCacheFileSize %d\n", obj -> _RealCacheFileSize);

	//DWORD  _VirtualCacheFileSize
	d_printf("\tDWORD _VirtualCacheFileSize %d\n", obj -> _VirtualCacheFileSize);

#ifdef LAZY_WRITE
	//LPBYTE  _CacheScratchBuf
	d_printf("\tLPBYTE _CacheScratchBuf 0X%X\n", obj -> _CacheScratchBuf);

	//DWORD  _CacheScratchBufLen
	d_printf("\tDWORD _CacheScratchBufLen %d\n", obj -> _CacheScratchBufLen);

	//DWORD  _CacheScratchUsedLen
	d_printf("\tDWORD _CacheScratchUsedLen %d\n", obj -> _CacheScratchUsedLen);

#endif
	//DWORD  _dwCacheFlags
	d_printf("\tDWORD _dwCacheFlags %d\n", obj -> _dwCacheFlags);

	//DWORD  _dwStreamRefCount
	d_printf("\tDWORD _dwStreamRefCount %d\n", obj -> _dwStreamRefCount);

	//DWORD  _dwCurrentStreamPosition
	d_printf("\tDWORD _dwCurrentStreamPosition %d\n", obj -> _dwCurrentStreamPosition);

	//BOOL  _fFromCache
	d_printf("\tBOOL _fFromCache %d\n", obj -> _fFromCache);

	//BOOL  _fCacheWriteDisabled
	d_printf("\tBOOL _fCacheWriteDisabled %d\n", obj -> _fCacheWriteDisabled);

	//BOOL  _fIsHtmlFind
	d_printf("\tBOOL _fIsHtmlFind %d\n", obj -> _fIsHtmlFind);

	//BOOL  _CacheCopy
	d_printf("\tBOOL _CacheCopy %d\n", obj -> _CacheCopy);

	//BOOL  _CachePerUserItem
	d_printf("\tBOOL _CachePerUserItem %d\n", obj -> _CachePerUserItem);

	//BOOL  _fForcedExpiry
	d_printf("\tBOOL _fForcedExpiry %d\n", obj -> _fForcedExpiry);

	//BOOL  _fLazyUpdate
	d_printf("\tBOOL _fLazyUpdate %d\n", obj -> _fLazyUpdate);

	//LPSTR  _OriginalUrl
	d_printf("\tLPSTR _OriginalUrl %s\n", obj -> _OriginalUrl);

#ifdef LAZY_WRITE
#endif // LAZY_WRITE
	//DWORD  _ReadBufferSize
	d_printf("\tDWORD _ReadBufferSize %d\n", obj -> _ReadBufferSize);

	//DWORD  _WriteBufferSize
	d_printf("\tDWORD _WriteBufferSize %d\n", obj -> _WriteBufferSize);

	//ICSTRING  _HostName
	d_printf("\tICSTRING (*) _HostName 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _HostName) );

	//XSTRING  _xsUser
	d_printf("\tXSTRING (*) _xsUser 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsUser) );

	//XSTRING  _xsPass
	d_printf("\tXSTRING (*) _xsPass 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsPass) );

	//XSTRING  _xsProxyUser
	d_printf("\tXSTRING (*) _xsProxyUser 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsProxyUser) );

	//XSTRING  _xsProxyPass
	d_printf("\tXSTRING (*) _xsProxyPass 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsProxyPass) );

	//INTERNET_PORT  _HostPort
	d_printf("\tINTERNET_PORT _HostPort %d\n", obj -> _HostPort);

	//INTERNET_SCHEME  _SchemeType
	d_printf("\tINTERNET_SCHEME _SchemeType %d\n", obj -> _SchemeType);

	//LPSTR  _LastResponseInfo
	d_printf("\tLPSTR _LastResponseInfo %s\n", obj -> _LastResponseInfo);

	//DWORD  _LastResponseInfoLength
	d_printf("\tDWORD _LastResponseInfoLength %d\n", obj -> _LastResponseInfoLength);

	//BOOL  _bViaProxy
	d_printf("\tBOOL _bViaProxy %d\n", obj -> _bViaProxy);

	//BOOL  _bNoHeaders
	d_printf("\tBOOL _bNoHeaders %d\n", obj -> _bNoHeaders);

	//BOOL  _bNetFailed
	d_printf("\tBOOL _bNetFailed %d\n", obj -> _bNetFailed);



	d_printf("\n");

}  // INTERNET_CONNECT_HANDLE_OBJECT


///////////////////////////////////
//
// Dump the LIST_ENTRY  structure
//
///////////////////////////////////
VOID
do_list_entry(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( LIST_ENTRY ) ];

	LIST_ENTRY * obj  = (LIST_ENTRY *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( LIST_ENTRY ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read LIST_ENTRY at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("LIST_ENTRY @ 0x%x \n\n", addr);

	//struct _LIST_ENTRY * Flink
	d_printf("\tstruct _LIST_ENTRY * Flink = 0x%X\n", obj -> Flink);

	//struct _LIST_ENTRY * Blink
	d_printf("\tstruct _LIST_ENTRY * Blink = 0x%X\n", obj -> Blink);


	d_printf("\n");

}

DECLARE_API( lste )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_list_entry(dwAddr);
}

///////////////////////////////////
//
// Dump the SERIALIZED_LIST structure
//
///////////////////////////////////
VOID
do_serialized_list(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( SERIALIZED_LIST ) ];

	SERIALIZED_LIST * obj  = (SERIALIZED_LIST *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( SERIALIZED_LIST ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read SERIALIZED_LIST at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("SERIALIZED_LIST @ 0x%x \n\n", addr);

#if INET_DEBUG
	//DWORD  Signature
	d_printf("\tDWORD Signature %d\n", obj -> Signature);

	//RESOURCE_INFO  ResourceInfo
	d_printf("\tRESOURCE_INFO (*) ResourceInfo 0X%X\n", 
				((DWORD)addr + offsetof(SERIALIZED_LIST, ResourceInfo)) 
			);

	//LONG  LockCount
	d_printf("\tLONG LockCount %d\n", obj -> LockCount);

#endif // INET_DEBUG

	//LIST_ENTRY  List
	d_printf("\tLIST_ENTRY (*) List 0X%X\n",
				((DWORD)addr + offsetof(SERIALIZED_LIST, List)) 
			);

	//do_list_entry( (DWORD) &obj->List );

	//LONG  ElementCount
	d_printf("\tLONG ElementCount %ld\n", obj -> ElementCount);



	d_printf("\n");

}

DECLARE_API( serialist )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_serialized_list(dwAddr);
}

/////////////////////////////////////////////////
//
//	PROXY_INFO structure
//
/////////////////////////////////////////////////
VOID
do_proxy_info(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_INFO ) ];

	PROXY_INFO * obj  = (PROXY_INFO *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_INFO ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_INFO at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_INFO @ 0x%x \n\n", addr);

	//PROXY_SERVER_LIST * _ProxyServerList
	d_printf("\tPROXY_SERVER_LIST * _ProxyServerList = 0X%X\n",obj -> _ProxyServerList);

	//AUTO_PROXY_DLLS * _AutoProxyList
	d_printf("\tAUTO_PROXY_DLLS * _AutoProxyList = 0X%X\n", obj -> _AutoProxyList);

	//PROXY_BYPASS_LIST * _ProxyBypassList
	d_printf("\tPROXY_BYPASS_LIST * _ProxyBypassList = 0X%X\n", obj -> _ProxyBypassList);

	//DWORD  _Error
	d_printf("\tDWORD _Error %d\n", obj -> _Error);

	//RESOURCE_LOCK  _Lock
	d_printf("\tRESOURCE_LOCK (*) _Lock 0X%X\n", OFFSET(PROXY_INFO, _Lock));

	//BOOL  _Modified
	d_printf("\tBOOL _Modified %d\n", obj -> _Modified);

	//BAD_PROXY_LIST  _BadProxyList
	d_printf("\tBAD_PROXY_LIST _BadProxyList 0X%X\n", OFFSET(PROXY_INFO, _BadProxyList));

	d_printf("\n");

}

DECLARE_API( proxyinfo )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_proxy_info(dwAddr);
}


/////////////////////////////////////////////////
//
//	PROXY_BYPASS_LIST_ENTRY structure
//
/////////////////////////////////////////////////

DECLARE_API( proxybyplste )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_PROXY_BYPASS_LIST_ENTRY(dwAddr);
}

VOID
do_PROXY_BYPASS_LIST_ENTRY(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_BYPASS_LIST_ENTRY ) ];

	PROXY_BYPASS_LIST_ENTRY * obj  = (PROXY_BYPASS_LIST_ENTRY *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_BYPASS_LIST_ENTRY ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_BYPASS_LIST_ENTRY at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_BYPASS_LIST_ENTRY @ 0x%x \n\n", addr);

	//LIST_ENTRY  _List
	d_printf("\tLIST_ENTRY (*) _List 0x%x\n", OFFSET( PROXY_BYPASS_LIST_ENTRY, _List) );

	//INTERNET_SCHEME  _Scheme
	d_printf("\tINTERNET_SCHEME _Scheme %d\n", obj -> _Scheme);

	//ICSTRING  _Name
	d_printf("\tICSTRING (*) _Name 0x%x\n", OFFSET( PROXY_BYPASS_LIST_ENTRY, _Name) );

	//INTERNET_PORT  _Port
	d_printf("\tINTERNET_PORT _Port %d\n", obj -> _Port);

	//BOOL  _LocalSemantics
	d_printf("\tBOOL _LocalSemantics %d\n", obj -> _LocalSemantics);



	d_printf("\n");

}  // PROXY_BYPASS_LIST_ENTRY



/////////////////////////////////////////////////
//
//	PROXY_BYPASS_LIST structure
//
/////////////////////////////////////////////////

DECLARE_API( proxybyplst )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_PROXY_BYPASS_LIST(dwAddr);
}

VOID
do_PROXY_BYPASS_LIST(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_BYPASS_LIST ) ];

	PROXY_BYPASS_LIST * obj  = (PROXY_BYPASS_LIST *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_BYPASS_LIST ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_BYPASS_LIST at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_BYPASS_LIST @ 0x%x \n\n", addr);

	//SERIALIZED_LIST  _List
	d_printf("\tSERIALIZED_LIST (*) _List 0x%x\n", OFFSET( PROXY_BYPASS_LIST, _List) );

	//DWORD  _Error
	d_printf("\tDWORD _Error %d\n", obj -> _Error);



	d_printf("\n");

}  // PROXY_BYPASS_LIST



/////////////////////////////////////////////////
//
//	PROXY_SERVER_LIST_ENTRY structure
//
/////////////////////////////////////////////////

DECLARE_API( proxysrvlste )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_PROXY_SERVER_LIST_ENTRY(dwAddr);
}

VOID
do_PROXY_SERVER_LIST_ENTRY(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_SERVER_LIST_ENTRY ) ];

	PROXY_SERVER_LIST_ENTRY * obj  = (PROXY_SERVER_LIST_ENTRY *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_SERVER_LIST_ENTRY ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_SERVER_LIST_ENTRY at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_SERVER_LIST_ENTRY @ 0x%x \n\n", addr);

	//LIST_ENTRY  _List
	d_printf("\tLIST_ENTRY (*) _List 0x%x\n", OFFSET( PROXY_SERVER_LIST_ENTRY, _List) );

	//INTERNET_SCHEME  _Protocol
	d_printf("\tINTERNET_SCHEME _Protocol %d\n", obj -> _Protocol);

	//INTERNET_SCHEME  _Scheme
	d_printf("\tINTERNET_SCHEME _Scheme %d\n", obj -> _Scheme);

	//ICSTRING  _ProxyName
	d_printf("\tICSTRING (*) _ProxyName 0x%x\n", OFFSET( PROXY_SERVER_LIST_ENTRY, _ProxyName) );

	//INTERNET_PORT  _ProxyPort
	d_printf("\tINTERNET_PORT _ProxyPort %d\n", obj -> _ProxyPort);


	d_printf("\n");

}  // PROXY_SERVER_LIST_ENTRY



/////////////////////////////////////////////////
//
//	PROXY_SERVER_LIST structure
//
/////////////////////////////////////////////////

DECLARE_API( proxysrvlst )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_PROXY_SERVER_LIST(dwAddr);
}

VOID
do_PROXY_SERVER_LIST(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_SERVER_LIST ) ];

	PROXY_SERVER_LIST * obj  = (PROXY_SERVER_LIST *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_SERVER_LIST ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_SERVER_LIST at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_SERVER_LIST @ 0x%x \n\n", addr);

	//SERIALIZED_LIST  _List
	d_printf("\tSERIALIZED_LIST (*) _List 0x%x\n", OFFSET( PROXY_SERVER_LIST, _List) );

	//DWORD  _Error
	d_printf("\tDWORD _Error %d\n", obj -> _Error);


	d_printf("\n");

}  // PROXY_SERVER_LIST

/////////////////////////////////////////////////
//
//      ICSocket structure
//
/////////////////////////////////////////////////

DECLARE_API( ICSocket )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_ICSocket(dwAddr);
}

VOID
do_ICSocket(
           DWORD addr
    )
{
        BOOL b;
        char block[ sizeof( ICSocket ) ];

        ICSocket * obj  = (ICSocket *) &block;

    b = GetData(
                        addr,
                        block,
                        sizeof( ICSocket ),
                        NULL);

        if ( !b ) {
                d_printf("couldn't read ICSocket at 0x%x; sorry.\n", addr);
                return;
        }


        d_printf("ICSocket @ 0x%x \n\n", addr);

        //LIST_ENTRY  m_List
        d_printf("\tLIST_ENTRY (*) m_List 0x%x\n", OFFSET( ICSocket, m_List) );

        //DWORD  m_dwTimeout
        d_printf("\tDWORD m_dwTimeout %d\n", obj -> m_dwTimeout);

        //LONG  m_ReferenceCount
        d_printf("\tLONG m_ReferenceCount %d\n", obj -> m_ReferenceCount);

        //DWORD  m_dwFlags
        d_printf("\tDWORD m_dwFlags %d\n", obj -> m_dwFlags);

	//    SOCKET m_Socket;
	d_printf("\tSOCKET m_Socket %d\n", obj -> m_Socket);

        //INTERNET_PORT  m_Port
        d_printf("\tINTERNET_PORT m_Port %d\n", obj -> m_Port);

        //INTERNET_PORT  m_SourcePort
        d_printf("\tINTERNET_PORT m_SourcePort %d\n", obj -> m_SourcePort);

        //BOOL  m_bAborted
        d_printf("\tBOOL m_bAborted %d\n", obj -> m_bAborted);

        //DWORD  m_SocksAddress
        d_printf("\tDWORD m_SocksAddress %d\n", obj -> m_SocksAddress);

        //INTERNET_PORT  m_SocksPort
        d_printf("\tINTERNET_PORT m_SocksPort %d\n", obj -> m_SocksPort);

#if INET_DEBUG
        //DWORD  m_Signature
        d_printf("\tDWORD m_Signature %d\n", obj -> m_Signature);

#endif


        d_printf("\n");

}  // ICSocket

/////////////////////////////////////////////////
//
//      ICSecureSocket structure
//
/////////////////////////////////////////////////

DECLARE_API( ICSecureSocket )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_ICSecureSocket(dwAddr);
}

VOID
do_ICSecureSocket(
           DWORD addr
    )
{
        BOOL b;
        char block[ sizeof( ICSecureSocket ) ];

        ICSecureSocket * obj  = (ICSecureSocket *) &block;

	b = GetData(
                        addr,
                        block,
                        sizeof( ICSecureSocket ),
                        NULL);

        if ( !b ) {
                d_printf("couldn't read ICSecureSocket at 0x%x; sorry.\n", addr);
                return;
        }


        d_printf("ICSecureSocket @ 0x%x \n\n", addr);

        //CtxtHandle  m_hContext
        d_printf("\tCtxtHandle (*) m_hContext 0x%x\n", OFFSET( ICSecureSocket, m_hContext) );

        //DWORD  m_dwProviderIndex
        d_printf("\tDWORD m_dwProviderIndex %d\n", obj -> m_dwProviderIndex);

        //LPSTR  m_lpszHostName
        d_printf("\tLPSTR m_lpszHostName %s\n", obj -> m_lpszHostName);

        //DBLBUFFER * m_pdblbufBuffer
        d_printf("\tDBLBUFFER * m_pdblbufBuffer 0x%x\n", obj -> m_pdblbufBuffer);

        //DWORD  m_dwErrorFlags
        d_printf("\tDWORD m_dwErrorFlags %d\n", obj -> m_dwErrorFlags);

        //SECURITY_CACHE_LIST_ENTRY * m_pSecurityInfo
        d_printf("\tSECURITY_CACHE_LIST_ENTRY * m_pSecurityInfo 0x%x\n", obj -> m_pSecurityInfo);

#if INET_DEBUG
#endif


        d_printf("\n");

}  // ICSecureSocket



#if INET_DEBUG

LPSTR
MapType(
    FSM_TYPE m_Type
    ) {
    switch (m_Type) {
    case FSM_TYPE_NONE:                     return "NONE";
    case FSM_TYPE_WAIT_FOR_COMPLETION:      return "WAIT_FOR_COMPLETION";
    case FSM_TYPE_RESOLVE_HOST:             return "RESOLVE_HOST";
    case FSM_TYPE_SOCKET_CONNECT:           return "SOCKET_CONNECT";
    case FSM_TYPE_SOCKET_SEND:              return "SOCKET_SEND";
    case FSM_TYPE_SOCKET_RECEIVE:           return "SOCKET_RECEIVE";
    case FSM_TYPE_SOCKET_QUERY_AVAILABLE:   return "SOCKET_QUERY_AVAILABLE";
    case FSM_TYPE_SECURE_CONNECT:           return "SECURE_CONNECT";
    case FSM_TYPE_SECURE_HANDSHAKE:         return "SECURE_HANDSHAKE";
    case FSM_TYPE_SECURE_NEGOTIATE:         return "SECURE_NEGOTIATE";
    case FSM_TYPE_NEGOTIATE_LOOP:           return "NEGOTIATE_LOOP";
    case FSM_TYPE_SECURE_SEND:              return "SECURE_SEND";
    case FSM_TYPE_SECURE_RECEIVE:           return "SECURE_RECEIVE";
    case FSM_TYPE_GET_CONNECTION:           return "GET_CONNECTION";
    case FSM_TYPE_HTTP_SEND_REQUEST:        return "HTTP_SEND_REQUEST";
    case FSM_TYPE_MAKE_CONNECTION:          return "MAKE_CONNECTION";
    case FSM_TYPE_OPEN_CONNECTION:          return "OPEN_CONNECTION";
    case FSM_TYPE_OPEN_PROXY_TUNNEL:        return "OPEN_PROXY_TUNNEL";
    case FSM_TYPE_SEND_REQUEST:             return "SEND_REQUEST";
    case FSM_TYPE_RECEIVE_RESPONSE:         return "RECEIVE_RESPONSE";
    case FSM_TYPE_HTTP_READ:                return "HTTP_READ";
    case FSM_TYPE_HTTP_WRITE:               return "HTTP_WRITE";
    case FSM_TYPE_READ_DATA:                return "READ_DATA";
    case FSM_TYPE_HTTP_QUERY_AVAILABLE:     return "HTTP_QUERY_AVAILABLE";
    case FSM_TYPE_DRAIN_RESPONSE:           return "DRAIN_RESPONSE";
    case FSM_TYPE_REDIRECT:                 return "REDIRECT";
    case FSM_TYPE_READ_LOOP:                return "READ_LOOP";
    case FSM_TYPE_PARSE_HTTP_URL:           return "PARSE_HTTP_URL";
    case FSM_TYPE_PARSE_URL_FOR_HTTP:       return "PARSE_URL_FOR_HTTP";
    case FSM_TYPE_READ_FILE:                return "READ_FILE";
    case FSM_TYPE_READ_FILE_EX:             return "READ_FILE_EX";
    case FSM_TYPE_WRITE_FILE:               return "WRITE_FILE";
    case FSM_TYPE_QUERY_DATA_AVAILABLE:     return "QUERY_DATA_AVAILABLE";
    }
    return "?";
}

#endif // INET_DEBUG

LPSTR
MapState(
    IN DWORD State
    ) {
    switch (State) {
    CASE_OF(FSM_STATE_BAD);
    CASE_OF(FSM_STATE_INIT);
    CASE_OF(FSM_STATE_WAIT);
    CASE_OF(FSM_STATE_DONE);
    CASE_OF(FSM_STATE_ERROR);
    CASE_OF(FSM_STATE_CONTINUE);
    CASE_OF(FSM_STATE_FINISH);
    CASE_OF(FSM_STATE_1);
    CASE_OF(FSM_STATE_2);
    CASE_OF(FSM_STATE_3);
    CASE_OF(FSM_STATE_4);
    CASE_OF(FSM_STATE_5);
    CASE_OF(FSM_STATE_6);
    CASE_OF(FSM_STATE_7);
    CASE_OF(FSM_STATE_8);
    CASE_OF(FSM_STATE_9);
    CASE_OF(FSM_STATE_10);
    }
    return "?";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\test\tproxy\tproxy.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    tproxy.c

Abstract:

    Test program for Wininet proxy settings

    Contents:

Author:

    Richard L Firth (rfirth) 23-Jul-1996

Revision History:

    23-Jul-1996 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>
#include <malloc.h>
#include <memory.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#define NEW_USER_AGENT  "and now for a completely different user-agent"

void _CRTAPI1 main(int, char**);
void usage(void);
void get_proxy_info(HINTERNET);
void set_proxy_info(HINTERNET, LPINTERNET_PROXY_INFO);
void dump_proxy_info(HINTERNET, LPINTERNET_PROXY_INFO);
void get_user_agent(HINTERNET, char*, LPDWORD);
void set_user_agent(HINTERNET, char*);
void refresh_handle(HINTERNET);

BOOL Verbose = FALSE;
DWORD Failures = 0;

void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET hInternet1;
    HINTERNET hInternet2;
    HINTERNET hInternet3;
    HINTERNET hInternet4;
    INTERNET_PROXY_INFO proxyInfo;
    char proxyBuffer[512];
    DWORD length;
    BOOL ok;
    char uaBuf1[128];
    char uaBuf2[128];
    DWORD uaLen1;
    DWORD uaLen2;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    //
    // get global proxy info
    //

    get_proxy_info(NULL);

    //
    // get & remember it
    //

    length = sizeof(proxyBuffer);
    ok = InternetQueryOption(NULL, INTERNET_OPTION_PROXY, (LPVOID)proxyBuffer, &length);
    if (!ok) {
        print_error("tproxy()", "InternetQueryOption()");
        ++Failures;
    }

    //
    // create handles
    //

    //
    // 1. preconfig
    //

    hInternet1 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PRECONFIG, "foo", "bar", 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(PRECONFIG)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PRECONFIG) returns %#x\n", hInternet1);
    }
    get_proxy_info(hInternet1);

    //
    // 2. direct
    //

    hInternet2 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_DIRECT, "foo", "bar", 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(DIRECT)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(DIRECT) returns %#x\n", hInternet2);
    }
    get_proxy_info(hInternet2);

    //
    // 3. private proxy
    //

    hInternet3 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PROXY, "foo", "bar", 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(PROXY)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PROXY) returns %#x\n", hInternet3);
    }
    get_proxy_info(hInternet3);

    //
    // 4. another preconfig
    //

    hInternet4 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(PRECONFIG)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PRECONFIG #2) returns %#x\n", hInternet4);
    }
    get_proxy_info(hInternet4);

    //
    // change global proxy
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
    proxyInfo.lpszProxy = "modified.global.proxy";
    proxyInfo.lpszProxyBypass = "modified.global.proxy.bypass.list, *";
    set_proxy_info(NULL, &proxyInfo);

    //
    // make sure global, hInternet1 and hInternet4 all reference same proxy info
    //

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet4);

    //
    // reload global proxy info from registry
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    proxyInfo.lpszProxy = "modified.global.proxy";
    proxyInfo.lpszProxyBypass = "modified.global.proxy.bypass.list, *";
    set_proxy_info(NULL, &proxyInfo);

    //
    // set hInternet2 to use private proxy
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
    proxyInfo.lpszProxy = "my.test.proxy";
    proxyInfo.lpszProxyBypass = "www.foo.com www.bar.com";
    set_proxy_info(hInternet2, &proxyInfo);
    get_proxy_info(hInternet2);

    //
    // set hInternet3 to use direct
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
    proxyInfo.lpszProxy = "this.is.a.bogus.proxy";
    proxyInfo.lpszProxyBypass = "this.is.a.bogus.bypass.entry";
    set_proxy_info(hInternet3, &proxyInfo);
    get_proxy_info(hInternet3);

    //
    //
    //

    //
    // get the user-agent
    //

    uaLen1 = sizeof(uaBuf1);
    get_user_agent(hInternet1, uaBuf1, &uaLen1);

    //
    // set the user-agent
    //

    set_user_agent(hInternet1, NEW_USER_AGENT);

    //
    // get it again to make sure its the correct value
    //

    uaLen2 = sizeof(uaBuf2);
    get_user_agent(hInternet1, uaBuf2, &uaLen2);

    //
    // compare 'em
    //

    if (strcmp(uaBuf2, NEW_USER_AGENT)) {
        printf("error: tproxy(): set_user_agent() failed\n");
    }

    //
    // reset global proxy info
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    proxyInfo.lpszProxy = NULL;
    proxyInfo.lpszProxyBypass = NULL;
    set_proxy_info(NULL, &proxyInfo);

    //
    // make sure global, hInternet1 and hInternet4 all reference same proxy info
    //

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet4);

    //
    // close all handles
    //

    InternetCloseHandle(hInternet1);
    InternetCloseHandle(hInternet2);
    InternetCloseHandle(hInternet3);
    InternetCloseHandle(hInternet4);

    //
    // do the AOL test
    //

    if (Verbose) {
        printf("\nThe AOL Test\n\n");
    }

    if (Verbose) {
        printf("Opening PRECONFIG Internet handle #1\n");
    }
    hInternet1 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(PRECONFIG)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PRECONFIG) returns %#x\n", hInternet1);
    }
    get_proxy_info(hInternet1);

    if (Verbose) {
        printf("Changing global proxy info\n");
    }
    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
    proxyInfo.lpszProxy = "my.test.proxy";
    proxyInfo.lpszProxyBypass = "www.foo.com www.bar.com";
    set_proxy_info(NULL, &proxyInfo);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);

    if (Verbose) {
        printf("Opening PRECONFIG Internet handle #2\n");
    }
    hInternet2 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (hInternet2 == NULL) {
        print_error("tproxy()", "InternetOpen(PRECONFIG)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PRECONFIG) returns %#x\n", hInternet2);
    }
    get_proxy_info(hInternet2);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    if (Verbose) {
        printf("Changing proxy info on Internet handle #2\n");
    }
    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
    proxyInfo.lpszProxy = "THIS.IS.A.BOGUS.SERVER.LIST";
    proxyInfo.lpszProxyBypass = "THIS.IS.A.BOGUS.BYPASS.LIST";
    set_proxy_info(hInternet2, &proxyInfo);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    //
    // refresh handle 2 - shouldn't change
    //

    if (Verbose) {
        printf("Refreshing Internet handle #2\n");
    }
    refresh_handle(hInternet2);

    //
    // refresh the global handle - should refresh global handle & handle 1
    //

    if (Verbose) {
        printf("Refreshing global handle\n");
    }
    refresh_handle(NULL);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    //
    // change global proxy info back to registry. Global handle & handle 1
    // proxy info should change
    //

    if (Verbose) {
        printf("Changing global proxy info back to preconfig\n");
    }
    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    proxyInfo.lpszProxy = NULL;
    proxyInfo.lpszProxyBypass = NULL;
    set_proxy_info(NULL, &proxyInfo);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    //
    // refresh the global handle - should refresh global handle & handle 1
    //

    if (Verbose) {
        printf("Refreshing global handle\n");
    }
    refresh_handle(NULL);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    //
    // close all handles
    //

    InternetCloseHandle(hInternet1);
    InternetCloseHandle(hInternet2);

    //
    // pass or fail?
    //

    if (Verbose) {
        printf("\nDone.\n");
        if (Failures) {
            printf("Test failed\n");
        } else {
            printf("Test passed\n");
        }
    }
    exit(Failures);
}

void usage() {
    printf("usage: tproxy [-v]\n"
           "where: -v = Verbose mode\n"
           );
    exit(1);
}

void get_proxy_info(HINTERNET hInternet) {

    DWORD length;
    BOOL ok;

    length = 0;
    ok = InternetQueryOption(hInternet, INTERNET_OPTION_PROXY, NULL, &length);
    if (ok) {
        printf("error: get_proxy_info(%#x): InternetQueryOption() w/ no buffer succeeds\n", hInternet);
        ++Failures;
    } else {

        LPVOID buf = malloc(length);

        if (Verbose) {
            printf("get_proxy_info(%#x): %d bytes required for proxy info buffer\n", hInternet, length);
        }
        memset(buf, 0x99, length);
        ok = InternetQueryOption(hInternet, INTERNET_OPTION_PROXY, buf, &length);
        if (!ok) {
            print_error("get_proxy_info()", "InternetQueryOption()");
            ++Failures;
        } else if (Verbose) {
            dump_proxy_info(hInternet, (LPINTERNET_PROXY_INFO)buf);
        }
        free(buf);
    }
}

void set_proxy_info(HINTERNET hInternet, LPINTERNET_PROXY_INFO ProxyInfo) {

    BOOL ok;

    ok = InternetSetOption(hInternet, INTERNET_OPTION_PROXY, (LPVOID)ProxyInfo, sizeof(*ProxyInfo));
    if (!ok) {
        print_error("set_proxy_info()", "InternetSetOption()");
        ++Failures;
    }
}

void dump_proxy_info(HINTERNET hInternet, LPINTERNET_PROXY_INFO ProxyInfo) {
    printf("INTERNET_PROXY_INFO for handle %#x:\n"
           "\tAccess Type   : %s\n"
           "\tProxy Server  : \"%s\"\n"
           "\tProxy Bypass  : \"%s\"\n"
           "\n",
           hInternet,
           (ProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG)
                ? "PRECONFIG"
                : (ProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
                    ? "DIRECT"
                    : (ProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                        ? "PROXY"
                        : "?",
           (ProxyInfo->lpszProxy != NULL) ? ProxyInfo->lpszProxy : "",
           (ProxyInfo->lpszProxyBypass != NULL) ? ProxyInfo->lpszProxyBypass : ""
           );
}

void get_user_agent(HINTERNET hInternet, char* Buffer, LPDWORD lpdwLen) {

    DWORD length;
    BOOL ok;

    length = 0;
    ok = InternetQueryOption(hInternet, INTERNET_OPTION_USER_AGENT, NULL, &length);
    if (ok) {
        printf("error: get_user_agent(%#x): InternetQueryOption() w/ no buffer succeeds\n", hInternet);
        ++Failures;
    } else if (length <= *lpdwLen) {
        if (Verbose) {
            printf("get_user_agent(%#x): %d bytes required for proxy info buffer\n", hInternet, length);
        }
        memset(Buffer, 0x99, *lpdwLen);
        ok = InternetQueryOption(hInternet, INTERNET_OPTION_USER_AGENT, Buffer, &length);
        if (!ok) {
            print_error("get_proxy_info()", "InternetQueryOption()");
            ++Failures;
        } else {
            if (Buffer[length] != '\0') {
                printf("error: InternetQueryOption(USER_AGENT) returns incorrectly terminated string\n");
                ++Failures;
            }
            *lpdwLen = length;
            if (Verbose) {
                printf("User-Agent for %#x = \"%s\" (%d)\n", hInternet, Buffer, length);
            }
        }
    } else {
        printf("error: get_user_agent(%#x): not enough buffer (%d)\n", hInternet, *lpdwLen);
        ++Failures;
    }
}

void set_user_agent(HINTERNET hInternet, char* String) {

    BOOL ok;

    ok = InternetSetOption(hInternet, INTERNET_OPTION_USER_AGENT, (LPVOID)String, strlen(String) + 1);
    if (!ok) {
        print_error("set_user_agent()", "InternetSetOption()");
        ++Failures;
    }
}

void refresh_handle(HINTERNET hInternet) {

    BOOL ok;
    DWORD zero;

    zero = 0;
    ok = InternetSetOption(hInternet, INTERNET_OPTION_REFRESH, &zero, sizeof(zero));
    if (!ok) {
        print_error("refresh_handle()", "InternetSetOption()");
        ++Failures;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\dirlist.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dirlist.h

Abstract:

    Prototypes, etc. for dirlist.c

Author:

    Richard L Firth (rfirth) 31-Jul-1995

Revision History:

    31-Jul-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
ParseDirList(
    IN LPSTR lpBuffer,
    IN DWORD lpBufferLength,
    IN LPSTR lpszFilespec OPTIONAL,
    IN OUT PLIST_ENTRY lpList
    );

BOOL
IsFilespecWild(
    IN LPCSTR lpszFilespec
    );

PRIVATE
VOID
ClearFindList(
    IN PLIST_ENTRY lpList
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\test\ou\ou.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    openurl.c

Abstract:

    Tests InternetOpenUrl()/InternetReadFile()

Author:

    Richard L Firth (rfirth) 29-May-1995

Revision History:

    29-May-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <io.h>
#include <fcntl.h>
#include <windows.h>
#include <wininet.h>
#include <winsock.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

//
// prototypes
//

void _CRTAPI1 main(int, char**);
void usage(void);
void _CRTAPI1 my_cleanup(void);
void my_callback(DWORD, DWORD, LPVOID, DWORD);
void open_urls(LPSTR*, int);
void get_url_data(HINTERNET);
void ftp_find(HINTERNET);
void gopher_find(HINTERNET);
void read_data(HINTERNET);
void print_error(char*, char*, ...);
char* map_error(DWORD);
void get_last_internet_error(void);

//
// data
//

BOOL Verbose = FALSE;
HINTERNET InternetHandle = NULL;
INTERNET_STATUS_CALLBACK PreviousCallback;

//
// functions
//

void _CRTAPI1 main(int argc, char** argv) {

    BOOL ok;
    LPSTR urls[64];
    int numberOfUrls = 0;
    BOOL fCallback = FALSE;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case 'c':
                fCallback = TRUE;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("unknown command line flag: '%c'\n", **argv);
                usage();
            }
        } else {
            if (numberOfUrls == sizeof(urls)/sizeof(urls[0]) - 1) {
                break;
            }
            urls[numberOfUrls++] = *argv;
        }
    }

    //
    // exit function
    //

    atexit(my_cleanup);

    //
    // let's have a status callback
    //

    if (fCallback) {
        PreviousCallback = InternetSetStatusCallback(my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    //
    // open gateway
    //

    InternetHandle = InternetOpen("ou",
                                  PRE_CONFIG_INTERNET_ACCESS,
                                  NULL,
                                  0,
                                  0
                                  );
    if (InternetHandle == NULL) {
        printf("error: openurl: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    }

    if (numberOfUrls == 0) {
        printf("error: you must supply an URL\n");
        usage();
    } else {
        open_urls(urls, numberOfUrls);
    }

    ok = InternetCloseHandle(InternetHandle);
    if (!ok) {
        printf("error: openurl: InternetClose(InternetHandle) returns %d\n", GetLastError());
        exit(1);
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: ou [-c] [-v] [url]*\n"
           "where:  -c = enable status call-backs\n"
           "        -v = Verbose mode\n"
           "        url = one or more URLs to open\n"
           );
    exit(1);
}

void _CRTAPI1 my_cleanup() {
    if (InternetHandle != NULL) {
        printf("closing Internet handle %x\n", InternetHandle);
        if (!InternetCloseHandle(InternetHandle)) {
            print_error("my_cleanup", "InternetCloseHandle()");
        }
    }
}

VOID
my_callback(
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    default:
        type$ = "???";
        break;
    }
    printf("callback: %s ", type$);
    if (Info) {
        printf(Info);
    }
    putchar('\n');
}

void open_urls(LPSTR* purls, int nurls) {

    HINTERNET handle;

    while (nurls--) {
        printf("\nopening URL \"%s\"\n\n", *purls);
        handle = InternetOpenUrl(InternetHandle,
                                 *purls,
                                 NULL,
                                 0,
                                 0,
                                 0
                                 );
        if (handle == NULL) {
            print_error("open_urls", "InternetOpenUrl(%s)", *purls);
        } else {
            get_url_data(handle);
        }
        ++purls;
    }
}

void get_url_data(HINTERNET handle) {

    DWORD handleType;
    DWORD handleTypeLen;

    handleTypeLen = sizeof(handleType);
    if (InternetQueryOption(handle,
                            INTERNET_OPTION_HANDLE_TYPE,
                            (LPVOID)&handleType,
                            &handleTypeLen
                            )) {
        switch (handleType) {
        case INTERNET_HANDLE_TYPE_INTERNET:
            printf("error: get_url_data: HANDLE_TYPE_INTERNET?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_FTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_FTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_GOPHER?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_HTTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND:
            ftp_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_FTP_FILE:
            read_data(handle);
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND:
            gopher_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FILE:
            read_data(handle);
            break;

        case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
            read_data(handle);
            break;

        default:
            printf("error: get_url_data: handleType == %d?\n", handleType);
            break;
        }
        if (!InternetCloseHandle(handle)) {
            print_error("get_url_data", "InternetCloseHandle()");
        }
    } else {
        print_error("get_url_data", "InternetQueryOption()");
    }
}

void ftp_find(HINTERNET handle) {

    WIN32_FIND_DATA ffd;
    DWORD nRead;

    while (InternetReadFile(handle, (LPVOID)&ffd, sizeof(ffd), &nRead)) {

        SYSTEMTIME stDbg;

        if (!FileTimeToSystemTime(&ffd.ftLastWriteTime, &stDbg)) {
            printf("| ftLastWriteTime = ERROR\n");
        }

        printf("%2d-%02d-%04d %2d:%02d:%02d  %15d bytes %-s%-s%-s %s\n",
               stDbg.wMonth, stDbg.wDay, stDbg.wYear,
               stDbg.wHour, stDbg.wMinute, stDbg.wSecond,
               ffd.nFileSizeLow,
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)    ? "Normal    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)  ? "ReadOnly  " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? "Directory " : "",
               ffd.cFileName
               );
    }
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("ftp_find", "InternetReadFile()");
    }
}

void gopher_find(HINTERNET handle) {

    GOPHER_FIND_DATA data;
    int i;
    DWORD nRead;

    i = 0;
    while (InternetReadFile(handle, (LPVOID)&data, sizeof(data), &nRead)) {

        LPGOPHER_FIND_DATA p;
        SYSTEMTIME systemTime;
        char timeBuf[9];
        char sizeBuf[32];

        p = (LPGOPHER_FIND_DATA)&data;
        if ((p->LastModificationTime.dwLowDateTime != 0)
        && (p->LastModificationTime.dwHighDateTime != 0)) {
            FileTimeToSystemTime(&p->LastModificationTime, &systemTime);
            sprintf(timeBuf,
                    "%02d-%02d-%02d",
                    systemTime.wMonth,
                    systemTime.wDay,
                    systemTime.wYear % 100
                    );
            sprintf(sizeBuf, "%d", p->SizeLow);
        } else {
            timeBuf[0] = '\0';
            sizeBuf[0] = '\0';
        }
        printf("%5d %c %7s %10s %8s %s\n",
                i,
                (p->GopherType & GOPHER_TYPE_GOPHER_PLUS) ? '+' : ' ',
                (p->GopherType & GOPHER_TYPE_TEXT_FILE)         ? "Text"
                : (p->GopherType & GOPHER_TYPE_DIRECTORY)       ? "Dir"
                : (p->GopherType & GOPHER_TYPE_CSO)             ? "Phone"
                : (p->GopherType & GOPHER_TYPE_ERROR)           ? "Error"
                : (p->GopherType & GOPHER_TYPE_MAC_BINHEX)      ? "MAC"
                : (p->GopherType & GOPHER_TYPE_DOS_ARCHIVE)     ? "Archive"
                : (p->GopherType & GOPHER_TYPE_UNIX_UUENCODED)  ? "UNIX"
                : (p->GopherType & GOPHER_TYPE_INDEX_SERVER)    ? "Index"
                : (p->GopherType & GOPHER_TYPE_TELNET)          ? "Telnet"
                : (p->GopherType & GOPHER_TYPE_BINARY)          ? "Binary"
                : (p->GopherType & GOPHER_TYPE_REDUNDANT)       ? "Backup"
                : (p->GopherType & GOPHER_TYPE_TN3270)          ? "TN3270"
                : (p->GopherType & GOPHER_TYPE_GIF)             ? "GIF"
                : (p->GopherType & GOPHER_TYPE_IMAGE)           ? "Image"
                : (p->GopherType & GOPHER_TYPE_BITMAP)          ? "Bitmap"
                : (p->GopherType & GOPHER_TYPE_MOVIE)           ? "Movie"
                : (p->GopherType & GOPHER_TYPE_SOUND)           ? "Sound"
                : (p->GopherType & GOPHER_TYPE_HTML)            ? "HTML"
                : (p->GopherType & GOPHER_TYPE_PDF)             ? "PDF"
                : (p->GopherType & GOPHER_TYPE_CALENDAR)        ? "Cal"
                : (p->GopherType & GOPHER_TYPE_INLINE)          ? "Inline"
                : (p->GopherType & GOPHER_TYPE_UNKNOWN)         ? "Unknown"
                : "\a????",
                sizeBuf,
                timeBuf,
                p->DisplayString
                );
        ++i;
    }
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("gopher_find", "InternetReadFile()");
    }
}

void read_data(HINTERNET handle) {

    char buf[1021]; // odd number for fun!
    DWORD nread;

    while (InternetReadFile(handle, buf, sizeof(buf), &nread)) {
        if (!nread) {
            printf("=== end of file ===\n");
            break;
        } else {
            setmode(1, _O_BINARY);
            write(1, buf, nread);
        }
    }
    if (GetLastError() != ERROR_SUCCESS) {
        print_error("read_file", "InternetReadFile()");
    }
}

void print_error(char* func, char* format, ...) {

    va_list argptr;
    char buf[256];
    DWORD error;

    error = GetLastError();
    va_start(argptr, format);
    vsprintf(buf, format, argptr);
    printf("error: %s: %s returns %d [%s]\n", func, buf, error, map_error(error));
    va_end(argptr);
    if (error == ERROR_INTERNET_EXTENDED_ERROR) {
        get_last_internet_error();
    }
}

char* map_error(DWORD error) {
    switch (error) {
    case ERROR_FILE_NOT_FOUND:
        return "ERROR_FILE_NOT_FOUND";

    case ERROR_PATH_NOT_FOUND:
        return "ERROR_PATH_NOT_FOUND";

    case ERROR_ACCESS_DENIED:
        return "ERROR_ACCESS_DENIED";

    case ERROR_INVALID_HANDLE:
        return "ERROR_INVALID_HANDLE";

    case ERROR_NOT_ENOUGH_MEMORY:
        return "ERROR_NOT_ENOUGH_MEMORY";

    case ERROR_NO_MORE_FILES:
        return "ERROR_NO_MORE_FILES";

    case ERROR_INVALID_PASSWORD:
        return "ERROR_INVALID_PASSWORD";

    case ERROR_INVALID_PARAMETER:
        return "ERROR_INVALID_PARAMETER";

    case ERROR_BUFFER_OVERFLOW:
        return "ERROR_BUFFER_OVERFLOW";

    case ERROR_NO_MORE_SEARCH_HANDLES:
        return "ERROR_NO_MORE_SEARCH_HANDLES";

    case ERROR_INVALID_TARGET_HANDLE:
        return "ERROR_INVALID_TARGET_HANDLE";

    case ERROR_CALL_NOT_IMPLEMENTED:
        return "ERROR_CALL_NOT_IMPLEMENTED";

    case ERROR_INSUFFICIENT_BUFFER:
        return "ERROR_INSUFFICIENT_BUFFER";

    case ERROR_INVALID_NAME:
        return "ERROR_INVALID_NAME";

    case ERROR_INVALID_LEVEL:
        return "ERROR_INVALID_LEVEL";

    case ERROR_BAD_PATHNAME:
        return "ERROR_BAD_PATHNAME";

    case ERROR_BUSY:
        return "ERROR_BUSY";

    case ERROR_ALREADY_EXISTS:
        return "ERROR_ALREADY_EXISTS";

    case ERROR_FILENAME_EXCED_RANGE:
        return "ERROR_FILENAME_EXCED_RANGE";

    case ERROR_MORE_DATA:
        return "ERROR_MORE_DATA";

    case ERROR_NO_MORE_ITEMS:
        return "ERROR_NO_MORE_ITEMS";

    case ERROR_INVALID_ADDRESS:
        return "ERROR_INVALID_ADDRESS";

    case ERROR_OPERATION_ABORTED:
        return "ERROR_OPERATION_ABORTED";

    case ERROR_INTERNET_OUT_OF_HANDLES:
        return "ERROR_INTERNET_OUT_OF_HANDLES";

    case ERROR_INTERNET_TIMEOUT:
        return "ERROR_INTERNET_TIMEOUT";

    case ERROR_INTERNET_EXTENDED_ERROR:
        return "ERROR_INTERNET_EXTENDED_ERROR";

    case ERROR_INTERNET_INTERNAL_ERROR:
        return "ERROR_INTERNET_INTERNAL_ERROR";

    case ERROR_INTERNET_INVALID_URL:
        return "ERROR_INTERNET_INVALID_URL";

    case ERROR_INTERNET_UNRECOGNIZED_SCHEME:
        return "ERROR_INTERNET_UNRECOGNIZED_SCHEME";

    case ERROR_INTERNET_NAME_NOT_RESOLVED:
        return "ERROR_INTERNET_NAME_NOT_RESOLVED";

    case ERROR_INTERNET_PROTOCOL_NOT_FOUND:
        return "ERROR_INTERNET_PROTOCOL_NOT_FOUND";

    case ERROR_INTERNET_INVALID_OPTION:
        return "ERROR_INTERNET_INVALID_OPTION";

    case ERROR_FTP_TRANSFER_IN_PROGRESS:
        return "ERROR_FTP_TRANSFER_IN_PROGRESS";

    case ERROR_FTP_CONNECTED:
        return "ERROR_FTP_CONNECTED";

    case ERROR_FTP_DROPPED:
        return "ERROR_FTP_DROPPED";

    case ERROR_GOPHER_PROTOCOL_ERROR:
        return "ERROR_GOPHER_PROTOCOL_ERROR";

    case ERROR_GOPHER_NOT_FILE:
        return "ERROR_GOPHER_NOT_FILE";

    case ERROR_GOPHER_DATA_ERROR:
        return "ERROR_GOPHER_DATA_ERROR";

    case ERROR_GOPHER_END_OF_DATA:
        return "ERROR_GOPHER_END_OF_DATA";

    case ERROR_GOPHER_INVALID_LOCATOR:
        return "ERROR_GOPHER_INVALID_LOCATOR";

    case ERROR_GOPHER_INCORRECT_LOCATOR_TYPE:
        return "ERROR_GOPHER_INCORRECT_LOCATOR_TYPE";

    case ERROR_GOPHER_NOT_GOPHER_PLUS:
        return "ERROR_GOPHER_NOT_GOPHER_PLUS";

    case ERROR_GOPHER_ATTRIBUTE_NOT_FOUND:
        return "ERROR_GOPHER_ATTRIBUTE_NOT_FOUND";

    case ERROR_GOPHER_UNKNOWN_LOCATOR:
        return "ERROR_GOPHER_UNKNOWN_LOCATOR";

    case ERROR_HTTP_HEADER_NOT_FOUND:
        return "ERROR_HTTP_HEADER_NOT_FOUND";

    case ERROR_HTTP_DOWNLEVEL_SERVER:
        return "ERROR_HTTP_DOWNLEVEL_SERVER";

    case ERROR_HTTP_INVALID_SERVER_RESPONSE:
        return "ERROR_HTTP_INVALID_SERVER_RESPONSE";

    case WSAEINTR:
        return "WSAEINTR";

    case WSAEBADF:
        return "WSAEBADF";

    case WSAEACCES:
        return "WSAEACCES";

    case WSAEFAULT:
        return "WSAEFAULT";

    case WSAEINVAL:
        return "WSAEINVAL";

    case WSAEMFILE:
        return "WSAEMFILE";

    case WSAEWOULDBLOCK:
        return "WSAEWOULDBLOCK";

    case WSAEINPROGRESS:
        return "WSAEINPROGRESS";

    case WSAEALREADY:
        return "WSAEALREADY";

    case WSAENOTSOCK:
        return "WSAENOTSOCK";

    case WSAEDESTADDRREQ:
        return "WSAEDESTADDRREQ";

    case WSAEMSGSIZE:
        return "WSAEMSGSIZE";

    case WSAEPROTOTYPE:
        return "WSAEPROTOTYPE";

    case WSAENOPROTOOPT:
        return "WSAENOPROTOOPT";

    case WSAEPROTONOSUPPORT:
        return "WSAEPROTONOSUPPORT";

    case WSAESOCKTNOSUPPORT:
        return "WSAESOCKTNOSUPPORT";

    case WSAEOPNOTSUPP:
        return "WSAEOPNOTSUPP";

    case WSAEPFNOSUPPORT:
        return "WSAEPFNOSUPPORT";

    case WSAEAFNOSUPPORT:
        return "WSAEAFNOSUPPORT";

    case WSAEADDRINUSE:
        return "WSAEADDRINUSE";

    case WSAEADDRNOTAVAIL:
        return "WSAEADDRNOTAVAIL";

    case WSAENETDOWN:
        return "WSAENETDOWN";

    case WSAENETUNREACH:
        return "WSAENETUNREACH";

    case WSAENETRESET:
        return "WSAENETRESET";

    case WSAECONNABORTED:
        return "WSAECONNABORTED";

    case WSAECONNRESET:
        return "WSAECONNRESET";

    case WSAENOBUFS:
        return "WSAENOBUFS";

    case WSAEISCONN:
        return "WSAEISCONN";

    case WSAENOTCONN:
        return "WSAENOTCONN";

    case WSAESHUTDOWN:
        return "WSAESHUTDOWN";

    case WSAETOOMANYREFS:
        return "WSAETOOMANYREFS";

    case WSAETIMEDOUT:
        return "WSAETIMEDOUT";

    case WSAECONNREFUSED:
        return "WSAECONNREFUSED";

    case WSAELOOP:
        return "WSAELOOP";

    case WSAENAMETOOLONG:
        return "WSAENAMETOOLONG";

    case WSAEHOSTDOWN:
        return "WSAEHOSTDOWN";

    case WSAEHOSTUNREACH:
        return "WSAEHOSTUNREACH";

    case WSAENOTEMPTY:
        return "WSAENOTEMPTY";

    case WSAEPROCLIM:
        return "WSAEPROCLIM";

    case WSAEUSERS:
        return "WSAEUSERS";

    case WSAEDQUOT:
        return "WSAEDQUOT";

    case WSAESTALE:
        return "WSAESTALE";

    case WSAEREMOTE:
        return "WSAEREMOTE";

    case WSAEDISCON:
        return "WSAEDISCON";

    case WSASYSNOTREADY:
        return "WSASYSNOTREADY";

    case WSAVERNOTSUPPORTED:
        return "WSAVERNOTSUPPORTED";

    case WSANOTINITIALISED:
        return "WSANOTINITIALISED";

    case WSAHOST_NOT_FOUND:
        return "WSAHOST_NOT_FOUND";

    case WSATRY_AGAIN:
        return "WSATRY_AGAIN";

    case WSANO_RECOVERY:
        return "WSANO_RECOVERY";

    case WSANO_DATA:
        return "WSANO_DATA";

    default:
        return "???";
    }
}

void get_last_internet_error() {

    DWORD bufLength;
    char buffer[256];
    DWORD category;

    bufLength = sizeof(buffer);
    if (InternetGetLastResponseInfo(&category, buffer, &bufLength)) {
        printf("InternetGetLastResponseInfo() returns %d bytes\n", bufLength);
        if (bufLength != 0) {
            printf("Text = \"%s\"\n", buffer);
        }
        if (strlen(buffer) != bufLength) {
            printf("\aerror: get_last_internet_error: InternetGetLastResponseInfo() returns %d bytes; strlen(buffer) = %d\n",
                    bufLength,
                    strlen(buffer)
                    );
        }
    } else {

        LPSTR errbuf;

        printf("InternetGetLastResponseInfo() returns error %d (bufLength = %d)\n",
               GetLastError(),
               bufLength
               );
        if ((errbuf = malloc(bufLength)) == NULL) {
            printf("error: get_last_internet_error: malloc(%d) failed\n", bufLength);
            return;
        }
        if (InternetGetLastResponseInfo(&category, errbuf, &bufLength)) {
            printf("InternetGetLastResponseInfo() returns %d bytes\n", bufLength);
            if (bufLength != 0) {
                printf("Text = \"%s\"\n", errbuf);
            }
            if (strlen(buffer) != bufLength) {
                printf("\aerror: get_last_internet_error: InternetGetLastResponseInfo() returns %d bytes; strlen(buffer) = %d\n",
                        bufLength,
                        strlen(buffer)
                        );
            }
        } else {
            printf("error: get_last_internet_error: InternetGetLastResponseInfo() returns error %d (bufLength = %d)\n",
               GetLastError(),
               bufLength
               );
        }
        free(errbuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\dirlist.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dirlist.cxx

Abstract:

    Contains functions for parsing directory output from LIST command

    Contents:
        ParseDirList
        IsFilespecWild
        ClearFindList
        (DetermineDirectoryFormat)
        (IsNtDateFormat)
        (GetToken)
        (IsUnixAttributeFormat)
        (ParseNtDirectory)
        (ParseUnixDirectory)
        (ParseOs2Directory)
        (ParseMacDirectory)
        (ExtractFileSize)
        (_ExtractFilename)
        (ExtractNtDate)
        (ExtractUnixDate)
        (ExtractOs2Attributes)
        (ParseWord)
        (ExtractInteger)

Author:

    Richard L Firth (rfirth) 26-Jul-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    26-Jul-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// private manifests
//

#define MAX_YEAR_SUPPORTED  2100
#define TOKEN_BUFFER_LENGTH 128
#define RELATIVELY_SMALL_AMOUNT_OF_LS_DATA  512 // arbitrary, but allow for
                                                // prolix error text

//
// private types
//

typedef enum {
    State_Start,
    State_Error,
    State_Continue,
    State_Done
} PARSE_STATE;

typedef PARSE_STATE (*DIR_PARSER)(LPSTR*, LPDWORD, LPWIN32_FIND_DATA);

//
// private macros
//

#define ClearFileTime(fileTime) \
    (fileTime).dwLowDateTime = 0; \
    (fileTime).dwHighDateTime = 0;

#define ClearFindDataFields(lpFind) \
    ClearFileTime((lpFind)->ftCreationTime); \
    ClearFileTime((lpFind)->ftLastAccessTime); \
    (lpFind)->dwReserved0 = 0; \
    (lpFind)->dwReserved1 = 0; \
    (lpFind)->cAlternateFileName[0] = '\0';

//
// private prototypes
//

PRIVATE
BOOL
DetermineDirectoryFormat(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    OUT DIR_PARSER* ParserFunction
    );

PRIVATE
BOOL
IsNtDateFormat(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength
    );

PRIVATE
BOOL
GetToken(
    IN LPSTR lpszBuffer,
    IN DWORD dwBufferLength,
    OUT LPSTR lpszToken,
    IN OUT LPDWORD lpdwTokenLength
    );

PRIVATE
BOOL
IsUnixAttributeFormat(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength
    );

PRIVATE
PARSE_STATE
ParseNtDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
PARSE_STATE
ParseUnixDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
PARSE_STATE
ParseOs2Directory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
PARSE_STATE
ParseMacDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ExtractFileSize(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
_ExtractFilename(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ExtractNtDate(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ExtractUnixDate(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ExtractOs2Attributes(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ParseWord(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN WORD LowerBound,
    IN WORD UpperBound,
    OUT LPWORD lpNumber
    );

PRIVATE
BOOL
ExtractInteger(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    OUT LPINT lpNumber
    );

//
// private data
//

//
// DefaultSystemTime - if we fail to parse the time/date field for any reason,
// we will return this default time
//

PRIVATE static SYSTEMTIME DefaultSystemTime = {1980, 1, 0, 1, 12, 0, 0, 0};

//
// functions
//

DWORD
ParseDirList(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength,
    IN LPSTR lpszFilespec OPTIONAL,
    IN OUT PLIST_ENTRY lpList
    )

/*++

Routine Description:

    Creates a list of WIN32_FIND_DATA structures given the output from the LIST
    command run at the FTP server

Arguments:

    lpBuffer        - pointer to buffer containing LIST output

    lpBufferLength  - length of Buffer - no trailing \0

    lpszFilespec    - pointer to file specification used to generate listing.
                      May contain path components. May be NULL, in which case
                      we perform no filtering based on name (results should be
                      an exact match with request)

    lpList          - pointer to LIST_ENTRY list to add to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "ParseDirList",
                "%x, %d, %x",
                lpBuffer,
                dwBufferLength,
                lpList
                ));

    DWORD error;
    DIR_PARSER directoryParser;
    BOOL needBuffer;
    LPSTR lpszOriginalBuffer;
    DWORD dwOriginalBufferLength;

    //
    // remember the initial buffer pointer and length, in case we can't determine
    // the format - DetermineDirectoryFormat() will alter the input buffer pointer
    // and length
    //

    lpszOriginalBuffer = lpBuffer;
    dwOriginalBufferLength = dwBufferLength;

    //
    // find out the format of the directory listing. Currently we understand
    // NT and the basic Unix directory listing formats
    //

    if (!DetermineDirectoryFormat(&lpBuffer, &dwBufferLength, &directoryParser)) {

        DEBUG_PRINT(FTP,
                    ERROR,
                    ("Can't determine directory format\n"
                    ));

        //
        // if we received a relatively small amount of data, then there is a
        // good chance that what we actually received is an error message from
        // the ls command, or operating system, etc. Make it an extended error.
        // This will reduce (but not eliminate) the chances of getting back an
        // internal error
        //

        if (dwBufferLength <= RELATIVELY_SMALL_AMOUNT_OF_LS_DATA) {
            error = InternetSetLastError(0,
                                         lpszOriginalBuffer,
                                         dwOriginalBufferLength,
                                         SLE_APPEND | SLE_ZERO_TERMINATE
                                         );

            //
            // return internal error if we failed to add the text for any reason
            //

            error = (error == ERROR_SUCCESS)
                        ? ERROR_INTERNET_EXTENDED_ERROR
                        : ERROR_INTERNET_INTERNAL_ERROR
                        ;
        } else {

            //
            // BUGBUG - error code?
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
        goto quit;
    }

    //
    // the list must be currently empty
    //

    INET_ASSERT(IsListEmpty(lpList));

    //
    // the app may have specified a path. Chances are that if there are
    // wildcards within the path then the server would have returned an
    // error. But if the app requested e.g. foo\bar\*.exe then the server
    // would have returned the directory results for foo\bar. Therefore,
    // we must skip any path components, or all tests against the filespec
    // will fail
    //

    if (ARGUMENT_PRESENT(lpszFilespec)) {

        LPSTR lpszSpec;

        lpszSpec = strrchr(lpszFilespec, '\\');
        if (lpszSpec == NULL) {
            lpszSpec = strrchr(lpszFilespec, '/');
        }
        if (lpszSpec != NULL) {
            lpszFilespec = lpszSpec + 1;
        }

        DEBUG_PRINT(FTP,
                    INFO,
                    ("lpszFilespec = %s\n",
                    lpszFilespec
                    ));

    }

    //
    // loop round, parsing the listing until we reach the end or get an
    // error
    //

    needBuffer = TRUE;
    error = ERROR_SUCCESS;
    while ((dwBufferLength != 0) && (error == ERROR_SUCCESS)) {

        PLIST_ENTRY dirEntry;
        LPWIN32_FIND_DATA lpFind;

        //
        // we need to allocate a buffer for the WIN32_FIND_DATA structure
        // unless we already have one from the previous iteration (because
        // the filename didn't match our target criteria)
        //

        if (needBuffer) {
            dirEntry = (PLIST_ENTRY)ALLOCATE_FIXED_MEMORY(
                                    sizeof(LIST_ENTRY) + sizeof(WIN32_FIND_DATA)
                                    );
            lpFind = (LPWIN32_FIND_DATA)(dirEntry + 1);
            needBuffer = FALSE;

            DEBUG_PRINT(FTP,
                        INFO,
                        ("Allocated WIN32_FIND_DATA @ %x\n",
                        lpFind
                        ));

        }
        if (dirEntry == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("Failed to allocate WIN32_FIND_DATA\n"
                        ));

        } else {

            PARSE_STATE state;

            //
            // zero initialize the WIN32_FIND_DATA fields we don't fill in
            // below
            //

            ClearFindDataFields(lpFind);

            //
            // and parse the rest of the information out of the returned FTP
            // directory listing
            //

            state = directoryParser(&lpBuffer, &dwBufferLength, lpFind);

            //
            // if the parser returns State_Continue or State_Done then we need
            // to add the structure to the list if the caller wants it, else we
            // free it and quit
            //

            if (state != State_Error) {

                BOOL addIt;

                //
                // before we put this entry on the list, see if the caller wants
                // it
                //

                if (ARGUMENT_PRESENT(lpszFilespec)) {
                    addIt = MyFsRtlIsNameInExpression(lpszFilespec,
                                                    lpFind->cFileName,
                                                    TRUE    // case-sensitive
                                                    );
                } else {
                    addIt = TRUE;
                }
                if (addIt) {

                    DEBUG_PRINT(FTP,
                                INFO,
                                ("Match: file %q, target %q\n",
                                lpFind->cFileName,
                                lpszFilespec
                                ));

                    InsertTailList(lpList, (PLIST_ENTRY)dirEntry);
                    needBuffer = TRUE;
                } else {

                    DEBUG_PRINT(FTP,
                                INFO,
                                ("No match: file %q, target %q\n",
                                lpFind->cFileName,
                                lpszFilespec
                                ));

                }
            }

            //
            // if we had an error or there's no more buffer to parse but we
            // didn't keep the last entry, then we need to free the unused
            // WIN32_FIND_DATA and get out
            //

            if ((state == State_Error) || ((state == State_Done) && !needBuffer)) {
                FREE_MEMORY(dirEntry);
                if (state == State_Error) {

                    DEBUG_PRINT(FTP,
                                ERROR,
                                ("State_Error\n"
                                ));

                    //
                    // BUGBUG - error code
                    //

                    error = ERROR_INTERNET_INTERNAL_ERROR;
                }
            }
        }
    }

quit:

    //
    // if we had an error then free up any data structures that we allocated
    //

    if (error != ERROR_SUCCESS) {
        ClearFindList(lpList);
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
IsFilespecWild(
    IN LPCSTR lpszFilespec
    )

/*++

Routine Description:

    Returns TRUE if lpszFilespec is a wild-card file specifier

Arguments:

    lpszFilespec    - pointer to string containing file specification. Cannot
                      be a NULL string

Return Value:

    BOOL

--*/

{
    int len;
    int i;

    INET_ASSERT(ARGUMENT_PRESENT(lpszFilespec));

    //
    // check if the file specifier contains a '*' or a '?'. If so, then the
    // caller is making a DOS-style search request and we have to perform our
    // own filtering, otherwise, we can leave the server to return what the
    // caller asked for
    //

    for (i = 0, len = strlen(lpszFilespec); i < len; ++i) {
        if ((lpszFilespec[i] == '*') || (lpszFilespec[i] == '?')) {
            return TRUE;
        }
    }
    return FALSE;
}


VOID
ClearFindList(
    IN PLIST_ENTRY lpList
    )

/*++

Routine Description:

    Dequeues and deallocates all WIN32_FIND_DATA structures on a directory list

Arguments:

    lpList  - pointer to list to clear

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_FTP,
                None,
                "ClearFindList",
                "%x",
                lpList
                ));

    while (!IsListEmpty(lpList)) {

        PLIST_ENTRY lpHead;

        lpHead = RemoveHeadList(lpList);

        DEBUG_PRINT(FTP,
                    INFO,
                    ("Freeing WIN32_FIND_DATA @ %x, FileName=%q\n",
                    lpHead,
                    ((LPWIN32_FIND_DATA)(lpHead + 1))->cFileName
                    ));

        FREE_MEMORY(lpHead);
    }

    DEBUG_LEAVE(0);
}

//
// private functions
//


PRIVATE
BOOL
DetermineDirectoryFormat(
    IN LPSTR* lpBuffer,
    IN LPDWORD lpdwBufferLength,
    OUT DIR_PARSER* lpfnParserFunction
    )

/*++

Routine Description:

    Determines whether the directory listing is in Unix or NT (or other?) format
    and returns a pointer to the parser function to use

    The buffer pointer and length may be adjusted past any prologue information

Arguments:

    lpBuffer            - pointer to pointer to buffer containing directory
                          listing

    lpdwBufferLength    - pointer to length of Buffer

    lpfnParserFunction  - returned directory parser function

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Bool,
                "DetermineDirectoryFormat",
                "%x [%.40q], %x [%d], %x",
                lpBuffer,
                *lpBuffer,
                lpdwBufferLength,
                *lpdwBufferLength,
                lpfnParserFunction
                ));

    BOOL success;

    if (!SkipWhitespace(lpBuffer, lpdwBufferLength)) {
        success = FALSE;
        goto quit;
    }

    if (IsNtDateFormat(*lpBuffer, *lpdwBufferLength)) {

        DEBUG_PRINT(FTP,
                    INFO,
                    ("format is NT\n"
                    ));

        *lpfnParserFunction = ParseNtDirectory;
        success = TRUE;
        goto quit;
    }

    //
    // we think the directory output is from Unix. The listing probably
    // starts with "total #" or a number, or other random garbage. We
    // know that a Unix dir listing starts with the ls attributes, so
    // we'll search for those, but keep our search within a reasonable
    // distance of the start
    //

    LPSTR buffer;
    DWORD length;
    char tokenBuffer[TOKEN_BUFFER_LENGTH];
    int lengthChecked;
    int iteration;
    int dataLength;

    buffer = *lpBuffer;
    length = *lpdwBufferLength;
    lengthChecked = 0;
    iteration = 0;
    dataLength = min((int)*lpdwBufferLength, RELATIVELY_SMALL_AMOUNT_OF_LS_DATA);

    while (lengthChecked < dataLength) {

        DWORD tokenLength;
        DWORD previousLength;

        tokenLength = sizeof(tokenBuffer);
        if (!GetToken(buffer,
                      length,
                      tokenBuffer,
                      &tokenLength)) {
            success = FALSE;
            goto quit;
        }
        lengthChecked += tokenLength;
        if (IsUnixAttributeFormat(tokenBuffer, tokenLength)) {

            DEBUG_PRINT(FTP,
                        INFO,
                        ("format is Unix\n"
                        ));

            *lpfnParserFunction = ParseUnixDirectory;
            *lpBuffer = buffer;
            *lpdwBufferLength = length;
            success = TRUE;
            goto quit;
        } else if ((iteration == 0)
        && (tokenLength == 5)
        && !strnicmp(tokenBuffer, "total", 5)) {

            //
            // there may be nothing in the directory listing, except
            // "total 0". If this is this case, then we recognize the
            // format
            //

            buffer += tokenLength;
            length -= tokenLength;
            tokenLength = sizeof(tokenBuffer) - 1;  // for '\0'
            if (!GetToken(buffer,
                          length,
                          tokenBuffer,
                          &tokenLength)) {
                success = FALSE;
                goto quit;
            }
            tokenBuffer[tokenLength] = '\0';
            if (isdigit(tokenBuffer[0]) && (atoi(tokenBuffer) == 0)) {

                DEBUG_PRINT(FTP,
                            INFO,
                            ("format is Unix - empty directory\n"
                            ));

                *lpfnParserFunction = ParseUnixDirectory;
                SkipLine(&buffer, &length);
                *lpBuffer = buffer;
                *lpdwBufferLength = length;
                success = TRUE;
                goto quit;
            }
        }

        //
        // try the next line
        //

        previousLength = length;
        SkipLine(&buffer, &length);
        lengthChecked += previousLength - length;
        ++iteration;
    }

    //
    // not NT or Unix. Lets try for OS/2. The format of an OS/2 directory entry
    // is:
    //
    //      [<ws>]<length>[DIR|<attribute>]<date><time><filename>
    //
    // we just try to parse the first line. If this succeeds, we assume OS/2
    // format
    //

    WIN32_FIND_DATA findData;
    PARSE_STATE state;

    buffer = *lpBuffer;
    length = *lpdwBufferLength;
    state = ParseOs2Directory(&buffer, &length, &findData);
    if ((state == State_Continue) || (state == State_Done)) {

        DEBUG_PRINT(FTP,
                    INFO,
                    ("format is OS/2\n"
                    ));

        success = TRUE;
        *lpfnParserFunction = ParseOs2Directory;
        goto quit;
    }

    //
    // Mac? Mac servers return Unix-like output which will (should) have already
    // been handled by the Unix listing check, and a very simple format which
    // just consists of names with an optional '/' appended, indicating a
    // directory
    //

    //
    // the Telnet 2.6 FTP server (which just reports the ultra-simple listing
    // format) returns a weird 'hidden' entry at the start of the listing which
    // consists of "\x03\x02\x01". We will skip all leading control characters
    //

    buffer = *lpBuffer;
    length = *lpdwBufferLength;
    while (length && (*buffer < ' ')) {
        ++buffer;
        --length;
    }

    LPSTR buffer_;
    DWORD length_;

    buffer_ = buffer;
    length_ = length;

    state = ParseMacDirectory(&buffer, &length, &findData);
    if ((state == State_Continue) || (state == State_Done)) {

        DEBUG_PRINT(FTP,
                    INFO,
                    ("format is Mac\n"
                    ));

        *lpBuffer = buffer_;
        *lpdwBufferLength = length_;
        success = TRUE;
        *lpfnParserFunction = ParseMacDirectory;
        goto quit;
    }

    //
    // failed to determine the format
    //

    success = FALSE;

quit:

    DEBUG_LEAVE(success);

    return success;
}


PRIVATE
BOOL
IsNtDateFormat(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Determines if the directory listing starts with an NT-style date field:

        MM-DD-YY

Arguments:

    lpBuffer        - pointer to buffer containing listing

    dwBufferLength  - number of bytes in lpBuffer

Return Value:

    BOOL
        TRUE    - buffer starts with NT-style date format

        FALSE   - not NT-listing

--*/

{
    if (dwBufferLength > 8) {

        LPSTR buffer;
        WORD number;

        buffer = lpBuffer;
        if (!ParseWord(&buffer, &dwBufferLength, 1, 12, &number)) {
            return FALSE;
        }
        if (!((dwBufferLength > 0) && (*buffer == '-'))) {
            return FALSE;
        }
        ++buffer;
        --dwBufferLength;
        if (!ParseWord(&buffer, &dwBufferLength, 1, 31, &number)) {
            return FALSE;
        }
        if (!((dwBufferLength > 0) && (*buffer == '-'))) {
            return FALSE;
        }
        ++buffer;
        --dwBufferLength;
        return ParseWord(&buffer, &dwBufferLength, 0, MAX_YEAR_SUPPORTED, &number);
    }
    return FALSE;
}


PRIVATE
BOOL
GetToken(
    IN LPSTR lpszBuffer,
    IN DWORD dwBufferLength,
    OUT LPSTR lpszToken,
    IN OUT LPDWORD lpdwTokenLength
    )

/*++

Routine Description:

    Copies a token out of the buffer without updating the buffer pointer or length

Arguments:

    lpszBuffer      - pointer to buffer to copy from

    lpBufferLength  - length of buffer

    lpszToken       - buffer to copy to

    lpdwTokenLength - length of buffer on input, length of token on output

Return Value:

    BOOL

--*/

{
    DWORD length;

    if (!SkipSpaces(&lpszBuffer, &dwBufferLength)) {
        return FALSE;
    }

    if (dwBufferLength == 0) {
        return FALSE;
    }

    length = *lpdwTokenLength;
    while (!isspace(*lpszBuffer) && (dwBufferLength != 0) && (length != 0)) {
        *lpszToken++ = *lpszBuffer++;
        --dwBufferLength;
        --length;
    }
    *lpdwTokenLength -= length;
    return TRUE;
}


PRIVATE
BOOL
IsUnixAttributeFormat(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Checks if the buffer contains a Unix ls attribute field format

Arguments:

    lpBuffer        - pointer to buffer containing token to check

    dwBufferLength  - length of buffer

Return Value:

    BOOL
        TRUE    - lpBuffer *probably* contained a Unix attribute field
        FALSE   - lpBuffer *probably didn't* contain a Unix attribute field

--*/

{
    int i;
    int hits;

    if (dwBufferLength != 10) {
        return FALSE;
    }

    //
    // the first character contains 'd' for directory, 'l' for link, '-' for
    // file, and may contain other, unspecified characters, so we just ignore
    // it. So long as the next 9 characters are in the set [-rwx] then we have
    // a Unix ls attribute field.
    //
    // N.B. it turns out that the first character can be in the set [-bcdlp]
    // and the attribute characters can be in the set [-lrsStTwx] (as of
    // 08/18/95)
    //

    ++lpBuffer;
    hits = 0;
    for (i = 0; i < 9; ++i) {

        char ch;

        ch = tolower(*lpBuffer);
        ++lpBuffer;

        if ((ch == '-')
        || (ch == 'l')
        || (ch == 'r')
        || (ch == 's')
        || (ch == 't')
        || (ch == 'w')
        || (ch == 'x')) {
            ++hits;
        }
    }

    //
    // new scheme: we decide if the token was a Unix attribute field based on
    // probability. If the hit rate was greater than 1 in 2 (5 out of 9 or
    // higher) then we say that the field was probably a Unix attribute. This
    // scheme allows us to accept future enhancements or non-standard Unix
    // implementations without changing this code (for a while) (Make the
    // attribute set a registry value (!))
    //

    return hits >= 5;
}


PRIVATE
PARSE_STATE
ParseNtDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Parses a single line of an NT directory listing (output from DIR) into a
    WIN32_FIND_DATA structure

    The format of an NT directory list line is:

    <date> <time> <'<DIR>'|<size>> <filename>

Arguments:

    lpBuffer        - pointer to pointer to directory listing

    lpBufferLength  - pointer to number of bytes remaining in lpBuffer

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    PARSE_STATE
        State_Continue  - more listing to parse

        State_Done      - fin!

--*/

{
    //
    // not expecting the line to start with spaces, but we check anyway
    //

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto done;
    }

    if (!ExtractNtDate(lpBuffer, lpBufferLength, lpFindData)) {
        goto done;
    }

    if (!strnicmp(*lpBuffer, "<DIR>", 5)) {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        lpFindData->nFileSizeHigh = 0;
        lpFindData->nFileSizeLow = 0;
        FindToken(lpBuffer, lpBufferLength);
    } else {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
        ExtractFileSize(lpBuffer, lpBufferLength, lpFindData);
        SkipSpaces(lpBuffer, lpBufferLength);
    }

    _ExtractFilename(lpBuffer, lpBufferLength, lpFindData);

    //
    // we expect the filename to be the last thing on the line
    //

done:

    return SkipLine(lpBuffer, lpBufferLength) ? State_Continue : State_Done;
}


PRIVATE
void
ReadUnixPermissions(
    IN LPCSTR pszBuffer,
    IN DWORD cbBufferSize,
    OUT LPDWORD pdwPermissions)
{
    // Format: rwxrwxrwx <Owner><Group><All>
    *pdwPermissions = 0;

    if (cbBufferSize > 10)
    {
        if ('r' == pszBuffer[1])
            *pdwPermissions |= 0x00000400;

        if ('w' == pszBuffer[2])
            *pdwPermissions |= 0x00000200;

        if ('x' == pszBuffer[3])
            *pdwPermissions |= 0x00000100;

        if ('r' == pszBuffer[4])
            *pdwPermissions |= 0x00000040;

        if ('w' == pszBuffer[5])
            *pdwPermissions |= 0x00000020;

        if ('x' == pszBuffer[6])
            *pdwPermissions |= 0x00000010;

        if ('r' == pszBuffer[7])
            *pdwPermissions |= 0x00000004;

        if ('w' == pszBuffer[8])
            *pdwPermissions |= 0x00000002;

        if ('x' == pszBuffer[9])
            *pdwPermissions |= 0x00000001;
    }
}


PRIVATE
PARSE_STATE
ParseUnixDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Parses a single line of a Unix directory listing (output from ls) into a
    WIN32_FIND_DATA structure

    The format of a Unix directory list line is:

    <attributes> <link-count> <owner> <group> <size> <date-time> <filename>

Arguments:

    lpBuffer        - pointer to pointer to directory listing

    lpBufferLength  - pointer to number of bytes remaining in lpBuffer

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    PARSE_STATE
        State_Continue  - more listing to parse

        State_Done      - fin!

--*/

{
    DWORD error;
    int i;
    BOOL symbolicLink;
    char ch;

    //
    // not expecting the line to start with spaces, but we check anyway
    //

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto done;
    }

    //
    // if the item is a symbolic link then we have to trim the 'filename' below
    //

    ch = tolower(**lpBuffer);
    symbolicLink = (ch == 'l');

    //
    // attributes are first thing on line
    //

    lpFindData->dwFileAttributes = (ch == 'd') ? FILE_ATTRIBUTE_DIRECTORY
                                 : (ch == '-') ? FILE_ATTRIBUTE_NORMAL
                                 : 0;

    //
    // skip over the attributes and over the owner/creator fields to the file
    // size
    //

    // Read the Attributes and put them in the WIN32_FIND_DATA.dwReserved0 attributes.
    // It's OK to use FILE_ATTRIBUTE_REPARSE_POINT because it's unused unless
    // WIN32_FIND_DATA.dwFileAttributes contains yyy, which we don't set.
    ReadUnixPermissions(*lpBuffer, *lpBufferLength, &(lpFindData->dwReserved0));

    LPSTR lpszLastToken;
    DWORD dwLastToken;

    for (i = 0; i < 4; ++i) {
        lpszLastToken = *lpBuffer;
        dwLastToken = *lpBufferLength;
        if (!FindToken(lpBuffer, lpBufferLength)) {
            goto done;
        }
    }

    if (!ExtractFileSize(lpBuffer, lpBufferLength, lpFindData)) {
        ExtractFileSize(&lpszLastToken, &dwLastToken, lpFindData);
    }

    SkipSpaces(lpBuffer, lpBufferLength);

    if (!ExtractUnixDate(lpBuffer, lpBufferLength, lpFindData)) {
        goto done;
    }

    SkipSpaces(lpBuffer, lpBufferLength);

    //
    // we expect the filename to be the last thing on the line
    //

    _ExtractFilename(lpBuffer, lpBufferLength, lpFindData);

    //
    // if the item is a symbolic link, then remove everything after the " -> "
    //

    if (symbolicLink) {

        LPSTR lpArrow;

        lpArrow = strstr(lpFindData->cFileName, " -> ");
        if (lpArrow != NULL) {
            *lpArrow = '\0';
        }
    }

done:

    return SkipLine(lpBuffer, lpBufferLength) ? State_Continue : State_Done;
}


PRIVATE
PARSE_STATE
ParseOs2Directory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Parses a single line of an OS/2 directory listing (output from dir) into a
    WIN32_FIND_DATA structure

    The format of an OS/2 directory list line is:

    <size> <attributes> <date> <time> <filename>

    This function is also used to determine OS/2 directory format

Arguments:

    lpBuffer        - pointer to pointer to directory listing

    lpBufferLength  - pointer to number of bytes remaining in lpBuffer

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    PARSE_STATE
        State_Continue  - more listing to parse

        State_Done      - fin!

        State_Error     - directory format not recognized
--*/

{
    PARSE_STATE state;

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto skip;
    }

    if (!ExtractFileSize(lpBuffer, lpBufferLength, lpFindData)) {
        state = State_Error;
        goto done;
    }

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto skip;
    }

    if (!strnicmp(*lpBuffer, "DIR", 3)) {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        FindToken(lpBuffer, lpBufferLength);
    } else if (!isdigit(**lpBuffer)) {
        if (!ExtractOs2Attributes(lpBuffer, lpBufferLength, lpFindData)) {
            state = State_Error;
            goto done;
        }
        SkipSpaces(lpBuffer, lpBufferLength);
    } else {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    if (!ExtractNtDate(lpBuffer, lpBufferLength, lpFindData)) {
        state = State_Error;
        goto done;
    }

    _ExtractFilename(lpBuffer, lpBufferLength, lpFindData);

    //
    // we expect the filename to be the last thing on the line
    //

skip:

    state = SkipLine(lpBuffer, lpBufferLength) ? State_Continue : State_Done;

done:

    return state;
}


PRIVATE
PARSE_STATE
ParseMacDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Parses a single line of a Mac directory listing (output from ls) into a
    WIN32_FIND_DATA structure

    The format of a Mac directory list line is:

    <dir-or-file-name>[/]

    This function is also used to determine Mac directory format

Arguments:

    lpBuffer        - pointer to pointer to directory listing

    lpBufferLength  - pointer to number of bytes remaining in lpBuffer

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    PARSE_STATE
        State_Continue  - more listing to parse

        State_Done      - fin!

        State_Error     - directory format not recognized

--*/

{
    PARSE_STATE state;

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto skip;
    }

    _ExtractFilename(lpBuffer, lpBufferLength, lpFindData);

    int len;

    len = lstrlen(lpFindData->cFileName);
    if (lpFindData->cFileName[len - 1] == '/') {
        lpFindData->cFileName[len - 1] = '\0';
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    } else {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
    }
    if ((*lpBufferLength != 0)
    && !((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        state = State_Error;
        goto done;
    }

    //
    // this directory format has no size or time information
    //

    lpFindData->nFileSizeLow = 0;
    lpFindData->nFileSizeHigh = 0;
    SystemTimeToFileTime(&DefaultSystemTime, &lpFindData->ftLastWriteTime);

    //
    // we expect the filename to be the last thing on the line
    //

skip:

    state = SkipLine(lpBuffer, lpBufferLength) ? State_Continue : State_Done;

done:

    return state;
}


PRIVATE
BOOL
ExtractFileSize(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Extracts the the next token in the directory listing. The next token is
    expected to be the file size. It is extracted to the WIN32_FIND_DATA
    structure

    Assumes:    1. The file size is <= 32 bits

Arguments:

    lpBuffer        - pointer to pointer to directory listing buffer

    lpBufferLength  - pointer to remaining buffer length

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL

--*/

{
    INET_ASSERT(*lpBufferLength != 0);

    LPSTR buffer;
    char ch = **lpBuffer;

    if (isdigit(ch)) {
        lpFindData->nFileSizeLow = strtoul(*lpBuffer, &buffer, 10);
        lpFindData->nFileSizeHigh = 0;
        *lpBufferLength -= (DWORD) (buffer - *lpBuffer);
        *lpBuffer = buffer;
        return TRUE;
    }
    return FALSE;
}


PRIVATE
BOOL
_ExtractFilename(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Extracts the filename from the current directory listing position into the
    WIN32_FIND_DATA structure

Arguments:

    lpBuffer        - pointer to pointer to directory listing buffer

    lpBufferLength  - pointer to remaining buffer length

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL

--*/

{
    LPSTR dest;
    DWORD destLength;

    dest = lpFindData->cFileName;
    destLength = sizeof(lpFindData->cFileName) - 1;
    while ((*lpBufferLength != 0)
    && (destLength != 0)
    && !((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        *dest++ = *(*lpBuffer)++;
        --*lpBufferLength;
        --destLength;
    }
    *dest = '\0';
    return TRUE;
}


PRIVATE
BOOL
ExtractNtDate(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Extracts an NT date and time from the directory listing. NT dates have a
    specific format:

        MM-DD-YY hh:mmPP

Arguments:

    lpBuffer        - pointer to pointer to current position in directory list

    lpBufferLength  - number of bytes til end of directory list

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    SYSTEMTIME systemTime;
    LPSTR buffer;
    DWORD buflen;
    int number;
    LPSTR stop;
    LPSYSTEMTIME lpSystemTime;

    lpSystemTime = &DefaultSystemTime;

    //
    // BUGBUG - what about internationalization? E.g. does UK FTP server return
    //          the date as e.g. 27/07/95? Other formats?
    //

    //
    // month ::= 1..12
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 1, 12, &systemTime.wMonth)) {
        goto done;
    }
    if (!((*lpBufferLength > 0) && (**lpBuffer == '-'))) {
        goto done;
    }
    ++*lpBuffer;
    --*lpBufferLength;

    //
    // date ::= 1..31
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 1, 31, &systemTime.wDay)) {
        goto done;
    }
    if (!((*lpBufferLength > 0) && (**lpBuffer == '-'))) {
        goto done;
    }
    ++*lpBuffer;
    --*lpBufferLength;

    //
    // year ::= 0..2100
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 0, MAX_YEAR_SUPPORTED, &systemTime.wYear)) {
        goto done;
    }
    if (!((*lpBufferLength > 0) && (**lpBuffer == ' '))) {
        goto done;
    }

    //
    // the oldest file can be dated 1980. We allow the following:
    //
    //  1-1-79              => 1-1-2079
    //  1-1-80..12-31-99    => 1-1-1980..12-31-1999
    //  1-1-00              => 1-1-2000
    //  1-1-1995            => 1-1-1995
    //  1-1-2001            => 1-1-2001
    //  etc.
    //

    systemTime.wYear += (systemTime.wYear < 80)
                        ? 2000
                        : (systemTime.wYear <= 99)
                            ? 1900
                            : 0
                            ;

    //
    // find start of time (er, Professor Hawking..?)
    //

    if (!FindToken(lpBuffer, lpBufferLength)) {
        goto done;
    }

    //
    // hour ::= 0..23 | 1..12
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 0, 23, &systemTime.wHour)) {
        goto done;
    }
    if (!((*lpBufferLength > 0) && (**lpBuffer == ':'))) {
        goto done;
    }
    ++*lpBuffer;
    --*lpBufferLength;

    //
    // minute ::= 0..59
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 0, 59, &systemTime.wMinute)) {
        goto done;
    }

    //
    // if the time is followed by AM or PM then convert to 24-hour time if PM
    // and skip to end of token in both cases
    //

    if (*lpBufferLength >= 2) {

        char ch_p;

        ch_p = tolower(**lpBuffer);
        if ((ch_p == 'p') || (ch_p == 'a')) {

            char ch_m;

            ch_m = tolower(*(*lpBuffer + 1));
            if ((ch_p == 'p') && (ch_m == 'm')) {
                // 12 PM = 12, 1PM = 13, 2PM = 14, etc
                if ( systemTime.wHour < 12 ) {
                    systemTime.wHour += 12;
                }
            } else if ( systemTime.wHour == 12 ) {
                // 12 AM == 0:00 24hr
                INET_ASSERT((ch_p == 'a') && (ch_m == 'm'));
                systemTime.wHour = 0;
            }
        }
    }

    //
    // seconds, milliseconds and weekday always zero
    //

    systemTime.wSecond = 0;
    systemTime.wMilliseconds = 0;
    systemTime.wDayOfWeek = 0;

    //
    // get ready to convert the parsed date/time to a FILETIME
    //

    lpSystemTime = &systemTime;

done:

    //
    // convert the system time to file time and move the buffer pointer/length
    // to the next line
    //

    if (!SystemTimeToFileTime(lpSystemTime, &lpFindData->ftLastWriteTime)) {
        SystemTimeToFileTime(&DefaultSystemTime, &lpFindData->ftLastWriteTime);
    }
    FindToken(lpBuffer, lpBufferLength);
    return TRUE;
}


PRIVATE
BOOL
ExtractUnixDate(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Extracts a Unix date and time from the directory listing. Unix dates have a
    multitude of formats:

        Jul  3 14:52
        Oct  7 1994
        Jul 26  4:05
        Jul 26 03:51

Arguments:

    lpBuffer        - pointer to pointer to current position in directory list

    lpBufferLength  - number of bytes til end of directory list

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    SYSTEMTIME systemTime;
    LPSYSTEMTIME lpSystemTime;
    static LPSTR Months = "janfebmaraprmayjunjulaugsepoctnovdec";
    char monthStr[4];
    int i;
    LPSTR offset;
    WORD wnum;

    lpSystemTime = &DefaultSystemTime;

    //
    // month ::= Jan..Dec
    //

    for (i = 0; i < 3; ++i) {
        if (*lpBufferLength == 0) {
            goto done;
        }
        monthStr[i] = *(*lpBuffer)++;
        monthStr[i] = tolower(monthStr[i]);
        --*lpBufferLength;
    }
    monthStr[i] = '\0';
    offset = strstr(Months, monthStr);
    if (offset == NULL) {
        goto done;
    }
    systemTime.wMonth = (unsigned short) ((offset-Months) / 3 + 1);

    FindToken(lpBuffer, lpBufferLength);

    //
    // date ::= 1..31
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 1, 31, &systemTime.wDay)) {
        goto done;
    }

    SkipSpaces(lpBuffer, lpBufferLength);

    //
    // year or hour
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 0, 65535, &wnum)) {
        goto done;
    }

    if ((*lpBufferLength != 0) && (**lpBuffer == ':')) {

        SYSTEMTIME timeNow;

        systemTime.wHour = wnum;

        //
        // we found the hour field, now get the minutes
        //

        ++*lpBuffer;
        --*lpBufferLength;
        if (!ParseWord(lpBuffer, lpBufferLength, 0, 59, &systemTime.wMinute)) {
            goto done;
        }

        //
        // a date-time with an hour:minute field is based in this year. We need
        // to get the current year from the system. There is a slight problem in
        // that if this machine's just had a new year and the FTP server is
        // behind us, then the file can be a year out of date.
        //
        // There is no guarantees about the basis of time used by the FTP server,
        // so we'll get the UTC (aka Greenwich Mean Time) time
        //

        GetSystemTime(&timeNow);
        systemTime.wYear = timeNow.wYear;

        if(!GlobalBypassFtpTimeCheck)
        {
            //
            // apparently its not quite as straightforward as first we'd believed.
            // If the date/month is in the future then the year is last year
            //

            BOOL bLastYear = FALSE;

            if (systemTime.wMonth > timeNow.wMonth) {
                bLastYear = TRUE;
            } else if (systemTime.wMonth == timeNow.wMonth) {

                //
                // BUGBUG - leap year? I believe that in this case, because the time
                //          difference is 1 year minus 1 day, then that is great
                //          enough for the date format including year to have been
                //          used and thus making this moot. Need to prove it.
                //          Note, by that logic, everything from here on down should
                //          also be moot - we should only have to concern ourselves
                //          with the month
                //

                if (systemTime.wDay > timeNow.wDay) {
                    bLastYear = TRUE;
                } else if (systemTime.wDay == timeNow.wDay) {
                    if (systemTime.wHour > timeNow.wHour) {
                        bLastYear = TRUE;
                    } else if (systemTime.wHour == timeNow.wHour) {
                        if (systemTime.wMinute > timeNow.wMinute) {
                            bLastYear = TRUE;
                        } else if (systemTime.wMinute == timeNow.wMinute) {
                            if (systemTime.wSecond > timeNow.wSecond) {
                                bLastYear = TRUE;
                            }
                        }
                    }
                }
            }
            if (bLastYear) {
                --systemTime.wYear;
            }
        }
    } else {

        //
        // next field is the year
        //

        systemTime.wYear = wnum;

        //
        // time for a file with only a year is 00:00 (mitternacht)
        //

        systemTime.wHour = 0;
        systemTime.wMinute = 0;
    }

    //
    // seconds, milliseconds and weekday always zero
    //

    systemTime.wSecond = 0;
    systemTime.wMilliseconds = 0;
    systemTime.wDayOfWeek = 0;

    //
    // get ready to convert the parsed date/time to a FILETIME
    //

    lpSystemTime = &systemTime;

done:

    //
    // convert the system time to file time and move the buffer pointer/length
    // to the next line
    //

    if (!SystemTimeToFileTime(lpSystemTime, &lpFindData->ftLastWriteTime)) {
        SystemTimeToFileTime(&DefaultSystemTime, &lpFindData->ftLastWriteTime);
    }
    FindToken(lpBuffer, lpBufferLength);
    return TRUE;
}


PRIVATE
BOOL
ExtractOs2Attributes(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Converts an OS/2 attribute string into Win32 file attribute flags in the
    WIN32_FIND_DATA structure

Arguments:

    lpBuffer        - pointer to pointer to current position in directory list

    lpBufferLength  - number of bytes til end of directory list

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DWORD attributes = 0;
    BOOL done = FALSE;

    while (*lpBufferLength && !done) {

        char ch = **lpBuffer;

        switch (toupper(ch)) {
        case 'A':
            attributes |= FILE_ATTRIBUTE_ARCHIVE;
            break;

        case 'H':
            attributes |= FILE_ATTRIBUTE_HIDDEN;
            break;

        case 'R':
            attributes |= FILE_ATTRIBUTE_READONLY;
            break;

        case 'S':
            attributes |= FILE_ATTRIBUTE_SYSTEM;
            break;

        case ' ':

            //
            // if there is only one space, we will be pointing at the next token
            // after this function completes. Okay so long as we will be calling
            // SkipSpaces() next (which doesn't expect to be pointing at a space)
            //

            done = TRUE;
            break;
        }
        --*lpBufferLength;
        ++*lpBuffer;
    }

    //
    // if we are here there must have been some characters which looked like
    // OS/2 file attributes
    //

    INET_ASSERT(attributes != 0);

    lpFindData->dwFileAttributes = attributes;

    return TRUE;
}


PRIVATE
BOOL
ParseWord(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN WORD LowerBound,
    IN WORD UpperBound,
    OUT LPWORD lpNumber
    )

/*++

Routine Description:

    Extract a WORD value out of the buffer. To be correctly parsed the number
    field must:

        * start with numeric characters
        * not be negative
        * be >= LowerBound and <= UpperBound
        * must end with a non-numeric character or when the buffer is exhausted

Arguments:

    lpBuffer        - pointer to pointer to buffer containing number to parse

    lpBufferLength  - pointer to remaining length in buffer

    LowerBound      - lowest value converted number can have

    UpperBound      - highest value converted number can have

    lpNumber        - pointer to returned WORD value

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    int number;

    if (ExtractInteger(lpBuffer, lpBufferLength, &number)) {
        if ((number >= (int)LowerBound) && (number <= (int)UpperBound)) {
            *lpNumber = (WORD)number;
            return TRUE;
        }
    }
    return FALSE;
}


PRIVATE
BOOL
ExtractInteger(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    OUT LPINT lpNumber
    )

/*++

Routine Description:

    Performs a strtoul type function, but the input string is not terminated by
    \0. It has an associated length

Arguments:

    lpBuffer        - pointer to pointer to string containing number to extract

    lpBufferLength  - pointer to length of string remaining in lpBuffer

    lpNumber        - pointer to returned value

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    BOOL success;
    int number;

    number = 0;
    if ((*lpBufferLength > 0) && isdigit(**lpBuffer)) {
        while (isdigit(**lpBuffer) && (*lpBufferLength != 0)) {
            number = number * 10 + (int)(**lpBuffer - '0');
            ++*lpBuffer;
            --*lpBufferLength;
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpNumber = number;
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftpapih.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapih.h

Abstract:

    Precompiled include header

Author:

    Richard L Firth (rfirth) 21-Dec-1994

Revision History:

    21-Dec-1994 rfirth
        Created

--*/

#include "dirlist.h"
#include "ftphelp.h"
#include "name.h"
#include "nvt.h"
#include "session.h"
#include "ftpapir.h"
#include "protocol.h"
#include "tcputil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\test\thh\thh.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thh.c

Abstract:

    Test program for handle hierarchy

Author:

    Richard L Firth (rfirth) 12-Jan-1996

Revision History:

    12-Jan-1996 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define OPEN_CONTEXT_VALUE      0x11
#define CONNECT_CONTEXT_VALUE   0x22

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
void usage(void);
void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);

BOOL Verbose = FALSE;
DWORD AsyncResult;
DWORD AsyncError;


void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET hInternet;
    HINTERNET hConnect;
    HINTERNET hRequest;
    BOOL callbacks = FALSE;
    INTERNET_STATUS_CALLBACK cbres;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case 'c':
                callbacks = TRUE;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    hInternet = InternetOpen("Handle Hierarchy Test Program (thh)",
                             LOCAL_INTERNET_ACCESS,
                             NULL,
                             0,
                             0
                             );
    if (!hInternet) {
        print_error("thh()", "InternetOpen()");
        exit(1);
    }

    if (Verbose) {
        printf("InternetOpen() returns handle %x\n", hInternet);
    }

    if (callbacks) {
        if (Verbose) {
            printf("installing callback\n");
        }

        cbres = InternetSetStatusCallback(hInternet, my_callback);
        if (cbres == INTERNET_INVALID_STATUS_CALLBACK) {
            print_error("thh()", "InternetSetStatusCallback()");
            exit(1);
        } else if (Verbose) {
            printf("previous callback = %x\n", cbres);
        }
    }

    if (Verbose) {
        printf("calling InternetConnect()...\n");
    }

    hConnect = InternetConnect(hInternet,
                               "foo.bar.com",
                               0,
                               "albert einstein",
                               "e=mc2",
                               INTERNET_SERVICE_HTTP,
                               0,
                               callbacks ? CONNECT_CONTEXT_VALUE : 0
                               );
    if (!hInternet) {
        print_error("thh()", "InternetConnect()");
        exit(1);
    } else if (Verbose) {
        printf("InternetConnect() returns handle %x\n", hConnect);
    }

    if (Verbose) {
        printf("calling HttpOpenRequest()...\n");
    }

    hRequest = HttpOpenRequest(hConnect,
                               NULL,    // verb
                               NULL,    // object
                               NULL,    // version
                               NULL,    // referrer
                               NULL,    // accept types
                               0,       // flags
                               callbacks ? OPEN_CONTEXT_VALUE : 0
                               );
    if (!hRequest) {
        print_error("thh()", "HttpOpenRequest()");
        exit(1);
    } else if (Verbose) {
        printf("HttpOpenRequest() returns handle %x\n", hRequest);
    }

    if (Verbose) {
        printf("closing InternetOpen() handle %x\n", hInternet);
    }

    if (InternetCloseHandle(hInternet)) {
        if (Verbose) {
            printf("closed Internet handle %x OK\n", hInternet);
        }
    } else {
        print_error("thh()", "InternetCloseHandle()");
        exit(1);
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: thh [-c] [-v]\n"
           "where: -c = use callbacks\n"
           "       -v = verbose mode\n"
           );
    exit(1);
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: H=%x [C=%x [%s]] %s ",
                Handle,
                Context,
                (Context == CONNECT_CONTEXT_VALUE)
                    ? "Connect"
                    : (Context == OPEN_CONTEXT_VALUE)
                        ? "Open   "
                        : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {

                DWORD handleType;
                DWORD handleTypeSize = sizeof(handleType);

                if (InternetQueryOption(*(LPHINTERNET)Info,
                                        INTERNET_OPTION_HANDLE_TYPE,
                                        (LPVOID)&handleType,
                                        &handleTypeSize
                                        )) {
                    switch (handleType) {
                    case INTERNET_HANDLE_TYPE_INTERNET:
                        type$ = "Internet";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_FTP:
                        type$ = "FTP Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
                        type$ = "Gopher Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
                        type$ = "HTTP Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FIND:
                        type$ = "FTP Find";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
                        type$ = "FTP Find HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FILE:
                        type$ = "FTP File";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
                        type$ = "FTP File HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FIND:
                        type$ = "Gopher Find";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
                        type$ = "Gopher Find HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FILE:
                        type$ = "Gopher File";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
                        type$ = "Gopher File HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
                        type$ = "HTTP Request";
                        break;

                    default:
                        type$ = "???";
                        break;
                    }
                } else {
                    type$ = "<error>";
                }
                printf("%x [%s]", *(LPHINTERNET)Info, type$);
            } else if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {

                //
                // nothing
                //

            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else {
                printf(Info);
            }
        }
        putchar('\n');
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftpinit.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftpinit.cxx

Abstract:

    FTP package-specific initialization & termination. Used to be libmain.c

    Contents:
        FtpInitialize
        FtpTerminate

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Environment:

    Win32 user-mode

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// functions
//


VOID
FtpInitialize(
    VOID
    )

/*++

Routine Description:

    Performs FTP-specific initialization

Arguments:

    None.

Return Value:

    None.

--*/

{
    FtpSessionInitialize();
}


VOID
FtpTerminate(
    VOID
    )

/*++

Routine Description:

    Performs FTP-specific termination/cleanup

Arguments:

    None.

Return Value:

    None.

--*/

{
    CleanupFtpSessions();
    FtpSessionTerminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftpapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapia.cxx

Abstract:

    ANSI versions of Windows Internet Client DLL FTP APIs

    Contents:
        FtpFindFirstFileA
        FtpGetFileA
        FtpPutFileA
        FtpDeleteFileA
        FtpRenameFileA
        FtpOpenFileA
        FtpCreateDirectoryA
        FtpRemoveDirectoryA
        FtpSetCurrentDirectoryA
        FtpGetCurrentDirectoryA
        FtpCommandA
        FtpGetFileSize
        FtpGetSystemNameA
        FtpFindNextFileA
        FtpReadFile
        FtpWriteFile
        pFtpGetUrlString

Author:

    Heath Hunnicutt [t-heathh] 13-Jul-1994

Environment:

    Win32 user-level DLL

Revision History:

    09-Mar-1995 rfirth
        moved from findfile.c, ftphelp.c

    13-Jul-1994 t-heathh
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// manifests
//

#define DEFAULT_TRANSFER_BUFFER_LENGTH  (4 K)

#define ALLOWED_FTP_FLAGS               (INTERNET_FLAGS_MASK \
                                        | FTP_TRANSFER_TYPE_MASK \
                                        )

//
// private prototypes
//

PRIVATE
BOOL
FBeginCacheReadProcessing(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL  fIsHtmlFind
    );

PRIVATE
BOOL
FFtpCanReadFromCache(
    IN HINTERNET hFtpSession
    );

PRIVATE
BOOL
FBeginCacheWriteProcessing(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL  fIsHtmlFind
    );

PRIVATE
BOOL
FFtpCanWriteToCache(
    HINTERNET   hFtpSession
    );

DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtpFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

PRIVATE
BOOL
FGetCWDFromCache(
    HINTERNET   hFtpSession,
    LPSTR       lpBuff,
    LPDWORD     lpdwBuffSize
    );

PRIVATE
BOOL
FIsFtpExpired(
    HINTERNET   handle,
    LPCACHE_ENTRY_INFO  lpCEI
    );

VOID
LocalSetObjectName(
    HINTERNET hFtpMapped,
    LPSTR   lpszFileName
    );

PRIVATE
BOOL
IsSearchFileDirectory(
    LPCSTR   lpszFileDirName
);

//
// functions
//


INTERNETAPI_(HINTERNET) FtpFindFirstFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Download the remote site's directory listing and parse it into
    WIN32_FIND_DATA structures that we can pass back to the app.

    If the FTP session is currently involved in a data transfer, such as
    a FtpOpenFile()....FtpCloseFile() series of calls, this function will
    fail.

Arguments:

    hFtpSession     - Handle to an FTP session, as returned from FtpOpen()

    lpszSearchFile  - Pointer to a string containing a file specification
                      that constrains the search.  (e.g., "*.txt"). A NULL
                      pointer is treated the same as an empty string

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds. If this parameter
                      is NULL, then we can still return success, but all find
                      information will be returned via InternetFindNextFile()

    dwFlags         - controlling caching, etc.

    dwContext       - app-supplied context value for call-backs

Return Value:

    HINTERNET
        Success - new find handle

        Failure - NULL. Call GetLastError() for more information:

                    ERROR_INVALID_HANDLE
                        The session handle is not recognized

                    ERROR_FTP_TRANSFER_IN_PROGRESS
                        The data connection is already in use

                    ERROR_NO_MORE_FILES
                        The end of the directory listing has been reached

                    ERROR_INTERNET_EXTENDED_ERROR
                        Call InternetGetLastResponseInfo() for the text

                    ERROR_INTERNET_INTERNAL_ERROR
                        Something bad happened

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "FtpFindFirstFileA",
                     "%#x, %.80q, %#x, %#x, %#x",
                     hFtpSession,
                     lpszSearchFile,
                     lpFindFileData,
                     dwFlags,
                     dwContext
                     ));


    HINTERNET hFind = InternalFtpFindFirstFileA(hFtpSession,
                                                lpszSearchFile,
                                                lpFindFileData,
                                                dwFlags,
                                                dwContext,
                                                FALSE   // not a CACHE_ONLY request
                                                );

    DEBUG_LEAVE_API(hFind);

    return hFind;
}


HINTERNET
InternalFtpFindFirstFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fCacheOnly,
    IN BOOL fAllowEmpty
    )

/*++

Routine Description:

    Download the remote site's directory listing and parse it into
    WIN32_FIND_DATA structures that we can pass back to the app.

    If the FTP session is currently involved in a data transfer, such as
    a FtpOpenFile()....FtpCloseFile() series of calls, this function will
    fail.

Arguments:

    hFtpSession     - Handle to an FTP session, as returned from FtpOpen()

    lpszSearchFile  - Pointer to a string containing a file specification
                      that constrains the search.  (e.g., "*.txt"). A NULL
                      pointer is treated the same as an empty string

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds. If this parameter
                      is NULL, then we can still return success, but all find
                      information will be returned via InternetFindNextFile()

    dwFlags         - controlling caching, etc.

    dwContext       - app-supplied context value for call-backs,

    fCacheOnly      - don't go remote if didn't find in the cache

    fAllowEmpty     - return handle even if no files found

Return Value:

    HINTERNET
        Success - new find handle

        Failure - NULL. Call GetLastError() for more information:

                    ERROR_INVALID_HANDLE
                        The session handle is not recognized

                    ERROR_FTP_TRANSFER_IN_PROGRESS
                        The data connection is already in use

                    ERROR_NO_MORE_FILES
                        The end of the directory listing has been reached

                    ERROR_INTERNET_EXTENDED_ERROR
                        Call InternetGetLastResponseInfo() for the text

                    ERROR_INTERNET_INTERNAL_ERROR
                        Something bad happened

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Handle,
                 "InternalFtpFindFirstFileA",
                 "%#x, %.80q, %#x, %#x, %#x, %B, %B",
                 hFtpSession,
                 lpszSearchFile,
                 lpFindFileData,
                 dwFlags,
                 dwContext,
                 fCacheOnly,
                 fAllowEmpty
                 ));

    HINTERNET findHandle = NULL;
    HINTERNET hConnectMapped = NULL;
    BOOL isLocal;
    BOOL isAsync = FALSE;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    BOOL bIsWorker = FALSE;
    BOOL bNonNestedAsync = FALSE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    bIsWorker = lpThreadInfo->IsAsyncWorkerThread;
    bNonNestedAsync = bIsWorker && (lpThreadInfo->NestedRequests == 1);

    //
    // if this is the async part of the request and this function is not nested
    // then hFtpSession is actually the mapped address of the find handle
    //

    if (bNonNestedAsync) {
        findHandle = hFtpSession;
        hConnectMapped = ((FTP_FIND_HANDLE_OBJECT *)findHandle)->GetParent();
    } else {
        error = MapHandleToAddress(hFtpSession, (LPVOID *)&hConnectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hConnectMapped == NULL)) {
            goto quit;
        }
        error = RIsHandleLocal(hConnectMapped,
                               &isLocal,
                               &isAsync,
                               TypeFtpConnectHandle
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // validate parameters
        //

        if ((ARGUMENT_PRESENT(lpFindFileData)
            && IsBadWritePtr(lpFindFileData, sizeof(*lpFindFileData)))
        || (ARGUMENT_PRESENT(lpszSearchFile)
            && IsBadStringPtr(lpszSearchFile, INTERNET_MAX_PATH_LENGTH + 1))) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // convert NULL search argument to empty string
        //

        if (!ARGUMENT_PRESENT(lpszSearchFile)) {
            lpszSearchFile = "";
        }

        //
        // set the context and handle info and clear last error variables
        //

        _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hConnectMapped);
        _InternetSetContext(lpThreadInfo, dwContext);
        _InternetClearLastError(lpThreadInfo);

        //
        // create the handle object now. This can be used to cancel the async
        // operation, or the sync operation if InternetCloseHandle() is called
        // from a different thread
        //

        INET_ASSERT(findHandle == NULL);

        error = RMakeFtpFindObjectHandle(hConnectMapped,
                                         &findHandle,
                                         (CLOSE_HANDLE_FUNC)wFtpFindClose,
                                         dwContext
                                         );
        if (error != ERROR_SUCCESS) {

            INET_ASSERT(findHandle == NULL);

            goto quit;
        }

        //
        // add another reference: we need this to protect the handle against
        // closure in callbacks and across the async thread transition
        //

        ((HANDLE_OBJECT *)findHandle)->Reference();

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)findHandle)->GetPseudoHandle(),
                                 findHandle
                                 );
    }

    //
    // check to see if the data is in the cache. Do it here so that we don't
    // waste any time going async if we already have the data locally
    //

    if (IsSearchFileDirectory(lpszSearchFile)
    && FBeginCacheReadProcessing(findHandle,
                                 lpszSearchFile,
                                 GENERIC_READ,
                                 dwFlags,
                                 dwContext,
                                 ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)
                                            ->IsHtmlFind()))// doing html finds

    {

        error = ERROR_SUCCESS;

        if (lpFindFileData) {

            DWORD dwBytes = sizeof(WIN32_FIND_DATA);

            error = ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->ReadCache(
                        (LPBYTE)lpFindFileData,
                        sizeof(WIN32_FIND_DATA),
                        &dwBytes
                        );
        }
        if (error == ERROR_SUCCESS) {
            goto quit;
        } else {
            ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->EndCacheRetrieval();
        }
    }
    if (!((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->IsCacheReadInProgress()) {

        // if this is a cacheonly request or we are in OFFLINE mode
        // then fail

        if (fCacheOnly ||
            ((((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->
                GetInternetOpenFlags() | dwFlags) & INTERNET_FLAG_OFFLINE)) {
            error = ERROR_PATH_NOT_FOUND;
            goto quit;
        }
    }

    //
    // the data wasn't in the cache. If the app requested async operation and
    // we are in the app's synchronous thread context then queue the request to
    // the async scheduler
    //

    if (!bIsWorker && isAsync && (dwContext != INTERNET_NO_CALLBACK)) {

        CFsm_FtpFindFirstFile * pFsm = new CFsm_FtpFindFirstFile(
            lpszSearchFile,
            lpFindFileData,
            dwFlags,
            dwContext
            );

        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            if (error == ERROR_SUCCESS) {
                error = pFsm->QueueWorkItem();
                if (error == ERROR_IO_PENDING) {
                    hConnectMapped = NULL;
                    findHandle = NULL;
                }
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);

        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

    //
    // if we're here then we're on the synchronous path: either async I/O was
    // not requested, or we failed to make the request asynchronous
    //

    HINTERNET protocolFtpHandle;

    error = RGetLocalHandle(hConnectMapped, &protocolFtpHandle);
    if (error == ERROR_SUCCESS) {

        HINTERNET protocolFindHandle;

        error = wFtpFindFirstFile(protocolFtpHandle,
                                  lpszSearchFile,
                                  lpFindFileData,
                                  &protocolFindHandle
                                  );

        if (error == ERROR_NO_MORE_FILES && fAllowEmpty) {

            //
            // The directory is empty.  Allow a handle to be returned,
            // but mark it empty so FtpFindNextFile doesn't complain.
            //

            ((FTP_FIND_HANDLE_OBJECT *) findHandle)->SetIsEmpty();
            error = ERROR_SUCCESS;
        }

        if (error == ERROR_SUCCESS) {
            ((FTP_FIND_HANDLE_OBJECT *)findHandle)->SetFindHandle(
                                                        protocolFindHandle
                                                        );
        }
    }

    //
    // if we succeeded in getting the data, add it to the cache
    //

    if (error == ERROR_SUCCESS) {

        //
        // don't worry about errors if cache write fails
        //

        if (IsSearchFileDirectory(lpszSearchFile)  && FBeginCacheWriteProcessing(findHandle,
                                       lpszSearchFile,
                                       GENERIC_READ,
                                       dwFlags,
                                       dwContext,
                                       ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)
                                            ->IsHtmlFind()// doing html finds
                                       )) {
            if (!((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->IsHtmlFind()
                     && lpFindFileData) {

                DWORD dwBytes = sizeof(WIN32_FIND_DATA);
                DWORD errorCache;

                errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->
                                WriteCache((LPBYTE)lpFindFileData,
                                           sizeof(WIN32_FIND_DATA)
                                           );
                if (errorCache != ERROR_SUCCESS) {
                    InbLocalEndCacheWrite(findHandle,
                                          NULL,
                                          (errorCache == ERROR_NO_MORE_FILES)
                                          );
                }
            }
        }
    }

quit:

    _InternetDecNestingCount(1);

    if ((!bNonNestedAsync
         || ((error != ERROR_SUCCESS) && (error != ERROR_IO_PENDING)))
        && (findHandle != NULL)) {

        //
        // balance the extra reference we added to protect against closure in
        // callbacks and across the async thread transition. If non-nested
        // async request, this will be accomplished after REQUEST_COMPLETE
        // callback
        //

        if (((HANDLE_OBJECT *)findHandle)->Dereference()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        }
    }

done:

    if (error == ERROR_SUCCESS) {

        //
        // success - return generated pseudo-handle
        //

        findHandle = ((HANDLE_OBJECT *)findHandle)->GetPseudoHandle();
    } else {
        if (bNonNestedAsync) {
            if (((HANDLE_OBJECT *)findHandle)->IsInvalidated()) {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
            }
        }
        if ((error != ERROR_IO_PENDING) && (findHandle != NULL)) {
            _InternetCloseHandle(((HANDLE_OBJECT *)findHandle)->GetPseudoHandle());
            if (bNonNestedAsync) {

                //
                // this handle deref'd at async completion
                //

                hConnectMapped = NULL;
            }

            if (lpThreadInfo) {
                _InternetSetContext(lpThreadInfo, dwContext);
            }
        }
        findHandle = NULL;
    }
    if (hConnectMapped != NULL) {
        DereferenceObject((LPVOID)hConnectMapped);
    }
    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
    }

    DEBUG_LEAVE(findHandle);

    return findHandle;
}


INTERNETAPI_(BOOL) FtpGetFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszRemoteFile,
    IN LPCSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    This is a 'wrapper' function that opens/creates a local file and calls other
    FTP APIs to copy a file from an FTP server to the local file.

    This API does not get remoted, although APIs called herein do

Arguments:

    hFtpSession             - identifies the FTP server where the file resides

    lpszRemoteFile          - name of the file on the server to get

    lpszNewFile             - name of the local file to create

    fFailIfExists           - TRUE if we should not overwrite an existing file

    dwFlagsAndAttributes    - various flags

    dwFlags                 - how to transfer the file: as ASCII text or binary
                              and open options

    dwContext               - app-supplied context value for call-backs

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetFileA",
                     "%#x, %q, %q, %B, %#x, %#x, %#x",
                     hFtpSession,
                     lpszRemoteFile,
                     lpszNewFile,
                     fFailIfExists,
                     dwFlagsAndAttributes,
                     dwFlags,
                     dwContext
                     ));

    BOOL fSuccess = FALSE;
    DWORD error = ERROR_SUCCESS;

    PWSTR pwszRemoteFile = NULL, pwszNewFile = NULL;
    DWORD cc;
    
    if (IsBadStringPtr(lpszRemoteFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszRemoteFile == '\0')
        || IsBadStringPtr(lpszNewFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNewFile == '\0'))
    {
        error = ERROR_INVALID_PARAMETER;
        goto done;
    }

    cc = MultiByteToWideChar(CP_ACP, 0, lpszRemoteFile, -1, NULL, 0);
    pwszRemoteFile = (PWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszRemoteFile)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    MultiByteToWideChar(CP_ACP, 0, lpszRemoteFile, -1, pwszRemoteFile, cc);

    cc = MultiByteToWideChar(CP_ACP, 0, lpszNewFile, -1, NULL, 0);
    pwszNewFile = (PWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszNewFile)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;        
    }
    MultiByteToWideChar(CP_ACP, 0, lpszNewFile, -1, pwszNewFile, cc);

    fSuccess = FtpGetFileW(
                        hFtpSession,
                        pwszRemoteFile,
                        pwszNewFile,
                        fFailIfExists,
                        dwFlagsAndAttributes,
                        dwFlags,
                        dwContext);

done:
    if (pwszRemoteFile)
    {
        FREE_MEMORY(pwszRemoteFile);
    }
    if (pwszNewFile)
    {
        FREE_MEMORY(pwszNewFile);
    }
    
    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        DEBUG_ERROR(API, error);
    }
    DEBUG_LEAVE_API(fSuccess);

    return fSuccess;
}


INTERNETAPI_(BOOL) FtpPutFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    This is a 'wrapper' function that opens/creates a local file and calls other
    FTP APIs to copy a file from an FTP server to the local file.

    This API does not get remoted, although APIs called herein do

    BUGBUG - this API is virtually the same as FtpGetFileA(). Check out
             possibility of commonalizing

Arguments:

    hFtpSession         - identifies the FTP server where the file resides

    lpszLocalFile       - name of the local file to upload

    lpszNewRemoteFile   - name of the file on the server to create

    dwFlags             - how to transfer the file: as ASCII text or binary and
                          open options

    dwContext           - app-supplied context value for call-backs

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpPutFileA",
                     "%#x, %q, %q, %#x, %#x",
                     hFtpSession,
                     lpszLocalFile,
                     lpszNewRemoteFile,
                     dwFlags,
                     dwContext
                     ));

    BOOL fSuccess = FALSE;
    DWORD error = ERROR_SUCCESS;

    PWSTR pwszRemoteFile = NULL, pwszNewFile = NULL;
    DWORD cc;
    
    if (IsBadStringPtr(lpszNewRemoteFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNewRemoteFile == '\0')
        || IsBadStringPtr(lpszLocalFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszLocalFile == '\0'))
    {
        error = ERROR_INVALID_PARAMETER;
        goto done;
    }

    cc = MultiByteToWideChar(CP_ACP, 0, lpszNewRemoteFile, -1, NULL, 0);
    pwszRemoteFile = (PWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszRemoteFile)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    MultiByteToWideChar(CP_ACP, 0, lpszNewRemoteFile, -1, pwszRemoteFile, cc);

    cc = MultiByteToWideChar(CP_ACP, 0, lpszLocalFile, -1, NULL, 0);
    pwszNewFile = (PWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszNewFile)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;        
    }
    MultiByteToWideChar(CP_ACP, 0, lpszLocalFile, -1, pwszNewFile, cc);

    fSuccess = FtpPutFileW(
                        hFtpSession,
                        pwszNewFile,
                        pwszRemoteFile,
                        dwFlags,
                        dwContext);

done:
    if (pwszRemoteFile)
    {
        FREE_MEMORY(pwszRemoteFile);
    }
    if (pwszNewFile)
    {
        FREE_MEMORY(pwszNewFile);
    }
    
    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        DEBUG_ERROR(API, error);
    }
    DEBUG_LEAVE_API(fSuccess);

    return fSuccess;
}


INTERNETAPI_(BOOL) FtpDeleteFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName
    )

/*++

Routine Description:

    Deletes the named file at the FTP server

Arguments:

    hFtpSession     - identifies FTP server where file is to be deleted

    lpszFileName    - name of file to delete

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpDeleteFileA",
                     "%#x, %q",
                     hFtpSession,
                     lpszFileName
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszFileName, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszFileName == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        // BUGBUG there is hole in this API, there is no dwFlags
        // so there is no way to know whether these operations are
        // happening online or offline
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->GetInternetOpenFlags() &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpDeleteFile * pFsm;

            pFsm = new CFsm_FtpDeleteFile(hFtpSession, lpszFileName);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    LocalSetObjectName(hMapped, (LPSTR)lpszFileName);

    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {

        error = wFtpDeleteFile(ftpHandle, lpszFileName);

        if (error == ERROR_SUCCESS) {

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->ExpireDependents();

        }
    }

quit:

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }
    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpRenameFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    )

/*++

Routine Description:

    Renames a file on an FTP server

Arguments:

    hFtpSession     - identifies FTP server where file is to be renamed

    lpszExisting    - current file name

    lpszNew         - new file name

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpRenameFileA",
                     "%#x, %q, %q",
                     hFtpSession,
                     lpszExisting,
                     lpszNew
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1))
    {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszExisting, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszExisting == '\0')
        || IsBadStringPtr(lpszNew, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNew == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        // BUGBUG there is hole in this API, there is no dwFlags
        // so there is no way to know whether these operations are
        // happening online or offline
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->GetInternetOpenFlags() &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpRenameFile * pFsm;

            pFsm = new CFsm_FtpRenameFile(hFtpSession, lpszExisting, lpszNew);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    HINTERNET ftpHandle;

    LocalSetObjectName(hMapped, (LPSTR)lpszExisting);

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpRenameFile(ftpHandle,
                               lpszExisting,
                               lpszNew
                               );

        if (error == ERROR_SUCCESS) {

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->ExpireDependents();

        }
    }

quit:

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(HINTERNET) FtpOpenFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sets up the FTP session to read or write a file at the FTP server

Arguments:

    hFtpSession     - InternetConnect handle identifying FTP server

    lpszFileName    - name of file to open

    dwAccess        - how to access file - for read or write. Can be one of:
                        - GENERIC_READ
                        - GENERIC_WRITE

    dwFlags         - how to transfer file - ASCII text, or binary and open
                      options. Can be any or all of the following:
                        - INTERNET_FLAG_RELOAD

                        - INTERNET_FLAG_RAW_DATA (passed through by
                          InternetOpenUrl(), meaningless here)

                        - INTERNET_FLAG_EXISTING_CONNECT (passed through by
                          InternetOpenUrl(), meaningless here)

                        - FTP_TRANSFER_TYPE_XXX

    dwContext       - app-supplied context value for call-backs

Return Value:

    HINTERNET
        Success - handle of FTP file object

        Failure - NULL. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "FtpOpenFileA",
                     "%#x, %q, %#x, %#x, %#x",
                     hFtpSession,
                     lpszFileName,
                     dwAccess,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET hFile = InternalFtpOpenFileA(hFtpSession,
                                           lpszFileName,
                                           dwAccess,
                                           dwFlags,
                                           dwContext,
                                           FALSE   // this is not a cachonly request
                                           );

    DEBUG_LEAVE_API(hFile);

    return hFile;
}


HINTERNET
InternalFtpOpenFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fCacheOnly
    )

/*++

Routine Description:

    Sets up the FTP session to read or write a file at the FTP server

Arguments:

    hFtpSession     - InternetConnect handle identifying FTP server

    lpszFileName    - name of file to open

    dwAccess        - how to access file - for read or write. Can be one of:
                        - GENERIC_READ
                        - GENERIC_WRITE

    dwFlags         - how to transfer file - ASCII text, or binary and open
                      options. Can be any or all of the following:
                        - INTERNET_FLAG_RELOAD

                        - INTERNET_FLAG_RAW_DATA (passed through by
                          InternetOpenUrl(), meaningless here)

                        - INTERNET_FLAG_EXISTING_CONNECT (passed through by
                          InternetOpenUrl(), meaningless here)

                        - FTP_TRANSFER_TYPE_XXX

    dwContext       - app-supplied context value for call-backs

    fCacheOnly      - TRUE if this operation must be satisfied from cache

Return Value:

    HINTERNET
        Success - handle of FTP file object

        Failure - NULL. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Handle,
                 "InternalFtpOpenFileA",
                 "%#x, %q, %#x, %#x, %#x, %B",
                 hFtpSession,
                 lpszFileName,
                 dwAccess,
                 dwFlags,
                 dwContext,
                 fCacheOnly
                 ));

    HINTERNET fileHandle = NULL;
    HINTERNET hConnectMapped;
    HINTERNET hObject;
    HINTERNET hObjectMapped = NULL;
    BOOL bNonNestedAsync = FALSE;

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    DWORD nestingLevel = 0;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    bNonNestedAsync = lpThreadInfo->IsAsyncWorkerThread
                    && (lpThreadInfo->NestedRequests == 0);
    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // if this is the async worker thread AND we haven't been called from
    // another API which is running asynchronously, then what we think is
    // hFtpSession is really the file handle object. Get the handles in the
    // right variables
    //

    if (bNonNestedAsync) {
        hObject = hFtpSession;
        error = MapHandleToAddress(hObject, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        fileHandle = hObjectMapped;
        hConnectMapped = ((FTP_FILE_HANDLE_OBJECT *)fileHandle)->GetParent();
    } else {
        error = MapHandleToAddress(hFtpSession, (LPVOID *)&hConnectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hConnectMapped == NULL)) {
            goto quit;
        }
        hObject = hFtpSession;
        hObjectMapped = hConnectMapped;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hObject, hObjectMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszFileName, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszFileName == '\0')

        //
        // dwAccess must be GENERIC_READ or GENERIC_WRITE, but not both, and
        // can't be zero or have undefined bits set. Comparing for equality
        // works
        //

        || ((dwAccess != GENERIC_READ) && (dwAccess != GENERIC_WRITE))

        //
        // must be a recognized transfer type
        //

        || (((dwFlags & FTP_TRANSFER_TYPE_MASK) != 0)
            ? (((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_ASCII)
            && ((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_BINARY))
            : FALSE)
        || ((dwFlags & ~ALLOWED_FTP_FLAGS) != 0)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // use default transfer type if so requested
        //

        if ((dwFlags & FTP_TRANSFER_TYPE_MASK) == 0) {
            dwFlags |= FTP_TRANSFER_TYPE_BINARY;
        }

        //
        // create the handle object now. This can be used to cancel the async
        // operation, or the sync operation if InternetCloseHandle() is called
        // from a different thread
        //

        INET_ASSERT(fileHandle == NULL);

        error = RMakeFtpFileObjectHandle(hConnectMapped,
                                         &fileHandle,
                                         (CLOSE_HANDLE_FUNC)wFtpCloseFile,
                                         dwContext
                                         );
        if (error != ERROR_SUCCESS) {

            INET_ASSERT(fileHandle == NULL);

            goto quit;
        }

        //
        // add reference to keep handle alive during callbacks and across
        // async thread transition
        //

        ((HANDLE_OBJECT *)fileHandle)->Reference();

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle(),
                                 fileHandle
                                 );
    }

    if (((FTP_FILE_HANDLE_OBJECT *)fileHandle)->SetFileName(lpszFileName) != ERROR_SUCCESS)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    //
    // check to see if the data is in the cache
    //

    if (FBeginCacheReadProcessing(fileHandle,
                                  lpszFileName,
                                  dwAccess,
                                  dwFlags,
                                  dwContext, FALSE)) {
        error = ERROR_SUCCESS;
        goto quit;
    } else {
        if (fCacheOnly ||
                ((((INTERNET_CONNECT_HANDLE_OBJECT *)fileHandle)->
                    GetInternetOpenFlags() | dwFlags )& INTERNET_FLAG_OFFLINE)) {
            // if we are offline,or doing cacheonly request
            // let us give the right error and quit

            error = ERROR_FILE_NOT_FOUND;

            goto quit;
        }
    }

    if (!lpThreadInfo->IsAsyncWorkerThread
    && isAsync
    && (dwContext != INTERNET_NO_CALLBACK)) {

        // MakeAsyncRequest
        CFsm_FtpOpenFile * pFsm;

        pFsm = new CFsm_FtpOpenFile(((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle(),
                                     dwContext,
                                     lpszFileName,
                                     dwAccess,
                                     dwFlags
                                     );
        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if (error == ERROR_IO_PENDING) {
                fileHandle = NULL;
                hObjectMapped = NULL;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);

        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

    HINTERNET protocolFtpHandle;

    error = RGetLocalHandle(hConnectMapped, &protocolFtpHandle);
    if (error == ERROR_SUCCESS) {

        HINTERNET protocolFileHandle;

        error = wFtpOpenFile(protocolFtpHandle,
                             lpszFileName,
                             dwAccess,
                             dwFlags,
                             &protocolFileHandle
                             );
        if (error == ERROR_SUCCESS) {
            ((FTP_FILE_HANDLE_OBJECT *)fileHandle)->SetFileHandle(
                                                        protocolFileHandle
                                                        );
            // Now seems like a reasonable time to remove the entry from the
            // cache IFF the open has GENERIC_WRITE access set, i.e. the
            // caller is about to write to this url and make the cache entry
            // stale. This fixes a problem in FtpParseUrl where we bypass the expiry
            // info by forcing an offline state.

            if (dwAccess & GENERIC_WRITE) {
                DeleteUrlCacheEntryA(((FTP_FILE_HANDLE_OBJECT *)fileHandle)->GetURL());
            }
        }
    }

    if (error == ERROR_SUCCESS) {

        //
        // don't worry about errors if cache write does not begin
        //

        FBeginCacheWriteProcessing(fileHandle,
                                   lpszFileName,
                                   dwAccess,
                                   dwFlags,
                                   dwContext,
                                   FALSE        // not a find
                                   );
    }

quit:

    if (fileHandle != NULL) {

        //
        // balance the refcount we added to keep the handle alive during
        // callbacks and across the async thread transition. If this is a non-
        // nested async request then the reference will be balanced after the
        // REQUEST_COMPLETE callback
        //

        ((HANDLE_OBJECT *)fileHandle)->Dereference();
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (bNonNestedAsync && (error == ERROR_SUCCESS)) {
        hObjectMapped = hConnectMapped;
    }
    if (hObjectMapped != NULL) {

        //
        // if we are about to deref the file handle BUT it is already invalidated
        // because the operation was cancelled, e.g., then do not perform the
        // deref - leave it for the close. Otherwise, the close will fail and
        // will not reinstate the callback parameters
        //

        if (!((hObjectMapped == fileHandle) && ((HANDLE_OBJECT *)fileHandle)->IsInvalidated())) {
            DereferenceObject((LPVOID)hObjectMapped);
        }
    }
    if (error != ERROR_SUCCESS) {

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (fileHandle != NULL)) {

            HANDLE_OBJECT * hConnMapped;
            HINTERNET hConn;

            hConnMapped = (HANDLE_OBJECT *)((HANDLE_OBJECT *)fileHandle)->GetParent();
            if (hConnMapped != NULL) {
                hConn = (HINTERNET)hConnMapped->GetPseudoHandle();
            }
            ((HANDLE_OBJECT *)fileHandle)->Invalidate();
            ((HANDLE_OBJECT *)fileHandle)->Dereference();
            if (hConnMapped != NULL) {
                _InternetSetObjectHandle(lpThreadInfo, hConn, hConnMapped);
                _InternetSetContext(lpThreadInfo, dwContext);
            }
        }

        //
        // error situation, or request is being processed asynchronously: return
        // a NULL handle
        //

        fileHandle = NULL;

        DEBUG_ERROR(API, error);

        SetLastError(error);
    } else {

        //
        // success - return generated pseudo-handle
        //

        fileHandle = ((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle();
    }

    DEBUG_LEAVE(fileHandle);

    return fileHandle;
}


INTERNETAPI_(BOOL) FtpCreateDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Creates a directory on the FTP server

Arguments:

    hFtpSession     - identifies FTP server where directory is to be created

    lpszDirectory   - name of directory to create

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpCreateDirectoryA",
                     "%#x, %q",
                     hFtpSession,
                     lpszDirectory
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszDirectory, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszDirectory == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        // BUGBUG there is hole in this API, there is no dwFlags
        // so there is no way to know whether these operations are
        // happening online or offline
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->GetInternetOpenFlags() &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpCreateDirectory * pFsm;

            pFsm = new CFsm_FtpCreateDirectory(hFtpSession, lpszDirectory);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    HINTERNET ftpHandle;

    LocalSetObjectName(hMapped, (LPSTR)lpszDirectory);

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpCreateDirectory(ftpHandle,
                                    lpszDirectory
                                    );
        if (error == ERROR_SUCCESS) {

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->ExpireDependents();

        }
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;
        DEBUG_ERROR(API, error);
    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpRemoveDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Removes a directory at an FTP server

Arguments:

    hFtpSession     - identifies FTP server where directory is to be removed

    lpszDirectory   - name of directory to remove

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpRemoveDirectoryA",
                     "%#x, %q",
                     hFtpSession,
                     lpszDirectory
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszDirectory, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszDirectory == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        // BUGBUG there is hole in this API, there is no dwFlags
        // so there is no way to know whether these operations are
        // happening online or offline
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->GetInternetOpenFlags() &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpRemoveDirectory * pFsm;

            pFsm = new CFsm_FtpRemoveDirectory(hFtpSession, lpszDirectory);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpRemoveDirectory(ftpHandle,
                                    lpszDirectory
                                    );
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpSetCurrentDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Sets the current directory (for this session) at an FTP server

Arguments:

    hFtpSession     - identifies FTP server at which directory is to be set

    lpszDirectory   - name of directory to make current working directory

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpSetCurrentDirectoryA",
                     "%#x, %q",
                     hFtpSession,
                     lpszDirectory
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    INTERNET_CONNECT_HANDLE_OBJECT * pMapped;

    pMapped = (INTERNET_CONNECT_HANDLE_OBJECT *)hMapped;

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszDirectory, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszDirectory == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // if we are not going to net at all (offline), spoof setting directory
        // at the server
        //

        if (pMapped->GetInternetOpenFlags() & INTERNET_FLAG_OFFLINE) {
            goto set_object_cwd;
        }

        //
        // we have to hit the net. This will be an asynchronous operation if the
        // app requested async
        //

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpSetCurrentDirectory * pFsm;

            pFsm = new CFsm_FtpSetCurrentDirectory(hFtpSession, lpszDirectory);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpSetCurrentDirectory(ftpHandle, lpszDirectory);
    }

set_object_cwd:

    if (error == ERROR_SUCCESS) {
        error = pMapped->SetCurrentWorkingDirectory((LPSTR)lpszDirectory);
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpGetCurrentDirectoryA(
    IN HINTERNET hFtpSession,
    OUT LPSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    )

/*++

Routine Description:

    Gets the name of the current working directory for this session at the
    FTP server identified by hFtpSession

Arguments:

    hFtpSession             - identifies FTP server from which to get directory

    lpszCurrentDirectory    - buffer where name of current directory will be written

    lpdwCurrentDirectory    - IN: size of the buffer
                              OUT: number of bytes returned

Return Value:

    BOOL
        TRUE    - *lpdwCurrentDirectory contains number of characters returned

        FALSE   - Use GetLastError() to get more info. One of the following will
                  be returned:
                    ERROR_INVALID_PARAMETER

                    ERROR_INSUFFICIENT_BUFFER
                        *lpdwCurrentDirectory contains required buffer length

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetCurrentDirectoryA",
                     "%#x, %#x, %#x [%d]",
                     hFtpSession,
                     lpszCurrentDirectory,
                     lpdwCurrentDirectory,
                     lpdwCurrentDirectory ? *lpdwCurrentDirectory : 0
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        //
        // lpdwCurrentDirectory must be present (and writeable - we assume it is)
        //

        if (!ARGUMENT_PRESENT(lpdwCurrentDirectory)

        //
        // lpszCurrentDirectory may be not present, but if it is must be writeable
        // by the number of bytes specified in *lpdwCurrentDirectory
        //

        || (ARGUMENT_PRESENT(lpszCurrentDirectory)
            ? IsBadWritePtr(lpszCurrentDirectory, *lpdwCurrentDirectory) : FALSE)) {

            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // we get CWD from the cache only in disconnected state
    //

    if (FGetCWDFromCache(hMapped, lpszCurrentDirectory, lpdwCurrentDirectory)) {
        error = ERROR_SUCCESS;
        goto quit;
    }

    if (!lpThreadInfo->IsAsyncWorkerThread
        && isAsync) {

        // MakeAsyncRequest
        CFsm_FtpGetCurrentDirectory * pFsm;

        pFsm = new CFsm_FtpGetCurrentDirectory(hFtpSession, lpszCurrentDirectory, lpdwCurrentDirectory);
        if (pFsm != NULL) {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpGetCurrentDirectory(
                    ftpHandle,

                    //
                    // if the caller supplied no buffer then the
                    // buffer length is 0
                    //

                    ARGUMENT_PRESENT(lpszCurrentDirectory)
                        ? *lpdwCurrentDirectory
                        : 0,
                    lpszCurrentDirectory,
                    lpdwCurrentDirectory
                    );
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpCommandA(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand,
    IN DWORD_PTR dwContext,
    OUT HINTERNET *phFtpCommand OPTIONAL
    )

/*++

Routine Description:

    Runs an arbitrary command at the identified FTP server

Arguments:

    hFtpSession     - identifies FTP server where this command is to be run

    fExpectResponse - TRUE if we expect response data

    dwTransferType  - how to receive the data - as ASCII text, or as BINARY,
                      and open options

    lpszCommand     - string describing the command to run

    dwContext       - app-supplied context value for call-backs


    phFtpCommand    - pointer to an optional handle that will be created if
                        a valid data socket is opened, fExpectResponse must
                        be set to TRUE phFtpCommand to be filled
Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpCommandA",
                     "%#x, %B, %#x, %q, %#x, %#x",
                     hFtpSession,
                     fExpectResponse,
                     dwFlags,
                     lpszCommand,
                     dwContext,
                     phFtpCommand
                     ));

    DWORD error;
    HINTERNET hMapped = NULL;
    HINTERNET hCommandMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }


    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    INTERNET_CONNECT_HANDLE_OBJECT * pMapped;

    pMapped = (INTERNET_CONNECT_HANDLE_OBJECT *)hMapped;

    //
    // this is the handle we are currently working on
    //

    _InternetSetObjectHandle(lpThreadInfo,
                             hFtpSession,
                             hMapped
                             );
    _InternetSetContext(lpThreadInfo, dwContext);

    //
    // clear the per-thread object last error variables
    //

    InternetClearLastError();

    BOOL isLocal;
    BOOL isAsync;

    //
    // make RPC or local-worker function call
    //

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );

    if ( error != ERROR_SUCCESS ) {
        goto quit;
    }

    //
    // in offline mode we can't execute commands
    //

    if ((pMapped->GetInternetOpenFlags()|dwFlags) & INTERNET_FLAG_OFFLINE) {
        error = ERROR_INTERNET_NO_DIRECT_ACCESS;
        goto quit;
    }

    //
    // validate parameters
    //

    if ( !lpThreadInfo->IsAsyncWorkerThread
         || (lpThreadInfo->NestedRequests > 1) )
    {
        //
        // BUGBUG - reasonable upper limit for command string length?
        //

        if (fExpectResponse && (phFtpCommand == NULL))
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }


        if (IsBadStringPtr(lpszCommand, 1024)
        || (*lpszCommand == '\0')
        || (fExpectResponse
            && (((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_ASCII)
            && ((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_BINARY)))
        || ((dwFlags & ~ALLOWED_FTP_FLAGS) != 0))
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    if (!lpThreadInfo->IsAsyncWorkerThread
    && isAsync
    && (dwContext != INTERNET_NO_CALLBACK)) {

        CFsm_FtpCommand * pFsm;

        pFsm = new CFsm_FtpCommand(hFtpSession,
                                   fExpectResponse,
                                   dwFlags,
                                   lpszCommand,
                                   dwContext,
                                   phFtpCommand
                                   );
        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }


    INET_ASSERT (error == ERROR_SUCCESS) ;

    if ( fExpectResponse )
    {

        //
        // create the handle object now. This can be used to cancel the async
        // operation, or the sync operation if InternetCloseHandle() is called
        // from a different thread
        //

        error = RMakeFtpFileObjectHandle(hMapped,
                                         &hCommandMapped,
                                         (CLOSE_HANDLE_FUNC)wFtpCloseFile,
                                         dwContext
                                         );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this new handle will be used in callbacks
        //

    }


    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS)
    {
        //InternetSetContext(dwContext);
        error = wFtpCommand(ftpHandle,
                            fExpectResponse,
                            dwFlags,
                            lpszCommand
                            );

        if ( fExpectResponse )
        {

            //
            // FTP can only have one active operation per session, so we just return
            // this session handle as the find handle
            //

            ((FTP_FILE_HANDLE_OBJECT *)hCommandMapped)->SetFileHandle(
                                                            ftpHandle
                                                            );

            *phFtpCommand = ((HANDLE_OBJECT *)hCommandMapped)->GetPseudoHandle();
        }
    }

quit:

    BOOL success;

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(DWORD) FtpGetFileSize(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwFileSizeHigh OPTIONAL
    )

/*++

Routine Description:

    Same as base Win32 GetFileSize() function. Returns size of file as reported
    by server (if known). For the IIS FTP server, the file size is reported in
    the response string when we open the file. For other (Unix) server, we need
    to send a "SIZE <filename>" command

Arguments:

    hFile               - hInternet of FTP_FILE_HANDLE_OBJECT returned by
                          FtpOpenFile()

    lpdwFileSizeHigh    - optional pointer to returned high 32 bits of file size

Return Value:

    DWORD
        Success - low 32 bits of size of file associated with hFile. If
                  0xFFFFFFFF is returned then GetLastError() must be used to
                  determine if an error occurred. If GetLastError() returns
                  ERROR_SUCCESS then the file size is 4GB-1

        Failure - 0xFFFFFFFF. GetLastError() returns possible error codes:

                    ERROR_INVALID_HANDLE
                        The handle is not a valid HINTERNET

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        The handle is a valid HINTERNET, but does not describe
                        a FTP FILE handle object

                    ERROR_INVALID_PARAMETER
                        lpdwFileSizeHigh is an invalid pointer

                    ERROR_INTERNET_OVERFLOW
                        The server reported that the file size was >0xFFFFFFFF,
                        but lpdwFileSizeHigh was NULL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Dword,
                     "FtpGetFileSize",
                     "%#x, %#x",
                     hFile,
                     lpdwFileSizeHigh
                     ));

    DWORD error = ERROR_SUCCESS;
    DWORD dwSizeLow = 0;
    DWORD dwSizeHigh = 0;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    FTP_FILE_HANDLE_OBJECT * pFileMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnectMapped = NULL;

    HINTERNET hMapped;

    BOOL fFile = TRUE;

    BOOL isAsync;
    BOOL isLocal;
    BOOL fDeref = TRUE;
    BOOL fDerefSession = FALSE;


    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // validate parameters
    //

    if (lpdwFileSizeHigh != NULL) {
        if(IsBadWritePtr(lpdwFileSizeHigh, sizeof(*lpdwFileSizeHigh))) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        *lpdwFileSizeHigh = 0;
    }

    error = MapHandleToAddress(hFile, (LPVOID *)&pFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (pFileMapped == NULL)) {
        goto quit;
    }

    hMapped = pFileMapped;

    _InternetSetObjectHandle(lpThreadInfo, hFile, pFileMapped);
    _InternetSetContext(lpThreadInfo,
                        ((FTP_FILE_HANDLE_OBJECT *)pFileMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    error = RIsHandleLocal(hMapped, // mapped file handle
                           &isLocal,
                           &isAsync,
                           TypeFtpFileHandle
                           );
    if (error != ERROR_SUCCESS) {

#if 0
        error = RIsHandleLocal((HINTERNET) hMapped,
                               &isLocal,
                               &isAsync,
                               TypeFtpConnectHandle
                               );

        if ( error != ERROR_SUCESS ) {
            goto quit;
        }

        //else ...
        fFile = FALSE;
        pConnectMapped = (INTERNET_CONNECT_HANDLE_OBJECT *) pFileMapped;
        hMapped = (HINTERNET) pConnectMapped;
        pFileMapped = NULL;
#else
        goto quit;
#endif
    }

    //
    // If we're reading from the cache we need to find the file size via the cache api.
    //

    //
    // BUGBUG [arthurbi] - Need to test the cached code path, as it may be that we're
    //  not properly reading from the cached handle
    //

    if (fFile && pFileMapped->IsCacheReadInProgress())
    {
        CACHE_ENTRY_INFO ceiCacheInfo;
        DWORD dwBuffSize = sizeof(ceiCacheInfo);

        if (!pFileMapped->CacheGetUrlInfo(
                        &ceiCacheInfo,
                        &dwBuffSize
                        ))
        {
            error = GetLastError();
            goto quit;
        }

        dwSizeLow =  ceiCacheInfo.dwSizeLow;
        dwSizeHigh = ceiCacheInfo.dwSizeHigh;

        goto quit;
    }

    //
    // if we already know the size of the file from a 150 response, return it
    // immediately, else we need to send a "SIZE" request to the server to get
    // it
    //

    LPFTP_SESSION_INFO lpSessionInfo;
    HINTERNET hHandleMapped;
    HINTERNET hFtpSession;

    //
    // find the FTP_SESSION_INFO and ensure it is set up to receive data
    //

    error = RGetLocalHandle(hMapped, &hFtpSession);
    if (error == ERROR_SUCCESS) {
        if (!FindFtpSession( hFtpSession, &lpSessionInfo)) {
            error = ERROR_INVALID_HANDLE;
            goto quit;
        }
    }
    else
    {
        goto quit;
    }

    fDerefSession = TRUE;

#if 0
    if (!fFile)
    {

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync)
        {
            CFsm_FtpGetFileSize * pFsm;

            pFsm = new CFsm_FtpGetFileSize(hFile);
            if (pFsm != NULL )
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }

        error = wFtpGetFileSize(hMapped, lpSessionInfo, &dwSizeLow, &dwSizeHigh);
    }
    else
#endif
    {
        INET_ASSERT(fFile);

        //
        // if FFTP_KNOWN_FILE_SIZE is set then we already know the file size
        //

        if ( (lpSessionInfo->Flags & FFTP_KNOWN_FILE_SIZE) == 0 ) {
            error = ERROR_INTERNET_ITEM_NOT_FOUND;
            goto quit;
        }

        // set dwSizeLow here..
        dwSizeLow = lpSessionInfo->dwFileSizeLow;
    }

quit:

    if ( fDerefSession ) {
        DereferenceFtpSession(lpSessionInfo);
    }

    if (pFileMapped != NULL && fDeref) {
        DereferenceObject((LPVOID)pFileMapped);
    }

    if ( error != ERROR_SUCCESS )
    {
        dwSizeLow = 0xffffffff;
    }

    SetLastError(error);

    DEBUG_LEAVE_API(dwSizeLow);

    return dwSizeLow;
}


INTERNETAPI_(BOOL) FtpGetSystemNameA(
        IN HINTERNET hSession,
        OUT LPSTR lpszBuffer,
        IN OUT LPDWORD lpdwBufferLength
        )

/*++

Routine Description:

    Returns the results of a "SYST" command sent to the FTP server to identify
    the FTP server/operating system type in use at the site. The server will
    return a string of the form "215 Windows_NT Version 4.0". The FTP status
    code substring "215 " will be stripped before the string is returned to the
    caller

Arguments:

    hSession            - a HINTERNET returned by InternetConnect() describing
                          an FTP session

    lpszBuffer          - pointer to buffer where output string will be stored

    lpdwBufferLength    - IN: the size of lpszBuffer in BYTEs
                          OUT: if successful, the number of CHARACTERs comprising
                          the string in lpszBuffer minus 1 for the string
                          terminator. If ERROR_INSUFFICIENT_BUFFER is returned,
                          the number of BYTEs required to hold the string,
                          including the string termination character

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() to return the error information.
                  Possible error codes are:

                    ERROR_INVALID_HANDLE
                        The handle is not a valid HINTERNET

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        The handle is a valid HINTERNET, but does not describe
                        an FTP connect handle object

                    ERROR_INVALID_PARAMETER
                        lpszBuffer or lpdwBufferLength are invalid pointers

                    ERROR_INSUFFICIENT_BUFFER
                        The buffer size given in *lpdwBufferLength is too small
                        to hold the resultant string. The required buffer length
                        is returned in *lpdwBufferLength

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetSystemNameA",
                     "%#x, %#x, %#x [%d]",
                     hSession,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD error;
    INTERNET_CONNECT_HANDLE_OBJECT * phMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // validate parameters
    //

    if ((lpdwBufferLength == NULL)
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || IsBadWritePtr(lpszBuffer, *lpdwBufferLength)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    error = MapHandleToAddress(hSession, (LPVOID *)&phMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (phMapped == NULL)) {
        goto quit;
    }

quit:

    if (phMapped != NULL) {
        DereferenceObject((LPVOID)phMapped);
    }

    BOOL success;

    if (error == ERROR_SUCCESS) {
        success = TRUE;
    } else {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


//
// Internet subordinate functions
//

BOOL
FtpFindNextFileA(
    IN HINTERNET hFind,
    OUT LPWIN32_FIND_DATA lpFindFileData
    )

/*++

Routine Description:

    Returns the directory entry in the list returned by FtpFindFirstFile()

    Assumes:    1. We are being called from InternetFindNextFile() which has
                   already validated the parameters, set the thread variables,
                   and cleared the object last error info

Arguments:

    hFind           - find object handle, returned by FtpFindFirstFile()

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Bool,
                 "FtpFindNextFileA",
                 "%#x, %#x",
                 hFind,
                 lpFindFileData
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error, errorCache;
    BOOL isLocal;
    BOOL isAsync, fIsHtml = FALSE;

    //
    // make RPC or local-worker function call
    //

    error = RIsHandleLocal(hFind,
                           &isLocal,
                           &isAsync,
                           TypeFtpFindHandle
                           );
    if (error != ERROR_SUCCESS) {

        //
        // if the handle is actually a HTML FTP find handle, then we allow the
        // operation. Note: we can do this because FtpFindNextFile() is not
        // exported, so a rogue app cannot call this function after opening the
        // handle via InternetOpenUrl()
        //

        error = RIsHandleLocal(hFind,
                               &isLocal,
                               &isAsync,
                               TypeFtpFindHandleHtml
                               );
        fIsHtml = (error == ERROR_SUCCESS);
    }

    FTP_FIND_HANDLE_OBJECT * pFind;

    pFind = (FTP_FIND_HANDLE_OBJECT *)hFind;

    if (error == ERROR_SUCCESS) {
        if (pFind->IsCacheReadInProgress()) {

            //we should never get here when the it is a findhtml type handle.
            // internetopenurl should skim it off the top.

            INET_ASSERT(!fIsHtml);

            DWORD   dwLen = sizeof(WIN32_FIND_DATA);
            error = pFind->ReadCache((LPBYTE)lpFindFileData,
                                                                dwLen,
                                                                &dwLen);
            if ((error == ERROR_SUCCESS) && !dwLen) {
                error = ERROR_NO_MORE_FILES;
            }
            goto quit;
        } else {

            INET_ASSERT(!(pFind->GetInternetOpenFlags() & INTERNET_FLAG_OFFLINE));
        }

        HINTERNET ftpHandle;

        error = RGetLocalHandle(hFind, &ftpHandle);
        if (error == ERROR_SUCCESS) {
            if (pFind->IsEmpty()) {
                error = ERROR_NO_MORE_FILES;
            } else {
                error = wFtpFindNextFile(ftpHandle, lpFindFileData);
            }
        }
    }

    errorCache = error;

    if (error == ERROR_SUCCESS) {
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->IsCacheWriteInProgress()) {

            // write here only if it is a native find handle
            // otherwise, internetreadurl will take care
            if (!fIsHtml) {
                errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->WriteCache(
                                (LPBYTE)lpFindFileData,
                                sizeof(WIN32_FIND_DATA)
                                );
            }
        }

    }
    if (errorCache != ERROR_SUCCESS) {
        if (!fIsHtml) {
            InbLocalEndCacheWrite(hFind, NULL, (errorCache == ERROR_NO_MORE_FILES));
        }
    }

quit:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE(success);

    SetLastError(error);

    return success;
}


BOOL
FtpReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    Reads number of bytes from file at FTP server

    Assumes:    1. We are being called from InternetReadFile() which has
                   already validated the parameters, handled the zero byte
                   read case, set the thread variables, and cleared the object
                   last error info

Arguments:

    hFile                   - file object handle, returned by FtpOpenFile()

    lpBuffer                - pointer to user's buffer

    dwNumberOfBytesToRead   - size of user's buffer

    lpdwNumberOfBytesRead   - number of bytes copied to user's buffer on output

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Bool,
                 "FtpReadFile",
                 "%#x, %#x, %d, %#x",
                 hFile,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error, errorCache;
    BOOL isLocal;
    BOOL isAsync;

    FTP_FILE_HANDLE_OBJECT * pFile = (FTP_FILE_HANDLE_OBJECT *)hFile;

    //
    // make RPC or local-worker function call
    //

    error = RIsHandleLocal(hFile,
                           &isLocal,
                           &isAsync,
                           TypeFtpFileHandle
                           );
    if (error == ERROR_SUCCESS) {

        if (pFile->IsCacheReadInProgress()) {
            error = pFile->ReadCache((LPBYTE)lpBuffer,
                                     dwNumberOfBytesToRead,
                                     lpdwNumberOfBytesRead
                                     );
            if (!*lpdwNumberOfBytesRead || (error != ERROR_SUCCESS)) {

                //
                // don't do anything here so we don't barf when someone
                // does an extraneous read. The cache stream gets closed
                // when the handle is closed. bug#9086
//                ((FTP_FILE_HANDLE_OBJECT *)hFile)->EndCacheRetrieval();
                //

            }

            //
            // quit whether we succeed or we fail
            //

            goto quit;
        } else {

            INET_ASSERT(!((pFile->GetInternetOpenFlags()|pFile->GetCacheFlags())
                            & INTERNET_FLAG_OFFLINE));

        }

        HINTERNET ftpHandle;

        error = RGetLocalHandle(hFile, &ftpHandle);
        if (error == ERROR_SUCCESS) {
            error = wFtpReadFile(ftpHandle,
                                 lpBuffer,
                                 dwNumberOfBytesToRead,
                                 lpdwNumberOfBytesRead
                                 );
        }
    }

    if (error == ERROR_SUCCESS) {
        if (pFile->IsCacheWriteInProgress()) {

            if (!*lpdwNumberOfBytesRead) {

                DEBUG_PRINT(CACHE,
                            INFO,
                            ("Cache write complete\r\n"
                            ));

                errorCache = InbLocalEndCacheWrite(hFile, NULL, TRUE);

                INET_ASSERT(error == ERROR_SUCCESS);

                goto quit;
            }

            INET_ASSERT(pFile->IsCacheReadInProgress() == FALSE);

            if (pFile->WriteCache((LPBYTE)lpBuffer,
                                  *lpdwNumberOfBytesRead
                                  ) != ERROR_SUCCESS) {

                DEBUG_PRINT(CACHE,
                            ERROR,
                            ("Error in Cache write\n"
                            ));

                errorCache = InbLocalEndCacheWrite(hFile, NULL, FALSE);

                INET_ASSERT(error == ERROR_SUCCESS);

            }
        }
    }

quit:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}


BOOL
FtpWriteFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    Writes a number of bytes from the user's buffer to an open file on an FTP
    server

    Assumes:    1. We are being called from InternetWriteFile() which has
                   already validated the parameters, handled the zero byte
                   read case, set the thread variables, and cleared the object
                   last error info

Arguments:

    hFile                       - file object handle, returned by FtpOpenFile()

    lpBuffer                    - pointer to user's buffer

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Bool,
                 "FtpWriteFile",
                 "%#x, %#x, %d, %#x",
                 hFile,
                 lpBuffer,
                 dwNumberOfBytesToWrite,
                 lpdwNumberOfBytesWritten
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error;
    BOOL isLocal;
    BOOL isAsync;

    //
    // make RPC or local-worker function call
    //

    error = RIsHandleLocal(hFile,
                           &isLocal,
                           &isAsync,
                           TypeFtpFileHandle
                           );
    if (error == ERROR_SUCCESS) {

        HINTERNET ftpHandle;

        error = RGetLocalHandle(hFile, &ftpHandle);
        if (error == ERROR_SUCCESS) {
            error = wFtpWriteFile(ftpHandle,
                                  lpBuffer,
                                  dwNumberOfBytesToWrite,
                                  lpdwNumberOfBytesWritten
                                  );
            if (error == ERROR_SUCCESS) {

                // expire the url if it exists and it's
                // parent directory

                if( !((FTP_FILE_HANDLE_OBJECT *)hFile)->IsForcedExpirySet()){

                    ((FTP_FILE_HANDLE_OBJECT *)hFile)->ExpireDependents();

                    ((FTP_FILE_HANDLE_OBJECT *)hFile)->SetForcedExpiry(TRUE);

                    ((FTP_FILE_HANDLE_OBJECT *)hFile)->ExpireUrl();
                }
            }
        }
    }

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}


DWORD
pFtpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR    lpszTargetName,
    IN LPSTR    lpszCWD,
    IN LPSTR    lpszObjectName,
    IN LPSTR    lpszExtension,
    IN DWORD    dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine returns a LocaAlloc'ed buffer containing an FTP URL constructed
    from the TargetHost, CWD, and the ObjectName. The caller is responsible
    for freeing the memory.

Arguments:

    SchemeType      - protocol scheme (INTERNET_SCHEME_FTP)

    lpszTargetName  - name of server

    lpszCWD         - current directory at server

    lpszObjectName  - name of file. If NULL or empty then the URL is for a
                      directory

    lpszExtension   - file extension. NOT USED

    dwPort          - port at server

    lplpUrlName     - pointer to returned URL

    lpdwUrlLen      - pointer to returned URL length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD dwError, dwLen, dwT, dwTargetNameLen=0, dwObjectNameLen=0;
    char cBuff[INTERNET_MAX_URL_LENGTH], cBuff1[INTERNET_MAX_URL_LENGTH];//????
    URL_COMPONENTS sUrlComp;
    DWORD dwSav, i, ccFirst, ccTmp;

    INET_ASSERT(lpszTargetName);
    INET_ASSERT(lpszObjectName || lpszCWD);

    //
    // NULL or empty object name == directory
    //

    if ((lpszObjectName != NULL) && (*lpszObjectName == '\0')) {
        lpszObjectName = NULL;
    }

    memcpy(cBuff1, "/", sizeof("/"));
    ccFirst = 2;

    // add the current directory only if the path is a relative one
    if (lpszCWD && !(lpszObjectName && (*lpszObjectName == '/')) ) {
        if (*lpszCWD == '/') {
            ++lpszCWD;
        }
        ccTmp = lstrlen(lpszCWD);
        if (ccTmp > sizeof(cBuff1) - 2)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        memcpy(cBuff1 + 1, lpszCWD, ccTmp + 1);
        ccFirst += ccTmp;

        INET_ASSERT(lpszCWD[ccTmp - 1] == '/');

    }

    if (lpszObjectName) {

        if (*lpszObjectName == '/') {
            lpszObjectName++;
        }

        ccTmp = lstrlen(lpszObjectName);
        if (ccTmp > sizeof(cBuff1) - ccFirst)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        memcpy(cBuff1 + ccFirst - 1, lpszObjectName, ccTmp + 1);
    }

    memset(&sUrlComp, 0, sizeof(URL_COMPONENTS));

    sUrlComp.dwStructSize = sizeof(URL_COMPONENTS);
    sUrlComp.nScheme = INTERNET_SCHEME_FTP;
    sUrlComp.lpszHostName = lpszTargetName;
    sUrlComp.lpszUrlPath = cBuff1;
    sUrlComp.nPort = (INTERNET_PORT)dwPort;

    dwSav = sizeof(cBuff);

    if(!InternetCreateUrl(&sUrlComp, 0, cBuff, &dwSav)){
        dwError = GetLastError();
        goto Cleanup;
    }

    // BUGBUG, this is because InternetCreateUrl is not returning
    // the correct size

    dwSav = strlen(cBuff)+5;

    for(i=0;i<2;++i) {

        *lplpUrlName = (LPSTR)ALLOCATE_MEMORY(LPTR, dwSav);

        if (*lplpUrlName) {

            if(!InternetCanonicalizeUrl(cBuff, *lplpUrlName, &dwSav, ICU_NO_ENCODE)){

                FREE_MEMORY(*lplpUrlName);

                // general paranoia
                *lplpUrlName = NULL;

                dwError = GetLastError();

                if ((i == 1) || (dwError != ERROR_INSUFFICIENT_BUFFER)) {
                    goto Cleanup;
                }
            }
            else {

                dwError = ERROR_SUCCESS;
                *lpdwUrlLen = dwSav;
                break;

            }
        }
        else {
            SetLastError(dwError = ERROR_NOT_ENOUGH_MEMORY);
            goto Cleanup;
        }
    }



Cleanup:
    if (dwError != ERROR_SUCCESS) {

        INET_ASSERT(!*lplpUrlName);

        *lpdwUrlLen = 0;
    }

    return (dwError);
}


PRIVATE
BOOL
FBeginCacheReadProcessing(
    IN HINTERNET hFtp,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fIsHtmlFind
    )

/*++

Routine Description:

    Sets up to read FTP data from the cache

Arguments:

    hFtp            A mapped handle to an ftp data transfer object (FtpOpenFile/FtpFindFirstFile)

    lpszFileName    ftp file to look for in the cache

    dwAccess        Accesstype eg: GENERIC_READ

    dwFlags         caching flags

    dwContext       async context

Returns:

    TRUE of started cache reading,  FALSE otherwise

Comments:

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Bool,
                 "FBeginCacheReadProcessing",
                 "%#x, %q, %d, %08x, %x, %B",
                 hFtp,
                 lpszFileName,
                 dwAccess,
                 dwFlags,
                 dwContext,
                 fIsHtmlFind
                 ));

    DWORD dwError = ERROR_SUCCESS;
    URLGEN_FUNC fn = pFtpGetUrlString;
    LPCACHE_ENTRY_INFO lpCEI = NULL;
    FTP_FILE_HANDLE_OBJECT *pFtp = (FTP_FILE_HANDLE_OBJECT *)hFtp;

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsCacheReadInProgress()) {

        //
        // BUGBUG - return FALSE surely? If there is a cache read in progress
        //          then by default, its for another request?
        //

        DEBUG_LEAVE(TRUE);

        return (TRUE);
    }

    //
    // if the object name is not set then all cache methods fail
    //

    //
    // BUGBUG - do this only when we know we are reading from cache?
    //

    ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetObjectName((LPSTR)lpszFileName,
                                                            NULL,
                                                            &fn
                                                            );
    if (dwAccess & GENERIC_WRITE) {

        DEBUG_LEAVE(FALSE);

        return (FALSE);
    }

    if (!(dwFlags & INTERNET_FLAG_NO_CACHE_WRITE)) {

        //
        // set the cache flags like RELOAD etc.
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetCacheFlags(dwFlags);
    } else {

        //
        // set flags to disable both read and write
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetCacheFlags(
                                                    INTERNET_FLAG_NO_CACHE_WRITE
                                                    | INTERNET_FLAG_RELOAD);
    }

    if (!FFtpCanReadFromCache(hFtp)) {

        DEBUG_LEAVE(FALSE);

        return (FALSE);
    }

    DEBUG_PRINT(CACHE,
                INFO,
                ("Checking in the cache\n"
                ));

    dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->BeginCacheRetrieval(&lpCEI);
    if (dwError == ERROR_SUCCESS)
    {
        //
        // found it in the cache
        //

        DEBUG_PRINT(FTP,
                    INFO,
                    ("Found in the cache\n"
                    ));

        BOOL bGetFromCache = FALSE;

        if (IsOffline()
        || (((((INTERNET_HANDLE_OBJECT *)hFtp)->GetInternetOpenFlags() | dwFlags)
            & INTERNET_FLAG_OFFLINE) && !(dwFlags & INTERNET_FLAG_RELOAD))) {
            bGetFromCache = TRUE;
            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Offline, loading from cache:\n \
                            dwFlags & INTERNET_FLAG_RELOAD = %s \n \
                            dwFlags & INTERNET_FLAG_OFFLIME = %s \n \
                            InternetOpenFlags & INTERNET_FLAG_OFFLIME = %s \n",
                            (dwFlags & INTERNET_FLAG_RELOAD) ? "TRUE" : "FALSE",
                            (dwFlags & INTERNET_FLAG_OFFLINE) ? "TRUE" : "FALSE",
                            (((INTERNET_HANDLE_OBJECT *)hFtp)->GetInternetOpenFlags()
                            & INTERNET_FLAG_OFFLINE) ? "TRUE" : "FALSE"
                        ));

        } else {
            if (!FIsFtpExpired(hFtp, lpCEI))
            {
                bGetFromCache = TRUE;
            }
        }

        if (! (( fIsHtmlFind  &&  lpCEI->lpszFileExtension) ||
               (!fIsHtmlFind  && !lpCEI->lpszFileExtension) ) )
        {
            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Mismatched HTML-type, expiring\n"
                        ));

            bGetFromCache = FALSE;
        }


        if (bGetFromCache) {
            dwError = ERROR_SUCCESS;
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetFromCache();
        } else {

            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Expired\n"
                        ));

            dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->EndCacheRetrieval();

            INET_ASSERT(dwError == ERROR_SUCCESS);

            dwError = ERROR_FILE_NOT_FOUND;
        }
    }

    //
    // cleanup
    //

    if (lpCEI != NULL) {
        lpCEI = (LPCACHE_ENTRY_INFO)FREE_MEMORY(lpCEI);

        INET_ASSERT(lpCEI == NULL);

    }

    DEBUG_LEAVE(dwError == ERROR_SUCCESS);

    return (dwError == ERROR_SUCCESS);
}


PRIVATE
BOOL
FFtpCanReadFromCache(
    HINTERNET hFtp
    )

/*++

Routine Description:

    This routine checks whether a cache read should even be started.

Arguments:

    hFtp    a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)

Returns:

    Windows Error Code.

Comments:

--*/

{
    DWORD dwFlags;

    dwFlags = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->GetCacheFlags();

    //
    // in offline or disconnected states client always reads
    //

    if (IsOffline()
    || (((INTERNET_HANDLE_OBJECT *)hFtp)->GetInternetOpenFlags() | dwFlags)
        & INTERNET_FLAG_OFFLINE) {
        return (TRUE);
    }

    //
    // if we are asked to reload data, it is not OK to read
    //

    if (dwFlags & (INTERNET_FLAG_RELOAD | INTERNET_FLAG_RESYNCHRONIZE)) {

        DEBUG_PRINT(CACHE,
                    INFO,
                    ("no cache option\n"
                    ));

        return (FALSE);
    }

    return (TRUE);
}


PRIVATE
BOOL
FBeginCacheWriteProcessing(
    IN HINTERNET hFtp,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    BOOL fIsHtmlFind
    )

/*++

Routine Description:

    Sets up to start writing FTP data to the cache

Arguments:

    hFtp            A mapped handle to an ftp data transfer object (FtpOpenFile/FtpFindFirstFile)

    lpszFileName    ftp file to look for in the cache

    dwAccess        Accesstype eg: GENERIC_WRITE

    dwFlags         caching flags

    dwContext       async context

Returns:

    TRUE if started cache writing,  FALSE otherwise

Comments:

--*/

{
    DWORD dwError = ERROR_INVALID_FUNCTION;
    URLGEN_FUNC fn = pFtpGetUrlString;
    char cExt[DEFAULT_MAX_EXTENSION_LENGTH + 1];
    DWORD dwBuffLen;
    LPSTR lpszFileExtension;

    if (dwAccess & GENERIC_WRITE) {
        return (FALSE);
    }

    if (!((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsCacheReadInProgress()) {

        //
        // we are not reading from the cache
        // Let us ask a routine whether we should cache this
        // stuff or not
        //

        if (FFtpCanWriteToCache(hFtp)) {

            //
            // if the object name is not set then all cache methods fail
            //

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->
                SetObjectName((LPSTR)lpszFileName,
                              NULL,
                              &fn
                              );

            //
            // set the cache flags
            //

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetCacheFlags(dwFlags);

            //
            // he says we can cache it.
            //

            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Starting cache write\n"
                        ));

            if (!fIsHtmlFind) {
                dwBuffLen = sizeof(cExt);
                lpszFileExtension = GetFileExtensionFromUrl(((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->GetURL(), &dwBuffLen);

                if (lpszFileExtension != NULL) {
                    memcpy(cExt, lpszFileExtension, dwBuffLen);
                    cExt[dwBuffLen] = '\0';
                    lpszFileExtension = cExt;
                }
            }
            else {
                //allways generate htm extension
                strcpy(cExt, "htm");
                lpszFileExtension = cExt;
            }

            dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->BeginCacheWrite(0, lpszFileExtension);

            if (dwError != ERROR_SUCCESS) {

                DEBUG_PRINT(CACHE,
                            ERROR,
                            ("Error in BeginCacheWrite %ld\n",
                            dwError
                            ));

            }
        }
    }
    return (dwError == ERROR_SUCCESS);
}


PRIVATE
BOOL
FFtpCanWriteToCache(
    HINTERNET hFtp
    )

/*++

Routine Description:
    This routine checks whether a cache write should even be started.

Arguments:
    hFtp    a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)

Returns:

    TRUE if successful, FALSE otherwise

Comments:

--*/

{

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->GetCacheFlags() & INTERNET_FLAG_DONT_CACHE) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtp,
    LPSTR lpszFileExtension,
    IN BOOL fNormal
    )

/*++

Routine Description:
    This routine checks terminates cache writing if it was in progress and
    commits the entry to the cache

Arguments:
    hFtp    a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)
    fNormal TRUE if the termination is normal, in which case the collected data
            is entered in the cache, otherwise it is discarded
Returns:

    Windows error code

Comments:

--*/

{

    FILETIME ftLastModTime, ftExpiryTime, ftPostCheck;
    DWORD   dwEntryType;

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsCacheWriteInProgress()) {

        ftLastModTime.dwLowDateTime =
        ftLastModTime.dwHighDateTime = 0;

        ftExpiryTime.dwLowDateTime =
        ftExpiryTime.dwHighDateTime = 0;

        ftPostCheck.dwLowDateTime =
        ftPostCheck.dwHighDateTime = 0;


        dwEntryType = (!fNormal)?0xffffffff:
                        ((((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->

                            GetCacheFlags() & INTERNET_FLAG_MAKE_PERSISTENT)
                                ? STICKY_CACHE_ENTRY:0
                        );

         DEBUG_PRINT(CACHE,
                     INFO,
                     ("Cache write EntryType = %x \
                     IsPerUserItem = %d \
                     <hFtp = 0x%x> \
                     <hFtp->GetParent() = 0x%x> \
                     <hFtp->IsPerUserItem() = %d\n",
                     dwEntryType,
                     ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsPerUserItem(),
                     hFtp,
                     ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->GetParent(),
                     ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsPerUserItem()
                     ));

        return (((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->
                                EndCacheWrite(  &ftExpiryTime,
                                                &ftLastModTime,
                                                &ftPostCheck,
                                                dwEntryType,
                                                0,
                                                NULL,
                                                lpszFileExtension));
    }
    return (ERROR_SUCCESS);
}


PRIVATE
BOOL
FGetCWDFromCache(
    HINTERNET   hFtpSession,
    LPSTR       lpBuff,
    LPDWORD     lpdwBuffSize
    )

/*++

Routine Description:
    This routine returns the current working directory for an FTP session

Arguments:
    hFtpSession     a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)

    LPSTR           buffer to return the string in

    lpdwBuffSize    IN size of lpBuff, OUT size passed back
Returns:

    TRUE if successful, FALSE otherwise

Comments:

--*/

{
    if ((((INTERNET_CONNECT_HANDLE_OBJECT *)hFtpSession)->GetInternetOpenFlags()
            & INTERNET_FLAG_OFFLINE)) {
        ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtpSession)->GetCurrentWorkingDirectory(lpBuff, lpdwBuffSize);
        return (TRUE);
    }
    return (FALSE);
}


PRIVATE
BOOL
FIsFtpExpired(
    HINTERNET   hFtp,
    LPCACHE_ENTRY_INFO  lpCEI
    )

/*++

Routine Description:
    This routine checks whether an ftp item in the cache has expired

Arguments:
    hFtp    a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)
    lpCEI   cache entry info for the item

Returns:

    TRUE if successful, FALSE otherwise

Comments:

    Even though this is a trivial routine and can be nuked, it is good
    place holder for doing special things to check FTP expiry

--*/

{
    BOOL fExpired = FALSE;

    if (CheckExpired(   hFtp,
                        &fExpired,
                        lpCEI,
                        dwdwFtpDefaultExpiryDelta) != ERROR_SUCCESS) {
        fExpired = TRUE;
    }
    return (fExpired);
}



VOID
LocalSetObjectName(
    HINTERNET hFtpMapped,
    LPSTR   lpszFileName
    )
{
    URLGEN_FUNC fn = pFtpGetUrlString;

    ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtpMapped)->
                SetObjectName((LPSTR)lpszFileName,
                              NULL,
                              &fn
                              );
}

/*++

Routine Description:
    This routine checks whether a string given to FtpFindFirstFile
    is a directory or a file

Arguments:

    lpszSearchFile string passed in to either FtpFindFirstFile

Returns:

    TRUE if successful, FALSE otherwise

Comments:

    This routine should not be used anywhere other thatn FtpFindFirstFile
    functions



--*/
BOOL IsSearchFileDirectory(
    LPCSTR   lpszSearchFile
)
{
    DWORD dwLen;

    if (!lpszSearchFile) {

        return (TRUE);

    }

    dwLen = lstrlen(lpszSearchFile);

    if (!dwLen) {

        return (TRUE);

    }


    return (lpszSearchFile[dwLen-1] == '/');

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftphelp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftphelp.h

Abstract:

    header for private FTP manifests etc

Author:

    Heath Hunnicut (t-heathh) 26-May-1995

Revision History:

    26-May-1995 t-heathh
        Created

--*/

typedef struct {
    int Major;
    int Minor;
    int Detail;
    int Status;
} FTP_RESPONSE_CODE;

//
// response categories (1st digit)
//

#define FTP_RESPONSE_PRELIMINARY        1
#define FTP_RESPONSE_COMPLETE           2
#define FTP_RESPONSE_CONTINUE           3
#define FTP_RESPONSE_TRANSIENT_FAILURE  4
#define FTP_RESPONSE_PERMANENT_FAILURE  5

//
// response codes
//

#define FTP_RESPONSE_RESTART_MARKER     110
#define FTP_RESPONSE_DATA_ALREADY_OPEN  125
#define FTP_RESPONSE_OPENING_DATA       150
#define FTP_RESPONSE_CMD_OK             200
#define FTP_RESPONSE_CMD_EXTRANEOUS     202
#define FTP_RESPONSE_DIRECTORY_STATUS   212
#define FTP_RESPONSE_FILE_STATUS        213
#define FTP_RESPONSE_SYSTEM_TYPE        215
#define FTP_RESPONSE_SEND_USER_CMD      220
#define FTP_RESPONSE_CLOSING_CONTROL    221
#define FTP_RESPONSE_CLOSING_DATA       226
#define FTP_RESPONSE_ENTERING_PASSIVE   227
#define FTP_RESPONSE_LOGGED_IN_PROCEED  230
#define FTP_RESPONSE_FILE_ACTION_OK     250
#define FTP_RESPONSE_PATHNAME_CREATED   257
#define FTP_RESPONSE_SEND_PASS_CMD      331
#define FTP_RESPONSE_NEED_LOGIN_ACCOUNT 332
#define FTP_RESPONSE_FILE_CMD_PENDING   350
#define FTP_RESPONSE_CANT_OPEN_DATA     425
#define FTP_RESPONSE_CMD_SYNTAX_ERROR   500
#define FTP_RESPONSE_ARG_SYNTAX_ERROR   501
#define FTP_RESPONSE_CMD_NOT_IMPL       502
#define FTP_RESPONSE_BAD_CMD_SEQ        503
#define FTP_RESPONSE_NOT_LOGGED_IN      530
#define FTP_RESPONSE_ACTION_NOT_TAKEN   550
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftpapiu.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftpapiu.h

Abstract:

    Header for ftpapiu.h

Author:

    Richard L Firth (rfirth) 31-May-1995

Revision History:

    31-May-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
ParseFtpUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD Context
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftpapir.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapir.h

Abstract:

    Prototypes etc. for ftpapir.c

Author:

    Richard L Firth (rfirth) 09-Mar-1995

Revision History:

    09-Mar-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
wFtpFindFirstFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    OUT LPHINTERNET lphInternet
    );

DWORD
wFtpDeleteFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName
    );

DWORD
wFtpRenameFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    );

DWORD
wFtpOpenFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    OUT LPHINTERNET lphInternet
    );

DWORD
wFtpCreateDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );

DWORD
wFtpRemoveDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );

DWORD
wFtpSetCurrentDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );

DWORD
wFtpGetCurrentDirectory(
    IN HINTERNET hFtpSession,
    IN DWORD cchCurrentDirectory,
    OUT LPSTR lpszCurrentDirectory,
    OUT LPDWORD lpdwBytesReturned
    );

DWORD
wFtpCommand(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwTransferType,
    IN LPCSTR lpszCommand
    );

DWORD
wFtpFindNextFile(
    IN HINTERNET hFtpSession,
    OUT LPWIN32_FIND_DATA lpFindFileData
    );

DWORD
wFtpFindClose(
    IN HINTERNET hFtpSession
    );

DWORD
wFtpReadFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD nNumberOfBytesToRead,
    OUT LPDWORD lpNumberOfBytesRead
    );

DWORD
wFtpWriteFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD nNumberOfBytesToWrite,
    OUT LPDWORD lpNumberOfBytesWritten
    );

DWORD
wFtpCloseFile(
    IN HINTERNET hFtpSession
    );

DWORD
wFtpGetFileSize(
    IN  HINTERNET hMappedFtpSession,
    IN  LPFTP_SESSION_INFO lpSessionInfo,
    OUT LPDWORD lpdwFileSizeLow,
    OUT LPDWORD lpdwFileSizeHigh
    );

DWORD
wFtpFindServerType(
    IN HINTERNET hFtpSession
    );

HINTERNET
InternalFtpFindFirstFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL  fCacheOnly,
    IN BOOL  fAllowEmpty = FALSE
    );

HINTERNET
InternalFtpOpenFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fCacheOnly
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftpapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapiw.cxx

Abstract:

    Wide-character versions of Windows Internet Client DLL FTP APIs and
    Internet subordinate functions

    Contents:
        FtpFindFirstFileW
        FtpGetFileW
        FtpPutFileW
        FtpDeleteFileW
        FtpRenameFileW
        FtpOpenFileW
        FtpCreateDirectoryW
        FtpRemoveDirectoryW
        FtpSetCurrentDirectoryW
        FtpGetCurrentDirectoryW
        FtpCommandW

Author:

    Heath Hunnicutt [t-heathh] 13-Jul-1994

Environment:

    Win32(s) user-level DLL

Revision History:

    09-Mar-1995 rfirth
        moved from unicode.c

    21-Jul-1994 t-heathh
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"
#include <w95wraps.h>

#define DEFAULT_TRANSFER_BUFFER_LENGTH  (4 K)

#define ALLOWED_FTP_FLAGS               (INTERNET_FLAGS_MASK \
                                        | FTP_TRANSFER_TYPE_MASK \
                                        )

//
// functions
//


BOOL
TransformFtpFindDataToW(LPWIN32_FIND_DATAA pfdA, LPWIN32_FIND_DATAW pfdW)
{
    pfdW->dwFileAttributes = pfdA->dwFileAttributes;
    pfdW->ftCreationTime = pfdA->ftCreationTime;
    pfdW->ftLastAccessTime = pfdA->ftLastAccessTime;
    pfdW->ftLastWriteTime = pfdA->ftLastWriteTime;
    pfdW->nFileSizeHigh = pfdA->nFileSizeHigh;
    pfdW->nFileSizeLow = pfdA->nFileSizeLow;
    pfdW->dwReserved0 = pfdA->dwReserved0;
    pfdW->dwReserved1 = pfdA->dwReserved1;
    MultiByteToWideChar(CP_ACP, 0, pfdA->cFileName, -1, pfdW->cFileName, MAX_PATH);
    MultiByteToWideChar(CP_ACP, 0, pfdA->cAlternateFileName, -1, pfdW->cAlternateFileName, 14);

    return TRUE;
}


INTERNETAPI_(HINTERNET) FtpFindFirstFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszSearchFile,
    OUT LPWIN32_FIND_DATAW pffdOutput,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    lpszSearchFile  -
    pffdOutput      -
    dwFlags         -
    dwContext       -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "FtpFindFirstFileW",
                     "%#x, %.80wq, %#x, %#x, %#x",
                     hFtpSession,
                     lpszSearchFile,
                     pffdOutput,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpSearchFile;
    HANDLE hInternet = NULL;
    WIN32_FIND_DATAA fdA;
    
    if (!pffdOutput 
        || IsBadWritePtr(pffdOutput, sizeof(*pffdOutput))
        || (lpszSearchFile && (IsBadStringPtrW(lpszSearchFile, INTERNET_MAX_PATH_LENGTH + 1))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (lpszSearchFile)
    {
        ALLOC_MB(lpszSearchFile,0,mpSearchFile);
        if (!mpSearchFile.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszSearchFile,mpSearchFile);
    }
    hInternet = FtpFindFirstFileA(hFtpSession,mpSearchFile.psStr,&fdA,dwFlags,dwContext);
    if (hInternet)
    {
        TransformFtpFindDataToW(&fdA, pffdOutput);
    }
cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(BOOL) FtpGetFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession             -
    lpszRemoteFile          -
    lpszNewFile             -
    fFailIfExists           -
    dwFlagsAndAttributes    -
    dwFlags                 -
    dwContext               -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetFileW",
                     "%#x, %wq, %wq, %B, %#x, %#x, %#x",
                     hFtpSession,
                     lpszRemoteFile,
                     lpszNewFile,
                     fFailIfExists,
                     dwFlagsAndAttributes,
                     dwFlags,
                     dwContext
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    BOOL success;
    DWORD nestingLevel = 0;
    HINTERNET hSessionMapped = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the INTERNET_THREAD_INFO
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the connect handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hSessionMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hSessionMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hSessionMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hSessionMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if we're in the async thread context then we've already validated the
    // parameters, so skip this stage
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtrW(lpszRemoteFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszRemoteFile == L'\0')
        || IsBadStringPtrW(lpszNewFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNewFile == L'\0')
        || (((dwFlags & FTP_TRANSFER_TYPE_MASK) != 0)
            ? (((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_ASCII)
            && ((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_BINARY))
            : FALSE)
        || ((dwFlags & ~ALLOWED_FTP_FLAGS) != 0)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // use default transfer type if so requested
        //

        if ((dwFlags & FTP_TRANSFER_TYPE_MASK) == 0) {
            dwFlags |= FTP_TRANSFER_TYPE_BINARY;
        }

        //
        // if we're performing async I/O AND this we are not in the context of
        // an async worker thread AND the app supplied a non-zero context value
        // then we can make an async request
        //

        if (!lpThreadInfo->IsAsyncWorkerThread
        && isAsync
        && (dwContext != INTERNET_NO_CALLBACK)) {

            //
            // create an asynchronous request block (ARB) and copy the parameters
            //

            // MakeAsyncRequest
            CFsm_FtpGetFile * pFsm;

            pFsm = new CFsm_FtpGetFile(hFtpSession, dwContext, lpszRemoteFile, lpszNewFile, fFailIfExists,
                                            dwFlagsAndAttributes, dwFlags);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();

                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    //
    // initialize variables in case of early exit
    //

    HANDLE hLocalFile;
    HINTERNET hRemoteFile;
    LPBYTE transferBuffer;

    hLocalFile = INVALID_HANDLE_VALUE;
    hRemoteFile = NULL;
    transferBuffer = NULL;

    //
    // first off, allocate a buffer for the transfer(s) below. The caller can
    // now influence the buffer size used by setting the appropriate option
    // for this handle. If we fail to get the value then revert to the default
    // size of 4K. We want to reduce the number of RPC calls we make
    //

    DWORD optionLength;
    DWORD transferBufferLength;

    optionLength = sizeof(transferBufferLength);
    if (!InternetQueryOption(hFtpSession,
                             INTERNET_OPTION_READ_BUFFER_SIZE,
                             (LPVOID)&transferBufferLength,
                             &optionLength
                             )) {
        transferBufferLength = DEFAULT_TRANSFER_BUFFER_LENGTH;
    }
    transferBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(transferBufferLength);
    if (transferBuffer == NULL) {
        goto last_error_exit;
    }

    //
    // open/create local file
    //

    hLocalFile = CreateFileW(lpszNewFile,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            fFailIfExists ? CREATE_NEW : CREATE_ALWAYS,
                            dwFlagsAndAttributes | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL // need NULL for Win95, handle to file with attributes to copy
                            );

    if (hLocalFile == INVALID_HANDLE_VALUE) {
        goto last_error_exit;
    }

    //
    // open file at FTP server
    //

    hRemoteFile = FtpOpenFileW(hFtpSession,
                               lpszRemoteFile,
                               GENERIC_READ,
                               dwFlags,
                               dwContext
                               );
    if (hRemoteFile == NULL) {
        goto last_error_exit;
    }

    //
    // since we are going under the API, map the file handle
    //

    error = MapHandleToAddress(hRemoteFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto cleanup;
    }

    //
    // transfer remote file to local (i.e. download it)
    //

    do {

        DWORD bytesRead;

        //
        // let app invalidate out
        //

        if (((HANDLE_OBJECT *)hFileMapped)->IsInvalidated()
        || ((HANDLE_OBJECT *)hSessionMapped)->IsInvalidated()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
            goto cleanup;
        }

        success = FtpReadFile(hFileMapped,
                              transferBuffer,
                              transferBufferLength,
                              &bytesRead
                              );
        if (success) {
            if (bytesRead != 0) {

                DWORD bytesWritten;

                success = WriteFile(hLocalFile,
                                    transferBuffer,
                                    bytesRead,
                                    &bytesWritten,
                                    NULL
                                    );
            } else {

                //
                // done
                //

                error = ERROR_SUCCESS;
                goto cleanup;
            }
        }
    } while (success);

last_error_exit:

    error = GetLastError();

cleanup:

    if (transferBuffer != NULL) {
        FREE_MEMORY((HLOCAL)transferBuffer);
    }

    //
    // close local file
    //

    if (hLocalFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hLocalFile);

        //
        // if we failed, but created the local file then delete it
        //

        if ((error != ERROR_SUCCESS) && (hLocalFile != INVALID_HANDLE_VALUE)) {
            DeleteFileW(lpszNewFile);
        }
    }

    //
    // close remote file
    //

    if (hRemoteFile != NULL) {
        _InternetCloseHandle(hRemoteFile);
    }

    //
    // BUGBUG [arthurbi] SetContext should not be called from here,
    //   InternetCloseHandle should not reset the context as its
    //   doing right now, and this needs to be investigated more,
    //   as for now we're workaround this problem by calling SetContext
    //

    _InternetSetContext(lpThreadInfo, dwContext);

quit:

    if (hFileMapped != NULL) {
        INET_ASSERT(fDeref);
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (hSessionMapped != NULL && fDeref) {
        DereferenceObject((LPVOID)hSessionMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI_(BOOL) FtpPutFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszLocalFile,
    IN LPCWSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession         -
    lpszLocalFile       -
    lpszNewRemoteFile   -
    dwFlags             -
    dwContext           -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpPutFileW",
                     "%#x, %wq, %wq, %#x, %#x",
                     hFtpSession,
                     lpszLocalFile,
                     lpszNewRemoteFile,
                     dwFlags,
                     dwContext
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    BOOL success;
    DWORD nestingLevel = 0;
    HINTERNET hSessionMapped = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the INTERNET_THREAD_INFO
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the connect handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hSessionMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hSessionMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hSessionMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hSessionMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if we're in the async thread context then we've already validated the
    // parameters, so skip this stage
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtrW(lpszNewRemoteFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNewRemoteFile == L'\0')
        || IsBadStringPtrW(lpszLocalFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszLocalFile == L'\0')
        || (((dwFlags & FTP_TRANSFER_TYPE_MASK) != 0)
            ? (((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_ASCII)
            && ((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_BINARY))
            : FALSE)
        || ((dwFlags & ~ALLOWED_FTP_FLAGS) != 0)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // use default transfer type if so requested
        //

        if ((dwFlags & FTP_TRANSFER_TYPE_MASK) == 0) {
            dwFlags |= FTP_TRANSFER_TYPE_BINARY;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        if ((((INTERNET_CONNECT_HANDLE_OBJECT *)hSessionMapped)->
                GetInternetOpenFlags() | dwFlags) &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        //
        // if we're performing async I/O AND this we are not in the context of
        // an async worker thread AND the app supplied a non-zero context value
        // then we can make an async request
        //

        if (!lpThreadInfo->IsAsyncWorkerThread
        && isAsync
        && (dwContext != INTERNET_NO_CALLBACK)) {

            // MakeAsyncRequest
            CFsm_FtpPutFile * pFsm;

            pFsm = new CFsm_FtpPutFile(hFtpSession, dwContext, lpszLocalFile, lpszNewRemoteFile, dwFlags);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    //
    // initialize variables in case of early exit
    //

    HANDLE hLocalFile;
    HINTERNET hRemoteFile;
    LPBYTE transferBuffer;

    hLocalFile = INVALID_HANDLE_VALUE;
    hRemoteFile = NULL;
    transferBuffer = NULL;

    //
    // first off, allocate a buffer for the transfer(s) below. The caller can
    // now influence the buffer size used by setting the appropriate option
    // for this handle. If we fail to get the value then revert to the default
    // size of 4K. We want to reduce the number of RPC calls we make
    //

    DWORD optionLength;
    DWORD transferBufferLength;

    optionLength = sizeof(transferBufferLength);
    if (!InternetQueryOption(hFtpSession,
                             INTERNET_OPTION_WRITE_BUFFER_SIZE,
                             (LPVOID)&transferBufferLength,
                             &optionLength
                             )) {
        transferBufferLength = DEFAULT_TRANSFER_BUFFER_LENGTH;
    }
    transferBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(transferBufferLength);
    if (transferBuffer == NULL) {
        goto last_error_exit;
    }

    //
    // open local file
    //

    hLocalFile = CreateFileW(lpszLocalFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL // need NULL for Win95, handle to file with attributes to copy
                            );
    if (hLocalFile == INVALID_HANDLE_VALUE) {
        goto last_error_exit;
    }

    //
    // open file at FTP server
    //

    hRemoteFile = FtpOpenFileW(hFtpSession,
                               lpszNewRemoteFile,
                               GENERIC_WRITE,
                               dwFlags,
                               dwContext
                               );
    if (hRemoteFile == NULL) {
        goto last_error_exit;
    }

    //
    // since we are going under the API, map the file handle
    //

    error = MapHandleToAddress(hRemoteFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto cleanup;
    }

    //
    // transfer local file to remote (i.e. upload it)
    //

    do {

        DWORD bytesRead;

        //
        // let app invalidate out
        //

        if (((HANDLE_OBJECT *)hFileMapped)->IsInvalidated()
        || ((HANDLE_OBJECT *)hSessionMapped)->IsInvalidated()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
            goto cleanup;
        }

        success = ReadFile(hLocalFile,
                           transferBuffer,
                           transferBufferLength,
                           &bytesRead,
                           NULL
                           );
        if (success) {
            if (bytesRead != 0) {

                DWORD bytesWritten;

                success = FtpWriteFile(hFileMapped,
                                       transferBuffer,
                                       bytesRead,
                                       &bytesWritten
                                       );
            } else {

                //
                // ensure last error is really no error
                //

                error = ERROR_SUCCESS;

                goto cleanup;
            }
        }
    } while (success);

last_error_exit:

    error = GetLastError();

cleanup:

    if (transferBuffer != NULL) {
        FREE_MEMORY((HLOCAL)transferBuffer);
    }

    //
    // close local file
    //

    if (hLocalFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hLocalFile);
    }

    //
    // close remote file
    //

    if (hRemoteFile != NULL) {
        _InternetCloseHandle(hRemoteFile);
    }

    //
    // BUGBUG [arthurbi] SetContext should not be called from here,
    //   InternetCloseHandle should not reset the context as its
    //   doing right now, and this needs to be investigated more,
    //   as for now we're workaround this problem by calling SetContext
    //

    _InternetSetContext(lpThreadInfo, dwContext);

quit:
    SetLastError(ERROR_SUCCESS);  // a-thkesa. from win CE code BUG: WinSE 23985

    if (hFileMapped != NULL) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (hSessionMapped != NULL && fDeref) {
        DereferenceObject((LPVOID)hSessionMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    // a-thkesa Becuase 23985 fix returns ERROR_INTERNET_EXTENDED_ERROR
    if(ERROR_INTERNET_EXTENDED_ERROR == GetLastError()){
         success = FALSE;
     }
    else if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;

    }

    DEBUG_LEAVE_API(success);

    return success;
}

INTERNETAPI_(BOOL) FtpGetFileEx(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetFileEx",
                     "%#x, %sq, %wq, %B, %#x, %#x, %#x",
                     hFtpSession,
                     lpszRemoteFile,
                     lpszNewFile,
                     fFailIfExists,
                     dwFlagsAndAttributes,
                     dwFlags,
                     dwContext
                     ));

    DWORD cc, dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    PWSTR pwszRemoteFile = NULL;

    cc = MultiByteToWideChar(CP_ACP, 0, lpszRemoteFile, -1, NULL, 0);
    pwszRemoteFile = (LPWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszRemoteFile)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    MultiByteToWideChar(CP_ACP, 0, lpszRemoteFile, -1, pwszRemoteFile, cc);

    fResult = FtpGetFileW(hFtpSession,pwszRemoteFile,lpszNewFile,fFailIfExists,
        dwFlagsAndAttributes,dwFlags,dwContext);

cleanup: 
    if (pwszRemoteFile)
    {
        FREE_MEMORY(pwszRemoteFile);
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;

}


INTERNETAPI_(BOOL) FtpPutFileEx(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpPutFileEx",
                     "%#x, %wq, %sq, %#x, %#x",
                     hFtpSession,
                     lpszLocalFile,
                     lpszNewRemoteFile,
                     dwFlags,
                     dwContext
                     ));

    DWORD cc, dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    PWSTR pwszRemoteFile = NULL;

    cc = MultiByteToWideChar(CP_ACP, 0, lpszNewRemoteFile, -1, NULL, 0);
    pwszRemoteFile = (LPWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszRemoteFile)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    MultiByteToWideChar(CP_ACP, 0, lpszNewRemoteFile, -1, pwszRemoteFile, cc);

    fResult = FtpPutFileW(hFtpSession,lpszLocalFile,pwszRemoteFile,dwFlags,dwContext);

cleanup: 
    if (pwszRemoteFile)
    {
        FREE_MEMORY(pwszRemoteFile);
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;

}


INTERNETAPI_(BOOL) FtpDeleteFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszFileName
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    lpszFileName    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpDeleteFileW",
                     "%#x, %wq",
                     hFtpSession,
                     lpszFileName
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpFile;

    if (!lpszFileName 
        || (IsBadStringPtrW(lpszFileName, INTERNET_MAX_PATH_LENGTH + 1))
        || (*lpszFileName == L'\0'))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszFileName,0,mpFile);
    if (!mpFile.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszFileName,mpFile);
    fResult = FtpDeleteFileA(hFtpSession,mpFile.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpRenameFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszExisting,
    IN LPCWSTR lpszNew
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    lpszExisting    -
    lpszNew         -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpRenameFileW",
                     "%#x, %wq, %wq",
                     hFtpSession,
                     lpszExisting,
                     lpszNew
                     ));


    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpExisting, mpNew;

    if (!(lpszExisting && lpszNew)
        || (IsBadStringPtrW(lpszExisting, INTERNET_MAX_PATH_LENGTH + 1))
        || (IsBadStringPtrW(lpszNew, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszExisting,0,mpExisting);
    ALLOC_MB(lpszNew,0,mpNew);
    if (!(mpExisting.psStr && mpNew.psStr))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszExisting,mpExisting);
    UNICODE_TO_ANSI(lpszNew,mpNew);
    fResult = FtpRenameFileA(hFtpSession,mpExisting.psStr,mpNew.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(HINTERNET) FtpOpenFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    lpszFileName    -
    dwAccess        -
    dwFlags         -
    dwContext       -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "FtpOpenFileW",
                     "%#x, %wq, %#x, %#x, %#x",
                     hFtpSession,
                     lpszFileName,
                     dwAccess,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpFile;

    if (!lpszFileName
        || (IsBadStringPtrW(lpszFileName, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszFileName,0,mpFile);
    if (!mpFile.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszFileName,mpFile);
    hInternet = FtpOpenFileA(hFtpSession,mpFile.psStr,dwAccess,dwFlags,dwContext);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);

    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(BOOL) FtpCreateDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR pwszDir
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession -
    pwszDir     -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpCreateDirectoryW",
                     "%#x, %wq",
                     hFtpSession,
                     pwszDir
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpDir;

    if (!pwszDir
        || (IsBadStringPtrW(pwszDir, INTERNET_MAX_PATH_LENGTH + 1)
        || (*pwszDir == L'\0')))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pwszDir,0,mpDir);
    if (!mpDir.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pwszDir,mpDir);
    fResult = FtpCreateDirectoryA(hFtpSession,mpDir.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpRemoveDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR pwszDir
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession -
    pwszDir     -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpRemoveDirectoryW",
                     "%#x, %wq",
                     hFtpSession,
                     pwszDir
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpDir;

    if (!pwszDir
        || (IsBadStringPtrW(pwszDir, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pwszDir,0,mpDir);
    if (!mpDir.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pwszDir,mpDir);
    fResult = FtpRemoveDirectoryA(hFtpSession,mpDir.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpSetCurrentDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR pwszDir
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession -
    pwszDir     -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpSetCurrentDirectoryW",
                     "%#x, %wq",
                     hFtpSession,
                     pwszDir
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpDir;

    if (!pwszDir
        || (IsBadStringPtrW(pwszDir, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pwszDir,0,mpDir);
    if (!mpDir.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pwszDir,mpDir);
    fResult = FtpSetCurrentDirectoryA(hFtpSession,mpDir.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpGetCurrentDirectoryW(
    IN HINTERNET hFtpSession,
    OUT LPWSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession             -
    lpszCurrentDirectory    -
    lpdwCurrentDirectory    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetCurrentDirectoryW",
                     "%#x, %#x, %#x [%d]",
                     hFtpSession,
                     lpszCurrentDirectory,
                     lpdwCurrentDirectory,
                     lpdwCurrentDirectory ? *lpdwCurrentDirectory : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpDir;

    if (!lpdwCurrentDirectory 
        || IsBadWritePtr(lpdwCurrentDirectory, sizeof(*lpdwCurrentDirectory))
        || (lpszCurrentDirectory && IsBadWritePtr(lpszCurrentDirectory, *lpdwCurrentDirectory)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (lpszCurrentDirectory)
    {
        mpDir.dwSize = mpDir.dwAlloc = *lpdwCurrentDirectory*sizeof(CHAR);
        mpDir.psStr = (LPSTR)ALLOC_BYTES(mpDir.dwAlloc);
        if (!mpDir.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    else
    {
        *lpdwCurrentDirectory = 0;
    }
    
    fResult = FtpGetCurrentDirectoryA(hFtpSession,mpDir.psStr,&mpDir.dwSize);
    if (fResult) 
    {
        DWORD cc = MultiByteToWideChar(CP_ACP, 0, mpDir.psStr, -1, NULL, 0);
        if (*lpdwCurrentDirectory>=cc)
        {
            *lpdwCurrentDirectory = MultiByteToWideChar(CP_ACP, 0, mpDir.psStr, -1, 
                    lpszCurrentDirectory, *lpdwCurrentDirectory);
        }
        else
        {
            *lpdwCurrentDirectory = cc*sizeof(WCHAR);
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            fResult = FALSE;
        }
    }
    else
    {
        if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
        {
            *lpdwCurrentDirectory = mpDir.dwSize*sizeof(WCHAR);
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpCommandW(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCWSTR lpszCommand,
    IN DWORD_PTR dwContext,
    OUT HINTERNET *phFtpCommand OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    fExpectResponse -
    dwFlags         -
    lpszCommand     -
    dwContext       -
    phFtpCommand    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpCommandW",
                     "%#x, %B, %#x, %wq, %#x, %x",
                     hFtpSession,
                     fExpectResponse,
                     dwFlags,
                     lpszCommand,
                     dwContext,
                     phFtpCommand
                     ));

    MEMORYPACKET mpCommand;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    if (!lpszCommand 
        || IsBadStringPtrW(lpszCommand, INTERNET_MAX_URL_LENGTH) 
        || (phFtpCommand && IsBadWritePtr(phFtpCommand, sizeof(*phFtpCommand))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszCommand, 0, mpCommand);
    if (!mpCommand.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszCommand, mpCommand);

    fResult = FtpCommandA(hFtpSession, fExpectResponse, dwFlags, mpCommand.psStr, dwContext, phFtpCommand);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftpapiu.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftpapiu.cxx

Abstract:

    Common sub-API level FTP functions (created from dll\parseurl.c)

    Contents:
        ParseFtpUrl

Author:

    Richard L Firth (rfirth) 31-May-1995

Environment:

    Win32 user-level DLL

Revision History:

    31-May-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>

//
// functions
//


DWORD
ParseFtpUrl(
    IN OUT LPHINTERNET lphInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    )

/*++

Routine Description:

    URL parser for FTP URLs. Support function for InternetOpenUrl() and
    ParseUrl().

    This is a macro function that just cracks the URL and calls FTP APIs to
    do the work

Arguments:

    lphInternet     - IN: pointer to InternetOpen handle
                      OUT: if successful handle of opened item, else undefined

    Url             - pointer to string containing FTP URL to open

    SchemeLength    - length of the URL scheme, exluding "://"

    Headers         - unused for FTP

    HeadersLength   - unused for FTP

    OpenFlags       - optional flags for opening a file (cache/no-cache, etc.)

    Context         - app-supplied context value for call-backs

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Dword,
                 "ParseFtpUrl",
                 "%#x [%#x], %q, %d, %#x, %d, %#x, %#x",
                 lphInternet,
                 *lphInternet,
                 Url,
                 SchemeLength,
                 Headers,
                 HeadersLength,
                 OpenFlags,
                 Context
                 ));

    UNREFERENCED_PARAMETER(Headers);
    UNREFERENCED_PARAMETER(HeadersLength);

    //
    // parse out the name[:password] and host[:port] parts
    //

    DWORD urlLength;
    LPSTR pUserName;
    DWORD userNameLength;
    LPSTR pPassword;
    DWORD passwordLength;
    LPSTR pHostName;
    DWORD hostNameLength;
    INTERNET_PORT port;
    LPSTR lpszUrl = NULL, lpszBackup = NULL;
    char firstUrlPathCharacter;

    HINTERNET hConnect = NULL;
    DWORD error;

    // The passed in Url string gets munged during this function.
    // Make a copy, so the proper URL is set to the mapped connection handle.
    lpszUrl = NewString((LPCSTR)Url);
    if (lpszUrl == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    lpszBackup = lpszUrl;

    lpszUrl += SchemeLength + sizeof("://") - 1;

    error = GetUrlAddress(&lpszUrl,
                          &urlLength,
                          &pUserName,
                          &userNameLength,
                          &pPassword,
                          &passwordLength,
                          &pHostName,
                          &hostNameLength,
                          &port,
                          NULL
                          );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we can safely zero-terminate the address parts - the '/' between address
    // info and url-path is not significant
    //

    //if (*Url == '/') {
    //    ++Url;
    //    --urlLength;
    //}
    if (pUserName != NULL) {
        pUserName[userNameLength] = '\0';
    }
    if (pPassword != NULL) {
        pPassword[passwordLength] = '\0';
    }

    //
    // now get the FTP file/directory information
    //

    BOOL isDirectory;

    if ((*lpszUrl == '\0') || (*(lpszUrl + 1) == '\0')) {

        //
        // if the URL just consisted of ftp://host then by default we are
        // referencing an FTP directory (the root directory)
        //

        isDirectory = TRUE;
    } else {

        LPSTR pSemiColon;

        pSemiColon = strchr(lpszUrl, ';');
        if (pSemiColon != NULL) {

            //
            // if there's not enough space left in the string after ';' for the
            // "type=?" substring, then assume this URL is bad
            //

            if ((urlLength - (pSemiColon - lpszUrl)) < 6) {
                error = ERROR_INTERNET_INVALID_URL;
                goto quit;
            }
            if (strnicmp(pSemiColon + 1, "type=", 5) == 0) {
                switch (tolower(*(pSemiColon + 6))) {
                case 'a':
                    OpenFlags |= FTP_TRANSFER_TYPE_ASCII;
                    isDirectory = FALSE;
                    *pSemiColon = '\0';
                    break;

                case 'i':
                    OpenFlags |= FTP_TRANSFER_TYPE_BINARY;
                    isDirectory = FALSE;
                    *pSemiColon = '\0';
                    break;

                case 'd':
                    isDirectory = TRUE;
                    break;

                default:
                    error = ERROR_INTERNET_INVALID_URL;
                    goto quit;
                }
            } else {

                //
                // found a ';', but not "type=". Don't understand this URL
                //

                error = ERROR_INTERNET_INVALID_URL;
                goto quit;
            }
            urlLength = (DWORD) (pSemiColon - lpszUrl);
        } else {

            //
            // there is no ;type= field to help us out. If the string ends in /
            // then it is a directory. Further, if the url-path refers to a
            // file, we don't know which mode to use to transfer it - ASCII or
            // BINARY. We'll default to binary
            //

            if (lpszUrl[urlLength - 1] == '/') {
                isDirectory = TRUE;
            } else {
                OpenFlags |= FTP_TRANSFER_TYPE_BINARY;
                isDirectory = FALSE;
            }
        }

        //
        // decode the url-path
        //
        if(FAILED(UrlUnescapeInPlace(lpszUrl, 0))){
            goto quit;
        }
        urlLength = lstrlen(lpszUrl);
    }

    //
    // we potentially need to go round this loop 3 times:
    //
    //  1. try to get the item from the cache
    //  2. try to get the item from the origin server
    //  3. only if we got an existing connect & the origin server request
    //     failed, reopen the connect handle & try step 2 again
    //
    // however, we only need make one attempt if we're in OFFLINE mode - either
    // we can get the item from the cache, or we can't
    //

    HINTERNET hInternetMapped;

    //
    // BUGBUG - this function should receive the handle already mapped
    //

    error = MapHandleToAddress(*lphInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    INET_ASSERT(hInternetMapped != NULL);

    //
    // if the InternetOpen() handle was created in OFFLINE mode then is an
    // offline request
    //
        DEBUG_PRINT(FTP,
                    INFO,
                    ("ParseFtpUrl: pre-OpenFlags check: OpenFlags = %#x\n",
                    OpenFlags
                    ));

    OpenFlags |= ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->GetInternetOpenFlags()
        & INTERNET_FLAG_OFFLINE;

        DEBUG_PRINT(FTP,
                    INFO,
                    ("ParseFtpUrl: post-OpenFlags check: OpenFlags = %#x\n",
                    OpenFlags
                    ));


    DereferenceObject((LPVOID)hInternetMapped);

    DWORD limit;

    limit = (OpenFlags & INTERNET_FLAG_OFFLINE) ? 1 : 3;

    //
    // resynchronize same as reload for FTP
    //

    if (OpenFlags & INTERNET_FLAG_RESYNCHRONIZE) {
        OpenFlags |= INTERNET_FLAG_RELOAD;
        DEBUG_PRINT(FTP,
                    INFO,
                    ("ParseFtpUrl: INTERNET_FLAG_RESYNCHRONIZE set\n"));
    }

    DWORD i;
    BOOL bFromCache;

    i = 0;
    bFromCache = (OpenFlags & INTERNET_FLAG_RELOAD || (GlobalUrlCacheSyncMode == WININET_SYNC_MODE_ALWAYS)) ? FALSE : TRUE;

    while (i < limit) {

        //
        // ok, all parts present and correct; open a handle to the FTP resource
        //

        DWORD dwFlags = OpenFlags;

        if (bFromCache) {

            //
            // attempting to get item from cache
            //

            dwFlags |= INTERNET_FLAG_OFFLINE;
        } else {

            //
            // performing net request
            //

            dwFlags |= INTERNET_FLAG_RELOAD;
            dwFlags &= ~INTERNET_FLAG_OFFLINE;
        }

        //
        // zero-terminating the host name will wipe out the first '/' of the
        // URL-path which we must restore before using
        //

        firstUrlPathCharacter = *lpszUrl;
        if (pHostName != NULL) {
            pHostName[hostNameLength] = '\0';
        }

        //
        // record current online/offline state
        //

        BOOL bOffline = IsOffline();

        //
        // create a connect handle object or find an existing one if using
        // INTERNET_FLAG_EXISTING_CONNECT
        //

        if ( hConnect )
        {
            _InternetCloseHandle(hConnect); // nuke old connect handle, otherwise we leak.
        }

        hConnect = InternetConnectA(*lphInternet,
                                    pHostName,
                                    port,
                                    pUserName,
                                    pPassword,
                                    INTERNET_SERVICE_FTP,
                                    dwFlags,

                                    //
                                    // we are creating a "hidden" handle - don't
                                    // tell the app about it
                                    //

                                    INTERNET_NO_CALLBACK
                                    );

        //
        // restore URL-path, but only if its not '\0' - we may have a const
        // string (we can't write to it - we change to "/" below, which is a
        // const string)
        //

        if (*lpszUrl == '\0') {
            *(LPSTR)lpszUrl = firstUrlPathCharacter;
        }

        HINTERNET hConnectMapped = NULL;

        if (hConnect != NULL) {

            //
            // lock the handle by mapping it
            //

            error = MapHandleToAddress(hConnect,
                                       (LPVOID *)&hConnectMapped,
                                       FALSE
                                       );

            INET_ASSERT(error == ERROR_SUCCESS);
            INET_ASSERT(hConnectMapped != NULL);

            if (error != ERROR_SUCCESS) {
                break;
            }

            INTERNET_CONNECT_HANDLE_OBJECT * pConnectMapped;

            pConnectMapped = (INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped;

            //
            // the ref count should be 2: either we created the connect handle
            // or we picked up an EXISTING_CONNECT handle which should not be
            // used by any other requests
            //

            INET_ASSERT(pConnectMapped->ReferenceCount() == 2);

            //
            // first off, associate the last response info, possibly including
            // the server welcome message, with the connection
            //

            pConnectMapped->AttachLastResponseInfo();
            pConnectMapped->SetURL(Url);

            HINTERNET hRequest;

            if (isDirectory) {
                if (*lpszUrl == '\0') {
                    lpszUrl = "/";
                }

                //
                // if we are reading from cache then set the working directory
                // locally, else also set the CWD at the server
                //

                if (bFromCache) {
                    error = pConnectMapped->SetCurrentWorkingDirectory((LPSTR)lpszUrl);
                } else if (FtpSetCurrentDirectory(hConnect, lpszUrl)) {
                    error = ERROR_SUCCESS;
                } else {
                    error = GetLastError();
                }
                if (error == ERROR_SUCCESS) {

                    // if we are not asked to give raw data
                    // then set htmlfind to TRUE

                    if (!(dwFlags & INTERNET_FLAG_RAW_DATA)) {
                        pConnectMapped->SetHtmlFind(TRUE);
                    }
                    hRequest = InternalFtpFindFirstFileA(hConnect,
                                              NULL,
                                              NULL,
                                              dwFlags,
                                              Context,
                                              bFromCache,
                                              pConnectMapped->IsHtmlFind() // allow empty
                                              );
                } else {
                    hRequest = NULL;
                }
            } else /* if (!isDirectory) */ {
                hRequest = InternalFtpOpenFileA(hConnect,
                                                lpszUrl,
                                                GENERIC_READ,
                                                dwFlags,
                                                Context,
                                                bFromCache
                                                );

                //
                // we may have failed because we're not trying to get a file
                // after all - we've been given a directory without a trailing
                // slash
                //

                if (hRequest == NULL) {
                    if (!(dwFlags & INTERNET_FLAG_RAW_DATA)) {
                        pConnectMapped->SetHtmlFind(TRUE);
                    }
                    error = pConnectMapped->SetCurrentWorkingDirectory((LPSTR)lpszUrl);

                    INET_ASSERT(error == ERROR_SUCCESS);

                    if (error == ERROR_SUCCESS) {
                        if (!bFromCache) {
                            if (!FtpSetCurrentDirectory(hConnect, lpszUrl)) {
                                error = GetLastError();
                            }
                        }
                        if (error == ERROR_SUCCESS) {
                            hRequest = InternalFtpFindFirstFileA(
                                            hConnect,
                                            NULL,
                                            NULL,
                                            dwFlags,
                                            Context,
                                            bFromCache,
                                            pConnectMapped->IsHtmlFind()
                                            );
                        }
                    }
                }
            }

            //
            // link the request and connect handles so that the connect handle
            // object will be deleted when the request handle is closed
            //

            if (hRequest != NULL) {

                HINTERNET hRequestMapped = NULL;

                error = MapHandleToAddress(hRequest,
                                           (LPVOID *)&hRequestMapped,
                                           FALSE
                                           );
                if (error == ERROR_SUCCESS) {
                    RSetParentHandle(hRequestMapped, hConnectMapped, TRUE);
                }

                //
                // dereference the handles referenced by MapHandleToAddress()
                //

                if (hRequestMapped != NULL) {
                    DereferenceObject((LPVOID)hRequestMapped);
                }

                //
                // return the request handle
                //

                *lphInternet = hRequest;
            }

            //
            // unmap and dereference the connect handle
            //

            DereferenceObject((LPVOID)hConnectMapped);

            //
            // if we succeeded in opening the item then we're done
            //

            if (hRequest != NULL) {
                break;
            } else {
                error = GetLastError();

                //
                // close the handle without modifying the per-thread handle and
                // context values
                //

                //DWORD closeError = _InternetCloseHandleNoContext(hConnect);
                DWORD closeError = ERROR_SUCCESS;

                INET_ASSERT(closeError == ERROR_SUCCESS);

                //
                // if we failed because we went offline then make a cache
                // request if we can
                //

                if (IsOffline() && !bFromCache) {

                    //
                    // this will be the last chance
                    //

                    bFromCache = TRUE;
                    continue;
                }
            }
        } else {

            //
            // InternetConnect() failed. If the offline state didn't change then
            // its a real error - quit
            //

            error = GetLastError();
            if (IsOffline() == bOffline) {
                break;
            }

            //
            // we must have transitioned offline state. If we went offline then
            // attempt to read from cache only
            //

            if (IsOffline() && !bFromCache) {
                bFromCache = TRUE;
                continue;
            }
        }

        //
        // next iteration - second & subsequent not from cache unless we are
        // offline
        //

        bFromCache = FALSE;
        ++i;
    }

quit:
    if (lpszBackup)
        FREE_MEMORY(lpszBackup);

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\ftpapir.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapir.cxx

Abstract:

    Contains the remote-side FTP API worker functions. In each case, the API
    proper validates the arguments. The worker functions contained herein just
    perform the requested operation with the supplied arguments.

    These functions are the remote side of the RPC interface. If the DLL is
    the abstract0 version (no RPC) then the A forms of the functions simply
    call the w functions

    Contents:
        wFtpFindFirstFile
        wFtpDeleteFile
        wFtpRenameFile
        wFtpOpenFile
        wFtpCreateDirectory
        wFtpRemoveDirectory
        wFtpSetCurrentDirectory
        wFtpGetCurrentDirectory
        wFtpCommand
        wFtpFindNextFile
        wFtpFindClose
        wFtpConnect
        wFtpMakeConnection
        wFtpDisconnect
        wFtpReadFile
        wFtpWriteFile
        wFtpQueryDataAvailable
        wFtpCloseFile
        wFtpFindServerType
        wFtpGetFileSize

Author:

    Heath Hunnicutt [t-heathh] 13-Jul-1994

Environment:

    Win32(s) user-level DLL

Revision History:

    09-Mar-1995 rfirth
        Created new file/worker functions from functions contained in
        findfile.c, ftphelp.c

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// private macros
//

#define CASE_OF(constant)   case constant: return # constant

//
// private debug functions
//

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
InternetMapFtpServerType(
    IN FTP_SERVER_TYPE ServerType
    );

#else

#define InternetMapFtpServerType(x) (VOID)(x)

#endif // INET_DEBUG

//
// external functions
//

extern
DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtpFile,
    IN LPSTR lpszFileExtension,
    IN BOOL fNormal
    );

//
// functions
//


DWORD
wFtpFindFirstFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFilespec,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    OUT LPHINTERNET lphInternet
    )

/*++

Routine Description:

    Download the remote site's directory listing and parse it into
    WIN32_FIND_DATA structures that we can pass back to the app.

    If the FTP session is currently involved in a data transfer, such as
    a FtpOpenFile()....FtpCloseFile() series of calls, this function will
    fail.

Arguments:

    hFtpSession     - Handle to an FTP session, as returned from FtpOpen()

    lpszFilespec    - Pointer to a string containing a file specification
                      to find. May be empty, but not NULL

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds.
                      If this parameter is not supplied, then any find data
                      will be returned via InternetFindNextFile()

    lphInternet     - place to return open find handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    *lphInternet contains new find handle

        Failure - ERROR_INVALID_HANDLE
                    The session handle is not recognized

                  ERROR_FTP_TRANSFER_IN_PROGRESS
                    The data connection is already in use

                  ERROR_NO_MORE_FILES
                    The end of the directory listing has been reached

                  ERROR_INTERNET_EXTENDED_ERROR
                    Call InternetGetLastResponseInfo() for the text

                  ERROR_INTERNET_INTERNAL_ERROR
                    Something bad happened
--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpFindFirstFile",
                "%#x, %q, %#x, %#x",
                hFtpSession,
                lpszFilespec,
                lpFindFileData,
                lphInternet
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    LPSTR lpBuffer = NULL;
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPFTP_SESSION_INFO lpSessionInfo;

    if (!FindFtpSession(hFtpSession, &lpSessionInfo)) {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    //
    // acquire the session lock while we check and optionally set the active
    // find flag
    //

    AcquireFtpSessionLock(lpSessionInfo);

    if (!(lpSessionInfo->Flags & FFTP_FIND_ACTIVE)) {
        lpSessionInfo->Flags |= FFTP_FIND_ACTIVE;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_FTP_TRANSFER_IN_PROGRESS;
    }

    ReleaseFtpSessionLock(lpSessionInfo);

    //
    // if we already have a directory listing on this connection, then we can
    // not allow another one, until the current listing is cleared out by the
    // app calling InternetCloseHandle()
    //

    if (error != ERROR_SUCCESS) {
        goto deref_exit;
    }

    //
    // the filespec may have a path component. We assume that any wild-cards
    // will only be in the filename part. We use the path part in the directory
    // request and the filename part when parsing the directory output
    //

    char pathBuf[INTERNET_MAX_PATH_LENGTH + 1];
    LPSTR lpszPathPart;
    LPSTR lpszFilePart;
    BOOL isWild;
    DWORD dwFilePartLength;

    lpszFilePart = (LPSTR)lpszFilespec;
    lpszPathPart = NULL;
    dwFilePartLength = lstrlen(lpszFilePart);

    if (*lpszFilePart != '\0') {

        LPSTR pathSeparator;

        pathSeparator = _memrchr(lpszFilePart, '\\', dwFilePartLength);
        if (pathSeparator == NULL) {
            pathSeparator = _memrchr(lpszFilePart, '/', dwFilePartLength);
        }
        if (pathSeparator != NULL) {

            int len = (int) (pathSeparator - lpszFilePart) + 1;

            if (len < sizeof(pathBuf)) {
                memcpy(pathBuf, lpszFilePart, len);
                pathBuf[len] = '\0';
                lpszPathPart = pathBuf;
                lpszFilePart = pathSeparator + 1;

                DEBUG_PRINT(FTP,
                            INFO,
                            ("lpszPathPart = %q, lpszFilePart = %q\n",
                            lpszPathPart,
                            lpszFilePart
                            ));

            }
        }

        //
        // determine whether the caller is asking for a fuzzy file match, or
        // (typically) the request is for the contents of a directory
        //

        isWild = IsFilespecWild(lpszFilePart);
    } else {

        //
        // empty string - not asking for wildcard search
        //

        isWild = FALSE;
    }

    //
    // and ask the FTP server for the directory listing
    //

    FTP_RESPONSE_CODE rcResponse;

    error = Command(lpSessionInfo,
                    TRUE,
                    FTP_TRANSFER_TYPE_ASCII,
                    &rcResponse,
                    ((lpszPathPart == NULL) && (isWild || (*lpszFilePart == '\0')))
                        ? "LIST"
                        : "LIST %s",
                    (lpszPathPart == NULL)
                        ? lpszFilePart
                        : isWild
                            ? lpszPathPart
                            : lpszFilespec
                    );

    //
    // quit early if we failed to send the command, or the server didn't
    // understand it
    //

    if (error != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // presumably, the server has sent us a directory listing. Receive it
    //

    DWORD bufferLength;
    DWORD bufferLeft;
    DWORD bytesReceived;
    BOOL eof;

    bufferLength = 0;
    bufferLeft = 0;
    bytesReceived = 0;

    error = lpSessionInfo->socketData->Receive((LPVOID *)&lpBuffer,
                                               &bufferLength,
                                               &bufferLeft,
                                               &bytesReceived,
                                               0,
                                               SF_EXPAND
                                               | SF_COMPRESS
                                               | SF_RECEIVE_ALL
                                               | SF_INDICATE,
                                               &eof
                                               );

    //
    // we are done with the data connection
    //

    lpSessionInfo->socketData->Close();

    //
    // quit now if we had an error while receiving
    //

    if (error != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // if the previous response was preliminary then get the final response from
    // the FTP server
    //

    if (rcResponse.Major != FTP_RESPONSE_COMPLETE) {
        error = GetReply(lpSessionInfo, &rcResponse);
        if (error != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // check response for failure
        //

        if (rcResponse.Major != FTP_RESPONSE_COMPLETE) {

            //
            // <-- Return "command failed" error code
            //
            if(rcResponse.Status == FTP_RESPONSE_ACTION_NOT_TAKEN)
            {
                error = ERROR_NO_MORE_FILES;
            }
            else
            {
                error = ERROR_INTERNET_EXTENDED_ERROR;
            }            
            goto cleanup;
        }
    }

    if (bytesReceived == 0) {

        DEBUG_PRINT(WORKER,
                    ERROR,
                    ("ReceiveData() returns 0 bytes\n"
                    ));

        error = ERROR_NO_MORE_FILES;
        goto cleanup;
    }

    //
    // trap bad servers which return a not-found message in the data stream. We
    // only do this if we are not performing a wild-card search (because the
    // wild-card match will fail to match anything if the target file or path
    // cannot be found)
    //

    LPSTR lpszSearch;
    DWORD dwSearch;

    lpszSearch = (lpszPathPart == NULL) ? lpszFilePart : (LPSTR)lpszFilespec;
    dwSearch = lstrlen(lpszSearch);

    if (!isWild && (bytesReceived > dwSearch)) {
        if (!_strnicmp(lpBuffer, lpszSearch, dwSearch)
        && (lpBuffer[dwSearch] == ':')) {

            static char testChars[] = {'\r', '\n', '\0'};
            LPSTR lpStartOfString = lpBuffer + dwSearch + 1;
            LPSTR lpEndOfString;

            for (int i = 0; i < ARRAY_ELEMENTS(testChars); ++i) {
                lpEndOfString = strchr(lpStartOfString, testChars[i]);
                if (lpEndOfString != NULL) {
                    break;
                }
            }

            //
            // we should have found at least one of the target characters
            //

            INET_ASSERT(lpEndOfString != NULL);

            if (lpEndOfString != NULL) {

                int lengthToTest = (int) (lpEndOfString - lpStartOfString);

                //
                // BUGBUG - internationalization?
                //

                if (strnistr(lpStartOfString, "not found", lengthToTest)
                || strnistr(lpStartOfString, "cannot find", lengthToTest)) {
                    error = ERROR_NO_MORE_FILES;
                    goto cleanup;
                }
            } else {
                error = ERROR_INTERNET_INTERNAL_ERROR;
                goto cleanup;
            }
        }
    }

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)bytesReceived > 0);

    error = ParseDirList(lpBuffer,
                         bytesReceived,
                         isWild ? (LPSTR)lpszFilePart : NULL,
                         &lpSessionInfo->FindFileList
                         );

    //
    // ParseDirList() may have failed
    //

    if (error != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // if there's nothing in the list then no files matching the caller's
    // specification were found
    //

    if (IsListEmpty(&lpSessionInfo->FindFileList)) {
        error = ERROR_NO_MORE_FILES;
    } else {

        //
        // if the caller supplied an output buffer then return the first entry
        // and remove it from the list
        //

        if (ARGUMENT_PRESENT(lpFindFileData)) {

            PLIST_ENTRY pEntry;

            pEntry = RemoveHeadList(&lpSessionInfo->FindFileList);
            CopyMemory(lpFindFileData,
                       (LPWIN32_FIND_DATA)(pEntry + 1),
                       sizeof(*lpFindFileData)
                       );
            FREE_MEMORY(pEntry);
        }

        //
        // FTP can only have one active operation per session, so we just return
        // this session handle as the find handle
        //

        *lphInternet = hFtpSession;
        error = ERROR_SUCCESS;
    }

cleanup:

    if (lpSessionInfo->socketData->IsValid()) {
        lpSessionInfo->socketData->SetLinger(TRUE, 0);
        lpSessionInfo->socketData->Close();
    }

    if (lpBuffer != NULL) {
        (void)FREE_MEMORY((HLOCAL)lpBuffer);
    }

    //
    // if we failed then reset the active find flag. We set it, so we know it
    // is safe to reset without acquiring the session lock
    //

    if (error != ERROR_SUCCESS) {
        lpSessionInfo->Flags &= ~FFTP_FIND_ACTIVE;
    }

deref_exit:

    DereferenceFtpSession(lpSessionInfo);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpDeleteFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName
    )

/*++

Routine Description:

    Deletes a file at an FTP server

Arguments:

    hFtpSession     - identifies the FTP server

    lpszFileName    - name of file to delete

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpDeleteFile",
                "%#x, %q",
                hFtpSession,
                lpszFileName
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "DELE %s",
                        lpszFileName
                        );

        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpRenameFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    )

/*++

Routine Description:

    Renames a file at an FTP server

Arguments:

    hFtpSession     - identifies FTP server

    lpszExisting    - current file name

    lpszNew         - new file name

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpRenameFile",
                "%#x, %q, %q",
                hFtpSession,
                lpszExisting,
                lpszNew
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "RNFR %s",
                        lpszExisting
                        );

        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_CONTINUE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        if (error == ERROR_SUCCESS) {
            error = Command(lpSessionInfo,
                            FALSE,
                            FTP_TRANSFER_TYPE_UNKNOWN,
                            &rcResponse,
                            "RNTO %s",
                            lpszNew
                            );
            if ((error == ERROR_SUCCESS)
            && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
                error = ERROR_INTERNET_EXTENDED_ERROR;
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpOpenFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    OUT LPHINTERNET lphInternet
    )

/*++

Routine Description:

    Initiates the connection to read or write a file at the FTP server

Arguments:

    hFtpSession     - identifies FTP server

    lpszFileName    - name of file to open

    dwAccess        - access mode - GENERIC_READ or GENERIC_WRITE

    dwFlags         - flags controlling how to transfer the data

    lphInternet     - where to return the open file handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpOpenFile",
                "%#x, %q, %#x, %#x, %#x",
                hFtpSession,
                lpszFileName,
                dwAccess,
                dwFlags,
                lphInternet
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        //
        // control session must be established
        //

        if (! lpSessionInfo->socketControl->IsValid()) {
            error = ERROR_FTP_DROPPED;
        } else if ((lpSessionInfo->socketData->IsValid())
        || (lpSessionInfo->Flags & FFTP_FILE_ACTIVE)) {

            //
            // there is a (file) transfer in progress if the socket is valid,
            // or we are awaiting a call to InternetCloseHandle() before we can
            // open another file (FFTP_FILE_ACTIVE is set. This stops another
            // thread from closing our socket handle)
            //

            error = ERROR_FTP_TRANSFER_IN_PROGRESS;
        } else {

            FTP_RESPONSE_CODE rcResponse;

            INET_ASSERT(!lpSessionInfo->socketData->IsValid());

            //
            // Clear the session's "known size bit" before we download the next file,
            //  this is to make sure we don't read an extranous size value off it.
            //

            lpSessionInfo->Flags &= ~(FFTP_KNOWN_FILE_SIZE);

            //
            // send the connection set-up commands, and issue either the send
            // or the receive command
            //
            // Either "RETR filename" or "STOR filename"
            //

            error = NegotiateDataConnection(lpSessionInfo,
                                            dwFlags,
                                            &rcResponse,
                                            (dwAccess & GENERIC_READ)
                                                 ? "RETR %s"
                                                 : "STOR %s",
                                            lpszFileName
                                            );

            if (error == ERROR_SUCCESS) {

                //
                // Check response for failure
                //

                if ((rcResponse.Major != FTP_RESPONSE_PRELIMINARY)
                && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {

                    ICSocket * socketData;

                    //
                    // BUGBUG - RLF - don't know if this is what's intended
                    //          here, but the code just used to check
                    //          socketData != INVALID_SOCKET. Since socketData
                    //          was getting set to INVALID_SOCKET at the top
                    //          of this routine, this branch would never be
                    //          taken
                    //

                    socketData = lpSessionInfo->socketData;
                    if (socketData->IsValid()) {
                        ResetSocket(socketData);
                    }
                    error = ERROR_INTERNET_EXTENDED_ERROR;
                } else {

                    lpSessionInfo->dwTransferAccess = dwAccess;

                    //
                    // Some FTP servers will send us back both the preliminary
                    // response and the complete response so quickly that we
                    // will never see the preliminary.
                    //
                    // In order for FtpCloseFile() to know that the completion
                    // response has been received, we store the response
                    // structure in the Session Info.
                    //
                    // The response structure only needs to be stored between
                    // API calls in this situation, it is not generally
                    // referred to.
                    //

                    SetSessionLastResponseCode(lpSessionInfo, &rcResponse);

                    //
                    // set the abort flag if the file was opened for read - this
                    // lets the server know it can clean up the session if we
                    // close early
                    //

                    if (dwAccess & GENERIC_READ) {
                        lpSessionInfo->Flags |= FFTP_ABORT_TRANSFER;
                    }

                    //
                    // FTP can only have one active operation per session, so
                    // we just return this session handle as the find handle
                    //

                    *lphInternet = hFtpSession;

                    //
                    // this session has an active file operation
                    //

                    lpSessionInfo->Flags |= FFTP_FILE_ACTIVE;

                    //
                    // N.B. error == ERROR_SUCCESS from above test after call
                    // to NegotiateDataConnection
                    //

                    INET_ASSERT(error == ERROR_SUCCESS);
                }
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpCreateDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Creates a directory at the FTP server

Arguments:

    hFtpSession     - identifies the FTP server

    lpszDirectory   - directory to create

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpCreateDirectory",
                "%#x, %q",
                hFtpSession,
                lpszDirectory
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "MKD %s",
                        lpszDirectory
                        );
        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpRemoveDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Removes the named directory at the FTP server

Arguments:

    hFtpSession     - identifies the FTP server

    lpszDirectory   - directory to remove

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpRemoveDirectory",
                "%#x, %q",
                hFtpSession,
                lpszDirectory
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "RMD %s",
                        lpszDirectory
                        );
        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpSetCurrentDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Sets the current directory for this FTP server session

Arguments:

    hFtpSession     - identifies the FTP server/session

    lpszDirectory   - name of directory to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpSetCurrentDirectory",
                "%#x, %q",
                hFtpSession,
                lpszDirectory
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "CWD %s",
                        lpszDirectory
                        );
        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpGetCurrentDirectory(
    IN HINTERNET hFtpSession,
    IN DWORD cchCurrentDirectory,
    OUT LPSTR lpszCurrentDirectory,
    OUT LPDWORD lpdwBytesReturned
    )

/*++

Routine Description:

    Gets the current working directory at the FTP server for this session

Arguments:

    hFtpSession             - identifies FTP server

    cchCurrentDirectory     - number of characters in lpszCurrentDirectory

    lpszCurrentDirectory    - buffer where current directory string is written

    lpdwBytesReturned       - number of characters in output string NOT including
                              terminating NUL

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

                  ERROR_INSUFFICIENT_BUFFER
                    The buffer in lpszCurrentDirectory is not large enough to
                    hold the directory string. *lpdwBytesReturned will have
                    the required size

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpGetCurrentDirectory",
                "%#x, %d, %#x, %#x",
                hFtpSession,
                cchCurrentDirectory,
                lpszCurrentDirectory,
                lpdwBytesReturned
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD cchCopied;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "PWD"
                        );
        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        if (error == ERROR_SUCCESS) {

            LPSTR pchResponse;

            //
            // parse the returned directory name out of the response text
            //

            pchResponse = InternetLockErrorText();
            if (pchResponse != NULL) {
                pchResponse = strstr(pchResponse, "257 ");
                if (pchResponse != NULL) {
                    pchResponse = strchr(pchResponse, '\"');
                    if (pchResponse != NULL) {

                        int idx;

                        ++pchResponse;
                        for (idx = 0, cchCopied = 0; pchResponse[idx] != '\0'; idx++) {
                            if (pchResponse[idx] == '\"') {
                                if (pchResponse[idx + 1] == '\"') {
                                    continue;
                                }
                                break;
                            }
                            if (cchCopied < cchCurrentDirectory) {
                                lpszCurrentDirectory[cchCopied] = pchResponse[idx];
                            }
                            cchCopied++;
                        }
                        if (cchCopied < cchCurrentDirectory) {
                            lpszCurrentDirectory[cchCopied] = '\0';
                            error = ERROR_SUCCESS;
                        } else {
                            error = ERROR_INSUFFICIENT_BUFFER;
                            ++cchCopied;
                        }
                    } else {
                        error = ERROR_INTERNET_EXTENDED_ERROR;
                    }
                }
                //InternetUnlockErrorText();
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    if ((error == ERROR_SUCCESS) || (error == ERROR_INSUFFICIENT_BUFFER)) {
        *lpdwBytesReturned = cchCopied;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpCommand(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand
    )

/*++

Routine Description:

    Runs arbitrary command at an FTP server. Direct connect over Internet

Arguments:

    hFtpSession     - identifies the FTP server

    fExpectResponse - TRUE if we expect a response from the server

    dwFlags         - type of response - ASCII text or BINARY data

    lpszCommand     - pointer to string describing command to run

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpCommand",
                "%#x, %#x, %#x, %q",
                hFtpSession,
                fExpectResponse,
                dwFlags,
                lpszCommand
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    //
    // Look up the given handle.
    //

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        //
        // Issue the command.
        //

        error = Command(lpSessionInfo,
                        fExpectResponse,
                        dwFlags,
                        &rcResponse,
                        lpszCommand
                        );
        if (fExpectResponse && (error == ERROR_SUCCESS)) {

            INET_ASSERT(lpSessionInfo->socketData->IsValid());

            lpSessionInfo->dwTransferAccess |= (GENERIC_READ|GENERIC_WRITE);

        }
#if DBG
        else {

            INET_ASSERT(! lpSessionInfo->socketData->IsValid());

        }

        if (error == ERROR_SUCCESS) {

            INET_ASSERT(lpSessionInfo->socketControl->IsValid());

        }

#endif

        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


//
// Internet subordinate functions
//

DWORD
wFtpFindNextFile(
    IN HINTERNET hFtpSession,
    OUT LPWIN32_FIND_DATA lpFindFileData
    )

/*++

Routine Description:

    Returns the next file found from a call to FtpFindFirstFile().

Arguments:

    hFtpSession     - Handle to an FTP session, as returned from FtpConnect()

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NO_MORE_FILES
                    The end of the file list has been reached.

                  ERROR_INVALID_HANDLE
                    Can't find session that knows about hFind
--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpFindNextFile",
                "%#x, %#x",
                hFtpSession,
                lpFindFileData
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        //
        // ISSUE this code is cut & paste from find first - they should both call a
        // fn instead
        //

        if (!IsListEmpty(&lpSessionInfo->FindFileList)) {

            PLIST_ENTRY pEntry;

            //
            // Enumerate the first entry and advance pointers
            //

            pEntry = RemoveHeadList(&lpSessionInfo->FindFileList);

            INET_ASSERT(pEntry != NULL);

            CopyMemory(lpFindFileData,
                       (LPWIN32_FIND_DATA)(pEntry + 1),
                       sizeof(WIN32_FIND_DATA)
                       );
            FREE_MEMORY(pEntry);
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NO_MORE_FILES;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpFindClose(
    IN HINTERNET hFtpSession
    )

/*++

Routine Description:

    Frees the WIN32_FIND_DATA structures in the directory list for this session

Arguments:

    hFtpSession - handle of an FTP session, created by InternetConnect

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpFindClose",
                "%#x",
                hFtpSession
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {
        ClearFindList(&lpSessionInfo->FindFileList);

        //
        // this session no longer has an active directory listing
        //

        lpSessionInfo->Flags &= ~FFTP_FIND_ACTIVE;
        DereferenceFtpSession(lpSessionInfo);
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpConnect(
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUsername,
    IN LPCSTR lpszPassword,
    IN DWORD dwService,
    IN DWORD dwFlags,
    OUT LPHINTERNET lphInternet
    )

/*++

Routine Description:

    Creates a new FTP session object

Arguments:

    lpszServerName  - pointer to string identifying FTP server

    nServerPort     - port number to connect to

    lpszUsername    - pointer to string identifying user name to log on as

    lpszPassword    - pointer to string identifying password to use with user name

    dwService       - service type parameter (unused)

    dwFlags         - session flags. Currently only INTERNET_FLAG_PASSIVE
                      is defined

    lphInternet     - returned handle of created FTP session

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory while creating the session object

                  ERROR_INTERNET_OUT_OF_HANDLES
                    Ran out of handles while creating the session object

                  ERROR_INTERNET_SHUTDOWN
                    The DLL is being unloaded

--*/

{
    INET_ASSERT(lpszUsername != NULL);
    INET_ASSERT(lpszPassword != NULL);

    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpConnect",
                "%q, %d, %q, %q, %d, %#x, %#x",
                lpszServerName,
                nServerPort,
                lpszUsername,
                lpszPassword,
                dwService,
                dwFlags,
                lphInternet
                ));

    DWORD error;
    LPFTP_SESSION_INFO sessionInfo;

    UNREFERENCED_PARAMETER(lpszUsername);
    UNREFERENCED_PARAMETER(lpszPassword);
    UNREFERENCED_PARAMETER(dwService);

    //
    // create a new FTP session object
    //

    error = CreateFtpSession((LPSTR)lpszServerName,
                             nServerPort,

                             //
                             // if INTERNET_FLAG_PASSIVE then create a passive
                             // session object
                             //

                             (dwFlags & INTERNET_FLAG_PASSIVE)
                                ? FFTP_PASSIVE_MODE
                                : 0,
                             &sessionInfo
                             );
    if (error == ERROR_SUCCESS) {

        //
        // return the FTP_SESSION_INFO handle
        //

        *lphInternet = sessionInfo->Handle;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpMakeConnection(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszUsername,
    IN LPCSTR lpszPassword
    )

/*++

Routine Description:

    Connect with and log into an FTP server.

    This function is cancellable

Arguments:

    hFtpSession - handle of an FTP session, created by InternetConnect

    pszUsername - pointer to string identifying user name to log on as

    pszPassword - pointer to string identifying password to use with user name

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INCORRECT_USER_NAME
                    The server didn't like the user name

                  ERROR_INTERNET_INCORRECT_PASSWORD
                    The server didn't like the password

                  ERROR_INTERNET_LOGIN_FAILURE
                    The server rejected the login request

                  ERROR_FTP_DROPPED
                    The connection has been closed

                  ERROR_FTP_TRANSFER_IN_PROGRESS
                    There is already a transfer in progress on this connection

                  ERROR_INTERNET_NAME_NOT_RESOLVED
                    Couldn't resolve the server name

                  WSA error
                    Couldn't connect to the server, or problems while
                    communicating with it

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpMakeConnection",
                "%#x, %q, %q",
                hFtpSession,
                lpszUsername,
                lpszPassword
                ));

    LPFTP_SESSION_INFO sessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &sessionInfo)) {

        //
        // resolve the FTP server's host name and connect to the server
        //

        error = FtpOpenServer(sessionInfo);
        if (error == ERROR_SUCCESS) {

            FTP_RESPONSE_CODE rcResponse;

            //
            // set send and receive timeouts on the control channel socket.
            // Ignore any errors
            //

            sessionInfo->socketControl->SetTimeout(
                        SEND_TIMEOUT,
                        GetTimeoutValue(INTERNET_OPTION_CONTROL_SEND_TIMEOUT)
                        );

            sessionInfo->socketControl->SetTimeout(
                        RECEIVE_TIMEOUT,
                        GetTimeoutValue(INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT)
                        );

            //
            // check greeting and store in per-thread response text buffer
            //

            error = GetReply(sessionInfo, &rcResponse);
            if (error == ERROR_SUCCESS) {

                //
                // check that the server sent us an affirmative response
                //

                if (rcResponse.Major == FTP_RESPONSE_COMPLETE) {

                    //
                    // send the user name
                    //

                    error = Command(sessionInfo,
                                    FALSE,
                                    FTP_TRANSFER_TYPE_UNKNOWN,
                                    &rcResponse,
                                    "USER %s",
                                    lpszUsername
                                    );

                    //
                    // BUGBUG - is it possible to get success from Command(),
                    //          but an error from the server - e.g. 332, need
                    //          account for login?
                    //

                    if (error == ERROR_SUCCESS) {

                        //
                        // send the password if required
                        //

                        if (rcResponse.Major == FTP_RESPONSE_CONTINUE) {
                            error = Command(sessionInfo,
                                            FALSE,
                                            FTP_TRANSFER_TYPE_UNKNOWN,
                                            &rcResponse,
                                            "PASS %s",
                                            lpszPassword
                                            );

                            //
                            // if we failed to send the password, or the password
                            // was rejected, or we are attempting to log on as
                            // "anonymous" and it turns out that the server does
                            // not allow anonymous logon, then return a password
                            // error. The caller can still check the response
                            // from the server
                            //

                            if (((error == ERROR_SUCCESS)
                                && (rcResponse.Major != FTP_RESPONSE_COMPLETE))
                            || (error == ERROR_INTERNET_EXTENDED_ERROR)) {
                                if (stricmp(lpszUsername, "anonymous") == 0) {
                                    error = ERROR_INTERNET_LOGIN_FAILURE;
                                } else {
                                    error = ERROR_INTERNET_INCORRECT_PASSWORD;
                                }
                            }
                        } else if (rcResponse.Major != FTP_RESPONSE_COMPLETE) {
                            error = ERROR_INTERNET_INCORRECT_USER_NAME;
                        }

                        //
                        // get the server type
                        //

                        //if (error == ERROR_SUCCESS) {
                        //    error = wFtpFindServerType(hFtpSession);
                        //}
                    }
                } else {
                    error = ERROR_INTERNET_LOGIN_FAILURE;
                }
            }
        }

        //
        // success or fail: unlock the session object
        //

        DereferenceFtpSession(sessionInfo);

        //
        // if we failed to login then let wFtpDisconnect() clean up - it will
        // also send a "QUIT" to the server (if we have a control connection)
        // which will ensure a clean exit
        //

        if (error != ERROR_SUCCESS) {

            //
            // if we experience an error during disconnect, we will just ignore
            // it and return the error generated during our failed login attempt
            //

            (void)wFtpDisconnect(hFtpSession, CF_EXPEDITED_CLOSE);
        }
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpDisconnect(
    IN HINTERNET hFtpSession,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Closes the connection, issues the quit command, etc.,

Arguments:

    hFtpSession - FTP session created by wFtpConnect

    dwFlags     - controlling operation. Can be:

                    CF_EXPEDITED_CLOSE  - Don't send QUIT to the server, just
                                          close the control connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpDisconnect",
                "%#x, %#x",
                hFtpSession,
                dwFlags
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        ICSocket * socketControl;
        ICSocket * socketData;

        socketControl = lpSessionInfo->socketControl;
        socketData = lpSessionInfo->socketData;

        //
        // kill any active data transfer
        //

        if (socketData->IsValid()) {

            //
            // set the non-blocking state depending on whether we are called in
            // an app thread context, or in the async scheduler thread context
            //

            //socketData->SetNonBlockingMode(lpThreadInfo->IsAsyncWorkerThread);

            if (dwFlags & CF_EXPEDITED_CLOSE) {
                error = socketData->Close();
            } else {
                error = wFtpCloseFile(hFtpSession);
                if (error != ERROR_SUCCESS) {

                    DEBUG_PRINT(WORKER,
                                ERROR,
                                ("wFtpCloseFile() returns %d\n",
                                error
                                ));

                }
            }
        }

        INET_ASSERT(!lpSessionInfo->socketData->IsValid());

        //
        // perform graceful close to the server if we have a control connection
        //

        if (socketControl->IsValid()) {

            //
            // set the non-blocking state depending on whether we are called in
            // an app thread context, or in the async scheduler thread context
            //

            //socketControl->SetNonBlockingMode(lpThreadInfo->IsAsyncWorkerThread);

            if (!(dwFlags & CF_EXPEDITED_CLOSE)) {

                FTP_RESPONSE_CODE rcResponse;

                Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "QUIT"
                        );
            }
            lpSessionInfo->socketControl->Disconnect(SF_INDICATE);
        }

        //
        // finally kill the FTP_SESSION_INFO structure
        //

        TerminateFtpSession(lpSessionInfo);
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INVALID_HANDLE;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpReadFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    Reads data from the FTP server. We use the data channel

Arguments:

    hFtpSession             - handle identifying FTP session

    lpBuffer                - pointer to buffer for received data

    dwNumberOfBytesToRead   - size of lpBuffer in bytes

    lpdwNumberOfBytesRead   - returned number of bytes received

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find hFtpSession

                  ERROR_ACCESS_DENIED
                    This session doesn't have read access (?)

                  ERROR_FTP_DROPPED
                    The data channel has been closed

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpReadFile",
                "%#x, %#x, %d, %#x",
                hFtpSession,
                lpBuffer,
                dwNumberOfBytesToRead,
                lpdwNumberOfBytesRead
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPFTP_SESSION_INFO lpSessionInfo;
    ICSocket * socketData;
    BOOL eof;
    DWORD bytesReceived;

    //
    // initialize variables in case we quit early (i.e. via goto)
    //

    bytesReceived = 0;

    //
    // find the FTP_SESSION_INFO and ensure it is set up to receive data
    //

    if (!FindFtpSession(hFtpSession, &lpSessionInfo)) {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    //
    // if FFTP_EOF is set then we already reached the end the file
    //

    if (lpSessionInfo->Flags & FFTP_EOF) {
        error = ERROR_SUCCESS;
        goto unlock_and_quit;
    }

    //
    // get the data socket. If it has become INVALID_SOCKET then the server
    // closed the connection
    //

    socketData = lpSessionInfo->socketData;
    if (!socketData->IsValid()) {
        error = ERROR_FTP_DROPPED;
        goto unlock_and_quit;
    }

    if (!(lpSessionInfo->dwTransferAccess & GENERIC_READ)) {
        error = ERROR_ACCESS_DENIED;
        goto unlock_and_quit;
    }

    //
    // read until we fill the users buffer, get an error, or get to EOF
    //

    DWORD bufferRemaining;

    bufferRemaining = dwNumberOfBytesToRead;
    error = socketData->Receive(
                          &lpBuffer,
                          &dwNumberOfBytesToRead,   // lpdwBufferLength
                          &bufferRemaining,         // lpdwBufferRemaining
                          &bytesReceived,           // lpdwBytesReceived
                          0,                        // dwExtraSpace
                          SF_RECEIVE_ALL
                          | SF_INDICATE,
                          &eof
                          );
    if (error == ERROR_SUCCESS) {

        //
        // if we got to EOF then the server will have closed the data
        // connection. We need to close the socket at our end. If this is
        // a passive connection then we initiate session termination
        //

        if (eof) {
            (void)socketData->Close();

            INET_ASSERT(lpSessionInfo->socketData == socketData);

            //
            // reset the abort flag - we no longer have to send and ABOR command
            // when we close the handle
            //

            lpSessionInfo->Flags &= ~FFTP_ABORT_TRANSFER;

            //
            // set EOF in the FTP_SESSION_INFO flags so we know next time
            // we call this function that the session is not dropped, but
            // that we already reached the end of the data
            //

            lpSessionInfo->Flags |= FFTP_EOF;
        }
    }

    //
    // BUGBUG - in error case we should probably close the socket, set
    //          INVALID_SOCKET in the FTP_SESSION_INFO, etc.
    //

unlock_and_quit:

    //
    // update the output parameters if we succeeded
    //

    if (error == ERROR_SUCCESS) {
        *lpdwNumberOfBytesRead = bytesReceived;
    }

    DereferenceFtpSession(lpSessionInfo);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpWriteFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    Writes data to the FTP server. We use the data channel

Arguments:

    hFtpSession                 - handle identifying FTP session

    lpBuffer                    - pointer to buffer containing data to write

    dwNumberOfBytesToWrite      - size of lpBuffer in bytes

    lpdwNumberOfBytesWritten    - returned number of bytes sent

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find hFtpSession

                  ERROR_ACCESS_DENIED
                    This session doesn't have write access (?)

                  ERROR_FTP_DROPPED
                    The data channel has been closed

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpWriteFile",
                "%#x, %#x, %d, %#x",
                hFtpSession,
                lpBuffer,
                dwNumberOfBytesToWrite,
                lpdwNumberOfBytesWritten
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPFTP_SESSION_INFO lpSessionInfo;
    ICSocket * socketData;
    int nSent;

    //
    // find the FTP_SESSION_INFO and ensure it is set up to send data
    //

    if (!FindFtpSession(hFtpSession, &lpSessionInfo)) {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    socketData = lpSessionInfo->socketData;
    if (! socketData->IsValid()) {
        error = ERROR_FTP_DROPPED;
        goto unlock_and_quit;
    }

    if (!(lpSessionInfo->dwTransferAccess & GENERIC_WRITE)) {
        error = ERROR_ACCESS_DENIED;
        goto unlock_and_quit;
    }

    error = socketData->Send(lpBuffer, dwNumberOfBytesToWrite, SF_INDICATE);
    if (error == ERROR_SUCCESS) {
        *lpdwNumberOfBytesWritten = dwNumberOfBytesToWrite;
    } else {

        //
        // we had a failure. We should check the control socket for any error
        // info from the server
        //

        FTP_RESPONSE_CODE response = {0};
        response.Major = FTP_RESPONSE_PERMANENT_FAILURE;
        //
        SetSessionLastResponseCode(lpSessionInfo, &response);
    }

unlock_and_quit:

    DereferenceFtpSession(lpSessionInfo);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpQueryDataAvailable(
    IN HINTERNET hFtpSession,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines amount of data available to be received on a data (file) socket

Arguments:

    hFtpSession                 - identifies FTP session

    lpdwNumberOfBytesAvailable  - returned number of bytes available

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpQueryDataAvailable",
                "%#x, %#x",
                hFtpSession,
                lpdwNumberOfBytesAvailable
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(lpThreadInfo->hObjectMapped, &handleType);

    if (error != ERROR_SUCCESS) {
        return (error);
    }

    *lpdwNumberOfBytesAvailable = 0;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPFTP_SESSION_INFO lpSessionInfo;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        //
        // if we are currently performing a directory list then return the size
        // of a dir list entry
        //

        if (lpSessionInfo->Flags & FFTP_FIND_ACTIVE) {
            *lpdwNumberOfBytesAvailable = !IsListEmpty(&lpSessionInfo->FindFileList)
                                        ? sizeof(WIN32_FIND_DATA) : 0;
        } else {

            //
            // otherwise, if we are receiving data, find out how much
            //

            ICSocket * socketData;

            socketData = lpSessionInfo->socketData;
            if (socketData->IsValid()) {
                error = socketData->DataAvailable(lpdwNumberOfBytesAvailable);
            } else {

                //
                // there is no data connection
                //

                *lpdwNumberOfBytesAvailable = 0;
                error = ERROR_SUCCESS;
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

quit:

    if ((error == ERROR_SUCCESS) && (*lpdwNumberOfBytesAvailable == 0)) {

        InbLocalEndCacheWrite(lpThreadInfo->hObjectMapped,
                                            ((handleType==TypeFtpFindHandleHtml)
                                            ?"htm":NULL),
                                            TRUE);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpCloseFile(
    IN HINTERNET hFtpSession
    )

/*++

Routine Description:

    Terminates the connection used for file transfer. The connection may already
    be closed (by the server during a READ, or by the client during a WRITE) in
    which case we just need to receive the confirmation (226) on the control
    socket. If the connection is still open, or the abort flag is set for this
    connection, then this is an abnormal termination, and we need to send an
    ABORt command

Arguments:

    hFtpSession - Identifies the session on which to terminate file transfer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find the FTP_SESSION_INFO corresponding to
                    hFtpSession

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpCloseFile",
                "%#x",
                hFtpSession
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        BOOL getResponse;
        ICSocket * socketData;
        FTP_RESPONSE_CODE rcResponse;

        socketData = lpSessionInfo->socketData;
        if (socketData->IsValid()) {

            //
            // if we are performing a read/write operation and the transfer
            // isn't complete then abort the connection
            //

            if (lpSessionInfo->Flags & FFTP_ABORT_TRANSFER) {
                AbortTransfer(lpSessionInfo);
                ResetSocket(lpSessionInfo->socketData);
            } else {

                //
                // in all other cases - completed READ, complete or incomplete
                // WRITE - just close the socket
                //

                lpSessionInfo->socketData->Close();
            }
        } else if (lpSessionInfo->Flags & FFTP_ABORT_TRANSFER) {

            //
            // we have no data socket, but the abort transfer flag is set. We
            // are probably closing a file we opened for read without having
            // read any data. In this case we send an abort anyway
            //

            AbortTransfer(lpSessionInfo);
        }

        //
        // get the server response - we expect either 226 to a good transfer,
        // or 426 for an aborted transfer...
        //

        GetSessionLastResponseCode(lpSessionInfo, &rcResponse);
        if (rcResponse.Major == FTP_RESPONSE_PRELIMINARY) {
            error = GetReply(lpSessionInfo, &rcResponse);
            SetLastError(ERROR_SUCCESS);  // a-thkesa;. added from Win CE fix of BUG WinSE: 23985
            if ((error == ERROR_SUCCESS)
            && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
                error = ERROR_INTERNET_EXTENDED_ERROR;
                SetLastError(error); // a-thkesa;. added from Win CE fix of BUG WinSE: 23985 
            }
        } else if (rcResponse.Major == FTP_RESPONSE_PERMANENT_FAILURE){
            error = ERROR_SUCCESS;
        } else {
            if(rcResponse.Major != FTP_RESPONSE_COMPLETE)
                error = GetReply(lpSessionInfo, &rcResponse);
            else
                error = ERROR_SUCCESS;
        }

        //
        // reset the ABORT, FILE_ACTIVE and EOF flags
        //

        lpSessionInfo->Flags &= ~(FFTP_ABORT_TRANSFER
                                  | FFTP_EOF
                                  | FFTP_FILE_ACTIVE
                                  );
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpFindServerType(
    IN HINTERNET hFtpSession
    )

/*++

Routine Description:

    Determines the type of server we are talking to (NT or Unix)

Arguments:

    hFtpSession - identifies FTP_SESSION_INFO. The structure ServerType field
                  will be updated with the discovered info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find the FTP_SESSION_INFO corresponding to
                    hFtpSession

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpFindServerType",
                "%#x",
                hFtpSession
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "SYST"
                        );
        if (error == ERROR_SUCCESS) {

            LPSTR lpszResponse = InternetLockErrorText();

            if (lpszResponse != NULL) {

                FTP_SERVER_TYPE serverType = FTP_SERVER_TYPE_UNKNOWN;

                //
                // "215 " must be first token in response text
                //

                lpszResponse = strstr(lpszResponse, "215 ");
                if (lpszResponse != NULL) {

                    //
                    // check for existence of "Windows_NT" or "Unix" (case
                    // insensitive comparison)
                    //

                    //
                    // BUGBUG - find out from MuraliK/TerryK the values these
                    //          ids can have
                    //

                    static struct {
                        LPCSTR lpszSystemName;
                        FTP_SERVER_TYPE ServerType;
                    } FtpServerTypes[] = {
                        "Windows_NT",   FTP_SERVER_TYPE_NT,
                        "Unix",         FTP_SERVER_TYPE_UNIX
                    };

                    DWORD textLength = strlen(lpszResponse);

                    for (int i = 0; i < ARRAY_ELEMENTS(FtpServerTypes); ++i) {
                        if (strnistr(lpszResponse,
                                     (LPSTR)FtpServerTypes[i].lpszSystemName,
                                     textLength
                                     ) != NULL) {

                            serverType = FtpServerTypes[i].ServerType;

                            DEBUG_PRINT(FTP,
                                        INFO,
                                        ("serverType = %s (%d)\n",
                                        InternetMapFtpServerType(serverType),
                                        serverType
                                        ));

                            break;
                        }
                    }
                }
                lpSessionInfo->ServerType = serverType;
                //InternetUnlockErrorText();
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}



#if 0

//
// We don't use this today, because FtpGetFileSize does not support
//   issuing backround commands through the FTP Control socket while
//   the user is doing an FTP download (with FtpOpenFile)
//


DWORD
wFtpGetFileSize(
    IN  HINTERNET hMappedFtpSession,
    IN  LPFTP_SESSION_INFO lpSessionInfo,
    OUT LPDWORD lpdwFileSizeLow,
    OUT LPDWORD lpdwFileSizeHigh
    )

/*++

Routine Description:

    Finds size of a file at server

Arguments:

    hFtpSession         - identifies mapped FTP handle obj

    lpSessionInfo       - LPFTP_SESSION_INFO structure ptr.

    lpdwFileSizeLow     - pointer to low dword of file size

    lpdwFileSizeHigh    - optional output pointer to high dword of file size

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find the FTP_SESSION_INFO corresponding to
                    hFtpSession

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpGetFileSize",
                "%#x, %#x, %#x, %#x",
                hMappedFtpSession,
                lpSessionInfo,
                lpdwFileSizeLow,
                lpdwFileSizeHigh
                ));


    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;
    FTP_FILE_HANDLE_OBJECT * pFileMapped = (FTP_FILE_HANDLE_OBJECT *) hMappedFtpSession;

    *lpdwFileSizeLow  = 0;
    *lpdwFileSizeHigh = 0;

    if (lpSessionInfo) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "SIZE %s",
                        pFileMapped->GetFileName()
                        );
        if (error == ERROR_SUCCESS) {

            LPSTR lpszResponse = InternetLockErrorText();

            if (lpszResponse != NULL) {

                FTP_SERVER_TYPE serverType = FTP_SERVER_TYPE_UNKNOWN;

                //
                // "213 " must be first token in response text of file size
                //

                lpszResponse = strstr(lpszResponse, "213 ");
                if (lpszResponse != NULL) {
                    *lpdwFileSizeLow = atoi(lpszResponse);
                    error = ERROR_SUCCESS;
                }
            }
        }
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}
#endif

//
// private debug functions
//

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
InternetMapFtpServerType(
    IN FTP_SERVER_TYPE ServerType
    )
{
    switch (ServerType) {
    CASE_OF(FTP_SERVER_TYPE_UNKNOWN);
    CASE_OF(FTP_SERVER_TYPE_NT);
    CASE_OF(FTP_SERVER_TYPE_UNIX);
    }
    return "?";
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\namep.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    namep.cxx

Abstract:

    This module declares the global data used by the Name Module

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

    Heath Hunnicutt [T-HeathH]  17-Jul-1994 - adopted and stripped of most
        stuff for ftphelp api.

--*/

#include <wininetp.h>
#include "ftpapih.h"
#include "namep.h"

//
//  The global static legal ANSI character array.  Wild characters
//  are not considered legal, they should be checked seperately if
//  allowed.
//

static UCHAR LocalLegalAnsiCharacterArray[128] = {

    0,                                                     // 0x00 ^@
    0,                                                     // 0x01 ^A
    0,                                                     // 0x02 ^B
    0,                                                     // 0x03 ^C
    0,                                                     // 0x04 ^D
    0,                                                     // 0x05 ^E
    0,                                                     // 0x06 ^F
    0,                                                     // 0x07 ^G
    0,                                                     // 0x08 ^H
    0,                                                     // 0x09 ^I
    0,                                                     // 0x0A ^J
    0,                                                     // 0x0B ^K
    0,                                                     // 0x0C ^L
    0,                                                     // 0x0D ^M
    0,                                                     // 0x0E ^N
    0,                                                     // 0x0F ^O
    0,                                                     // 0x10 ^P
    0,                                                     // 0x11 ^Q
    0,                                                     // 0x12 ^R
    0,                                                     // 0x13 ^S
    0,                                                     // 0x14 ^T
    0,                                                     // 0x15 ^U
    0,                                                     // 0x16 ^V
    0,                                                     // 0x17 ^W
    0,                                                     // 0x18 ^X
    0,                                                     // 0x19 ^Y
    0,                                                     // 0x1A ^Z
    0,                                                     // 0x1B
    0,                                                     // 0x1C
    0,                                                     // 0x1D
    0,                                                     // 0x1E
    0,                                                     // 0x1F
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x20
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x21 !
    MY_FSRTL_WILD_CHARACTER,                                  // 0x22 "
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x23 #
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x24 $
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x25 %
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x26 &
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x27 '
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x28 (
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x29 )
    MY_FSRTL_WILD_CHARACTER,                                  // 0x2A *
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x2B +
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x2C ,
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x2D -
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x2E .
    0,                                                     // 0x2F /
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x30 0
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x31 1
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x32 2
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x33 3
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x34 4
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x35 5
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x36 6
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x37 7
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x38 8
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x39 9
    MY_FSRTL_NTFS_LEGAL,                                      // 0x3A :
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x3B ;
    MY_FSRTL_WILD_CHARACTER,                                  // 0x3C <
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x3D =
    MY_FSRTL_WILD_CHARACTER,                                  // 0x3E >
    MY_FSRTL_WILD_CHARACTER,                                  // 0x3F ?
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x40 @
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x41 A
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x42 B
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x43 C
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x44 D
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x45 E
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x46 F
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x47 G
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x48 H
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x49 I
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4A J
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4B K
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4C L
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4D M
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4E N
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4F O
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x50 P
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x51 Q
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x52 R
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x53 S
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x54 T
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x55 U
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x56 V
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x57 W
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x58 X
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x59 Y
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x5A Z
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x5B [
    0,                                                     // 0x5C backslash
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x5D ]
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x5E ^
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x5F _
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x60 `
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x61 a
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x62 b
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x63 c
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x64 d
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x65 e
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x66 f
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x67 g
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x68 h
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x69 i
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6A j
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6B k
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6C l
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6D m
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6E n
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6F o
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x70 p
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x71 q
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x72 r
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x73 s
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x74 t
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x75 u
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x76 v
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x77 w
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x78 x
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x79 y
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7A z
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7B {
    0,                                                     // 0x7C |
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7D }
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7E ~
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7F ^?
};

PUCHAR MyFsRtlLegalAnsiCharacterArray = &LocalLegalAnsiCharacterArray[0];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\makefile.inc ===
lprmnmsg.h lprmnmsg.rc msg00001.bin: lprmnmsg.mc
    mc -v lprmnmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\name.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Name.h

Abstract:

    This module defines all of the name.c routines

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

    Heath Hunnicutt [T-HeathH]  13-Jul-1994 - Ported this file to ftphelp
        project.

--*/

#ifndef _NAME_H_INCLUDED_
#define _NAME_H_INCLUDED_

#if defined(__cplusplus)
extern "C" {
#endif

//
//  The following enumerated type is used to denote the result of name
//  comparisons
//

typedef enum _MY_FSRTL_COMPARISON_RESULT {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} MY_FSRTL_COMPARISON_RESULT;
//
//  These following bit values are set in the MyFsRtlLegalDbcsCharacterArray
//

extern PUCHAR MyFsRtlLegalAnsiCharacterArray;

#define MY_FSRTL_FAT_LEGAL         0x01
#define MY_FSRTL_HPFS_LEGAL        0x02
#define MY_FSRTL_NTFS_LEGAL        0x04
#define MY_FSRTL_WILD_CHARACTER    0x08

//
//  The following macro is used to determine if an Ansi character is wild.
//

#define MyFsRtlIsAnsiCharacterWild(C) (                                 \
        ((SCHAR)(C) < 0) ? FALSE :                                    \
                           FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)], \
                                   MY_FSRTL_WILD_CHARACTER )             \
)

//
//  The following macro is used to determine if an Ansi character is Fat legal.
//

#define MyFsRtlIsAnsiCharacterLegalFat(C,WILD_OK) (                           \
        ((SCHAR)(C) < 0) ? TRUE :                                           \
                           FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)],       \
                                   MY_FSRTL_FAT_LEGAL |                        \
                                   ((WILD_OK) ? MY_FSRTL_WILD_CHARACTER : 0) ) \
)

//
//  The following macro is used to determine if an Ansi character is Hpfs legal.
//

#define MyFsRtlIsAnsiCharacterLegalHpfs(C,WILD_OK) (                          \
        ((SCHAR)(C) < 0) ? TRUE :                                           \
                           FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)],       \
                                   MY_FSRTL_HPFS_LEGAL |                       \
                                   ((WILD_OK) ? MY_FSRTL_WILD_CHARACTER : 0) ) \
)

//
//  The following macro is used to determine if an Ansi character is Ntfs legal.
//

#define MyFsRtlIsAnsiCharacterLegalNtfs(C,WILD_OK) (                          \
        ((SCHAR)(C) < 0) ? TRUE :                                           \
                           FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)],       \
                                   MY_FSRTL_NTFS_LEGAL |                       \
                                   ((WILD_OK) ? MY_FSRTL_WILD_CHARACTER : 0) ) \
)

//
//  Unicode Name support routines, implemented in Name.c
//
//  The routines here are used to manipulate unicode names
//

//
//  The following macro is used to determine if a character is wild.
//

#define MyFsRtlIsUnicodeCharacterWild(C) (                                  \
      (((C) >= 0x40) ? FALSE : FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)], \
                                       MY_FSRTL_WILD_CHARACTER ) )           \
)

BOOLEAN
MyFsRtlIsNameInExpression
(
    IN LPCSTR pszExpression,
    IN LPCSTR pszName,
    IN BOOLEAN IgnoreCase
);


#if defined(__cplusplus)
}
#endif

#endif // _NAME_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\namep.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NameP.h

Abstract:

    This module defines private part of the File System Rtl component, used by
        name.c.

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

        [t-HeathH]  17-Jul-1994 Moved this header file into the ftphelp porject, to
        maintain a single source base for Chicago and NT.

--*/

#ifndef _NAMEP_H_INCLUDED_
#define _NAMEP_H_INCLUDED_

#if defined(__cplusplus)
extern "C" {
#endif

//#include "ftp.h"
#include <name.h>

//
//  The global MyFsRtl debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bug check)
//
//      0x00000001      Error conditions
//      0x00000002      Debug hooks
//      0x00000004
//      0x00000008
//
//      0x00000010
//      0x00000020
//      0x00000040
//      0x00000080
//
//      0x00000100
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000
//      0x00002000
//      0x00004000
//      0x00008000
//
//      0x00010000
//      0x00020000
//      0x00040000
//      0x00080000
//
//      0x00100000
//      0x00200000
//      0x00400000
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000      NotifyChange routines
//      0x08000000      Oplock routines
//
//      0x10000000      Name routines
//      0x20000000      FileLock routines
//      0x40000000      Vmcb routines
//      0x80000000      Mcb routines
//

//
//  Debug trace support
//

#ifdef FSRTLDBG

extern LONG MyFsRtlDebugTraceLevel;
extern LONG MyFsRtlDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                        \
    LONG _i;                                                  \
    if (((LEVEL) == 0) || (MyFsRtlDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                     \
        DbgPrint("%08lx:",_i);                                 \
        if ((INDENT) < 0) {                                   \
            MyFsRtlDebugTraceIndent += (INDENT);                \
        }                                                     \
        if (MyFsRtlDebugTraceIndent < 0) {                      \
            MyFsRtlDebugTraceIndent = 0;                        \
        }                                                     \
        for (_i=0; _i<MyFsRtlDebugTraceIndent; _i+=1) {         \
            DbgPrint(" ");                                     \
        }                                                     \
        DbgPrint(X,Y);                                         \
        if ((INDENT) > 0) {                                   \
            MyFsRtlDebugTraceIndent += (INDENT);                \
        }                                                     \
    }                                                         \
}

#define DebugDump(STR,LEVEL,PTR) {                            \
    ULONG _i;                                                 \
    VOID MyFsRtlDump();                                         \
    if (((LEVEL) == 0) || (MyFsRtlDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                     \
        DbgPrint("%08lx:",_i);                                 \
        DbgPrint(STR);                                         \
        if (PTR != NULL) {MyFsRtlDump(PTR);}                    \
        DbgBreakPoint();                                      \
    }                                                         \
}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}

#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#endif // FSRTLDBG

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  This macro takes a ulong and returns its value rounded up to a sector
//  boundary
//

#define SectorAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 511) & 0xfffffe00) \
    )

//
//  This macro takes a number of bytes and returns the number of sectors
//  required to contain that many bytes, i.e., it sector aligns and divides
//  by the size of a sector.
//

#define SectorsFromBytes(bytes) ( \
    ((bytes) + 511) / 512         \
    )

//
//  This macro takes a number of sectors and returns the number of bytes
//  contained in that many sectors.
//

#define BytesFromSectors(sectors) ( \
    (sectors) * 512                 \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

#if defined(__cplusplus)
}
#endif

#endif // _FSRTLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\protocol.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    protocol.h

Abstract:

    Prototypes, etc. for protocol.c

Author:

    Richard L Firth (rfirth) 16-Mar-1995

Revision History:

    16-Mar-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
Command(
    IN OUT LPFTP_SESSION_INFO lpSessionInfo,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE * prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN ...
    );

DWORD
I_Command(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN FTP_RESPONSE_CODE * prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist
    );

DWORD
__cdecl
NegotiateDataConnection(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    OUT FTP_RESPONSE_CODE * prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN ...
    );

DWORD
GetReply(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    OUT FTP_RESPONSE_CODE * prcResponse
    );

DWORD
ReceiveFtpResponse(
    IN ICSocket * Socket,
    OUT LPVOID * lpBuffer,
    OUT LPDWORD lpdwBufferLength,
    IN BOOL bEndOfLineCheck,
    IN FTP_RESPONSE_CODE * prcResponse
    );

DWORD
AbortTransfer(
    IN LPFTP_SESSION_INFO lpSessionInfo
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\name.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    name.cxx

Abstract:

    Support for pattern-matching file names versus file specs, used by
    FtpFindFirstFile() to form the list of found files.  Lifted from
    ntos\fsrtl\name.c, and trimmed to fit.

    This module was included in the ftphelp project because of the need
    for binary portability to Chicago.

    ---

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    This package uses the same FSRTL_COMPARISON_RESULT typedef used by name.c

    The following routines are provided by this package:

      o  MyFsRtlDissectName - removed

      o  MyFsRtlColateNames - removed

      o  MyFsRtlDoesNameContainsWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  MyFsRtlIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

        Heath Hunnicutt [t-heathh] 13-Jul-1994

--*/

#include <wininetp.h>
#include "ftpapih.h"
#include "namep.h"

//
//  Trace level for the module
//

#define Dbg                              (0x10000000)

//
//  Some special debugging stuff
//

#if DBG

extern ULONG DaveDebug;
#define DavePrint if (DaveDebug) DbgPrint

#else

#define DavePrint NOTHING

#endif

//
//  Local support routine prototypes
//

BOOLEAN
MyFsRtlIsNameInExpressionPrivate
(
    IN ANSI_STRING *Expression,
    IN ANSI_STRING *Name
);

BOOLEAN
MyFsRtlDoesNameContainWildCards
(
    IN LPCSTR pszName
)

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/

{
    ULONG i;
    USHORT Length;

//    PAGED_CODE();

    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    Length =(unsigned short) lstrlenA( pszName );
    for (i = 0; i < Length; i += 1) {

        //
        //  check for a wild card character
        //

        if (MyFsRtlIsAnsiCharacterWild( pszName[i] )) {

            //
            //  Tell caller that this name contains wild cards
            //

            return TRUE;
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}


//
//  The following routine is just a wrapper around
//  MyFsRtlIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOLEAN
MyFsRtlIsNameInExpression
(
    IN LPCSTR pszExpression,
    IN LPCSTR pszName,
    IN BOOLEAN IgnoreCase
)
{
    BOOLEAN Result=FALSE;

        ANSI_STRING Expression;
        ANSI_STRING Name;

        Name.Buffer = NewString( pszName );

        if ( Name.Buffer==NULL )
            {
                return( FALSE );
            }

        Expression.Buffer = NewString( pszExpression );

        if ( Expression.Buffer==NULL )
            {
                FREE_MEMORY( Name.Buffer );
                return( FALSE );
            }

        if ( IgnoreCase )
            {
                strupr( Name.Buffer );
                strupr( Expression.Buffer );
            }

        Name.Length = (unsigned short) lstrlenA( Name.Buffer );
        Name.MaximumLength = Name.Length;

        Expression.Length = (unsigned short) lstrlenA( Expression.Buffer );
        Expression.MaximumLength = Expression.Length;

    //
    //  Now call the main routine, remembering to free the upcased string
    //  if we allocated one.
    //

    __try {

        Result = MyFsRtlIsNameInExpressionPrivate( &Expression,
                                                 &Name );

    } __finally {
        FREE_MEMORY(Name.Buffer);
        FREE_MEMORY(Expression.Buffer);
    }
    ENDFINALLY
    return Result;
}


#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

BOOLEAN
MyFsRtlIsNameInExpressionPrivate
(
    IN ANSI_STRING *Expression,
    IN ANSI_STRING *Name
)

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except .

               e is a null character transition

               EOF is the end of the name string


    The last construction, ~? (the DOS question mark), can either match any
    single character, or upon encountering a period or end of input string,
    advances the expression to the end of the set of contiguous ~?s.  This may
    seem somewhat convoluted, but is what DOS needs.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    CaseInsensitive - TRUE if Name should be Upcased before comparing.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    ULONG StartingNameOffset;

    CHAR NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

//    PAGED_CODE();

    INET_ASSERT(Name->Length != 0);
    INET_ASSERT(Expression->Length != 0);

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *, or *.*
    //

    if ((Expression->Length == 1 && Expression->Buffer[0] == '*')
    || (Expression->Length == 3 && memcmp(Expression->Buffer,"*.*",3)==0)) {

        return TRUE;
    }

    INET_ASSERT(MyFsRtlDoesNameContainWildCards(Expression->Buffer));

    //
    // Before special casing *X, we must special case *., as people tend
    // to use that expression incorrectly to mean "all files without
    // extensions."  However, if this case, fails, it falls through to the
    // next special case, wherein files ending in dots match *.
    //

    if ( Expression->Length == 2 && memcmp(Expression->Buffer,"*.",2)==0 ) {

        PVOID pvDot;

        //
        // Attempt to find a dot in the name buffer.  A dot would indicate
        // the presence of an extension.
        //

        pvDot = memchr( Name->Buffer, '.', Name->Length );

        //
        // If there is no dot, return that this name matches the expression "*."
        //

        if ( pvDot==NULL ) {
            return( TRUE );
        }
    }

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == '*') {

        //
        //  Only special case an expression with a single *, recognized
        //  by the fact that the tail contains no wildcards.
        //

        if ( !MyFsRtlDoesNameContainWildCards( Expression->Buffer + 1 ) ) {
            if (Name->Length < (USHORT)(Expression->Length - sizeof(CHAR))) {
                return FALSE;
            }

                        //
                        // Calculate the offset to the Name's tail.
                        //

            StartingNameOffset = ( Name->Length - ( Expression->Length - 1 ) );

            //
            //  Compare the tail of the expression with the name.
            //

            return( (BOOLEAN)
                            memcmp( Expression->Buffer + 1,
                                            Name->Buffer + StartingNameOffset,
                                            Name->Length - StartingNameOffset ) == 0 );
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[ NameOffset ];

            NameOffset ++;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount )
            {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                INET_ASSERT(ExprOffset >= 0);
                INET_ASSERT(ExprOffset <= Expression->Length);

                if ( ExprOffset == Expression->Length ) {
                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(CHAR);

                CurrentState = (USHORT)(ExprOffset*2);

                if ( ExprOffset == Expression->Length ) {
                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset];

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) && (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(CHAR);

                    AuxBuffer = (USHORT *)
                                ALLOCATE_MEMORY(LMEM_FIXED,
                                                (ExpressionChars + 1)
                                                    * sizeof(USHORT) * 2 * 2
                                                );

                    CopyMemory( AuxBuffer,
                                CurrentMatches,
                                MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    CopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                PreviousMatches,
                                MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == '*') {
                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 1;
                    continue;
                }


                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(CHAR) * 2);

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    INET_ASSERT(FALSE);

                    if ( NameFinished ) {
                        continue;
                    }

                    if (NameChar == '.') {
                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {
                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == '?') {
                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Check if the expression char matches the name char
                //

                if ( !NameFinished && ExprChar == NameChar ) {
                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            } // while() that tries to use up expression chars


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) && (PreviousDestCount < DestCount) ) {
                while (PreviousDestCount < DestCount) {
                    if ( PreviousMatches[SrcCount] < CurrentMatches[PreviousDestCount] ) {
                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        } // while() that uses up name chars

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {
            if (AuxBuffer != NULL) {
                FREE_MEMORY(AuxBuffer);
            }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) {
        FREE_MEMORY(AuxBuffer);
    }


    return (BOOLEAN)(CurrentState == MaxState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\nvt.h ===
#ifndef _NVT_H_INCLUDED_
#define _NVT_H_INCLUDED_

#define NVT_IAC_STRING "\377"
#define NVT_INTERRUPT_PROCESS_STRING "\377\364"
#define NVT_DATA_MARK_STRING "\377\362"

#endif // _NVT_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\protocol.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    protocol.cxx

Abstract:

    Contains functions to negotiate data connections with, send commands to and
    receive data from, the FTP server

    Contents:
        Command
        I_Command
        NegotiateDataConnection
        GetReply
        ReceiveFtpResponse
        AbortTransfer
        (SendCommand)
        (I_SendCommand)
        (I_AttemptDataNegotiation)
        (I_NegotiateDataConnection)

Author:

    Heath Hunnicutt (t-hheath) 21-Jun-1994

Environment:

    Win32 user-level DLL

Revision History:

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// private prototypes
//

PRIVATE
DWORD
__cdecl
SendCommand(
    IN ICSocket * s,
    IN LPCSTR lpszFormat,
    IN ...
    );

PRIVATE
DWORD
I_SendCommand(
    IN ICSocket * s,
    IN LPCSTR lpszFormat,
    va_list arglist
    );

PRIVATE
DWORD
I_AttemptDataNegotiation(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist
    );

PRIVATE
DWORD
I_NegotiateDataConnection(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist,
    IN BOOL bOverridePassive
    );

//
// functions
//


DWORD
Command(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN ...
    )

/*++

Routine Description:

    Sends a command to the FTP server on the control connection and optionally
    sets up a data connection. Wrapper for I_Command()

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing FTP server and
                          our connection to it

    fExpectResponse     - TRUE if we need a data connection

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to response code returned from server

    lpszCommandFormat   - pointer to command string

    ...                 - optional arguments for command string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "Command",
                "%#x, %B, %#x, %#x, %q",
                lpSessionInfo,
                fExpectResponse,
                dwFlags,
                prcResponse,
                lpszCommandFormat
                ));

    DWORD error;
    va_list arglist;

    va_start(arglist, lpszCommandFormat);

    error = I_Command(lpSessionInfo,
                      fExpectResponse,
                      dwFlags,
                      prcResponse,
                      lpszCommandFormat,
                      arglist
                      );

    va_end(arglist);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
I_Command(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist
    )

/*++

Routine Description:

    Sends a command to the FTP server, and if requested, negotiates a data
    connection

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing the FTP server
                          and our connection to it

    fExpectResponse     - TRUE if we need a data connection

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to returned server response

    lpszCommandFormat   - command to send to server

    arglist             - optional arguments for lpszCommandFormat

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "I_Command",
                "%#x, %B, %#x, %#x, %q, %#x",
                lpSessionInfo,
                fExpectResponse,
                dwFlags,
                prcResponse,
                lpszCommandFormat,
                arglist
                ));

    DWORD error;

    INET_ASSERT(lpSessionInfo != NULL);
    INET_ASSERT(prcResponse != NULL);
    INET_ASSERT(lpszCommandFormat != NULL);
    INET_ASSERT(   ((dwFlags & FTP_TRANSFER_TYPE_MASK) == FTP_TRANSFER_TYPE_UNKNOWN)
                || ((dwFlags & FTP_TRANSFER_TYPE_MASK) == FTP_TRANSFER_TYPE_ASCII)
                || ((dwFlags & FTP_TRANSFER_TYPE_MASK) == FTP_TRANSFER_TYPE_BINARY)
                );

    //
    // if the control socket is not valid, return "connection dropped"
    //

    if (!lpSessionInfo->socketControl->IsValid()) {
        error = ERROR_FTP_DROPPED;
        goto quit;
    }

    //
    // there can only be one data connection established for each FTP session
    //

    if (lpSessionInfo->socketData->IsValid()) {
        error = ERROR_FTP_TRANSFER_IN_PROGRESS;
        goto quit;
    }

    //
    // if we need a data connection then send the connection set-up commands
    // and issue the command
    //

    if (fExpectResponse) {
        error = I_AttemptDataNegotiation(lpSessionInfo,
                                         dwFlags,
                                         prcResponse,
                                         lpszCommandFormat,
                                         arglist
                                         );
        if (error == ERROR_SUCCESS) {

            //
            // check the server response for failure
            //

            if ((prcResponse->Major != FTP_RESPONSE_PRELIMINARY)
            && (prcResponse->Major != FTP_RESPONSE_COMPLETE)) {
                error = ERROR_INTERNET_EXTENDED_ERROR;
            }
        }
    } else {

        //
        // no data connection required, just send the command and check any
        // response from the server for a failure indication
        //

        error = I_SendCommand(lpSessionInfo->socketControl,
                              lpszCommandFormat,
                              arglist
                              );
        if (error == ERROR_SUCCESS) {
            error = GetReply(lpSessionInfo, prcResponse);
            if (error == ERROR_SUCCESS) {
                if ((prcResponse->Major != FTP_RESPONSE_COMPLETE)
                && (prcResponse->Major != FTP_RESPONSE_CONTINUE)
                && (prcResponse->Major != FTP_RESPONSE_PRELIMINARY)) {
                    error = ERROR_INTERNET_EXTENDED_ERROR;
                }
            }
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
NegotiateDataConnection(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN ...
    )

/*++

Routine Description:

    Sets up a data connection between this client and the FTP server. Wrapper
    for I_AttemptDataNegotiation()

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing the FTP server
                          and our connection to it

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to returned server response code

    lpszCommandFormat   - command string to send

    ...                 - optional arguments for lpszCommandFormat

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    error returned by Windows sockets

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "NegotiateDataConnection",
                "%#x, %#x, %#x, %q",
                lpSessionInfo,
                dwFlags,
                prcResponse,
                lpszCommandFormat
                ));

    va_list arglist;

    va_start(arglist, lpszCommandFormat);

    DWORD error = I_AttemptDataNegotiation(lpSessionInfo,
                                           dwFlags,
                                           prcResponse,
                                           lpszCommandFormat,
                                           arglist
                                           );

    va_end(arglist);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
GetReply(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    OUT FTP_RESPONSE_CODE *prcResponse
    )

/*++

Routine Description:

    Gets the response code from the server. The response text is stored in the
    per-thread last response text field, and the FTP response code is parsed
    off the start of the text and returned in prcResponse

Arguments:

    lpSessionInfo   - pointer to FTP_SESSION_INFO for which to get response text

    prcResponse     - pointer to the response code structure

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "GetReply",
                "%#x, %#x",
                lpSessionInfo,
                prcResponse
                ));

    PCHAR pchReplyBuffer;
    DWORD cchBufferLength;
    DWORD error;

    INET_ASSERT(prcResponse != NULL);

    //
    // set up a default error code
    //

    prcResponse->Major = FTP_RESPONSE_PERMANENT_FAILURE;
    prcResponse->Minor = 0;
    prcResponse->Detail = 0;
    prcResponse->Status = 0;

    pchReplyBuffer = NULL;

    //
    // receive the last response on the control socket
    //

    error = ReceiveFtpResponse(lpSessionInfo->socketControl,
                               (LPVOID *)&pchReplyBuffer,
                               &cchBufferLength,
                               TRUE,
                               prcResponse
                               );
    if (error == ERROR_SUCCESS) {

        INET_ASSERT(pchReplyBuffer != NULL);

        //
        // append this response text to that already stored in this thread's
        // data object
        //

        InternetSetLastError(0,
                             pchReplyBuffer,
                             cchBufferLength,
                             SLE_APPEND | SLE_ZERO_TERMINATE
                             );

        //
        // extract status code
        //

        LPSTR lpszError = pchReplyBuffer;

        ExtractInt(&lpszError, 0, &prcResponse->Status);

        DEBUG_PRINT(PROTOCOL, INFO, ("FTP status = %d\n", prcResponse->Status));

    } else {

        INET_ASSERT(pchReplyBuffer == NULL);

    }

    //
    // finished with the buffer
    //

    if (pchReplyBuffer != NULL) {
        pchReplyBuffer = (PCHAR)FREE_MEMORY((HLOCAL)pchReplyBuffer);

        INET_ASSERT(pchReplyBuffer == NULL);

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReceiveFtpResponse(
    IN ICSocket * Socket,
    OUT LPVOID * lpBuffer,
    OUT LPDWORD lpdwBufferLength,
    IN BOOL fEndOfLineCheck,
    IN FTP_RESPONSE_CODE * prcResponse
    )

/*++

Routine Description:

    Receives data from the FTP server. Optionally parses it for end-of-line
    sequence

    This function is typically going to receive one or more lines of response
    data, i.e. a small amount of data. Also typically, we will not normally
    expect to get EOF(connection) because we are usually reading the control
    connection

Arguments:

    Socket              - socket on which to receive data

    lpBuffer            - pointer to pointer to returned data buffer

    lpdwBufferLength    - pointer to returned length of (returned) data buffer

    fEndOfLineCheck     - TRUE if we are to perform an end-of-line check

    prcResponse         - pointer to returned server response code

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "ReceiveFtpResponse",
                "%#x, %#x, %#x, %B, %#x",
                Socket,
                lpBuffer,
                lpdwBufferLength,
                fEndOfLineCheck,
                prcResponse
                ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT(lpdwBufferLength != NULL);

    if (fEndOfLineCheck) {

        INET_ASSERT(prcResponse != NULL);

    }

    LPSTR pchBuffer;
    DWORD bufferLength;
    DWORD bufferLeft;
    DWORD bytesReceived;
    int idxPosInLine;
    BOOL fLastLineDigitsSeen;
    BOOL fAtEOL;
    int nNumericReply;
    DWORD error;

    //
    // initialize variables (for SocketReceive())
    //

    pchBuffer = NULL;
    bufferLength = 0;
    bufferLeft = 0;
    bytesReceived = 0;

    //
    // get per-thread info block to determine blocking/non-blocking socket calls
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //DWORD asyncFlags;
    //
    //asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // this flag is set to FALSE once the digits are definitely NOT seen, and
    // needs to be TRUE at the start of each new line
    //

    fLastLineDigitsSeen = TRUE;
    nNumericReply = 0;
    idxPosInLine = 0;
    fAtEOL = FALSE;

    BOOL eofData;

    while (TRUE) {

        //
        // get the next chunk of response data from the server. Since we are
        // expecting a response (i.e. small amount of data (< 1K)) we shouldn't
        // have to do this too many times
        //

        error = Socket->Receive(
                              (LPVOID *)&pchBuffer,
                              &bufferLength,
                              &bufferLeft,
                              &bytesReceived,
                              sizeof('\0'),     // dwExtraSpace
                              SF_EXPAND         // SocketReceive will allocate/grow the buffer
                              | SF_COMPRESS     //  and compress any unused space at EOF
                              | SF_INDICATE,     //  and make indications to app
                              &eofData
                              );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // if we have hit the end of the data then zero-terminate the buffer
        //

        if (eofData) {

            INET_ASSERT(bufferLeft > 0);

            pchBuffer[bytesReceived] = '\0';
        }

        //
        // if requested, find out if we got the end-of-line (on the last line)
        //

        if (fEndOfLineCheck) {

            //
            // look for the final line of the response
            //

            for (DWORD bytesChecked = 0;
                bytesChecked < bytesReceived;
                ++bytesChecked, ++idxPosInLine) {

                //
                // ISSUE: fAtEOL && fLastLineDigitsSeen ==> protocol error,
                // since there is data after the response line
                //

                //
                // if the previous character was an EOL, then the next one must
                // be the start of the next line. Reinitialize the response-
                // decoding state
                //

                if (fAtEOL) {
                    fLastLineDigitsSeen = TRUE;
                    nNumericReply = 0;
                    idxPosInLine = 0;
                    fAtEOL = FALSE;
                }

                //
                // if (so far) this line has been of the form we expect for a
                // response last-line, check the chars we just received to see
                // if it maintains that form
                //
                // since this form is completely determined by the first four
                // characters of the line, limit the checking to those chars
                //

                if (fLastLineDigitsSeen && (idxPosInLine < 4)) {
                    if (idxPosInLine < 3) {

                        //
                        // if one of the first three chars is not a digit, mark
                        // this line as a non-response
                        //

                        if (!isdigit(pchBuffer[bytesChecked])) {
                            fLastLineDigitsSeen = FALSE;
                        } else {

                            //
                            // store the numeric reply in an int
                            //

                            nNumericReply *= 10;
                            nNumericReply += (int)(pchBuffer[bytesChecked] - '0');
                        }
                    } else if (idxPosInLine == 3) {

                        //
                        // the first three chars must be digits.  If the fourth is a
                        // space, then this line has the right form
                        //

                        if (pchBuffer[bytesChecked] != ' ') {
                            fLastLineDigitsSeen = FALSE;
                        }
                    }
                }

                //
                // if at the end of a line, reset vars for the next line
                //

                if (pchBuffer[bytesChecked] == '\n') {

                    DEBUG_PRINT(PROTOCOL,
                                INFO,
                                ("At EOL, and fDigits = %B\n",
                                fLastLineDigitsSeen
                                ));

                    fAtEOL = TRUE;
                }
            }
        }

        //
        // if this data is expected to end in a proper response line, and that
        // line has been received, stop receiving more data
        //

        if (fEndOfLineCheck && fLastLineDigitsSeen && fAtEOL) {

            //
            // we found the end of the response, although we may not have
            // received an EOF(transmission) indication, because the server
            // didn't close the connection. Zero terminate the buffer
            //

            INET_ASSERT(bufferLeft > 0);

            pchBuffer[bytesReceived] = '\0';

            //
            // tear the numeric reply up by digit, placing it into our nicer
            // reply structure
            //

            INET_ASSERT(nNumericReply >= 0);
            INET_ASSERT(nNumericReply < 1000);

            prcResponse->Major = (nNumericReply / 100) % 10;
            prcResponse->Minor = (nNumericReply / 10) % 10;
            prcResponse->Detail = (nNumericReply) % 10;
            error = ERROR_SUCCESS;
            goto done;
        }

        //
        // if we were receiving data that was supposed to end in an EOL then this
        // is an error condition. Otherwise, it is the expected way to signal the
        // end of transmission
        //

        if (eofData) {
            if (fEndOfLineCheck) {
                error = ERROR_FTP_DROPPED;
                goto quit;
            } else {

                //
                // caller just receiving data. We're done
                //

                error = ERROR_SUCCESS;
                goto done;
            }
        }
    }

    INET_ASSERT(FALSE);

quit:

    INET_ASSERT(error != ERROR_SUCCESS);

    if (pchBuffer != NULL) {
        pchBuffer = (LPSTR)FREE_MEMORY((HLOCAL)pchBuffer);

        INET_ASSERT(pchBuffer == NULL);

    }

done:

    *lpBuffer = pchBuffer;
    *lpdwBufferLength = bytesReceived;

    INET_ASSERT((pchBuffer != NULL) ? (*(LPDWORD)pchBuffer != 0xc5c5c5c5) : TRUE);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
AbortTransfer(
    IN LPFTP_SESSION_INFO lpSessionInfo
    )

/*++

Routine Description:

    Aborts an ongoing transfer. Typically used to terminate a read file
    operation early. We don't expect a response from the server in this case

Arguments:

    lpSessionInfo   - pointer to FTP_SESSION_INFO containing context for sesion
                      to abort

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_EXTENDED_ERROR

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "AbortTransfer",
                "%#x",
                lpSessionInfo
                ));

    //
    // get per-thread info block to determine blocking/non-blocking socket calls
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //DWORD asyncFlags;
    //
    //asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // send an ABORT preceded by the following NVT/Telnet sequences:
    //
    //  FF F4 = Interrupt Process (IP)
    //  FF F2 = Data Mark (DM)
    //

#define ABORT_COMMAND NVT_INTERRUPT_PROCESS_STRING  \
                      NVT_DATA_MARK_STRING          \
                      "ABOR"                        \
                      "\r\n"

    //
    // BUGBUG - the IP/DM sequence should be sent as URGENT data
    //

    error = lpSessionInfo->socketControl->Send((LPBYTE)ABORT_COMMAND,
                                               sizeof(ABORT_COMMAND) - 1,
                                               SF_INDICATE
                                               );

quit:

    DEBUG_LEAVE(error);

    return error;
}

//
// private functions
//


PRIVATE
DWORD
__cdecl
SendCommand(
    IN ICSocket * Socket,
    IN LPCSTR lpszFormat,
    IN ...
    )

/*++

Routine Description:

    Sends a command string to the FTP server. Wrapper for I_SendCommand()

Arguments:

    Socket      - socket to send data on

    lpszFormat  - printf-style format string

    ...         - arguments for lpszFormat

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "SendCommand",
                "%#x, %q",
                Socket,
                lpszFormat
                ));

    va_list arglist;
    DWORD error;

    va_start(arglist, lpszFormat);

    error = I_SendCommand(Socket,
                          lpszFormat,
                          arglist
                          );

    va_end(arglist);

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
I_SendCommand(
    IN ICSocket * Socket,
    IN LPCSTR lpszFormat,
    va_list arglist
    )

/*++

Routine Description:

    Sends a command string to a server

Arguments:

    Socket      - socket to send command on

    lpszFormat  - printf-style format string for command

    arglist     - variable list of arguments for format string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    error returned from Windows Sockets

                  ERROR_INTERNET_INTERNAL_ERROR
                    The string was too large to fit into our stack buffer

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "I_SendCommand",
                "%#x, %q, %#x",
                Socket,
                lpszFormat,
                arglist
                ));

#define I_SEND_COMMAND_BUFFER_LENGTH    2048    // Arbitrary (but large)

    //
    // get per-thread info block to determine blocking/non-blocking socket calls
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // we need a buffer large enough to be able to handle the longest path plus
    // the command overhead. Typically, we will only be getting short strings
    // (USER, PORT, etc.)
    //

    //
    // BUGBUG
    // use _vsnprintf() to create the buffer - this allows us to specify the
    // maximum offset in the buffer, so avoiding a stack crash but this
    // brings in the cruntimes which we don't want to do.
    //

    CHAR buf[I_SEND_COMMAND_BUFFER_LENGTH];

    {
        int numChars = wvnsprintf(buf, I_SEND_COMMAND_BUFFER_LENGTH, lpszFormat, arglist);

        INET_ASSERT(numChars <= I_SEND_COMMAND_BUFFER_LENGTH - 2);
        INET_ASSERT(numChars > 0);

        if (numChars <= I_SEND_COMMAND_BUFFER_LENGTH - 2) {

            //
            // append trailing "\r\n"
            //

            buf[numChars++] = '\r';
            buf[numChars++] = '\n';

            error = Socket->Send((LPVOID)buf, numChars, SF_INDICATE);
        } else {

            DEBUG_PRINT(PROTOCOL,
                        ERROR,
                        ("%d chars blows internal buffer limit (%d chars)\n",
                        numChars,
                        I_SEND_COMMAND_BUFFER_LENGTH
                        ));

            error = ERROR_INVALID_PARAMETER;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
I_AttemptDataNegotiation(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist
    )

/*++

Routine Description:

    Attempts to generate a data connection with server. If passive mode is
    selected & passive mode fails, then we back-down to non-passive

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing server to
                          connect to

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to response code variable

    lpszCommandFormat   - command to send

    arglist             - any arguments for command

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - same as I_NegotiateDataConnection

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "I_AttemptDataNegotiation",
                "%#x, %#x, %#x, %q, %#x",
                lpSessionInfo,
                dwFlags,
                prcResponse,
                lpszCommandFormat,
                arglist
                ));

    //
    // first try it without overriding passive mode
    //

    DWORD error = I_NegotiateDataConnection(lpSessionInfo,
                                            dwFlags,
                                            prcResponse,
                                            lpszCommandFormat,
                                            arglist,
                                            FALSE
                                            );

    //
    // if the negotiation failed because passive mode wasn't supported or not
    // allowed then try non-passive (if ok to do so)
    //

    if (error == ERROR_FTP_NO_PASSIVE_MODE) {

        INET_ASSERT(IsPassiveModeSession(lpSessionInfo));

        error = I_NegotiateDataConnection(lpSessionInfo,
                                          dwFlags,
                                          prcResponse,
                                          lpszCommandFormat,
                                          arglist,
                                          TRUE  // no passive mode this time
                                          );
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
I_NegotiateDataConnection(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist,
    IN BOOL bOverridePassive
    )

/*++

Routine Description:

    Sends a command to the FTP server and opens a data channel

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing server to
                          connect to

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to response code variable

    lpszCommandFormat   - command to send

    arglist             - any arguments for command

    bOverridePassive    - TRUE if OK to override passive mode (set at connect
                          level)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "I_NegotiateDataConnection",
                "%#x, %#x, %#x, %q, %#x, %B",
                lpSessionInfo,
                dwFlags,
                prcResponse,
                lpszCommandFormat,
                arglist,
                bOverridePassive
                ));

    PUCHAR puchAddr;
    PCHAR pch;

    ICSocket * socketControl;
    ICSocket * socketData ;
    ICSocket * socketListener ;
    DWORD error;
    int serr;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL isAsync;
    BOOL bPassiveMode = FALSE;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    isAsync = lpThreadInfo->IsAsyncWorkerThread;

//Command(lpSessionInfo,
//        FALSE,
//        FTP_TRANSFER_TYPE_UNKNOWN,
//        prcResponse,
//        "MODE B"
////        "MODE S"
//        );

    //
    // tell the server the type of transfer we want - ASCII ('A') or Binary ('I')
    //

    error = Command(lpSessionInfo,
                    FALSE,
                    FTP_TRANSFER_TYPE_UNKNOWN,
                    prcResponse,
                    "TYPE %s",
                    ((dwFlags & FTP_TRANSFER_TYPE_MASK)
                        == FTP_TRANSFER_TYPE_ASCII) ? "A" : "I"
                    );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (prcResponse->Major != FTP_RESPONSE_COMPLETE) {
        error = ERROR_INTERNET_EXTENDED_ERROR;
        goto quit;
    }

    socketControl = lpSessionInfo->socketControl;
    socketData = lpSessionInfo->socketData;
    socketListener = lpSessionInfo->socketListener;

    INET_ASSERT(!socketData->IsValid());
    INET_ASSERT(!socketListener->IsValid());

    //
    // Get the address of our control socket.  We need to know what address
    // family (IPv4 or IPv6) to use for our data connection.  And in the
    // active case, we need to provide this address to the server.
    //

    SOCKADDR_STORAGE ourCtrlAddr;
    error = socketControl->GetSockName((LPSOCKADDR)&ourCtrlAddr,
                                       sizeof(ourCtrlAddr));
    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // we make passive connection if passive mode was specified in
    // InternetConnect() AND we are not overriding it
    //

    bPassiveMode = IsPassiveModeSession(lpSessionInfo) && !bOverridePassive;

    //
    // make the required type of data connection
    //

    if (!bPassiveMode) {

        SOCKADDR_STORAGE ourDataAddr;
        int cbAddrLen;

        //
        // standard (non-passive (ACTIVE?)) transfers. We create a socket and
        // tell the server which socket to connect to. The server then initiates
        // the connection with this client
        //

        error = socketListener->CreateSocket(0, ourCtrlAddr.ss_family,
                                             SOCK_STREAM, IPPROTO_TCP);
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

#if INET_DEBUG
        socketListener->SetSourcePort();
#endif

        error = socketListener->Listen();
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Now tell the server what address and port number it should use to
        // connect to us.  The address is the local side of our control
        // connection, and the port number is that of the listening socket.
        //

        error = socketListener->GetSockName((LPSOCKADDR)&ourDataAddr,
                                            sizeof(ourDataAddr));
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // BUGBUG - using (global) winsock ntohs() (i.e. not SOCKS)
        //

        u_short port;

        if (ourCtrlAddr.ss_family == AF_INET) {
            //
            // Legacy IPv4.  The PORT command consists of our IP address
            // formatted as 4 decimal numbers (one per byte) followed by
            // the port number as 2 decimals numbers (one per byte).
            // Byte order is big-endian.
            //
            // REVIEW: RFC 2428 describes the EPRT command, which is
            // intended to replace the PORT command.  Should we try it
            // first?  At the moment, we only attempt EPRT over IPv6.
            //
            port = _I_ntohs(((LPSOCKADDR_IN)&ourDataAddr)->sin_port);
            puchAddr = (PUCHAR)&((LPSOCKADDR_IN)&ourCtrlAddr)->sin_addr;
            error = SendCommand(socketControl,
                                "PORT %d,%d,%d,%d,%d,%d",
                                puchAddr[0],
                                puchAddr[1],
                                puchAddr[2],
                                puchAddr[3],
                                HIBYTE(port),
                                LOBYTE(port)
                );
        } else {
            //
            // IPv6.  The EPRT command is defined in RFC 2428, and has the
            // following format:
            //     EPRT<space><d><address-family><d><address><d><port><d>
            // where <d> is a delimiter character ('|' recommended),
            // <address-family> is an IANA defined number (1=IPv4, 2=IPv6),
            // <address> is the IP address in common string notation,
            // <port> is the port number in common string notation.
            //
#define MAX_IPV6_ADDR_LIT_LEN (sizeof("1111:2222:3333:4444:5555:6666:255.255.255.255%4294967295"))
            char Address[MAX_IPV6_ADDR_LIT_LEN];
            error = _I_getnameinfo((LPSOCKADDR)&ourCtrlAddr,
                                   sizeof(SOCKADDR_IN6), Address,
                                   sizeof(Address), NULL, 0, NI_NUMERICHOST);
            if (error) {
                goto error_exit;
            }
            port = _I_ntohs(((LPSOCKADDR_IN6)&ourDataAddr)->sin6_port);
            error = SendCommand(socketControl, "EPRT |2|%s|%u", Address, port);
        }
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // read the response from the server. We are expecting something along
        // the lines: "200 PORT Command Successful"
        //

        error = GetReply(lpSessionInfo, prcResponse);
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }
        if (prcResponse->Major != FTP_RESPONSE_COMPLETE) {

            //
            // Some IPv6 servers use LPRT instead of EPRT.  So we try that.
            // REVIEW: If we change the IPv4 case above to try EPRT first
            // (see REVIEW comment above) then we'd try PORT here for IPv4.
            //

            if ((ourCtrlAddr.ss_family == AF_INET6) &&
                (prcResponse->Status == FTP_RESPONSE_CMD_NOT_IMPL) ||
                (prcResponse->Status == FTP_RESPONSE_CMD_SYNTAX_ERROR)) {

                error = SendCommand(socketControl,
                                    "LPRT 6,16,%u,%u,%u,%u,"
                                    "%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,"
                                    "2,%u,%u",
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[0],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[1],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[2],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[3],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[4],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[5],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[6],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[7],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[8],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[9],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[10],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[11],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[12],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[13],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[14],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[15],
                                    HIBYTE(port), LOBYTE(port)
                                    );
                if (error != ERROR_SUCCESS) {
                    goto error_exit;
                }

                error = GetReply(lpSessionInfo, prcResponse);
                if (error != ERROR_SUCCESS) {
                    goto error_exit;
                }

                if (prcResponse->Major == FTP_RESPONSE_COMPLETE)
                    goto GotActiveReply;
            }

            error = ERROR_INTERNET_EXTENDED_ERROR;
            goto error_exit;
        }
    } else {

        PCHAR pchTemp;

        //
        // PASSIVE mode. Due to problems with firewalls not allowing incoming
        // connection requests, we have to ask the server to create a new socket
        // which we then connect to. This is the inverse of the non-PASV connect
        // case above
        //

        error = socketData->CreateSocket(0, ourCtrlAddr.ss_family,
                                         SOCK_STREAM, IPPROTO_TCP);
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // send the PASV request to the server
        //

        if (ourCtrlAddr.ss_family == AF_INET) {
            // REVIEW: Attempt EPSV first for IPv4 as well?
            error = SendCommand(socketControl, "PASV");
        } else {
            error = SendCommand(socketControl, "EPSV");
        }
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Read the response.  For the "PASV" command, we are expecting it
        // to return the full address information for the port in the form
        //     "227 (h1,h2,h3,h4,p1,p2)"
        // meaning that the server is entering PASSIVE mode (227), and the
        // IP address and socket to connect to being h1.h2.h3.h4, p1p2.
        //
        // For the "EPSV" command, we are expecting a response of the form
        //     "229 (<d><d><d><port><d>)"
        // meaning that the server is entering PASSIVE mode (229), the
        // IP address to connect to is that of the control connection, and
        // the port number to connect to is given by <port>.
        //

        error = GetReply(lpSessionInfo, prcResponse);
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }
        if (prcResponse->Major != FTP_RESPONSE_COMPLETE) {

            //
            // Some IPv6 servers use LPSV instead of EPSV.
            // The wonderful thing about standards is that
            // there are so many to choose from.
            //
            if ((ourCtrlAddr.ss_family == AF_INET6) &&
                ((prcResponse->Status == FTP_RESPONSE_CMD_NOT_IMPL) ||
                 (prcResponse->Status == FTP_RESPONSE_CMD_SYNTAX_ERROR))) {

                error = SendCommand(socketControl, "LPSV");
                if (error != ERROR_SUCCESS) {
                    goto error_exit;
                }

                error = GetReply(lpSessionInfo, prcResponse);
                if (error != ERROR_SUCCESS) {
                    goto error_exit;
                }

                if (prcResponse->Major == FTP_RESPONSE_COMPLETE)
                    goto GotPassiveReply;
            }

            //
            // If we get 500 or 502 (command not implemented), 425
            // (can't open data connection), or 530 (not logged in)
            // then return ERROR_FTP_NO_PASSIVE_MODE, else
            // ERROR_INTERNET_EXTENDED_ERROR.
            //

            if ((prcResponse->Status == FTP_RESPONSE_CANT_OPEN_DATA)
            ||  (prcResponse->Status == FTP_RESPONSE_CMD_NOT_IMPL)
            ||  (prcResponse->Status == FTP_RESPONSE_CMD_SYNTAX_ERROR)
            ||  (prcResponse->Status == FTP_RESPONSE_NOT_LOGGED_IN)) {
                error = ERROR_FTP_NO_PASSIVE_MODE;
            } else {
                error = ERROR_INTERNET_EXTENDED_ERROR;
            }
            goto error_exit;
        }

      GotPassiveReply:

        //
        // parse the endpoint out of the server response (stored in the per-
        // thread last response info buffer).
        //
        // If we fail to lock the response text, then that's an internal error.
        // If we fail to parse the required information out of the response text
        // then we return an extended error indication, since presumably the
        // server sent response text, but not what we were expecting
        //

        pch = (PCHAR)InternetLockErrorText();
        if (pch != NULL) {
            if (ourCtrlAddr.ss_family == AF_INET) {
                //
                // Parse respone to PASV command.
                //
                pch = strstr(pch, "227 ");
                if (pch != NULL) {
                    pch += sizeof("227 ") - 1;
                    while (!isdigit(*pch) && *pch) {
                        ++pch;
                    }
                    if (isdigit(*pch)) {

                        int i;
                        DWORD octets[6];

                        //
                        // parse the individual address parts out of the response
                        //

                        for (i = 0; (i < ARRAY_ELEMENTS(octets)) && isdigit(*pch); ++i) {
                            if (!ExtractInt(&pch, 0, (LPINT)&octets[i])) {
                                break;
                            }
                            if (octets[i] > 255) {
                                break;
                            }
                            if (i < ARRAY_ELEMENTS(octets) - 1) {
                                while (!isdigit(*pch) && *pch) {
                                    ++pch;
                                }
                            }
                        }

                        //
                        // if we successfully parsed the server's address info then
                        // try to connect with the address it sent us
                        //

                        if ((i == ARRAY_ELEMENTS(octets)) && (octets[i - 1] <= 255)) {

                            SOCKADDR_IN remoteSockaddr;

                            memset(&remoteSockaddr, 0, sizeof(remoteSockaddr));
                            remoteSockaddr.sin_family = AF_INET;

                            //
                            // N.B. Using (global) winsock ntohs() (i.e. not SOCKS)
                            //

                            remoteSockaddr.sin_port = _I_htons(
                                (USHORT)((octets[4] << 8)
                                         | (USHORT)octets[5]));
                            puchAddr = (PUCHAR)&remoteSockaddr.sin_addr;
                            puchAddr[0] = (UCHAR)octets[0];
                            puchAddr[1] = (UCHAR)octets[1];
                            puchAddr[2] = (UCHAR)octets[2];
                            puchAddr[3] = (UCHAR)octets[3];
                            error = socketData->DirectConnect(
                                (LPSOCKADDR)&remoteSockaddr);
                        } else {

                            DEBUG_PRINT(PROTOCOL,
                                        ERROR,
                                        ("failed to parse 6 address elements\n"
                                        ));

                            error = ERROR_INTERNET_EXTENDED_ERROR;
                        }
                    } else {

                        DEBUG_PRINT(PROTOCOL,
                                    ERROR,
                                    ("failed to locate start of address info in response text\n"
                                    ));

                        error = ERROR_INTERNET_EXTENDED_ERROR;
                    }
                } else {

                    DEBUG_PRINT(PROTOCOL,
                                ERROR,
                                ("failed to locate \"227\" in response text\n"
                                ));

                    error = ERROR_INTERNET_EXTENDED_ERROR;
                }
            } else {
                CHAR delim;
                //
                // Parse respone to EPSV or LPSV command.
                //
                pchTemp = strstr(pch, "229 ");
                if (pchTemp != NULL) {
                    pch = pchTemp + sizeof("229 ") - 1;
                    while ((*pch != '(') && (*pch != '\0')) {
                        ++pch;
                    }
                    if ((pch[0] == '(') &&
                        ((delim = pch[1]) != '\0') &&
                        (pch[2] == delim) &&
                        (pch[3] == delim)) {

                        DWORD port;

                        //
                        // parse the port out of the response
                        //
                        pch += 4;
                        if (ExtractInt(&pch, 0, (LPINT)&port)) {

                            //
                            // if we successfully parsed the port then
                            // try to connect with it
                            //

                            SOCKADDR_IN6 remoteSockaddr;

                            error = socketControl->GetPeerName(
                                (LPSOCKADDR)&remoteSockaddr,
                                sizeof(SOCKADDR_IN6));

                            if (error == ERROR_SUCCESS) {
                                //
                                // N.B. Using (global) winsock ntohs()
                                // (i.e. not SOCKS)
                                //
                                remoteSockaddr.sin6_port =
                                    _I_htons((USHORT)port);
                                error = socketData->DirectConnect(
                                    (LPSOCKADDR)&remoteSockaddr);
                            }
                        } else {
                            DEBUG_PRINT(PROTOCOL,
                                        ERROR,
                                        ("failed to parse port\n"
                                        ));

                            error = ERROR_INTERNET_EXTENDED_ERROR;
                        }
                    } else {

                        DEBUG_PRINT(PROTOCOL,
                                    ERROR,
                                    ("failed to locate start of address info in response text\n"
                                    ));

                        error = ERROR_INTERNET_EXTENDED_ERROR;
                    }
                } else if ((pchTemp = strstr(pch, "228 ")) != NULL) {
                    pch = pchTemp + sizeof("228 ") - 1;
                    while (!isdigit(*pch) && *pch) {
                        ++pch;
                    }
                    if (isdigit(*pch)) {

                        int i;
                        DWORD octets[21];

                        //
                        // Parse the individual address parts out of
                        // the response.
                        //

                        for (i = 0; (i < ARRAY_ELEMENTS(octets)) && isdigit(*pch); ++i) {
                            if (!ExtractInt(&pch, 0, (LPINT)&octets[i])) {
                                break;
                            }
                            if (octets[i] > 255) {
                                break;
                            }
                            if (i < ARRAY_ELEMENTS(octets) - 1) {
                                while (!isdigit(*pch) && *pch) {
                                    ++pch;
                                }
                            }
                        }

                        //
                        // If we successfully parsed the server's address info
                        // then try to connect with the address it sent us.
                        //

                        if ((i == ARRAY_ELEMENTS(octets)) &&
                            (octets[i - 1] <= 255) &&
                            (octets[0] == 6) &&
                            (octets[1] == 16) &&
                            (octets[18] == 2)) {

                            SOCKADDR_IN6 remoteSockaddr;

                            memset(&remoteSockaddr, 0, sizeof remoteSockaddr);
                            remoteSockaddr.sin6_family = AF_INET6;

                            //
                            // N.B. Using (global) winsock ntohs()
                            // (i.e. not SOCKS)
                            //

                            remoteSockaddr.sin6_port = _I_htons(
                                (USHORT)((octets[19] << 8)
                                         | (USHORT)octets[20]));
                            for (i = 0; i < 16; i++)
                                remoteSockaddr.sin6_addr.s6_addr[i] = (UCHAR)octets[i + 2];

                            error = socketData->DirectConnect(
                                (LPSOCKADDR)&remoteSockaddr);
                        } else {

                            DEBUG_PRINT(PROTOCOL,
                                        ERROR,
                                        ("failed to parse 20 address elements\n"
                                        ));

                            error = ERROR_INTERNET_EXTENDED_ERROR;
                        }
                    } else {

                        DEBUG_PRINT(PROTOCOL,
                                    ERROR,
                                    ("failed to locate start of address info in response text\n"
                                    ));

                        error = ERROR_INTERNET_EXTENDED_ERROR;
                    }
                } else {

                    DEBUG_PRINT(PROTOCOL,
                                ERROR,
                                ("failed to locate \"229\" or \"228\" in response text\n"
                                ));

                    error = ERROR_INTERNET_EXTENDED_ERROR;
                }
            }

            //
            // unlock the response text
            //

            //InternetUnlockErrorText();
        } else {

            DEBUG_PRINT(PROTOCOL,
                        ERROR,
                        ("failed to lock last response text\n"
                        ));

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }

        //
        // bail out if we met with any errors
        //

        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

  GotActiveReply:

    //
    // issue SIZE command to get file size
    //
    if(StrCmpNI(lpszCommandFormat, "RETR", 4) == 0) {   // If we're downloading a file
        error = I_SendCommand(socketControl,
                              "SIZE %s",
                              arglist
                              );
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        error = GetReply(lpSessionInfo, prcResponse);
        if (error != ERROR_SUCCESS) {
            if (socketData->IsValid()) {
                ResetSocket(socketData);
            }
            goto error_exit;
        }

        if (prcResponse->Major == FTP_RESPONSE_COMPLETE) {
            pch = (PCHAR)InternetLockErrorText();
            if (pch != NULL) {
                pch = strstr(pch, "213 ");
                if (pch != NULL) {

                    pch += sizeof("213 ") - 1;
                    if ( pch )
                    {
                        if (*pch && isdigit(*pch)) {
                            if (ExtractInt(&pch, 0, (int *) &(lpSessionInfo->dwFileSizeLow))) {
                                lpSessionInfo->Flags |= FFTP_KNOWN_FILE_SIZE;
                            }
                        }
                    }

                }
            }
        }
    }

    //
    // we have the data connection, send the command
    //

    error = I_SendCommand(socketControl,
                          lpszCommandFormat,
                          arglist
                          );
    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // get the preliminary reply from the FTP server
    //

    error = GetReply(lpSessionInfo, prcResponse);
    if (error != ERROR_SUCCESS) {
        if (socketData->IsValid()) {
            ResetSocket(socketData);
        }
        goto error_exit;
    }

    if ((prcResponse->Major != FTP_RESPONSE_PRELIMINARY)
    && (prcResponse->Major != FTP_RESPONSE_COMPLETE)) {
        if (socketData->IsValid()) {
            ResetSocket(socketData);
        }
        error = ERROR_INTERNET_EXTENDED_ERROR;
        goto error_exit;
    }

    //
    // Parse out file size if its around
    // Assumes the substring containing the file size looks like; "(99999 bytes)"
    //
    if(!(lpSessionInfo->Flags & FFTP_KNOWN_FILE_SIZE)) {  // Don't already have the size
        pch = (PCHAR)InternetLockErrorText();
        if (pch != NULL) {
            pch = strstr(pch, "150 ");
            if (pch != NULL) {

                pch += sizeof("150 ") - 1;
                PCHAR pchEnd = strstr(pch, " bytes)");
                if (pchEnd) {
                    DWORD dwFileSize = 0;
                    DWORD dwMul = 1;
                    PCHAR pchBeg = pch;
                    pch = pchEnd - 1;
                    while (pch && (pch > pchBeg) && isdigit(*pch)) {
                        dwFileSize += ((*pch - '0') * dwMul);
                        dwMul *= 10;
                        pch--;
                    }
                    
                    if (pch && (*pch == '(') && (dwFileSize > 0)) {
                        lpSessionInfo->dwFileSizeLow = dwFileSize;
                        lpSessionInfo->Flags |= FFTP_KNOWN_FILE_SIZE;
                    }
                }
            }
        }
    }

    //
    // unlock the response text
    //

    //InternetUnlockErrorText();

    //
    // if we are expecting the server to create the connection (ACTIVE mode)
    // then perform an accept() on our listening socket in order to establish
    // the connection
    //

    if (!bPassiveMode) {

        //
        // if we just accept(), we may hang forever if the server doesn't call
        // back (servers are all alike), so we use select() to wait for the
        // socket to be acceptable before calling accept() proper
        //

        error = socketListener->SelectAccept(
                                    *socketData,

                                    //
                                    // BUGBUG - call GetTimeoutValue()
                                    //

                                    GlobalFtpAcceptTimeout
                                    );

        if ( error != ERROR_SUCCESS ) {
            goto error_exit;
        }

        //
        // we no longer require the socket we created for listening for the
        // incoming server connection request
        //

        INET_ASSERT(socketListener != socketControl);
        INET_ASSERT(socketListener != socketData);
        INET_ASSERT(socketListener->GetSocket() != socketControl->GetSocket());
        INET_ASSERT(socketListener->GetSocket() != socketData->GetSocket());

#if INET_DEBUG
        socketData->SetSourcePort();
#endif

        socketListener->Close();
        if (!socketData->IsValid()) {
            goto error_exit;
        }
    }

    //
    // set send and receive timeouts for data socket. If we get an error, ignore
    // it. Note this probably means that the socket is (somehow) invalid, and
    // that we should really return an error. But for now (as with the other
    // protocols), I will presume that the error is non-fatal (but note it)
    //

    socketData->SetTimeout(
                SEND_TIMEOUT,
                (int)GetTimeoutValue(INTERNET_OPTION_DATA_SEND_TIMEOUT)
                );
    socketData->SetTimeout(
                RECEIVE_TIMEOUT,
                (int)GetTimeoutValue(INTERNET_OPTION_DATA_RECEIVE_TIMEOUT)
                );

    INET_ASSERT(error == ERROR_SUCCESS);

    INET_ASSERT(lpSessionInfo->socketData == socketData);

quit:

    DEBUG_LEAVE(error);

    return error;


error_exit:

    if (socketData->IsValid()) {
        socketData->Close();
    }
    if (socketListener->IsValid()) {
        socketListener->Close();
    }
    goto quit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\tcputil.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    tcputil.h

Abstract:

    Contains prototypes etc. for tcputil.c

Author:

    Heath Hunnicutt (t-hheath) 21-Jun-1994

Revision History:

--*/

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
FtpOpenServer(
    IN LPFTP_SESSION_INFO SessionInfo
    );

BOOL
ResetSocket(
    IN ICSocket * Socket
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\session.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    session.h

Abstract:

    Structures, prototypes for session.c

Author:

    Heath Hunnicutt (t-hheath) 21-Jun-1994

Revision History:

    21-Jun-1994 t-heathh
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define FTP_SESSION_SIGNATURE   0x53707446  // "FtpS" (when viewed via db/dc)

//
// macros
//

#if INET_DEBUG

#define SetSessionSignature(lpSessionInfo)  \
    (lpSessionInfo)->Signature = FTP_SESSION_SIGNATURE

#else

#define SetSessionSignature(lpSessionInfo)

#endif

#define SetSessionLastResponseCode(pSession, prc) \
    CopyMemory(&((pSession)->rcResponseOpenFile), (prc), sizeof(FTP_RESPONSE_CODE))

#define GetSessionLastResponseCode(pSession, prc) \
    CopyMemory((prc), &((pSession)->rcResponseOpenFile), sizeof(FTP_RESPONSE_CODE))

#define IsPassiveModeSession(lpSessionInfo) \
    (((lpSessionInfo)->Flags & FFTP_PASSIVE_MODE) ? TRUE : FALSE)

//
// types
//

typedef enum {
    FTP_SERVER_TYPE_UNKNOWN = 0,
    FTP_SERVER_TYPE_NT = 1,
    FTP_SERVER_TYPE_UNIX = 2
} FTP_SERVER_TYPE;

//
// FTP_SESSION_INFO - describes an FTP server and our connection to it
//

typedef struct {

    //
    // List - SESSION_INFOs are maintained on double-linked list
    //

    LIST_ENTRY List;

    //
    // Host - name of the server we are connected to. We only need this for
    // diagnositic purposes - e.g. knowing which server to talk to to
    // reproduce a problem
    //

    LPSTR Host;

    //
    // Port - the port at which the FTP server listens
    //

    INTERNET_PORT Port;

    //
    // socketListener - listening socket
    //

    ICSocket *socketListener;


    //
    // socketControl - control connection socket
    //

    ICSocket *socketControl;

    //
    // socketData - data connection socket
    //

    ICSocket *socketData;

    //
    // ServerType - type of FTP server, e.g. NT or *nix
    //

    FTP_SERVER_TYPE ServerType;

    //
    // Handle - internally identifies this FTP session
    //

    HANDLE Handle;

    //
    // Flags - bitmask of various flags - see below
    //

    DWORD Flags;

    //
    // ReferenceCount - keeps object alive whilst we are not holding
    // CriticalSection
    //

    LONG ReferenceCount;

    //
    // dwTransferAccess - Indicates, for an ongoing transfer, whether the
    // transfer was begun with GENERIC_READ or GENERIC_WRITE access.
    //
    // {dwTransferAccess} = {GENERIC_READ, GENERIC_WRITE}
    //

    DWORD dwTransferAccess;

    //
    // rcResponseOpenFile - The response code sent back when a data connection
    // was opened, either by FtpOpenFile or FtpCommand.
    //
    // Used by FtpCloseFile to determine whether the completion
    // code was already received.
    //

    FTP_RESPONSE_CODE rcResponseOpenFile;

    //
    // FindFileList - A linked-list of WIN32_FIND_DATA structures, formed by a
    // call to FtpFindFirstFile, used by FtpFindNextFile and
    // FtpFindClose.
    //

    LIST_ENTRY FindFileList;

    //
    // CriticalSection - Synchronize access to this structure's contents
    //

    CRITICAL_SECTION CriticalSection;

    //
    // dwFileSizeLow - Size of the file found on the FTP server, should be gotten
    //   from response data on openning a data connection
    //

    DWORD dwFileSizeLow;
    DWORD dwFileSizeHigh;

#if INET_DEBUG

    //
    // Signature - to help us know this is what its supposed to be in debug build
    //

    DWORD Signature;

#endif

} FTP_SESSION_INFO, *LPFTP_SESSION_INFO;

//
// Flags defines
//

//
// FFTP_PASSIVE_MODE - set if the session uses passive mode data connections
//

#define FFTP_PASSIVE_MODE       0x00000001

//
// FFTP_ABORT_TRANSFER - set if we have not completed a file transfer on this
// (data) connection, and therefore need to send an ABOR command when we close
// the connection
//

#define FFTP_ABORT_TRANSFER     0x00000002

//
// FFTP_FIND_ACTIVE - set when a directory listing is active on this session
//

#define FFTP_FIND_ACTIVE        0x00000004

//
// FFTP_IN_DESTRUCTOR - set when this session is being terminated
//

#define FFTP_IN_DESTRUCTOR      0x00000008

//
// FFTP_EOF - set when we have reached the end of a (receive) data connection
//

#define FFTP_EOF                0x00000010

//
// FFTP_FILE_ACTIVE - set when a file is open on this session
//

#define FFTP_FILE_ACTIVE        0x00000020

//
// FFTP_KNOWN_FILE_SIZE - set when we know the size of the file we're downloading
//

#define FFTP_KNOWN_FILE_SIZE    0x00000040

//
// prototypes
//

VOID
CleanupFtpSessions(
    VOID
    );

VOID
TerminateFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    );

VOID
DereferenceFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    );

DWORD
CreateFtpSession(
    IN LPSTR lpszHost,
    IN INTERNET_PORT Port,
    IN DWORD dwFlags,
    OUT LPFTP_SESSION_INFO* lpSessionInfo
    );

BOOL
FindFtpSession(
    IN HANDLE Handle,
    OUT LPFTP_SESSION_INFO* lpSessionInfo
    );

#if INET_DEBUG

VOID
FtpSessionInitialize(
    VOID
    );

VOID
FtpSessionTerminate(
    VOID
    );

VOID
AcquireFtpSessionList(
    VOID
    );

VOID
ReleaseFtpSessionList(
    VOID
    );

VOID
AcquireFtpSessionLock(
    IN LPFTP_SESSION_INFO SessionInfo
    );

VOID
ReleaseFtpSessionLock(
    IN LPFTP_SESSION_INFO SessionInfo
    );

#else

//
// one-line functions replaced by macros in retail version
//

extern SERIALIZED_LIST FtpSessionList;

#define FtpSessionInitialize() \
    InitializeSerializedList(&FtpSessionList)

#define FtpSessionTerminate() \
    TerminateSerializedList(&FtpSessionList)

#define AcquireFtpSessionList() \
    LockSerializedList(&FtpSessionList)

#define ReleaseFtpSessionList() \
    UnlockSerializedList(&FtpSessionList)

#define AcquireFtpSessionLock(lpSessionInfo) \
    EnterCriticalSection(&lpSessionInfo->CriticalSection)

#define ReleaseFtpSessionLock(lpSessionInfo) \
    LeaveCriticalSection(&lpSessionInfo->CriticalSection)

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\session.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    Contains functions to create and delete FTP_SESSION_INFOs

    Contents:
        FtpSessionInitialize
        FtpSessionTerminate
        AcquireFtpSessionList
        ReleaseFtpSessionList
        AcquireFtpSessionLock
        ReleaseFtpSessionLock
        CleanupFtpSessions
        TerminateFtpSession
        DereferenceFtpSession
        CreateFtpSession
        (DestroyFtpSession)
        FindFtpSession

Author:

    Richard L Firth (rfirth) 09-Jun-95

Environment:

    Win32 user-level DLL

Revision History:

    09-Jun-95 rfirth
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"
#include "..\urlcache\debug.h"
//
// private prototypes
//

PRIVATE
VOID
DestroyFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    );

//
// public data
//

//
// FtpSessionList - a doubly-linked list of all the FTP_SESSION_INFOs owned by
// this process
//

PUBLIC SERIALIZED_LIST FtpSessionList;

//
// external data
//

extern BOOL InDllCleanup;

//
// functions
//

#if INET_DEBUG


VOID
FtpSessionInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes any global data items for this module.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Initializing ftp session list\r\n"));
    InitializeSerializedList(&FtpSessionList);
}


VOID
FtpSessionTerminate(
    VOID
    )

/*++

Routine Description:

    Terminates any items initialized by FtpSessionInitialize()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Terminating ftp session list\r\n"));
    TerminateSerializedList(&FtpSessionList);
}


VOID
AcquireFtpSessionList(
    VOID
    )

/*++

Routine Description:

    Acquires the FtpSessionList lock

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Trying to acquiring ftp session list\r\n"));
    LockSerializedList(&FtpSessionList);
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Acquired ftp session list\r\n"));
}


VOID
ReleaseFtpSessionList(
    VOID
    )

/*++

Routine Description:

    Releases the FtpSessionList lock

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Trying to release ftp session list\r\n"));
    UnlockSerializedList(&FtpSessionList);
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Release ftp session list\r\n"));
}


VOID
AcquireFtpSessionLock(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Acquires an individual session info lock

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to lock

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSION: Trying to acquire %d\r\n", &SessionInfo->CriticalSection));
    EnterCriticalSection(&SessionInfo->CriticalSection);
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSION: Acquired ftp session %d\r\n", &SessionInfo->CriticalSection));
}


VOID
ReleaseFtpSessionLock(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Releases an individual session info lock

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to unlock

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSION: Trying to release %d\r\n", &SessionInfo->CriticalSection));
    LeaveCriticalSection(&SessionInfo->CriticalSection);
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSION: Released ftp session %d\r\n", &SessionInfo->CriticalSection));
}

#endif // INET_DEBUG


VOID
CleanupFtpSessions(
    VOID
    )

/*++

Routine Description:

    Terminates all active FTP sessions owned by this process

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPFTP_SESSION_INFO info;

    DEBUG_ENTER((DBG_FTP,
                None,
                "CleanupFtpSessions",
                NULL
                ));

    //
    // walk the session list. For each FTP_SESSION_INFO, close the data and
    // control sockets, if open, then destroy the session
    //

    do {

        DWORD error;

        AcquireFtpSessionList();

        info = (LPFTP_SESSION_INFO)HeadOfSerializedList(&FtpSessionList);
        if (info == (LPFTP_SESSION_INFO)&FtpSessionList.List.Flink) {
            ReleaseFtpSessionList();
            break;
        }

        //
        // kill the data and control sockets. Remorselessly. If the sockets are
        // set to INVALID_SOCKET, then Close() will do the right thing
        //

        error = info->socketData->Close();
        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(SESSION,
                        ERROR,
                        ("Data: Close(%x) returns %d\n",
                        info->socketData,
                        error
                        ));

        }

        error = info->socketControl->Close();
        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(SESSION,
                        ERROR,
                        ("Control: Close(%x) returns %d\n",
                        info->socketControl,
                        error
                        ));

        }

        ReleaseFtpSessionList();
        DestroyFtpSession(info);
    } while (1);

    DEBUG_LEAVE(0);
}


VOID
TerminateFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Initiates termination of the FTP_SESSION_INFO object

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to terminate

Return Value:

    None.

--*/

{
    BOOL destroy;
    int i;

    INET_ASSERT(SessionInfo != NULL);
    INET_ASSERT(!(SessionInfo->Flags & FFTP_IN_DESTRUCTOR));
    INET_ASSERT(SessionInfo->ReferenceCount >= 2);

    DEBUG_ENTER((DBG_FTP,
                None,
                "TerminateFtpSession",
                "%x",
                SessionInfo
                ));

    //
    // first off, set the in-destructor flag. This will cause any other threads
    // trying to find & reference this object to fail
    //

    SessionInfo->Flags |= FFTP_IN_DESTRUCTOR;

    //
    // now we need to decrement the reference count by 2, which should cause
    // the FTP_SESSION_INFO to be destroyed
    //

    AcquireFtpSessionLock(SessionInfo);
    INET_ASSERT(SessionInfo->ReferenceCount>=2);
    if (InterlockedDecrement(&SessionInfo->ReferenceCount))
    {
        InterlockedDecrement(&SessionInfo->ReferenceCount);
    }
    
    if (SessionInfo->ReferenceCount == 0) {
        DestroyFtpSession(SessionInfo);
    } else {
        ReleaseFtpSessionLock(SessionInfo);
        DEBUG_PRINT(REFCOUNT,
                    WARNING,
                    ("unexpected: SessionInfo(%x)->ReferenceCount = %d\n",
                    SessionInfo,
                    SessionInfo->ReferenceCount
                    ));
    }    
    DEBUG_LEAVE(0);
}


VOID
DereferenceFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Reduces the reference count on an FTP_SESSION_INFO object by 1. If the
    reference count goes to 0, the FTP_SESSION_INFO is destroyed

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to dereference

Return Value:

    None.

--*/

{
    INET_ASSERT(SessionInfo->ReferenceCount >= 1);

    DEBUG_ENTER((DBG_FTP,
                None,
                "DereferenceFtpSession",
                "%x",
                SessionInfo
                ));

    AcquireFtpSessionLock(SessionInfo);
    INET_ASSERT(SessionInfo->ReferenceCount>1);
    if (InterlockedDecrement(&SessionInfo->ReferenceCount) == 0) {
        if (SessionInfo->socketControl->IsValid()
            || SessionInfo->socketData->IsValid())
        {
            // All sockets should have been closed by now. However
            // there's a case where two wFtpDisconnect closes the connection
            // but another thread revives those sockets.
            // In this case, shutting down the session would be inappropriate.
            // We should reset the ref count so that it may continue
            INET_ASSERT((SessionInfo->Flags & FFTP_IN_DESTRUCTOR));
            InterlockedIncrement(&SessionInfo->ReferenceCount);
            ReleaseFtpSessionLock(SessionInfo);           
        }
        else
        {
            DestroyFtpSession(SessionInfo);
        }
    } else {
        ReleaseFtpSessionLock(SessionInfo);
        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("SessionInfo(%x)->ReferenceCount = %d\n",
                    SessionInfo,
                    SessionInfo->ReferenceCount
                    ));
    }

    DEBUG_LEAVE(0);
}


DWORD
CreateFtpSession(
    IN LPSTR lpszHost,
    IN INTERNET_PORT Port,
    IN DWORD dwFlags,
    OUT LPFTP_SESSION_INFO* lpSessionInfo
    )

/*++

Routine Description:

    Creates a new FTP_SESSION_INFO object. If successful, adds the new object
    to the FtpSessionList; the reference count of the new object will be 1 (i.e.
    it is unowned)

Arguments:

    lpszHost        - pointer to name of the host we are connecting to. Mainly
                      for diagnostic purposes (can remove it later)

    Port            - Port at which the FTP server listens. Only in anomalous
                      circumstances will this not be 21

    dwFlags         - flags controlling session creation. Can be:
                        - FFTP_PASSIVE_MODE

    lpSessionInfo   - pointer to returned session info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate memory

                  ERROR_INTERNET_OUT_OF_HANDLES
                    Couldn't allocate a handle

                  ERROR_INTERNET_SHUTDOWN
                    The DLL is being unloaded

--*/

{
    LPFTP_SESSION_INFO sessionInfo;
    DWORD error;

    DEBUG_ENTER((DBG_FTP,
                Dword,
                "CreateFtpSession",
                "%q, %d, %x",
                lpszHost,
                Port,
                lpSessionInfo
                ));

    //
    // if the DLL is being unloaded then return the shutdown error
    //

    if (InDllCleanup) {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;
    }

    //
    // allocate the FTP_SESSION_INFO 'object' and its various sub-assemblies
    //

    sessionInfo = NEW(FTP_SESSION_INFO);
    if (sessionInfo != NULL) {
        sessionInfo->Host = NEW_STRING(lpszHost);
        if (sessionInfo->Host != NULL) {
            error = AllocateHandle((LPVOID)sessionInfo, &sessionInfo->Handle);
            if (error == ERROR_SUCCESS) {

                INET_ASSERT(sessionInfo->ServerType == FTP_SERVER_TYPE_UNKNOWN);

                //
                // initialize any non-zero fields
                //

                InitializeListHead(&sessionInfo->List);
                sessionInfo->Port = Port;
                sessionInfo->Flags = dwFlags;
                sessionInfo->ReferenceCount = 1;
                InitializeListHead(&sessionInfo->FindFileList);
                InitializeCriticalSection(&sessionInfo->CriticalSection);
                SetSessionSignature(sessionInfo);

                //
                // Allocate Our Socket Objects.
                //

                //
                // Isn't this kinda of messy?  I've copied the format of
                // surrounding block, since there is no clean quit case in this
                // function... arhh.
                //

                sessionInfo->socketControl = new ICSocket();
                if ( sessionInfo->socketControl )
                {
                    sessionInfo->socketData = new ICSocket();
                    if ( sessionInfo->socketData )
                    {
                        sessionInfo->socketListener = new ICSocket();
                        if ( sessionInfo->socketListener  == NULL )
                        {
                            sessionInfo->socketControl->Dereference();
                            sessionInfo->socketData->Dereference();
                            error = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                    else
                    {
                        sessionInfo->socketControl->Dereference();
                        error = ERROR_NOT_ENOUGH_MEMORY;
                    }

                }
                else
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }
    if (error == ERROR_SUCCESS) {

        //
        // add this FTP_SESSION_INFO to the object list
        //

        InsertAtHeadOfSerializedList(&FtpSessionList, &sessionInfo->List);
        *lpSessionInfo = sessionInfo;

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("handle = %x, SessionInfo = %x\n",
                    sessionInfo->Handle,
                    sessionInfo
                    ));

    } else if (sessionInfo != NULL) {
        if (sessionInfo->Host != NULL) {
            DEL_STRING(sessionInfo->Host);
        }
        DEL(sessionInfo);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
VOID
DestroyFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Removes an FTP_SESSION_INFO object from the session list and destroys it.

    Note: SessionInfo MUST be owned by the current thread (critical section held
    but reference count == 0)

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to delete

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_FTP,
                None,
                "DestroyFtpSession",
                "%x",
                SessionInfo
                ));

    INET_DEBUG_ASSERT(SessionInfo->Signature == FTP_SESSION_SIGNATURE);
    INET_ASSERT(!SessionInfo->socketControl->IsValid());
    INET_ASSERT(!SessionInfo->socketData->IsValid());
    INET_ASSERT(SessionInfo->ReferenceCount == 0);

    RemoveFromSerializedList(&FtpSessionList, (PLIST_ENTRY)&SessionInfo->List);

    INET_DEBUG_ASSERT(SessionInfo->List.Flink == NULL);
    INET_DEBUG_ASSERT(SessionInfo->List.Blink == NULL);

    ReleaseFtpSessionLock(SessionInfo);

    if (SessionInfo->Handle) {
        FreeHandle(SessionInfo->Handle);
    }

    if (SessionInfo->Host != NULL) {
        DEL_STRING(SessionInfo->Host);
    }

    if ( SessionInfo->socketControl )
        SessionInfo->socketControl->Dereference();

    if ( SessionInfo->socketData )
        SessionInfo->socketData->Dereference();

    if ( SessionInfo->socketListener )
        SessionInfo->socketListener->Dereference();

    ClearFindList(&SessionInfo->FindFileList);

    DeleteCriticalSection(&SessionInfo->CriticalSection);

    DEL(SessionInfo);

    DEBUG_LEAVE(0);
}


BOOL
FindFtpSession(
    IN HANDLE Handle,
    OUT LPFTP_SESSION_INFO *lpSessionInfo
    )

/*++

Routine Description:

    Searches the session list for an FTP_SESSION_INFO object. If found, the
    FTP_SESSION_INFO's reference count is incremented by 1

Arguments:

    Handle          - handle to search for

    lpSessionInfo   - pointer to returned FTP_SESSION_INFO if found

Return Value:

    BOOL
        Success - TRUE, *lppSessionInfo is pointer to FTP_SESSION_INFO

        Failure - FALSE

--*/

{
    BOOL found;
    LPFTP_SESSION_INFO sessionInfo;

    DEBUG_ENTER((DBG_FTP,
                Bool,
                "FindFtpSession",
                "%x",
                Handle
                ));

    //
    // lock the list, to prevent the element from moving under us
    //

    AcquireFtpSessionList();

    found = FALSE;
    for (sessionInfo = (LPFTP_SESSION_INFO)FtpSessionList.List.Flink;
        sessionInfo != (LPFTP_SESSION_INFO)&FtpSessionList.List;
        sessionInfo = (LPFTP_SESSION_INFO)(sessionInfo->List.Flink)) {

        if (sessionInfo->Handle == Handle) {
            AcquireFtpSessionLock(sessionInfo);

            //
            // if the destructor flag is set then another thread is already
            // destroying this session - we cannot return it. Treat as not
            // found
            //

            if (!(sessionInfo->Flags & FFTP_IN_DESTRUCTOR)) {

                //
                // although we're holding the session info lock (a critical
                // section), we still need to perform interlocked increment
                // on the reference count
                //

                InterlockedIncrement(&sessionInfo->ReferenceCount);
                found = TRUE;
            }
            ReleaseFtpSessionLock(sessionInfo);
            break;
        }
    }

    ReleaseFtpSessionList();

    if (found) {
        *lpSessionInfo = sessionInfo;

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("handle = %x, FTP_SESSION_INFO = %x\n",
                    Handle,
                    sessionInfo
                    ));

    } else {

        DEBUG_PRINT(SESSION,
                    ERROR,
                    ("handle %x: not found\n",
                    Handle
                    ));

    }

    DEBUG_LEAVE(found);

    return found;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\tcputil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    tcputil.cxx

Abstract:

    Contains functions to connect to an FTP server

    Contents:
        FtpOpenServer
        ResetSocket

Author:

    Heath Hunnicutt (t-hheath) 21-Jun-1994

Environment:

    Win32 user-level DLL

Revision History:

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// functions
//

DWORD
FtpOpenServer(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Resolves a host name and makes a connection to the FTP server at that host.
    If successful, the controlSocket field of the FTP_SESSION_INFO object will
    contain an opened socket handle

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO describing host to connect to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_NAME_NOT_RESOLVED
                  WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "FtpOpenServer",
                "%#x",
                SessionInfo
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;
    BOOL  fUseSocksProxy = FALSE;
    INTERNET_CONNECT_HANDLE_OBJECT *pConnect;
    AUTO_PROXY_ASYNC_MSG *pProxyInfoQuery = NULL;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    DWORD asyncFlags;

    asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // attempt to resolve the host name, server port, and possibly service GUID
    // to socket address(es)
    //

    SessionInfo->socketControl->SetPort(SessionInfo->Port);


    //
    // Using the object handle, check to see if we have a socks proxy.
    //  If so, use it to do our connections.
    //

    INTERNET_HANDLE_OBJECT * pInternet;
    HINTERNET hConnectMapped;

    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(SessionInfo->Host != NULL);

    //
    // Get the Mapped Connect Handle Object
    //

    hConnectMapped = lpThreadInfo->hObjectMapped;

    INET_ASSERT(hConnectMapped);

    //
    // Finally get the Internet Object, so we can query proxy information
    //  out of it.
    //

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *) hConnectMapped;


    pInternet = (INTERNET_HANDLE_OBJECT *)
                    ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->GetParent();

    INET_ASSERT(pInternet);

    {
        CHAR szUrl[INTERNET_MAX_URL_LENGTH + sizeof("ftp:// /")];

        PROXY_STATE * pProxyState = NULL;

        INTERNET_SCHEME scheme = INTERNET_SCHEME_DEFAULT;

        if (lstrlen(SessionInfo->Host)>INTERNET_MAX_URL_LENGTH)
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }
        wsprintf(szUrl, "ftp://%s/", SessionInfo->Host);

        AUTO_PROXY_ASYNC_MSG proxyInfoQuery(
                                    INTERNET_SCHEME_FTP,
                                    szUrl,
                                    lstrlen(szUrl),
                                    SessionInfo->Host,
                                    lstrlen(SessionInfo->Host),
                                    (INTERNET_PORT) SessionInfo->Port
                                    );

        proxyInfoQuery.SetBlockUntilCompletetion(TRUE);

        pProxyInfoQuery = &proxyInfoQuery;

        error = pInternet->GetProxyInfo(
                                &pProxyInfoQuery
                                );

        if ( error != ERROR_SUCCESS)
        {
            goto quit2;
        }


        if ( pProxyInfoQuery->IsUseProxy() &&
             pProxyInfoQuery->GetProxyScheme() == INTERNET_SCHEME_SOCKS &&
             pProxyInfoQuery->_lpszProxyHostName )
        {

            //
            //  If Socks is enabled, then turn it on.
            //

            error = SessionInfo->socketControl->EnableSocks(
                                                             pProxyInfoQuery->_lpszProxyHostName,
                                                             pProxyInfoQuery->_nProxyHostPort
                                                             );

            if ( error != ERROR_SUCCESS)
            {
                goto quit2;
            }

            error = SessionInfo->socketData->EnableSocks(
                                                             pProxyInfoQuery->_lpszProxyHostName,
                                                             pProxyInfoQuery->_nProxyHostPort
                                                             );


            if ( error != ERROR_SUCCESS)
            {
                goto quit2;
            }

            //
            // Force Passive Mode, since Socks Firewalls may not
            //  support connections from the outside in.
            //

            SessionInfo->Flags |= FFTP_PASSIVE_MODE;

        }

        pConnect->SetServerInfo(SessionInfo->Host,
                                lstrlen(SessionInfo->Host));



        //
        // name was resolved ok, now let's try to connect to the server. Here
        // we create the control socket
        //

        error = SessionInfo->socketControl->Connect(
                              GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                              GetTimeoutValue(INTERNET_OPTION_CONNECT_RETRIES),
                              SF_INDICATE | asyncFlags
                              );

    quit2:

        if ( pProxyInfoQuery && pProxyInfoQuery->IsAlloced() )
        {
            delete pProxyInfoQuery;
            pProxyInfoQuery = NULL;
        }
    }

quit:


    DEBUG_LEAVE(error);

    return error;
}


BOOL
ResetSocket(
    IN ICSocket * Socket
    )

/*++

Routine Description:

    Sets linger time to zero on a socket, then closes the socket, causing a
    "hard" close

Arguments:

    Socket  - The socket to reset the connection on

Return Value:

    BOOL
        Success - TRUE
        Failure - FALSE

--*/

{
    //
    // ignore return code from linger - if error, socket is closed or aborted
    //

    Socket->SetLinger(TRUE, 0);
    return (Socket->Close() == ERROR_SUCCESS) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\test\ftpcat\ftpcat.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpcat.c

Abstract:

    Windows Internet API FTP test program

    Provides the same functionality as a cut-down version of the venerable
    (console-mode) ftp program

Author:

    Richard L Firth (rfirth) 05-Jun-1995

Environment:

    Win32 user-mode console app

Revision History:

    05-Jun-1995 rfirth
        Created

--*/

#include "ftpcatp.h"

#undef tolower

//
// macros
//

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

//
// manifests
//

#define MAX_COMMAND_LENGTH 100

//
// external data
//

extern BOOL fQuit;
extern DWORD CacheFlags;

//
// data
//

DWORD Verbose = 0;
INTERNET_STATUS_CALLBACK PreviousCallback;
HINTERNET hCancel = NULL;
BOOL AsyncMode = FALSE;
BOOL fOffline = FALSE;
DWORD Context = 0;
DWORD AsyncResult = 0;
DWORD AsyncError = 0;
HANDLE AsyncEvent = NULL;
BOOL UseQueryData = FALSE;

#if DBG
BOOL CheckHandleLeak = FALSE;
#endif

//
// external functions
//

extern BOOL DispatchCommand(LPCTSTR, HANDLE);

//
// prototypes
//

void __cdecl main(int, char**);
void __cdecl control_c_handler(int);
void usage(void);
BOOL Prompt(LPCTSTR, LPTSTR*);

//
// functions
//

void __cdecl main(int argc, char** argv) {

    LPTSTR ptszSite = NULL;
    LPTSTR ptszUser = NULL;
    LPTSTR ptszPass = NULL;
    HINTERNET hInternet;
    HINTERNET hFtpSession;
    DWORD dwLocalAccessFlags;
    LPTSTR lpszCmd;
    DWORD lastError;
    DWORD bufLen;
    BOOL enableCallbacks = FALSE;
    DWORD flags = 0;
    DWORD accessMethod = INTERNET_OPEN_TYPE_PRECONFIG;
    BOOL expectingProxy = FALSE;
    LPSTR proxyServer = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'a':
                ++*argv;
                if ((**argv == 'l') || (**argv == 'd')) {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                    if (*++*argv) {
                        proxyServer = *argv;
                    } else {
                        expectingProxy = TRUE;
                    }
                } else {
                    printf("error: unrecognised access type: '%c'\n", **argv);
                    usage();
                }
                break;

            case 'c':
                enableCallbacks = TRUE;
                break;

#if DBG
            case 'l':
                CheckHandleLeak = TRUE;
                break;
#endif

            case 'n':
                CacheFlags |= INTERNET_FLAG_DONT_CACHE;
                break;

            case 'p':
                flags |= INTERNET_FLAG_PASSIVE;
                break;

            case 'q':
                UseQueryData = TRUE;
                break;

            case 'v':
                if (*++*argv == '\0') {
                    Verbose = 1;
                } else {
                    Verbose = atoi(*argv);
                }
                break;

            case 'x':
                Context = (DWORD)atoi(++*argv);
                break;

            case 'y':
                AsyncMode = TRUE;
                break;
            case 'o':
                fOffline = TRUE;
                break;
            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxy) {
            proxyServer = *argv;
            expectingProxy = FALSE;
        } else if (ptszSite == NULL) {
            ptszSite = *argv;
        } else if (ptszUser == NULL) {
            ptszUser = *argv;
        } else if (ptszPass == NULL) {
            ptszPass = *argv;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (ptszSite == NULL) {
        printf("error: required server name argument missing\n");
        exit(1);
    }

    if (AsyncMode) {

        //
        // create auto-reset, initially unsignalled event
        //

        AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (AsyncEvent == NULL) {
            print_error("ftpcat", "CreateEvent()");
            exit(1);
        }
    }

    //
    // add a control-c handler
    //

    signal(SIGINT, control_c_handler);

#if DBG
    if (CheckHandleLeak) {
        printf("initial handle count = %d\n", GetProcessHandleCount());
    }
#endif

#if DBG
    if (CheckHandleLeak && Verbose) {
        printf("Initial handle count = %d\n", GetProcessHandleCount());
    }
#endif

    if (Verbose) {
        printf("calling InternetOpen()...\n");
    }
    hInternet = InternetOpen("ftpcat",
                             accessMethod,
                             proxyServer,
                             NULL,
                             AsyncMode ? INTERNET_FLAG_ASYNC : 0
                             | (fOffline ? INTERNET_FLAG_OFFLINE : 0)
                             );
    if (hInternet == NULL) {
        print_error("ftpcat", "InternetOpen()");
        exit(1);
    } else if (Verbose) {
        printf("Internet handle = %x\n", hInternet);
        hCancel = hInternet;
    }

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetOpen(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    if (enableCallbacks) {

        //
        // let's have a status callback
        //
        // Note that callbacks can be set even before we have opened a handle
        // to the internet/gateway
        //

        PreviousCallback = InternetSetStatusCallback(hInternet, my_callback);
        if (PreviousCallback == INTERNET_INVALID_STATUS_CALLBACK) {
            print_error("ftpcat", "InternetSetStatusCallback()");
        } else if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    if (Verbose) {
        printf("calling InternetConnect()...\n");
    }
    hFtpSession = InternetConnect(hInternet,
                                  ptszSite,
                                  0,
                                  ptszUser,
                                  ptszPass,
                                  INTERNET_SERVICE_FTP,
                                  flags,
                                  FTPCAT_CONNECT_CONTEXT
                                  );
    if ((hFtpSession == NULL) && AsyncMode) {
        if (Verbose) {
            printf("waiting for async InternetConnect()...\n");
        }
        WaitForSingleObject(AsyncEvent, INFINITE);
        hFtpSession = (HINTERNET)AsyncResult;
        SetLastError(AsyncError);
    }
    if (hFtpSession == NULL) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("ftpcat",
                    "%sInternetConnect()",
                    AsyncMode ? "async " : ""
                    );
        get_response(hFtpSession);
        close_handle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("FTP session handle = %x\n", hFtpSession);
    }

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetConnect(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    printf("Connected to %s.\n", ptszSite);

    get_response(hFtpSession);

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetGetLastResponseInfo(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    //
    // set the (top level) cancellable handle
    //

    hCancel = hFtpSession;

    while (!fQuit) {
        if (Prompt(TEXT("ftp> "), &lpszCmd)) {
            DispatchCommand(lpszCmd, hFtpSession);
        }
    }

    if (Verbose) {
        printf("Closing %x\n", hFtpSession);
    }

    close_handle(hFtpSession);

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetCloseHandle(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    get_response(hFtpSession);

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetGetLastResponseInfo(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    close_handle(hInternet);

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetCloseHandle(): handle count = %d\n", GetProcessHandleCount());
    }

    if (CheckHandleLeak && Verbose) {
        printf("Final handle count = %d\n", GetProcessHandleCount());
    }
#endif

    exit(0);
}

void __cdecl control_c_handler(int sig) {

    //
    // disable signals
    //

    signal(SIGINT, SIG_IGN);

    //
    // cancel the current operation
    //

    if (Verbose) {
        printf("control-c handler\n");
    }
    if (hCancel == NULL) {
        if (Verbose) {
            printf("control-c handler: no Internet operation in progress\n");
        }
    } else {
        close_handle(hCancel);
    }

    //
    // re-enable this signal handler
    //

    signal(SIGINT, control_c_handler);
}

void usage() {
    printf("\n"
           "usage: ftpcat [-a{g{[ ]server}|l|d|p}] [-c] [-d] [-n] [-p] [-v] [-x#] [-y]\n"
           "              {servername} [username] [password]\n"
           "\n"
           "where: -a = access type. Default is pre-configured:\n"
           "            g = gateway access via <gateway server>\n"
           "            l = local internet access\n"
           "            d = local internet access\n"
           "            p = CERN proxy access\n"
           "       -c = Enable callbacks\n"
           "       -n = Don't cache\n"
           "       -p = Use Passive transfer mode\n"
           "       -v = Verbose mode. Default is off\n"
           "       -x = Set context value\n"
           "       -y = Asynchronous APIs\n"
           );
    exit(1);
}

BOOL
Prompt(
    IN LPCTSTR pszPrompt,
    OUT LPTSTR* ppszCommand
    )
{
    static CHAR Command[MAX_COMMAND_LENGTH + sizeof(TEXT('\0'))];

#ifdef UNICODE

    static WCHAR wchBuf[MAX_COMMAND_LENGTH + sizeof(L'\0')];

#endif

    DWORD dwBytesRead;
    PTCHAR pch;

    lprintf(TEXT("%s"), pszPrompt);

    if (!ReadFile(GetStdHandle(STD_INPUT_HANDLE),
                  Command,
                  MAX_COMMAND_LENGTH * sizeof(CHAR),
                  &dwBytesRead,
                  NULL)) {
        return FALSE;
    }

    Command[dwBytesRead] = '\0';

#ifdef UNICODE

    wsprintf(wchBuf, L"%S", Command);
    *ppszCommand = wchBuf;

#else

    *ppszCommand = Command;

#endif

    pch = lstrchr(*ppszCommand, TEXT('\r'));

    if (pch) {
        *pch = TEXT('\0');
    }

    return TRUE;
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        hCancel = *(LPHINTERNET)Info;
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                Handle,
                Context,
                (Context == FTPCAT_CONNECT_CONTEXT) ? "Connect"
                : (Context == FTPCAT_FIND_CONTEXT) ? "Find"
                : (Context == FTPCAT_FILE_CONTEXT) ? "File"
                : (Context == FTPCAT_GET_CONTEXT) ? "Get"
                : (Context == FTPCAT_PUT_CONTEXT) ? "Put"
                : (Context == FTPCAT_COMMAND_CONTEXT) ? "Command"
                : (Context == FTPCAT_OPEN_CONTEXT) ? "Open"
                : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {
                printf("%x", *(LPHINTERNET)Info);
            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else {
                printf(Info);
            }
        }
        putchar('\n');
    }
    if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
        get_response(Handle);
        if (AsyncMode) {
            SetEvent(AsyncEvent);
        } else {
            printf("error: INTERNET_STATUS_REQUEST_COMPLETE returned. Not async\n");
        }
    }
}

void close_handle(HINTERNET handle) {
    if (Verbose) {
        printf("closing handle %#x\n", handle);
    }
    if (!InternetCloseHandle(handle)) {
        print_error("close_handle", "InternetCloseHandle(%x)", handle);
    }
}

#if DBG

DWORD GetProcessHandleCount() {

    DWORD error;
    DWORD count;
    DWORD countSize;

    countSize = sizeof(count);
    if (!InternetQueryOption(NULL,
                             INTERNET_OPTION_GET_HANDLE_COUNT,
                             &count,
                             &countSize
                             )) {
        print_error("GetProcessHandleCount", "InternetQueryOption()");
        return 0;
    }
    return count;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\test\ftpcat\cmds.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cmds.c

Abstract:

    FTP commands

Author:

    Richard L Firth (rfirth) 03-Nov-1995

Revision History:

    03-Nov-1995 rfirth
        Created

--*/

#include "ftpcatp.h"

//
// manifests
//

#define MAX_ARGV            20
#define COMMAND_WHITESPACE  TEXT(" ,\r\n")

//
// external functions
//

extern
BOOL
Prompt(
    IN LPCTSTR pszPrompt,
    OUT LPTSTR* ppszCommand
    );

//
// prototypes
//

BOOL dbgbreak(HINTERNET, int, PTCHAR *);
BOOL chdir(HINTERNET, int, PTCHAR *);
BOOL del(HINTERNET, int, PTCHAR *);
BOOL dir(HINTERNET, int, PTCHAR *);
BOOL get(HINTERNET, int, PTCHAR *);
BOOL help(HINTERNET, int, PTCHAR *);
BOOL lcd(HINTERNET, int, char**);
BOOL mkdir(HINTERNET, int, PTCHAR *);
BOOL put(HINTERNET, int, PTCHAR *);
BOOL pwd(HINTERNET, int, PTCHAR *);
BOOL quit(HINTERNET, int, PTCHAR *);
BOOL rb(HINTERNET, int, char**);
BOOL rename_file(HINTERNET, int, PTCHAR *);
BOOL rmdir(HINTERNET, int, PTCHAR *);
BOOL wb(HINTERNET, int, char**);
BOOL toggle_verbose(HINTERNET, int, PTCHAR *);
BOOL set_type(HINTERNET, int, PTCHAR *);
BOOL open_file(HINTERNET, int, PTCHAR *);
BOOL close_file(HINTERNET, int, PTCHAR *);
BOOL read_file(HINTERNET, int, PTCHAR *);
BOOL write_file(HINTERNET, int, PTCHAR *);
BOOL DispatchCommand(LPTSTR, HINTERNET);

#if DBG

BOOL CheckHandles(HINTERNET, int, PTCHAR*);

#endif

//
// external data
//

extern DWORD Verbose;
extern INTERNET_STATUS_CALLBACK PreviousCallback;
extern HINTERNET hCancel;
extern BOOL AsyncMode;
extern HANDLE AsyncEvent;
extern DWORD AsyncResult;
extern DWORD AsyncError;
extern BOOL UseQueryData;

//
// data
//

typedef struct {
    LPCSTR pszCommand;
    LPCSTR HelpText;
    BOOL (*fn)(HINTERNET, int, PTCHAR []);
} COMMAND_ENTRY;

COMMAND_ENTRY Commands[] = {

#if DBG
    {"b",       "Break into debugger",              dbgbreak},
#endif

    {"!",       "Shell escape",                     NULL},
    {"?",       "This list",                        help},
    {"cd",      "Change to a remote directory",     chdir},
    {"close",   "Close an open file handle",        close_file},
    {"dir",     "List a directory",                 dir},
    {"del",     "Delete a remote file",             del},
    {"get",     "Copy a file from the server",      get},

#if DBG
    {"hndl",    "Get current handle count",         CheckHandles},
#endif

    {"lcd",     "Change local directory",           lcd},
    {"md",      "Create a remote directory",        mkdir},
    {"open",    "Open a file for read or write",    open_file},
    {"put",     "Copy a file to the server",        put},
    {"pwd",     "Display the current directory",    pwd},
    {"quit",    "Terminate this program",           quit},
    {"rb",      "Get/set Read buffer size",         rb},
    {"rd",      "Remove a remote directory",        rmdir},
    {"read",    "Read data from a file",            read_file},
    {"ren",     "Rename a remote file",             rename_file},
    {"type",    "Set transfer type",                set_type},
    {"verbose", "Toggle verbose mode",              toggle_verbose},
    {"wb",      "Get/set Write buffer size",        wb},
    {"write",   "Write data to a file",             write_file},
    {NULL,      NULL,                               NULL}
};

BOOL fQuit = FALSE;
DWORD CacheFlags = 0;
HINTERNET FileHandle = NULL;

//
// functions
//

void get_response(HINTERNET hFtp) {

    DWORD buflen;
    char buffer[2048];
    DWORD category;

    buflen = sizeof(buffer);
    if (InternetGetLastResponseInfo(&category, buffer, &buflen)) {
        if (hFtp && (Verbose >= 2)) {

            DWORD len = sizeof(DWORD);
            DWORD dwFlags;

            if (InternetQueryOption(hFtp,
                                    INTERNET_OPTION_REQUEST_FLAGS,
                                    &dwFlags,
                                    &len)) {
                if (dwFlags & INTERNET_REQFLAG_FROM_CACHE) {
                    fprintf(stderr, "****** Got from the cache ***** \n");
                } else {
                    fprintf(stderr, "****** From the wire ***** \n");
                }
            }
        }
        if (buflen || (Verbose >= 2)) {
            print_response(buffer, buflen, TRUE);
        }
    } else {

        DWORD error;

        error = GetLastError();
        if (Verbose || (error != ERROR_INSUFFICIENT_BUFFER)) {

            LPSTR errString;

            errString = (error == ERROR_INSUFFICIENT_BUFFER)
                            ? "InternetGetLastResponseInfo() returns error %d (buflen = %d)\n"
                            : "InternetGetLastResponseInfo() returns error %d\n"
                            ;
            printf(errString, error, buflen);
        }
        if (error = ERROR_INSUFFICIENT_BUFFER) {

            LPSTR errbuf;

            if ((errbuf = malloc(buflen)) == NULL) {
                printf("error: get_response: malloc(%d) failed\n", buflen);
                return;
            }
            if (InternetGetLastResponseInfo(&category, errbuf, &buflen)) {
                if (buflen || (Verbose >= 2)) {
                    print_response(errbuf, buflen, TRUE);
                }
            } else {
                printf("error: get_response: InternetGetLastResponseInfo() returns error %d (buflen = %d)\n",
                   GetLastError(),
                   buflen
                   );
            }
            free(errbuf);
        }
    }
}

BOOL
quit(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    fQuit = TRUE;

    return TRUE;
}

BOOL
get(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszFilename;
    LPTSTR pszLocalfile;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("remote-name: "), &pszFilename)) {
            return FALSE;
        }
    } else {
        pszFilename = argv[1];
    }

    if (argc >= 3) {
        pszLocalfile = argv[2];
    } else {
        pszLocalfile = pszFilename;
    }

    ok = FtpGetFile(hFtpSession,
                    pszFilename,
                    pszLocalfile,
                    FALSE,
                    FILE_ATTRIBUTE_NORMAL,
                    CacheFlags
                    | FTP_TRANSFER_TYPE_BINARY,
                    FTPCAT_GET_CONTEXT
                    );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("get", "FtpGetFile()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpGetFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("get", "%sFtpGetFile()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
put(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszFilename;
    LPTSTR pszLocalfile;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("remote-name: "), &pszFilename)) {
            return FALSE;
        }
    } else {
        pszFilename = argv[1];
    }

    if (argc >= 3) {
        pszLocalfile = argv[2];
    } else {
        pszLocalfile = pszFilename;
    }

    ok = FtpPutFile(hFtpSession,
                    pszLocalfile,
                    pszFilename,
                    FTP_TRANSFER_TYPE_BINARY,
                    FTPCAT_PUT_CONTEXT
                    );
    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("put", "FtpPutFile()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpPutFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("put", "%sFtpPutFile()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
rename_file(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszTemp;
    LPTSTR pszOldFilename;
    LPTSTR pszNewFilename;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("Old name: "), &pszTemp)) {
            return FALSE;
        }

        pszOldFilename = lstrdup(pszTemp);

        if (pszOldFilename == NULL) {
            return FALSE;
        }
    } else {
        pszOldFilename = argv[1];
    }

    if (argc < 3) {
        if (!Prompt(TEXT("New name: "), &pszNewFilename)) {
            return FALSE;
        }
    } else {
        pszNewFilename = argv[2];
    }

    ok = FtpRenameFile(hFtpSession,
                       pszOldFilename,
                       pszNewFilename
                       );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("rename_file", "FtpRenameFile()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpRenameFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("rename_file", "%sFtpRenameFile()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    if (argc < 2) {
        LocalFree(pszOldFilename);
    }

    return ok;
}

BOOL
del(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszFilename;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("File name: "), &pszFilename)) {
            return FALSE;
        }
    } else {
        pszFilename = argv[1];
    }

    ok = FtpDeleteFile(hFtpSession, pszFilename);

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("del", "FtpDeleteFile()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpDeleteFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("del",
                    "%sFtpDeleteFile()",
                    AsyncMode ? "async " : ""
                    );
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
mkdir(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszDirname;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("Directory name: "), &pszDirname)) {
            return FALSE;
        }
    } else {
        pszDirname = argv[1];
    }

    ok = FtpCreateDirectory(hFtpSession,
                            pszDirname
                            );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("mkdir", "FtpCreateDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpCreateDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("mkdir", "%sFtpCreateDirectory()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
chdir(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszDirname;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("Directory name: "), &pszDirname)) {
            return FALSE;
        }
    } else {
        pszDirname = argv[1];
    }

    ok = FtpSetCurrentDirectory(hFtpSession,
                                pszDirname
                                );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("chdir", "FtpSetCurrentDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpSetCurrentDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("chdir", "%sFtpSetCurrentDirectory()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
rmdir(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszDirname;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("Directory name: "), &pszDirname)) {
            return FALSE;
        }
    } else {
        pszDirname = argv[1];
    }

    ok = FtpRemoveDirectory(hFtpSession,
                            pszDirname
                            );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("rmdir", "FtpRemoveDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpRemoveDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("rmdir", "%sFtpRemoveDirectory()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
dir(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    BOOL ok;
    WIN32_FIND_DATA ffd;
    SYSTEMTIME st;
    LPTSTR pszFileSpec;
    TCHAR EmptyExpression[] = "";
    HINTERNET hFind;
    HINTERNET hPrevious;
    static LPSTR month[] = {
        "",
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    };

    if (argc < 2) {
        pszFileSpec = EmptyExpression;
    } else {
        pszFileSpec = argv[1];
    }

    hFind = FtpFindFirstFileA(hFtpSession,
                              pszFileSpec,
                              &ffd,
                              CacheFlags,   // dwFlags
                              FTPCAT_FIND_CONTEXT
                              );

    if (AsyncMode && (hFind == NULL)) {
        if (GetLastError() == ERROR_IO_PENDING) {
            if (Verbose) {
                printf("waiting for async FtpFindFirstFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            hFind = (HINTERNET)AsyncResult;
            if (hFind == NULL) {
                SetLastError(AsyncError);
            }
        }
    }

    if (hFind == NULL) {
        print_error("dir", "%sFtpFindFirstFile()", AsyncMode ? "async " : "");
        return FALSE;
    }

    hPrevious = hCancel;
    hCancel = hFind;

    get_response(hFind);
    putchar('\n');

    ok = TRUE;
    while (ok) {
        if (!FileTimeToSystemTime(&ffd.ftLastWriteTime, &st)) {
            printf("| ftLastWriteTime = ERROR\n");
        }

        printf("%02d-%s-%04d %02d:%02d:%02d  %15d bytes %-s%-s%-s%-s%-s%-s %s\n",
               st.wDay,
               month[st.wMonth],
               st.wYear,
               st.wHour,
               st.wMinute,
               st.wSecond,
               ffd.nFileSizeLow,
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE)   ? "Archive   " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)    ? "Normal    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)    ? "System    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)    ? "Hidden    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)  ? "ReadOnly  " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? "Directory " : "",
               ffd.cFileName
               );

        if (UseQueryData) {

            DWORD error;
            DWORD avail;

            ok = InternetQueryDataAvailable(hFind, &avail, 0, 0);
            if (!ok) {
                error = GetLastError();
                if (error == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetQueryDataAvailable()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    SetLastError(AsyncError);
                }
            }
            if (!ok) {
                print_error("dir", "%sSYNC InternetQueryDataAvailable()", AsyncMode ? "A" : "");
                break;
            }

            if (Verbose) {
                printf("InternetQueryDataAvailable() returns %d available\n", avail);
            }

            if (avail == 0) {
                break;
            }
        }

        ok = InternetFindNextFile(hFind, &ffd);

        if (!ok && AsyncMode) {
            if (GetLastError() == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("waiting for async InternetFindNextFile()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                ok = (BOOL)AsyncResult;
                if (!ok) {
                    SetLastError(AsyncError);
                }
            }
        }

        if (!ok) {
            if (GetLastError() != ERROR_NO_MORE_FILES) {
                print_error("dir", "%sInternetFindNextFile()", AsyncMode ? "async " : "");
                break;
            }
        }
    }

    putchar('\n');

    close_handle(hFind);

    hCancel = hPrevious;

    return ok;
}

BOOL
pwd(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    BOOL ok;
    char* buf;
    DWORD len;

    len = 0;
    ok = FtpGetCurrentDirectory(hFtpSession, NULL, &len);

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("pwd", "async FtpGetCurrentDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpGetCurrentDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
            SetLastError(AsyncError);
        }
    }

    if (ok) {
        printf("error: FtpGetCurrentDirectory() w/ no buffer returns ok\n");
        return FALSE;
    } else if (Verbose) {
        printf("FtpGetCurrentDirectory() returns %d, %d bytes in cur dir\n",
               GetLastError(),
               len
               );
    }

    buf = (char*)malloc(len);

    ok = FtpGetCurrentDirectory(hFtpSession, buf, &len);

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("pwd", "async FtpGetCurrentDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpGetCurrentDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
            SetLastError(AsyncError);
        }
    }

    if (!ok) {
        print_error("pwd", "%sFtpGetCurrentDirectory()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
        lprintf(TEXT("Current directory: %s\n"), buf);
    }

    free(buf);

    return ok;
}

BOOL help(IN HINTERNET hFtpSession, IN int argc, IN PTCHAR argv[]) {

    int i;

    for (i = 0; Commands[i].pszCommand != NULL; ++i) {
        lprintf(TEXT("\t%s\t%s\n"),
                Commands[i].pszCommand,
                Commands[i].HelpText
                );
    }

    return TRUE;
}

#if DBG

BOOL CheckHandles(HINTERNET hFtpSession, int argc, PTCHAR argv[]) {
    printf("handle count = %d\n", GetProcessHandleCount());
    return TRUE;
}

#endif

BOOL lcd(HINTERNET hInternet, int argc, char** argv) {

    char curDir[MAX_PATH + 1];
    DWORD curDirLen;

    if (argc == 2) {
        if (!SetCurrentDirectory(argv[1])) {
            print_error("lcd", "SetCurrentDirectory()");
            return FALSE;
        }
    } else if (argc != 1) {
        printf("error: lcd: incorrect number of arguments\n");
        return FALSE;
    }

    curDirLen = sizeof(curDir);
    if (GetCurrentDirectory(curDirLen, curDir)) {
        printf("Current directory is %s\n", curDir);
        return TRUE;
    } else {
        print_error("lcd", "GetCurrentDirectory()");
        return FALSE;
    }
}

BOOL rb(HINTERNET hInternet, int argc, char** argv) {

    DWORD value;
    DWORD valueLength;

    if (argc > 1) {
        value = atoi(argv[1]);
        if (!InternetSetOption(hInternet,
                               INTERNET_OPTION_READ_BUFFER_SIZE,
                               (LPVOID)&value,
                               sizeof(DWORD)
                               )) {
            print_error("rb", "InternetSetOption()");
            return FALSE;
        }
    }
    valueLength = sizeof(value);
    if (InternetQueryOption(hInternet,
                            INTERNET_OPTION_READ_BUFFER_SIZE,
                            (LPVOID)&value,
                            &valueLength
                            )) {
        printf("Read buffer size = %d bytes\n", value);
        return TRUE;
    } else {
        print_error("rb", "InternetQueryOption()");
        return FALSE;
    }
}

BOOL wb(HINTERNET hInternet, int argc, char** argv) {

    DWORD value;
    DWORD valueLength;

    if (argc > 1) {
        value = atoi(argv[1]);
        if (!InternetSetOption(hInternet,
                               INTERNET_OPTION_WRITE_BUFFER_SIZE,
                               (LPVOID)&value,
                               sizeof(DWORD)
                               )) {
            print_error("wb", "InternetSetOption()");
            return FALSE;
        }
    }
    valueLength = sizeof(value);
    if (InternetQueryOption(hInternet,
                            INTERNET_OPTION_WRITE_BUFFER_SIZE,
                            (LPVOID)&value,
                            &valueLength
                            )) {
        printf("Write buffer size = %d bytes\n", value);
        return TRUE;
    } else {
        print_error("wb", "InternetQueryOption()");
        return FALSE;
    }
}

BOOL toggle_verbose(HINTERNET hInternet, int argc, PTCHAR * argv) {

    static DWORD PreviousVerbose = 0;

    if (Verbose) {
        PreviousVerbose = Verbose;
        Verbose = 0;
    } else {
        Verbose = PreviousVerbose;
        if (Verbose == 0) {
            Verbose = 1;
        }
    }
    printf("Verbose mode is o%s\n", Verbose ? "n" : "ff");
    return TRUE;
}

BOOL toggle_callback(HINTERNET hInternet, int argc, PTCHAR * argv) {

    INTERNET_STATUS_CALLBACK callback;

    if (PreviousCallback != NULL && PreviousCallback != my_callback) {
        printf("error: PreviousCallback %x not recognized\n", PreviousCallback);
    } else {
        PreviousCallback = InternetSetStatusCallback(hInternet, PreviousCallback);
        if (PreviousCallback == INTERNET_INVALID_STATUS_CALLBACK) {
            print_error("toggle_callback", "InternetSetStatusCallback()");
        } else if (PreviousCallback != NULL && PreviousCallback != my_callback) {
            printf("error: PreviousCallback %x not recognized\n", PreviousCallback);
        } else if (Verbose) {
            printf("callback toggled Ok\n");
        }
    }

    printf("Verbose mode is o%s\n", Verbose ? "n" : "ff");
    return TRUE;
}

BOOL dbgbreak(HINTERNET hInternet, int argc, PTCHAR * argv) {
    DebugBreak();
    return TRUE;
}

BOOL set_type(HINTERNET hInternet, int argc, PTCHAR * argv) {
    return TRUE;
}

BOOL open_file(HINTERNET hInternet, int argc, PTCHAR * argv) {

    HINTERNET hFile;
    BOOL bOk;

    if (argc < 2) {
        printf("error: required filename missing\n");
        return FALSE;
    }
    hFile = FtpOpenFile(hInternet,
                        argv[1],
                        GENERIC_READ,
                        0,
                        AsyncMode ? FTPCAT_OPEN_CONTEXT : 0
                        );
    if (AsyncMode && !hFile) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("open_file", "async FtpOpenFile()");
            return FALSE;
        }
        if (Verbose) {
            printf("waiting for async FtpOpenFile()...\n");
        }
        WaitForSingleObject(AsyncEvent, INFINITE);
        hFile = (HINTERNET)AsyncResult;
        SetLastError(AsyncError);
    }
    if (!hFile) {
        print_error("open_file", "%sFtpOpenFile()", AsyncMode ? "async " : "");
    } else {
        get_response(hInternet);
        printf("returned handle is %#x\n", hFile);
    }
    return hFile != NULL;
}

BOOL close_file(HINTERNET hInternet, int argc, PTCHAR * argv) {

    HINTERNET hFile;
    BOOL bOk;

    if (argc < 2) {
        printf("error: required handle missing\n");
        return FALSE;
    }
    hFile = (HINTERNET)strtol(argv[1], NULL, 0);
    bOk = InternetCloseHandle(hFile);
    if (!bOk) {
        print_error("close_file", "InternetCloseHandle()");
    } else if (Verbose) {
        printf("handle %#x closed OK\n", hFile);
    }
    return bOk;
}

BOOL read_file(HINTERNET hInternet, int argc, PTCHAR * argv) {
    return TRUE;
}

BOOL write_file(HINTERNET hInternet, int argc, PTCHAR * argv) {
    return TRUE;
}

BOOL
DispatchCommand(
    IN LPTSTR pszCommand,
    IN HINTERNET hFtpSession
    )
{
    COMMAND_ENTRY *pce;
    PTCHAR ArgV[MAX_ARGV];
    int index;
    int state;

    if (*pszCommand == TEXT('!')) {

        LPSTR shellPath;

        shellPath = getenv("COMSPEC");
        if (shellPath == NULL) {
            printf("error: COMSPEC environment variable not set\n");
            return FALSE;
        }

        ++pszCommand;
        while (isspace(*pszCommand)) {
            ++pszCommand;
        }

        if (*pszCommand != TEXT('\0')) {
            _spawnlp(_P_WAIT, shellPath, "/C", pszCommand, NULL);
        } else {
            printf("\nSpawning command interpreter. Type \"exit\" to return to FTP\n\n");
            _spawnlp(_P_WAIT, shellPath, "/K", NULL);
            putchar('\n');
        }
        return TRUE;
    }

    state = 0;
    index = 0;

    while (*pszCommand) {
        switch (state) {
        case 0:
            if (!isspace(*pszCommand)) {
                if (*pszCommand == '"') {
                    state = 2;
                } else {
                    state = 1;
                }
                ArgV[index++] = (state == 2) ? (pszCommand + 1) : pszCommand;
            }
            break;

        case 1:
            if (isspace(*pszCommand)) {
                *pszCommand = '\0';
                state = 0;
            }
            break;

        case 2:
            if (*pszCommand == '"') {
                *pszCommand = '\0';
                state = 0;
            }
            break;
        }
        ++pszCommand;
    }

    if (index == 0) {
        return FALSE;
    }

    for (pce = Commands; pce->pszCommand != NULL; pce++) {
        if (lstrcmpi(pce->pszCommand, ArgV[0]) == 0) {
            return pce->fn(hFtpSession, index, ArgV);
        }
    }

    if (!lstrcmpi(ArgV[0], "q")) {
        return quit(hFtpSession, index, ArgV);
    }

    printf("error: unrecognized command: \"%s\"\n", ArgV[0]);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\test\ftpcat\error.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    error.c

Abstract:

    Wininet error handlers

Author:

    Richard L Firth (rfirth) 03-Nov-1995

Revision History:

    03-Nov-1995 rfirth
        Created

--*/

#include "ftpcatp.h"

//
// data
//

BOOL NoAlerts = TRUE;

//
// external data
//

extern BOOL Verbose;

//
// private prototypes
//

LPSTR get_error_string(DWORD);

//
// functions
//

void print_error(char* func, char* format, ...) {

    va_list argptr;
    char buf[256];
    DWORD error;

    error = GetLastError();
    va_start(argptr, format);
    vsprintf(buf, format, argptr);
    printf("error: %s: %s returns %d [%s]\n", func, buf, error, map_error(error));
    va_end(argptr);
    if (error == ERROR_INTERNET_EXTENDED_ERROR) {
        get_last_internet_error();
    }
}

#define ERROR_CASE(error)  case error: return # error

char* map_error(DWORD error) {
    switch (error) {

    //
    // Windows base errors
    //

    ERROR_CASE(ERROR_SUCCESS);
    ERROR_CASE(ERROR_INVALID_FUNCTION);
    ERROR_CASE(ERROR_FILE_NOT_FOUND);
    ERROR_CASE(ERROR_PATH_NOT_FOUND);
    ERROR_CASE(ERROR_ACCESS_DENIED);
    ERROR_CASE(ERROR_INVALID_HANDLE);
    ERROR_CASE(ERROR_NOT_ENOUGH_MEMORY);
    ERROR_CASE(ERROR_NO_MORE_FILES);
    ERROR_CASE(ERROR_INVALID_PASSWORD);
    ERROR_CASE(ERROR_INVALID_PARAMETER);
    ERROR_CASE(ERROR_BUFFER_OVERFLOW);
    ERROR_CASE(ERROR_NO_MORE_SEARCH_HANDLES);
    ERROR_CASE(ERROR_INVALID_TARGET_HANDLE);
    ERROR_CASE(ERROR_CALL_NOT_IMPLEMENTED);
    ERROR_CASE(ERROR_INSUFFICIENT_BUFFER);
    ERROR_CASE(ERROR_INVALID_NAME);
    ERROR_CASE(ERROR_INVALID_LEVEL);
    ERROR_CASE(ERROR_BAD_PATHNAME);
    ERROR_CASE(ERROR_BUSY);
    ERROR_CASE(ERROR_ALREADY_EXISTS);
    ERROR_CASE(ERROR_FILENAME_EXCED_RANGE);
    ERROR_CASE(ERROR_MORE_DATA);
    ERROR_CASE(ERROR_NO_MORE_ITEMS);
    ERROR_CASE(ERROR_INVALID_ADDRESS);
    ERROR_CASE(ERROR_OPERATION_ABORTED);
    ERROR_CASE(ERROR_IO_PENDING);
    ERROR_CASE(RPC_S_INVALID_STRING_BINDING);
    ERROR_CASE(RPC_S_WRONG_KIND_OF_BINDING);
    ERROR_CASE(RPC_S_INVALID_BINDING);
    ERROR_CASE(RPC_S_PROTSEQ_NOT_SUPPORTED);
    ERROR_CASE(RPC_S_INVALID_RPC_PROTSEQ);
    ERROR_CASE(RPC_S_INVALID_STRING_UUID);
    ERROR_CASE(RPC_S_INVALID_ENDPOINT_FORMAT);
    ERROR_CASE(RPC_S_INVALID_NET_ADDR);
    ERROR_CASE(RPC_S_NO_ENDPOINT_FOUND);
    ERROR_CASE(RPC_S_INVALID_TIMEOUT);
    ERROR_CASE(RPC_S_OBJECT_NOT_FOUND);
    ERROR_CASE(RPC_S_ALREADY_REGISTERED);
    ERROR_CASE(RPC_S_TYPE_ALREADY_REGISTERED);
    ERROR_CASE(RPC_S_ALREADY_LISTENING);
    ERROR_CASE(RPC_S_NO_PROTSEQS_REGISTERED);
    ERROR_CASE(RPC_S_NOT_LISTENING);
    ERROR_CASE(RPC_S_UNKNOWN_MGR_TYPE);
    ERROR_CASE(RPC_S_UNKNOWN_IF);
    ERROR_CASE(RPC_S_NO_BINDINGS);
    ERROR_CASE(RPC_S_NO_PROTSEQS);
    ERROR_CASE(RPC_S_CANT_CREATE_ENDPOINT);
    ERROR_CASE(RPC_S_OUT_OF_RESOURCES);
    ERROR_CASE(RPC_S_SERVER_UNAVAILABLE);
    ERROR_CASE(RPC_S_SERVER_TOO_BUSY);
    ERROR_CASE(RPC_S_INVALID_NETWORK_OPTIONS);
    ERROR_CASE(RPC_S_NO_CALL_ACTIVE);
    ERROR_CASE(RPC_S_CALL_FAILED);
    ERROR_CASE(RPC_S_CALL_FAILED_DNE);
    ERROR_CASE(RPC_S_PROTOCOL_ERROR);
    ERROR_CASE(RPC_S_UNSUPPORTED_TRANS_SYN);
    ERROR_CASE(RPC_S_UNSUPPORTED_TYPE);
    ERROR_CASE(RPC_S_INVALID_TAG);
    ERROR_CASE(RPC_S_INVALID_BOUND);
    ERROR_CASE(RPC_S_NO_ENTRY_NAME);
    ERROR_CASE(RPC_S_INVALID_NAME_SYNTAX);
    ERROR_CASE(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    ERROR_CASE(RPC_S_UUID_NO_ADDRESS);
    ERROR_CASE(RPC_S_DUPLICATE_ENDPOINT);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_TYPE);
    ERROR_CASE(RPC_S_MAX_CALLS_TOO_SMALL);
    ERROR_CASE(RPC_S_STRING_TOO_LONG);
    ERROR_CASE(RPC_S_PROTSEQ_NOT_FOUND);
    ERROR_CASE(RPC_S_PROCNUM_OUT_OF_RANGE);
    ERROR_CASE(RPC_S_BINDING_HAS_NO_AUTH);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_SERVICE);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_LEVEL);
    ERROR_CASE(RPC_S_INVALID_AUTH_IDENTITY);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    ERROR_CASE(EPT_S_INVALID_ENTRY);
    ERROR_CASE(EPT_S_CANT_PERFORM_OP);
    ERROR_CASE(EPT_S_NOT_REGISTERED);
    ERROR_CASE(RPC_S_NOTHING_TO_EXPORT);
    ERROR_CASE(RPC_S_INCOMPLETE_NAME);
    ERROR_CASE(RPC_S_INVALID_VERS_OPTION);
    ERROR_CASE(RPC_S_NO_MORE_MEMBERS);
    ERROR_CASE(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    ERROR_CASE(RPC_S_INTERFACE_NOT_FOUND);
    ERROR_CASE(RPC_S_ENTRY_ALREADY_EXISTS);
    ERROR_CASE(RPC_S_ENTRY_NOT_FOUND);
    ERROR_CASE(RPC_S_NAME_SERVICE_UNAVAILABLE);
    ERROR_CASE(RPC_S_INVALID_NAF_ID);
    ERROR_CASE(RPC_S_CANNOT_SUPPORT);
    ERROR_CASE(RPC_S_NO_CONTEXT_AVAILABLE);
    ERROR_CASE(RPC_S_INTERNAL_ERROR);
    ERROR_CASE(RPC_S_ZERO_DIVIDE);
    ERROR_CASE(RPC_S_ADDRESS_ERROR);
    ERROR_CASE(RPC_S_FP_DIV_ZERO);
    ERROR_CASE(RPC_S_FP_UNDERFLOW);
    ERROR_CASE(RPC_S_FP_OVERFLOW);
    ERROR_CASE(RPC_X_NO_MORE_ENTRIES);
    ERROR_CASE(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    ERROR_CASE(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    ERROR_CASE(RPC_X_SS_IN_NULL_CONTEXT);
    ERROR_CASE(RPC_X_SS_CONTEXT_DAMAGED);
    ERROR_CASE(RPC_X_SS_HANDLES_MISMATCH);
    ERROR_CASE(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    ERROR_CASE(RPC_X_NULL_REF_POINTER);
    ERROR_CASE(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    ERROR_CASE(RPC_X_BYTE_COUNT_TOO_SMALL);
    ERROR_CASE(RPC_X_BAD_STUB_DATA);


    //
    // WinInet errors
    //

    ERROR_CASE(ERROR_INTERNET_OUT_OF_HANDLES);
    ERROR_CASE(ERROR_INTERNET_TIMEOUT);
    ERROR_CASE(ERROR_INTERNET_EXTENDED_ERROR);
    ERROR_CASE(ERROR_INTERNET_INTERNAL_ERROR);
    ERROR_CASE(ERROR_INTERNET_INVALID_URL);
    ERROR_CASE(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    ERROR_CASE(ERROR_INTERNET_NAME_NOT_RESOLVED);
    ERROR_CASE(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    ERROR_CASE(ERROR_INTERNET_INVALID_OPTION);
    ERROR_CASE(ERROR_INTERNET_BAD_OPTION_LENGTH);
    ERROR_CASE(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    ERROR_CASE(ERROR_INTERNET_SHUTDOWN);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_USER_NAME);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_PASSWORD);
    ERROR_CASE(ERROR_INTERNET_LOGIN_FAILURE);
    ERROR_CASE(ERROR_INTERNET_INVALID_OPERATION);
    ERROR_CASE(ERROR_INTERNET_OPERATION_CANCELLED);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    ERROR_CASE(ERROR_INTERNET_NOT_PROXY_REQUEST);
    ERROR_CASE(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    ERROR_CASE(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    ERROR_CASE(ERROR_INTERNET_NO_DIRECT_ACCESS);
    ERROR_CASE(ERROR_INTERNET_CONNECTION_BUSY);
    ERROR_CASE(ERROR_INTERNET_NO_CONTEXT);
    ERROR_CASE(ERROR_INTERNET_NO_CALLBACK);
    ERROR_CASE(ERROR_INTERNET_ASYNC_REQUEST_PENDING);

    ERROR_CASE(ERROR_FTP_TRANSFER_IN_PROGRESS);
    ERROR_CASE(ERROR_FTP_DROPPED);

    ERROR_CASE(ERROR_GOPHER_PROTOCOL_ERROR);
    ERROR_CASE(ERROR_GOPHER_NOT_FILE);
    ERROR_CASE(ERROR_GOPHER_DATA_ERROR);
    ERROR_CASE(ERROR_GOPHER_END_OF_DATA);
    ERROR_CASE(ERROR_GOPHER_INVALID_LOCATOR);
    ERROR_CASE(ERROR_GOPHER_INCORRECT_LOCATOR_TYPE);
    ERROR_CASE(ERROR_GOPHER_NOT_GOPHER_PLUS);
    ERROR_CASE(ERROR_GOPHER_ATTRIBUTE_NOT_FOUND);
    ERROR_CASE(ERROR_GOPHER_UNKNOWN_LOCATOR);

    ERROR_CASE(ERROR_HTTP_HEADER_NOT_FOUND);
    ERROR_CASE(ERROR_HTTP_DOWNLEVEL_SERVER);
    ERROR_CASE(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    ERROR_CASE(ERROR_HTTP_NO_KEEP_ALIVE);


    //
    // Windows sockets errors
    //

    ERROR_CASE(WSAEINTR);
    ERROR_CASE(WSAEBADF);
    ERROR_CASE(WSAEACCES);
    ERROR_CASE(WSAEFAULT);
    ERROR_CASE(WSAEINVAL);
    ERROR_CASE(WSAEMFILE);
    ERROR_CASE(WSAEWOULDBLOCK);
    ERROR_CASE(WSAEINPROGRESS);
    ERROR_CASE(WSAEALREADY);
    ERROR_CASE(WSAENOTSOCK);
    ERROR_CASE(WSAEDESTADDRREQ);
    ERROR_CASE(WSAEMSGSIZE);
    ERROR_CASE(WSAEPROTOTYPE);
    ERROR_CASE(WSAENOPROTOOPT);
    ERROR_CASE(WSAEPROTONOSUPPORT);
    ERROR_CASE(WSAESOCKTNOSUPPORT);
    ERROR_CASE(WSAEOPNOTSUPP);
    ERROR_CASE(WSAEPFNOSUPPORT);
    ERROR_CASE(WSAEAFNOSUPPORT);
    ERROR_CASE(WSAEADDRINUSE);
    ERROR_CASE(WSAEADDRNOTAVAIL);
    ERROR_CASE(WSAENETDOWN);
    ERROR_CASE(WSAENETUNREACH);
    ERROR_CASE(WSAENETRESET);
    ERROR_CASE(WSAECONNABORTED);
    ERROR_CASE(WSAECONNRESET);
    ERROR_CASE(WSAENOBUFS);
    ERROR_CASE(WSAEISCONN);
    ERROR_CASE(WSAENOTCONN);
    ERROR_CASE(WSAESHUTDOWN);
    ERROR_CASE(WSAETOOMANYREFS);
    ERROR_CASE(WSAETIMEDOUT);
    ERROR_CASE(WSAECONNREFUSED);
    ERROR_CASE(WSAELOOP);
    ERROR_CASE(WSAENAMETOOLONG);
    ERROR_CASE(WSAEHOSTDOWN);
    ERROR_CASE(WSAEHOSTUNREACH);
    ERROR_CASE(WSAENOTEMPTY);
    ERROR_CASE(WSAEPROCLIM);
    ERROR_CASE(WSAEUSERS);
    ERROR_CASE(WSAEDQUOT);
    ERROR_CASE(WSAESTALE);
    ERROR_CASE(WSAEREMOTE);
    ERROR_CASE(WSAEDISCON);
    ERROR_CASE(WSASYSNOTREADY);
    ERROR_CASE(WSAVERNOTSUPPORTED);
    ERROR_CASE(WSANOTINITIALISED);
    ERROR_CASE(WSAHOST_NOT_FOUND);
    ERROR_CASE(WSATRY_AGAIN);
    ERROR_CASE(WSANO_RECOVERY);
    ERROR_CASE(WSANO_DATA);

    default:
        return "?";
    }
}

void get_last_internet_error() {

    DWORD buflen;
    char buffer[256];
    DWORD category;

    buflen = sizeof(buffer);
    if (InternetGetLastResponseInfo(&category, buffer, &buflen)) {
        print_response(buffer, buflen, FALSE);
    } else {

        DWORD error;

        error = GetLastError();
        if (Verbose || (error != ERROR_INSUFFICIENT_BUFFER)) {
            printf(get_error_string(error), error, buflen);
        }
        if (error == ERROR_INSUFFICIENT_BUFFER) {

            LPSTR errbuf;

            if ((errbuf = malloc(buflen)) != NULL) {
                if (InternetGetLastResponseInfo(&category, errbuf, &buflen)) {
                    print_response(errbuf, buflen, FALSE);
                } else {
                    error = GetLastError();
                    printf(get_error_string(GetLastError()), error, buflen);
                }
                free(errbuf);
            } else {
                printf("error: get_last_internet_error: malloc(%d) failed\n", buflen);
            }
        }
    }
}

LPSTR get_error_string(DWORD error) {

    static LPSTR errText_1 = "error: get_last_internet_error: InternetGetLastResponseInfo() returns error %d (buflen = %d)\n";
    static LPSTR errText_2 = "error: get_last_internet_error: InternetGetLastResponseInfo() returns error %d\n";

    return (error == ERROR_INSUFFICIENT_BUFFER) ? errText_1 : errText_2;
}

void print_response(LPSTR buffer, DWORD buflen, BOOL isMessage) {
    if (Verbose || !isMessage) {
        printf("InternetGetLastResponseInfo() returns %d bytes\n", buflen);
    }
    if (buflen != 0) {
        if (isMessage) {

            int mode;

            mode = _setmode(1, _O_BINARY);
            write(1, buffer, buflen);
            _setmode(1, mode);
        } else {
            printf("Text = \"%s\"\n", buffer);
        }
    }
    if (strlen(buffer) != buflen) {
        alert();
        printf("error: print_response: InternetGetLastResponseInfo(): buflen = %d; strlen(buffer) = %d\n",
                buflen,
                strlen(buffer)
                );
    }
}

void alert() {
    if (!NoAlerts) {
        putchar('\a');
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\test\multfind\multfind.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
void usage(void);

void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET h1;
    HINTERNET h2;
    HINTERNET h3;
    HINTERNET h4;
    LPSTR search;

    search = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case 'v':
                printf("Ha! There is no verbose mode, sucker. Try again\n");
                break;

            default:
                printf("error: unrecognized command line flag '%c'\n", **argv);
                usage();
            }
        } else if (!search) {
            search = *argv;
        } else {
            printf("error: unrecognized command line argument \"%s\"\n", *argv);
            usage();
        }
    }

    h1 = InternetOpen("multfind", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (!h1) {
        printf("error: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    }

    h2 = InternetConnect(h1,
                         "rfirthmips",
                         0,
                         NULL,
                         NULL,
                         INTERNET_SERVICE_FTP,
                         0,
                         0
                         );
    if (!h2) {
        printf("error: InternetConnect() returns %d\n", GetLastError());
        exit(1);
    }

    h3 = FtpFindFirstFile(h2, search, NULL, INTERNET_FLAG_RELOAD, 0);
    if (!h3) {
        printf("error: FtpFindFirstFile() #1 returns %d\n", GetLastError());
        exit(1);
    }

    //
    // try simultaneous search for same thing - should fail
    //

    h4 = FtpFindFirstFile(h2, search, NULL, INTERNET_FLAG_RELOAD, 0);
    if (h4) {
        printf("error: FtpFindFirstFile() #2 returns OK\n");
        exit(1);
    } else {
        printf("FtpFindFirstFile() #2 returns %d\n", GetLastError());
    }

    //
    // close first handle and try again - should succeed
    //

    if (!InternetCloseHandle(h3)) {
        printf("error: InternetCloseHandle() returns %d\n", GetLastError());
    }

    h3 = FtpFindFirstFile(h2, search, NULL, INTERNET_FLAG_RELOAD, 0);
    if (!h3) {
        printf("error: FtpFindFirstFile() returns %d\n", GetLastError());
        exit(1);
    }

    //
    // try a second time again - should fail again
    //

    h4 = FtpFindFirstFile(h2, search, NULL, INTERNET_FLAG_RELOAD, 0);
    if (h4) {
        printf("error: FtpFindFirstFile() #2 returns OK\n");
        exit(1);
    } else {
        printf("FtpFindFirstFile() #2 returns %d\n", GetLastError());
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: multfind [-v] [search argument]\n"
           "where: -v = Verbose mode\n"
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\test\ftpszcls\ftpszcls.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpszcls.cxx

Abstract:

    Tests FTP abort during FtpGetFileSize(). Ensure we overcome IE5 bug #71219

Author:

    Richard L Firth (rfirth) 09-Feb-1999

Revision History:

    09-Feb-1999 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))
#define SESSION_CONTEXT 0x01010101
#define FILE_CONTEXT    0x02020202

void _CRTAPI1 main(int, char**);
void usage(void);
VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    );

BOOL Verbose = FALSE;

void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET hInternet;
    HINTERNET hFtpSession;
    HINTERNET hFile;
    char server[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    char username[INTERNET_MAX_USER_NAME_LENGTH];
    char password[INTERNET_MAX_PASSWORD_LENGTH];
    LPSTR filename = NULL;
    DWORD accessMethod = INTERNET_OPEN_TYPE_PRECONFIG;
    BOOL expectingProxyServer = FALSE;
    LPSTR proxyServer = NULL;
    LPSTR pszUrl = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();

            case 'a':
                ++*argv;
                if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                } else if (**argv == 'd') {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else {
                    if (**argv) {
                        printf("error: unrecognised access type: '%c'\n", **argv);
                    } else {
                        printf("error: missing access type\n");
                    }
                    usage();
                }
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxyServer) {
            proxyServer = *argv;
            expectingProxyServer = FALSE;
        } else if (!pszUrl) {
            pszUrl = *argv;
        }
    }

    if (!pszUrl) {
        printf("error: must supply file URL\n");
        usage();
    }

    URL_COMPONENTS urlbits;

    memset(&urlbits, 0, sizeof(urlbits));
    urlbits.dwStructSize = sizeof(urlbits);
    urlbits.lpszHostName = (LPSTR)server;
    urlbits.dwHostNameLength = (DWORD)-1;
    urlbits.lpszUserName = (LPSTR)username;
    urlbits.dwUserNameLength = (DWORD)-1;
    urlbits.lpszPassword = (LPSTR)password;
    urlbits.dwPasswordLength = (DWORD)-1;
    urlbits.dwUrlPathLength = (DWORD)-1;

    BOOL ok;

    ok = InternetCrackUrl(pszUrl, (DWORD)-1, 0, &urlbits);
    if (!ok) {
        print_error("ftpszcls()", "InternetCrackUrl()");
        exit(1);
    }

    hInternet = InternetOpen("ftpszcls",
                             accessMethod,
                             proxyServer,
                             NULL,
                             0);
    if (!hInternet) {
        print_error("ftpszcls()", "InternetOpen()");
        exit(1);
    } else if (Verbose) {
        printf("opened Internet handle %#x\n", hInternet);
    }

    hFtpSession = InternetConnect(hInternet,
                                  server,
                                  INTERNET_INVALID_PORT_NUMBER,
                                  username,
                                  password,
                                  INTERNET_SERVICE_FTP,
                                  0,
                                  SESSION_CONTEXT
                                  );
    if (!hFtpSession) {
        print_error("ftpszcls()", "InternetConnect()");
        InternetCloseHandle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("opened FTP connect handle %#x\n", hFtpSession);
    }

    filename = urlbits.lpszUrlPath;

    hFile = FtpOpenFile(hFtpSession,
                        filename,
                        GENERIC_READ,
                        FTP_TRANSFER_TYPE_BINARY,
                        FILE_CONTEXT
                        );
    if (!hFile) {
        print_error("ftpszcls()", "FtpOpenFile(%s)", filename);
        InternetCloseHandle(hFtpSession);
        InternetCloseHandle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("opened FTP File handle %#x\n", hFile);
    }

    InternetSetStatusCallback(hInternet, my_callback);

    DWORD dwFileSizeLow, dwFileSizeHigh;

    //
    // force TLS handle value to be not FTP file handle object
    //

    HINTERNET hInternet2;

    hInternet2 = InternetOpen("ftpszcls",
                              INTERNET_OPEN_TYPE_PRECONFIG,
                              NULL,
                              NULL,
                              0
                              );
    InternetCloseHandle(hInternet2);

    //
    // get the size of the FTP file. Buggy wininet now has TLS handle and
    // mapped handle values set to hInternet2
    //

    dwFileSizeLow = FtpGetFileSize(hFile, &dwFileSizeHigh);

    if (dwFileSizeLow == (DWORD)-1) {
        print_error("ftpszcls()", "FtpGetFileSize()");
        exit(1);
    } else if (Verbose) {
        printf("size of \"%s\" is %d\n", pszUrl, dwFileSizeLow);
    }

    InternetCloseHandle(hFile);
    InternetCloseHandle(hFtpSession);
    InternetCloseHandle(hInternet);

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("\n"
           "usage: ftpszcls [-a{d|p}] [-v] fileURL\n"
           "\n"
           "where:  -a = Access mode: d = direct; p = proxy. Default is pre-config\n"
           "        -v = Verbose mode\n"
           );
    exit(1);
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        //hCancel = *(LPHINTERNET)Info;
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        //AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        //AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                Handle,
                Context,
                (Context == SESSION_CONTEXT) ? "Session"
                : (Context == FILE_CONTEXT) ? "File"
                : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {
                printf("%x", *(LPHINTERNET)Info);
            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else {
                printf((LPSTR)Info);
            }
        }
        putchar('\n');
    }
    //if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
    //    get_response(Handle);
    //    if (AsyncMode) {
    //        SetEvent(AsyncEvent);
    //    } else {
    //        printf("error: INTERNET_STATUS_REQUEST_COMPLETE returned. Not async\n");
    //    }
    //}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\test\ftpcat\ftpcatp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpcatp.h

Abstract:

    (Precompiled) Header file for ftpcat

Author:

    Richard L Firth (rfirth) 03-Nov-1995

Revision History:

    03-Nov-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <io.h>
#include <fcntl.h>
#include <signal.h>
#include <conio.h>
#include <process.h>
#include <windows.h>
#include <wininet.h>
#include <wininetd.h>
#include <catlib.h>

#ifdef UNICODE

#include <wchar.h>
#define lstrtok(s,t)    wcstok((s),(t))
#define lstrchr(s,c)    wcschr((s),(c))
#define lstrdup(s)      wcsdup((s))

#define lprintf             wprintf

#else

#include <string.h>
#define lstrtok(s,t)    strtok((s),(t))
#define lstrchr(s,c)    strchr((s),(c))
#define lstrdup(s)      _strdup((s))

#define lprintf             printf

#endif // UNICODE


#define nelems(a) ((sizeof(a))/sizeof((a)[0]))

extern DWORD GetProcessHandleCount(void);

//
// manifests
//

#define FTPCAT_CONNECT_CONTEXT  0x1
#define FTPCAT_FIND_CONTEXT     0x2
#define FTPCAT_FILE_CONTEXT     0x3
#define FTPCAT_GET_CONTEXT      0x4
#define FTPCAT_PUT_CONTEXT      0x5
#define FTPCAT_COMMAND_CONTEXT  0x6
#define FTPCAT_OPEN_CONTEXT     0x7

//
// prototypes
//

//
// ftpcat.c
//

void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);
void close_handle(HINTERNET);

//
// cmds.c
//

void get_response(HINTERNET hFtpSession);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ftp\test\ftpclose\ftpclose.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpclose.c

Abstract:

    Tests FTP open/read/close. Main purpose is to make sure we do the right
    thing with ABOR

Author:

    Richard L Firth (rfirth) 11-Oct-1995

Revision History:

    11-Oct-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#define DEFAULT_BUFFER_SIZE 1024

void _CRTAPI1 main(int, char**);
void usage(void);

BOOL Verbose = FALSE;

void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET hInternet;
    HINTERNET hFtpSession;
    HINTERNET hFile;
    LPSTR server = NULL;
    LPSTR username = NULL;
    LPSTR password = NULL;
    LPSTR filename = NULL;
    LPBYTE buffer;
    int buflen = DEFAULT_BUFFER_SIZE;
    DWORD bytesRead;
    DWORD totalBytes;
    DWORD closeAfter = 0xffffffff;
    DWORD accessMethod = INTERNET_OPEN_TYPE_PRECONFIG;
    BOOL expectingProxyServer = FALSE;
    LPSTR proxyServer = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'a':
                ++*argv;
                if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                    if (*++*argv) {
                        proxyServer = *argv;
                    } else {
                        expectingProxyServer = TRUE;
                    }
                } else if (**argv == 'l') {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else {
                    if (**argv) {
                        printf("error: unrecognised access type: '%c'\n", **argv);
                    } else {
                        printf("error: missing access type\n");
                    }
                    usage();
                }
                break;

            case 'b':
                buflen = atoi(++*argv);
                break;

            case 'f':
                filename = ++*argv;
                break;

            case 'n':
                closeAfter = (DWORD)atoi(++*argv);
                break;

            case 'p':
                password = ++*argv;
                break;

            case 's':
                server = ++*argv;
                break;

            case 'u':
                username = ++*argv;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxyServer) {
            proxyServer = *argv;
            expectingProxyServer = FALSE;
        }
    }

    if (!server) {
        printf("error: must supply server name\n");
        usage();
    }

    if (!filename) {
        printf("error: must supply file name\n");
        usage();
    }

    hInternet = InternetOpen("ftpclose",
                             accessMethod,
                             proxyServer,
                             NULL,
                             0);
    if (!hInternet) {
        printf("error: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    } else if (Verbose) {
        printf("opened Internet handle %x\n", hInternet);
    }

    hFtpSession = InternetConnect(hInternet,
                                  server,
                                  INTERNET_INVALID_PORT_NUMBER,
                                  username,
                                  password,
                                  INTERNET_SERVICE_FTP,
                                  0,
                                  0
                                  );
    if (!hFtpSession) {
        printf("error: InternetConnect() returns %d\n", GetLastError());
        InternetCloseHandle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("opened FTP connect handle %x\n", hFtpSession);
    }

    hFile = FtpOpenFile(hFtpSession,
                        filename,
                        GENERIC_READ,
                        FTP_TRANSFER_TYPE_BINARY,
                        0,
                        0
                        );
    if (!hFile) {
        printf("error: FtpOpenFile(%s) returns %d\n", filename, GetLastError());
        InternetCloseHandle(hFtpSession);
        InternetCloseHandle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("opened FTP File handle %x\n", hFile);
    }

    buffer = (LPBYTE)malloc(buflen);
    if (!buffer) {
        printf("error: failed to allocate %u bytes\n", buflen);
        InternetCloseHandle(hFile);
        InternetCloseHandle(hFtpSession);
        InternetCloseHandle(hInternet);
        exit(1);
    }

    if (closeAfter == 0) {
        if (Verbose) {
            printf("not reading file (close after 0)\n");
        }
    } else {
        if (Verbose) {
            printf("reading file %s", filename);
            if (closeAfter != 0xffffffff) {
                printf(" closing after %d bytes", closeAfter);
            }
            putchar('\n');
        }

        totalBytes = 0;
        while (InternetReadFile(hFile, buffer, buflen, &bytesRead)) {
            if (Verbose) {
                printf("read %d bytes\n", bytesRead);
            }
            if (bytesRead == 0) {
                break;
            }
            totalBytes += bytesRead;
            if (totalBytes >= closeAfter) {
                break;
            }
        }

        if (GetLastError() != ERROR_SUCCESS) {
            printf("error: InternetReadFile() returns %d\n", GetLastError());
            InternetCloseHandle(hFile);
            InternetCloseHandle(hFtpSession);
            InternetCloseHandle(hInternet);
            exit(1);
        }

        if (Verbose) {
            printf("%d bytes read\n", totalBytes);
        }
    }

    InternetCloseHandle(hFile);
    InternetCloseHandle(hFtpSession);
    InternetCloseHandle(hInternet);

    exit(0);
}

void usage() {
    printf("\n"
           "usage: ftpclose [-a{l|p}] [-b#] [-v] [-n#] <-sserver> [-uuser] [-ppassword]\n"
           "                <-ffile>\n"
           "\n"
           "where:  -a = Access mode: l = local; p = proxy\n"
           "        -b = Buffer size. Default is %d\n"
           "        -n = Number of bytes to read before closing file. Default is all\n"
           "        -p = Password (with -u)\n"
           "        -s = FTP server\n"
           "        -u = User name\n"
           "        -v = Verbose mode\n",
           DEFAULT_BUFFER_SIZE
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\buffer.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    Contains manifests, macros, types and typedefs for buffer.c

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

//
// LOOK_AHEAD_LENGTH - read enough characters to comprise the maximum (32-bit)
// length returned by gopher+
//

#define LOOK_AHEAD_LENGTH   sizeof("+4294967296\r\n")   // 12

//
// BUFFER_INFO - structure maintains information about responses from gopher
// server. The same data can be shared amongst many requests
//

typedef struct {

    //
    // ReferenceCount - number of VIEW_INFO structures referencing this buffer
    //

    LONG ReferenceCount;

    //
    // Flags - information about the buffer
    //

    DWORD Flags;

    //
    // RequestEvent - the owner of this event is the only thread which can
    // make the gopher request that creates this buffer info. All other
    // requesters for the same information wait for the first thread to signal
    // the event, then just read the data returned by the first thread
    //

//    HANDLE RequestEvent;

    //
    // RequestWaiters - used in conjunction with RequestEvent. If this field
    // is 0 by the time the initial requester thread comes to signal the
    // event, it can do away with the event altogether, since it was only
    // required to stop those other threads from making a redundant request
    //

//    DWORD RequestWaiters;

    //
    // ConnectedSocket - contains socket we are using to receive the data in
    // the buffer, and the index into the parent SESSION_INFO's
    // ADDRESS_INFO_LIST of the address used to connect the socket
    //

//    CONNECTED_SOCKET ConnectedSocket;
    ICSocket * Socket;

    //
    // ResponseLength - the response length as told to us by the gopher+ server
    //

    int ResponseLength;

    //
    // BufferLength - length of Buffer
    //

    DWORD BufferLength;

    //
    // Buffer - containing response
    //

    LPBYTE Buffer;

    //
    // ResponseInfo - we read the gopher+ header information (i.e. length) here.
    // The main reason is so that we can determine the length of a gopher+ file
    // even though we were given a zero-length user buffer
    //

    char ResponseInfo[LOOK_AHEAD_LENGTH];

    //
    // BytesRemaining - number of bytes left in ResponseInfo that are data
    //

    int BytesRemaining;

    //
    // DataBytes - pointer into ResponseInfo where data bytes start
    //

    LPBYTE DataBytes;

    //
    // CriticalSection - used to serialize readers
    //

//    CRITICAL_SECTION CriticalSection;

} BUFFER_INFO, *LPBUFFER_INFO;

//
// BUFFER_INFO flags
//

#define BI_RECEIVE_COMPLETE 0x00000001  // receiver thread has finished
#define BI_DOT_AT_END       0x00000002  // buffer terminated with ".\r\n"
#define BI_BUFFER_RESPONSE  0x00000004  // response is buffered internally
#define BI_ERROR_RESPONSE   0x00000008  // the server responded with an error
#define BI_MOVEABLE         0x00000010  // buffer is moveable memory
#define BI_FIRST_RECEIVE    0x00000020  // this is the first receive
#define BI_OWN_BUFFER       0x00000040  // set if we own the buffer (directory)

//
// external data
//

DEBUG_DATA_EXTERN(LONG, NumberOfBuffers);

//
// prototypes
//

LPBUFFER_INFO
CreateBuffer(
    OUT LPDWORD Error
    );

VOID
DestroyBuffer(
    IN LPBUFFER_INFO BufferInfo
    );

VOID
AcquireBufferLock(
    IN LPBUFFER_INFO BufferInfo
    );

VOID
ReleaseBufferLock(
    IN LPBUFFER_INFO BufferInfo
    );

VOID
ReferenceBuffer(
    IN LPBUFFER_INFO BufferInfo
    );

LPBUFFER_INFO
DereferenceBuffer(
    IN LPBUFFER_INFO BufferInfo
    );

//
// macros
//

#if INET_DEBUG

#define BUFFER_CREATED()    ++NumberOfBuffers
#define BUFFER_DESTROYED()  --NumberOfBuffers
#define ASSERT_NO_BUFFERS() \
    if (NumberOfBuffers != 0) { \
        INET_ASSERT(FALSE); \
    }

#else

#define BUFFER_CREATED()    /* NOTHING */
#define BUFFER_DESTROYED()  /* NOTHING */
#define ASSERT_NO_BUFFERS() /* NOTHING */

#endif

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\buffer.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    Contains functions for managing BUFFER_INFO 'objects'

    Contents:
        CreateBuffer
        DestroyBuffer
        AcquireBufferLock
        ReleaseBufferLock
        ReferenceBuffer
        DereferenceBuffer

Author:

    Richard L Firth (rfirth) 02-Nov-1994

Revision History:

    02-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// data
//

DEBUG_DATA(LONG, NumberOfBuffers, 0);

//
// functions
//


LPBUFFER_INFO
CreateBuffer(
    OUT LPDWORD Error
    )

/*++

Routine Description:

    Creates and initializes a BUFFER_INFO

Arguments:

    Error   - pointer to returned error

Return Value:

    LPBUFFER_INFO
        Success - pointer to new BUFFER_INFO
        Failure - NULL

--*/

{
    LPBUFFER_INFO bufferInfo;
    DWORD error;
    HANDLE hEvent;

    bufferInfo = NEW(BUFFER_INFO);
    if (bufferInfo != NULL) {

        //
        // create an event that is initially unsignalled. The thread that
        // creates this buffer info will signal the event when the response
        // has been received from the server. At that point, any other
        // concurrent requesters can access the data
        //

//        bufferInfo->RequestEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
//        if (bufferInfo->RequestEvent != NULL) {
            //bufferInfo->ConnectedSocket.Socket = INVALID_SOCKET;

//            InitializeCriticalSection(&bufferInfo->CriticalSection);
            bufferInfo->Socket = new ICSocket();

            if ( bufferInfo->Socket != NULL )
            {
                error = ERROR_SUCCESS;

                BUFFER_CREATED();
            }
            else
                error = ERROR_NOT_ENOUGH_MEMORY;


//        } else {
//            error = GetLastError();
//        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (error != ERROR_SUCCESS) {
        if (bufferInfo != NULL) {
            DEL(bufferInfo);
        }
        *Error = error;
    }

    return bufferInfo;
}


VOID
DestroyBuffer(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Frees resources belonging to BUFFER_INFO and frees memory occupied by
    BUFFER_INFO. BufferInfo must have been removed from any lists first

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to destroy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "DestroyBuffer",
                "%x",
                BufferInfo
                ));

    INET_ASSERT(BufferInfo != NULL);
    INET_ASSERT(BufferInfo->ReferenceCount == 0);
//    INET_ASSERT(! BufferInfo->Socket->IsValid());

    //if (BufferInfo->ConnectedSocket.Socket != INVALID_SOCKET) {
    INET_ASSERT(BufferInfo->Socket);

    if (BufferInfo->Socket->IsValid()) {

        //
        // BUGBUG - do we need to set linger or don't linger?
        //

        //
        // close the socket
        //

        BufferInfo->Socket->Close();
    }

    BufferInfo->Socket->Dereference();

//    if (BufferInfo->RequestEvent != NULL) {
//        CloseHandle(BufferInfo->RequestEvent);
//    }

    //
    // if we allocated a buffer for the response then free it
    //

    if ((BufferInfo->Buffer != NULL)
    && (BufferInfo->Flags & BI_BUFFER_RESPONSE)) {

        FREE_FIXED_MEMORY(BufferInfo->Buffer);

    }

//    DeleteCriticalSection(&BufferInfo->CriticalSection);

    DEL(BufferInfo);

    BUFFER_DESTROYED();

    DEBUG_LEAVE(0);
}


VOID
AcquireBufferLock(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Locks the BUFFER_INFO against simultaneous updates of the Buffer

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to lock

Return Value:

    None.

--*/

{
    INET_ASSERT(BufferInfo != NULL);

//    EnterCriticalSection(&BufferInfo->CriticalSection);
}


VOID
ReleaseBufferLock(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Opposite of AcquireBufferLock

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to unlock

Return Value:

    None.

--*/

{
    INET_ASSERT(BufferInfo != NULL);

//    LeaveCriticalSection(&BufferInfo->CriticalSection);
}


VOID
ReferenceBuffer(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Increments the BUFFER_INFO reference count

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to reference (by 1)

Return Value:

    None.

--*/

{
    INET_ASSERT(BufferInfo != NULL);

    InterlockedIncrement(&BufferInfo->ReferenceCount);
}


LPBUFFER_INFO
DereferenceBuffer(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Reduces the BUFFER_INFO reference count by 1. If the reference count goes
    to zero, the BUFFER_INFO is destroyed

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to dereference/destroy

Return Value:

    DWORD
        previous value of reference count

--*/

{
    INET_ASSERT(BufferInfo != NULL);
    INET_ASSERT(BufferInfo->ReferenceCount >= 1);

    if (InterlockedDecrement(&BufferInfo->ReferenceCount) == 0) {
        DestroyBuffer(BufferInfo);
        BufferInfo = NULL;
    }
    return BufferInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrapih.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapih.h

Abstract:

    Includes all headers for precompiled header to build GFRAPI.DLL

Author:

    Richard L Firth (rfirth) 26-Oct-1994

Revision History:

    26-Oct-1994 rfirth
        Created

--*/

#include "buffer.h"
#include "view.h"
#include "session.h"
#include "gfrapip.h"
#include "gfrapiu.h"
#include "gfrapir.h"
#include "parse.h"
#include "sockets.h"
#include "inet.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrapip.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapip.h

Abstract:

    Contains private or internal definitions for client gopher protocol
    provider

Author:

    Richard L Firth (rfirth) 13-Oct-1994

Revision History:

    13-Oct-1994 rfirth
        Created

--*/

//
// manifests
//

//
// gopher strings
//

#define GOPHER_REQUEST_TERMINATOR               "\r\n"
#define GOPHER_REQUEST_TERMINATOR_LENGTH        (sizeof(GOPHER_REQUEST_TERMINATOR) - 1)
#define GOPHER_DOT_TERMINATOR                   ".\r\n"
#define GOPHER_DOT_TERMINATOR_LENGTH            (sizeof(GOPHER_DOT_TERMINATOR) - 1)

//
// gopher+ strings
//

#define GOPHER_PLUS_INDICATOR                   "\t+"
#define GOPHER_PLUS_INDICATOR_LENGTH            (sizeof(GOPHER_PLUS_INDICATOR) - 1)
#define GOPHER_PLUS_ITEM_INFO                   "\t!"
#define GOPHER_PLUS_ITEM_INFO_LENGTH            (sizeof(GOPHER_PLUS_ITEM_INFO) - 1)
#define GOPHER_PLUS_INFO_REQUEST                "\t!\r\n"
#define GOPHER_PLUS_INFO_REQUEST_LENGTH         (sizeof(GOPHER_PLUS_INFO_REQUEST) - 1)
#define GOPHER_PLUS_DIRECTORY_REQUEST           "\t$"
#define GOPHER_PLUS_DIRECTORY_REQUEST_LENGTH    (sizeof(GOPHER_PLUS_DIRECTORY_REQUEST) - 1)
#define GOPHER_PLUS_INFO_TOKEN                  "+INFO"
#define GOPHER_PLUS_INFO_TOKEN_LENGTH           (sizeof(GOPHER_PLUS_INFO_TOKEN) - 1)
#define GOPHER_PLUS_ADMIN_TOKEN                 "+ADMIN"
#define GOPHER_PLUS_ADMIN_TOKEN_LENGTH          (sizeof(GOPHER_PLUS_ADMIN_TOKEN) - 1)
#define GOPHER_PLUS_VIEWS_TOKEN                 "+VIEWS"
#define GOPHER_PLUS_VIEWS_TOKEN_LENGTH          (sizeof(GOPHER_PLUS_VIEWS_TOKEN) - 1)

//
// single characters
//

#define GOPHER_FIELD_SEPARATOR          '\t'
#define GOPHER_PLUS_SUCCESS_INDICATOR   '+'
#define GOPHER_PLUS_ERROR_INDICATOR     '-'

//
// misc.
//

#define INVALID_GOPHER_CHAR             0
#define INVALID_GOPHER_TYPE             0
#define DEFAULT_GOPHER_DISPLAY_STRING   ""
#define DEFAULT_GOPHER_SELECTOR_STRING  ""
#define UNKNOWN_GOPHER_TYPE             0

//
// types and masks
//

#define VALID_GOPHER_TYPES              (GOPHER_TYPE_TEXT_FILE          \
                                        | GOPHER_TYPE_DIRECTORY         \
                                        | GOPHER_TYPE_CSO               \
                                        | GOPHER_TYPE_MAC_BINHEX        \
                                        | GOPHER_TYPE_DOS_ARCHIVE       \
                                        | GOPHER_TYPE_UNIX_UUENCODED    \
                                        | GOPHER_TYPE_INDEX_SERVER      \
                                        | GOPHER_TYPE_TELNET            \
                                        | GOPHER_TYPE_BINARY            \
                                        | GOPHER_TYPE_REDUNDANT         \
                                        | GOPHER_TYPE_TN3270            \
                                        | GOPHER_TYPE_GIF               \
                                        | GOPHER_TYPE_IMAGE             \
                                        | GOPHER_TYPE_BITMAP            \
                                        | GOPHER_TYPE_MOVIE             \
                                        | GOPHER_TYPE_SOUND             \
                                        | GOPHER_TYPE_HTML              \
                                        | GOPHER_TYPE_PDF               \
                                        | GOPHER_TYPE_CALENDAR          \
                                        | GOPHER_TYPE_INLINE            \
                                        )

#define GOPHER_TYPE_MASK                (~(GOPHER_TYPE_GOPHER_PLUS))

#define GOPHER_ATTRIBUTE_MASK           (GOPHER_TYPE_GOPHER_PLUS)

#define GOPHER_FILE_MASK                (GOPHER_TYPE_TEXT_FILE          \
                                        | GOPHER_TYPE_MAC_BINHEX        \
                                        | GOPHER_TYPE_DOS_ARCHIVE       \
                                        | GOPHER_TYPE_UNIX_UUENCODED    \
                                        | GOPHER_TYPE_BINARY            \
                                        | GOPHER_TYPE_GIF               \
                                        | GOPHER_TYPE_IMAGE             \
                                        | GOPHER_TYPE_BITMAP            \
                                        | GOPHER_TYPE_MOVIE             \
                                        | GOPHER_TYPE_SOUND             \
                                        | GOPHER_TYPE_HTML              \
                                        | GOPHER_TYPE_PDF               \
                                        | GOPHER_TYPE_CALENDAR          \
                                        | GOPHER_TYPE_INLINE            \
                                        )

#define GOPHER_DIRECTORY_MASK           (GOPHER_TYPE_DIRECTORY)


#define GOPHER_DOT_TERMINATED_TYPES     (GOPHER_TYPE_TEXT_FILE          \
                                        | GOPHER_TYPE_DIRECTORY         \
                                        | GOPHER_TYPE_MAC_BINHEX        \
                                        | GOPHER_TYPE_UNIX_UUENCODED    \
                                        | GOPHER_TYPE_INDEX_SERVER      \
                                        )

//
// gopher locator characters
//

#define GOPHER_CHAR_REDUNDANT           '+'
#define GOPHER_CHAR_TEXT_FILE           '0'
#define GOPHER_CHAR_DIRECTORY           '1'
#define GOPHER_CHAR_CSO                 '2'
#define GOPHER_CHAR_ERROR               '3'
#define GOPHER_CHAR_MAC_BINHEX          '4'
#define GOPHER_CHAR_DOS_ARCHIVE         '5'
#define GOPHER_CHAR_UNIX_UUENCODED      '6'
#define GOPHER_CHAR_INDEX_SERVER        '7'
#define GOPHER_CHAR_TELNET              '8'
#define GOPHER_CHAR_BINARY              '9'
#define GOPHER_CHAR_BITMAP              ':'
#define GOPHER_CHAR_MOVIE               ';'
#define GOPHER_CHAR_SOUND               '<'
#define GOPHER_CHAR_IMAGE               'I'
//#define GOPHER_CHAR_BIG_M               'M'
#define GOPHER_CHAR_PDF                 'P'
#define GOPHER_CHAR_TN3270              'T'
#define GOPHER_CHAR_CALENDAR            'c'
//#define GOPHER_CHAR_LITTLE_E            'e'
#define GOPHER_CHAR_GIF                 'g'
#define GOPHER_CHAR_INLINE              'i'
#define GOPHER_CHAR_HTML                'h'
#define GOPHER_CHAR_SOUND_2             's'

//
// macros
//

#define IS_DOT_TERMINATED_REQUEST(request) \
    ((request & GOPHER_DOT_TERMINATED_TYPES) ? TRUE : FALSE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapia.cxx

Abstract:

    ANSI versions of Windows Internet Extensions Gopher Protocol APIs

    Contents:
        GopherCreateLocatorA
        GopherGetLocatorTypeA
        GopherFindFirstFileA
        GopherFindNextA
        GopherOpenFileA
        GopherReadFile
        GopherGetAttributeA
        GopherSendDataA
        pGfrGetUrlInfo
        pGopherGetUrlString

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Environment:

    Win32 user-level DLL

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// manifests
//

#define GOPHER_ATTRIBUTE_BUFFER_LENGTH  (4 K)   // arbitrary
#define MAX_GOPHER_SEARCH_STRING_LENGTH (1 K)   // arbitrary

// used as delimiter in creating a unique cache name to append
// searchstring or viewtype to a url
#define GOPHER_EXTENSION_DELIMITER_SZ   "<>"

DWORD
pGopherGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR    lpszTargetHost,
    IN LPSTR    lpszCWD,
    IN LPSTR    lpszObjectLocator,
    IN LPSTR    lpszExtension,
    IN DWORD    dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

//
// private functions
//

PRIVATE
BOOL
FGopherBeginCacheReadProcessing(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszFileName,
    IN LPCSTR lpszViewType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    BOOL    fIsHtmlFind
    );

PRIVATE
BOOL
FGopherCanReadFromCache(
    HINTERNET   hGopherSession
    );

PRIVATE
BOOL
FGopherBeginCacheWriteProcessing(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszFileName,
    IN LPCSTR lpszViewType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    BOOL    fIsHtmlFind
    );

PRIVATE
BOOL
FGopherCanWriteToCache(
    HINTERNET   hGopherSession
    );

DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopherFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );


PRIVATE
BOOL
FIsGopherExpired(
    HINTERNET hGopher,
    LPCACHE_ENTRY_INFO lpCEI
    );

//
// functions
//


INTERNETAPI_(BOOL) GopherCreateLocatorA(
    IN LPCSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszDisplayString OPTIONAL,
    IN LPCSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Creates a gopher locator string. The string should be an opaque type so far
    as the app is concerned.

    This API mainly exists for situations where the app may want to request
    explicit information, without first having contacted a server and asked for
    a list of available information

Arguments:

    lpszHost            - Name of the host where the gopher server lives

    nServerPort         - Port at which the gopher server listens. The default
                          value 70 will be substituted if 0 is passed in

    lpszDisplayString   - Optional display string. Mainly a place holder. Can be
                          NULL, or NUL string, in which case a default string
                          will be substituted (just \t)

    lpszSelectorString  - The string used to select the item at the gopher
                          server. Can be NULL

    dwGopherType        - Tells us that the item to return is a file or
                          directory, graphics image, audio file, etc...
                          If 0, the default GOPHER_TYPE_DIRECTORY is used

    lpszLocator         - Place where the locator is returned

    lpdwBufferLength    - IN: Length of Buffer
                          OUT: Required length of Buffer only if
                          ERROR_INSUFFICIENT_BUFFER returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError()/InternetGetLastResponseInfo() to
                  get more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherCreateLocatorA",
                     "%q, %d, %q, %q, %#x, %#x, %#x [%d]",
                     lpszHost,
                     nServerPort,
                     lpszDisplayString,
                     lpszSelectorString,
                     dwGopherType,
                     lpszLocator,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD requiredLength;
    char portBuffer[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    char gopherChar;
    DWORD displayStringLength;
    DWORD selectorStringLength;
    DWORD hostNameLength;
    DWORD portLength;
    BOOL gopherPlus;
    BOOL success;

    //
    // default is directory, ordinary gopher (i.e. not gopher+)
    //

    if (dwGopherType == 0) {
        dwGopherType = GOPHER_TYPE_DIRECTORY;
    }

    gopherChar = GopherTypeToChar(dwGopherType);

    //
    // validate parameters
    //

    if (IsBadStringPtr(lpszHost, MAX_GOPHER_HOST_NAME)
    || (*lpszHost == '\0')
    || (ARGUMENT_PRESENT(lpszDisplayString)
        && IsBadStringPtr(lpszDisplayString, MAX_GOPHER_DISPLAY_TEXT))
    || (ARGUMENT_PRESENT(lpszSelectorString)
        && IsBadStringPtr(lpszSelectorString, MAX_GOPHER_SELECTOR_TEXT))
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || (ARGUMENT_PRESENT(lpszLocator)
        && IsBadWritePtr(lpszLocator, *lpdwBufferLength))
    || (gopherChar == INVALID_GOPHER_TYPE)) {

        DEBUG_ERROR(API, ERROR_INVALID_PARAMETER);

        DEBUG_LEAVE(FALSE);

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // ensure that if the caller passed in a NULL locator pointer then the size
    // of the buffer is 0
    //

    if (!ARGUMENT_PRESENT(lpszLocator)) {
        *lpdwBufferLength = 0;
    }

    if (nServerPort == 0) {
        nServerPort = INTERNET_DEFAULT_GOPHER_PORT;
    }

    //ULTOA(nServerPort, portBuffer, 10);
    wsprintf (portBuffer, "%u", nServerPort);


    if (!(ARGUMENT_PRESENT(lpszDisplayString) && (*lpszDisplayString != '\0'))) {
        lpszDisplayString = DEFAULT_GOPHER_DISPLAY_STRING;
    }

    if (!(ARGUMENT_PRESENT(lpszSelectorString) && (*lpszSelectorString != '\0'))) {
        lpszSelectorString = DEFAULT_GOPHER_SELECTOR_STRING;
    }

    gopherPlus = IS_GOPHER_PLUS(dwGopherType);

    displayStringLength = lstrlen(lpszDisplayString);
    selectorStringLength = lstrlen(lpszSelectorString);
    hostNameLength = lstrlen(lpszHost);
    portLength = lstrlen(portBuffer);

    //
    // calculate how many bytes of buffer required for the locator
    //

    requiredLength = sizeof(char)           // descriptor character
                   + displayStringLength
                   + sizeof(char)           // TAB
                   + selectorStringLength
                   + sizeof(char)           // TAB
                   + hostNameLength
                   + sizeof(char)           // TAB
                   + portLength
                   + (gopherPlus ? 2 : 0)   // TAB, '+'
                   + sizeof(char)           // CR
                   + sizeof(char)           // LF
                   + sizeof(char)           // EOS
                   ;

    //
    // and if the caller supplied at least that much, then create the locator,
    // else just return the size of buffer needed
    //

    if (*lpdwBufferLength >= requiredLength) {
        *lpszLocator++ = gopherChar;

        CopyMemory(lpszLocator, lpszDisplayString, displayStringLength);
        lpszLocator += displayStringLength;
        *lpszLocator++ = '\t';

        CopyMemory(lpszLocator, lpszSelectorString, selectorStringLength);
        lpszLocator += selectorStringLength;
        *lpszLocator++ = '\t';

        CopyMemory(lpszLocator, lpszHost, hostNameLength);
        lpszLocator += hostNameLength;
        *lpszLocator++ = '\t';

        CopyMemory(lpszLocator, portBuffer, portLength);
        lpszLocator += portLength;

        if (gopherPlus) {
            *lpszLocator++ = '\t';
            *lpszLocator++ = '+';
        }

        *lpszLocator++ = '\r';
        *lpszLocator++ = '\n';
        *lpszLocator = '\0';

        //
        // in the case of a successful copy, we return *lpdwBufferLength as the
        // number of characters in the string, as if returned by lstrlen()
        //

        --requiredLength;
        success = TRUE;
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);

        DEBUG_ERROR(API, ERROR_INSUFFICIENT_BUFFER);

        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) GopherGetLocatorTypeA(
    IN LPCSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    )

/*++

Routine Description:

    Returns the type of the locator

Arguments:

    lpszLocator     - pointer to locator to return type of

    lpdwGopherType  - pointer to DWORD where type is returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Check GetLastError() for more information:
                    ERROR_INVALID_PARAMETER
                    ERROR_GOPHER_UNKNOWN_LOCATOR

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherGetLocatorTypeA",
                     "%q, %#x",
                     lpszLocator,
                     lpdwGopherType
                     ));

    DWORD error;

    if (IsValidLocator(lpszLocator, MAX_GOPHER_LOCATOR_LENGTH)
    && !IsBadWritePtr(lpdwGopherType, sizeof(*lpdwGopherType))) {

        DWORD gopherType;

        gopherType = GopherCharToType(*lpszLocator);
        if (gopherType != INVALID_GOPHER_CHAR) {
            gopherType |= IsGopherPlus(lpszLocator)
                            ? GOPHER_TYPE_GOPHER_PLUS
                            : 0
                            ;
            *lpdwGopherType = gopherType;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_GOPHER_UNKNOWN_LOCATOR;
        }
    } else {
        error = ERROR_INVALID_PARAMETER;
    }

    DWORD success;

    if (error == ERROR_SUCCESS) {
        success = TRUE;
    } else {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(HINTERNET) GopherFindFirstFileA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator OPTIONAL,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAA lpBuffer OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Used to return directory/hierarchy information from the gopher server

Arguments:

    hGopherSession      - identifies gopher server context to use - either via
                          gateway, or straight to internet

    lpszLocator         - descriptor of information to get. If NULL then we get
                          the default directory at the server

    lpszSearchString    - if this request is to an search server, this
                          parameter specifies the string(s) to search for. If
                          Locator does not specify a search server then
                          the paraneter is not used, but it IS validated

    lpBuffer            - pointer to user-allocated buffer in which to return
                          info. This parameter may be NULL, in which case if
                          this function returns success, then the results of
                          the request will be returned via InternetFindNextFile()

    dwFlags             - controlling caching, etc.

    dwContext           - app-supplied context value for use in call-backs

Return Value:

    HINTERNET
        Success - valid handle value
                    If lpBuffer was not NULL, a GOPHER_FIND_DATA structure has
                    been returned in lpBuffer. Use InternetFindNextFile() to
                    retrieve the remainder of the directory entries.
                    If lpBuffer was NULL, then this call is still successful,
                    but all directory entries (including the first) will be
                    returned via InternetFindNextFile()

        Failure - NULL
                    Use GetLastError()/InternetGetLastResponseInfo() to get
                    more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "GopherFindFirstFileA",
                     "%#x, %q, %q, %#x, %#x, %$x",
                     hGopherSession,
                     lpszLocator,
                     lpszSearchString,
                     lpBuffer,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET findHandle;
    HINTERNET hConnectMapped = NULL;
    HINTERNET hObject;
    HINTERNET hObjectMapped = NULL;

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // if this is the async worker thread then what we think is hGopherSession
    // is really the find handle object. Get the handles in the right variables
    //

    if (lpThreadInfo->IsAsyncWorkerThread
    && (lpThreadInfo->NestedRequests == 1)) {
        hObject = hGopherSession;
        error = MapHandleToAddress(hObject, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        findHandle = hObjectMapped;
        hConnectMapped = ((FTP_FIND_HANDLE_OBJECT *)findHandle)->GetParent();
    } else {

        //
        // map the handle
        //

        hObject = hGopherSession;
        error = MapHandleToAddress(hGopherSession, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        hConnectMapped = hObjectMapped;
        findHandle = NULL;
    }

    //
    // set the context info and clear the error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hObject, hObjectMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters - check handle and discover sync/async and
    // local/remote
    //

    BOOL isLocal, isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeGopherConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // skip rest of validation if we're in the async worker thread context -
    // we already did this
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {
        if ((ARGUMENT_PRESENT(lpBuffer)
            && IsBadWritePtr(lpBuffer, sizeof(GOPHER_FIND_DATA)))
        || (ARGUMENT_PRESENT(lpszSearchString)

            //
            // BUGBUG - limit on search string?
            //

            && IsBadStringPtr(lpszSearchString,
                              MAX_GOPHER_SEARCH_STRING_LENGTH))) {

            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        if (ARGUMENT_PRESENT(lpszLocator)) {

            //
            // BUGBUG - limit on locator?
            //

            if (IsValidLocator(lpszLocator, MAX_GOPHER_LOCATOR_LENGTH)) {

                DWORD locatorType;

                locatorType = GopherCharToType(*lpszLocator);

                //
                // we only allow directories and index/cso servers to be searched
                //

                if (  !IS_GOPHER_DIRECTORY(locatorType)
                   && !IS_GOPHER_SEARCH_SERVER(locatorType)) {
                    error = ERROR_GOPHER_INCORRECT_LOCATOR_TYPE;
                    goto quit;
                }

                //
                // if this is an search server then there must be search strings
                // - the server will only tell us that we need to supply them,
                // so no point in going to the expense of sending a request just
                // to get this response
                //

                if (  IS_GOPHER_SEARCH_SERVER (locatorType)
                   && (  !ARGUMENT_PRESENT(lpszSearchString)
                      || (*lpszSearchString == '\0'))) {

                    error = ERROR_INVALID_PARAMETER;
                    goto quit;
                }
            } else {
                error = ERROR_GOPHER_INVALID_LOCATOR;
                goto quit;
            }
        }

        //
        // create the handle object now. This can be used to cancel the async
        // operation, or the sync operation if InternetCloseHandle() is called
        // from a different thread
        //

        INET_ASSERT(findHandle == NULL);

        error = RMakeGfrFindObjectHandle(hConnectMapped,
                                         &findHandle,
                                         (CLOSE_HANDLE_FUNC)wGopherFindClose,
                                         dwContext
                                         );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)findHandle)->GetPseudoHandle(),
                                 findHandle
                                 );

        //
        // get the OFFLINE flag whether set globally (@ InternetOpen() level) or
        // locally (for this function)
        //

        if ((((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->GetInternetOpenFlags()
             | dwFlags) & INTERNET_FLAG_OFFLINE) {
            dwFlags |= INTERNET_FLAG_OFFLINE;
        }

try_again:

        //
        // check to see if the data is in the cache. Do it here so that we don't
        // waste any time going async if we already have the data locally
        //

        //
        // can't do it for default locator
        //

        if ((lpszLocator != NULL)
        && FGopherBeginCacheReadProcessing(findHandle,
                                           lpszLocator,
                                           lpszSearchString,
                                           dwFlags,
                                           dwContext,
                                           ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->IsHtmlFind()
                                           )) {

            error = ERROR_SUCCESS;

            if (lpBuffer) {

                DWORD dwBytes = sizeof(GOPHER_FIND_DATA);

                error = ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->ReadCache(
                            (LPBYTE)lpBuffer,
                            sizeof(GOPHER_FIND_DATA),
                            &dwBytes
                            );
            }
            if (error == ERROR_SUCCESS) {
                goto quit;
            } else {
                ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->EndCacheRetrieval();
            }
        }

        if (dwFlags & INTERNET_FLAG_OFFLINE) {

            //
            // we are supposed to be in offline mode
            // if we are not reading from the cache, let us bailout
            //

            if (!((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->IsCacheReadInProgress()) {
                error = ERROR_PATH_NOT_FOUND;
                goto quit;
            }
        }
    }

    //
    // if the handle was created for async I/O AND there is a non-zero context
    // value AND we are not in the context of an async worker thread then queue
    // the request
    //

    if (isAsync
    && (dwContext != INTERNET_NO_CALLBACK)
    && !lpThreadInfo->IsAsyncWorkerThread) {

        // MakeAsyncRequest
        CFsm_GopherFindFirstFile * pFsm;

        pFsm = new CFsm_GopherFindFirstFile(((HANDLE_OBJECT *)findHandle)->GetPseudoHandle(),
                                             dwContext,
                                             lpszLocator,
                                             lpszSearchString,
                                             lpBuffer,
                                             dwFlags
                                             );

        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

    //
    // make the request
    //

    char defaultLocator[MAX_GOPHER_LOCATOR_LENGTH * 2];

    //
    // if we were given a NULL locator then create a locator to access
    // the default directory at the configured default server.
    //
    // N.B. This only gives us gopher access (i.e. not gopher+)
    //

    if (!ARGUMENT_PRESENT(lpszLocator)) {

        BOOL ok;
        DWORD defaultLocatorLength;

        defaultLocatorLength = sizeof(defaultLocator);
        ok = GopherCreateLocator(
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->GetHostName(),
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->GetHostPort(),
            NULL,
            NULL,
            GOPHER_TYPE_DIRECTORY,
            defaultLocator,
            &defaultLocatorLength
            );
        if (ok) {
            lpszLocator = defaultLocator;
        } else {

            //
            // set error to ERROR_SUCCESS so that cleanup doesn't set it
            // again (already set by GopherCreateLocator)
            //

            error = ERROR_SUCCESS;
            goto quit;
        }
    }

    HINTERNET protocolFindHandle;

    error = wGopherFindFirst(lpszLocator,
                             lpszSearchString,
                             lpBuffer,
                             &protocolFindHandle
                             );
    if (error == ERROR_SUCCESS) {
        ((GOPHER_FIND_HANDLE_OBJECT *)findHandle)->SetFindHandle(protocolFindHandle);

        //
        // if we succeeded in getting the data, add it to the cache. Don't worry
        // about errors if cache write fails
        //

        if (FGopherBeginCacheWriteProcessing(
            findHandle,
            lpszLocator,
            lpszSearchString,
            0,
            dwContext,
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->IsHtmlFind())) {

            if (lpBuffer != NULL) {

                DWORD dwBytes = sizeof(GOPHER_FIND_DATA);
                DWORD errorCache;

                errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->WriteCache(
                    (LPBYTE)lpBuffer,
                    sizeof(GOPHER_FIND_DATA)
                    );
                if (errorCache != ERROR_SUCCESS) {
                    InbGopherLocalEndCacheWrite(findHandle,
                                                NULL,
                                                (errorCache == ERROR_NO_MORE_FILES)
                                                );
                }
            }
        }
    } else if (IsOffline() && !(dwFlags & INTERNET_FLAG_OFFLINE)) {

        //
        // if we failed because we went offline before retrieving it from the
        // cache, then try from the cache again
        //

        dwFlags |= INTERNET_FLAG_OFFLINE;
        goto try_again;
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    //
    // if we got an error then set this thread's error variable and return
    // NULL. The app must call GetLastError()
    //

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (findHandle != NULL)) {
            InternetCloseHandle(((HANDLE_OBJECT *)findHandle)->GetPseudoHandle());
        }

        //
        // error situation, or request is being processed asynchronously: return
        // a NULL handle
        //

        findHandle = NULL;
    } else {

        //
        // success - return generated pseudo-handle
        //

        findHandle = ((HANDLE_OBJECT *)findHandle)->GetPseudoHandle();
    }

    if ((hConnectMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    if ( error != ERROR_SUCCESS ) {
        SetLastError(error);
    }

    DEBUG_LEAVE_API(findHandle);

    return findHandle;
}


BOOL
GopherFindNextA(
    IN HINTERNET hFind,
    OUT LPGOPHER_FIND_DATA lpBuffer
    )

/*++

Routine Description:

    Continues a search created by GopherFindFirstFile(). The same search
    criteria as specfied in GopherFindFirstFile() will be applied

    Assumes:    1. We are being called from InternetFindNextFile() which has
                   already validated the parameters, set the thread variables,
                   and cleared the object last error info

Arguments:

    hFind       - search handle created by call to GopherFindFirstFile()

    lpBuffer    - pointer to user-allocated buffer in which to return info

Return Value:

    BOOL
        TRUE    - Information has been returned in lpBuffer

        FALSE   - Use GetLastError()/InternetGetLastResponseInfo() to get nore
                  information

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "GopherFindNextA",
                 "%#x, %#x",
                 hFind,
                 lpBuffer
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error;

    //
    // find path from internet handle
    //

    BOOL isLocal;
    BOOL isAsync, fIsHtml = FALSE;

    error = RIsHandleLocal(hFind,
                           &isLocal,
                           &isAsync,
                           TypeGopherFindHandle
                           );
    if (error != ERROR_SUCCESS) {

        //
        // if the handle is actually a HTML gopher find handle, then we allow
        // the operation. Note: we can do this because GopherFindNext() is not
        // exported, so a rogue app cannot call this function after opening the
        // handle via InternetOpenUrl()
        //

        error = RIsHandleLocal(hFind,
                               &isLocal,
                               &isAsync,
                               TypeGopherFindHandleHtml
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        fIsHtml = TRUE;
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->IsCacheReadInProgress()) {
        DWORD   dwLen = sizeof(GOPHER_FIND_DATA);
        error = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->ReadCache((LPBYTE)lpBuffer,
                                                            dwLen,
                                                            &dwLen);
        if ((error == ERROR_SUCCESS) && !dwLen) {
            error = ERROR_NO_MORE_FILES;
        }
        goto quit;
    }

    HINTERNET localHandle;

    error = RGetLocalHandle(hFind, &localHandle);
    if (error == ERROR_SUCCESS) {
        error = wGopherFindNext(localHandle, lpBuffer);
    }

    DWORD errorCache;

    errorCache = error;

    if (error == ERROR_SUCCESS) {
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->IsCacheWriteInProgress()) {
            if (!fIsHtml) {
                errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->WriteCache((LPBYTE)lpBuffer,
                                                                sizeof(GOPHER_FIND_DATA));
            }
        }

    }
    if (errorCache != ERROR_SUCCESS) {
        if (!fIsHtml) {
            InbGopherLocalEndCacheWrite(hFind,
                                        NULL,
                                        (errorCache == ERROR_NO_MORE_FILES)
                                        );
        }
    }

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        success = TRUE;
    } else {

        DEBUG_ERROR(API, error);

        success = FALSE;
    }

    DEBUG_LEAVE(success);

    SetLastError(error);

    return success;
}


INTERNETAPI_(HINTERNET) GopherOpenFileA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    'Opens' a file at a gopher server. Right now this means transferring the
    file locally, keeping it in a buffer

Arguments:

    hGopherSession  - defines where to go for the file - gateway or internet

    lpszLocator     - descriptor of file to get

    lpszView        - optional type of file to read as MIME content-type

    dwFlags         - open options

    dwContext       - app-supplied context value for use in call-backs

Return Value:

    HINTERNET
        Success - valid handle value

        Failure - NULL
                    Use GetLastError()/InternetGetLastResponseInfo() to get
                    more information

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "GopherOpenFileA",
                     "%#x, %q, %q, %#x, %#x",
                     hGopherSession,
                     lpszLocator,
                     lpszView,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET fileHandle = NULL;
    HINTERNET hConnectMapped = NULL;
    HINTERNET hObject;
    HINTERNET hObjectMapped = NULL;

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    DWORD nestingLevel = 0;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // need the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // if this is the async worker thread then what we think is hGopherSession
    // is really the file handle object. Get the handles in the right variables
    //

    if (lpThreadInfo->IsAsyncWorkerThread
    && (lpThreadInfo->NestedRequests == 1)) {
        hObject = hGopherSession;
        error = MapHandleToAddress(hObject, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        fileHandle = hObjectMapped;
        hConnectMapped = ((FTP_FIND_HANDLE_OBJECT *)fileHandle)->GetParent();
    } else {

        //
        // map the handle
        //

        hObject = hGopherSession;
        error = MapHandleToAddress(hObject, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        hConnectMapped = hObjectMapped;
    }

    //
    // handle must be valid type
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeGopherConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // set the context info & clear the error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hObject, hObjectMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // if this is an async request and we're in the context of an async worker
    // thread then skip the rest of parameter validation - it was already done
    // when the request was originally queued
    //

    if (isAsync
    && lpThreadInfo->IsAsyncWorkerThread
    && (lpThreadInfo->NestedRequests == 1)) {
        goto synchronous_path;
    }

    //
    // validate parameters - locator must identify a file (and be a valid
    // locator), and the flags parameter cannot contain any undefined flags.
    // lpszView must be NULL or valid string
    //

    if (dwFlags & ~INTERNET_FLAGS_MASK) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (ARGUMENT_PRESENT(lpszView)) {

        int len;

        __try {
            len = lstrlen(lpszView);
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    error = TestLocatorType(lpszLocator, GOPHER_FILE_MASK);
    if (error != ERROR_SUCCESS) {

        //
        // TestLocatorType uses ERROR_INVALID_FUNCTION to mean Locator is not
        // the specified type. Map this to ERROR_SUCCESS and NOT SUCCESS
        //

        if (error == ERROR_INVALID_FUNCTION) {
            error = ERROR_GOPHER_NOT_FILE;
        }
        goto quit;
    }

    //
    // create the handle object now. This can be used to cancel the async
    // operation, or the sync operation if InternetCloseHandle() is called
    // from a different thread
    //

    fileHandle = NULL;
    error = RMakeGfrFileObjectHandle(hConnectMapped,
                                     &fileHandle,
                                     (CLOSE_HANDLE_FUNC)wGopherCloseHandle,
                                     dwContext
                                     );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // this new handle will be used in callbacks
    //

    _InternetSetObjectHandle(lpThreadInfo,
                             ((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle(),
                             fileHandle
                             );

    //
    // get the OFFLINE flag whether set globally (@ InternetOpen() level) or
    // locally (for this function)
    //

    if ((((GOPHER_FILE_HANDLE_OBJECT *)fileHandle)->GetInternetOpenFlags()
         | dwFlags) & INTERNET_FLAG_OFFLINE) {
        dwFlags |= INTERNET_FLAG_OFFLINE;
    }

try_again:

    //
    // check to see if the data is in the cache
    //

    if (FGopherBeginCacheReadProcessing(fileHandle,
                                        lpszLocator,
                                        lpszView,
                                        dwFlags,
                                        dwContext,
                                        FALSE)) {
        error = ERROR_SUCCESS;
        goto quit;
    } else if (dwFlags & INTERNET_FLAG_OFFLINE) {

        //
        // we are supposed to be in offline mode, let us bailout
        //

        error = ERROR_FILE_NOT_FOUND;
        goto quit;
    }

    //
    // if we're here then we know we're not in the context of an async worker
    // thread, so if the request is async, we queue it and get out
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    && isAsync
    && (dwContext != INTERNET_NO_CALLBACK))
    {
        // MakeAsyncRequest
        CFsm_GopherOpenFile * pFsm;

        pFsm = new CFsm_GopherOpenFile(((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle(),
                                        dwContext,
                                        lpszLocator,
                                        lpszView,
                                        dwFlags
                                        );

        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

synchronous_path:

    //
    // local call, call the worker directly.
    //

    HINTERNET protocolFileHandle;

    error = wGopherOpenFile(lpszLocator,
                            lpszView,
                            &protocolFileHandle
                            );
    if (error == ERROR_SUCCESS) {
        ((GOPHER_FILE_HANDLE_OBJECT *)fileHandle)->SetFileHandle(protocolFileHandle);

        //
        // don't worry about errors if cache write does not begin
        //

        FGopherBeginCacheWriteProcessing(fileHandle,
                                         lpszLocator,
                                         lpszView,
                                         dwFlags,
                                         dwContext,
                                         FALSE
                                         );
    } else if (IsOffline() && !(dwFlags & INTERNET_FLAG_OFFLINE)) {

        //
        // if we failed because we went offline before retrieving it from the
        // cache, then try from the cache again
        //

        dwFlags |= INTERNET_FLAG_OFFLINE;
        goto try_again;
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (fileHandle != NULL)) {
            InternetCloseHandle(((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle());
        }

        //
        // error situation, or request is being processed asynchronously: return
        // a NULL handle
        //

        fileHandle = NULL;
    } else {

        //
        // success - return generated pseudo-handle
        //

        fileHandle = ((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle();
    }

    if ((hConnectMapped != NULL) && fDeref ) {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    DEBUG_LEAVE_API(fileHandle);

    return fileHandle;
}


BOOL
GopherReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    Reads from a file opened by GopherOpenFile into the caller's buffer. The
    number of bytes returned is the smaller of dwNumberOfBytesToRead and the
    number of bytes between the current file pointer and the end of the file

    Assumes:    1. We are being called from InternetReadFile() which has
                   already validated the parameters, handled the zero byte
                   read case, set the thread variables, and cleared the object
                   last error info

Arguments:

    hFile                   - file handle created by GopherOpenFile

    lpBuffer                - pointer to caller's buffer

    dwNumberOfBytesToRead   - pointer to length of Buffer

    lpdwNumberOfBytesRead   - number of bytes copied into Buffer

Return Value:

    BOOL
        TRUE    - lpdwNumberOfBytesRead contains amount of data written to
                  lpBuffer

        FALSE   - use GetLastError()/InternetGetLastResponseInfo() to get more
                  info

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "GopherReadFile",
                 "%#x, %#x, %d, %#x",
                 hFile,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error;

    //
    // find path from file handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFile,
                           &isLocal,
                           &isAsync,
                           TypeGopherFileHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (((GOPHER_FILE_HANDLE_OBJECT *)hFile)->IsCacheReadInProgress()) {
        error = ((GOPHER_FILE_HANDLE_OBJECT *)hFile)->ReadCache((LPBYTE)lpBuffer,
                                                  dwNumberOfBytesToRead,
                                                  lpdwNumberOfBytesRead
                                                  );
        if (!*lpdwNumberOfBytesRead || (error != ERROR_SUCCESS)) {
            // Don't end cache retrieval. So any extraneous reads
            // continue down this path. bug #9086
//            ((GOPHER_FILE_HANDLE_OBJECT *)hFile)->EndCacheRetrieval();
        }

        // quit whether we succeed or we fail

        goto quit;
    }

    HINTERNET localHandle;

    error = RGetLocalHandle(hFile, &localHandle);
    if (error == ERROR_SUCCESS) {
        error = wGopherReadFile(localHandle,
                                (LPBYTE)lpBuffer,
                                dwNumberOfBytesToRead,
                                lpdwNumberOfBytesRead
                                );
    }

    if (error == ERROR_SUCCESS) {
        DWORD   errorCache;
        if (((GOPHER_FILE_HANDLE_OBJECT *)hFile)->IsCacheWriteInProgress()) {

            if(!*lpdwNumberOfBytesRead) {

                DEBUG_PRINT(GOPHER,
                            INFO,
                            ("Cache write complete\r\n"
                            ));

                errorCache = InbGopherLocalEndCacheWrite(hFile, NULL, TRUE);

                INET_ASSERT(error == ERROR_SUCCESS);

                goto quit;
            }

            INET_ASSERT(((GOPHER_FILE_HANDLE_OBJECT *)hFile)->IsCacheReadInProgress()==FALSE);

            if (((GOPHER_FILE_HANDLE_OBJECT *)hFile)->WriteCache((LPBYTE)lpBuffer,
                                                   *lpdwNumberOfBytesRead
                                                   ) != ERROR_SUCCESS) {

                DEBUG_PRINT(GOPHER,
                            ERROR,
                            ("Error in Cache write\n"
                            ));

                errorCache = InbGopherLocalEndCacheWrite(hFile, NULL, FALSE);

                INET_ASSERT(error == ERROR_SUCCESS);

            }
        }

    }

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        success = TRUE;
    } else {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);

    return success;
}


INTERNETAPI_(BOOL) GopherGetAttributeA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Gets an attribute from a server

    BUGBUG - it should be possible for a caller to specify e.g. "+VIEWS+ABSTRACT"
             (according to gopher plus documentation) and get both types back

Arguments:

    hGopherSession          - identifies the gopher session object

    lpszLocator             - pointer to locator identifying item to get
                              attribute for

    lpszAttributeName       - name of attribute to return. May be NULL,
                              meaning return everything

    lpBuffer                - pointer to buffer where attributes are to be
                              returned

    dwBufferLength          - length of buffer

    lpdwCharactersReturned  - pointer to variable which will receive the
                              number of bytes in lpBuffer on output (if no
                              error occurs)

    lpfnEnumerator          - optional enumerator. If supplied, we return an
                              enumerated series of GOPHER_ATTRIBUTE_TYPE
                              items, else we just return the info in the
                              caller's buffer

    dwContext               - app-supplied context value for use in call-backs

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError()/InternetGetLastResponseInfo() for
                  more information

--*/

{
#if !defined(GOPHER_ATTRIBUTE_SUPPORT)

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;

#else

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherGetAttributeA",
                     "%#x, %q, %q, %#x, %d, %#x, %#x, %#x",
                     hGopherSession,
                     lpszLocator,
                     lpszAttributeName,
                     lpBuffer,
                     dwBufferLength,
                     lpdwCharactersReturned,
                     lpfnEnumerator,
                     dwContext
                     ));

    DWORD error;
    DWORD gopherType;
    LPSTR gopherPlusInfo;
    DWORD categoryId;
    DWORD attributeId;
    DWORD attributeLength;
    LPBYTE attributeBuffer = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD bufferSize;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(hGopherSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the call context info & clear the error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hGopherSession, hMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle on all paths
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeGopherConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if we're in the async worker thread context then we've already validated
    // the parameters - skip validation and go straight to local/remote path
    //

    if (lpThreadInfo->IsAsyncWorkerThread) {
        goto synchronous_path;
    }

    //
    // validate parameters
    //

    if (!IsValidLocator(lpszLocator, MAX_GOPHER_LOCATOR_LENGTH)

    //
    // we say Buffer must be >= MIN_GOPHER_ATTRIBUTE_LENGTH to give us a chance
    // of returning enumerated attributes
    //

    || (dwBufferLength < MIN_GOPHER_ATTRIBUTE_LENGTH)
    || IsBadWritePtr(lpBuffer, dwBufferLength)
    || IsBadWritePtr(lpdwCharactersReturned, sizeof(*lpdwCharactersReturned))
    || ARGUMENT_PRESENT(lpfnEnumerator) && IsBadCodePtr((FARPROC)lpfnEnumerator)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // crack open the locator. We want the type and to know if its a gopher+
    // locator. Note that we could *really* accept a gopher0 locator if the
    // server identified therein was actually a gopher+ server, but that
    // would require more work just to identify whether we could proceed or
    // not. If the caller doesn't supply a gopher+ locator then 1) the caller
    // supplied their own locator and it won't be painful to recreate a
    // locator of the correct type, or 2) the locator was returned from a
    // previous find first/find next call and therefore we are justified in
    // refusing the request
    //

    CrackLocator(lpszLocator,
                 &gopherType,
                 NULL,  // DisplayString
                 NULL,  // DisplayStringLength
                 NULL,  // SelectorString
                 NULL,  // SelectorStringLength
                 NULL,  // HostName
                 NULL,  // HostNameLength
                 NULL,  // GopherPort
                 &gopherPlusInfo
                 );

    //
    // the locator must identify a gopher+ item - i.e. there must at least be a
    // "\t+" after the gopher server port number in the locator
    //

    if (!gopherPlusInfo) {
        error = ERROR_GOPHER_NOT_GOPHER_PLUS;
        goto quit;
    }

    //
    // and must be a file or directory
    //
    // BUGBUG - I can't find a gopher+ index server. It may be wrong to preclude
    //          this type from getting attributes. Likewise for telnet sessions,
    //          TN3270 sessions, etc. etc.?
    //

    if (!(IS_GOPHER_FILE(gopherType) || IS_GOPHER_DIRECTORY(gopherType))) {
        error = ERROR_GOPHER_INCORRECT_LOCATOR_TYPE;
        goto quit;
    }

    //
    // convert a NULL string to a NULL pointer, indicating that the caller wants
    // all available attributes for the locator
    //

    if (ARGUMENT_PRESENT(lpszAttributeName) && (*lpszAttributeName == '\0')) {
        lpszAttributeName = NULL;
    }

    //
    // we don't allow the app to request the +INFO attribute - we would have to
    // return it as a GOPHER_FIND_DATA which is already catered for by
    // GopherFindFirstFile()/GopherFindNext()
    //

    MapAttributeToIds(lpszAttributeName, &categoryId, &attributeId);
    if (categoryId == GOPHER_CATEGORY_ID_INFO) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // queue async request if that's what we're asked to do. We know we're not
    // in the async worker thread context at this point
    //

    INET_ASSERT(!lpThreadInfo->IsAsyncWorkerThread);

    if (isAsync && (dwContext != INTERNET_NO_CALLBACK))
    {
        // MakeAsyncRequest
        CFsm_GopherGetAttribute * pFsm;

        pFsm = new CFsm_GopherGetAttribute(hGopherSession, dwContext, lpszLocator, lpszAttributeName, lpBuffer,
                                            dwBufferLength, lpdwCharactersReturned, lpfnEnumerator );

        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

synchronous_path:

    //
    // we will allocate a buffer to receive the attributes into. Since we
    // won't be growing the buffer, we have to loop until we receive all
    // attribute information, or until an error occurs
    //

    bufferSize = GOPHER_ATTRIBUTE_BUFFER_LENGTH;
    error = ERROR_INSUFFICIENT_BUFFER;
    while (error == ERROR_INSUFFICIENT_BUFFER) {

        //
        // we need to allocate an intermediate buffer to receive the
        // attributes into, for two reasons: 1) we don't return the +INFO
        // attribute, 2) we probably need to filter the returned attributes
        // before returning the requested attributes to the caller
        //

        attributeBuffer = NEW_MEMORY(bufferSize, BYTE);
        if (attributeBuffer != NULL) {
            attributeLength = bufferSize;
            error = wGopherGetAttribute(lpszLocator,
                                        lpszAttributeName,
                                        attributeBuffer,
                                        &attributeLength
                                        );

        } else {

            DEBUG_PRINT(GOPHER,
                        ERROR,
                        ("failed to allocate %d byte attribute buffer\n",
                        GOPHER_ATTRIBUTE_BUFFER_LENGTH
                        ));

            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we have tried up to 64K then something serious has gone wrong.
        // Return an internal error (BUGBUG?)
        //

        if (error == ERROR_INSUFFICIENT_BUFFER) {
            if (bufferSize >= 64 K) {
                error = ERROR_INTERNET_INTERNAL_ERROR;
            } else {
                DEL(attributeBuffer);
                bufferSize += GOPHER_ATTRIBUTE_BUFFER_LENGTH;

                DEBUG_PRINT(GOPHER,
                            WARNING,
                            ("attribute buffer too small: trying %d\n",
                            bufferSize
                            ));

            }
        }
    }
    if (error == ERROR_SUCCESS) {

        //
        // we successfully got a buffer of attributes. Return the attributes
        // requested, either in the user buffer or via the enumerator
        //

        error = GetAttributes(lpfnEnumerator,
                              categoryId,
                              attributeId,
                              lpszAttributeName,
                              (LPSTR)attributeBuffer,
                              attributeLength,
                              lpBuffer,
                              dwBufferLength,
                              lpdwCharactersReturned
                              );
    }
    if (attributeBuffer != NULL) {
        DEL(attributeBuffer);
    }

quit:

    BOOL success;

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;

#endif
}

//
//INTERNETAPI_(BOOL) GopherSendDataA(
//    IN HINTERNET hGopherSession,
//    IN LPCSTR lpszLocator,
//    IN LPCSTR lpszBuffer,
//    IN DWORD dwNumberOfCharactersToSend,
//    OUT LPDWORD lpdwNumberOfCharactersSent,
//    IN DWORD dwContext
//    )
//
///*++
//
//Routine Description:
//
//    Sends arbitrary text to a gopher server. This function is used primarily
//    for returning the results of a gopher+ ASK item
//
//Arguments:
//
//    hGopherSession              - identifies the gopher session object
//
//    lpszLocator                 - pointer to locator identifying item to send
//                                  data for
//
//    lpszBuffer                  - pointer to buffer containing data to send
//
//    dwNumberOfCharactersToSend  - number of bytes in lpszBuffer
//
//    lpdwNumberOfCharactersSent  - pointer to returned number of bytes sent
//
//    dwContext                   - app-supplied context value for use in call-backs
//
//Return Value:
//
//    BOOL
//        Success - TRUE
//
//        Failure - FALSE. Call GetLastError()/InternetGetLastResponseInfo() for
//                  more information
//
//--*/
//
//{
//    DEBUG_ENTER_API((DBG_API,
//                     Bool,
//                     "GopherSendDataA",
//                     "%#x, %q, %#x, %d, %#x, %#x",
//                     hGopherSession,
//                     lpszLocator,
//                     lpszBuffer,
//                     dwNumberOfCharactersToSend,
//                     lpdwNumberOfCharactersSent,
//                     dwContext
//                     ));
//
//    DEBUG_ERROR(API, ERROR_CALL_NOT_IMPLEMENTED);
//
//    //
//    // this is the handle we are currently working on
//    //
//
//    InternetSetObjectHandle(hGopherSession, hGopherSession);
//
//    //
//    // clear the per-handle object last error variables
//    //
//
//    InternetClearLastError();
//
//    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
//
//    DEBUG_LEAVE_API(FALSE);
//
//    return FALSE;
//}

//
//DWORD
//pGfrGetUrlInfo(
//    IN HANDLE InternetConnectHandle,
//    OUT LPSTR Url
//    )
//
///*++
//
//Routine Description:
//
//    description-of-function.
//
//Arguments:
//
//    InternetConnectHandle   -
//    Url                     -
//
//Return Value:
//
//    DWORD
//
//--*/
//
//{
//    return( ERROR_CALL_NOT_IMPLEMENTED );
//}


DWORD
pGopherGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR    lpszTargetHost,
    IN LPSTR    lpszCWD,
    IN LPSTR    lpszObjectLocator,
    IN LPSTR    lpszExtension,
    IN DWORD    dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    Creates an URL for a gopher entity

Arguments:

    SchemeType          - protocol scheme (INTERNET_SCHEME_GOPHER)

    lpszTargetHost      - server

    lpszCWD             - current directory at server

    lpszObjectLocator   - gopher locator string

    lpszExtension       - file extension

    dwPort              - port at server

    lplpUrlName         - pointer to returned URL

    lpdwUrlLen          - pointer to returned URL length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

                  ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error, dwUrlLen, dwExtensionLength;
    BOOL fDoneOnce = FALSE;

    if (lpszExtension) {
        dwExtensionLength = lstrlen(lpszExtension)
                            + lstrlen(GOPHER_EXTENSION_DELIMITER_SZ);
    } else {
        dwExtensionLength = 0;
    }
    *lplpUrlName = NULL;
    *lpdwUrlLen = 128 + dwExtensionLength;  // let us try with less first

    BOOL isDir;

    error = TestLocatorType(lpszObjectLocator, GOPHER_TYPE_DIRECTORY);
    isDir = error == ERROR_SUCCESS;

    error = ERROR_INVALID_PARAMETER;

    do {

        INET_ASSERT(*lplpUrlName == NULL);

        //
        // BUGBUG - LPTR!
        //

        //*lplpUrlName = (LPSTR)ALLOCATE_MEMORY(LPTR, *lpdwUrlLen);

        *lplpUrlName = (LPSTR)ALLOCATE_FIXED_MEMORY(*lpdwUrlLen);
        if (!*lplpUrlName) {
            error = GetLastError();
            goto Cleanup;
        }
        dwUrlLen = *lpdwUrlLen;
#ifdef MAYBE
        if (isDir) {
            **lplpUrlName = '~';
        }
#endif //MAYBE
        error = GopherLocatorToUrl(lpszObjectLocator,
#ifdef MAYBE
                                   isDir ? (*lplpUrlName + 1) : *lplpUrlName,
                                   isDir ? (*lpdwUrlLen - 1) : *lpdwUrlLen,
#endif //MAYBE
                                   *lplpUrlName,
                                   *lpdwUrlLen,
                                   &dwUrlLen
                                   );
        if (error != ERROR_SUCCESS) {

            //
            // BUGBUG - *lplpUrlName cannot be non-NULL?
            //

            if (*lplpUrlName) {
                FREE_MEMORY(*lplpUrlName);
                *lplpUrlName = NULL;
            }
        }
        if (!fDoneOnce) {
            if (error != ERROR_INSUFFICIENT_BUFFER) {
                break;
            } else {
                *lpdwUrlLen = INTERNET_MAX_URL_LENGTH + dwExtensionLength;
                fDoneOnce = TRUE;
            }
        } else {
            break;
        }
    } while (TRUE);

    if (error == ERROR_SUCCESS) {
        if (lpszExtension) {

            INET_ASSERT(dwExtensionLength);

            lstrcat(*lplpUrlName, GOPHER_EXTENSION_DELIMITER_SZ);
            lstrcat(*lplpUrlName, lpszExtension);
        }
    }

Cleanup:

    return error;
}


PRIVATE
BOOL
FGopherBeginCacheReadProcessing(
    IN HINTERNET hGopher,
    IN LPCSTR lpszFileName,
    IN LPCSTR lpszViewType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fIsHtmlFind
    )
{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "FGopherBeginCacheReadProcessing",
                 "%#x, %q, %q, %#x, %#x, %B",
                 hGopher,
                 lpszFileName,
                 lpszViewType,
                 dwFlags,
                 dwContext,
                 fIsHtmlFind
                 ));

    DWORD dwError = ERROR_SUCCESS;
    URLGEN_FUNC fn = pGopherGetUrlString;
    LPCACHE_ENTRY_INFO lpCEI = NULL;
    BOOL ok;

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->IsCacheReadInProgress()) {
        goto quit;
    }

    if (!(dwFlags & INTERNET_FLAG_NO_CACHE_WRITE)) {

        //
        // if the object name is not set then all cache methods fail
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetObjectName(
                                                        (LPSTR)lpszFileName,
                                                        (LPSTR)lpszViewType,
                                                        &fn
                                                        );

        //
        // set the cache flags like RELOAD etc.
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetCacheFlags(dwFlags);
    } else {

        //
        // set flags to disable both read and write
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetCacheFlags(
                                                        INTERNET_FLAG_DONT_CACHE
                                                        | INTERNET_FLAG_RELOAD
                                                        );
    }

    if (!FGopherCanReadFromCache(hGopher)) {
        dwError = !ERROR_SUCCESS;
        goto quit;
    }

    DEBUG_PRINT(GOPHER,
                INFO,
                ("Checking in the cache\n"
                ));

    dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->BeginCacheRetrieval(&lpCEI);
    if (dwError == ERROR_SUCCESS) {

        //
        // found it in the cache
        //

        DEBUG_PRINT(GOPHER,
                    INFO,
                    ("Found in the cache\n"
                    ));

        if (IsOffline()
        || (!FIsGopherExpired(hGopher, lpCEI)
            && ((fIsHtmlFind && lpCEI->lpszFileExtension)
            || (!fIsHtmlFind && !lpCEI->lpszFileExtension)))) {

            dwError = ERROR_SUCCESS;
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetFromCache();
        } else {

            DEBUG_PRINT(GOPHER,
                        INFO,
                        ("Expired or invalid datatype\n"
                        ));

            dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->EndCacheRetrieval();

            INET_ASSERT(dwError == ERROR_SUCCESS);

            dwError = ERROR_FILE_NOT_FOUND;
        }
    }

    if (lpCEI != NULL) {
        lpCEI = (LPCACHE_ENTRY_INFO)FREE_MEMORY(lpCEI);

        INET_ASSERT(lpCEI == NULL);

    }

quit:

    ok = (dwError == ERROR_SUCCESS);

    DEBUG_LEAVE(ok);

    return ok;
}


PRIVATE
BOOL
FGopherCanReadFromCache(
    HINTERNET hGopher
    )
{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "FGopherCanReadFromCache",
                 "%#x",
                 hGopher
                 ));

    DWORD dwOpenFlags = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->GetInternetOpenFlags();
    DWORD dwCacheFlags = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->GetCacheFlags();
    BOOL ok = TRUE;

    //
    // in disconnected state client always reads
    //

    if (((dwOpenFlags | dwCacheFlags) & INTERNET_FLAG_OFFLINE) || IsOffline()) {

        DEBUG_PRINT(GOPHER,
                    INFO,
                    ("open flags=%#x, cache flags=%#x, offline=%B\n",
                    dwOpenFlags,
                    dwCacheFlags,
                    IsOffline()
                    ));

    } else if (dwCacheFlags & (INTERNET_FLAG_RELOAD | INTERNET_FLAG_RESYNCHRONIZE)) {

        //
        // if we are asked to reload data, it is not OK to read from cache
        //

        DEBUG_PRINT(GOPHER,
                    INFO,
                    ("no cache option\n"
                    ));

        ok = FALSE;
    }

    DEBUG_LEAVE(ok);

    return ok;
}


PRIVATE
BOOL
FGopherBeginCacheWriteProcessing(
    IN HINTERNET hGopher,
    IN LPCSTR lpszFileName,
    IN LPCSTR lpszViewType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fIsHtmlFind
    )
{
    DWORD   dwError = ERROR_INVALID_FUNCTION;
    URLGEN_FUNC fn = pGopherGetUrlString;
    LPSTR   lpszFileExtension, lpTemp;
    char cExt[DEFAULT_MAX_EXTENSION_LENGTH + sizeof("%09%09%2B") + 1];
    DWORD dwBuffLen;


    if (!((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->IsCacheReadInProgress()) {

        //
        // we are not reading from the cache
        // Let us ask a routine whether we should cache this
        // stuff or not
        //

        if (FGopherCanWriteToCache(hGopher)) {

            //
            // if the object name is not set then all cache methods fail
            //

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetObjectName(
                                                            (LPSTR)lpszFileName,
                                                            (LPSTR)lpszViewType,
                                                            &fn
                                                            );

            //
            // set the cache flags
            //

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetCacheFlags(dwFlags);

            //
            // he says we can cache it.
            //

            DEBUG_PRINT(GOPHER,
                        INFO,
                        ("Starting cache write\n"
                        ));

            if (!fIsHtmlFind) {
                dwBuffLen = sizeof(cExt);

                lpszFileExtension = GetFileExtensionFromUrl(
                    ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->GetURL(),
                    &dwBuffLen
                    );

                if (lpszFileExtension != NULL) {

                    //
                    // strip off gopher+ strings
                    //

                    for (lpTemp = lpszFileExtension;
                        *lpTemp != 0 && * lpTemp != '%';
                        ++lpTemp) {

                        //
                        // EMPTY LOOP
                        //

                    }

                    dwBuffLen = (DWORD) PtrDifference(lpTemp, lpszFileExtension);
                    memcpy(cExt, lpszFileExtension, dwBuffLen);
                    cExt[dwBuffLen] = '\0';
                    lpszFileExtension = cExt;
                }
            }
            else {
                //generate htm extension
                strcpy(cExt, "htm");
                lpszFileExtension = cExt;
            }

            dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->BeginCacheWrite(
                0,
                lpszFileExtension
                );

            if (dwError != ERROR_SUCCESS) {

                DEBUG_PRINT(GOPHER,
                            ERROR,
                            ("Error in BeginCacheWrite %ld\n",
                            dwError
                            ));

            }
        }
    }
    return (dwError == ERROR_SUCCESS);
}


PRIVATE
BOOL
FGopherCanWriteToCache(
    HINTERNET   hGopher
    )
{
    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->
    GetCacheFlags() & INTERNET_FLAG_DONT_CACHE) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopher,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    )
{

    FILETIME ftLastModTime, ftExpiryTime, ftPostCheck;
    DWORD   dwEntryType;

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->IsCacheWriteInProgress()) {

        ftLastModTime.dwLowDateTime =
        ftLastModTime.dwHighDateTime = 0;

        ftExpiryTime.dwLowDateTime =
        ftExpiryTime.dwHighDateTime = 0;

        ftPostCheck.dwLowDateTime =
        ftPostCheck.dwHighDateTime = 0;


        dwEntryType = (!fNormal)?0xffffffff:
                        ((((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->

                            GetCacheFlags() & INTERNET_FLAG_MAKE_PERSISTENT)
                                ? STICKY_CACHE_ENTRY:0
                        );

         DEBUG_PRINT(GOPHER,
                     INFO,
                     ("Cache write EntryType = %x\r\n", dwEntryType
                     ));

        return (((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->EndCacheWrite(
                    &ftExpiryTime,
                    &ftLastModTime,
                    &ftPostCheck,
                    dwEntryType,
                    0,
                    NULL,
                    lpszFileExtension
                    ));
    }
    return (ERROR_SUCCESS);
}


PRIVATE
BOOL
FIsGopherExpired(
    HINTERNET hGopher,
    LPCACHE_ENTRY_INFO lpCEI
    )
{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "FIsGopherExpired",
                 "%#x, %#x",
                 hGopher,
                 lpCEI
                 ));

    FILETIME ft;
    BOOL fExpired = TRUE;

    GetCurrentGmtTime(&ft);
    if (CheckExpired(   hGopher,
                        &fExpired,
                        lpCEI,
                        dwdwGopherDefaultExpiryDelta) != ERROR_SUCCESS) {
        fExpired = TRUE;
    }

    DEBUG_LEAVE(fExpired);

    return (fExpired);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrapir.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapir.cxx

Abstract:

    Contains the remote-side gopher API worker functions. In each case, the API
    proper validates the arguments. The worker functions contained herein just
    perform the requested operation with the supplied arguments.

    These functions are the remote side of the RPC interface. If the DLL is
    the abstract0 version (no RPC) then the A forms of the functions simply
    call the w functions

    Contents:
        wGopherFindFirst
        wGopherFindNext
        wGopherFindClose
        wGopherOpenFile
        wGopherReadFile
        wGopherQueryDataAvailable
        wGopherCloseHandle
        wGopherGetAttribute
        wGopherConnect
        wGopherDisconnect
        (GetView)

Author:

    Richard L Firth (rfirth) 14-Oct-1994

Environment:

    Win32 DLL

Revision History:

    14-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// manifests
//

#define DEFAULT_REQUEST_BUFFER_LENGTH   (MAX_GOPHER_SELECTOR_TEXT + GOPHER_REQUEST_TERMINATOR_LENGTH + 1)

//
// private data
//

char szQuery[] = "query "; // prepend to CSO searches

//
// private prototypes
//

PRIVATE
DWORD
GetView(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType,
    IN LPSTR Request,
    IN BOOL RequestIsGopherPlus,
    IN DWORD ResponseFlags,
    OUT LPVIEW_INFO* pViewInfo
    );

extern
DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopherFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

//
// functions
//


DWORD
wGopherFindFirst(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATA lpBuffer OPTIONAL,
    OUT LPHINTERNET lpHandle
    )

/*++

Routine Description:

    Connects to the gopher server, sends a request to get directory information,
    gets the response and converts the gopher descriptor strings to
    GOPHER_FIND_DATA structures

Arguments:

    lpszLocator         - pointer to descriptor of information to get

    lpszSearchString    - pointer to strings to search for if Locator is search
                          server. This argument MUST be present if Locator is
                          an search server

    lpBuffer            - pointer to user-allocated buffer in which to return
                          info

    lpHandle            - pointer to returned handle if ERROR_SUCCESS returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                  WSA error

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherFindFirst",
                "%q, %q, %#x, %#x",
                lpszLocator,
                lpszSearchString,
                lpBuffer,
                lpHandle
                ));

    DWORD gopherType;
    LPSTR requestPtr;
    DWORD requestLen;
    char hostName[MAX_GOPHER_HOST_NAME + 1];
    DWORD hostNameLen;
    DWORD port;
    LPSTR gopherPlus;
    LPSESSION_INFO sessionInfo;
    DWORD error;
    HINTERNET findHandle;
    LPVIEW_INFO viewInfo;
    DWORD newRequestLength;
    DWORD searchStringsLength;

    //
    // initialise variables in case of early exit (via goto)
    //

    sessionInfo = NULL;

    //
    // grab a buffer for the request string
    //

    requestLen = DEFAULT_REQUEST_BUFFER_LENGTH;
    requestPtr = (LPSTR)ResizeBuffer(NULL, requestLen, FALSE);
    if (requestPtr == NULL) {

        DEBUG_LEAVE(ERROR_NOT_ENOUGH_MEMORY);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // pull the individual fields out of the locator. Not interested in display
    // string
    //

    hostNameLen = sizeof(hostName);
    if (!CrackLocator(lpszLocator,
                      &gopherType,
                      NULL,         // DisplayString
                      NULL,         // DisplayStringLength
                      requestPtr,   // SelectorString
                      &requestLen,  // SelectorStringLength
                      hostName,
                      &hostNameLen,
                      &port,
                      &gopherPlus
                      )) {
        error = ERROR_GOPHER_INVALID_LOCATOR;
        goto quit;
    }

    //
    // find the session 'object'. If we don't have one describing the requested
    // gopher server then create one
    //

    sessionInfo = FindOrCreateSession(hostName, port, &error);
    if (sessionInfo == NULL) {
        goto quit;
    }

    //
    // if the request is gopher+ or plain gopher but we know the server is
    // gopher+ then we automatically promote the request to be gopher+. It
    // potentially makes life easier for this DLL (the server could tell us
    // the exact length of the response or be more discerning about errors)
    // and potentially gives more information to the app. Either way, the app
    // doesn't lose by this
    //

    if (gopherPlus || IsGopherPlusSession(sessionInfo)) {
        gopherType |= GOPHER_TYPE_GOPHER_PLUS;
    }

    //
    // calculate the length of the extra strings we have to add to the selector
    //

    newRequestLength = requestLen;

    if (  IS_GOPHER_SEARCH_SERVER(gopherType)) {

        INET_ASSERT(lpszSearchString != NULL);
        INET_ASSERT(*lpszSearchString != '\0');

        //
        // add search strings length
        //

        searchStringsLength = strlen(lpszSearchString);
        newRequestLength += searchStringsLength;

        if (IS_GOPHER_INDEX_SERVER(gopherType)) {
            newRequestLength++; // for tab
        } else {
            newRequestLength += sizeof(szQuery) - 1;
        }

    } else {
        searchStringsLength = 0;
    }

    //
    // gopher+ requests have "\t+" or "\t$" at the end of the request
    //

    if (IS_GOPHER_PLUS(gopherType)) {
        newRequestLength += 2;
    }

    //
    // all requests terminated by "\r\n". Add 1 for string terminator
    //

    newRequestLength += sizeof(GOPHER_REQUEST_TERMINATOR);

    //
    // grow the buffer if necessary
    //

    if (newRequestLength > DEFAULT_REQUEST_BUFFER_LENGTH) {
        requestPtr = (LPSTR)ResizeBuffer((HLOCAL)requestPtr, newRequestLength, FALSE);
        if (requestPtr == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    //
    // add the additional strings
    //

    if (searchStringsLength != 0) {

        if (IS_GOPHER_INDEX_SERVER(gopherType)) {
            requestPtr[requestLen++] = GOPHER_FIELD_SEPARATOR;
        } else {
            memcpy (requestPtr + requestLen, szQuery, sizeof(szQuery) - 1);
            requestLen += sizeof(szQuery) - 1;
        }
        memcpy(&requestPtr[requestLen], lpszSearchString, searchStringsLength);
        requestLen += searchStringsLength;
    }
    if (IS_GOPHER_PLUS(gopherType)) {
        requestPtr[requestLen++] = GOPHER_FIELD_SEPARATOR;
        requestPtr[requestLen++] =
            IS_GOPHER_SEARCH_SERVER(gopherType)? '+' : '$';
    }
    memcpy(&requestPtr[requestLen],
           GOPHER_REQUEST_TERMINATOR,
           sizeof(GOPHER_REQUEST_TERMINATOR)    // don't scrub the '\0' in this case
           );

    //
    // selector munged; get the directory listing
    //

    error = GetView(sessionInfo,
                    ViewTypeFind,
                    requestPtr,
                    IS_GOPHER_PLUS(gopherType) ? TRUE : FALSE,
                    BI_DOT_AT_END,
                    &viewInfo
                    );

    //
    // if no error was reported then we can return a directory entry
    //

    if (error == ERROR_SUCCESS) {

        //
        // if the caller supplied an output buffer then convert the first
        // directory entry to the API buffer format, else the caller wants
        // all gopher directory information returned by InternetFindNextFile()
        //

        if (ARGUMENT_PRESENT(lpBuffer)) {
            error = GetDirEntry(viewInfo, lpBuffer);
        }
        if (error == ERROR_SUCCESS) {
            findHandle = viewInfo->Handle;
        } else {
            DereferenceView(viewInfo);
        }
    }

quit:

    //
    // dereference the session. If we have an active VIEW_INFO then the
    // reference count will still be > 0
    //

    if (sessionInfo != NULL) {
        DereferenceSession(sessionInfo);
    }

    //
    // if we allocated a new request buffer for a large search request then
    // free it
    //

    if (requestPtr != NULL) {
        requestPtr = (LPSTR)ResizeBuffer((HLOCAL)requestPtr, 0, FALSE);

        INET_ASSERT(requestPtr == NULL);

    }

    //
    // set the handle value - ignored by caller if we don't return ERROR_SUCCESS
    //

    *lpHandle = findHandle;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherFindNext(
    IN HINTERNET hFind,
    OUT LPGOPHER_FIND_DATA lpBuffer
    )

/*++

Routine Description:

    Remote side of GopherFindNext API. All parameters have been validated by the
    time this function is called, so we know that Buffer is large enough to
    hold all the returned data

Arguments:

    hFind       - handle of FIND_DATA, created by GopherFindFirstFile()

    lpBuffer    - pointer to user-allocated buffer for GOPHER_FIND_DATA

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Buffer contains next GOPHER_FIND_DATA structure

        Failure - ERROR_INVALID_HANDLE
                    Can't find the VIEW_INFO corresponding to hFind

                  ERROR_NO_MORE_FILES
                    We have reached the end of the directory info

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherFindNext",
                "%#x, %#x",
                hFind,
                lpBuffer
                ));

    LPVIEW_INFO viewInfo;
    DWORD error;

    //
    // locate the VIEW_INFO corresponding to hFind and the SESSION_INFO
    // that owns it
    //

    viewInfo = FindViewByHandle(hFind, ViewTypeFind);
    if (viewInfo != NULL) {

        //
        // just read out the next directory entry
        //

        error = GetDirEntry(viewInfo, lpBuffer);

        //
        // if the Find has been closed or this was the last entry, the following
        // dereference will cause the VIEW_INFO to be deleted, and if there are no
        // more requests outstanding on the SESSION_INFO then it too will be
        // deleted (via a dereference)
        //

        DereferenceView(viewInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherFindClose(
    IN HINTERNET hFind
    )

/*++

Routine Description:

    Causes the VIEW_INFO described by hFind to be removed from the SESSION_INFO
    and freed. If there are no other links to the data buffer then it too is
    deallocated

Arguments:

    hFind   - handle describing the VIEW_INFO to terminate

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherFindClose",
                "%#x",
                hFind
                ));

    DWORD error;

    //
    // atomically find and dereference the VIEW_INFO given the handle
    //

    error = DereferenceViewByHandle(hFind, ViewTypeFind);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherOpenFile(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    OUT LPHINTERNET lpHandle
    )

/*++

Routine Description:

    'Opens' a gopher file by copying it locally and returning a handle to the
    buffer

Arguments:

    lpszLocator - pointer to locator describing file to open

    lpszView    - pointer to view name - identifies type of file to retrieve

    lpHandle    - pointer to returned handle if ERROR_SUCCESS returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                  WSA error

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherOpenFile",
                "%q, %q, %#x",
                lpszLocator,
                lpszView,
                lpHandle
                ));

    DWORD error;
    DWORD gopherType;
    LPSTR requestPtr;
    DWORD requestLen;
    char hostName[MAX_GOPHER_HOST_NAME + 1];
    DWORD hostNameLen;
    DWORD port;
    LPSTR gopherPlus;
    LPSESSION_INFO sessionInfo;
    LPVIEW_INFO viewInfo;
    HINTERNET fileHandle;
    DWORD viewLen;

    //
    // initialise variables in case of early exit (via goto)
    //

    sessionInfo = NULL;
    fileHandle = NULL;

    //
    // grab a buffer for the request string
    //

    requestLen = MAX_GOPHER_SELECTOR_TEXT + 1;
    requestPtr = (LPSTR)ResizeBuffer((HLOCAL)NULL, requestLen, FALSE);
    if (requestPtr == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull the individual fields out of the locator. Not interested in display
    // string
    //

    hostNameLen = sizeof(hostName);
    if (!CrackLocator(lpszLocator,
                      &gopherType,
                      NULL,         // DisplayString
                      NULL,         // DisplayStringLength
                      requestPtr,   // SelectorString
                      &requestLen,  // SelectorStringLength
                      hostName,
                      &hostNameLen,
                      &port,
                      &gopherPlus
                      )) {
        error = ERROR_GOPHER_INVALID_LOCATOR;
        goto quit;
    }

    //
    // find the session 'object'. If we don't have one describing the requested
    // gopher server then create one
    //

    sessionInfo = FindOrCreateSession(hostName, port, &error);
    if (sessionInfo == NULL) {
        goto quit;
    }

    //
    // (see GopherFindFirstFile()). If gopher+ is requested or available then
    // make this a gopher+ request
    //

    if (gopherPlus || IsGopherPlusSession(sessionInfo)) {
        gopherType |= GOPHER_TYPE_GOPHER_PLUS;

        //
        // we at least need some space for "\t+"
        //

        viewLen = sizeof(GOPHER_PLUS_INDICATOR) - 1;

        //
        // get the amount of space required for the alternate view, if supplied
        //

        if (ARGUMENT_PRESENT(lpszView)) {

            //
            // the extra +1 here is for the '+' between the selector and the
            // alternate view string: the '\0' is handled by
            // sizeof(GOPHER_REQUEST_TERMINATOR)
            //

            viewLen += strlen(lpszView);
        }
    } else {

        //
        // the caller may have supplied an alternate view for a gopher0 even
        // though it is meaningless. Ensure that it is not used
        //

        lpszView = NULL;
        viewLen = 0;
    }

    //
    // grow the buffer if it is not large enough to hold the view etc. Note, if
    // this is true, then we have bust one of our internal limits, which is
    // unexpected to say the least. But this way, we can allow apps to present
    // completely bogus (so we think) parameters, and at least give them a try
    //

    if ((requestLen + viewLen + sizeof(GOPHER_REQUEST_TERMINATOR))
    > (MAX_GOPHER_SELECTOR_TEXT + 1)) {
        requestPtr = (LPSTR)ResizeBuffer((HLOCAL)requestPtr,
                                         requestLen
                                         + viewLen
                                         + sizeof(GOPHER_REQUEST_TERMINATOR),
                                         FALSE
                                         );
        if (requestPtr == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    //
    // if this is a gopher plus request, then add the "\t+". If there is an
    // alternate view then it will be appended to the plus, else we just add
    // the line terminator
    //

    if (IS_GOPHER_PLUS(gopherType)) {
        memcpy(&requestPtr[requestLen],
               GOPHER_PLUS_INDICATOR,
               sizeof(GOPHER_PLUS_INDICATOR) - 1
               );
        requestLen += sizeof(GOPHER_PLUS_INDICATOR) - 1;
    }

    //
    // add the alternate view information, if any was supplied
    //

    if (ARGUMENT_PRESENT(lpszView)) {
        memcpy(&requestPtr[requestLen], lpszView, viewLen);
        requestLen += viewLen;
    }

    //
    // in gopher0 and gopher+ cases we must terminate the selector by CR-LF
    //

    memcpy(&requestPtr[requestLen],
           GOPHER_REQUEST_TERMINATOR,
           sizeof(GOPHER_REQUEST_TERMINATOR)
           );

    //
    // selector munged; get the file
    //

    error = GetView(sessionInfo,
                    ViewTypeFile,
                    requestPtr,
                    (gopherPlus != NULL)
                        ? TRUE
                        : FALSE,
                    IS_DOT_TERMINATED_REQUEST(gopherType)
                        ? BI_DOT_AT_END
                        : 0,
                    &viewInfo
                    );
    if (error == ERROR_SUCCESS) {
        fileHandle = viewInfo->Handle;
    }

quit:

    //
    // free the request buffer
    //

    if (requestPtr != NULL) {
        requestPtr = (LPSTR)ResizeBuffer((HLOCAL)requestPtr, 0, FALSE);

        INET_ASSERT(requestPtr == NULL);

    }

    //
    // dereference the session - this may cause it to be deleted
    //

    if (sessionInfo != NULL) {
        DereferenceSession(sessionInfo);
    }

    //
    // set the handle value - ignored by caller if we don't return ERROR_SUCCESS
    //

    *lpHandle = fileHandle;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherReadFile(
    IN HINTERNET hFile,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwBytesReturned
    )

/*++

Routine Description:

    Reads the next dwBufferLength bytes (or as much as is remaining) from the
    file identified by hFile and writes to lpBuffer

Arguments:

    hFile               - identifies file

    lpBuffer            - place to return file data

    dwBufferLength      - length of Buffer

    lpdwBytesReturned   - amount of data written to Buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    *lpdwBytesReturned written to lpBuffer

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find the VIEW_INFO corresponding to hFile

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherReadFile",
                "%#x, %#x, %d, %#x",
                hFile,
                lpBuffer,
                dwBufferLength,
                lpdwBytesReturned
                ));

    LPVIEW_INFO viewInfo;
    DWORD error;

    viewInfo = FindViewByHandle(hFile, ViewTypeFile);
    if (viewInfo != NULL) {

        LPBUFFER_INFO bufferInfo;

        INET_ASSERT(viewInfo->BufferInfo != NULL);

        bufferInfo = viewInfo->BufferInfo;

        bufferInfo->Buffer = lpBuffer;
        bufferInfo->BufferLength = dwBufferLength;
        error = ReadData(viewInfo, lpdwBytesReturned);
        DereferenceView(viewInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data available to be read on the socket

Arguments:

    hFile                       - identifies gopher file

    lpdwNumberOfBytesAvailable  - where number of available bytes returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherQueryDataAvailable",
                "%#x, %#x",
                hFile,
                lpdwNumberOfBytesAvailable
                ));

    DWORD bytesAvailable = 0;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(lpThreadInfo->hObjectMapped, &handleType);

    if (error != ERROR_SUCCESS) {
        return (error);
    }

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPVIEW_INFO viewInfo;
    VIEW_TYPE viewType;

    //
    // assume this is a directory list first
    //

    if ((viewInfo = FindViewByHandle(hFile, ViewTypeFind)) != NULL) {
        viewType = ViewTypeFind;
        error = ERROR_SUCCESS;
        if (viewInfo->ViewOffset < viewInfo->BufferInfo->BufferLength) {
            bytesAvailable = sizeof(GOPHER_FIND_DATA);
        }
    } else if ((viewInfo = FindViewByHandle(hFile, ViewTypeFile)) != NULL) {
        viewType = ViewTypeFile;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INVALID_HANDLE;
    }
    if ((error == ERROR_SUCCESS) && (bytesAvailable == 0)) {

        INET_ASSERT(viewInfo->BufferInfo != NULL);

        ICSocket *socket = viewInfo->BufferInfo->Socket;

        if (socket->IsValid()) {
            error = socket->DataAvailable(&bytesAvailable);
        }
        if ((error == ERROR_SUCCESS)
        && (viewType == ViewTypeFind)
        && (bytesAvailable != 0)) {
            bytesAvailable = sizeof(GOPHER_FIND_DATA);
        }
    } else {
        error = ERROR_SUCCESS;
    }

    if (viewInfo != NULL) {
        DereferenceView(viewInfo);
    }

    *lpdwNumberOfBytesAvailable = bytesAvailable;

quit:

    if ((error == ERROR_SUCCESS) && !bytesAvailable) {
        InbGopherLocalEndCacheWrite(lpThreadInfo->hObjectMapped,
                                    ((handleType==TypeFtpFindHandleHtml)
                                    ?"htm":NULL),
                                    TRUE);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherCloseHandle(
    IN HINTERNET hFile
    )

/*++

Routine Description:

    Causes the VIEW_INFO described by hFile to be removed from the
    SESSION_INFO and freed. If there are no other links to the data buffer
    then it too is deallocated

Arguments:

    hFile   - handle describing the VIEW_INFO to terminate

Return Value:

    BOOL
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherCloseHandle",
                "%#x",
                hFile
                ));

    DWORD error;

    //
    // atomically find and dereference the VIEW_INFO given the handle
    //

    error = DereferenceViewByHandle(hFile, ViewTypeFile);

    DEBUG_LEAVE(error);

    return error;
}

#if defined(GOPHER_ATTRIBUTE_SUPPORT)


DWORD
wGopherGetAttribute(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttribute,
    OUT LPBYTE lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Retrieves the requested attribute

Arguments:

    lpszLocator         - descriptor of item for which attribute information will
                          be retrieved

    lpszAttribute       - the attribute name, e.g. +VIEWS

    lpBuffer            - to receive attributes

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_ATTRIBUTE_NOT_FOUND
                  ERROR_GOPHER_NOT_GOPHER_PLUS
                  ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherGetAttribute",
                "%q, %q, %#x, %#x [%d]",
                lpszLocator,
                lpszAttribute,
                lpBuffer,
                lpdwBufferLength
                ));

    DWORD error;

    //
    // the locator we are requested to get attributes for may have come from a
    // server other than that identified in the locator. We will search any
    // VIEW_INFO buffers we have looking for the locator. In the worst case
    // we won't find it and will have to send a request to the server
    //

    error = SearchSessionsForAttribute((LPSTR)lpszLocator,
                                       (LPSTR)lpszAttribute,
                                       lpBuffer,
                                       lpdwBufferLength
                                       );
    if (error == ERROR_GOPHER_ATTRIBUTE_NOT_FOUND) {

        char request[MAX_GOPHER_SELECTOR_TEXT + 1];
        DWORD requestLen;
        char hostName[MAX_GOPHER_HOST_NAME + 1];
        DWORD hostNameLen;
        DWORD port;
        LPSTR gopherPlus;
        LPSESSION_INFO sessionInfo;
        DWORD requestType;

        //
        // its the worst case - we don't (or no longer) have the requested
        // locator/attributes. We must request them again from the server
        //

        //
        // pull the individual fields out of the locator. Not interested in display
        // string
        //

        requestLen = sizeof(request);
        hostNameLen = sizeof(hostName);
        if (!CrackLocator(lpszLocator,
                          &requestType,
                          NULL,         // DisplayString
                          NULL,         // DisplayStringLength
                          request,      // SelectorString
                          &requestLen,  // SelectorStringLength
                          hostName,
                          &hostNameLen,
                          &port,
                          &gopherPlus
                          )) {
            error = ERROR_GOPHER_INVALID_LOCATOR;
            goto quit;
        }

        //
        // if we already have a session to the server identified in the locator
        // then we will check if we already have the information stored in a
        // VIEW_INFO. If not then we must send the request for the attribute info
        //

        sessionInfo = FindOrCreateSession(hostName, port, &error);
        if (sessionInfo != NULL) {

            //
            // BUGBUG - IsGopherPlusSession needs to perform discovery if
            //          unknown
            //

//            if (IsGopherPlusSession(sessionInfo)) {
            if (TRUE) {

                LPSTR attributeRequest;

                //
                // convert the request to a request for attributes that the
                // gopher server understands
                //

                attributeRequest = MakeAttributeRequest(request,
                                                        (LPSTR)lpszAttribute
                                                        );
                if (attributeRequest != NULL) {

                    LPVIEW_INFO viewInfo;

                    error = GetView(sessionInfo,
                                    ViewTypeFind,
                                    attributeRequest,
                                    TRUE,   // RequestIsGopherPlus
                                    0,
                                    &viewInfo
                                    );

                    //
                    // done with attribute request buffer (created by
                    // MakeAttributeRequest)
                    //

                    DEL(attributeRequest);

                    //
                    // copy everything that came back to the caller's buffer
                    // if there's enough space
                    //

                    if (error == ERROR_SUCCESS) {

                        DWORD amountToCopy;

                        INET_ASSERT(viewInfo->BufferInfo->Flags & BI_RECEIVE_COMPLETE);

                        AcquireBufferLock(viewInfo->BufferInfo);
                        amountToCopy = viewInfo->BufferInfo->BufferLength;

                        //
                        // if the buffer contains dot-terminated info, then
                        // account for the dot
                        //

                        if ((viewInfo->BufferInfo->Flags & BI_DOT_AT_END)

                        //
                        // this *SHOULD* always be true, but just in case we
                        // have an anomalous situation, we don't want to
                        // return a negative value (i.e. a large DWORD value)
                        //

                        && (amountToCopy > GOPHER_DOT_TERMINATOR_LENGTH)) {
                            amountToCopy -= GOPHER_DOT_TERMINATOR_LENGTH;
                        }
                        if (amountToCopy <= *lpdwBufferLength) {

                            LPBYTE attributeBuffer;

                            attributeBuffer = viewInfo->BufferInfo->Buffer;

                            INET_ASSERT(attributeBuffer != NULL);

                            memcpy(lpBuffer, attributeBuffer, amountToCopy);
                        }

                        //
                        // whether we copied the data or not, indicate to the
                        // caller how much data is available
                        //

                        *lpdwBufferLength = amountToCopy;

                        //
                        // we are done with the buffer. Unlock the BUFFER_INFO
                        // and the VIEW_INFO. Both will probably be destroyed
                        //

                        ReleaseBufferLock(viewInfo->BufferInfo);
                        DereferenceView(viewInfo);
                    }
                } else {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                error = ERROR_GOPHER_NOT_GOPHER_PLUS;
            }

            //
            // dereference the session, possibly destroying it
            //

            DereferenceSession(sessionInfo);
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)

//
//DWORD
//wGopherConnect(
//    IN LPCSTR lpszServerName,
//    IN INTERNET_PORT nServerPort,
//    IN LPCSTR lpszUsername,
//    IN LPCSTR lpszPassword,
//    IN DWORD dwService,
//    IN DWORD dwFlags,
//    OUT LPHINTERNET lpConnectHandle
//    )
//
///*++
//
//Routine Description:
//
//    Creates a default gopher connection information 'object' from the
//    parameters supplied in InternetConnect()
//
//Arguments:
//
//    lpszServerName  - pointer to default gopher server
//
//    nServerPort     - default configured gopher port (0 for use default of 70)
//
//    lpszUsername    - our user's name
//
//    lpszPassword    - and password
//
//    dwService       - INTERNET_SERVICE_GOPHER
//
//    dwFlags         - unused
//
//    lpConnectHandle - where we return the pointer to the 'object'
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_NOT_ENOUGH_MEMORY
//
//--*/
//
//{
//    LPGOPHER_DEFAULT_CONNECT_INFO info;
//    DWORD error;
//
//    DEBUG_ENTER((DBG_GOPHER,
//                Dword,
//                "wGopherConnect",
//                "%q, %d, %q, %q, %d, %#x, %#x",
//                lpszServerName,
//                nServerPort,
//                lpszUsername,
//                lpszPassword,
//                dwService,
//                dwFlags,
//                lpConnectHandle
//                ));
//
//    UNREFERENCED_PARAMETER(dwService);
//    UNREFERENCED_PARAMETER(dwFlags);
//
//    info = NEW(GOPHER_DEFAULT_CONNECT_INFO);
//    if (info != NULL) {
//        error = ERROR_SUCCESS;
//        if (lpszServerName != NULL) {
//            info->HostName = NEW_STRING((LPSTR)lpszServerName);
//            if (info->HostName == NULL) {
//                error = ERROR_NOT_ENOUGH_MEMORY;
//            }
//        }
//        info->Port = nServerPort;
//        if ((lpszUsername != NULL) && (error == ERROR_SUCCESS)) {
//            info->UserName = NEW_STRING((LPSTR)lpszUsername);
//            if (info->UserName == NULL) {
//                error = ERROR_NOT_ENOUGH_MEMORY;
//            }
//        }
//        if ((lpszPassword != NULL) && (error == ERROR_NOT_ENOUGH_MEMORY)) {
//            info->Password = NEW_STRING((LPSTR)lpszPassword);
//            if (info->Password == NULL) {
//                error = ERROR_NOT_ENOUGH_MEMORY;
//            }
//        }
//    } else {
//        error = ERROR_NOT_ENOUGH_MEMORY;
//    }
//    if (error == ERROR_SUCCESS) {
//        *lpConnectHandle = (HINTERNET)info;
//    } else {
//        if (info != NULL) {
//            if (info->HostName != NULL) {
//                DEL_STRING(info->HostName);
//            }
//            if (info->UserName != NULL) {
//                DEL_STRING(info->UserName);
//            }
//            if (info->Password != NULL) {
//                DEL_STRING(info->Password);
//            }
//            DEL(info);
//        }
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//wGopherDisconnect(
//    IN HINTERNET hInternet
//    )
//
///*++
//
//Routine Description:
//
//    Undoes the work of wGopherConnect
//
//Arguments:
//
//    hInternet   - handle to object created by wGopherConnect. Actually just a
//                  pointer to GOPHER_DEFAULT_CONNECT_INFO structure
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_INTERNET_INTERNAL_ERROR
//                    hInternet does not identify a GOPHER_DEFAULT_CONNECT_INFO
//
//--*/
//
//{
//    LPGOPHER_DEFAULT_CONNECT_INFO info;
//    DWORD error;
//
//    DEBUG_ENTER((DBG_GOPHER,
//                Dword,
//                "wGopherDisconnect",
//                "%#x",
//                hInternet
//                ));
//
//    //
//    // BUGBUG - not expecting bogus pointer?!
//    //
//
//    info = (LPGOPHER_DEFAULT_CONNECT_INFO)hInternet;
//    if (info != NULL) {
//        if (info->HostName != NULL) {
//            DEL_STRING(info->HostName);
//        }
//        if (info->UserName != NULL) {
//            DEL_STRING(info->UserName);
//        }
//        if (info->Password != NULL) {
//            DEL_STRING(info->Password);
//        }
//        DEL(info);
//        error = ERROR_SUCCESS;
//    } else {
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}

//
// private functions
//


PRIVATE
DWORD
GetView(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType,
    IN LPSTR Request,
    IN BOOL RequestIsGopherPlus,
    IN DWORD ResponseFlags,
    OUT LPVIEW_INFO* pViewInfo
    )

/*++

Routine Description:

    Creates a 'view object'. Sends a request to the gopher server and receives
    the response. The response data is the view. Multiple simultaneous
    requests for the same data from the same server are serialized. It is
    possible that when this function terminates, the entire response may not
    have been received, but we have enough to return to the caller. In this
    case, a background thread may be actively receiving the remainder of the
    response

Arguments:

    SessionInfo         - pointer to SESSION_INFO describing the gopher server

    ViewType            - type of view being requested, File or Find

    Request             - gopher request string

    RequestIsGopherPlus - TRUE if this is a gopher+ request

    ResponseFlags       - bit-mask describing expected response buffer

    pViewInfo           - returned view info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "GetView",
                "%#x, %s, %q, %B, %#x, %#x",
                SessionInfo,
                (ViewType == ViewTypeFile) ? "File" : "Find",
                Request,
                RequestIsGopherPlus,
                ResponseFlags,
                pViewInfo
                ));

    DWORD error;
    LPVIEW_INFO viewInfo;
    BOOL viewCloned;

    //
    // find the view info that contains the results of sending Request to
    // the server identified by the session info. If this succeeds then we
    // will have added another reference to the session info
    //

    viewInfo = CreateView(SessionInfo, ViewType, Request, &error, &viewCloned);
    if (viewInfo != NULL) {

        LPBUFFER_INFO bufferInfo;

        //
        // if this is a gopher+ request then mark it in the VIEW_INFO
        //

        if (RequestIsGopherPlus) {
            viewInfo->Flags |= VI_GOPHER_PLUS;
        }

        bufferInfo = viewInfo->BufferInfo;

        INET_ASSERT(bufferInfo != NULL);

        //
        // set the expected response type (dot-terminated or not.) Only really
        // useful if request is gopher0 file
        //

        bufferInfo->Flags |= ResponseFlags;

        if (!viewCloned) {

            BOOL receiveComplete;

            //
            // if this is a directory view then we need to communicate the fact
            // that ReceiveResponse needs to allocate a buffer
            //

            if (ViewType == ViewTypeFind) {
                bufferInfo->Flags |= BI_BUFFER_RESPONSE;
            }

            //
            // the view was created. We must make the request to the gopher
            // server
            //

            error = GopherTransaction(viewInfo);

            //
            // if there were multiple simultaneous requests for the same data
            // then we must signal the request event to restart those other
            // threads. If no other threads are waiting then we can dispense
            // with the request event
            //

//            AcquireViewLock(SessionInfo, ViewType);

//            if (bufferInfo->RequestWaiters != 0) {

                //
                // the request has completed, maybe with an error. In both
                // cases, we signal the event in the BUFFER_INFO to allow
                // any concurrent requesters of the same information to
                // continue
                //

//                SetEvent(bufferInfo->RequestEvent);
//            } else {

                //
                // no other concurrent waiters. The system can have an event
                // back
                //

//                CloseHandle(bufferInfo->RequestEvent);
//                bufferInfo->RequestEvent = NULL;
//            }

//            ReleaseViewLock(SessionInfo, ViewType);

        } else {

            //
            // we no longer allow file views to be cloned - each request for a
            // file must now make a separate connection to the server
            //

            INET_ASSERT(ViewType != ViewTypeFile);

            //
            // the view was cloned. If we made the request at the same time
            // another thread was making the same request to the server then
            // wait for that other thread to signal the request event. If the
            // request event handle is NULL then we don't have to wait
            //

//            if (bufferInfo->RequestEvent != NULL) {
//                WAIT_FOR_SINGLE_OBJECT(bufferInfo->RequestEvent, error);
//            } else {
//                error = WAIT_OBJECT_0;
//            }

            //
            // if RequestEvent existed when this clone was generated then we
            // decrement the number of waiters, now that we have access to the
            // data.
            // If the number of requesters goes to zero, we grab the view lock
            // for this list. If the number of requesters is still zero then
            // we close the event handle.
            // The event handle was only required for a special purpose - to
            // hold off multiple simultaneous requesters of the same data from
            // the same server. Once the data has been retrieved, there is no
            // need to keep the event
            //

//            if (bufferInfo->RequestWaiters != 0) {
//                if (InterlockedDecrement(&bufferInfo->RequestWaiters) == 0) {

//                    AcquireViewLock(SessionInfo, ViewType);

//                    if (bufferInfo->RequestWaiters == 0) {
//                        CloseHandle(bufferInfo->RequestEvent);
//                        bufferInfo->RequestEvent = NULL;
//                    }

//                    ReleaseViewLock(SessionInfo, ViewType);
//                }
//            }
        }

        //
        // if an error occurred then dereferencing the view should destroy it
        //

        if (error != ERROR_SUCCESS) {
            viewInfo = DereferenceView(viewInfo);
        }
    }

    *pViewInfo = viewInfo;

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrapir.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapir.c

Abstract:

    Manifests, macros, types, prototypes for gfrapir.c

Author:

    Richard L Firth (rfirth) 14-Oct-1994

Environment:

    Win32 DLL

Revision History:

    14-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

#define IS_GOPHER_SEARCH_SERVER(type) \
    (BOOL)(((type) & (GOPHER_TYPE_CSO | GOPHER_TYPE_INDEX_SERVER)))

//
// prototypes
//

DWORD
wGopherFindFirst(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATA lpBuffer OPTIONAL,
    OUT LPHINTERNET lpHandle
    );

DWORD
wGopherFindNext(
    IN HINTERNET hFind,
    OUT LPGOPHER_FIND_DATA lpszBuffer
    );

DWORD
wGopherFindClose(
    IN HINTERNET hFind
    );

DWORD
wGopherOpenFile(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    OUT LPHINTERNET lpHandle
    );

DWORD
wGopherReadFile(
    IN HINTERNET hFile,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwBytesReturned
    );

DWORD
wGopherCloseHandle(
    IN HINTERNET hFile
    );

DWORD
wGopherGetAttribute(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttribute,
    OUT LPBYTE lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrapiu.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapiu.cxx

Abstract:

    Common sub-API level functions

    Contents:
        TestLocatorType
        GetAttributes
        MakeAttributeRequest
        ParseGopherUrl
        GopherLocatorToUrl

Author:

    Richard L Firth (rfirth) 19-Nov-1994

Environment:

    Win32 user-level DLL

Revision History:

    19-Nov-1994
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>

#define INTERNET_DEFAULT_CSO_PORT     105
#define INTERNET_MAX_WELL_KNOWN_PORT 1023
//
// functions
//

BOOL IsInappropriateGopherPort (INTERNET_PORT port)
/*++

Routine Description:

    Gopher URLs can encode arbitrary data to arbitrary ports.  This characteristic
    enables malicious web pages to redirect IE to exploit security holes, for
    example, to spoof a mailer daemon inside a firewall.  Based on experimentation,
    Netscape apparently disables gopher on ports 1 and 7 though 25 odd.  That range
    covers many of the well-known ports catalogued by IANA but misses many others
    like 137 through 139, assigned for netbios over tcp/ip .  Since gopher is
    becoming increasingly irrelevant, we prefer to be stricter .  IE3 now disables
    gopher on ports less than 1024, except for 70, the standard gopher port, and
    105, typically used for CSO name searches.

Arguments: Port number

Return Value: TRUE for success, FALSE for failure

--*/
{
    if (port > INTERNET_MAX_WELL_KNOWN_PORT)
        return FALSE;
    switch (port) {
        case INTERNET_INVALID_PORT_NUMBER:
        case INTERNET_DEFAULT_GOPHER_PORT:
        case INTERNET_DEFAULT_CSO_PORT:
            return FALSE;
        default:
            return TRUE;
    }
}




DWORD
TestLocatorType(
    IN LPCSTR Locator,
    IN DWORD TypeMask
    )

/*++

Routine Description:

    Checks that Locator is valid and checks if it is of the specified type.
    This function is mainly for use by GfrIsXxxx APIs

Arguments:

    Locator     - pointer to app-supplied locator string

    TypeMask    - gopher type mask to check for

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Locator is good and of the specified type

        Failure - ERROR_INVALID_PARAMETER
                    Locator is bad

                  ERROR_INVALID_FUNCTION
                    Locator is good, but not of the specified type

--*/

{
    DWORD error;
    BOOL success = FALSE;

    //
    // BUGBUG - 1. Do we really want to test this parameter?
    //          2. If so, is the length sufficient?
    //

    if (IsBadStringPtr(Locator, MAX_GOPHER_LOCATOR_LENGTH)) {
        error = ERROR_INVALID_PARAMETER;
    } else {

        DWORD gopherType;

        gopherType = GopherCharToType(*Locator);
        if (gopherType == INVALID_GOPHER_TYPE) {

            //
            // not a recognizable type - Locator is bogus
            //

            error = ERROR_INVALID_PARAMETER;
        } else if (gopherType & TypeMask) {
            error = ERROR_SUCCESS;
        } else {

            //
            // slight bogosity - need an error code to differentiate matched
            // vs. not-matched: INVALID_FUNCTION will do
            //

            error = ERROR_INVALID_FUNCTION;
        }
    }
    return error;
}

#if defined(GOPHER_ATTRIBUTE_SUPPORT)


DWORD
GetAttributes(
    IN GOPHER_ATTRIBUTE_ENUMERATOR Enumerator,
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN LPCSTR AttributeName,
    IN LPSTR InBuffer,
    IN DWORD InBufferLength,
    OUT LPBYTE OutBuffer,
    IN DWORD OutBufferLength,
    OUT LPDWORD CharactersReturned
    )

/*++

Routine Description:

    Pulls attributes out of a buffer and puts them in the caller's buffer or
    enumerates them (if Enumerator supplied)

Arguments:

    Enumerator          - address of caller's enumerator function

    CategoryId          - category of attribute(s)

    AttributeId         - the attribute to return

    AttributeName       - name of the attribute if not a known attribute

    InBuffer            - pointer to buffer containing gopher+ attributes

    InBufferLength      - length of attribute buffer

    OutBuffer           - pointer to caller's buffer where attributes returned

    OutBufferLength     - length of caller's buffer

    CharactersReturned  - pointer to returned buffer length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_ATTRIBUTE_NOT_FOUND
                    We couldn't find the requested attribute/category

                  ERROR_INSUFFICIENT_BUFFER
                    The caller's buffer isn't large enough to contain the
                    attributes. *lpdwCharactersReturned will contain the
                    required length

                  ERROR_GOPHER_DATA_ERROR
                    We couldn't parse the attributes for some reason

--*/

{
    DWORD error;

    *CharactersReturned = 0;

    //
    // the buffer starts with the "+INFO:" attribute describing the locator. We
    // don't return this as an attribute
    //

    if (SkipLine(&InBuffer, &InBufferLength)) {

        LPSTR endSection;
        BOOL done;
        BOOL found;
        BOOL more;

        if (CategoryId != GOPHER_CATEGORY_ID_ALL) {

            //
            // advance InBuffer to the line that contains the requested
            // attribute
            //

            found = FindAttribute(CategoryId,
                                  AttributeId,
                                  AttributeName,
                                  &InBuffer,
                                  &InBufferLength
                                  );
            if (found) {

                //
                // if the caller requested that we return all attributes in a
                // section, then skip the line containing the category name
                //

                if (AttributeId == GOPHER_ATTRIBUTE_ID_ALL) {
                    found = SkipLine(&InBuffer, &InBufferLength);
                }
                if (found) {

                    DWORD bufferLeft;

                    //
                    // get the end of the section or line in endSection
                    //

                    endSection = InBuffer;
                    bufferLeft = InBufferLength;
                    FindNextAttribute(CategoryId,
                                      AttributeId,
                                      &endSection,
                                      &bufferLeft
                                      );
                }
            }
            error = found ? ERROR_SUCCESS : ERROR_GOPHER_ATTRIBUTE_NOT_FOUND;
        } else {
            endSection = InBuffer + InBufferLength;
        }

        more = TRUE;
        done = FALSE;

        while ((error == ERROR_SUCCESS) && (InBuffer < endSection) && more) {

            LPSTR linePtr;
            char lineBuffer[256];  // arbitrary
            DWORD lineLength;
            BOOL ok;

            linePtr = lineBuffer;
            lineLength = sizeof(lineBuffer);
            ok = CopyToEol(&linePtr,
                           &lineLength,
                           &InBuffer,
                           &InBufferLength
                           );
            if (ok) {
                if (Enumerator != NULL) {

                    //
                    // if the line starts with a '+' then (we assume) we are
                    // enumerating all attributes, in which case this line
                    // just serves to identify the next attribute section. We
                    // don't return any info
                    //

                    if (*linePtr == '+') {

                        char newCategory[32];   // arbitrary
                        int i;

                        for (i = 0; i < sizeof(newCategory); ++i) {

                            char ch;

                            ch = linePtr[i];
                            if ((ch == '\r') || (ch == '\n') || (ch == ' ') || (ch == ':')) {
                                break;
                            }
                            newCategory[i] = ch;
                        }
                        newCategory[i] = '\0';
                        MapAttributeToIds((LPCSTR)newCategory,
                                          &CategoryId,
                                          &AttributeId
                                          );
                        if (CategoryId == GOPHER_CATEGORY_ID_ABSTRACT) {

                            //
                            // BUGBUG - the remainder of this line may contain
                            //          a locator identifying the location of
                            //          a file containing the abstract
                            //

                        }
                    } else {
                        error = EnumerateAttribute(Enumerator,
                                                   linePtr,
                                                   lineLength,
                                                   OutBuffer,
                                                   OutBufferLength,
                                                   &more
                                                   );
                        done = TRUE;
                    }
                } else {

                    //
                    // get the length of the line in lineLength. N.B. We have
                    // to subtract an extra 1 because CopyToEol adds a '\0'
                    //

                    lineLength = sizeof(lineBuffer) - lineLength - 1;
                    if (OutBufferLength >= lineLength) {
                        memcpy(OutBuffer, lineBuffer, lineLength);
                        OutBuffer += lineLength;
                        OutBufferLength -= lineLength;
                        done = TRUE;
                    } else {
                        error = ERROR_INSUFFICIENT_BUFFER;
                    }

                    //
                    // always update the characters copied/required parameter
                    //

                    *CharactersReturned += lineLength;
                }
            } else {
                error = ERROR_GOPHER_DATA_ERROR;
            }
        }

        //
        // if nothing was copied or enumerated then the attribute was not found
        //

        if (!done && (error == ERROR_SUCCESS)) {
            error = ERROR_GOPHER_ATTRIBUTE_NOT_FOUND;
        }
    } else {
        error = ERROR_GOPHER_DATA_ERROR;
    }
    return error;
}


LPSTR
MakeAttributeRequest(
    IN LPSTR Selector,
    IN LPSTR Attribute
    )

/*++

Routine Description:

    Converts a gopher+ request into a request for attributes. E.g. turns
    "0Foo" into "0Foo\t!+ADMIN"

Arguments:

    Selector    - pointer to identifier of gopher+ item to get attributes for

    Attribute   - pointer to name of attribute(s) to retrieve

Return Value:

    LPSTR
        Success - pointer to allocated memory containing attribute requester

        Failure - NULL

--*/

{
    INT selectorLength;
    INT attributeLength;
    LPSTR request;

    selectorLength = (Selector != NULL) ? strlen(Selector) : 0;
    attributeLength = (Attribute != NULL) ? strlen(Attribute) : 0;
    request = NEW_MEMORY(selectorLength

                         //
                         // sizeof(GOPHER_PLUS_INFO_REQUEST) includes 2 for
                         // <CR><LF> and 1 for terminator
                         //

                         + sizeof(GOPHER_PLUS_INFO_REQUEST)
                         + attributeLength,
                         CHAR
                         );
    if (request != NULL) {
        if (Selector != NULL) {
            memcpy(request, Selector, selectorLength);
        }
        memcpy(&request[selectorLength],
               GOPHER_PLUS_ITEM_INFO,
               sizeof(GOPHER_PLUS_ITEM_INFO) - 1
               );
        selectorLength += sizeof(GOPHER_PLUS_ITEM_INFO) - 1;
        if (Attribute != NULL) {
            memcpy(&request[selectorLength], Attribute, attributeLength);
            selectorLength += attributeLength;
        }
        memcpy(&request[selectorLength],
               GOPHER_REQUEST_TERMINATOR,
               sizeof(GOPHER_REQUEST_TERMINATOR)
               );
    }
    return request;
}

#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)


DWORD
ParseGopherUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    )

/*++

Routine Description:

    URL parser for gopher URLs. Support function for InternetOpenUrl() and
    ParseUrl().

    This is a macro function that just cracks the URL and calls gopher APIs to
    do the work

Arguments:

    hInternet       - IN: Internet gateway handle
                      OUT: if successful handle of opened item, else undefined

    Url             - pointer to string containing gopher URL to open

    SchemeLength    - length of the URL scheme, exluding "://"

    Headers         - unused for gopher

    HeadersLength   - unused for gopher

    OpenFlags       - optional flags for opening a file (cache/no-cache, etc.)

    Context         - app-supplied context value for call-backs

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                 Dword,
                 "ParseGopherUrl",
                 "%#x [%#x], %q, %d, %#x, %d, %#x, %#x",
                 hInternet,
                 *hInternet,
                 Url,
                 SchemeLength,
                 Headers,
                 HeadersLength,
                 OpenFlags,
                 Context
                 ));

    DWORD error;
    DWORD gopherType;
    LPSTR selector;
    LPSTR searchString;
    HINTERNET hMapped = NULL;

    UNREFERENCED_PARAMETER(Headers);
    UNREFERENCED_PARAMETER(HeadersLength);

    //
    // extract the address information - no user name or password
    //

    DWORD urlLength;
    LPSTR pHostName;
    DWORD hostNameLength;
    INTERNET_PORT port;
    LPSTR lpszUrl = Url;

    Url += SchemeLength + sizeof("://") - 1;
    error = GetUrlAddress(&Url,
                          &urlLength,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          &pHostName,
                          &hostNameLength,
                          &port,
                          NULL
                          );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (IsInappropriateGopherPort(port)) {
        error = ERROR_INTERNET_INVALID_URL;
        goto quit;
    }

    //
    // a '/' between address and url-path is not significant to gopher
    //

    if (*Url == '/') {
        ++Url;
        --urlLength;

        //
        // the fact that we can ignore the '/' between address and url-path
        // means that it is okay to write a '\0' at the end of the host name
        //

        pHostName[hostNameLength] = '\0';
    }

    //
    // if the URL just consisted of gopher://host[:port] then by default we are
    // referencing the root gopher directory
    //

    if (*Url != '\0') {

        //
        // Before decoding, convert '?' to tab and thereafter any '+' to ' '
        //

        LPSTR lpszScan = strchr (Url, '?');
        if (lpszScan)
        {
            *lpszScan++ = '\t';
            while (*lpszScan)
            {
                INET_ASSERT (*lpszScan != '?'); // should be encoded
                if (*lpszScan == '+')
                    *lpszScan = ' ';
                lpszScan++;
            }
        }

        //
        // we need to convert the url-path before checking it for the search
        // string and gopher+ fields because we need to search for '\t' which
        // is currently encoded
        //

        if(FAILED(UrlUnescapeInPlace(Url, 0))){
            goto quit;
        }
        urlLength = lstrlen(Url);

        //
        // find the type of the gopher resource; if unknown, treat as a file
        //

        gopherType = GopherCharToType(Url[0]);
        selector = &Url[1];

        //
        // urlLength is now the length of the converted selector
        //

        --urlLength;
        searchString = (LPSTR)memchr((LPVOID)selector, '\t', urlLength);
        if (searchString != NULL) {

            LPSTR plusString;

            //
            // zero-terminate the search string, then check if for a gopher+
            // component
            //

            *searchString++ = '\0';
            plusString = (LPSTR)memchr((LPVOID)searchString,
                                       '\t',
                                       urlLength - (DWORD) (searchString - selector)
                                       );
            if (plusString != NULL) {
                *plusString++ = '\0';
                gopherType |= GOPHER_TYPE_GOPHER_PLUS;

                //
                // if the URL defines a file then we may have a view type
                //

                //
                // BUGBUG - need to handle:
                //
                //      - alternate file views
                //      - attribute requests (?)
                //      - ASK forms
                //
            }
        }
    } else {
        gopherType = GOPHER_TYPE_DIRECTORY;
        selector = NULL;
        searchString = NULL;
    }

    HINTERNET hConnect;

    //
    // initialize in case of error
    //

    hConnect = NULL;

    //
    // get the offline state
    //

    BOOL bOffline;
    DWORD dwFlags;

    bOffline = IsOffline();
    if (bOffline || (OpenFlags & INTERNET_FLAG_OFFLINE)) {
        dwFlags = INTERNET_FLAG_OFFLINE;
    } else {
        dwFlags = 0;
    }

    //
    // try to create a locator from the various parts
    //

    char locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
    DWORD locatorLength;

    locatorLength = sizeof(locator);
    if (GopherCreateLocator(pHostName,
                            port,
                            NULL,
                            selector,
                            gopherType,
                            locator,
                            &locatorLength
                            )) {

        //
        // ok, all parts present and correct; open a handle to the gopher
        // resource
        //

        hConnect = InternetConnect(*hInternet,
                                   pHostName,
                                   port,
                                   NULL,    // lpszUserName
                                   NULL,    // lpszPassword
                                   INTERNET_SERVICE_GOPHER,
                                   dwFlags,

                                   //
                                   // we are creating a "hidden" handle - don't
                                   // tell the app about it
                                   //

                                   INTERNET_NO_CALLBACK
                                   );

try_again:

        if (hConnect != NULL) {

            HINTERNET handle;

            if ( hMapped == NULL )
            {
                error = MapHandleToAddress(hConnect, (LPVOID *)&hMapped, FALSE);

                if ( (error != ERROR_SUCCESS) && (hMapped == NULL) )
                {
                    goto error_quit;
                }

                error = ERROR_SUCCESS;
            }

            INET_ASSERT(hMapped != NULL);

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->SetURL(lpszUrl);

            if (  IS_GOPHER_DIRECTORY(gopherType)
               || IS_GOPHER_SEARCH_SERVER(gopherType)) {

                // set htmlfind only if RAW is not asked

                if (!(OpenFlags & INTERNET_FLAG_RAW_DATA)) {

                    ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->SetHtmlFind(TRUE);

                    //
                    // BUGBUG: we don't have time to handle CSO searches
                    //
                    if (IS_GOPHER_PHONE_SERVER (gopherType))
                        goto cso_hack;

                    if ( IS_GOPHER_SEARCH_SERVER(gopherType)
                          && (!searchString || !searchString[0])) {

cso_hack:
                        handle = NULL;

                        if (ERROR_SUCCESS == RMakeGfrFixedObjectHandle
                            (hMapped, &handle, gopherType)) {
                            handle = ((HANDLE_OBJECT *)handle)->GetPseudoHandle();
                        }

                        DereferenceObject((LPVOID)hMapped);
                        goto got_handle;
                    }

                }

                handle = GopherFindFirstFile(hConnect,
                                             locator,
                                             searchString,
                                             NULL,
                                             OpenFlags | dwFlags,
                                             Context
                                             );


            } else {

                handle = GopherOpenFile(hConnect,
                                        locator,
                                        NULL,
                                        OpenFlags | dwFlags,
                                        Context
                                        );
            }

got_handle:

            if (handle != NULL) {

                //
                // map the handles
                //

                HINTERNET hRequestMapped;
                error = MapHandleToAddress(handle, (LPVOID *)&hRequestMapped, FALSE);
                INET_ASSERT(error == ERROR_SUCCESS);

                HINTERNET hConnectMapped;
                error = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);
                INET_ASSERT(error == ERROR_SUCCESS);

                //
                // link the request and connect handles so that the connect handle
                // object will be deleted when the request handle is closed
                //

                RSetParentHandle(hRequestMapped, hConnectMapped, TRUE);

                //
                // reduce the reference counts incremented by MapHandleToAddress()
                //

                if (hRequestMapped != NULL) {
                    DereferenceObject((LPVOID)hRequestMapped);
                }
                if (hConnectMapped != NULL) {
                    DereferenceObject((LPVOID)hConnectMapped);
                }

                //
                // return the request handle to the caller
                //

                *hInternet = handle;

                error = ERROR_SUCCESS;
                goto quit;
            } else if (!bOffline && IsOffline() && !(dwFlags & INTERNET_FLAG_OFFLINE)) {

                //
                // we went offline during the request. Try again, this time
                // from cache
                //

                dwFlags = INTERNET_FLAG_OFFLINE;
                goto try_again;
            }
        }
    }

error_quit:

    if ( hMapped != NULL )
    {
        DereferenceObject((LPVOID)hMapped);
        hMapped = NULL;
    }


    error = GetLastError();
    if (hConnect != NULL) {

        //
        // BUGBUG - this should close the item handle also (if open)
        //

        _InternetCloseHandle(hConnect);
    }

    INET_ASSERT(error != ERROR_SUCCESS);

quit:


    DEBUG_LEAVE(error);
    return error;
}


DWORD
GopherLocatorToUrl(
    IN LPSTR Locator,
    OUT LPSTR Buffer,
    IN DWORD BufferLength,
    OUT LPDWORD UrlLength
    )

/*++

Routine Description:

    Converts a gopher locator to a gopher URL. E.g. converts:

        1foo\tFoo Directory\tfoo.host\t77\t+

    to the URL:

        gopher://foo.host:77/1Foo%20Directory%09%09%2B

Arguments:

    Locator         - pointer to gopher locator to convert

    Buffer          - pointer to buffer where URL is written

    BufferLength    - size of Buffer in bytes

    UrlLength       - number of bytes written to Buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INTERNAL_ERROR
                    We blew an internal buffer limit

                  ERROR_INSUFFICIENT_BUFFER
                    Buffer is not large enough to hold the converted URL

--*/

{
    DWORD gopherType;
    char selector[MAX_GOPHER_SELECTOR_TEXT + 1];
    DWORD selectorLength;
    char hostName[MAX_GOPHER_HOST_NAME + 1];
    DWORD hostNameLength;
    DWORD gopherPort;
    LPSTR gopherPlus;
    char urlBuf[INTERNET_MAX_URL_LENGTH];
    DWORD urlBufferLength;
    LPSTR urlBuffer;
    DWORD error;
    DWORD bufLen;

    urlBufferLength = sizeof(urlBuf);
    urlBuffer = urlBuf;
    bufLen = BufferLength;

    //
    // start with the gopher protocol specifier
    //

    if (bufLen > sizeof("gopher://")) {
        memcpy(Buffer, "gopher://", sizeof("gopher://") - 1);
        Buffer += sizeof("gopher://") - 1;
        bufLen -= sizeof("gopher://") - 1;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // use CrackLocator() to get the individual parts of the locator
    //

    selectorLength = sizeof(selector);
    hostNameLength = sizeof(hostName);
    if (!CrackLocator(Locator,
                      &gopherType,
                      NULL,  // DisplayString - we don't care about this in the URL
                      NULL,  // DisplayStringLength
                      selector,
                      &selectorLength,
                      hostName,
                      &hostNameLength,
                      &gopherPort,
                      &gopherPlus
                      )) {

        //
        // most likely we bust a limit!
        //

        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    //
    // add in the host name
    //

    if (bufLen > hostNameLength) {
        memcpy(Buffer, hostName, hostNameLength);
        Buffer += hostNameLength;
        bufLen -= hostNameLength;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // add the port, but only if it is not the default (70)
    //

    if (gopherPort != INTERNET_DEFAULT_GOPHER_PORT) {
        if (bufLen > 1 + INTERNET_MAX_PORT_NUMBER_LENGTH) {

            int n;

            n = wsprintf(Buffer, ":%u", gopherPort);
            Buffer += n;
            bufLen -= (DWORD)n;
        } else {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    // add the URL-path separator and the locator type character
    //

    if (bufLen > 2) {
        *Buffer++ = '/';
        *Buffer++ = *Locator;
        bufLen -= 2;
    }

    //
    // copy the selector string, and any gopher+ addenda to a separater buffer
    //

    if (urlBufferLength > selectorLength) {
        memcpy(urlBuffer, selector, selectorLength);
        urlBuffer += selectorLength;
        urlBufferLength -=  selectorLength;
    }

    //
    // if the locator specifies a gopher+ item then add the gopher+ indicator
    //

    if (gopherPlus != NULL) {
        if (urlBufferLength > 3) {
            memcpy(urlBuffer, "\t\t+", 3);
            urlBufferLength -= 3;
            urlBuffer += 3;
        }
    }

    //
    // finally terminate the URL
    //

    if (urlBufferLength >= 1) {
        *urlBuffer++ = '\0';
        --urlBufferLength;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // now escape any special characters (e.g. space, tab, etc.) in the url-path
    //

    *UrlLength = bufLen;

    error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
                          SCHEME_GOPHER,
                          urlBuf,
                          sizeof(urlBuf) - urlBufferLength - 1,
                          Buffer,
                          UrlLength
                          );
    if (error == ERROR_SUCCESS) {
        *UrlLength += BufferLength - bufLen;
    }
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrinit.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    gfrinit.cxx

Abstract:

    Gopher protocol initialization. This used to be gfrdll.c. All DLL specific
    code has moved to internet\client\dll

    Contents:
        GopherInitialize
        GopherTerminate

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Environment:

    Win32 user-mode

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// functions
//


VOID
GopherInitialize(
    VOID
    )

/*++

Routine Description:

    Performs gopher-specific initialization

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // initialize any critical sections, lists, etc.
    //

    InitializeSerializedList(&SessionList);
}


VOID
GopherTerminate(
    VOID
    )

/*++

Routine Description:

    Performs gopher-specific termination/cleanup

Arguments:

    None.

Return Value:

    None.

--*/

{
    CleanupSessions();
    TerminateSerializedList(&SessionList);

    //
    // make sure we returned all gopher resources
    //

    ASSERT_NO_BUFFERS();
    ASSERT_NO_VIEWS();
    ASSERT_NO_SESSIONS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrapiu.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapiu.h

Abstract:

    Contains prototypes etc. for gfrapiu.c

Author:

    Richard L Firth (rfirth) 19-Nov-1994

Revision History:

    19-Nov-1994
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
TestLocatorType(
    IN LPCSTR Locator,
    IN DWORD TypeMask
    );

DWORD
GetAttributes(
    IN GOPHER_ATTRIBUTE_ENUMERATOR Enumerator,
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN LPCSTR AttributeName,
    IN LPSTR InBuffer,
    IN DWORD InBufferLength,
    OUT LPBYTE OutBuffer,
    IN DWORD OutBufferLength,
    OUT LPDWORD CharactersReturned
    );

LPSTR
MakeAttributeRequest(
    IN LPSTR Selector,
    IN LPSTR Attribute
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\parse.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    parse.h

Abstract:

    Manifests, macros, types and prototypes for parse.c

Author:

    Richard L Firth (rfirth) 17-Oct-1994

Revision History:

    17-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

BOOL
IsValidLocator(
    IN LPCSTR Locator,
    IN DWORD MaximumLength
    );

BOOL
IsGopherPlus(
    IN LPCSTR Locator
    );

BOOL
CrackLocator(
    IN LPCSTR Locator,
    OUT LPDWORD Type OPTIONAL,
    OUT LPSTR DisplayString OPTIONAL,
    IN OUT LPDWORD DisplayStringLength OPTIONAL,
    OUT LPSTR SelectorString OPTIONAL,
    IN OUT LPDWORD SelectorStringLength OPTIONAL,
    OUT LPSTR HostName OPTIONAL,
    IN OUT LPDWORD HostNameLength OPTIONAL,
    OUT LPDWORD GopherPort OPTIONAL,
    OUT LPSTR* ExtraStuff OPTIONAL
    );

DWORD
GopherCharToType(
    IN CHAR GopherChar
    );

CHAR
GopherTypeToChar(
    IN DWORD Attribute
    );

DWORD
GetDirEntry(
    IN LPVIEW_INFO ViewInfo,
    OUT LPGOPHER_FIND_DATA FindData
    );

DWORD
ReadData(
    IN LPVIEW_INFO ViewInfo,
    OUT LPDWORD BytesReturned
    );

BOOL
CopyToEol(
    IN OUT LPSTR* Destination,
    IN OUT LPDWORD DestinationLength,
    IN OUT LPSTR* Source,
    IN OUT LPDWORD SourceLength
    );

DWORD
IsGopherPlusToken(
    IN LPSTR Token,
    IN DWORD TokenLength,
    IN LPSTR Buffer,
    IN DWORD BufferLength
    );

DWORD
MapAttributeNameToId(
    IN LPCSTR AttributeName
    );

VOID
MapAttributeToIds(
    IN LPCSTR AttributeName,
    OUT LPDWORD CategoryId,
    OUT LPDWORD AttributeId
    );

BOOL
MapAttributeIdToNames(
    IN DWORD AttributeId,
    OUT LPSTR* CategoryName,
    OUT LPSTR* AttributeName
    );

DWORD
GetGopherNumber(
    IN OUT LPSTR* pString
    );

BOOL
ExtractDateAndTime(
    IN OUT LPSTR* pString,
    OUT LPFILETIME pFileTime
    );

BOOL
ExtractView(
    IN OUT LPSTR* pString,
    OUT LPSTR ContentType,
    IN OUT LPDWORD ContentTypeLength,
    OUT LPSTR Language,
    IN OUT LPDWORD LanguageLength,
    OUT LPDWORD Size
    );

BOOL
FindAttribute(
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN LPCSTR AttributeName,
    IN OUT LPSTR* Buffer,
    IN OUT LPDWORD BufferLength
    );

VOID
FindNextAttribute(
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN OUT LPSTR* Buffer,
    IN OUT LPDWORD BufferLength
    );

DWORD
EnumerateAttribute(
    IN GOPHER_ATTRIBUTE_ENUMERATOR Enumerator,
    IN LPSTR LinePtr,
    IN DWORD LineLength,
    IN LPBYTE Buffer,
    IN DWORD BufferLength,
    OUT LPBOOL ResumeEnumeration
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\inet.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inet.h

Abstract:

    Contains types, prototypes, manifests, macros, etc., for internet support
    functions

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Revision History:

    20-Mar-1995
        Created

--*/

//
// types
//

typedef struct {
    LPSTR HostName;
    INTERNET_PORT Port;
    LPSTR UserName;
    LPSTR Password;
} GOPHER_DEFAULT_CONNECT_INFO, *LPGOPHER_DEFAULT_CONNECT_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\parse.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    parse.cxx

Abstract:

    Contains functions to parse gopher information received from the server

    Contents:
        IsValidLocator
        IsGopherPlus
        CrackLocator
        GopherCharToType
        GopherTypeToChar
        GetDirEntry
        (GopherLocatorToFindData)
        ReadData
        (ExtractLine)
        (ExtractDisplayString)
        CopyToEol
        IsGopherPlusToken
        MapAttributeNameToId
        MapAttributeToIds
        MapAttributeIdToNames
        GetGopherNumber
        ExtractDateAndTime
        ExtractView
        FindAttribute
        FindNextAttribute
        EnumerateAttribute
        ParseIntField
        ParseDwordField
        ParseStringField
        ParseAdminAttribute
        ParseModDateAttribute
        ParseAbstractAttribute
        ParseViewAttribute
        ParseTreewalkAttribute
        ParseUnknownAttribute
        (ExtractAttributeName)
        (CharacterCount)
        (CountCharactersToEol)
        (CopyString)

Author:

    Richard L Firth (rfirth) 17-Oct-1994

Environment:

    Win32 user-level DLL

Revision History:

    17-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"
#include "iert.h"

//
// manifests
//

#define DEFAULT_LINE_BUFFER_LENGTH          1024    // arbitrary
#define DEFAULT_ATTRIBUTE_NAME_LENGTH       64      // "
#define DEFAULT_LANGUAGE_NAME_LENGTH        32      // "
#define DEFAULT_CONTENT_TYPE_NAME_LENGTH    80      // "
#define SEARCH_TYPE_MOD_DATE                1
#define SEARCH_TYPE_VIEW                    2

//
// macros
//

#define NUMERIC_CHARACTER_TO_NUMBER(c)  ((int)(c) - (int)('0'))

//
// prototypes
//

PRIVATE
DWORD
GopherLocatorToFindData(
    IN LPCSTR Locator,
    IN DWORD Length,
    OUT LPGOPHER_FIND_DATA FindData
    );

PRIVATE
DWORD
ExtractLine(
    IN LPVIEW_INFO ViewInfo,
    OUT LPBYTE LineBuffer,
    IN OUT LPDWORD LineBufferLength,
    IN OUT LPDWORD DataOffset
    );

PRIVATE
DWORD
ExtractDisplayString(
    IN LPCSTR Locator,
    IN OUT LPSTR* StringPointer,
    IN DWORD BufferLength
    );

PRIVATE
BOOL
SkipLeading(
    IN OUT LPSTR* String,
    IN OUT LPDWORD Length
    );

PRIVATE
DWORD
ExtractAttributeName(
    OUT LPSTR AttributeName,
    IN OUT LPDWORD AttributeNameLength,
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength
    );

PRIVATE
DWORD
CharacterCount(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    IN LPSTR TerminationSet
    );

PRIVATE
DWORD
CountCharactersToEol(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength
    );

PRIVATE
VOID
CopyString(
    IN OUT LPSTR* String,
    IN LPSTR Source,
    IN DWORD Length
    );

//
// functions
//


BOOL
IsValidLocator(
    IN LPCSTR Locator,
    IN DWORD MaximumLength
    )

/*++

Routine Description:

    Given a locator string, determines whether it is a valid gopher locator. A
    valid gopher locator must have the form:

    <GopherChar><DisplayString>TAB<SelectorString>TAB<HostName>TAB<Port>[TAB<Gopher+Stuff>]<CR><LF><EOS>

    We don't care about the contents of DisplayString, SelectorString, HostName,
    Port or Gopher+Stuff, since these will be sorted out by sockets functions or
    the gopher protocol

Arguments:

    Locator         - pointer to locator string

    MaximumLength   - maximum number characters that can be in the locator

Return Value:

    BOOL
        TRUE    - Locator is valid

        FALSE   - Locator does not look like kosher gopher locator, already

--*/

{
    BOOL success;

    success = FALSE;
    __try {

        DWORD locatorLength;

        locatorLength = strlen(Locator);

        //
        // 1. Since there are all sorts of unspecified gopher types in the world,
        // we no longer test the type, but just make sure its not 0 (which would
        // have yielded a zero locatorLength). Also check that the locator doesn't
        // break the maximum length limit
        //

        if ((locatorLength != 0) && (locatorLength <= MaximumLength)) {

            //
            // 2. <DisplayString>. Can be empty. This can be any character, ANSI
            // or otherwise, we just don't care about its contents
            //

            ++Locator;
            --locatorLength;
            while ((*Locator != '\t') && (locatorLength != 0)) {
                --locatorLength;
                ++Locator;
            }

            if ((*Locator == '\t') && (locatorLength != 0)) {

                //
                // 3. <SelectorString>. Same rules as for DisplayString: contents
                // not interesting
                //

                ++Locator;
                --locatorLength;
                while ((*Locator != '\t') && (locatorLength != 0)) {
                    --locatorLength;
                    ++Locator;
                }

                if ((*Locator == '\t') && (locatorLength != 0)) {

                    //
                    // 4. <HostName>. Again, we don't care about the characters
                    // that comprise HostName, or the length. We used to require
                    // a non-zero length
                    //

                    ++Locator;
                    --locatorLength;
                    while ((*Locator != '\t') && (locatorLength != 0)) {
                        --locatorLength;
                        ++Locator;
                    }

                    if ((*Locator == '\t') && (locatorLength != 0)) {

                        DWORD number;

                        //
                        // 5. Port. This must comprise 0..5 digit characters
                        //

                        ++Locator;
                        --locatorLength;
                        number = 0;
                        while ((*Locator != '\t')
                        && (*Locator != '\r')
                        && (*Locator != '\n')
                        && (*Locator >= '0')
                        && (*Locator <= '9')) {

                            //
                            // we are kind of assuming no leading zeroes...
                            //

                            number = number * 10 + (DWORD)(*Locator - '0');
                            --locatorLength;
                            ++Locator;
                        }

                        if (number <= (DWORD)INTERNET_MAX_PORT_NUMBER_VALUE) {

                            //
                            // 6. Optional gopher+ characters. We ignore the
                            // rest of the locator, and assume that it is
                            // correct
                            //

                            if ((*Locator == '\t') && (locatorLength >= 2)) {
                                do {
                                    ++Locator;
                                    --locatorLength;
                                } while (  (*Locator != '\r')
                                        && (*Locator != '\n')
                                        && (locatorLength != 0) );
                            }

                            //
                            // check for line termination. Because of the random
                            // nature of gopher servers, we allow 0 or more '\r'
                            // followed by '\n'. The locator MUST be terminated
                            // by '\n'
                            //

                            while ((*Locator == '\r') && (locatorLength != 0)) {
                                ++Locator;
                                --locatorLength;
                            }
                            if ((*Locator == '\n') && (locatorLength == 1)) {
                                success = TRUE;
                            }
                        }
                    }
                }
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        success = FALSE;
    }
    ENDEXCEPT
    return success;
}


BOOL
IsGopherPlus(
    IN LPCSTR Locator
    )

/*++

Routine Description:

    Returns TRUE if Locator describes a gopher+ request

    ASSUMES:    1. Locator is valid

Arguments:

    Locator - pointer to locator to check

Return Value:

    BOOL

--*/

{
    LPSTR plusStuff;

    if (!IsValidLocator(Locator, strlen(Locator))) {
        return FALSE;
    }

    //
    // use CrackLocator to see if there is gopher+ info on this locator
    //

    CrackLocator(Locator,
                 NULL,  // Type
                 NULL,  // DisplayString
                 NULL,  // DisplayStringLength
                 NULL,  // SelectorString
                 NULL,  // SelectorStringLength
                 NULL,  // HostName
                 NULL,  // HostNameLength
                 NULL,  // GopherPort
                 &plusStuff
                 );
    return (BOOL)(plusStuff != NULL);
}


BOOL
CrackLocator(
    IN LPCSTR Locator,
    OUT LPDWORD Type OPTIONAL,
    OUT LPSTR DisplayString OPTIONAL,
    IN OUT LPDWORD DisplayStringLength OPTIONAL,
    OUT LPSTR SelectorString OPTIONAL,
    IN OUT LPDWORD SelectorStringLength OPTIONAL,
    OUT LPSTR HostName OPTIONAL,
    IN OUT LPDWORD HostNameLength OPTIONAL,
    OUT LPDWORD GopherPort OPTIONAL,
    OUT LPSTR* ExtraStuff OPTIONAL
    )

/*++

Routine Description:

    Given a locator, break it into its constituent parts. The Locator argument
    is NOT modified

    ASSUMES:    1. Locator is valid

                2. If an optional pointer is supplied, the associated length
                   parameter (if applicable) must also be supplied

Arguments:

    Locator                 - pointer to locator to crack

    Type                    - optional returned type character

    DisplayString           - optional returned display string

    DisplayStringLength     - optional in/out display string buffer length

    SelectorString          - optional returned selector string

    SelectorStringLength    - optional in/out selector string buffer length

    HostName                - optional returned host name

    HostNameLength          - optional in/out host name buffer length

    GopherPort              - optional returned gopher port

    ExtraStuff              - optional returned extra (gopher+) data from end of locator.
                              This argument is a returned pointer, not a buffer. Care
                              should be taken since this argument aliases Locator (or
                              part thereof)

Return Value:

    TRUE    - locator cracked ok

    FALSE   - problem encountered cracking locator, probably substring
              breaks buffer limit

--*/

{
    LPSTR pTab;
    DWORD len;
    LPSTR extraStuff;
    DWORD locatorLength;

    locatorLength = strlen(Locator);
    if (ARGUMENT_PRESENT(Type)) {
        *Type = GopherCharToType(*Locator);
    }

    ++Locator;  // past type character
    --locatorLength;
    pTab = (LPSTR)memchr((LPVOID)Locator, '\t', locatorLength);

    INET_ASSERT(pTab != NULL);

    len = (DWORD) (pTab - Locator);
    if (ARGUMENT_PRESENT(DisplayString)) {

        INET_ASSERT(DisplayStringLength != NULL);

        if (*DisplayStringLength <= len) {
            return FALSE;
        }
        memcpy(DisplayString, Locator, len);
        DisplayString[len] = '\0';
        *DisplayStringLength = len;
    }

    Locator = pTab + 1; // past display string and TAB
    locatorLength -= (len + 1);

    pTab = (LPSTR)memchr((LPVOID)Locator, '\t', locatorLength);

    INET_ASSERT(pTab != NULL);

    len = (DWORD) (pTab - Locator);
    if (ARGUMENT_PRESENT(SelectorString)) {

        INET_ASSERT(SelectorStringLength != NULL);

        if (*SelectorStringLength <= len) {
            return FALSE;
        }
        memcpy(SelectorString, Locator, len);
        SelectorString[len] = '\0';
        *SelectorStringLength = len;
    }

    Locator = pTab + 1; // past selector string and TAB
    locatorLength -= (len + 1);

    pTab = (LPSTR)memchr((LPVOID)Locator, '\t', locatorLength);

    INET_ASSERT(pTab != NULL);

    len = (DWORD) (pTab - Locator);
    if (ARGUMENT_PRESENT(HostName)) {

        INET_ASSERT(HostNameLength != NULL);

        if (*HostNameLength <= len) {
            return FALSE;
        }
        memcpy(HostName, Locator, len);
        HostName[len] = '\0';
        *HostNameLength = len;
    }

    Locator = pTab + 1; // past host name and TAB
    locatorLength -= (len + 1);
    pTab = (LPSTR)memchr(Locator, '\t', locatorLength);
    if (pTab != NULL) {
        extraStuff = pTab + 1;  // past port and TAB
    } else {
        extraStuff = NULL;
    }

    if (ARGUMENT_PRESENT(GopherPort)) {
        *GopherPort = (DWORD)STRTOUL(Locator, NULL, 10);
    }

    if (ARGUMENT_PRESENT(ExtraStuff)) {
        *ExtraStuff = extraStuff;
    }

    return TRUE;
}


DWORD
GopherCharToType(
    IN CHAR GopherChar
    )

/*++

Routine Description:

    Converts the gopher descriptor character to a Gfr attribute

Arguments:

    GopherChar  - the gopher character to convert

Return Value:

    DWORD
        mapped gopher type or GOPHER_TYPE_UNKNOWN if we don't recognise the
        character

--*/

{
    //
    // these are the types currently specified in RFC 1436 (plus a few that
    // aren't)
    //

    switch (GopherChar) {
    case GOPHER_CHAR_TEXT_FILE:
        return GOPHER_TYPE_TEXT_FILE;

    case GOPHER_CHAR_DIRECTORY:
        return GOPHER_TYPE_DIRECTORY;

    case GOPHER_CHAR_CSO:
        return GOPHER_TYPE_CSO;

    case GOPHER_CHAR_ERROR:
        return GOPHER_TYPE_ERROR;

    case GOPHER_CHAR_MAC_BINHEX:
        return GOPHER_TYPE_MAC_BINHEX;

    case GOPHER_CHAR_DOS_ARCHIVE:
        return GOPHER_TYPE_DOS_ARCHIVE;

    case GOPHER_CHAR_UNIX_UUENCODED:
        return GOPHER_TYPE_UNIX_UUENCODED;

    case GOPHER_CHAR_INDEX_SERVER:
        return GOPHER_TYPE_INDEX_SERVER;

    case GOPHER_CHAR_TELNET:
        return GOPHER_TYPE_TELNET;

    case GOPHER_CHAR_BINARY:
        return GOPHER_TYPE_BINARY;

    case GOPHER_CHAR_REDUNDANT:
        return GOPHER_TYPE_REDUNDANT;

    case GOPHER_CHAR_TN3270:
        return GOPHER_TYPE_TN3270;

    case GOPHER_CHAR_GIF:
        return GOPHER_TYPE_GIF;

    case GOPHER_CHAR_IMAGE:
        return GOPHER_TYPE_IMAGE;

    case GOPHER_CHAR_BITMAP:
        return GOPHER_TYPE_BITMAP;

    case GOPHER_CHAR_MOVIE:
        return GOPHER_TYPE_MOVIE;

    case GOPHER_CHAR_SOUND:     // '<'
    case GOPHER_CHAR_SOUND_2:   // 's'
        return GOPHER_TYPE_SOUND;

    case GOPHER_CHAR_HTML:
        return GOPHER_TYPE_HTML;

    case GOPHER_CHAR_PDF:
        return GOPHER_TYPE_PDF;

    case GOPHER_CHAR_CALENDAR:
        return GOPHER_TYPE_CALENDAR;

    case GOPHER_CHAR_INLINE:
        return GOPHER_TYPE_INLINE;
    }
    return GOPHER_TYPE_UNKNOWN;
}


CHAR
GopherTypeToChar(
    IN DWORD GopherType
    )

/*++

Routine Description:

    Opposite of GopherCharToType

Arguments:

    GopherType  - bitmap of attributes. Only one file type and gopher plus
                  attributes can be set simultaneously

Return Value:

    CHAR
        Success - mapped gopher char
        Failure - INVALID_GOPHER_TYPE

--*/

{
    switch (GopherType & GOPHER_TYPE_MASK) {
    case GOPHER_TYPE_TEXT_FILE:
        return GOPHER_CHAR_TEXT_FILE;

    case GOPHER_TYPE_DIRECTORY:
        return GOPHER_CHAR_DIRECTORY;

    case GOPHER_TYPE_CSO:
        return GOPHER_CHAR_CSO;

    case GOPHER_TYPE_ERROR:
        return GOPHER_CHAR_ERROR;

    case GOPHER_TYPE_MAC_BINHEX:
        return GOPHER_CHAR_MAC_BINHEX;

    case GOPHER_TYPE_DOS_ARCHIVE:
        return GOPHER_CHAR_DOS_ARCHIVE;

    case GOPHER_TYPE_UNIX_UUENCODED:
        return GOPHER_CHAR_UNIX_UUENCODED;

    case GOPHER_TYPE_INDEX_SERVER:
        return GOPHER_CHAR_INDEX_SERVER;

    case GOPHER_TYPE_TELNET:
        return GOPHER_CHAR_TELNET;

    case GOPHER_TYPE_BINARY:
        return GOPHER_CHAR_BINARY;

    case GOPHER_TYPE_REDUNDANT:
        return GOPHER_CHAR_REDUNDANT;

    case GOPHER_TYPE_TN3270:
        return GOPHER_CHAR_TN3270;

    case GOPHER_TYPE_GIF:
        return GOPHER_CHAR_GIF;

    case GOPHER_TYPE_IMAGE:
        return GOPHER_CHAR_IMAGE;

    case GOPHER_TYPE_BITMAP:
        return GOPHER_CHAR_BITMAP;

    case GOPHER_TYPE_MOVIE:
        return GOPHER_CHAR_MOVIE;

    case GOPHER_TYPE_SOUND:
        return GOPHER_CHAR_SOUND;

    case GOPHER_TYPE_HTML:
        return GOPHER_CHAR_HTML;

    case GOPHER_TYPE_PDF:
        return GOPHER_CHAR_PDF;

    case GOPHER_TYPE_CALENDAR:
        return GOPHER_CHAR_CALENDAR;

    case GOPHER_TYPE_INLINE:
        return GOPHER_CHAR_INLINE;
    }
    return UNKNOWN_GOPHER_TYPE;
}


DWORD
GetDirEntry(
    IN LPVIEW_INFO ViewInfo,
    OUT LPGOPHER_FIND_DATA FindData
    )

/*++

Routine Description:

    Retrieves the next directory entry from the current VIEW_INFO data buffer.
    The buffer pointer will be updated to point to the start of the next line
    or 1 character past the end of the buffer

Arguments:

    ViewInfo    - pointer to VIEW_INFO which points to BUFFER_INFO which
                  points to buffer containing directory listing

    FindData    - pointer to user's GOPHER_FIND_DATA structure to fill in

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NO_MORE_FILES
                    End of the directory

                  ERROR_GOPHER_PROTOCOL_ERROR

--*/

{
    DWORD error;
    char lineBuf[DEFAULT_LINE_BUFFER_LENGTH];
    DWORD lineLen;
    LPSTR linePtr;
    BOOL haveLocator;

    //
    // get the next line from the buffer. If we don't have all the data that
    // constitutes a line, ExtractLine will endeavour to get it
    //

    haveLocator = FALSE;
    lineLen = sizeof(lineBuf);
    linePtr = lineBuf;
    error = ExtractLine(ViewInfo,
                        (LPBYTE)linePtr,
                        &lineLen,
                        &ViewInfo->ViewOffset
                        );

    //
    // convert lineLen to the number of characters actually extracted, minus
    // one for the '\0'. Doesn't matter if ExtractLine() failed
    //

    lineLen = sizeof(lineBuf) - (lineLen + 1);

    //
    // if we got a line of data, but the buffer contains gopher+ info then we
    // need to move the locator pointer past the "+INFO: " token
    //

    if ((error == ERROR_SUCCESS) && (ViewInfo->Flags & VI_GOPHER_PLUS)) {

        DWORD tokenLength;

        tokenLength = IsGopherPlusToken(GOPHER_PLUS_INFO_TOKEN,
                                        GOPHER_PLUS_INFO_TOKEN_LENGTH,
                                        linePtr,
                                        lineLen
                                        );
        if (tokenLength != 0) {
            linePtr += tokenLength;
            lineLen -= tokenLength;
        } else {

            //
            // hola! The "+INFO: " doesn't exist. We'll treat this as gopher0
            // info (or return an error?)
            //

            INET_ASSERT(FALSE);

            ViewInfo->Flags &= ~VI_GOPHER_PLUS;
        }
    }

    //
    // if no error occurred, convert the locator just retrieved into the
    // GOPHER_FIND_DATA structure
    //

    if (error == ERROR_SUCCESS) {
        error = GopherLocatorToFindData(linePtr, lineLen, FindData);

        //
        // if we parsed the locator OK and the buffer contains gopher+ info
        // then we must get the date and size information from the +ADMIN
        // section Mod-Date line and +VIEWS section resp.
        //

        if ((error == ERROR_SUCCESS) && (ViewInfo->Flags & VI_GOPHER_PLUS)) {

            DWORD dataOffset;
            DWORD previousOffset;
            DWORD searchType;
            BOOL done;

            haveLocator = TRUE;

            dataOffset = ViewInfo->ViewOffset;
            searchType = 0;
            done = FALSE;

            //
            // loop, reading the next line from the directory buffer. For each
            // line, parse the gopher+ token looking for the Mod-Date line,
            // or the first view line. We just skip all other lines
            //

            do {
                previousOffset = dataOffset;
                lineLen = sizeof(lineBuf);
                error = ExtractLine(ViewInfo,
                                    (LPBYTE)linePtr,
                                    &lineLen,
                                    &dataOffset
                                    );
                if (error == ERROR_SUCCESS) {

                    //
                    // again, convert lineLen to the number of characters
                    // extracted
                    //

                    lineLen = sizeof(lineBuf) - (lineLen + 1);

                    //
                    // if we found a line containing a categpry type on the
                    // previous iteration, then parse the per-category info
                    //

                    if (searchType == SEARCH_TYPE_VIEW) {

                        char contentType[DEFAULT_CONTENT_TYPE_NAME_LENGTH + 1];
                        char language[DEFAULT_LANGUAGE_NAME_LENGTH + 1];
                        DWORD contentTypeLength;
                        DWORD languageLength;
                        BOOL ok;

                        //
                        // must be views line. Just extract the first one
                        //

                        contentTypeLength = sizeof(contentType);
                        languageLength = sizeof(language);
                        ok = ExtractView(&linePtr,
                                         contentType,
                                         &contentTypeLength,
                                         language,
                                         &languageLength,
                                         &FindData->SizeLow
                                         );

                        INET_ASSERT(ok);
                        if (!ok) {
                            error = ERROR_GOPHER_DATA_ERROR;
                            break;
                        }

                        //
                        // we have the first view line. We aren't interested in
                        // the rest
                        //

                        searchType = 0;
                    } else {

                        LPSTR pAttribute;
                        char attributeBuffer[DEFAULT_CONTENT_TYPE_NAME_LENGTH + 1];
                        int i;
                        DWORD len;
                        LPSTR argPtr;

                        //
                        // pull out the first token on the line
                        //

                        i = 0;
                        len = lineLen;
                        pAttribute = linePtr;

                        //
                        // if this line has leading space, then skip it
                        //

                        while (*pAttribute == ' ') {
                            ++pAttribute;
                            --len;
                        }
                        while (len
                        && (i < sizeof(attributeBuffer) - 1)
                        && (pAttribute[i] != ' ')
                        && (pAttribute[i] != ':')
                        && (pAttribute[i] != '\r')
                        && (pAttribute[i] != '\n')) {
                            attributeBuffer[i] = pAttribute[i];
                            ++i;
                            --len;
                        }
                        attributeBuffer[i] = '\0';
                        switch (MapAttributeNameToId((LPCSTR)attributeBuffer)) {
                        case GOPHER_CATEGORY_ID_INFO:

                            //
                            // update the offset in the VIEW_INFO
                            //

                            ViewInfo->ViewOffset = previousOffset;

                            //
                            // we have got to the next directory entry. Quit
                            //

                            done = TRUE;
                            break;

                        case GOPHER_ATTRIBUTE_ID_MOD_DATE:

                            //
                            // this is the "Mod-Date" line. Find the start of
                            // the date-time field (in angle brackets) and
                            // extract the time and date to the GOPHER_FIND_DATE
                            // structure
                            //

                            argPtr = strchr(linePtr, '<');
                            if (argPtr != NULL) {
                                ExtractDateAndTime(&argPtr,
                                                   &FindData->LastModificationTime
                                                   );
                            }
                            break;

                        case GOPHER_CATEGORY_ID_VIEWS:

                            //
                            // we have found the +VIEWS section. Next thing to
                            // find is the views proper
                            //

                            searchType = SEARCH_TYPE_VIEW;
                            break;

                        default:

                            //
                            // we just skip all other lines except the line(s)
                            // containing view information, in which case
                            // searchType will be set to indicate that this line
                            // contains a view
                            //

                            break;
                        }
                    }

                } else {

                    //
                    // ExtractLine had an error
                    //

                     ViewInfo->ViewOffset = dataOffset;
                    done = TRUE;
                }
            } while ( !done );
        }
    }
    if (error == ERROR_GOPHER_END_OF_DATA) {
        if (haveLocator) {
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NO_MORE_FILES;
        }
    }
    return error;
}


PRIVATE
DWORD
GopherLocatorToFindData(
    IN LPCSTR Locator,
    IN DWORD Length,
    OUT LPGOPHER_FIND_DATA FindData
    )

/*++

Routine Description:

    Fills in the GOPHER_FIND_DATA fields from a gopher locator string. The
    strings in the GOPHER_FIND_DATA are appended after the fixed structure.

    ASSUMES 1. The buffer pointed to by FindData is large enough to hold the
               fixed and variable parts of the GOPHER_FIND_DATA

Arguments:

    Locator     - pointer to (ASCII) locator string

    Length      - length of Locator

    FindData    - pointer to GOPHER_FIND_DATA structure

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_PROTOCOL_ERROR

--*/

{
    LPSTR stringPointer;
    DWORD bufferLength;
    LPSTR locator;
    DWORD locatorLength;

    FindData->GopherType = GopherCharToType(*Locator);

    if (IsGopherPlus(Locator)) {
        FindData->GopherType |= GOPHER_TYPE_GOPHER_PLUS;
    }

    stringPointer = FindData->DisplayString;

    //
    // copy the display string into the GOPHER_FIND_DATA. We no longer care
    // about the length copied
    //

    ExtractDisplayString(Locator,
                         &stringPointer,
                         sizeof(FindData->DisplayString)
                         );

    //
    // default the size and time/date fields to zero. If we received a gopher+
    // directory list, we will fill in these fields from the attribute info
    //

    FindData->SizeLow = 0;
    FindData->SizeHigh = 0;
    FindData->LastModificationTime.dwLowDateTime = 0;
    FindData->LastModificationTime.dwHighDateTime = 0;

    //
    // copy the locator into the GOPHER_FIND_DATA
    //

    stringPointer = FindData->Locator;
    bufferLength = sizeof(FindData->Locator);
    locator = (LPSTR)Locator;
    locatorLength = Length;
    if (CopyToEol(&stringPointer, &bufferLength, &locator, &locatorLength)) {

        if (FindData->GopherType == GOPHER_TYPE_UNKNOWN) {

            DEBUG_PRINT(PARSE,
                        ERROR,
                        ("GopherLocatorToFindData(): unknown locator type: \"%s\"\n",
                        FindData->Locator
                        ));

        }

        return ERROR_SUCCESS;
    }

    //
    // CopyToEol failed to find the end-of-line in the Locator string.
    // Either something's bust, or we have received a locator that breaks
    // our locator length limit
    //

    if ((bufferLength == 0) && (locatorLength != 0)) {

        char bigLocator[2 * MAX_GOPHER_LOCATOR_LENGTH + 1];

        //
        // blown our locator length limit. We will reconstruct a slightly
        // modified (smaller) locator
        //

        stringPointer = bigLocator;
        bufferLength = sizeof(bigLocator);
        locator = (LPSTR)Locator;
        locatorLength = Length;
        if (!CopyToEol(&stringPointer, &bufferLength, &locator, &locatorLength)) {

            //
            // CopyToEol() still fails! Either this is an extremely long
            // locator, or we are not parsing a directory output
            //

            // skip to \r\n?

            INET_ASSERT(FALSE);

            return ERROR_GOPHER_DATA_ERROR;
        }

        //
        // if we think this is a locator, albeit one that breaks our internal
        // locator length limit, crack it open, and then reconstitute
        //

        if (IsValidLocator(bigLocator, sizeof(bigLocator))) {

            DWORD gopherType;
            char displayString[MAX_GOPHER_DISPLAY_TEXT * 2 + 1];
            DWORD displayStringLength;
            char selectorString[MAX_GOPHER_SELECTOR_TEXT * 2 + 1];
            DWORD selectorStringLength;
            char hostName[MAX_GOPHER_HOST_NAME * 2 + 1];
            DWORD hostNameLength;
            DWORD port;

            displayStringLength = sizeof(displayString);
            selectorStringLength = sizeof(selectorString);
            hostNameLength = sizeof(hostName);
            if (CrackLocator(bigLocator,
                             &gopherType,
                             displayString,
                             &displayStringLength,
                             selectorString,
                             &selectorStringLength,
                             hostName,
                             &hostNameLength,
                             &port,
                             NULL)) {

                //
                // we really want to ensure that only the display string is
                // broken, but we can get some weird FTP-based locators that
                // contain long selector strings. As a compromise, just add
                // an extra terminator at the relevamt maximum offset in each
                // string
                //

                displayString[MAX_GOPHER_DISPLAY_TEXT] = '\0';
                selectorString[MAX_GOPHER_SELECTOR_TEXT] = '\0';
                hostName[MAX_GOPHER_HOST_NAME] = '\0';

                //
                // and reconstruct the locator
                //

                bufferLength = sizeof(FindData->Locator);
                if (gopherType == GOPHER_TYPE_UNKNOWN) {

                    //
                    // BUGBUG - should change GopherCreateLocator() so that it
                    //          is more forgiving of 'unknown' types (accept
                    //          a character, not a bit)
                    //

                    gopherType = GOPHER_TYPE_ERROR;
                }
                if (GopherCreateLocator((LPCSTR)hostName,
                                        (INTERNET_PORT)port,
                                        (LPCSTR)displayString,
                                        (LPCSTR)selectorString,
                                        gopherType,
                                        FindData->Locator,
                                        &bufferLength)) {
                    return ERROR_SUCCESS;
                } else {

                    //
                    // GopherCreateLocator() failed
                    //

                    INET_ASSERT(FALSE);

                }
            } else {

                //
                // CrackLocator() failed
                //

                INET_ASSERT(FALSE);

            }
        } else {

            //
            // IsValidLocator() returned FALSE
            //

            INET_ASSERT(FALSE);

        }
    } else {

        //
        // ran off the end of the directory list without finding "\r\n"?
        //

        INET_ASSERT(FALSE);

    }
    return ERROR_GOPHER_DATA_ERROR;
}


DWORD
ReadData(
    IN LPVIEW_INFO ViewInfo,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Reads data from a file buffer into the caller's buffer

Arguments:

    ViewInfo        - pointer to VIEW_INFO structure

    BytesReturned   - amount of data copied to caller's buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    BytesReturned contains amount of data copied to user buffer

        Failure - ERROR_GOPHER_DATA_ERROR
                    There is an inconsistency between the VIEW_INFO and the
                    BUFFER_INFO

                  ERROR_GOPHER_END_OF_DATA
                    All data has been copied to the user buffer

                  ERROR_GOPHER_TIMEOUT
                    We got a timeout trying to communicate with the gopher
                    server

                  Win32 error
                    Returned if we have a memory or heap problem

                  WSA error
                    Socket specific error returned by ReceiveResponse()

--*/

{
    INET_ASSERT(ViewInfo != NULL);
    INET_ASSERT(ViewInfo->ViewType == ViewTypeFile);
    INET_ASSERT(ViewInfo->BufferInfo != NULL);

    if (ViewInfo->BufferInfo->Flags & BI_RECEIVE_COMPLETE) {
        *BytesReturned = 0;
        return ERROR_SUCCESS;
    } else {
        return GopherReceiveResponse(ViewInfo, BytesReturned);
    }
}


PRIVATE
DWORD
ExtractLine(
    IN LPVIEW_INFO ViewInfo,
    OUT LPBYTE LineBuffer,
    IN OUT LPDWORD LineBufferLength,
    IN OUT LPDWORD DataOffset
    )

/*++

Routine Description:

    Extracts a line from a response buffer into a local buffer. If the buffer
    does not contain all of the current line we retrieve the next chunk by
    calling ReceiveResponse()

Arguments:

    ViewInfo        - describes VIEW_INFO from which to extract line

    LineBuffer      - pointer to buffer where line will be copied

    LineBufferLength- IN: length of line buffer
                      OUT: number of bytes remaining in LineBuffer

    DataOffset      - IN: the point in the data buffer corresponding to
                      ViewInfo->BufferInfo->Buffer at which to start the
                      extraction

                      OUT: The next offset in buffer at which to start

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_DATA_ERROR
                    We had an error parsing the data

                  ERROR_GOPHER_END_OF_DATA
                    We reached the end of the info - API returns
                    ERROR_NO_MORE_FILES

                  Win32 error

--*/

{
    DWORD error;
    BOOL copied;
    LPBYTE startOfLine;
    LPBUFFER_INFO bufferInfo;

    INET_ASSERT(ViewInfo != NULL);
    INET_ASSERT(ViewInfo->BufferInfo != NULL);

    bufferInfo = ViewInfo->BufferInfo;
    startOfLine = LineBuffer;
    error = ERROR_SUCCESS;

    do {

        LPBYTE bufferPointer;
        LPBYTE responsePointer;
        DWORD bufferAvailable;
        DWORD oldBufferAvailable;

        if (*DataOffset > bufferInfo->BufferLength) {

            //
            // we think we're further into buffer than there is available data
            //

            INET_ASSERT(FALSE);

            error = ERROR_GOPHER_DATA_ERROR;

            DEBUG_PRINT(PARSE,
                        ERROR,
                        ("ExtractLine(): *DataOffset (%d) > BufferLength (%d)\n",
                        *DataOffset,
                        bufferInfo->BufferLength
                        ));

            goto quit;
        }

        if ((bufferInfo->Flags & BI_RECEIVE_COMPLETE)
        && (*DataOffset == bufferInfo->BufferLength)) {

            //
            // the caller has already reached the end of the buffer
            //

            DEBUG_PRINT(PARSE,
                        INFO,
                        ("ExtractLine(): already at EOF buffer\n"
                        ));

            error = ERROR_GOPHER_END_OF_DATA;
            goto quit;
        }

        //
        // get a pointer to the start of the buffer
        //

        bufferPointer = bufferInfo->Buffer;

        INET_ASSERT(bufferPointer != NULL);

        if (bufferPointer == NULL) {
            goto last_error_exit;
        }

        //
        // now point to the offset in the buffer where the caller thinks the
        // next line begins and reduce the buffer length by the same amount
        //

        responsePointer = bufferPointer + *DataOffset;
        bufferAvailable = bufferInfo->BufferLength - *DataOffset;

        //
        // copy from the current buffer position to the end of the line
        //

        oldBufferAvailable = bufferAvailable;
        copied = CopyToEol((LPSTR *)&LineBuffer,
                           LineBufferLength,
                           (LPSTR *)&responsePointer,
                           &bufferAvailable
                           );

        //
        // oldBufferAvailable - bufferAvailable is the amount we copied
        //

        *DataOffset += oldBufferAvailable - bufferAvailable;

        //
        // copied is TRUE if CopyToEol copied a full line
        //

        if (copied) {

            //
            // test again for ".\r\n" terminator. Someones servers terminate
            // with ".\r\r\n" which would have escaped our test in
            // ReceiveResponse(), but has now been compressed to ".\r\n" by
            // CopyToEol(). Other, equally unintelegent servers, terminate
            // with e.g. ".\r\n\x1a"  (presumably this directory was read from
            // a file and squirted out via send())
            //

            if (memcmp(startOfLine, ".\r\n", 3) == 0) {

                //
                // there should be very few bytes left in the buffer, if any,
                // depending on how the server terminated the buffer (".\r\r\n"
                // or ".\r\n\x1a", e.g.)
                //
                // N.B. 8 is an arbitrary number. I don't expect too many
                // garbage characters at the end of the buffer, but if there's
                // more than a relatively small number, we could have a ".\r\n"
                // embedded half-way down the directory listing. Implausable,
                // yes, but then there's nothing so unpredictable as the results
                // from a gopher server
                //
                // 05/23/95
                //
                // server at sutro.sfsu.edu returns a pile of garbage after the
                // end-of-buffer mark. Probably unintentional, but causes the
                // following assertion to go off:
                //
                //  INET_ASSERT(bufferInfo->BufferLength - *DataOffset <= 8);
                //

                if (bufferInfo->BufferLength - *DataOffset <= 8) {

                    DEBUG_PRINT(PARSE,
                                WARNING,
                                ("ExtractLine(): Buffer handle %#x contains data after end-of-buffer mark\n",
                                bufferInfo->Buffer
                                ));
                }

                error = ERROR_GOPHER_END_OF_DATA;
            }
        } else {

            //
            // at the time we called CopyToEol, all of the current line was
            // not in the response buffer. Get the next part of the response
            //

            AcquireBufferLock(bufferInfo);
            if (!(bufferInfo->Flags & BI_RECEIVE_COMPLETE)) {

                DWORD bytesReceived;

                error = GopherReceiveResponse(ViewInfo, &bytesReceived);
            }
            ReleaseBufferLock(bufferInfo);
        }
    } while (!copied && (error == ERROR_SUCCESS));

quit:

    return error;

last_error_exit:

    error = GetLastError();
    goto quit;
}


PRIVATE
DWORD
ExtractDisplayString(
    IN LPCSTR Locator,
    IN OUT LPSTR* StringPointer,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    Given a gopher locator string, extract the display string part

Arguments:

    Locator         - pointer to gopher locator

    StringPointer   - pointer to pointer to output string. Updated on output

    BufferLength    - amount of space in *StringPointer

Return Value:

    DWORD   Length of string extracted

--*/

{
    LPSTR originalPointer = *StringPointer;
    char ch;

    //
    // Locator starts off pointing at the type character. Move past it then
    // copy everything up to the tab character
    //

    while (((ch = *++Locator) != '\t') && BufferLength--) {
        *(*StringPointer)++ = ch;
    }
    *(*StringPointer)++ = '\0';
    return (DWORD) (*StringPointer - originalPointer);
}


BOOL
CopyToEol(
    IN OUT LPSTR* Destination,
    IN OUT LPDWORD DestinationLength,
    IN OUT LPSTR* Source,
    IN OUT LPDWORD SourceLength
    )

/*++

Routine Description:

    Copies the current gopher response line up to the end of the current line
    in the buffer. The destination string is zero terminated if TRUE is
    returned

    On exit, all parameters are updated to reflect the current positions and
    lengths of the buffers so this function can be called iteratively until
    the entire line is copied

    ASSUMES 1. The Length is absolutely reliable - i.e. when Length == 2 and
               **Source == '\r', then *(*Source + 1) == '\n'

Arguments:

    Destination         - pointer to place to copy to

    DestinationLength   - pointer to length of destination buffer, updated on output

    Source              - pointer to place to copy from (gopher response buffer)

    SourceLength        - pointer tp length of source buffer, updated on output

Return Value:

    BOOL
        TRUE    - we copied the entire line up to \r\n

        FALSE   - none or part of a line was copied

--*/

{
    LPSTR src;
    LPSTR dest;
    DWORD srcLen;
    DWORD destLen;
    BOOL copied;

    //
    // make smaller code (i.e. don't deref the parms every time)
    //

    src = *Source;
    dest = *Destination;
    srcLen = *SourceLength;
    destLen = *DestinationLength;

    while ((*src != '\r') && (*src != '\n') && (destLen != 0) && (srcLen != 0)) {
        *dest++ = *src++;
        --destLen;
        --srcLen;
    }

    //
    // we can receive multiple carriage-returns, presumably because the server
    // uses sprintf("\r\n") in text mode which expands "\n" to be \r\n in the
    // output buffer. We will collapse multiple carriage-returns
    //

    while ((*(src + 1) == '\r') && (srcLen != 0)) {
        ++src;
        --srcLen;
    }

    //INET_ASSERT((srcLen > 1) ? (*(src + 1) == '\n') : TRUE);

    //
    // if \r\n exist in the source buffer then copy them and update the length
    //

    copied = FALSE;
    if (destLen >= 3) {
        if ((srcLen >= 2) && (*src == '\r')) {
            ++src;
            --srcLen;
        }
        if ((srcLen >= 1) && (*src == '\n')) {
            ++src;
            --srcLen;

            //
            // we have reached a line-feed. It either exists on its own or was
            // prefixed by a carriage-return. This is the end of the line...
            //
            // Note, even if we did not find \r\n in the source, we create \r\n
            // in the destination
            //

            destLen -= 3;   // 1 for \r, 1 for \n, 1 for \0
            *dest++ = '\r';
            *dest++ = '\n';
            *dest++ = '\0';
            copied = TRUE;
        }
    }

    *Source = src;
    *Destination = dest;
    *SourceLength = srcLen;
    *DestinationLength = destLen;
    return copied;
}


DWORD
IsGopherPlusToken(
    IN LPSTR Token,
    IN DWORD TokenLength,
    IN LPSTR Buffer,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    Determines if a token is the gopher+ token. In order to match we need to
    match a trailing space character also. Seems that some servers return
    "+INFO" and some "+INFO:". We must handle both

Arguments:

    Token           - pointer to gopher+ token string

    TokenLength     - length of PlusToken

    Buffer          - pointer to buffer containing token to check

    BufferLength    - number of bytes in BufferPointer

Return Value:

    DWORD
        Success - Returns number of characters matched, including trailing ' '

        Failure - 0. TokenPointer does not point at PlusToken or we ran out of
                  buffer before we could make the distinction

--*/

{
    //
    // Length must contain at least the trailing space, and possibly a ':'
    //

    if (BufferLength >= TokenLength + 2) {
        if (memcmp(Buffer, Token, TokenLength) == 0) {
            if (Buffer[TokenLength] == ':') {
                ++TokenLength;
            }

            //
            // if there's a space after the token then we know its really what we
            // are searching for
            //

            if (Buffer[TokenLength] == ' ') {
                return ++TokenLength;
            }
        }
    }
    return 0;
}


DWORD
MapAttributeNameToId(
    IN LPCSTR AttributeName
    )

/*++

Routine Description:

    Given a category or attribute name, returns an identifier to avoid having
    to perform extraneous string comparisons

    ASSUMES:    1. AttributeName has correct case. Comparisons are CASE-SENSITIVE

Arguments:

    AttributeName   - name of category or attribute

Return Value:

    DWORD
        relevant identifer or GOPHER_ATTRIBUTE_ID_UNKNOWN

--*/

{
    if (AttributeName == NULL) {
        return GOPHER_CATEGORY_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_INFO_CATEGORY)) {
        return GOPHER_CATEGORY_ID_INFO;
    } else if (!stricmp(AttributeName, GOPHER_ADMIN_CATEGORY)) {
        return GOPHER_CATEGORY_ID_ADMIN;
    } else if (!stricmp(AttributeName, GOPHER_VIEWS_CATEGORY)) {
        return GOPHER_CATEGORY_ID_VIEWS;
    } else if (!stricmp(AttributeName, GOPHER_ABSTRACT_CATEGORY)) {
        return GOPHER_CATEGORY_ID_ABSTRACT;
    } else if (!stricmp(AttributeName, GOPHER_VERONICA_CATEGORY)) {
        return GOPHER_CATEGORY_ID_VERONICA;
    } else if (!stricmp(AttributeName, GOPHER_ADMIN_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_ADMIN;
    } else if (!stricmp(AttributeName, GOPHER_MOD_DATE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_MOD_DATE;
    } else if (!stricmp(AttributeName, GOPHER_TTL_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_TTL;
    } else if (!stricmp(AttributeName, GOPHER_SCORE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_SCORE;
    } else if (!stricmp(AttributeName, GOPHER_RANGE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_RANGE;
    } else if (!stricmp(AttributeName, GOPHER_SITE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_SITE;
    } else if (!stricmp(AttributeName, GOPHER_ORG_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_ORG;
    } else if (!stricmp(AttributeName, GOPHER_LOCATION_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_LOCATION;
    } else if (!stricmp(AttributeName, GOPHER_GEOG_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_GEOG;
    } else if (!stricmp(AttributeName, GOPHER_TIMEZONE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_TIMEZONE;
    } else if (!stricmp(AttributeName, GOPHER_PROVIDER_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_PROVIDER;
    } else if (!stricmp(AttributeName, GOPHER_VERSION_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_VERSION;
    } else if (!stricmp(AttributeName, GOPHER_ABSTRACT_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_ABSTRACT;
    } else if (!stricmp(AttributeName, GOPHER_VIEW_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_VIEW;
    }
    return GOPHER_ATTRIBUTE_ID_UNKNOWN;
}

#if defined(GOPHER_ATTRIBUTE_SUPPORT)


VOID
MapAttributeToIds(
    IN LPCSTR AttributeName,
    OUT LPDWORD CategoryId,
    OUT LPDWORD AttributeId
    )

/*++

Routine Description:

    Given a category or attribute name, returns an identifier to avoid having
    to perform extraneous string comparisons

    ASSUMES:    1. AttributeName has correct case. Comparisons are CASE-SENSITIVE

Arguments:

    AttributeName   - name of category or attribute

    CategoryId      - returned GOPHER_CATEGORY_ id

    AttributeId     - returned GOPHER_ATTRIBUTE_ id

Return Value:

    None.

--*/

{
    DWORD category;
    DWORD attribute;

    if (AttributeName == NULL) {
        category = GOPHER_CATEGORY_ID_ALL;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_INFO_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_INFO;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_ADMIN_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_VIEWS_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_VIEWS;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_ABSTRACT_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_ABSTRACT;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_VERONICA_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_VERONICA;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_ADMIN_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_ADMIN;
    } else if (!stricmp(AttributeName, GOPHER_MOD_DATE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_MOD_DATE;
    } else if (!stricmp(AttributeName, GOPHER_TTL_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_TTL;
    } else if (!stricmp(AttributeName, GOPHER_SCORE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_SCORE;
    } else if (!stricmp(AttributeName, GOPHER_RANGE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_RANGE;
    } else if (!stricmp(AttributeName, GOPHER_SITE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_SITE;
    } else if (!stricmp(AttributeName, GOPHER_ORG_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_ORG;
    } else if (!stricmp(AttributeName, GOPHER_LOCATION_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_LOCATION;
    } else if (!stricmp(AttributeName, GOPHER_GEOG_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_CATEGORY_ID_ADMIN;
    } else if (!stricmp(AttributeName, GOPHER_TIMEZONE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_TIMEZONE;
    } else if (!stricmp(AttributeName, GOPHER_PROVIDER_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_PROVIDER;
    } else if (!stricmp(AttributeName, GOPHER_VERSION_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_VERSION;
    } else if (!stricmp(AttributeName, GOPHER_ABSTRACT_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ABSTRACT;
        attribute = GOPHER_ATTRIBUTE_ID_ABSTRACT;
    } else if (!stricmp(AttributeName, GOPHER_VIEW_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_VIEWS;
        attribute = GOPHER_ATTRIBUTE_ID_VIEW;
    } else {
        category = GOPHER_CATEGORY_ID_UNKNOWN;
        attribute = GOPHER_ATTRIBUTE_ID_UNKNOWN;
    }
    *CategoryId = category;
    *AttributeId = attribute;
}


BOOL
MapAttributeIdToNames(
    IN DWORD AttributeId,
    OUT LPSTR* CategoryName,
    OUT LPSTR* AttributeName
    )

/*++

Routine Description:

    Do reverse transformation: given attribute ID, return the category and
    attribute names if known

Arguments:

    AttributeId     - id to map

    CategoryName    - pointer to pointer to category name

    AttributeName   - pointer to pointer to attribute name

Return Value:

    BOOL
        TRUE    - id was mapped

        FALSE   - id not recognized

--*/

{
    BOOL success = TRUE;

    switch (AttributeId) {
    case GOPHER_CATEGORY_ID_ALL:
        *CategoryName = NULL;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_INFO:
        *CategoryName = GOPHER_INFO_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_ADMIN:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_VIEWS:
        *CategoryName = GOPHER_VIEWS_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_ABSTRACT:
        *CategoryName = GOPHER_ABSTRACT_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_VERONICA:
        *CategoryName = GOPHER_VERONICA_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_ATTRIBUTE_ID_ADMIN:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_ADMIN_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_MOD_DATE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_MOD_DATE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_TTL:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_TTL_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_SCORE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_SCORE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_RANGE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_RANGE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_SITE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_SITE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_ORG:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_ORG_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_LOCATION:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_LOCATION_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_GEOG:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_GEOG_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_TIMEZONE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_TIMEZONE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_PROVIDER:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_PROVIDER_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_VERSION:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_VERSION_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_ABSTRACT:
        *CategoryName = GOPHER_ABSTRACT_CATEGORY;
        *AttributeName = GOPHER_ABSTRACT_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_VIEW:
        *CategoryName = GOPHER_VIEWS_CATEGORY;
        *AttributeName = GOPHER_VIEW_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_UNKNOWN:
        success = FALSE;
        break;

    default:
        success = FALSE;
        break;
    }
    return success;
}

#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)


DWORD
GetGopherNumber(
    IN OUT LPSTR* pString
    )

/*++

Routine Description:

    Converts a 'gopher number' to a DWORD. A gopher number is the value usually
    contained with angle brackets in e.g. a +VIEWS line, and is usually a
    fractional number with a 'k' suffix

Arguments:

    pString - pointer to pointer to string which points at the start of the
              number. The number may start with a period, indicating that it
              is less than one (hence the reason why we use a double).

              On output, the parameter points at the character after what we
              took to be the number

Return Value:

    DWORD
        DWORD representation of the number at *pString

--*/

{

    double number;

    //
    // the gopher number is usually inside angle brackets. Move the string
    // pointer past the opening bracket, if the caller has not already
    // done so
    //

    if (**pString == '<') {
        ++*pString;
    }

    //
    // allow strtod to move the string pointer forward
    //

    number = StrToDbl(*pString, pString);

    return (DWORD)number;
}


BOOL
ExtractDateAndTime(
    IN OUT LPSTR* pString,
    OUT LPFILETIME pFileTime
    )

/*++

Routine Description:

    Converts a 'gopher time-and-date' field to a WIN32 FILETIME structure. The
    gopher date-time field is a string representation of the date and time,
    contained within angle brackets and has the following format:

        <YYYYMMDDhhmmss>

    Where:

        YYYY = year (e.g. "1995")
        MM   = month (1..12)
        DD   = day of month
        hh   = hour of day in 24-hour format
        mm   = minute of hour
        ss   = second of minute

    Assumes:    1. On input, *pString contains entire field

Arguments:

    pString     - IN: points to the first character in the date-time field
                  OUT: points to the next character in the input stream

    pFileTime   - pointer to returned FILETIME structure

Return Value:

    BOOL
        Success - TRUE  - field was converted

        Failure - FALSE - a problem occurred while parsing the field

--*/

{
    SYSTEMTIME systemTime;

    if (**pString == '<') {
        ++*pString;
    }
    if (ExtractWord(pString, 4, &systemTime.wYear)
    && ExtractWord(pString, 2, &systemTime.wMonth)
    && ExtractWord(pString, 2, &systemTime.wDay)
    && ExtractWord(pString, 2, &systemTime.wHour)
    && ExtractWord(pString, 2, &systemTime.wMinute)
    && ExtractWord(pString, 2, &systemTime.wSecond)) {

        INET_ASSERT(**pString == '>');

        ++*pString;
        systemTime.wDayOfWeek = 0;
        systemTime.wMilliseconds = 0;
        return SystemTimeToFileTime(&systemTime, pFileTime);
    } else {

        INET_ASSERT(FALSE);

        return FALSE;
    }
}


BOOL
ExtractView(
    IN OUT LPSTR* pString,
    OUT LPSTR ContentType,
    IN OUT LPDWORD ContentTypeLength,
    OUT LPSTR Language,
    IN OUT LPDWORD LanguageLength,
    OUT LPDWORD Size
    )

/*++

Routine Description:

    Given a pointer to a line containing a view, parse it into its constituent
    parts. A view line has the following format:

        "{space}{content-type}{space}[{language-id}:]<{size}><CR><LF>"

    The language-id field is optional

Arguments:

    pString             - pointer to pointer to view line

    ContentType         - pointer to returned MIME content-type string

    ContentTypeLength   - IN: size of content-type buffer
                          OUT: length of content-type without terminating 0

    Language            - pointer to ISO-693 language-id (or NUL string)

    LanguageLength      - IN: size of language buffer
                          OUT: length of language without terminating 0

    Size                - pointer to returned size of view

Return Value:

    BOOL

--*/

{
    LPSTR string;
    DWORD contLen = 0;
    DWORD langLen = 0;

    string = *pString;
    while (*string == ' ') {
        ++string;
    }
    while (*string != ' ') {
        if (contLen >= *ContentTypeLength)
            return FALSE;
        *ContentType++ = *string++;
        contLen++;
    }
    *ContentType = '\0';
    *ContentTypeLength = contLen;
    while (*string == ' ') {
        ++string;
    }
    if (*string != '<') {

        //
        // must be the language field. Copy up to the terminating ':' or ' '
        //

        while ((*string != ' ') && (*string != ':')) {
            if (langLen >= *LanguageLength)
                return FALSE;
            *Language++ = *string++;
            langLen++;
        }

        //
        // move the string pointer to the start of the size field
        //

        while (*string != '<') {
            ++string;
        }
    }
    *Language = '\0';
    *LanguageLength = langLen;
    *Size = GetGopherNumber(&string);
    *pString = string;
    return TRUE;
}

#if defined(GOPHER_ATTRIBUTE_SUPPORT)

//
// manifests
//

#define SIZE_OF_GOPHER_ATTRIBUTE_FIXED_PART (2 * sizeof(DWORD))

//
// private types
//

typedef struct {
    DWORD CategoryId;
    DWORD AttributeId;
    DWORD (*Parser)(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
    DWORD NumberOfFields;
    DWORD FixedSize;
} ATTRIBUTE_PARSER, *LPATTRIBUTE_PARSER;

typedef struct {
    LPCSTR String;
} SINGLE_STRING_TYPE, *LPSINGLE_STRING_TYPE;

//
// private parser prototypes
//

PRIVATE DWORD ParseAdminAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseModDateAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseAbstractAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseViewAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseTreewalkAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseIntField(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseDwordField(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseStringField(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseUnknownAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);

//
// data
//

ATTRIBUTE_PARSER AttributeParsers[] = {
    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_ADMIN,
            ParseAdminAttribute,
                2,
                    sizeof(GOPHER_ADMIN_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_MOD_DATE,
            ParseModDateAttribute,
                1,
                    sizeof(GOPHER_MOD_DATE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_TTL,
            ParseDwordField,
                1,
                    sizeof(GOPHER_TTL_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_SCORE,
            ParseIntField,
                1,
                    sizeof(GOPHER_SCORE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_RANGE,
            ParseIntField,
                2,
                    sizeof(GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_SITE,
            ParseStringField,
                1,
                    sizeof(GOPHER_SITE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_ORG,
            ParseStringField,
                1,
                    sizeof(GOPHER_ORGANIZATION_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_LOCATION,
            ParseStringField,
                1,
                    sizeof(GOPHER_LOCATION_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_GEOG,
            ParseIntField,
                6,
                    sizeof(GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_TIMEZONE,
            ParseIntField,
                1,
                    sizeof(GOPHER_TIMEZONE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_PROVIDER,
            ParseStringField,
                1,
                    sizeof(GOPHER_PROVIDER_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_VERSION,
            ParseStringField,
                1,
                    sizeof(GOPHER_VERSION_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ABSTRACT,
        GOPHER_ATTRIBUTE_ID_ABSTRACT,
            ParseAbstractAttribute,
                2,
                    sizeof(GOPHER_ABSTRACT_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_VIEWS,
        GOPHER_ATTRIBUTE_ID_VIEW,
            ParseViewAttribute,
                3,
                    sizeof(GOPHER_VIEW_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_VERONICA,
        GOPHER_ATTRIBUTE_ID_TREEWALK,
            ParseTreewalkAttribute,
                1,
                    sizeof(GOPHER_VERONICA_ATTRIBUTE_TYPE),

    //
    // N.B. Unknown must be the last parser in the list
    //

    GOPHER_CATEGORY_ID_UNKNOWN,
        GOPHER_ATTRIBUTE_ID_UNKNOWN,
            ParseUnknownAttribute,
                1,
                sizeof(GOPHER_UNKNOWN_ATTRIBUTE_TYPE)
};

#define NUMBER_OF_PARSERS   ARRAY_ELEMENTS(AttributeParsers)

//
// functions
//


BOOL
FindAttribute(
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN LPCSTR AttributeName,
    IN OUT LPSTR* Buffer,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    CategoryId      -
    AttributeId     -
    AttributeName   -
    Buffer          -
    BufferLength    -

Return Value:

    BOOL

--*/

{
    BOOL ok;
    LPSTR categoryName;
    LPSTR attributeName;
    char searchName[DEFAULT_ATTRIBUTE_NAME_LENGTH + 1];
    DWORD id;
    int index;
    int len;

    if (AttributeId == GOPHER_ATTRIBUTE_ID_ALL) {
        id = CategoryId;
    } else {
        id = AttributeId;
    }
    ok = MapAttributeIdToNames(id, &categoryName, &attributeName);
    if (!ok) {
        attributeName = (LPSTR)AttributeName;
    }
    if (AttributeId != GOPHER_ATTRIBUTE_ID_ALL) {
        searchName[0] = ' ';
        index = 1;
    } else {
        index = 0;
        attributeName = categoryName;
    }
    len = strlen(attributeName);
    if (len >= sizeof(searchName)) {
        return FALSE;
    }
    strcpy(&searchName[index], attributeName);
    len += index;
    if (AttributeId != GOPHER_ATTRIBUTE_ID_ALL) {
        searchName[len++] = ':';
        searchName[len] = '\0';
    }
    do {
        if (*BufferLength < (DWORD)len) {
            return FALSE;
        }
        if (memcmp(*Buffer, searchName, len) == 0) {
            return TRUE;
        }
        SkipLine(Buffer, BufferLength);
    } while (*BufferLength != 0);
    return FALSE;
}


VOID
FindNextAttribute(
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN OUT LPSTR* Buffer,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    CategoryId      -
    AttributeId     -
    Buffer          -
    BufferLength    -

Return Value:

    None.

--*/

{
    BOOL found;

    INET_ASSERT((**Buffer == '+') || (**Buffer == ' '));

    if (CategoryId == GOPHER_CATEGORY_ID_UNKNOWN) {
        AttributeId = !GOPHER_ATTRIBUTE_ID_ALL;
    }

    //
    // loop looking at the next line until we find:
    //
    //  a) the end of the buffer
    //  b) the next section line (starts with '+')
    //  c) the next attribute line (starts with ' ')
    //

    for (found = FALSE; !found; ) {
        if (SkipLine(Buffer, BufferLength)) {
            if (AttributeId == GOPHER_ATTRIBUTE_ID_ALL) {
                found = (BOOL)(**Buffer == '+');
            } else {
                found = TRUE;
            }
        } else {

            //
            // end of buffer
            //

            found = TRUE;
        }
    }
}


DWORD
EnumerateAttribute(
    IN GOPHER_ATTRIBUTE_ENUMERATOR Enumerator,
    IN LPSTR LinePtr,
    IN DWORD LineLength,
    IN LPBYTE Buffer,
    IN DWORD BufferLength,
    OUT LPBOOL ResumeEnumeration
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Enumerator          -
    LinePtr             -
    LineLength          -
    Buffer              -
    BufferLength        -
    ResumeEnumeration   -

Return Value:

    DWORD

--*/

{
    DWORD error;
    char attributeName[DEFAULT_ATTRIBUTE_NAME_LENGTH + 1];
    DWORD nameLength;

    nameLength = sizeof(attributeName);
    error = ExtractAttributeName(attributeName,
                                 &nameLength,
                                 &LinePtr,
                                 &LineLength
                                 );
    if (error == ERROR_SUCCESS) {

        int i;
        DWORD categoryId;
        DWORD attributeId;
        BOOL found;

        MapAttributeToIds((LPCSTR)attributeName,
                          &categoryId,
                          &attributeId
                          );

        //
        // loop, looking fot the parser to handle this particular type. If we
        // don't find it, we will be conveniently left at the unknown parser
        // (that's why we have (NUMBER_OF_PARSERS - 1) and the unknown parser
        // at the end of the list)
        //

        for (i = 0; i < NUMBER_OF_PARSERS - 1; ++i) {
            if ((AttributeParsers[i].CategoryId == categoryId)
            && (AttributeParsers[i].AttributeId == attributeId)) {
                break;
            }
        }
        if (BufferLength >= SIZE_OF_GOPHER_ATTRIBUTE_FIXED_PART) {
            ((LPGOPHER_ATTRIBUTE_TYPE)Buffer)->CategoryId = categoryId;
            ((LPGOPHER_ATTRIBUTE_TYPE)Buffer)->AttributeId = attributeId;

            //
            // remove the fixed part from the buffer size before converting
            // the attribute
            //

            BufferLength -= SIZE_OF_GOPHER_ATTRIBUTE_FIXED_PART;
        } else {
            BufferLength = 0;
        }
        error = AttributeParsers[i].Parser(
                    &LinePtr,
                    &LineLength,
                    (LPBYTE)&((LPGOPHER_ATTRIBUTE_TYPE)Buffer)->AttributeType,
                    &BufferLength,
                    AttributeParsers[i].NumberOfFields,
                    AttributeParsers[i].FixedSize
                    );

        //
        // add back the amount of buffer space used by/required for the
        // fixed part of the GOPHER_ATTRIBUTE_TYPE structure
        //
        *ResumeEnumeration = Enumerator((LPGOPHER_ATTRIBUTE_TYPE)Buffer, error);
    }
    return error;
}


PRIVATE
DWORD
ParseIntField(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD error;

    if (*BufferLength < FixedSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = FixedSize;
    while ((error == ERROR_SUCCESS) && NumberOfFields--) {
        if (SkipLeading(LinePtr, LineLength)) {
            ExtractInt(LinePtr, 0, (LPINT)Buffer);
            Buffer = (LPBYTE)((LPINT)Buffer + 1);
        } else {
            error = ERROR_GOPHER_DATA_ERROR;
        }
    }
    return error;
}


PRIVATE
DWORD
ParseDwordField(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD error;

    if (*BufferLength < FixedSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = FixedSize;
    while ((error == ERROR_SUCCESS) && NumberOfFields--) {
        if (SkipLeading(LinePtr, LineLength)) {
            ExtractDword(LinePtr, 0, (LPDWORD)Buffer);
            Buffer = (LPBYTE)((LPDWORD)Buffer + 1);
        } else {
            error = ERROR_GOPHER_DATA_ERROR;
        }
    }
    return error;
}


PRIVATE
DWORD
ParseStringField(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD structureSize;
    DWORD error;
    DWORD stringLength;
    LPSTR stringPtr;
    LPSTR* fieldPtr;

    structureSize = 0;
    error = ERROR_SUCCESS;
    stringPtr = (LPSTR)((LPSTR)Buffer + NumberOfFields);
    fieldPtr = (LPSTR*)Buffer;
    while (NumberOfFields--) {
        SkipLeading(LinePtr, LineLength);
        stringLength = CharacterCount(LinePtr, LineLength, "\r\n");
        structureSize = sizeof(LPSTR)
                      + stringLength
                      + 1
                      ;
        if (*BufferLength >= structureSize) {
            *fieldPtr++ = stringPtr;
            CopyString(&stringPtr, *LinePtr, stringLength);
            *LinePtr += stringLength - 1;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    *BufferLength = structureSize;
    return error;
}


PRIVATE
DWORD
ParseAdminAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    LPSTR comment;
    DWORD commentLength;
    LPSTR emailAddress;
    DWORD emailAddressLength;
    LPSTR pstr;
    DWORD len;
    DWORD structureSize;
    DWORD error;

    SkipLeading(LinePtr, LineLength);
    comment = *LinePtr;
    emailAddress = strchr(*LinePtr, '<');
    if (emailAddress == NULL) {
        return ERROR_GOPHER_DATA_ERROR;
    }
    ++emailAddress;
    pstr = emailAddress;
    emailAddressLength = 0;
    len = *LineLength;
    while ((*pstr != '>') && (len != 0)) {
        ++pstr;
        ++emailAddressLength;
    }
    commentLength = (DWORD)(emailAddress - comment);
    structureSize = sizeof(GOPHER_ADMIN_ATTRIBUTE_TYPE)
                  + commentLength + 1
                  + emailAddressLength + 1
                  ;
    if (*BufferLength < structureSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = structureSize;
    if (error == ERROR_SUCCESS) {

        LPGOPHER_ADMIN_ATTRIBUTE_TYPE pStruct;
        LPSTR stringPtr;

        pStruct = (LPGOPHER_ADMIN_ATTRIBUTE_TYPE)Buffer;
        stringPtr = (LPSTR)pStruct + sizeof(GOPHER_ADMIN_ATTRIBUTE_TYPE);
        pStruct->Comment = (LPCSTR)stringPtr;
        CopyString(&stringPtr, comment, commentLength);
        pStruct->EmailAddress = (LPCSTR)stringPtr;
        CopyString(&stringPtr, emailAddress, emailAddressLength);
    }
    return error;
}


PRIVATE
DWORD
ParseModDateAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD structureSize;
    DWORD error;

    structureSize = sizeof(GOPHER_MOD_DATE_ATTRIBUTE_TYPE);
    if (*BufferLength < structureSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = structureSize;
    if (error == ERROR_SUCCESS) {

        LPSTR dateField;

        dateField = strchr(*LinePtr, '<');
        if (dateField != NULL) {
            ExtractDateAndTime(
                &dateField,
                &((LPGOPHER_MOD_DATE_ATTRIBUTE_TYPE)Buffer)->DateAndTime
                );
        } else {
            error = ERROR_GOPHER_DATA_ERROR;
        }
    }
    return error;
}


PRIVATE
DWORD
ParseAbstractAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD error;
    error = ERROR_SUCCESS;
    return error;
}


PRIVATE
DWORD
ParseViewAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    char contentType[DEFAULT_CONTENT_TYPE_NAME_LENGTH + 1];
    DWORD contentTypeLength;
    char language[DEFAULT_LANGUAGE_NAME_LENGTH + 1];
    DWORD languageLength;
    DWORD viewSize;
    BOOL ok;
    DWORD error;

    contentTypeLength = sizeof(contentType);
    languageLength = sizeof(language);
    SkipLeading(LinePtr, LineLength);
    ok = ExtractView(LinePtr,
                     contentType,
                     &contentTypeLength,
                     language,
                     &languageLength,
                     &viewSize
                     );
    if (ok) {

        DWORD structureSize;

        contentTypeLength = sizeof(contentType) - contentTypeLength;
        languageLength = sizeof(language) - languageLength;
        structureSize = sizeof(GOPHER_VIEW_ATTRIBUTE_TYPE)
                      + contentTypeLength
                      + languageLength
                      ;
        if (*BufferLength >= structureSize) {

            LPSTR stringPtr;

            stringPtr = (LPSTR)((LPGOPHER_VIEW_ATTRIBUTE_TYPE)Buffer + 1);
            ((LPGOPHER_VIEW_ATTRIBUTE_TYPE)Buffer)->ContentType = stringPtr;
            memcpy(stringPtr, contentType, contentTypeLength);
            stringPtr += contentTypeLength;
            ((LPGOPHER_VIEW_ATTRIBUTE_TYPE)Buffer)->Language = stringPtr;
            memcpy(stringPtr, language, languageLength);
            ((LPGOPHER_VIEW_ATTRIBUTE_TYPE)Buffer)->Size = viewSize;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        *BufferLength = structureSize;
    } else {
        error = ERROR_GOPHER_DATA_ERROR;
    }
    return error;
}


PRIVATE
DWORD
ParseTreewalkAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD structureSize;
    DWORD error;

    structureSize = sizeof(GOPHER_VERONICA_ATTRIBUTE_TYPE);
    if (*BufferLength < structureSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = structureSize;
    if (error == ERROR_SUCCESS) {
        SkipLeading(LinePtr, LineLength);
        if (*LineLength >= 3) {

            BOOL ok;

            ok = (BOOL)(_strnicmp(*LinePtr, "YES", 3) == 0);

            ((LPGOPHER_VERONICA_ATTRIBUTE_TYPE)Buffer)->TreeWalk = ok;
        } else {
            error = ERROR_GOPHER_DATA_ERROR;
        }
    }
    return error;
}


PRIVATE
DWORD
ParseUnknownAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD structureSize;
    DWORD error;
    DWORD stringLength;
    LPSTR stringPtr;

    stringPtr = (LPSTR)((LPGOPHER_UNKNOWN_ATTRIBUTE_TYPE)Buffer + 1);
    ((LPGOPHER_UNKNOWN_ATTRIBUTE_TYPE)Buffer)->Text = stringPtr;
    SkipLeading(LinePtr, LineLength);
    structureSize = sizeof(GOPHER_UNKNOWN_ATTRIBUTE_TYPE)
                  + *LineLength
                  + 1
                  ;
    if (*BufferLength >= structureSize) {
        CopyString(&stringPtr, *LinePtr, *LineLength);
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *BufferLength = structureSize;
    return error;
}


PRIVATE
DWORD
ExtractAttributeName(
    OUT LPSTR AttributeName,
    IN OUT LPDWORD AttributeNameLength,
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    AttributeName       -
    AttributeNameLength -
    LinePtr             -
    LineLength          -

Return Value:

    DWORD

--*/

{
    return ERROR_SUCCESS;
}


PRIVATE
DWORD
CharacterCount(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    IN LPSTR TerminationSet
    )

/*++

Routine Description:

    Returns the number of characters in a string, up to, but not including
    the termination character. Termination character is defined as being a
    member of TerminationSet

Arguments:

    LinePtr         - IN: Pointer to string to count characters in
                      OUT: Pointer to string at character found from
                      TerminationSet

    LineLength      - IN: Current length of LinePtr
                      OUT: Remaining length of LinePtr

    TerminationSet  - Pointer to string containing characters which will
                      terminate counting

Return Value:

    DWORD
        Number of character in LinePtr, up to, but not including the
        termination character

--*/

{
    char terminationChars[256];
    int i;
    DWORD count;

    //
    // zap discovery matrix, 4 bytes at a time
    //

    for (i = 0; i < ARRAY_ELEMENTS(terminationChars); i += sizeof(DWORD)) {
        *(LPDWORD)&terminationChars[i] = 0;
    }

    //
    // for each character that we are interested in, set its matrix entry to
    // non-zero
    //

    for (i = 0; TerminationSet[i] != '\0'; ++i) {
        terminationChars[(int)TerminationSet[i]] = 1;
    }

    //
    // loop, looking for end-of-string (LineLength decremented to 0) or one
    // of the termination characters
    //

    for (count = 0; *LineLength != 0; ) {

        char ch;

        ch = *(*LinePtr)++;
        --*LineLength;
        if (terminationChars[(int)ch]) {
            break;
        }
        ++count;
    }
    return count;
}


PRIVATE
DWORD
CountCharactersToEol(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength
    )

/*++

Routine Description:

    Special-case version of CharacterCount - knows that the termination set
    comprised <CR>, <LF>

Arguments:

    LinePtr     - Pointer to pointer to string to count. Updated on output

    LineLength  - Pointer to length of string. Updated on output

Return Value:

    DWORD
        Length of string

--*/

{
    int i;
    DWORD count;

    //
    // loop, looking for end-of-string (LineLength decremented to 0) or one
    // of the termination characters
    //

    for (count = 0; *LineLength != 0; ) {

        char ch;

        ch = *(*LinePtr)++;
        --*LineLength;
        if ((ch == '\r') || (ch == '\n')) {
            break;
        }
        ++count;
    }
    return count;
}


PRIVATE
BOOL
SkipLeading(
    IN OUT LPSTR* String,
    IN OUT LPDWORD Length
    )
{
    while (((**String == ' ') || (**String == ':')) && (*Length != 0)) {
        ++*String;
        --*Length;
    }
    return (BOOL)(*Length != 0);
}


PRIVATE
VOID
CopyString(
    IN OUT LPSTR* String,
    IN LPSTR Source,
    IN DWORD Length
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    String  -
    Source  -
    Length  -

Return Value:

    None.

--*/

{
    memcpy(*String, Source, Length);
    *String += Length;
    *((*String)++) = '\0';
}

#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\gfrapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapiw.cxx

Abstract:

    UNICODE versions of Windows Internet Extensions (WINX) Gopher Protocol APIs
    (in gfrapia.c)

    Contents:
        GopherCreateLocatorW
        GopherGetLocatorType
        GopherFindFirstFileW
        GopherFindNextW
        GopherOpenFileW
        GopherGetAttributeW
        GopherSendDataW

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Environment:

    Win32 user-level DLL

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"


//
// functions
//


INTERNETAPI_(BOOL) GopherCreateLocatorW(
    IN LPCWSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszDisplayString OPTIONAL,
    IN LPCWSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPWSTR lpszLocator,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherCreateLocatorW",
                     "%wq, %d, %wq, %wq, %#x, %#x, %#x [%d]",
                     lpszHost,
                     nServerPort,
                     lpszDisplayString,
                     lpszSelectorString,
                     dwGopherType,
                     lpszLocator,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpLocator,mpDisplay,mpSelector,mpHost;
    BOOL fResult = FALSE;

    if (!lpszHost || !lpdwBufferLength
        || (IsBadStringPtrW(lpszHost, INTERNET_MAX_PATH_LENGTH + 1))
        || (IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszHost,0,mpHost);
    if (!mpHost.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszHost,mpHost);
    if (lpszDisplayString)
    {
        ALLOC_MB(lpszDisplayString,0,mpDisplay);
        if (!mpDisplay.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszDisplayString,mpDisplay);
    }
    if (lpszSelectorString)
    {
        ALLOC_MB(lpszSelectorString,0,mpSelector);
        if (!mpSelector.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszSelectorString,mpSelector);
    }
    mpLocator.dwSize = *lpdwBufferLength;

    if (lpszLocator)
    {
        mpLocator.dwAlloc = *lpdwBufferLength*sizeof(CHAR);
        mpLocator.psStr = (LPSTR)ALLOC_BYTES(mpLocator.dwAlloc);
        if (!mpLocator.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    fResult = GopherCreateLocatorA(mpHost.psStr,nServerPort,mpDisplay.psStr,mpSelector.psStr,
        dwGopherType,mpLocator.psStr,&mpLocator.dwSize);

    *lpdwBufferLength = mpLocator.dwSize*sizeof(WCHAR);

    if (fResult && (*lpdwBufferLength <= mpLocator.dwAlloc))
    {
        *lpdwBufferLength = (MultiByteToWideChar(CP_ACP, 0, mpLocator.psStr, -1,
                    lpszLocator, mpLocator.dwAlloc/sizeof(WCHAR))+1)*sizeof(WCHAR);
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) GopherGetLocatorTypeW(
    IN LPCWSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherGetLocatorTypeW",
                     "%wq, %#x",
                     lpszLocator,
                     lpdwGopherType
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpLocator;

    if (!lpszLocator)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszLocator,0,mpLocator);
    if (!mpLocator.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszLocator,mpLocator);
    fResult = GopherGetLocatorTypeA(mpLocator.psStr,lpdwGopherType);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL
TransformGopherFindDataToW(LPGOPHER_FIND_DATAA pgfdA, LPGOPHER_FIND_DATAW pgfdW)
{
    pgfdW->GopherType = pgfdA->GopherType;
    pgfdW->SizeLow = pgfdA->SizeLow;
    pgfdW->SizeHigh = pgfdA->SizeHigh;
    pgfdW->LastModificationTime = pgfdA->LastModificationTime;
    MultiByteToWideChar(CP_ACP, 0, pgfdA->DisplayString, -1,
            pgfdW->DisplayString, MAX_GOPHER_DISPLAY_TEXT + 1);
    MultiByteToWideChar(CP_ACP, 0, pgfdA->Locator, -1,
            pgfdW->Locator, MAX_GOPHER_LOCATOR_LENGTH + 1);

    return TRUE;
}


INTERNETAPI_(HINTERNET) GopherFindFirstFileW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator OPTIONAL,
    IN LPCWSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAW lpBuffer OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "GopherFindFirstFileW",
                     "%#x, %wq, %wq, %#x, %#x, %$x",
                     hGopherSession,
                     lpszLocator,
                     lpszSearchString,
                     lpBuffer,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet=NULL;
    MEMORYPACKET mpLocator, mpSearch;
    GOPHER_FIND_DATAA gfda;

    if (lpszLocator && (IsBadStringPtrW(lpszLocator, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_GOPHER_INVALID_LOCATOR;
        goto cleanup;
    }
    if ((lpszSearchString && (IsBadStringPtrW(lpszSearchString, INTERNET_MAX_PATH_LENGTH + 1)))
        || (lpBuffer && (IsBadWritePtr(lpBuffer, sizeof(*lpBuffer)))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpszLocator)
    {
        ALLOC_MB(lpszLocator,0,mpLocator);
        if (!mpLocator.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszLocator,mpLocator);
    }
    if (lpszSearchString)
    {
        ALLOC_MB(lpszSearchString,0,mpSearch);
        if (!mpSearch.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszSearchString,mpSearch);
    }
    hInternet = GopherFindFirstFileA(hGopherSession, mpLocator.psStr, mpSearch.psStr,
                                    &gfda, dwFlags, dwContext);
    if (hInternet && lpBuffer)
    {
        TransformGopherFindDataToW(&gfda, lpBuffer);
    }


cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOL
GopherFindNextW(
    IN HINTERNET hFind,
    OUT LPGOPHER_FIND_DATA lpBuffer
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


INTERNETAPI_(HINTERNET) GopherOpenFileW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "GopherOpenFileW",
                     "%#x, %wq, %wq, %#x, %#x",
                     hGopherSession,
                     lpszLocator,
                     lpszView,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpLocator,mpView;

    if (!lpszLocator)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszLocator,0,mpLocator);
    if (!mpLocator.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszLocator,mpLocator);
    if (lpszView)
    {
        ALLOC_MB(lpszView,0,mpView);
        if (!mpView.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszView,mpView);
    }
    hInternet = GopherOpenFileA(hGopherSession,mpLocator.psStr,mpView.psStr,dwFlags,dwContext);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(BOOL) GopherGetAttributeW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD_PTR dwContext
    )
{
#if !defined(GOPHER_ATTRIBUTE_SUPPORT)

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;

#else
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherGetAttributeW",
                     "%#x, %wq, %wq, %#x, %d, %#x, %#x, %#x",
                     hGopherSession,
                     lpszLocator,
                     lpszAttributeName,
                     lpBuffer,
                     dwBufferLength,
                     lpdwCharactersReturned,
                     lpfnEnumerator,
                     dwContext
                     ));

    // WARNING: This function may not function after all; You've been warned.
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpLocator,mpAttribute;

    ALLOC_MB(lpszLocator,0,mpLocator);
    if (!mpLocator.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszLocator,mpLocator);
    if (lpszAttributeName)
    {
        ALLOC_MB(lpszAttributeName,0,mpAttribute);
        if (!mpAttribute.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszAttributeName,mpAttribute);
    }
    fResult = GopherGetAttributeA(hGopherSession,mpLocator.psStr,mpAttribute.psStr,
        lpBuffer,dwBufferLength,lpdwCharactersReturned, lpfnEnumerator, dwContext);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        DEBUG_ERROR(API, dwErr);
        SetLastError(dwErr); 
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)
}

//
//INTERNETAPI_(BOOL) GopherSendDataW(
//    IN HINTERNET hGopherSession,
//    IN LPCWSTR lpszLocator,
//    IN LPCWSTR lpszBuffer,
//    IN DWORD dwNumberOfCharactersToSend,
//    OUT LPDWORD lpdwNumberOfCharactersSent,
//    IN DWORD dwContext
//    )
//{
//#if 1
//    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
//    return FALSE;
//#else
//    DWORD dwErr;
//    MEMORYPACKET mpLocator,mpView;
//
//    MAKE_ANSI(lpszLocator,0,mpLocator);
//    if (lpszView)
//    {
//       MAKE_ANSI(lpszView,0,mpView);
//    }
//    return GopherSendDataA(hGopherSession,mpLocator.psStr,mpView.psStr,dwFlags);
//
//    LEAVE_API_CALL(FALSE);
//#endif
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\session.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    Contains functions for maintaining the global session list and SESSION_INFO
    specific functions

    Contents:
        AcquireSessionLock
        ReleaseSessionLock
        CleanupSessions
        (CleanupViewList)
        FindOrCreateSession
        (CreateSession)
        (DestroySession)
        ReferenceSession
        DereferenceSession
        AcquireViewLock
        ReleaseViewLock
        GopherTransaction
        IsServerGopherPlus
        IsGopherPlusSession
        SearchSessionsForAttribute

Author:

    Richard L Firth (rfirth) 19-Oct-1994

Environment:

    Win32 DLL

Revision History:

    19-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// manifests
//

#define NULL_HANDLE ((HANDLE)0)

//
// private prototypes
//

PRIVATE
VOID
CleanupViewList(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    );

PRIVATE
LPSESSION_INFO
CreateSession(
    IN LPSTR Host,
    IN DWORD Port,
    OUT LPDWORD Error
    );

PRIVATE
VOID
DestroySession(
    IN LPSESSION_INFO SessionInfo
    );

//
// data
//

PUBLIC SERIALIZED_LIST SessionList;

DEBUG_DATA(LONG, NumberOfSessions, 0);

//
// functions
//


VOID
AcquireSessionLock(
    VOID
    )

/*++

Routine Description:

    Acquires the SESSION_INFO list lock

Arguments:

    None.

Return Value:

    None.

--*/

{
    LockSerializedList(&SessionList);
}


VOID
ReleaseSessionLock(
    VOID
    )

/*++

Routine Description:

    Releases the SESSION_INFO list lock

Arguments:

    None.

Return Value:

    None.

--*/

{
    UnlockSerializedList(&SessionList);
}


VOID
CleanupSessions(
    VOID
    )

/*++

Routine Description:

    Tries to Remove all SESSION_INFOs from the session list, and terminate all
    active operations

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "CleanupSessions",
                NULL
                ));

    while (1) {

        LPSESSION_INFO sessionInfo;

        //
        // find the next SESSION_INFO to delete. Because we may cause the entry
        // currently at the head of the list to be deleted during this loop, we
        // must walk the list each time. We may also end up with a list of items
        // that are marked for delete, but cannot be deleted until the threads
        // that own them complete their current operations
        //

        AcquireSessionLock();

        for (sessionInfo = (LPSESSION_INFO)HeadOfSerializedList(&SessionList);
            (sessionInfo != (LPSESSION_INFO)&SessionList.List.Flink)
            && !(sessionInfo->Flags & SI_CLEANUP);
            sessionInfo = (LPSESSION_INFO)sessionInfo->List.Flink) {

            //
            // empty loop
            //

        }
        if (sessionInfo == (LPSESSION_INFO)&SessionList.List.Flink) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("end of list\n"
                        ));

            ReleaseSessionLock();
            break;
        }

        //
        // mark this SESSION_INFO as being cleaned up, in case it does not get
        // removed from the list (some other thread is accessing it)
        //

        sessionInfo->Flags |= SI_CLEANUP;

        //
        // increment the reference count so that we can release the list lock
        //

        ReferenceSession(sessionInfo);
        ReleaseSessionLock();

        //
        // now we have a pointer to a SESSION_INFO that cannot be deleted until
        // after we have dereferenced it. Dereference any items in the Find and
        // File lists. Note that had we not referenced the SESSION_INFO above,
        // it might have gotten deleted after cleaning up the Find list, and we
        // would be in danger of passing a bogus pointer to the second cleanup
        // view list call below
        //

        CleanupViewList(sessionInfo, ViewTypeFind);
        CleanupViewList(sessionInfo, ViewTypeFile);

        //
        // finally, dereference the session. This may cause it to be deleted,
        // and for the list to be changed
        //

        DereferenceSession(sessionInfo);
    }

    DEBUG_LEAVE(0);
}


PRIVATE
VOID
CleanupViewList(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Cleans up a VIEW_INFO list on a SESSION_INFO

Arguments:

    SessionInfo - pointer to SESSION_INFO we are cleaning up

    ViewType    - identifies which VIEW_INFO list to clean up

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "CleanupViewList",
                "%x, %x",
                SessionInfo,
                ViewType
                ));

    //
    // walk this VIEW_INFO list trying to delete everything by dereferencing
    //

    while (1) {

        LPSERIALIZED_LIST viewList;
        LPVIEW_INFO viewInfo;
        HINTERNET handle;

        AcquireViewLock(SessionInfo, ViewType);

        viewList = &SessionInfo->FindList;
        for (viewInfo = (LPVIEW_INFO)HeadOfSerializedList(viewList);
            (viewInfo != (LPVIEW_INFO)&viewList->List.Flink)
            && !(viewInfo->Flags & VI_CLEANUP);
            viewInfo = (LPVIEW_INFO)viewInfo->List.Flink) {

            //
            // empty loop
            //

        }

        if (viewInfo == (LPVIEW_INFO)&viewList->List.Flink) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("end of list\n"
                        ));

            ReleaseViewLock(SessionInfo, ViewType);
            break;
        }

        //
        // mark this VIEW_INFO as being cleaned-up, so we don't hit it again if
        // we don't delete it from the list this time
        //

        viewInfo->Flags |= VI_CLEANUP;

        //
        // safe to release the view lock
        //

        ReleaseViewLock(SessionInfo, ViewType);

        //
        // now dereference the VIEW_INFO. This may destroy it, but cannot
        // destroy the SESSION_INFO, since we added an extra reference in
        // CleanupSessions()
        //

        DereferenceView(viewInfo);
    }

    DEBUG_LEAVE(0);
}


LPSESSION_INFO
FindOrCreateSession(
    IN LPSTR Host,
    IN DWORD Port,
    OUT LPDWORD Error
    )

/*++

Routine Description:

    Locates a SESSION_INFO that contains (Host, Port), or creates a new
    SESSION_INFO

    BUGBUG - need to do the following:

        resolve the host name
        find host by name/port or address/port

Arguments:

    Host    - pointer to host name where gopher server lives

    Port    - port at which gopher server listens

    Error   - place to return error

Return Value:

    LPSESSION_INFO
        Success - pointer to session info. Created contains TRUE if we created
                  the SESSION_INFO, else FALSE

        Failure - NULL
                    Error contains reason for failure

--*/

{
    LPSESSION_INFO sessionInfo;
    BOOL found;

    AcquireSessionLock();

    found = FALSE;
    for (sessionInfo = (LPSESSION_INFO)SessionList.List.Flink;
        sessionInfo != (LPSESSION_INFO)&SessionList.List;
        sessionInfo = (LPSESSION_INFO)(sessionInfo->List.Flink)) {

        if (!stricmp(sessionInfo->Host, Host) && (sessionInfo->Port == Port)) {
            found = TRUE;
            break;
        }
    }
    if (!found) {
        sessionInfo = CreateSession(Host, Port, Error);
        if (sessionInfo != NULL) {
            InsertAtHeadOfSerializedList(&SessionList, &sessionInfo->List);
        }
    }
    if (sessionInfo != NULL) {

        //
        // the reference count will be at least 2
        //

        ReferenceSession(sessionInfo);
    }

    ReleaseSessionLock();

    return sessionInfo;
}


PRIVATE
LPSESSION_INFO
CreateSession(
    IN LPSTR Host,
    IN DWORD Port,
    OUT LPDWORD Error
    )

/*++

Routine Description:

    Creates and initializes a SESSION_INFO 'object'

Arguments:

    Host    - pointer to host name/ip address

    Port    - host port

    Error   - place to return reason for failure

Return Value:

    LPSESSION_INFO
        Success - pointer to initialized session info

        Failure - NULL
                    Error contains reason for failure

--*/

{
    LPSESSION_INFO sessionInfo;
    LPSTR hostName = NULL;
    DWORD error;

    DEBUG_ENTER((DBG_GOPHER,
                Pointer,
                "CreateSession",
                "%q, %d, %x",
                Host,
                Port,
                Error
                ));

    sessionInfo = NEW(SESSION_INFO);
    if (sessionInfo != NULL) {
        hostName = NEW_STRING(Host);
        if (hostName != NULL) {
            error = AllocateHandle((LPVOID)sessionInfo, &sessionInfo->Handle);
            if (error == ERROR_SUCCESS) {

                InitializeListHead(&sessionInfo->List);
                sessionInfo->Host = hostName;
                sessionInfo->Port = Port;
                InitializeSerializedList(&sessionInfo->FindList);
                InitializeSerializedList(&sessionInfo->FileList);

                SESSION_CREATED();

            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (error != ERROR_SUCCESS) {
        if (hostName != NULL) {
            DEL_STRING(hostName);
        }
        if (sessionInfo != NULL) {
            DEL(sessionInfo);
        }
        sessionInfo = NULL;
    }

    DEBUG_ERROR(SESSION, error);

    *Error = error;

    DEBUG_LEAVE(sessionInfo);

    return sessionInfo;
}


PRIVATE
VOID
DestroySession(
    IN LPSESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Opposite of CreateSession - removes a SESSION_INFO from SessionList and
    frees all resources owned by the SESSION_INFO and finally frees the memory

    Assumes:    1. SessionListLock is held
                2. SessionInfo is not on any lists
                3. The SERIALIZED_LISTs have already been created

Arguments:

    SessionInfo - pointer to SESSION_INFO to delete

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "DestroySession",
                "%x",
                SessionInfo
                ));

    INET_DEBUG_ASSERT(SessionInfo->List.Flink == NULL);
    INET_DEBUG_ASSERT(SessionInfo->List.Blink == NULL);
    INET_ASSERT(SessionInfo->ReferenceCount == 0);
    INET_ASSERT(IsSerializedListEmpty(&SessionInfo->FindList));
    INET_DEBUG_ASSERT(!IsLockHeld(&SessionInfo->FindList));
    INET_ASSERT(IsSerializedListEmpty(&SessionInfo->FileList));
    INET_DEBUG_ASSERT(!IsLockHeld(&SessionInfo->FileList));

    if (SessionInfo->Handle) {
        FreeHandle(SessionInfo->Handle);
    }

    if (SessionInfo->Host != NULL) {
        DEL(SessionInfo->Host);
    }

    TerminateSerializedList(&SessionInfo->FindList);
    TerminateSerializedList(&SessionInfo->FileList);

    DEL(SessionInfo);

    SESSION_DESTROYED();

    DEBUG_LEAVE(0);
}


VOID
ReferenceSession(
    IN LPSESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Increases the reference count of a SESSION_INFO

Arguments:

    Session - pointer to SESSION_INFO to reference

Return Value:

    None.

--*/

{
    INET_ASSERT(SessionInfo != NULL);

    InterlockedIncrement(&SessionInfo->ReferenceCount);
}


LPSESSION_INFO
DereferenceSession(
    IN LPSESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Reduces the reference count of a SESSION_INFO. If it goes to zero, the
    SESSION_INFO is removed from the SessionList and is deallocated

Arguments:

    SessionInfo - pointer to SESSION_INFO to dereference

Return Value:

    LPSESSION_INFO
        NULL    - SessionInfo was deleted

        !NULL   - Reference count still >0

--*/

{
    INET_ASSERT(SessionInfo);
    INET_ASSERT(SessionInfo->ReferenceCount >= 1);

    //
    // use InterlockedDecrement to dereference the session. If it goes to zero
    // acquire the session lock, check if the reference count is still zero,
    // and if so, remove the session from the session list
    //

    if (InterlockedDecrement(&SessionInfo->ReferenceCount) == 0) {
        AcquireSessionLock();
        if (SessionInfo->ReferenceCount == 0) {
            RemoveFromSerializedList(&SessionList, (PLIST_ENTRY)SessionInfo);
            DestroySession(SessionInfo);
            SessionInfo = NULL;
        }
        ReleaseSessionLock();
    }
    return SessionInfo;
}


VOID
AcquireViewLock(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Acquires one of the SessionInfo View locks

Arguments:

    SessionInfo - pointer to SESSION_INFO

    ViewType    - identifies which list to lock

Return Value:

    None.

--*/

{
    LPSERIALIZED_LIST list;

    INET_ASSERT(SessionInfo != NULL);
    INET_ASSERT((ViewType == ViewTypeFile) || (ViewType == ViewTypeFind));

    list = (ViewType == ViewTypeFile)
        ? &SessionInfo->FileList
        : &SessionInfo->FindList
        ;
    LockSerializedList(list);
}


VOID
ReleaseViewLock(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Releases the SessionInfo View lock

Arguments:

    SessionInfo - pointer to SESSION_INFO

    ViewType    - identifies which list to lock

Return Value:

    None.

--*/

{
    LPSERIALIZED_LIST list;

    INET_ASSERT(SessionInfo != NULL);
    INET_ASSERT((ViewType == ViewTypeFile) || (ViewType == ViewTypeFind));

    list = (ViewType == ViewTypeFile)
        ? &SessionInfo->FileList
        : &SessionInfo->FindList
        ;
    UnlockSerializedList(list);
}


DWORD
GopherTransaction(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Performs an 'atomic' gopher operation. Connects to a server (if it isn't
    already connected (in the future?)), sends a request and receives the
    entire response message. The connection is terminated

Arguments:

    ViewInfo    - pointer to VIEW_INFO describing gopher server to talk to,
                  request and buffer for response

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Winsock error

--*/

{
    DWORD error;

    INET_ASSERT(ViewInfo != NULL);

    error = GopherConnect(ViewInfo);
    if (error == ERROR_SUCCESS) {
        error = GopherSendRequest(ViewInfo);
        if (error == ERROR_SUCCESS) {

            DWORD bytesReceived;

            //
            // receive the first part of the response. We don't care about the
            // number of bytes received at this point
            //
            // If the response is completed and the connection is not persistent
            // or an error occurs, the connection will be closed
            //

            ViewInfo->BufferInfo->Flags |= BI_FIRST_RECEIVE;
            error = GopherReceiveResponse(ViewInfo, &bytesReceived);
        }
    }
    return error;
}


DWORD
IsServerGopherPlus(
    IN LPSESSION_INFO SessionInfo,
    OUT LPBOOL Answer
    )

/*++

Routine Description:

    Tries to determine whether a gopher server identified by Session is gopher+.
    The caller should already have determined that we don't know the type of
    gopher server described by Session and should modify the flags based on a
    successful return from this function

Arguments:

    SessionInfo - pointer to SESSION_INFO describing the (unknown) gopher server

    Answer      - pointer to place to put the answer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
/*
    DWORD error;
    BYTE buffer[GOPHER_PLUS_INFO_TOKEN_LENGTH + 2]; // "+INFO"
                                                    // + 1 for possible ':'
                                                    // + 1 for ' '
    BOOL receiveComplete;

    //
    // in order to find out the type of gopher server, we send a request for
    // gopher+ info of the root directory. We will get back either the gopher+
    // information or a gopher0 server will return the directory list (or we
    // will get an error). Therefore, if the transaction doesn't result in an
    // error, we can say that if the buffer starts with "+INFO" then the
    // server is gopher+ else plain gopher
    //

    error = GopherTransaction(SessionInfo,
                              GOPHER_PLUS_INFO_REQUEST,
                              TRUE,
                              sizeof(buffer),
                              buffer,
                              NULL,
                              &receiveComplete
                              );

    //
    // in both gopher+ and gopher server cases, the server should want to
    // return more data than we've supplied buffer for (7 bytes!). In the
    // case of gopher+, it will be trying to return the +INFO block for
    // the directory entry. In the case of gopher, it will be trying to
    // return the entire default directory list. Either way, we don't care
    // to take the data: "+INFO[:] " being present or not at the start of
    // the buffer is good enough for us, so just close the session and
    // examine what we have
    //

    DisconnectFromServer(SessionInfo, );
    if (error == ERROR_SUCCESS) {

        register DWORD matchLength;

        matchLength = IsGopherPlusToken(GOPHER_PLUS_INFO_TOKEN,
                                        GOPHER_PLUS_INFO_TOKEN_LENGTH,
                                        buffer,
                                        sizeof(buffer)
                                        );
        *Answer = (BOOL)(matchLength != 0);

        IF_DEBUG(SESSION) {
            DBGPRINT(DBG_INFO,
                     "IsServerGopherPlus",
                     ("Server \"%s\" %s gopher+\n",
                     SessionInfo->Host,
                     (matchLength == 0) ? "NOT" : "IS"
                     ));
        }
    } else {
        IF_DEBUG(SESSION) {
            DBGPRINT(DBG_ERROR,
                     "IsServerGopherPlus",
                     ("GopherTransaction() returns %d\n",
                     error
                     ));
        }
    }
    return error;
*/
    *Answer = FALSE;
    return ERROR_SUCCESS;
}


BOOL
IsGopherPlusSession(
    IN LPSESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Returns TRUE if Session is a session with a gopher+ server

Arguments:

    SessionInfo - pointer to SESSION_INFO describing gopher[+] server

Return Value:

    BOOL

--*/

{
    return (BOOL)SessionInfo->Flags & SI_GOPHER_PLUS;
}


DWORD
SearchSessionsForAttribute(
    IN LPSTR Locator,
    IN LPSTR Attribute,
    IN LPBYTE Buffer,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Searches all VIEW_INFO buffers for a requested Locator and extracts the
    attributes if found

Arguments:

    Locator         - pointer to locator describing item to get attributes for

    Attribute       - pointer to string describing attribute(s) to get

    Buffer          - pointer to buffer in which to return attribute strings

    BufferLength    - IN: length of Buffer in bytes
                      OUT: length of returned attribute strings in bytes,
                           excluding any terminating NUL

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_ATTRIBUTE_NOT_FOUND
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    LPSESSION_INFO session;
    BOOL found = FALSE;
    DWORD error = ERROR_SUCCESS;

    AcquireSessionLock();
/*
    for (session = (LPSESSION_INFO)SessionList.Flink;
        session != (LPSESSION_INFO)&SessionList.Flink;
        session = (LPSESSION_INFO)session->List.Flink) {

        LPVIEW_INFO viewInfo;

        AcquireFindLock(session);
        for (findInfo = (LPVIEW_INFO)session->FindList.Flink;
            findInfo != (LPVIEW_INFO)&session->FindList;
            findInfo = (LPVIEW_INFO)findInfo->List.Flink) {

            ReferenceFind(findInfo);
            if (findInfo->Handle) {
                found = TRUE;
                break;  // out of for()
            }
        }
        if (found) {
            break;  // out of while()
        }
        ReleaseFindLock(session);
    }
    if (found) {
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_GOPHER_ATTRIBUTE_NOT_FOUND;
    }
*/
    ReleaseSessionLock();

    error = ERROR_GOPHER_ATTRIBUTE_NOT_FOUND;

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\sockets.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    sockets.h

Abstract:

    Contains manifests, macros, types and prototypes for sockets.c

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
GopherConnect(
    IN LPVIEW_INFO ViewInfo
    );

DWORD
GopherDisconnect(
    IN LPVIEW_INFO ViewInfo,
    IN BOOL AbortConnection
    );

DWORD
GopherSendRequest(
    IN LPVIEW_INFO ViewInfo
    );

DWORD
GopherReceiveResponse(
    IN LPVIEW_INFO ViewInfo,
    OUT LPDWORD BytesReceived
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\session.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    session.h

Abstract:

    Manifests, macros, types, prototypes for session.c

Author:

    Richard L Firth (rfirth) 25-Oct-1994

Revision History:

    25-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// types
//

//
// SESSION_INFO - describes a session with a gopher server. We will keep a cache
// of these. Only one 'conversation' can be active at any one time with a gopher
// server. Threads must wait on the mutex handle
//

typedef struct _SESSION_INFO {

    //
    // List - SESSION_INFOs are maintained on double-linked list
    //

    LIST_ENTRY List;

    //
    // ReferenceCount - used to keep this session alive when there are
    // concurrent creates/deletes on different threads
    //

    LONG ReferenceCount;

    //
    // Handle - identifies this session to the application
    //

    HANDLE Handle;

    //
    // Flags - various control flags. See below
    //

    DWORD Flags;

    //
    // Host - name of host with which we have a connection
    //

    LPSTR Host;

    //
    // Port - port number at which gopher server listens at Host
    //

    DWORD Port;

    //
    // FindList - protected, doubly-linked list of VIEW_INFO 'object's generated
    // by gopher directory requests
    //

    SERIALIZED_LIST FindList;

    //
    // FileList - protected, doubly-linked list of VIEW_INFO 'object's generated
    // by gopher document (file) requests
    //

    SERIALIZED_LIST FileList;

} SESSION_INFO, *LPSESSION_INFO;

//
// SESSION_INFO flags
//

#define SI_GOPHER_PLUS      0x00000001  // gopher server at Host is gopher+
#define SI_CLEANUP          0x00000002  // set by CleanupSession()
#define SI_PERSISTENT       0x80000000  // connection to gopher server kept alive

//
// macros
//

#define UNKNOWN_GOPHER(session) ((session)->Flags & (SI_GOPHER_ZERO | SI_GOPHER_PLUS) == 0)

//
// public data
//

extern SERIALIZED_LIST SessionList;

DEBUG_DATA_EXTERN(LONG, NumberOfSessions);

//
// prototypes
//

VOID
AcquireSessionLock(
    VOID
    );

VOID
ReleaseSessionLock(
    VOID
    );

VOID
CleanupSessions(
    VOID
    );

LPSESSION_INFO
FindOrCreateSession(
    IN LPSTR Host,
    IN DWORD Port,
    OUT LPDWORD Error
    );

VOID
ReferenceSession(
    IN LPSESSION_INFO SessionInfo
    );

LPSESSION_INFO
DereferenceSession(
    IN LPSESSION_INFO SessionInfo
    );

VOID
AcquireViewLock(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    );

VOID
ReleaseViewLock(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    );

DWORD
GopherTransaction(
    IN LPVIEW_INFO ViewInfo
    );

BOOL
IsGopherPlusSession(
    IN LPSESSION_INFO SessionInfo
    );

DWORD
SearchSessionsForAttribute(
    IN LPSTR Locator,
    IN LPSTR Attribute,
    IN LPBYTE Buffer,
    IN OUT LPDWORD BufferLength
    );

//
// macros
//

#if INET_DEBUG

#define SESSION_CREATED()   ++NumberOfBuffers
#define SESSION_DESTROYED() --NumberOfBuffers
#define ASSERT_NO_SESSIONS() \
    if (NumberOfSessions != 0) { \
        INET_ASSERT(FALSE); \
    }

#else

#define SESSION_CREATED()       /* NOTHING */
#define SESSION_DESTROYED()     /* NOTHING */
#define ASSERT_NO_SESSIONS()    /* NOTHING */

#endif

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\sockets.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sockets.cxx

Abstract:

    Contains functions to interface between gopher APIs and Winsock

    Contents:
        GopherConnect
        GopherDisconnect
        GopherSendRequest
        GopherReceiveResponse

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Environment:

    Win32(s) user-mode DLL

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// manifests
//

#define DEFAULT_RESPONSE_BUFFER_LENGTH  (4 K)

//
// functions
//


DWORD
GopherConnect(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Makes a connection to a (gopher) server. Sets a receive timeout on the
    connected socket

Arguments:

    ViewInfo    - pointer to VIEW_INFO containing pointer to SESSION_INFO which
                  describes server to connect to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "GopherConnect",
                "%#x",
                ViewInfo
                ));

    DWORD error;
    BOOL  fSuccess;
    INTERNET_CONNECT_HANDLE_OBJECT *pConnect;
    PROXY_STATE *pProxyState = NULL;

    INET_ASSERT(ViewInfo->BufferInfo != NULL);
    INET_ASSERT(ViewInfo->SessionInfo != NULL);

    //
    // determine sync or async
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    DWORD asyncFlags;

    asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // Set the port we're using on the socket object.
    //

    ViewInfo->BufferInfo->Socket->SetPort((INTERNET_PORT) ViewInfo->SessionInfo->Port);

    //
    // Using the object handle, check to see if we have a socks proxy.
    //  If so, use it to do our connections.
    //

    INTERNET_HANDLE_OBJECT * pInternet;
    HINTERNET hConnectMapped;

    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(ViewInfo->SessionInfo->Host != NULL);

    //
    // Get the Mapped Connect Handle Object...
    //

    INET_ASSERT( (ViewInfo->ViewType == ViewTypeFile) ||
                 (ViewInfo->ViewType == ViewTypeFind) );

    hConnectMapped = ((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetParent();

    INET_ASSERT(hConnectMapped);

    //
    // Finally get the Internet Object, so we can query proxy information
    //  out of it.
    //

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *) hConnectMapped;

    pInternet = (INTERNET_HANDLE_OBJECT *)
                    ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->GetParent();

    INET_ASSERT(pInternet);

    {

        AUTO_PROXY_ASYNC_MSG proxyInfoQuery(
                                    INTERNET_SCHEME_GOPHER,
                                    pConnect->GetURL(),
                                    lstrlen(pConnect->GetURL()),
                                    ViewInfo->SessionInfo->Host,
                                    lstrlen(ViewInfo->SessionInfo->Host),
                                    (INTERNET_PORT) ViewInfo->SessionInfo->Port
                                    );

        AUTO_PROXY_ASYNC_MSG *pProxyInfoQuery;

        proxyInfoQuery.SetBlockUntilCompletetion(TRUE);

        pProxyInfoQuery = &proxyInfoQuery;

        error = pInternet->GetProxyInfo(
                                &pProxyInfoQuery
                                );

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }

        if (pProxyInfoQuery->IsUseProxy() &&
            pProxyInfoQuery->GetProxyScheme() == INTERNET_SCHEME_SOCKS &&
            pProxyInfoQuery->_lpszProxyHostName )
        {
            //
            //  If there is Socks enabled, then turned it on.
            //

            error = ViewInfo->BufferInfo->Socket->EnableSocks(
                                                               pProxyInfoQuery->_lpszProxyHostName,
                                                               pProxyInfoQuery->_nProxyHostPort
                                                               );
        }

        if ( pProxyInfoQuery && pProxyInfoQuery->IsAlloced() )
        {
            delete pProxyInfoQuery;
            pProxyInfoQuery = NULL;
        }

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }

    }


    error = ViewInfo->BufferInfo->Socket->Connect(
                          GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                          GetTimeoutValue(INTERNET_OPTION_CONNECT_RETRIES),
                          SF_INDICATE | asyncFlags
                          );

    if (error == ERROR_SUCCESS) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("GopherConnect(): ConnectSocket() returns socket %#x\n",
                    //ViewInfo->BufferInfo->ConnectedSocket.Socket
                    ViewInfo->BufferInfo->Socket->GetSocket()
                    ));

        //
        // we have made a connection with the server. Set the receive timeout.
        // If this fails for any reason, ignore it (although the socket is
        // probably bad if this is true)
        //

        ViewInfo->BufferInfo->Socket->SetTimeout(
                                RECEIVE_TIMEOUT,
                                GetTimeoutValue(INTERNET_OPTION_RECEIVE_TIMEOUT)
                                );
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("GopherConnect(): ConnectSocket() returns %d\n",
                    error
                    ));

    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
GopherDisconnect(
    IN LPVIEW_INFO ViewInfo,
    IN BOOL AbortConnection
    )

/*++

Routine Description:

    Disconnects from the gopher server if the session is not flagged as
    persistent. The socket is closed

Arguments:

    ViewInfo        - pointer to VIEW_INFO containing pointer to SESSION_INFO
                      which describes connection to gopher server

    AbortConnection - TRUE if the connection is to be terminated, even if it is
                      a persistent connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "GopherDisconnect",
                "%#x, %B",
                ViewInfo,
                AbortConnection
                ));

    DWORD error;
    LPSESSION_INFO sessionInfo;

    INET_ASSERT(ViewInfo->SessionInfo != NULL);

    sessionInfo = ViewInfo->SessionInfo;
    if (!(sessionInfo->Flags & SI_PERSISTENT) || AbortConnection) {

        LPBUFFER_INFO bufferInfo;

        INET_ASSERT(ViewInfo->BufferInfo != NULL);

        bufferInfo = ViewInfo->BufferInfo;

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("GopherDisconnect(): closing socket %#x\n",
                    //bufferInfo->ConnectedSocket.Socket
                    bufferInfo->Socket->GetSocket()
                    ));

        error = bufferInfo->Socket->Disconnect();

        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("GopherDisconnect(): Disconnect(%#x) returns %d\n",
                        ViewInfo->BufferInfo->Socket->GetSocket(),
                        error
                        ));

        }
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
GopherSendRequest(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Sends a gopher request to the server we are currently connected to. The
    request is the selector string used to tell the gopher server what to return

Arguments:

    ViewInfo    - pointer to VIEW_INFO describing request. Contains pointer to
                  CR/LF terminated text string gopher request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "GopherSendRequest",
                "%#x",
                ViewInfo
                ));

    DWORD error;

    //
    // determine sync or async
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    DWORD asyncFlags;

    asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    error = ViewInfo->BufferInfo->Socket->Send(ViewInfo->Request,
                                               ViewInfo->RequestLength,
                                               SF_INDICATE
                                               );

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
GopherReceiveResponse(
    IN OUT LPVIEW_INFO ViewInfo,
    OUT LPDWORD BytesReceived
    )

/*++

Routine Description:

    This function is called iteratively to receive the gopher response data. The
    first time this function is called, we determine the type of response -
    success or failure, gopher0 or gopher+.

    The buffer information passed in can refer to a buffer that we maintain
    internally (for directories), or to a buffer that the caller supplies to the
    GopherReadFile() function. In the latter case, the buffer address and length
    may be 0.

    This function assumes that directory responses will be received into a
    buffer which we allocate in this function, and that file requests are
    received into caller-supplied (user-supplied) buffers

Arguments:

    ViewInfo        - pointer to VIEW_INFO structure (including BUFFER_INFO)
                      describing the gopher request and the response from the
                      server

    BytesReceived   - number of bytes received in this response

Return Value:

     DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_EXTENDED_ERROR
                    The server sent us some form of error text. The app should
                    use InternetGetLastResponseInfo() to get the text

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "GopherReceiveResponse",
                "%#x, %#x",
                ViewInfo,
                BytesReceived
                ));

    LPBUFFER_INFO bufferInfo;
    DWORD error;
    int bufferLength;
    LPBYTE buffer;
    LPBYTE responseBuffer;
    int bytesReceived;
    BOOL discardBuffer;
    BOOL terminateConnection;
    BOOL checkResponse;

    *BytesReceived = 0;

    bytesReceived = 0;
    terminateConnection = FALSE;
    checkResponse = FALSE;

    //
    // variables for SocketReceive()
    //

    LPVOID psrBuffer;
    DWORD srLength;
    DWORD srLeft;
    DWORD srReceived;
    BOOL eof;

    bufferInfo = ViewInfo->BufferInfo;

    INET_ASSERT(bufferInfo != NULL);

    //
    // determine sync or async
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto cleanup;
    }

    DWORD asyncFlags;

    asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // if this is the first receive for this buffer then figure out what we
    // received. At this point we may have no buffer (GopherOpenFile()) so we
    // set up the BUFFER_INFO with the required information for the next
    // GopherReadFile()
    //

    if (bufferInfo->Flags & BI_FIRST_RECEIVE) {

        //
        // determine what we have received
        //

        psrBuffer = (LPVOID)bufferInfo->ResponseInfo;
        srLength = sizeof(bufferInfo->ResponseInfo);
        srLeft = sizeof(bufferInfo->ResponseInfo);
        srReceived = 0;

        error = bufferInfo->Socket->Receive(&psrBuffer,
                                            &srLength,
                                            &srLeft,
                                            &srReceived,
                                            0,    // dwExtraSpace
                                            SF_INDICATE,
                                            &eof
                                            );
        if (error != ERROR_SUCCESS) {
            goto cleanup;
        } else if (srReceived == 0) {

            INET_ASSERT(eof);

            //
            // the server has closed the connection already.  We either end up
            // with a zero-length file, or return ERROR_NO_MORE_FILES from a
            // directory listing
            //

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("SocketsReceive() returns 0 bytes on initial read\n"
                        ));

            bufferInfo->Flags |= BI_RECEIVE_COMPLETE;
            goto cleanup;
        }

        //
        // BytesRemaining is the number of data bytes in ResponseInfo
        //

        bufferInfo->BytesRemaining = srReceived;
        bufferInfo->DataBytes = (LPBYTE)bufferInfo->ResponseInfo;

        if (ViewInfo->Flags & VI_GOPHER_PLUS) {

            //
            // gopher+ request: expecting gopher+ response: +/-#\r\n
            //

            if (bufferInfo->ResponseInfo[0] == GOPHER_PLUS_ERROR_INDICATOR) {
                bufferInfo->Flags |= BI_ERROR_RESPONSE;
            } else if (bufferInfo->ResponseInfo[0] != GOPHER_PLUS_SUCCESS_INDICATOR) {

                //
                // buffer does not start with + or -; assume we received a
                // gopher0 response, and down-grade the request
                //

                ViewInfo->Flags &= ~VI_GOPHER_PLUS;

                DEBUG_PRINT(SOCKETS,
                            WARNING,
                            ("Gopher+ request resulted in gopher0 response!\n"
                            ));

            }
        } else if ((ViewInfo->ViewType != ViewTypeFile)
        && (bufferInfo->ResponseInfo[0] == GOPHER_PLUS_ERROR_INDICATOR)) {

            //
            // if this is a gopher+ error response then we promote the request/
            // response to gopher+ and handle the error below. If it actually
            // turns out that someone has invented a locator that starts '-'
            // then we will again down-grade the request
            //

            bufferInfo->Flags |= BI_ERROR_RESPONSE;
            ViewInfo->Flags |= VI_GOPHER_PLUS;

            DEBUG_PRINT(SOCKETS,
                        WARNING,
                        ("Gopher0 request resulted in gopher+ response!\n"
                        ));

        }

        //
        // if we still think the request/response is gopher+ then extract the
        // response length
        //

        if (ViewInfo->Flags & VI_GOPHER_PLUS) {

            BOOL ok;
            LPSTR pNumber;

            pNumber = &bufferInfo->ResponseInfo[1];
            ok = ExtractInt(&pNumber,
                            0,
                            &bufferInfo->ResponseLength
                            );
            if (!ok || (*pNumber != '\r') || (*(pNumber + 1) != '\n')) {
                ViewInfo->Flags &= ~VI_GOPHER_PLUS;

                DEBUG_PRINT(SOCKETS,
                            WARNING,
                            ("Gopher+ request resulted in gopher0 response!\n"
                            ));

                //
                // probably isn't an error either
                //

                bufferInfo->Flags &= ~BI_ERROR_RESPONSE;
            } else {

                int numberLength;

                //
                // this is the number of bytes we copied to the ResponseInfo
                // buffer that belong in the response proper
                //

                numberLength = (int) (pNumber - bufferInfo->ResponseInfo) + 2;
                bufferInfo->DataBytes = (LPBYTE)&bufferInfo->ResponseInfo[numberLength];
                bufferInfo->BytesRemaining -= numberLength;
            }
        }

        //
        // if we are receiving a gopher0 (directory) response then we need to
        // check below if we really received an error
        //

        if (!(ViewInfo->Flags & VI_GOPHER_PLUS)) {
            checkResponse = TRUE;
        }

        //
        // no longer the first time receive
        //

        bufferInfo->Flags &= ~BI_FIRST_RECEIVE;
    }

    //
    // either get the user buffer pointer, or allocate/resize a moveable buffer
    // (for directory listings and errors)
    //
    // N.B. A special case here is an error received in response to a gopher0
    // directory request: we don't know at this point if a gopher0 directory
    // request has resulted in an error, but we have to allocate a buffer
    // anyway, so we will determine error status after we have received the
    // data
    //

    discardBuffer = FALSE;
    if (!(bufferInfo->Flags & (BI_BUFFER_RESPONSE | BI_ERROR_RESPONSE))) {
        buffer = bufferInfo->Buffer;
        bufferLength = bufferInfo->BufferLength;

        //
        // if we are given a zero length user buffer then quit now; the bytes
        // received parameter has already been zeroed
        //

        if (bufferLength == 0) {
            goto quit;
        }
    } else {

        //
        // if we know how much data is in the response AND it is less than the
        // default length, then allocate a buffer that will exactly fit the
        // response. Otherwise allocate a buffer large enough to fit the default
        // response length
        //

        if (bufferInfo->ResponseLength > 0) {
            bufferLength = min(bufferInfo->ResponseLength,
                               DEFAULT_RESPONSE_BUFFER_LENGTH
                               );
        } else {

            //
            // the response length is -1 or -2, or its a gopher0 response: we
            // don't know how large it is
            //

            bufferLength = DEFAULT_RESPONSE_BUFFER_LENGTH;
        }

        //
        // if this is the first time we have called this function, allocate the
        // buffer, else grow it to the new size
        //

        bufferInfo->Buffer = (LPBYTE)ResizeBuffer(bufferInfo->Buffer,
                                                  bufferInfo->BufferLength
                                                  + bufferLength,
                                                  FALSE
                                                  );
        if (bufferInfo->Buffer == NULL) {
            terminateConnection = TRUE;

            INET_ASSERT(FALSE);

            goto last_error_exit;
        }

        bufferInfo->Flags |= BI_OWN_BUFFER;

        //
        // start receiving the next chunk at the end of the previous one
        //

        buffer = bufferInfo->Buffer + bufferInfo->BufferLength;
    }

    //
    // if we haven't already received all the data (in DetermineGopherResponse)
    // then receive the next chunk
    //

    responseBuffer = buffer;
    bytesReceived = bufferLength;

    //
    // receive the data. N.B. Don't change this loop without first examining
    // the checks below
    //

    int n;

    for (n = 0; bufferLength > 0; ) {

        //
        // if there is still data to copy in ResponseInfo then copy that
        //

        if (bufferInfo->BytesRemaining) {
            n = min(bufferInfo->BytesRemaining, bufferLength);
            memcpy(buffer, bufferInfo->DataBytes, n);
            bufferInfo->BytesRemaining -= n;
            bufferInfo->DataBytes += n;
        } else {

            //
            // if there is data left to copy in the look-ahead buffer that we
            // allocated in DetermineGopherResponse() then copy that data to
            // the response buffer
            //

            psrBuffer = (LPVOID)buffer;
            srLength = bufferLength;
            srLeft = bufferLength;
            srReceived = 0;

            error = bufferInfo->Socket->Receive(&psrBuffer,
                                                &srLength,
                                                &srLeft,
                                                &srReceived,
                                                0,    // dwExtraSpace
                                                SF_INDICATE,
                                                &eof
                                                );
            if (error != ERROR_SUCCESS) {
                discardBuffer = TRUE;
                terminateConnection = TRUE;
                goto cleanup;
            }
            n = srReceived;
            if (n == 0) {
                break;
            }
        }
        bufferLength -= n;
        buffer += n;
    }

    //
    // at this point we have one of the following:
    //
    //  * we reached the end of the response (n == 0)
    //  * we reached the end of the buffer (n != 0 && bufferLength == 0)
    //

    //
    // get the actual number of bytes received for this iteration
    //

    bytesReceived -= bufferLength;

    //
    // if we are receiving a gopher0 directory response then we need to check
    // whether we actually received an error
    //

    if (checkResponse) {

        //
        // allow for long locators (!)
        //

        char locator[2 * MAX_GOPHER_LOCATOR_LENGTH + 1];
        LPSTR destination;
        LPSTR source;
        DWORD destinationLength;
        DWORD sourceLength;

        //
        // we have a gopher0 error if the response starts with a '3' but there
        // is only one locator, or the response data is unformatted
        //

        //
        // N.B. We are making an assumption here that the locator(s) in the
        // response is(are) not larger than our buffer above. This should be a
        // safe assumption, but this test could fail if we get a large locator
        // but then a large locator will probably break all other gopher
        // clients? The reason we copy the locator is so that we get a zero-
        // terminated string for IsValidLocator(), and CopyToEol() compresses
        // multiple carriage-returns which some servers are uninteligent to
        // return
        //

        source = (LPSTR)responseBuffer;
        sourceLength = bytesReceived;
        destination = locator;
        destinationLength = sizeof(locator);
        if (CopyToEol(&destination,
                      &destinationLength,
                      &source,
                      &sourceLength)) {

            if (IsValidLocator(locator, sizeof(locator))) {

                //
                // response contains at least one valid locator. If it starts
                // with the gopher0 error indicator ('3') and its the only one
                // then this is an error response (although it *could* be the
                // one and only locator describing the directory, and the admin
                // decided to make it an error for some reason. We can't
                // differentiate in this case)
                //

                if (locator[0] == GOPHER_CHAR_ERROR) {
                    destination = locator;
                    destinationLength = sizeof(locator);
                    if (!CopyToEol(&destination,
                                   &destinationLength,
                                   &source,
                                   &sourceLength)) {
                        bufferInfo->Flags |= BI_ERROR_RESPONSE;
                    } else if (!IsValidLocator(locator, sizeof(locator))) {
                        bufferInfo->Flags |= BI_ERROR_RESPONSE;
                    }
                }
            } else {

                //
                // response doesn't contain a valid locator: must be an error
                //

                bufferInfo->Flags |= BI_ERROR_RESPONSE;
            }
        } else {

            //
            // we are receiving 4K but couldn't find an end-of-line? Must be an
            // error
            //

            bufferInfo->Flags |= BI_ERROR_RESPONSE;
        }
    }

    //
    // if we finished receivig the response then we can set the error code or
    // shrink the buffer
    //

    if ((n == 0)
    || (bytesReceived == bufferInfo->ResponseLength)
    || (bufferInfo->Flags & BI_ERROR_RESPONSE)) {

        //
        // no more data in the response. We have completed the transfer
        //

        bufferInfo->Flags |= BI_RECEIVE_COMPLETE;

        //
        // if this response type is terminated with a line containing only a dot
        // then remove the dot
        //

        if (bufferInfo->Flags & BI_DOT_AT_END) {

            //
            // BUGBUG - this is insufficient - need to check for different line
            //          termination schemes ('\n', '\r\r\n', '\r\n', etc.)
            //

            if ((bytesReceived >= 3) && (memcmp(buffer - 3, ".\r\n", 3) == 0)) {
                bytesReceived -= 3;
            }
            bufferInfo->Flags &= ~BI_DOT_AT_END;
        }

        //
        // if we received an error response then we must set the last error
        // response data
        //

        if (bufferInfo->Flags & BI_ERROR_RESPONSE) {
            if (bytesReceived > 0) {
                InternetSetLastError(0,
                                     (LPSTR)responseBuffer,
                                     bytesReceived,
                                     SLE_ZERO_TERMINATE
                                     );

                //
                // let the app know that it needs to call InternetGetLastResponseInfo()
                // to retrieve the error text
                //

                error = ERROR_INTERNET_EXTENDED_ERROR;
            } else {
                error = ERROR_SUCCESS;
            }

            //
            // we have copied the data in the error response, no more need for
            // the buffer
            //

            discardBuffer = TRUE;

            //
            // need to indicate to the caller that they need to get the last
            // error response
            //

        } else {
            error = ERROR_SUCCESS;
        }
    } else {

        //
        // this chunk received OK, more to go
        //

        error = ERROR_SUCCESS;
    }

cleanup:

    //
    // if we no longer need the buffer then discard it, else if we have completed
    // receiving the response, shrink the buffer to free up any unused space
    //

    if (bufferInfo->Flags & BI_OWN_BUFFER) {

        DWORD newBufferLength;
        BOOL resize;

        if (discardBuffer) {
            newBufferLength = 0;
            resize = TRUE;
        } else {

            //
            // update the amount of data received - i.e. the number of bytes in
            // the buffer (excluding header info)
            //

            bufferInfo->BufferLength += bytesReceived;
            if (bufferInfo->Flags & BI_RECEIVE_COMPLETE) {
                newBufferLength = bufferInfo->BufferLength;
                resize = TRUE;

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("received 0 bytes in response\n"
                            ));

            } else {
                resize = FALSE;
            }
        }

        //
        // if resize is TRUE then we are either shrinking the data buffer to
        // exclude any unused space, or we are shrinking it to nothing because
        // we have no data or it is being discarded
        //

        if (resize) {
            bufferInfo->Buffer = (LPBYTE)ResizeBuffer(bufferInfo->Buffer,
                                                      newBufferLength,
                                                      FALSE
                                                      );

            if (newBufferLength == 0) {

                //
                // we no longer own the buffer
                //

                bufferInfo->Flags &= ~BI_OWN_BUFFER;

                //
                // DEBUG version: ensure that the buffer has really been freed
                //

                INET_ASSERT(bufferInfo->Buffer == NULL);

            }
        }
    }

    //
    // if this is a gopher+ response and we know the length of the response then
    // reduce the outstanding size of the response by the amount we received
    //

    if (bufferInfo->ResponseLength > 0) {
        bufferInfo->ResponseLength -= bytesReceived;
    }

    //
    // if we completed the response and the connection is not persistent, or an
    // error occurred, close the connection
    //

    if ((bufferInfo->Flags & BI_RECEIVE_COMPLETE) || (error != ERROR_SUCCESS)) {

        //
        // let the app know we have finished receiving data
        //

        InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
                               &bytesReceived,
                               sizeof(bytesReceived)
                               );

        GopherDisconnect(ViewInfo, terminateConnection);
    }

    //
    // if we didn't receive error text from the server then we return the amount
    // of data received. This is only interesting to ReadData()
    //

    if (!(bufferInfo->Flags & BI_ERROR_RESPONSE)) {
        *BytesReceived = bytesReceived;
    }

quit:

    DEBUG_LEAVE(error);

    return error;

last_error_exit:

    error = GetLastError();

    INET_ASSERT(error != ERROR_SUCCESS);

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\view.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    view.h

Abstract:

    Manifests, macros, types prototypes for view.c

Author:

    Richard L Firth (rfirth) 17-Oct-1994

Revision History:

    17-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// have to forward-define LPSESSION_INFO
//

typedef struct _SESSION_INFO * LPSESSION_INFO;

//
// VIEW_TYPE - which type of view are we talking about, FIND or FILE?
//

typedef enum {
    ViewTypeFile = 0xff010101,  // arbitrary values always good for a few laughs
    ViewTypeFind
} VIEW_TYPE;

//
// VIEW_INFO - describes a data view, either the results of a FindFirst or a
// GetFile
//

typedef struct {

    //
    // List - the list of VIEW_INFO structures owned by the parent SESSION_INFO
    //

    LIST_ENTRY List;

    //
    // ViewType - lets us know which of the Session view lists this is on
    //

    VIEW_TYPE ViewType;

    //
    // Handle - the handle returned by GopherFindFirst/GopherGetFile
    //

    HINTERNET Handle;

    //
    // Request - the request string which generated Buffer
    //

    LPSTR Request;

    //
    // RequestLength - number of bytes in Request (excluding terminating \0)
    //

    DWORD RequestLength;

    //
    // Set to 1 when this 'object' is created. Any time it is used thereafter
    // this field must be incremented and decremented when no longer being
    // used. Closing the handle that corresponds to this view will dereference
    // it a final time and cause the view to be deleted
    //

    LONG ReferenceCount;

    //
    // Flags - various control flags, see below
    //

    DWORD Flags;

    //
    // ViewOffset - offset in buffer described by BufferInfo->Buffer which will
    // be used to generate the results of the next request on this view
    //

    DWORD ViewOffset;

    //
    // Buffer - pointer to BUFFER_INFO containing data returned from gopher
    // server
    //

    LPBUFFER_INFO BufferInfo;

    //
    // SessionInfo - back-pointer to the owning SESSION_INFO. Used when we
    // create or destroy this view - the owning session must be referenced
    // or dereferenced accordingly
    //

    LPSESSION_INFO SessionInfo;

} VIEW_INFO, *LPVIEW_INFO;

//
// VIEW_INFO flags
//

#define VI_GOPHER_PLUS      0x00000001  // the data buffer contains gopher+ data
#define VI_CLEANUP          0x00000002  // set by CleanupSessions()

//
// external data
//

DEBUG_DATA_EXTERN(LONG, NumberOfViews);

//
// prototypes
//

LPVIEW_INFO
CreateView(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType,
    IN LPSTR Request,
    OUT LPDWORD Error,
    OUT LPBOOL Cloned
    );

LPVIEW_INFO
FindViewByHandle(
    IN HINTERNET Handle,
    IN VIEW_TYPE ViewType
    );

VOID
ReferenceView(
    IN LPVIEW_INFO ViewInfo
    );

LPVIEW_INFO
DereferenceView(
    IN LPVIEW_INFO ViewInfo
    );

DWORD
DereferenceViewByHandle(
    IN HINTERNET Handle,
    IN VIEW_TYPE ViewType
    );

//
// macros
//

#if INET_DEBUG

#define VIEW_CREATED()      ++NumberOfViews
#define VIEW_DESTROYED()    --NumberOfViews
#define ASSERT_NO_VIEWS() \
    if (NumberOfViews != 0) { \
        INET_ASSERT(FALSE); \
    }

#else

#define VIEW_CREATED()      /* NOTHING */
#define VIEW_DESTROYED()    /* NOTHING */
#define ASSERT_NO_VIEWS()   /* NOTHING */

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\test\gc\gc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gc.c

Abstract:

    Gopher client test program

    Basically a real console-mode (win32) gopher client that uses the gopher
    client APIs

    Contents:

Author:

    Richard L Firth (rfirth) 08-Nov-1994

Environment:

    Win32 console mode user executable

Revision History:

    08-Nov-1994 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <wininetd.h>
#include <string.h>
#include <malloc.h>
#include <ctype.h>
#include <fcntl.h>
#include <io.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

//
// manifests
//

#define HOME    -1

#define GC_CONNECT_CONTEXT  0x47474747
#define GC_FIND_CONTEXT     0x47474644
#define GC_FILE_CONTEXT     0x47474645

//
// prototypes
//

void _CRTAPI1 main(int, char**);
void usage(void);
void _CRTAPI1 my_cleanup(void);
void gopher(LPSTR, WORD, CHAR, LPSTR);
BOOL get_dir(LPSTR, LPSTR);
void get_file(LPSTR);
int get_user_request(LPSTR);
void clear_items(void);
void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);
void print_error(char*, char*, ...);
char hex_to_char(char);
char* decontrol(char*, char*);
void toodle_pip(void);

//
// global data
//

BOOL Verbose = FALSE;
BOOL MakeRequestGopherPlus = FALSE;
HINTERNET InetHandle = NULL;
HINTERNET hGopherSession = NULL;
BOOL NewHome = FALSE;
INTERNET_STATUS_CALLBACK PreviousCallback;
BOOL AsyncMode = FALSE;
HANDLE AsyncEvent = NULL;
DWORD AsyncResult;
DWORD AsyncError;
DWORD CacheFlags = 0;
BOOL UseQueryData = FALSE;
DWORD UserContext = 0;
BOOL UseUserContext = FALSE;

//
// functions
//

void _CRTAPI1 main(int argc, char** argv) {

    LPSTR server = NULL;
    LPSTR selector = NULL;
    WORD port = 70;
    BOOL fCallback = FALSE;
    char selectorType = '1';
    DWORD accessMethod = PRE_CONFIG_INTERNET_ACCESS;
    BOOL expectingProxy = FALSE;
    LPSTR proxyServer = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case '+':
                MakeRequestGopherPlus = TRUE;
                break;

            case 'a':
                ++*argv;
                if (**argv == 'l') {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                    if (*++*argv) {
                        proxyServer = *argv;
                    } else {
                        expectingProxy = TRUE;
                    }
                } else {
                    printf("error: unrecognised access type: '%c'\n", **argv);
                    usage();
                }
                break;

            case 'c':
                fCallback = TRUE;
                break;

            case 'n':
                CacheFlags |= INTERNET_FLAG_DONT_CACHE;
                break;

            case 'p':
                port = atoi(++*argv);
                break;

            case 'q':
                UseQueryData = TRUE;
                break;

            case 't':
                selectorType = *++*argv;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            case 'x':
                UseUserContext = TRUE;
                if (*++*argv) {
                    UserContext = (DWORD)strtoul(*argv, NULL, 0);
                }
                break;

            case 'y':
                AsyncMode = TRUE;
                break;

            default:
                printf("unknown command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxy) {
            proxyServer = *argv;
            expectingProxy = FALSE;
        } else if (!server) {
            server = *argv;
        } else if (!selector) {
            selector = *argv;
        } else {
            printf("unknown command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (!server) {
        usage();
    }

    //
    // exit function
    //

    atexit(my_cleanup);

    if (AsyncMode) {

        //
        // create an auto-reset, initially unsignalled event
        //

        AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!AsyncEvent) {
            print_error("gc", "CreateEvent()");
            exit(1);
        }
    }

    //
    // open gateway
    //

    InetHandle = InternetOpen("gc",
                              accessMethod,
                              proxyServer,
                              NULL,
                              AsyncMode ? INTERNET_FLAG_ASYNC : 0
                              );

    if (InetHandle == NULL) {
        print_error("gc", "InternetOpen()");
        exit(1);
    }

    if (fCallback) {

        //
        // let's have a status callback
        //

        PreviousCallback = InternetSetStatusCallback(InetHandle, my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    hGopherSession = InternetConnect(InetHandle,
                                     server,
                                     0,
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_GOPHER,
                                     0,
                                     UseUserContext ? UserContext : GC_CONNECT_CONTEXT
                                     );
    if (AsyncMode && (hGopherSession == NULL)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("gc", "InternetConnect()");
            exit(1);
        } else {
            if (Verbose) {
                printf("Waiting for async InternetConnect()\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            hGopherSession = (HINTERNET)AsyncResult;
            SetLastError(AsyncError);
        }
    }

    if (hGopherSession == NULL) {
        print_error("gc", "InternetConnect()");
        exit(1);
    }

    gopher(server, port, selectorType, selector);

    if (Verbose) {
        printf("closing InternetConnect handle %x\n", hGopherSession);
    }
    if (!InternetCloseHandle(hGopherSession)) {
        print_error("gc", "InternetCloseHandle(%#x)", hGopherSession);
    } else {
        hGopherSession = NULL;
    }

    if (Verbose) {
        printf("closing InternetOpen handle %x\n", InetHandle);
    }
    if (!InternetCloseHandle(InetHandle)) {
        print_error("gc", "InternetCloseHandle(%#x)", InetHandle);
    } else {
        InetHandle = NULL;
    }

    toodle_pip();
    exit(0);
}

void toodle_pip() {

    static LPSTR intl[] = {
        "Goodbye",
        "Au revoir",
        "Auf wiederzehen",
        "Cheers",
        "Ciao"
    };

    srand(GetTickCount());
    printf("%s.\n", intl[rand() % (sizeof(intl) / sizeof(intl[0]))]);
}

void usage() {
    printf("\n"
           "usage: gc [-+] [-a{l|p[ ]proxy}] [-c] [-p#] [-n] [-v] [-y] [-q] [-t<char>]\n"
           "          [-x#] [selector] <server>\n"
           "\n"
           "where: -+ = First request is gopher+\n"
           "       -a = Access type. Default is pre-configured:\n"
           "        l = direct internet access\n"
           "        p = proxy access\n"
           "       -c = Enable status callbacks\n"
           "       -n = Don't cache\n"
           "       -p = Port number to connect to at <server>. Default is 70\n"
           "       -q = use InternetQueryDataAvailable\n"
           "       -t = Selector type character, e.g. -t9 for binary file. Default is dir\n"
           "       -v = Verbose mode\n"
           "       -x = Context value. # is number to use as context\n"
           "       -y = Asynchronous APIs\n"
          );
    exit(1);
}

void _CRTAPI1 my_cleanup() {
    if (hGopherSession != NULL) {
        printf("closing InternetConnect handle %x\n", hGopherSession);
        if (!InternetCloseHandle(hGopherSession)) {
            print_error("my_cleanup", "InternetCloseHandle(%#x)", hGopherSession);
        }
    }
    if (InetHandle != NULL) {
        printf("closing InternetOpen handle %x\n", InetHandle);
        if (!InternetCloseHandle(InetHandle)) {
            print_error("my_cleanup", "InternetCloseHandle(%#x)", InetHandle);
        }
    }
}

char HomeLocator[MAX_GOPHER_SELECTOR_TEXT];

typedef struct {
    LPSTR display_string;
    LPSTR locator;
} GINFO;

GINFO items[4096];
int nitems = 0;

void gopher(LPSTR server, WORD port, CHAR selectorType, LPSTR selector) {

    LPSTR request = "";
    char locator[MAX_GOPHER_SELECTOR_TEXT];
    DWORD len;
    BOOL done = FALSE;
    HINTERNET h;
    BOOL unknownType;
    DWORD gopherType;

    //
    // if the user supplied a gopher type character then create a default
    // text locator, then change the type (evil!). Otherwise, the default
    // is directory
    //

    gopherType = selector ? GOPHER_TYPE_TEXT_FILE : GOPHER_TYPE_DIRECTORY;
    if (MakeRequestGopherPlus) {
        gopherType |= GOPHER_TYPE_GOPHER_PLUS;
    }

    len = sizeof(HomeLocator);
    if (!GopherCreateLocator(server,
                             port,
                             NULL,
                             selector,
                             gopherType,
                             locator,
                             &len
                             )) {
        print_error("gopher", "GopherCreateLocator()");
        return;
    }

    if (selector) {
        *locator = selectorType;
    }

    NewHome = TRUE;

    while (!done) {

        DWORD gopherType;

        unknownType = FALSE;
        if (!GopherGetLocatorType(locator, &gopherType)) {
            print_error("gopher", "GopherGetLocatorType()");
            exit(1);
        }
        if (gopherType & GOPHER_TYPE_DIRECTORY) {
            if (get_dir(locator, NULL)) {
                if (NewHome) {
                    strcpy(HomeLocator, locator);
                    NewHome = FALSE;
                }
            }
        } else if (gopherType & GOPHER_TYPE_FILE_MASK) {
            get_file(locator);
        } else {
            if (gopherType & GOPHER_TYPE_INDEX_SERVER) {

                char searchBuf[256];

                printf("\nEnter Text To Search For: ");
                gets(searchBuf);
                get_dir(locator, searchBuf);
            } else {
                unknownType = TRUE;
            }
        }
        if (unknownType) {

            char dcbuf[1024];

            printf("error: gopher: locator %s is unknown type\n",
                    decontrol(locator, dcbuf)
                    );
            return;
        }
        done = get_user_request(locator) == 0;
    }
}

char CurrentDirLocator[256];

BOOL get_dir(LPSTR locator, LPSTR search) {

    HINTERNET h;
    GOPHER_FIND_DATA data;
    DWORD error;

    h = GopherFindFirstFile(hGopherSession,
                            locator,
                            search,
                            &data,
                            CacheFlags, // dwFlags
                            UseUserContext ? UserContext : GC_FIND_CONTEXT
                            );

    if (AsyncMode && (h == NULL)) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            if (Verbose) {
                printf("waiting for async GopherFindFirstFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            h = (HINTERNET)AsyncResult;
            error = AsyncError;
        }
        if (h == NULL) {
            SetLastError(error);
        }
    }

    if (h != NULL) {

        LPGOPHER_FIND_DATA p = (LPGOPHER_FIND_DATA)&data;
        SYSTEMTIME systemTime;
        int i = 0;
        char timeBuf[9];
        char sizeBuf[32];
        BOOL ok;

        clear_items();
        strcpy(CurrentDirLocator, locator);
        do {
            items[i].display_string = _strdup(p->DisplayString);
            items[i].locator = _strdup(p->Locator);
            ++i;
            if ((p->LastModificationTime.dwLowDateTime != 0)
            && (p->LastModificationTime.dwHighDateTime != 0)) {
                FileTimeToSystemTime(&p->LastModificationTime, &systemTime);
                sprintf(timeBuf,
                        "%02d-%02d-%02d",
                        systemTime.wMonth,
                        systemTime.wDay,
                        systemTime.wYear % 100
                        );
                sprintf(sizeBuf, "%d", p->SizeLow);
            } else {
                timeBuf[0] = '\0';
                sizeBuf[0] = '\0';
            }
            printf("%5d %c %7s %10s %8s %s\n",
                    i,
                    (p->GopherType & GOPHER_TYPE_GOPHER_PLUS) ? '+' : ' ',
                    (p->GopherType & GOPHER_TYPE_TEXT_FILE)         ? "Text"
                    : (p->GopherType & GOPHER_TYPE_DIRECTORY)       ? "Dir"
                    : (p->GopherType & GOPHER_TYPE_CSO)             ? "Phone"
                    : (p->GopherType & GOPHER_TYPE_ERROR)           ? "Error"
                    : (p->GopherType & GOPHER_TYPE_MAC_BINHEX)      ? "MAC"
                    : (p->GopherType & GOPHER_TYPE_DOS_ARCHIVE)     ? "Archive"
                    : (p->GopherType & GOPHER_TYPE_UNIX_UUENCODED)  ? "UNIX"
                    : (p->GopherType & GOPHER_TYPE_INDEX_SERVER)    ? "Index"
                    : (p->GopherType & GOPHER_TYPE_TELNET)          ? "Telnet"
                    : (p->GopherType & GOPHER_TYPE_BINARY)          ? "Binary"
                    : (p->GopherType & GOPHER_TYPE_REDUNDANT)       ? "Backup"
                    : (p->GopherType & GOPHER_TYPE_TN3270)          ? "TN3270"
                    : (p->GopherType & GOPHER_TYPE_GIF)             ? "GIF"
                    : (p->GopherType & GOPHER_TYPE_IMAGE)           ? "Image"
                    : (p->GopherType & GOPHER_TYPE_BITMAP)          ? "Bitmap"
                    : (p->GopherType & GOPHER_TYPE_MOVIE)           ? "Movie"
                    : (p->GopherType & GOPHER_TYPE_SOUND)           ? "Sound"
                    : (p->GopherType & GOPHER_TYPE_HTML)            ? "HTML"
                    : (p->GopherType & GOPHER_TYPE_PDF)             ? "PDF"
                    : (p->GopherType & GOPHER_TYPE_CALENDAR)        ? "Cal"
                    : (p->GopherType & GOPHER_TYPE_INLINE)          ? "Inline"
                    : (p->GopherType & GOPHER_TYPE_UNKNOWN)         ? "Unknown"
                    : "\a????",
                    sizeBuf,
                    timeBuf,
                    p->DisplayString
                    );

            if (UseQueryData) {

                DWORD avail;

                ok = InternetQueryDataAvailable(h, &avail, 0, 0);
                if (!ok) {
                    error = GetLastError();
                    if (error == ERROR_IO_PENDING) {
                        if (Verbose) {
                            printf("waiting for async InternetQueryDataAvailable()...\n");
                        }
                        WaitForSingleObject(AsyncEvent, INFINITE);
                        ok = (BOOL)AsyncResult;
                        SetLastError(AsyncError);
                    }
                }
                if (ok) {
                    if (Verbose) {
                        printf("%sSYNC IQDA(): %d available\n", AsyncMode ? "A" : "", avail);
                    }
                } else {
                    print_error("get_dir()", "InternetQueryDataAvailable()");
                    break;
                }
            }

            ok = InternetFindNextFile(h, (LPGOPHER_FIND_DATA)&data);

            if (AsyncMode && !ok) {
                error = GetLastError();
                if (error == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetFindNextFile()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    error = AsyncError;
                }
                SetLastError(error);
            }
        } while (ok);

        if (GetLastError() != ERROR_NO_MORE_FILES) {
            print_error("get_dir", "InternetFindNextFile()");
        }

        nitems = i;

        if (Verbose) {
            printf("closing Find handle %x\n", h);
        }
        if (!InternetCloseHandle(h)) {
            print_error("get_dir", "InternetCloseHandle(%#x)", h);
        }

        return TRUE;
    } else {
        print_error("get_dir", "GopherFindFirstFile()");
        return FALSE;
    }
}

void get_file(LPSTR locator) {

    HINTERNET h;
    char buf[4096];
    DWORD error;

    h = GopherOpenFile(hGopherSession,
                       locator,
                       NULL,
                       CacheFlags,
                       UseUserContext ? UserContext : GC_FILE_CONTEXT
                       );

    if (AsyncMode && (h == NULL)) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            if (Verbose) {
                printf("waiting for async GopherOpenFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            h = (HINTERNET)AsyncResult;
            error = AsyncError;
        }
        SetLastError(error);
    }

    if (h == NULL) {
        print_error("get_file", "GopherOpenFile()");
    } else {

        DWORD nread;
        BOOL ok;
        DWORD avail;

        do {
            if (UseQueryData) {
                ok = InternetQueryDataAvailable(h, &avail, 0, 0);
                if (!ok) {
                    error = GetLastError();
                    if (error == ERROR_IO_PENDING) {
                        if (Verbose) {
                            printf("waiting for async InternetQueryDataAvailable()...\n");
                        }
                        WaitForSingleObject(AsyncEvent, INFINITE);
                        ok = (BOOL)AsyncResult;
                        SetLastError(AsyncError);
                    }
                }
                if (ok) {
                    if (Verbose) {
                        printf("%sSYNC IQDA(): %d available\n", AsyncMode ? "A" : "", avail);
                    }
                } else {
                    print_error("get_dir()", "InternetQueryDataAvailable()");
                    break;
                }
            } else {
                avail = sizeof(buf);
            }

            avail = min(avail, sizeof(buf));
            if (avail == 0) {
                break;
            }

            ok = InternetReadFile(h, buf, avail, &nread);

            if (!ok && AsyncMode) {
                error = GetLastError();
                if (error == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetReadFile()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    error = AsyncError;
                }
                SetLastError(error);
            }

            if (ok) {
                if (!nread) {
                    printf("=== end of file ===\n");
                    break;
                } else {
                    _setmode(1, _O_BINARY);
                    _write(1, buf, nread);
                }
            }
        } while (ok);

        if (!ok) {
            error = GetLastError();
            if (error != ERROR_SUCCESS) {
                print_error("get_file", "InternetReadFile()");
            }
        }
        if (Verbose) {
            printf("closing File handle %x\n", h);
        }
        if (!InternetCloseHandle(h)) {
            print_error("get_file", "InternetCloseHandle(%#x)", h);
        }
    }
}

int get_user_request(LPSTR locator) {

    int n;
    char buf[80];
    BOOL got = FALSE;
    char newLocator[256];
    char serverBuf[80];
    char portBuf[32];
    DWORD len = sizeof(newLocator);
    int i;
    BOOL ok;
    DWORD handles;
    DWORD size_handles;

    while (!got) {
        printf("\nEnter selection: ");
        gets(buf);
        if (isdigit(buf[0])) {
            n = atoi(buf);
            if (n >= 1 && n <= nitems) {
                strcpy(locator, items[n - 1].locator);
                got = TRUE;
            } else {
                printf("\n"
                       "error: must enter number in the range 1 to %d\n", nitems);
            }
        } else {
            switch (buf[0]) {
            case '+':
                printf("NYI\n");
                break;

            case '.':
                strcpy(locator, CurrentDirLocator);
                got = TRUE;
                break;

            case 'g':
                for (i = 1; buf[i] && isspace(buf[i]); ) {
                    ++i;
                }
                if (buf[i]) {

                    int j = 0;

                    while (buf[i] && !isspace(buf[i])) {
                        serverBuf[j++] = buf[i++];
                    }
                    serverBuf[j] = 0;
                    while (buf[i] && isspace(buf[i])) {
                        ++i;
                    }
                } else {
                    printf("server: ");
                    gets(serverBuf);
                }
                if (buf[i]) {

                    int j = 0;

                    while (buf[i] && !isspace(buf[i])) {
                        portBuf[j++] = buf[i++];
                    }
                    portBuf[j] = 0;
                } else {
                    printf("port:   ");
                    gets(portBuf);
                }
                if (!GopherCreateLocator(serverBuf,
                                         (WORD)atoi(portBuf),
                                         NULL,
                                         NULL,
                                         GOPHER_TYPE_DIRECTORY,
                                         newLocator,
                                         &len
                                         )) {
                    print_error("get_user_request", "GopherCreateLocator()");
                } else {
                    strcpy(locator, newLocator);
                    got = TRUE;
                }
                NewHome = TRUE;
                break;

            case 'h':
                n = HOME;
                strcpy(locator, HomeLocator);
                got = TRUE;
                break;

            case 'l':
                size_handles = sizeof(handles);
                ok = InternetQueryOption(NULL,
                                         INTERNET_OPTION_GET_HANDLE_COUNT,
                                         (LPVOID)&handles,
                                         &size_handles
                                         );
                if (!ok) {
                    print_error("get_user_request", "InternetQueryOption(handle count)");
                } else {
                    printf("current handle count = %d\n", handles);
                }
                break;

            case 'q':
                toodle_pip();
                exit(0);

            case 's':
                PreviousCallback = InternetSetStatusCallback(InetHandle,
                                                             PreviousCallback
                                                             );
                if (Verbose) {
                    printf("previous Internet callback = %x\n", PreviousCallback);
                }
                if ((PreviousCallback != NULL) && (PreviousCallback != my_callback)) {
                    printf("error: get_gopher_request: previous callback not recognised\n");
                }
                got = TRUE;
                break;

            case 'v':
                Verbose = !Verbose;
                printf("verbose mode %s\n", Verbose ? "on" : "off");
                break;

            default:
                printf("\n"
                       "enter the number of your selection or one of the following:\n"
                       "\n"
                       "\t+ = toggle gopher+\n"
                       "\t. = list current directory\n"
                       "\tg = go to new server\n"
                       "\th = list home directory\n"
                       "\t1 = display handle usage\n"
                       "\tq = quit\n"
                       "\ts = toggle status callback\n"
                       "\tv = toggle verbose mode\n"
                       );
            }
        }
    }
    putchar('\n');

    return n;
}

void clear_items() {
    while (nitems) {
        --nitems;
        free(items[nitems].display_string);
        free(items[nitems].locator);
    }
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                Handle,
                Context,
                (Context == GC_CONNECT_CONTEXT) ? "Connect"
                : (Context == GC_FIND_CONTEXT) ? "Find"
                : (Context == GC_FILE_CONTEXT) ? "File"
                : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {
                printf("%x", *(LPHINTERNET)Info);
            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else if (Status != INTERNET_STATUS_REQUEST_COMPLETE) {
                printf(Info);
            }
        }
        putchar('\n');
    }
    if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
        if (AsyncMode) {
            SetEvent(AsyncEvent);
        } else {
            printf("error: INTERNET_STATUS_REQUEST_COMPLETE received when not async\n");
        }
    }
}

char hex_to_char(char b) {
    return (b <= 9) ? (b + '0') : ((b - 10) + 'a');
}

char* decontrol(char* instr, char* outstr) {

    char* outp;

    for (outp = outstr; *instr; ++instr) {
        if (*instr < 0x20) {
            *outp++ = '\\';
            switch (*instr) {
            case '\t':
                *outp++ = 't';
                break;

            case '\r':
                *outp++ = 'r';
                break;

            case '\n':
                *outp++ = 'n';
                break;

            default:
                *outp++ = 'x';
                *outp++ = hex_to_char((char)(*instr >> 4));
                *outp++ = hex_to_char((char)(*instr & 15));
            }
        } else {
            *outp++ = *instr;
        }
    }
    *outp = 0;
    return outstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\handles\connect.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    Contains methods for INTERNET_CONNECT_HANDLE_OBJECT class

    Contents:
        RMakeInternetConnectObjectHandle
        FindExistingConnectObject
        FlushExistingConnectObjects
        INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT
        INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT
        INTERNET_CONNECT_HANDLE_OBJECT::AttachLastResponseInfo
        INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer
        INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo(INTERNET_SCHEME, BOOL, BOOL)
        INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo(LPSTR, DWORD)

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

#define DEFAULT_VARIABLE_CACHE_INFO_SIZE    512

//
// data
//
LONG GlobalExistingConnectHandles = 0;

extern DWORD dwCacheWriteBufferSize;

BOOL
GetCanonicalizedParentUrl(
    LPSTR   lpszChildUrl,
    LPSTR   lpszParentUrlBuff,
    DWORD   dwBuffSize);

//
// functions
//


DWORD
RMakeInternetConnectObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CONNECT_CLOSE_HANDLE_FUNC wCloseFunc,
    IN LPSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPSTR lpszUserName OPTIONAL,
    IN LPSTR lpszPassword OPTIONAL,
    IN DWORD ServiceType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates an INTERNET_CONNECT_HANDLE_OBJECT. Wrapper function callable from
    C code

Arguments:

    ParentHandle    - parent InternetOpen() handle

    ChildHandle     - IN: protocol-specific child handle
                      OUT: address of handle object

    wCloseFunc      - pointer to function to close when object deleted

    lpszServerName  - pointer to server name

    nServerPort     - server port to connect to

    lpszUserName    - optional user name

    lpszPassword    - optional password

    ServiceType     - type of service required, e.g. INTERNET_SERVICE_HTTP

    dwFlags         - various open flags from InternetConnect()

    dwContext       - app-supplied context value to associate with the handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    INTERNET_CONNECT_HANDLE_OBJECT * hConnect;

    hConnect = new INTERNET_CONNECT_HANDLE_OBJECT(
                                (INTERNET_HANDLE_OBJECT *)ParentHandle,
                                *ChildHandle,
                                wCloseFunc,
                                lpszServerName,
                                nServerPort,
                                lpszUserName,
                                lpszPassword,
                                ServiceType,
                                dwFlags,
                                dwContext
                                );

    if (hConnect != NULL) {
        error = hConnect->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hConnect);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hConnect = NULL;
            }
        } else {
            delete hConnect;
            hConnect = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hConnect;

    return error;
}


HINTERNET
FindExistingConnectObject(
    IN HINTERNET hInternet,
    IN LPSTR lpHostName,
    IN INTERNET_PORT nPort,
    IN LPSTR lpszUserName,
    IN LPSTR lpszPassword,
    IN DWORD dwServiceType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Attempts to find an existing INTERNET_CONNECT_HANDLE_OBJECT with the
    desired attributes

Arguments:

    hInternet       - required parent handle

    lpHostName      - pointer to host name to connect to

    nPort           - port at server to connect to

    lpszUserName    - name of user making requests

    lpszPassword    - password required to establish connection

    dwServiceType   - type of service required

    dwFlags         - extra control information

    dwContext       - required context value

Return Value:

    HINTERNET
        Success - handle of found object

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Handle,
                 "FindExistingConnectObject",
                 "%#x, %q, %d, %q, %q, %s (%d), %#x, %#x",
                 hInternet,
                 lpHostName,
                 nPort,
                 lpszUserName,
                 lpszPassword,
                 InternetMapService(dwServiceType),
                 dwServiceType,
                 dwFlags,
                 dwContext
                 ));

    HINTERNET hConnect = NULL;
    HINTERNET_HANDLE_TYPE handleType;
    INTERNET_PORT defaultPort;

    switch (dwServiceType) {
    case INTERNET_SERVICE_FTP:
        handleType = TypeFtpConnectHandle;
        defaultPort = INTERNET_DEFAULT_FTP_PORT;
        break;

    case INTERNET_SERVICE_GOPHER:
        handleType = TypeGopherConnectHandle;
        defaultPort = INTERNET_DEFAULT_GOPHER_PORT;
        break;

    case INTERNET_SERVICE_HTTP:
        handleType = TypeHttpConnectHandle;
        defaultPort = (dwFlags & INTERNET_FLAG_SECURE)
                        ? INTERNET_DEFAULT_HTTPS_PORT
                        : INTERNET_DEFAULT_HTTP_PORT;
        break;

    default:

        INET_ASSERT(FALSE);

        break;
    }

    if (nPort == INTERNET_INVALID_PORT_NUMBER) {
        nPort = defaultPort;
    }

    LockSerializedList(&GlobalObjectList);

    PLIST_ENTRY entry;

    for (entry = HeadOfSerializedList(&GlobalObjectList);
        entry != (PLIST_ENTRY)SlSelf(&GlobalObjectList);
        entry = entry->Flink) {

        HANDLE_OBJECT * pObject = CONTAINING_RECORD(entry, HANDLE_OBJECT, _List);

        //
        // check elements of the HANDLE_OBJECT first (DWORDs)
        //

        HANDLE_OBJECT * pParent = (HANDLE_OBJECT *)pObject->GetParent();

        if ((pObject->GetHandleType() == handleType)
        && ((pParent != NULL) && (pParent->GetPseudoHandle() == hInternet))
        && (pObject->GetContext() == dwContext)

        //
        // the handle may be invalidated - its been closed, but is still alive
        // because it has children which are in the process of being closed
        //

        && !pObject->IsInvalidated()) {

            //
            // handle is correct type & has the right parent & context values.
            // Next, check if its reusable and currently unused, and has the
            // correct destination attributes
            //

            INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

            pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pObject;
            if (!pConnect->IsInUse() && (pConnect->GetHostPort() == nPort)) {

                LPSTR hostName = pConnect->GetHostName();

                if (((lpHostName == NULL) && (hostName == NULL))
                || ((lpHostName != NULL) && (hostName != NULL)
                    && !stricmp(lpHostName, hostName))) {

                    //
                    // must have same name and password, or no name and/or
                    // password
                    //

                    LPSTR userName = pConnect->GetUserOrPass (TRUE, IS_SERVER);

                    if (((lpszUserName == NULL) && (userName == NULL))
                    || ((lpszUserName != NULL) && (userName != NULL)
                        && !strcmp(lpszUserName, userName))) {

                        LPSTR password = pConnect->GetUserOrPass (FALSE, IS_SERVER);

                        if (((lpszPassword == NULL) && (password == NULL))
                        || ((lpszPassword != NULL) && (password != NULL)
                            && !strcmp(lpszPassword, password))) {

                            //
                            // this one will do - should be no other users
                            //

                            //INET_ASSERT(pConnect->ReferenceCount() == 1);
//{
//    if (pConnect->ReferenceCount() != 1) {
//        dprintf("handle %#x [%#x]: refcount = %d\n",
//            pConnect,
//            pConnect->GetPseudoHandle(),
//            pConnect->ReferenceCount()
//            );
//    }
//}
                            if (pConnect->ReferenceCount() == 1) {

                                //
                                // reset the CWD - ignore any error
                                //

                                DWORD error = pConnect->SetCurrentWorkingDirectory("/");

                                INET_ASSERT(error == ERROR_SUCCESS);

                                //
                                // this handle is back in use
                                //

                                pConnect->SetInUse();
                                hConnect = (HINTERNET)pConnect;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    UnlockSerializedList(&GlobalObjectList);

    DEBUG_LEAVE(hConnect);

    return hConnect;
}


INT
FlushExistingConnectObjects(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes all unused EXISTING_CONNECT objects that are children of hInternet

Arguments:

    hInternet   - parent handle

Return Value:

    INT
        Number of handles flushed

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "FlushExistingConnectObjects",
                 "%#x",
                 hInternet
                 ));

    INT nFlushed = 0;

    if (GlobalExistingConnectHandles > 0) {

        LockSerializedList(&GlobalObjectList);

        PLIST_ENTRY previous = (PLIST_ENTRY)SlSelf(&GlobalObjectList);
        PLIST_ENTRY entry = HeadOfSerializedList(&GlobalObjectList);

        while (entry != (PLIST_ENTRY)SlSelf(&GlobalObjectList)) {

            HANDLE_OBJECT * pObject = CONTAINING_RECORD(entry, HANDLE_OBJECT, _List);
            HANDLE_OBJECT * pParent = (HANDLE_OBJECT *)pObject->GetParent();
            BOOL flushed = FALSE;

            if ((pParent != NULL) && (pParent->GetPseudoHandle() == hInternet)) {

                HINTERNET_HANDLE_TYPE handleType = pObject->GetHandleType();

                if ((handleType == TypeFtpConnectHandle)
                || (handleType == TypeGopherConnectHandle)
                || (handleType == TypeHttpConnectHandle)) {

                    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

                    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pObject;
                    if (!pConnect->IsInUse() && !pConnect->IsInvalidated()) {

                        //INET_ASSERT(pConnect->ReferenceCount() == 1);

                        IF_DEBUG_CONTROL(ANY) {

                            if (pConnect->ReferenceCount() != 1) {

                                DEBUG_PRINT(OBJECTS,
                                            WARNING,
                                            ("handle %#x [%#x]: refcount = %d\n",
                                            pConnect,
                                            pConnect->GetPseudoHandle(),
                                            pConnect->ReferenceCount()
                                            ));

                                //dprintf("handle %#x [%#x]: refcount = %d\n",
                                //        pConnect,
                                //        pConnect->GetPseudoHandle(),
                                //        pConnect->ReferenceCount()
                                //        );
                            }

                        }

                        //
                        // invalidate the object (stops an assert - we normally
                        // expect the handle to be invalidated by
                        // MapHandleToAddress(), but we're simply dereferencing
                        // the object, which would usually be done by the second
                        // of 2 calls to DereferenceObject(), so we save ourselves
                        // from jumping through hoops just to destroy the object)
                        //

                        pConnect->Invalidate();
                        flushed = pConnect->Dereference();

                        //
                        // the entry was unused; it should have been destroyed
                        //

                        //INET_ASSERT(flushed);

                        DEBUG_PRINT(OBJECTS,
                                    INFO,
                                    ("flushed object %#x\n",
                                    pConnect
                                    ));

                    }
                }
            }

            //
            // if we just destroyed the object pointed at by entry then we need
            // to dereference the previous pointer for the next object
            //

            if (flushed) {
                ++nFlushed;
                entry = previous->Flink;
            } else {
                previous = entry;
                entry = entry->Flink;
            }
        }

        UnlockSerializedList(&GlobalObjectList);
    }

    DEBUG_LEAVE(nFlushed);

//dprintf("*** flushed %d objects\n", nFlushed);
    return nFlushed;
}

//
// INTERNET_CONNECT_HANDLE_OBJECT class implementation
//


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *InternetConnectObj
    ) : INTERNET_HANDLE_OBJECT((INTERNET_HANDLE_OBJECT *)InternetConnectObj)

/*++

Routine Description:

    Constructor that creates a copy of an INTERNET_CONNECT_HANDLE_OBJECT when
    generating a derived handle object, such as a HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    InternetConnectObj  - INTERNET_CONNECT_HANDLE_OBJECT to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x",
                 InternetConnectObj
                 ));

    _InternetConnectHandle = InternetConnectObj->_InternetConnectHandle;
    _wCloseFunction = InternetConnectObj->_wCloseFunction;
    _HandleType = InternetConnectObj->_HandleType;
    _ServiceType = InternetConnectObj->_ServiceType;
    _IsCopy = TRUE;

    //
    // copy the flags except EXISTING_CONNECT - we don't want to influence the
    // number of flushable handles just by closing a request handle
    //

    _Flags = InternetConnectObj->_Flags & ~INTERNET_FLAG_EXISTING_CONNECT;

    //
    // in this case, we are not dealing with a real connect handle object, but a
    // derived object, hence _InUse is FALSE
    //

    _InUse = FALSE;

    _ReadBufferSize = InternetConnectObj->_ReadBufferSize;
    _WriteBufferSize = InternetConnectObj->_WriteBufferSize;

    //
    // copy the name objects and server port
    //

    _HostName = InternetConnectObj->_HostName;
    _HostPort = InternetConnectObj->_HostPort;

    //
    // _SchemeType is actual scheme we use. May be different than original
    // object type when going via CERN proxy. Initially set to default (HTTP)
    //

    _SchemeType = InternetConnectObj->_SchemeType;

    //
    // _LastResponseInfo points to a buffer containing the last response info
    // from an FTP URL operation
    //

    _LastResponseInfo = NULL;

    InitCacheVariables();
    if (InternetConnectObj->_CacheUrlName != NULL) {
        SetURL (InternetConnectObj->_CacheUrlName);
    }
    if (InternetConnectObj->_CacheCWD != NULL) {
        _CacheCWD = NEW_STRING(InternetConnectObj->_CacheCWD);
    }

    // Inherit the PerUserItem status of the parent
    _CachePerUserItem = InternetConnectObj->_CachePerUserItem;
    
    _bViaProxy = InternetConnectObj->_bViaProxy;
    _bNoHeaders = InternetConnectObj->_bNoHeaders;
    _bNetFailed = InternetConnectObj->_bNetFailed;
    _ServerInfo = InternetConnectObj->_ServerInfo;
    _OriginServer = InternetConnectObj->_OriginServer;
    _dwErrorMask = 0;

    //
    // reference the server info to balance the deref in our destructor
    //

    if (_ServerInfo != NULL) {

        //
        // could be cache-only handle
        //

        _ServerInfo->Reference();
    }
    if (_OriginServer != NULL) {
        _OriginServer->Reference();
    }

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_HANDLE_OBJECT * Parent,
    HINTERNET Child,
    CONNECT_CLOSE_HANDLE_FUNC wCloseFunc,
    LPTSTR lpszServerName,
    INTERNET_PORT nServerPort,
    LPTSTR lpszUsername OPTIONAL,
    LPTSTR lpszPassword OPTIONAL,
    DWORD SrvType,
    DWORD dwFlags,
    DWORD_PTR dwContext
    ) : INTERNET_HANDLE_OBJECT(Parent)

/*++

Routine Description:

    Constructor for direct-to-net INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    Parent          - pointer to parent handle (INTERNET_HANDLE_OBJECT as
                      created by InternetOpen())

    Child           - handle of child object - typically an identifying value
                      for the protocol-specific code

    wCloseFunc      - pointer to function that handles closes when
                      InternetCloseHandle() called for this object

    lpszServerName  - name of the server we are connecting to. May also be the
                      IP address expressed as a string

    nServerPort     - the port number at the server to which we connect

    lpszUsername    - user name for logon at server (if required)

    lpszPassword    - password for logon at server (if required)

    SrvType         - Type of service, e.g. INTERNET_SERVICE_HTTP that this
                      object represents

    dwFlags         - creation flags from InternetConnect():

                        - INTERNET_FLAG_PASSIVE

    dwContext       - context value for call-backs

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x, %#x, %#x, %q, %d, %q, %q, %s (%d), %#x, %#x",
                 Parent,
                 Child,
                 wCloseFunc,
                 lpszServerName,
                 nServerPort,
                 lpszUsername,
                 lpszPassword,
                 InternetMapService(SrvType),
                 SrvType,
                 dwFlags,
                 dwContext
                 ));

    _fHasCredsTimestamp = FALSE;

    _InternetConnectHandle = Child;
    _wCloseFunction = wCloseFunc;
    _ServiceType = SrvType;
    _Context = dwContext;
    _IsCopy = FALSE;

    SetHandleType(SrvType);

    //
    // remember the creation flags. Mainly (currently) for HTTP Keep-Alive
    //

    _Flags = dwFlags;

    //
    // setting _InUse to TRUE stops any EXISTING_CONNECT requests from acquiring
    // it
    //

    _InUse = TRUE;

    InitCacheVariables();

    //
    // set the read/write buffer sizes to the default values (4K)
    //

    _ReadBufferSize = (4 K);
    _WriteBufferSize = (4 K);

    //
    // create the string buffer and copy the port number
    //

    _HostName = lpszServerName;
    if (lpszUsername) {
        _xsUser.SetData(lpszUsername);
    }
    if (lpszPassword) {
        _xsPass.SetData(lpszPassword);
        TimeStampCreds();
    }
    _HostPort = nServerPort;

    //
    // set the scheme and object types based on the service type
    //

    INTERNET_SCHEME schemeType;
    HINTERNET_HANDLE_TYPE handleType;

    switch (_ServiceType) {
    case INTERNET_SERVICE_HTTP:
        schemeType = INTERNET_SCHEME_HTTP;
        handleType = TypeHttpConnectHandle;
        break;

    case INTERNET_SERVICE_FTP:
        schemeType = INTERNET_SCHEME_FTP;
        handleType = TypeFtpConnectHandle;
        break;

    case INTERNET_SERVICE_GOPHER:
        schemeType = INTERNET_SCHEME_GOPHER;
        handleType = TypeGopherConnectHandle;
        break;

    default:
        schemeType = INTERNET_SCHEME_DEFAULT;
        handleType = TypeWildHandle;
        break;
    }
    SetSchemeType(schemeType);
    SetObjectType(handleType);

    //
    // _LastResponseInfo points to a buffer containing the last response info
    // from an FTP URL operation
    //

    _LastResponseInfo = NULL;
    _bViaProxy = FALSE;
    _bNoHeaders = TRUE;
    _bNetFailed = FALSE;
    _HandleFlags.fServerUserPassValid = TRUE;
    _HandleFlags.fProxyUserPassValid = TRUE;

    //
    // we need to get the server info that we are going to connect to. In the
    // HTTPS case, we don't yet have enough info to make a proper decision, so
    // we defer that until HttpOpenRequest() at which point we may get another
    // SERVER_INFO
    //

    _ServerInfo = NULL;
    _OriginServer = NULL;
    _Status = SetServerInfo(schemeType, FALSE);

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT(VOID)

/*++

Routine Description:

    Destructor for INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT",
                 NULL
                 ));

    if ((!_IsCopy) && (_InternetConnectHandle != INET_INVALID_HANDLE_VALUE)) {

        HINTERNET _INetHandle;
        DWORD LocalError = ERROR_SUCCESS;

        _INetHandle = this->GetInternetHandle();

        if (_INetHandle == LOCAL_INET_HANDLE) {
            if (_wCloseFunction != NULL) {
                LocalError = ERROR_SUCCESS;
                if (!(this->GetInternetOpenFlags() & INTERNET_FLAG_OFFLINE)) {
                    LocalError = _wCloseFunction(_InternetConnectHandle,
                                                 _ServiceType
                                                 );
                }
            } else {

                INET_ASSERT(LocalError == ERROR_SUCCESS);

            }
        }

        //INET_ASSERT( LocalError == ERROR_SUCCESS );

    }

    if (_CacheReadInProgress) {

        INET_ASSERT(_CacheWriteInProgress == FALSE);

        EndCacheRetrieval();
    } else if (_CacheWriteInProgress) {

        // Abort cache write operation
        //

        EndCacheWrite(NULL, NULL, NULL, 0xffffffff, 0, NULL, NULL);
    }

    // background update if the flag is set
    if( _fLazyUpdate )
    {
        LazyUpdate();
    }


    if (_hLockRequestInfo) {

        //
        // If the request is locked, the last InternetUnlockRequestFile
        // will clean up so there is no need to check _fDeleteDataFile.
        //

        if (_fDeleteDataFile) {

            // We let InternetUnlockRequestFile know that it doesn't
            // have to do a cache lookup and if DeleteFile fails that
            // it should add the file to the leaked list.

            LPLOCK_REQUEST_INFO pLock = (LPLOCK_REQUEST_INFO) _hLockRequestInfo;
            pLock->fNoCacheLookup = TRUE;

        }

        InternetUnlockRequestFile(_hLockRequestInfo);

    } else if (_fDeleteDataFile) {

        //
        // This flag is set if we are not committing a download file to cache,
        // either because we never intended to or the download was aborted.
        //

        if (!DeleteFile (_CacheFileName)) {

            switch (GetLastError()) {
                case ERROR_SHARING_VIOLATION:
                case ERROR_ACCESS_DENIED:
                 UrlCacheAddLeakFile (_CacheFileName);
            }
        }
    }

    // delete the staled entry (to prevent back/fwd see the staled entry)
    if( _fDeleteDataFile && _CacheUrlName ) {
        DeleteUrlCacheEntry(_CacheUrlName);
    }

    FreeCacheFileName();

    INET_ASSERT(_CacheFileName == NULL);
    INET_ASSERT(_CacheFileHandle == INVALID_HANDLE_VALUE);

    if (_CacheCWD) {
        _CacheCWD = (LPSTR)FREE_MEMORY((HLOCAL)_CacheCWD);

        INET_ASSERT(_CacheCWD == NULL);

    }

    // if there is refcount, then remove it


    FreeURL();

    SetOriginalUrl(NULL);

#ifdef LAZY_WRITE
    if (_CacheScratchBuf) {
        _CacheScratchBuf = (LPBYTE)FREE_MEMORY((HLOCAL)_CacheScratchBuf);

        INET_ASSERT(_CacheScratchBuf == NULL);

    }
#endif

    FreeLastResponseInfo();

    if ((_Flags & INTERNET_FLAG_EXISTING_CONNECT) && !_InUse) {

        //
        // one less handle that can be flushed right now
        //

//dprintf("GlobalExistingConnectHandles = %d\n", GlobalExistingConnectHandles);

        if (InterlockedDecrement(&GlobalExistingConnectHandles) < 0) {

            INET_ASSERT(FALSE);

            GlobalExistingConnectHandles = 0;
        }
    }

    if (_ServerInfo != NULL) {
        _ServerInfo->Dereference();
    }
    if (_OriginServer != NULL) {
        _OriginServer->Dereference();
    }

    DEBUG_LEAVE(0);
}

BOOL INTERNET_CONNECT_HANDLE_OBJECT::SetURL (LPSTR lpszUrl)
{
    LPSTR lpszNew;

    if (!_xsSecondaryCacheKey.GetPtr()) {

        // Make an undecorated copy of the URL.

        lpszNew = NewString(lpszUrl);
        if (!lpszNew) {
            return FALSE;
        }

    } else {

        // Decorate the URL by appending the secondary cache key.

        lpszNew = CatString (lpszUrl, _xsSecondaryCacheKey.GetPtr());
        if (!lpszNew) {
            return FALSE;
        }

        // Restore the undecorated URL as the primary cache key.

        if (!_xsPrimaryCacheKey.SetData (lpszUrl)) {
            FREE_MEMORY (lpszNew);
            return FALSE;
        }

    }

    // Clear any previous cache key and record the new one.

    FreeURL();
    INET_ASSERT (lpszNew);
    _CacheUrlName = lpszNew;
    return TRUE;
}

BOOL INTERNET_CONNECT_HANDLE_OBJECT::SetURLPtr(LPSTR* ppszUrl)
{
    LPSTR lpszNew;

    if (!_xsSecondaryCacheKey.GetPtr()) {

        // Swap in the new URL as the cache key.

        FreeURL();
        _CacheUrlName = *ppszUrl;
        *ppszUrl = NULL;

    } else {

        // Decorate the URL by appending the secondary cache key.

        lpszNew = CatString (*ppszUrl, _xsSecondaryCacheKey.GetPtr());
        if (!lpszNew) {
            return FALSE;
        }

        // Back up the undecorated URL as the primary cache key.

        _xsPrimaryCacheKey.SetPtr (ppszUrl);
        INET_ASSERT (!*ppszUrl);

        // Clear any previous cache key and record the new one.

        FreeURL();
        _CacheUrlName = lpszNew;
    }

    return TRUE;
}


BOOL INTERNET_CONNECT_HANDLE_OBJECT::SetSecondaryCacheKey (LPSTR lpszKey)
{
    LPSTR lpszTemp = NULL;


    if (_CacheUrlName) {

        // Decorate the URL by appending the secondary cache key.

        // BUGBUG: what if it is already decorated?  The app
        // better not set the secondary cache key more than once.

        lpszTemp = CatString (_CacheUrlName, lpszKey);
        if (!lpszTemp)
            return FALSE;
    }

    // Save the secondary cache key in case we later change the URL.

    if (!_xsSecondaryCacheKey.SetData (lpszKey)) {

        if (lpszTemp) {
            FREE_MEMORY (lpszTemp);
        }
        return FALSE;
    }

    if (lpszTemp)
    {
        // Back up the undecorated URL as the primary cache key.

        _xsPrimaryCacheKey.SetPtr (&_CacheUrlName);
        INET_ASSERT (!_CacheUrlName);
        _CacheUrlName = lpszTemp;
    }

    return TRUE;
}

void INTERNET_CONNECT_HANDLE_OBJECT::FreeSecondaryCacheKey (void)
{
    if (_xsSecondaryCacheKey.GetPtr()) {

        // Free the secondary key and the decorated URL.

        _xsSecondaryCacheKey.Free();
        FreeURL();

        // Back up the cache key from the undecorated URL.

        LPSTR lpszOld = _xsPrimaryCacheKey.ClearPtr();
        _CacheUrlName = lpszOld;
    }
}


HINTERNET
INTERNET_CONNECT_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _InternetConnectHandle;
}

//
// Cache methods.
//

char* back_up(char* stopper, char* ptr) {

    INET_ASSERT(stopper <= ptr);

    while ((*ptr != '/') && (ptr >= stopper)) --ptr;
    return ((ptr >= stopper) && (*ptr == '/')) ? ptr : NULL;
}

char* convert_macros(char* path) {

    char* ls = NULL;    // last slash
    char* pls = NULL;   // previous last slash
    char* p = path;

    while (*p) {
        if (*p == '/') {
            pls = ls;
            ls = p;
        }
        if (*p == '.') {
            if (*(p + 1) == '/') {
                p = lstrcpy(ls, p + 1);
            } else if (*(p + 1) == '\0') {
                if (*(p - 1) == '/') {
                    *p = '\0';
                }
            } else if (!strncmp(p, "../", 3)) {
                if ((!pls) || (ls != p - 1)) {
                    return NULL;
                }
                p = lstrcpy(pls, p + 2);
                ls = pls;
                pls = back_up(path, max(path, pls - 1));
            } else if (!lstrcmp(p, "..")) {
                if ((*(p - 1) != '/') || !pls) {
                    return NULL;
                } else {
                    *(pls + 1) = 0;
                    p = pls - 1;
                }
            }
        }
        ++p;
    }
    return path;
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::SetCurrentWorkingDirectory(
    IN LPSTR lpszCWD
    )
{
    INET_ASSERT(lpszCWD != NULL);

    //
    // BUGBUG - we assume lpszCWD is clean which might not be true....
    //

    int clen;
    int slen;
    LPSTR cwd;

    if (*lpszCWD == '/') {
        cwd = NULL;
        ++lpszCWD;
    } else {
        cwd = _CacheCWD;
    }

    if (!cwd) {
        clen = 1;
    } else {
        clen = lstrlen(cwd);
    }

    slen = lstrlen(lpszCWD);

    LPSTR buffer = (LPSTR)ALLOCATE_FIXED_MEMORY(clen + 1 + slen + 1);

    if (buffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (clen == 1) {
        buffer[0] = '/';
    } else {
        memcpy(buffer, _CacheCWD, clen);
    }

    memcpy(&buffer[clen], lpszCWD, slen);
    clen += slen;
    if ((clen > 1) && (lpszCWD[slen - 1] != '/')) {
        buffer[clen++] = '/';
    }
    buffer[clen] = '\0';

    LPSTR p = convert_macros(buffer);

    if (p) {
        if (_CacheCWD != NULL) {
            FREE_MEMORY(_CacheCWD);
            _CacheCWD = NULL;
        }
        _CacheCWD = NewString(p);
    }

    FREE_MEMORY(buffer);

    return (p == NULL) ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS;
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::GetCurrentWorkingDirectory(
    LPSTR   lpszCWD,
    LPDWORD lpdwLen
    )
{
    DWORD   dwlenCWD;

    if (!_CacheCWD) {
        *lpdwLen = 0;
    }
    else {
        // do something if the guy gave us any buffer
        if (*lpdwLen) {
            dwlenCWD = lstrlen(_CacheCWD);

            // if the buffer is not enough, copy the size of the buffer
            if (dwlenCWD >= *lpdwLen) {
                memcpy(lpszCWD, _CacheCWD, *lpdwLen);
            }
            else {
                strcpy(lpszCWD, _CacheCWD);
                *lpdwLen = dwlenCWD;
            }
        }
    }
    return (ERROR_SUCCESS);
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::SetObjectName(
    LPSTR lpszObjectName,
    LPSTR lpszExtension,
    URLGEN_FUNC * procProtocolUrl
    )
{
    DWORD   dwLen, dwError;
    INTERNET_SCHEME schemeType;

    // BUGBUG move this to protocol specific object

    //
    // if there is already an object name, then free it. We are replacing it
    //

    //
    // BUGBUG - make _CacheUrlString an ICSTRING
    //

    FreeURL();

    //
    // get protocol specific url
    //

    if (procProtocolUrl) {

        //
        // if we are going via proxy AND this is an FTP object AND the user name
        // consists of <username>@<servername> then <servername> is the real
        // server name, and _HostName is the name of the proxy
        //

        //
        // BUGBUG - this is a bit of a hack(!)
        //

        LPSTR target = _HostName.StringAddress();

        if (IsProxy()
        && (GetSchemeType() == INTERNET_SCHEME_FTP)
        && (_xsUser.GetPtr())) {

            LPSTR at = strchr(_xsUser.GetPtr(), '@');

            if (at != NULL) {
                target = at + 1;

                INET_ASSERT(*target);

            }
        }
        schemeType = GetSchemeType();

        // make the scheme type https if necessary

        schemeType = (((schemeType == INTERNET_SCHEME_DEFAULT)||
                      (schemeType == INTERNET_SCHEME_HTTP)) &&
                      (_dwCacheFlags & INTERNET_FLAG_SECURE))?
                      INTERNET_SCHEME_HTTPS: schemeType;

        LPSTR lpszNewUrl = NULL;

        dwError = (*procProtocolUrl)(schemeType,
                                     target,
                                     _CacheCWD,
                                     lpszObjectName,
                                     lpszExtension,
                                     _HostPort,
                                     &lpszNewUrl,
                                     &dwLen
                                     );

        if (dwError == ERROR_SUCCESS) {

            if (!SetURLPtr (&lpszNewUrl)) {
                FREE_MEMORY (lpszNewUrl);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
	}
	else
	{
		dwError = ERROR_INVALID_PARAMETER;
	}

    if (dwError == ERROR_SUCCESS) {

        DEBUG_PRINT(HANDLE,
                    INFO,
                    ("Url: %s\n",
                    _CacheUrlName
                    ));

    }
    return dwError;
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::BeginCacheRetrieval(
    LPCACHE_ENTRY_INFO  *lplpCacheEntryInfo
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::BeginCacheRetrieval",
                 "{%q} %#x",
                 _CacheUrlName,
                 lplpCacheEntryInfo
                 ));

    DWORD Error = ERROR_NOT_SUPPORTED;
    DWORD dwBufferSize = 0;
    int i;

    INET_ASSERT( _CacheReadInProgress == FALSE );
    INET_ASSERT( _CacheWriteInProgress == FALSE );
    //INET_ASSERT( _CacheFileName == NULL );
    INET_ASSERT( _CacheFileHandle == INVALID_HANDLE_VALUE );
    INET_ASSERT( _hCacheStream == NULL);

    *lplpCacheEntryInfo = NULL;

    if (!_CacheUrlName) {

        DEBUG_PRINT(CACHE,
                    ERROR,
                    ("Cache: No UrlName\n"
                    ));

        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);

        return (ERROR_INVALID_PARAMETER);
    }

    dwBufferSize = sizeof(CACHE_ENTRY_INFO) + DEFAULT_VARIABLE_CACHE_INFO_SIZE;
    for (i=0; i<2; ++i) {

        if (*lplpCacheEntryInfo != NULL) {
            FREE_MEMORY(*lplpCacheEntryInfo);
        }

        *lplpCacheEntryInfo = (LPCACHE_ENTRY_INFO)ALLOCATE_MEMORY(
                                    LPTR
                                    , dwBufferSize);
        if (*lplpCacheEntryInfo) {
            _hCacheStream = RetrieveUrlCacheEntryStream( _CacheUrlName,
                                       *lplpCacheEntryInfo,
                                        &dwBufferSize,
                                        FALSE, // Not Random, sequential
                                        0);
            if (_hCacheStream == NULL) {

                //
                // second time around the buffer must be sufficient
                //

                INET_ASSERT(!((i == 1) && (Error == ERROR_INSUFFICIENT_BUFFER)));

                Error = GetLastError();

                if ((i == 1) || (Error != ERROR_INSUFFICIENT_BUFFER)) {
                    goto Cleanup;
                }
            } else {

                break; // success
            }
        }
    }

    Error = RecordCacheRetrieval (*lplpCacheEntryInfo);

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        if (*lplpCacheEntryInfo) {
            FREE_MEMORY(*lplpCacheEntryInfo);
            *lplpCacheEntryInfo = NULL;
        }
        FreeCacheFileName();
    }

    DEBUG_LEAVE(Error);

    return( Error );
}

DWORD INTERNET_CONNECT_HANDLE_OBJECT::RecordCacheRetrieval
    (LPCACHE_ENTRY_INFO lpCacheEntryInfo)
{
    //
    // save cache file name.
    //
    FreeCacheFileName();
    INET_ASSERT(!_CacheFileName);
    _CacheFileName = NewString((lpCacheEntryInfo)->lpszLocalFileName);
    if (!_CacheFileName) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    _dwStreamRefCount = 0;
    _dwCurrentStreamPosition = 0;

    //
    // we have this much data immediately available to the application
    //

    SetAvailableDataLength((lpCacheEntryInfo)->dwSizeLow);

    //
    // and we automatically have the end-of-file indication
    //

    SetEndOfFile();

    _CacheReadInProgress = TRUE;

    return ERROR_SUCCESS;
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::ReadCache(
    LPBYTE lpbBuffer,
    DWORD dwBufferLen,
    LPDWORD lpdwBytesRead
    )
{
    DWORD dwError = ERROR_NOT_SUPPORTED;
    BOOL fOk;

    INET_ASSERT( _CacheReadInProgress == TRUE );

    *lpdwBytesRead = dwBufferLen;

    fOk = ReadUrlCacheEntryStream(
                                    _hCacheStream,
                                    _dwCurrentStreamPosition,
                                    lpbBuffer,
                                    lpdwBytesRead,
                                    0);
    if (fOk) {
        _dwCurrentStreamPosition += *lpdwBytesRead;
    }

    if( !fOk ) {
        dwError = GetLastError() ;
    }
    else {
        dwError =  ERROR_SUCCESS;

        DEBUG_PRINT(CACHE,
                    INFO,
                    ("read %d bytes from cache\n",
                    *lpdwBytesRead
                    ));

    }

    return(dwError);
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::EndCacheRetrieval(
    VOID
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "EndCacheRetrieval",
                 "Url=%s, File=%s",
                 _CacheUrlName, _CacheFileName
                 ));

    DWORD Error = ERROR_SUCCESS;

    INET_ASSERT( _CacheUrlName != NULL );
    INET_ASSERT( _CacheReadInProgress == TRUE );
    INET_ASSERT( _CacheWriteInProgress == FALSE );


    INET_ASSERT(_hCacheStream != NULL);

    if (!_dwStreamRefCount) {    // if the caller obtained it using GetCacheStream
                                // then it is his responsibility to call
                                // UnlockCacheStream
        DEBUG_PRINT(CACHE,
                        INFO,
                        ("Wininet.EndCacheRetrieval: Calling UnlockUrlCacheEntryStream for %s\n",
                        _CacheUrlName
                        ));
        if (!UnlockUrlCacheEntryStream(_hCacheStream, 0)) {
            Error = GetLastError();
        }
    }

    if (Error == ERROR_SUCCESS) {
        _CacheReadInProgress = FALSE;
        _hCacheStream = NULL;
        _dwCurrentStreamPosition = 0;
        _dwStreamRefCount = 0;
    }

    DEBUG_LEAVE(Error);
    return( Error );
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::LazyUpdate()
{
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;
    INET_ASSERT(_CacheUrlName);

    dwError = CreateAndQueueBackgroundWorkItem(_CacheUrlName);
    return dwError;
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::GetCacheStream(
    LPBYTE  lpBuffer,
    DWORD   dwLen
    )
{
    DWORD   dwError = ERROR_INVALID_FUNCTION;
    if (_CacheReadInProgress) {
        if (dwLen > sizeof(_hCacheStream)) {
            ++_dwStreamRefCount;
            *(HANDLE *)lpBuffer = _hCacheStream;
            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    return (dwError);
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::ReleaseCacheStream(
    HANDLE  hStream
    )
{
    DWORD   dwError = ERROR_INVALID_FUNCTION;
    if (_CacheReadInProgress) {
        if (_hCacheStream == hStream) {
            --_dwStreamRefCount;
            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_INVALID_PARAMETER;
        }
    }
    return (dwError);
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::BeginCacheWrite(
    DWORD   dwExpectedLength,
    LPCSTR  lpszFileExtension,
    LPCSTR  lpszFileName
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "BeginCacheWrite",
                 "%d, %q",
                 dwExpectedLength,
                 lpszFileExtension
                 ));

    DWORD Error=ERROR_NOT_SUPPORTED;

    CHAR FileName[MAX_PATH];
    CHAR* pFileName;

    // BUGBUG   uncode version needs to be fixed


    INET_ASSERT( _CacheReadInProgress == FALSE );
    INET_ASSERT( _CacheWriteInProgress == FALSE );
    FreeCacheFileName(); // may be left over from Begin/EndCacheRetrieval
                         // in case of ftp/gopher dir raw/html mismatch
    INET_ASSERT( _CacheFileHandle == INVALID_HANDLE_VALUE);

    if (!_CacheUrlName) {

        DEBUG_PRINT(CACHE,
                    ERROR,
                    ("Invalid parameter\n"
                    ));

        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);

        return (ERROR_INVALID_PARAMETER);
    }

    // lpszFileName passed in indicates that
    // we want to create a filename from scratch.
    if (!lpszFileName)
    {
        *FileName = '\0';
        pFileName = FileName;
    }
    // Otherwise, attempt to use the filename passed in.
    else
        pFileName = (CHAR*) lpszFileName;


    // Create the cache file.

    Error = UrlCacheCreateFile(
                    _CacheUrlName,
                    (CHAR*) lpszFileExtension,
                    pFileName,
                    &_CacheFileHandle,
                    IsPerUserItem());

    if (Error != ERROR_SUCCESS)
    {
        DEBUG_PRINT(CACHE,
                    ERROR,
                    ("Cache: Error %ld createurlcacheentry failed for %s\n",
                    Error,
                    _CacheUrlName
                    ));

        DEBUG_LEAVE(Error);

        return( Error); // BUGBUG refine this error
    } else IF_DEBUG(CACHE) {
        DEBUG_PRINT(CACHE, INFO, ("cache filename = %q\n", pFileName));
    }

//dprintf("caching %s (%s) in %s\n", _CacheUrlName, _OriginalUrl, FileName);

    //
    // save names.
    //

    INET_ASSERT(!_CacheFileName);
    _CacheFileName = NewString(pFileName);
    if (!_CacheFileName) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Error = ERROR_SUCCESS;

    INET_ASSERT(_CacheFileHandle != INVALID_HANDLE_VALUE);

    _CacheWriteInProgress = TRUE;
    Error =  ERROR_SUCCESS;


Cleanup:

    if( Error != ERROR_SUCCESS ) {

        if( _CacheFileHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( _CacheFileHandle );
            _CacheFileHandle = INVALID_HANDLE_VALUE;
        }

        FreeCacheFileName();

        //
        // delete file temp file
        //

        BOOL BoolError;

        BoolError = DeleteFile( pFileName );
        INET_ASSERT( BoolError == TRUE );
    }

    DEBUG_LEAVE(Error);

    return( Error );
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::WriteCache(
    LPBYTE Buffer,
    DWORD BufferLen
    )
{
    DWORD   dwError = ERROR_NOT_SUPPORTED;
    DWORD   dwSize, dwUsed, dwRemain;
    BOOL    fWriteToDisk = TRUE;

    DWORD BytesWritten;

    INET_ASSERT( _CacheWriteInProgress == TRUE );

/*
    DEBUG_PRINT( CACHE, INFO,
                ("Writecache: _virtualCacheFileSize=%d, realfilesize= %d, inputsize=%d\n",
                        _VirtualCacheFileSize, _RealCacheFileSize, BufferLen));
*/

#ifdef LAZY_WRITE

    LPBYTE   lpScratch, lpBuffer;

    if (_dwCacheFlags & INTERNET_FLAG_NEED_FILE) {

        lpScratch = GetCacheScratchBuf(&dwSize, &dwUsed);

        if (lpScratch) {

            // don't do default writes to disk
            fWriteToDisk = FALSE;

            lpBuffer = Buffer;
            dwRemain = BufferLen;

            INET_ASSERT(dwSize >= dwUsed);


            while ((dwUsed+dwRemain) >= dwSize) {

                DEBUG_PRINT( CACHE, INFO,
                            ("remaining=%d\n",
                             dwRemain));

                // Fill the buffer to the brim

                CopyToScratch(lpBuffer, (dwSize-dwUsed));

                lpBuffer += (dwSize-dwUsed);

                dwRemain -= (dwSize-dwUsed);

                // and write it out
                dwError = WriteToDisk(lpScratch, dwSize, &BytesWritten);

                if( dwError != ERROR_SUCCESS ) {

                    goto bailout;

                }

                INET_ASSERT( BytesWritten == dwSize );

                //mark the buffer as empty
                ResetScratchUseSize();

                // get it's location and new used size
                lpScratch = GetCacheScratchBuf(NULL, &dwUsed);
                INET_ASSERT(dwUsed == 0);

            }

            // if anything remain after our disk-writing frenzy
            // then keep it in the buffer

            if (dwRemain) {

                CopyToScratch(lpBuffer, dwRemain);

            }

        }
    }
#endif //LAZY_WRITE

    if (fWriteToDisk){

        // DEBUG_PRINT( CACHE, INFO, ("no lazy write, flushing to disk\n"));

        dwError = WriteToDisk(Buffer, BufferLen, &BytesWritten);

        if( dwError != ERROR_SUCCESS ) {

            goto bailout;

        }

        INET_ASSERT( BytesWritten == BufferLen );
    }


    _VirtualCacheFileSize += BufferLen;

#ifdef LAZY_WRITE
    INET_ASSERT(_VirtualCacheFileSize == (_RealCacheFileSize+_CacheScratchUsedLen));
#else
    INET_ASSERT(_VirtualCacheFileSize == (_RealCacheFileSize));
#endif

    dwError =  ERROR_SUCCESS;

bailout:

    DEBUG_PRINT( CACHE, INFO,
        ("WriteCache: _CacheFileSize=%d, inputsize=%d, dwError=%d\n",
        _VirtualCacheFileSize, BufferLen, dwError));

    return (dwError);
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::WriteToDisk(
    LPBYTE Buffer,
    DWORD BufferLen,
    LPDWORD lpdwBytesWritten
    )
{
    BOOL BoolError;

    BoolError = WriteFile(
                    _CacheFileHandle,
                    Buffer,
                    BufferLen,
                    lpdwBytesWritten,
                    NULL );
    if( !BoolError ) {
        return( GetLastError() );
    }

    _RealCacheFileSize += *lpdwBytesWritten;

    return (ERROR_SUCCESS);
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::EndCacheWrite(
    FILETIME    *lpftExpireTime,
    FILETIME    *lpftLastModifiedTime,
    FILETIME    *lpftPostCheckTime,
    DWORD       dwCacheEntryType,
    DWORD       dwHeaderLen,
    LPSTR       lpHeaderInfo,
    LPSTR       lpszFileExtension,
    BOOL        fImage
    )
{
    LPBYTE lpBuff;
    DWORD  dwBytesWritten, dwUsed;
    FILETIME ftCreate;

    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::EndCacheWrite",
                 "{%q} %#x, %#x,, %#x, %d, %d, %.32q",
                 _CacheUrlName,
                 lpftExpireTime,
                 lpftLastModifiedTime,
                 lpftPostCheckTime,
                 dwCacheEntryType,
                 dwHeaderLen,
                 lpHeaderInfo
                 ));

    DWORD Error = ERROR_NOT_SUPPORTED;

    INET_ASSERT( _CacheUrlName != NULL );
    INET_ASSERT( _CacheFileName != NULL );
    INET_ASSERT( _CacheReadInProgress == FALSE );
    INET_ASSERT( _CacheWriteInProgress == TRUE );
    INET_ASSERT( _CacheFileHandle != INVALID_HANDLE_VALUE );

    //
    // close the file.
    //

    if( _CacheFileHandle != INVALID_HANDLE_VALUE ) {

        GetFileTime( _CacheFileHandle, &ftCreate, NULL, NULL );
        
        CloseHandle( _CacheFileHandle );

        _CacheFileHandle = INVALID_HANDLE_VALUE;

    } else {

        DEBUG_PRINT(CACHE,
                    ERROR,
                    ("_CacheFileHandle = %x\n",
                    _CacheFileHandle
                    ));

    }

    if( _CacheFileHandleRead != INVALID_HANDLE_VALUE ) {
        CloseHandle( _CacheFileHandleRead );
        _CacheFileHandleRead = INVALID_HANDLE_VALUE;
    }

    //
    // Cache the file.
    //

    if( (_CacheUrlName != NULL) && (_CacheFileName != NULL) ) {

        //
        // if the cache file is successfully made, cache it, otherwise
        // mark it for deletion.
        //

        if( dwCacheEntryType == 0xffffffff ) {


            _fDeleteDataFile = TRUE;
        }

        if (!_fDeleteDataFile)
        {
            if (((GetHandleType() == TypeFtpConnectHandle) ||
                 (GetHandleType() == TypeFtpFileHandle) ||
                 (GetHandleType() == TypeFtpFileHandleHtml))
                 && IsPerUserItem())
            {
                char buff[256];
                DEBUG_PRINT(CACHE, 
                            INFO,
                            ("EndCacheWrite():FTP:PerUserItem = TRUE\n")
                            //("EndCacheWrite():PerUserItem = TRUE: <pConnect = 0x%x>.\n",pConnect)
                            );
                INET_ASSERT(vdwCurrentUserLen);

                // Store the total length to get copied to the args for AddUrl
                dwHeaderLen = sizeof(vszUserNameHeader) - 1
                                 + vdwCurrentUserLen
                                 + sizeof("\r\n");
                if (sizeof(buff) >= dwHeaderLen)
                {
                    memcpy(buff, vszUserNameHeader, sizeof(vszUserNameHeader) - 1);

                    DWORD dwSize = lstrlen(vszCurrentUser);
                    memcpy(&buff[sizeof(vszUserNameHeader) - 1],
                           vszCurrentUser,
                           dwSize);
                    dwSize += sizeof(vszUserNameHeader) - 1;
                    memcpy(&buff[dwSize], "\r\n", sizeof("\r\n"));

                    // Copy over to lpHeaderInfo which gets copied into the args for AddUrl
                    lpHeaderInfo = buff;
                    DEBUG_PRINT(CACHE, 
                                INFO,
                                ("EndCacheWrite():FTP: lpHeaderInfo = %q dwHeaderLen = %d\n",
                                lpHeaderInfo, dwHeaderLen)
                                );
                }
                else
                {
                    // if it failed, mark it as expired
/*
                    dwUserNameHeader = 0;
                    GetCurrentGmtTime(&_ftExpires);
                    *(LONGLONG *)&_ftExpires -= ONE_HOUR_DELTA;
*/              }
                                
            }
            else
            {
                DEBUG_PRINT(CACHE, 
                            INFO,
                            ("EndCacheWrite():FTP:PerUserItem = FALSE\n")
                            );

            }
        
            AddUrlArg Args;
            memset(&Args, 0, sizeof(Args));
            Args.pszUrl      = _CacheUrlName;
            Args.pszFilePath = _CacheFileName;
            Args.dwFileSize  = _RealCacheFileSize;
            Args.qwExpires   = *((LONGLONG*)lpftExpireTime);
            Args.qwLastMod   = *((LONGLONG*)lpftLastModifiedTime);
            Args.qwPostCheck = *((LONGLONG*)lpftPostCheckTime);
            Args.ftCreate    = ftCreate;
            Args.dwEntryType = dwCacheEntryType;
            Args.pbHeaders   = lpHeaderInfo;
            Args.cbHeaders   = dwHeaderLen;
            Args.pszFileExt  = lpszFileExtension;
            Args.pszRedirect = _OriginalUrl;
            Args.fImage      = fImage;
            Args.dwIdentity  = IsPerUserItem() ? GlobalIdentity : 0;
            
            Error = UrlCacheCommitFile(&Args);

            if (Error != ERROR_SUCCESS)
            {
                DEBUG_PRINT(CACHE,
                            ERROR,
                            ("CommitUrlCacheEntry(%q) failed\n",
                            _CacheUrlName
                            ));

                _fDeleteDataFile = TRUE;

                if (Error == ERROR_SHARING_VIOLATION) {

                    // we got new URL data, but the old one is in use.
                    // expire it, so any new user's will go to the net

                    ExpireUrl();

                }
            }
        }
    }

    _CacheWriteInProgress = FALSE;

    DEBUG_LEAVE(Error);

    return( Error );
}

BOOL
INTERNET_CONNECT_HANDLE_OBJECT::ExpireDependents(VOID
    )
{
    char szUrlParent[INTERNET_MAX_URL_LENGTH];
    BOOL fRet = FALSE;

    ExpireUrl();

    if (GetCanonicalizedParentUrl( _CacheUrlName,
                                       szUrlParent,
                                       sizeof(szUrlParent))){

        ExpireUrl(szUrlParent);

        fRet = TRUE;

    }
    return(fRet);

}


#ifdef LAZY_WRITE

LPBYTE
INTERNET_CONNECT_HANDLE_OBJECT::GetCacheScratchBuf(
    LPDWORD Length, LPDWORD lpdwUsed
    )
/*++

Routine Description:

    Get existing scratch buffer for use.

Arguments:

    Length : pointer to a location where the buffer length is returned.

Return Value:

    return scratch buffer pointer.

--*/
{
    //
    // no one else is using this buffer.
    //


    if(( _CacheScratchBuf != NULL )||(Length==NULL)) {


        INET_ASSERT(!((_CacheScratchBuf == NULL)&&(_CacheScratchUsedLen != 0)));

        if (Length) {

            *Length = _CacheScratchBufLen;

        }

        *lpdwUsed = _CacheScratchUsedLen;

        return( _CacheScratchBuf );
    }

    INET_ASSERT( _CacheScratchBufLen == 0 );

    //
    // create a default buffer.
    //

    *lpdwUsed = _CacheScratchUsedLen = 0;

    _CacheScratchBufLen = dwCacheWriteBufferSize;    //  default size;

    INET_ASSERT(dwCacheWriteBufferSize >= 4096);

    _CacheScratchBuf = (LPBYTE)ALLOCATE_MEMORY(LMEM_FIXED | LMEM_ZEROINIT,
                                          _CacheScratchBufLen
                                          );

    if( _CacheScratchBuf == NULL ) {

        //
        // we couldn't make one.
        //

        _CacheScratchBufLen = 0;


        *Length = 0;

        return( NULL );
    }

    *Length = _CacheScratchBufLen;

    return( _CacheScratchBuf );
}

#endif // LAZY_WRITE

BOOL
GetCanonicalizedParentUrl(
    LPSTR   lpszChildUrl,
    LPSTR   lpszParentUrlBuff,
    DWORD   dwBuffSize)
{

    char szUrlT[INTERNET_MAX_URL_LENGTH];
    LPSTR lpT;
    BOOL fRet = FALSE;
    DWORD dwT = dwBuffSize;

    if(lstrlen(lpszChildUrl) >= sizeof(szUrlT) / sizeof(szUrlT[0]))
	{
		INET_ASSERT(FALSE);
		return FALSE;
	}

	lstrcpy(szUrlT, lpszChildUrl);

    lpT = szUrlT+lstrlen(szUrlT);

    if ( lpT > szUrlT ) {

        --lpT;
        if (*lpT == '/') {
            --lpT;
        }

        for(; lpT >= szUrlT; --lpT){

            if (*lpT == '/') {

                *(lpT+1) = 0;

                if(InternetCanonicalizeUrl(szUrlT, lpszParentUrlBuff, &dwT, 0)) {

                    fRet = TRUE;

                }

                goto done;
            }

        }
    }

done:

    return (fRet);

}


VOID
INTERNET_CONNECT_HANDLE_OBJECT::AttachLastResponseInfo(
    VOID
    )

/*++

Routine Description:

    Called when we are performing an FTP URL operation & we want to display
    the welcome message contained in the last response info as part of the
    generated HTML. We need to keep hold of it in this object in case the
    app calls an API which wipes out the last response info before getting
    the HTML data

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPSTR buffer = NULL;
    DWORD bufferLength = 0;
    DWORD category;
    BOOL ok = InternetGetLastResponseInfo(&category,
                                          buffer,
                                          &bufferLength
                                          );
    if (!ok && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        buffer = (LPSTR)ResizeBuffer(NULL, bufferLength, FALSE);
        if (buffer != NULL) {
            ok = InternetGetLastResponseInfo(&category,
                                             buffer,
                                             &bufferLength
                                             );
            if (ok) {
                SetLastResponseInfo(buffer, bufferLength);
            } else {
                (void)ResizeBuffer((HLOCAL)buffer, 0, FALSE);
            }
        }
    }
}


VOID
INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer(
    IN CServerInfo * pServerInfo,
    IN BOOL fForceUpdate  /* = FALSE */
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pServerInfo -

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer",
                 "%#x{%q}",
                 pServerInfo,
                 pServerInfo ? pServerInfo->GetHostName() : ""
                 ));

    if (_OriginServer == NULL || fForceUpdate) {
        if (_OriginServer) {
            _OriginServer->Dereference();
        }
        _OriginServer = pServerInfo;
        if (pServerInfo != NULL) {
            pServerInfo->Reference();
        }
    }

    DEBUG_LEAVE(0);
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo(
    IN INTERNET_SCHEME tScheme,
    IN BOOL bDoResolution,
    IN OPTIONAL BOOL fNtlm
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name for which this object was created and an optional scheme
    type

Arguments:

    tScheme         - scheme type we want SERVER_INFO for

    bDoResolution   - TRUE if we are to resolve the host name if creating a new
                      SERVER_INFO object

    fNtlm           - TRUE if we are tunnelling for NTLM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%s (%d), %B, %B",
                 InternetMapScheme(tScheme),
                 tScheme,
                 bDoResolution,
                 fNtlm
                 ));

    //INTERNET_SCHEME proxyScheme = INTERNET_SCHEME_DEFAULT;
    //INTERNET_HANDLE_OBJECT * lpParent = (INTERNET_HANDLE_OBJECT *)GetParent();
    //
    //INET_ASSERT(lpParent != NULL);
    //
    ////
    //// this may be called from an INTERNET_CONNECT_HANDLE_OBJECT within a
    //// derived handle (HTTP_REQUEST_HANDLE_OBJECT), in which case we need to go
    //// one level higher to the INTERNET_HANDLE_OBJECT
    ////
    //
    //if (lpParent->GetHandleType() != TypeInternetHandle) {
    //    lpParent = (INTERNET_HANDLE_OBJECT *)lpParent->GetParent();
    //
    //    INET_ASSERT(lpParent != NULL);
    //    INET_ASSERT(lpParent->GetHandleType() == TypeInternetHandle);
    //
    //}

    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

//dprintf("getting server info for %q (current = %q)\n", hostName, GetHostName());
    DWORD error = ::GetServerInfo(GetHostName(),
                                  _ServiceType,
                                  bDoResolution,
                                  &_ServerInfo
                                  );

    ////
    //// if _ServerInfo is NULL then we didn't find a SERVER_INFO and couldn't
    //// create one, therefore we must be out of memory
    ////
    //
    //if (_ServerInfo != NULL) {
    //    if (proxyScheme == INTERNET_SCHEME_HTTP) {
    //        _ServerInfo->SetCernProxy();
    //    } else if (proxyScheme == INTERNET_SCHEME_FTP) {
    //        _ServerInfo->SetFTPProxy();
    //    }
    //
    //    INET_ASSERT(error == ERROR_SUCCESS);
    //
    //} else {
    //
    //    INET_ASSERT(error != ERROR_SUCCESS);
    //
    //}

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo(
    IN LPSTR lpszServerName,
    IN DWORD dwServerNameLength
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name in the parameters

Arguments:

    lpszServerName      - name of server

    dwServerNameLength  - length of lpszServerName

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%q, %d",
                 lpszServerName,
                 dwServerNameLength
                 ));

    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

    char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    int copyLength = (int)min(sizeof(hostName) - 1, dwServerNameLength);

    memcpy(hostName, lpszServerName, copyLength);
    hostName[copyLength] = '\0';

    DWORD error = ::GetServerInfo(hostName,
                                  _ServiceType,
                                  FALSE,
                                  &_ServerInfo
                                  );

    DEBUG_LEAVE(error);

    return error;
}

BOOL INTERNET_CONNECT_HANDLE_OBJECT::GetUserAndPass (BOOL fProxy, LPSTR *pszUser, LPSTR *pszPass)
{
    // How the credentials (username + password) are retrieved from handles during
    // authentication (see AuthOnRequest)
    //
    //             Connect      Request
    //  Server        4     <-     3
    //  Proxy         2     <-     1
    //
    //
    //
    // When credentials are transferred from the handle to the password cache, they
    // are invalidated on the handle for internal calls from wininet so that they
    // are not inadvertently used therafter. The handle credentials are maintained
    // for external apps which expect these values to be available via InternetQueryOption.
    // When GetUserAndPass is called, if a credential is found on the handle its validity is
    // checked for internal calls. If no credential is found or the credential is no longer
    // valid GetUserAndPass is called recursively on the parent connect handle if it exists.
    //
    // When transferring credentials from a handle to the password cache it is IMPORTANT
    // GetUserAndPass is called to invalidate the credentials. The credentials (both username
    // and password) are re-validated as a pair if either of them is reset via SetUserOrPass.

    if (fProxy)
    {
        // If proxy credentials are valid and exist invalidate and return.
        if (_HandleFlags.fProxyUserPassValid
            && _xsProxyUser.GetPtr()
            && _xsProxyPass.GetPtr())
        {
            *pszUser = _xsProxyUser.GetPtr();
            *pszPass = _xsProxyPass.GetPtr();
            _HandleFlags.fProxyUserPassValid = FALSE;
            return TRUE;
        }
    }
    else
    {
        // If server credentials are valid and exist, invalidate and return.
        if (_HandleFlags.fServerUserPassValid
            && _xsUser.GetPtr()
            && _xsPass.GetPtr())
        {
            *pszUser = _xsUser.GetPtr();
            *pszPass = _xsPass.GetPtr();
            _HandleFlags.fServerUserPassValid = FALSE;
            return TRUE;
        }
    }


    // Either credentials not found or are invalid on this handle.
    // Walk up to any existing connect handle and repeat call.
    if (GetHandleType() == TypeHttpRequestHandle)
    {
        INTERNET_CONNECT_HANDLE_OBJECT * pConnect =
            (INTERNET_CONNECT_HANDLE_OBJECT *) GetParent();

        return pConnect->GetUserAndPass (fProxy, pszUser, pszPass);
    }

    // Connect handle returns FALSE and null values if none/invalid.
    *pszUser = *pszPass = NULL;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\gopher\view.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    view.cxx

Abstract:

    Functions to manage VIEW 'object's

    Contents:
        CreateView
        (DestroyView)
        FindViewByHandle
        ReferenceView
        DereferenceView
        DereferenceViewByHandle

Author:

    Richard L Firth (rfirth) 17-Oct-1994

Environment:

    Win/32 user-mode DLL

Revision History:

    17-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// private prototypes
//

PRIVATE
VOID
DestroyView(
    IN LPVIEW_INFO ViewInfo
    );

//
// private data
//

DEBUG_DATA(LONG, NumberOfViews, 0);

//
// functions
//


LPVIEW_INFO
CreateView(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType,
    IN LPSTR Request,
    OUT LPDWORD Error,
    OUT LPBOOL Cloned
    )

/*++

Routine Description:

    Creates or clones a VIEW_INFO. There will only ever be one VIEW_INFO for a
    particular request to the same server. Other requests for the same data
    just reference the first view

Arguments:

    SessionInfo - pointer to SESSION_INFO describing gopher server

    ViewType    - type of view - ViewTypeFile or ViewTypeFind

    Request     - gopher request string

    Error       - returned error

    Cloned      - returned TRUE if we cloned the view

Return Value:

    LPVIEW_INFO
        Success - pointer to created or cloned view; check Cloned

        Failure - NULL

--*/

{
    LPVIEW_INFO viewInfo;
    DWORD error;

    DEBUG_ENTER((DBG_GOPHER,
                Pointer,
                "CreateView",
                "%x, %x, %q, %x, %x",
                SessionInfo,
                ViewType,
                Request,
                Error,
                Cloned
                ));

    //
    // in both cases, we need a new VIEW_INFO
    //

    viewInfo = NEW(VIEW_INFO);
    if (viewInfo != NULL) {
        error = AllocateHandle((LPVOID)viewInfo, &viewInfo->Handle);
        if (error == ERROR_SUCCESS) {
            viewInfo->Request = NEW_STRING(Request);
            viewInfo->RequestLength = strlen(Request);
            if (viewInfo->Request != NULL) {
                InitializeListHead(&viewInfo->List);
                viewInfo->ViewType = ViewType;
            } else {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // now search for an already existing view
    //

    if (error == ERROR_SUCCESS) {

        PLIST_ENTRY listPtr;
        PLIST_ENTRY list;
        PLIST_ENTRY listAddress;
        BOOL found;
        LPBUFFER_INFO bufferInfo;

        AcquireViewLock(SessionInfo, ViewType);

        //
        // new scheme: we now only buffer Find views: we always create a new
        // file request because file requests go straight to the user buffer
        // (keeping the connection alive until the caller finishes reading)
        //

        found = FALSE;
        if (ViewType == ViewTypeFind) {
//            list = SessionInfo->FindList.List.Flink;
            listAddress = &SessionInfo->FindList.List;
//            for (listPtr = list; listPtr != listAddress; listPtr = listPtr->Flink) {
//                if (!STRICMP(((LPVIEW_INFO)listPtr)->Request, Request)) {
//                    found = TRUE;
//                    break;
//                }
//            }
        } else {
            listAddress = &SessionInfo->FileList.List;
        }

        //
        // create a buffer info, or get a pointer to the current buffer info
        // depending on whether we located a view of the same request at the
        // same server
        //
/* N.B. found is never true because the above code is commented out. */
        if (found) {
//            bufferInfo = ((LPVIEW_INFO)listPtr)->BufferInfo;

            //
            // this is a clone. If there is a thread which is concurrently
            // requesting the data - right now - then we must wait on the
            // RequestEvent until gives us the green light. If there is no
            // RequestEvent then the data has already been received and
            // some kind soul has seen fit to close the request handle. I.e.
            // we don't have to wait
            //

//            if (bufferInfo->RequestEvent != NULL) {
//                ++bufferInfo->RequestWaiters;
//            }

            *Cloned = TRUE;
        } else {
            bufferInfo = CreateBuffer(&error);
            if (bufferInfo != NULL) {
                *Cloned = FALSE;
            }
        }

        if (error == ERROR_SUCCESS) {

            //
            // whilst holding the view lock, we add the view to the list, set
            // the view's reference count to 1, increment the session's
            // reference count, and point the view at the session
            //

            viewInfo->ReferenceCount = 1;
            viewInfo->BufferInfo = bufferInfo;
            viewInfo->SessionInfo = SessionInfo;

            //
            // also whilst holding the view lock, we increment the reference
            // count on the buffer info
            //

            ReferenceBuffer(bufferInfo);
            InsertHeadList(listAddress, &viewInfo->List);

            //
            // N.B. this will acquire the session list lock (then release it)
            //

            ReferenceSession(SessionInfo);

            VIEW_CREATED();

        }

        ReleaseViewLock(SessionInfo, ViewType);
    }

    if (error != ERROR_SUCCESS) {
        if (viewInfo != NULL) {
            viewInfo = DereferenceView(viewInfo);

            INET_ASSERT(viewInfo == NULL);

        }
    }

    DEBUG_PRINT(VIEW,
                INFO,
                ("ViewInfo %x is %scloned\n",
                viewInfo,
                (*Cloned == TRUE) ? "" : "NOT "
                ));

    DEBUG_ERROR(SESSION, error);

    *Error = error;

    DEBUG_LEAVE(viewInfo);

    return viewInfo;
}


PRIVATE
VOID
DestroyView(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Destroys a VIEW_INFO after freeing all resources that it owns. ViewInfo
    must have been removed from the relevant session view list by the time
    this function is called

Arguments:

    ViewInfo    - pointer to VIEW_INFO to destroy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "DestroyView",
                "%x",
                ViewInfo
                ));

    INET_ASSERT(ViewInfo != NULL);
    INET_ASSERT(ViewInfo->ReferenceCount == 0);

    if (ViewInfo->Handle) {

        DWORD error;

        error = FreeHandle(ViewInfo->Handle);

        INET_ASSERT(error == ERROR_SUCCESS);

    }

    if (ViewInfo->Request) {
        DEL_STRING(ViewInfo->Request);
    }

    DEL(ViewInfo);

    VIEW_DESTROYED();

    DEBUG_LEAVE(0);
}


LPVIEW_INFO
FindViewByHandle(
    IN HANDLE Handle,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Finds a VIEW_INFO given a handle. If found, the VIEW_INFO reference count
    is incremented

Arguments:

    Handle      - handle associated with VIEW_INFO

    ViewType    - identifies which list to look on

Return Value:

    LPVIEW_INFO
        Success - pointer to VIEW_INFO; Session points at SESSION_INFO

        Failure - NULL

--*/

{
    LPVIEW_INFO viewInfo;
    LPSESSION_INFO sessionInfo;
    BOOL found = FALSE;

    DEBUG_ENTER((DBG_GOPHER,
                Pointer,
                "FindViewByHandle",
                "%x, %x",
                Handle,
                ViewType
                ));

    AcquireSessionLock();

    sessionInfo = (LPSESSION_INFO)SessionList.List.Flink;
    while (sessionInfo != (LPSESSION_INFO)&SessionList.List) {

        PLIST_ENTRY endOfList;
        PLIST_ENTRY list;

        AcquireViewLock(sessionInfo, ViewType);

        INET_ASSERT((ViewType == ViewTypeFile) || (ViewType == ViewTypeFind));

        if (ViewType == ViewTypeFile) {
            list = sessionInfo->FileList.List.Flink;
            endOfList = &sessionInfo->FileList.List;
        } else {
            list = sessionInfo->FindList.List.Flink;
            endOfList = &sessionInfo->FindList.List;
        }

        for (viewInfo = (LPVIEW_INFO)list;
            viewInfo != (LPVIEW_INFO)endOfList;
            viewInfo = (LPVIEW_INFO)(viewInfo->List.Flink)) {

            if (viewInfo->Handle == Handle) {

                //
                // we found the one we were looking for. Make sure that we
                // increase the reference count before we release the lock
                //

                INET_ASSERT(viewInfo->ViewType == ViewType);

                ReferenceView(viewInfo);
                found = TRUE;
                break;  // out of for()
            }
        }

        ReleaseViewLock(sessionInfo, ViewType);

        if (found) {
            break;  // out of while()
        } else {
            sessionInfo = (LPSESSION_INFO)sessionInfo->List.Flink;
        }
    }
    if (!found) {
        viewInfo = NULL;
    }

    ReleaseSessionLock();

    DEBUG_LEAVE(viewInfo);

    return viewInfo;
}


VOID
ReferenceView(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Increments reference count on VIEW_INFO

Arguments:

    ViewInfo    - pointer to VIEW_INFO to reference

Return Value:

    None.

--*/

{
    INET_ASSERT(ViewInfo != NULL);

    InterlockedIncrement(&ViewInfo->ReferenceCount);

    DEBUG_PRINT(REFCOUNT,
                INFO,
                ("ReferenceView(): ViewInfo{%x}->ReferenceCount = %d\n",
                ViewInfo,
                ViewInfo->ReferenceCount
                ));
}


LPVIEW_INFO
DereferenceView(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Reduces the reference count of a VIEW_INFO by 1. If it goes to zero, the
    VIEW_INFO is removed from its owner's list and is deallocated

Arguments:

    ViewInfo    - pointer to VIEW_INFO to dereference

Return Value:

    LPVIEW_INFO
        NULL    - ViewInfo was deleted

        !NULL   - Reference count still >0

--*/

{
    BOOL deleteViewInfo;

    DEBUG_ENTER((DBG_GOPHER,
                Pointer,
                "DereferenceView",
                "%x",
                ViewInfo
                ));

    INET_ASSERT(ViewInfo != NULL);
    INET_ASSERT(ViewInfo->ReferenceCount >= 1);

    deleteViewInfo = FALSE;
    if (InterlockedDecrement(&ViewInfo->ReferenceCount) == 0) {

        //
        // perform any reference count manipulation within the view lock
        //

        AcquireViewLock(ViewInfo->SessionInfo, ViewInfo->ViewType);

        //
        // if the reference count is still zero, then it is safe to remove it
        // from the SESSION_INFO, and delete
        //

        if (ViewInfo->ReferenceCount == 0) {

            RemoveEntryList(&ViewInfo->List);

            INET_ASSERT(ViewInfo->BufferInfo != NULL);

            //
            // perform buffer info reference count manipulation within the view
            // lock
            //

            DereferenceBuffer(ViewInfo->BufferInfo);
            deleteViewInfo = TRUE;
        }

        ReleaseViewLock(ViewInfo->SessionInfo, ViewInfo->ViewType);
    } else {

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("DereferenceView(): ViewInfo{%x}->ReferenceCount = %d\n",
                    ViewInfo,
                    ViewInfo->ReferenceCount
                    ));

    }

    //
    // safe to delete this view info outside of the view lock
    //

    if (deleteViewInfo) {

        LPSESSION_INFO sessionInfo;

        sessionInfo = ViewInfo->SessionInfo;

        DestroyView(ViewInfo);
        ViewInfo = NULL;
        DereferenceSession(sessionInfo);
    }

    DEBUG_LEAVE(ViewInfo);

    return ViewInfo;
}


DWORD
DereferenceViewByHandle(
    IN HINTERNET Handle,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Atomically searches for the VIEW_INFO identified by Handle and if found
    dereferences it. This may cause the VIEW_INFO to be deleted

Arguments:

    Handle      - identifying VIEW_INFO to dereference

    ViewType    - identifies which list to look on

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Handle was dereferenced, but not necessarily deleted

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find Handle

--*/

{
    LPVIEW_INFO viewInfo;
    DWORD error;

    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "DereferenceViewByHandle",
                "%x",
                Handle
                ));

    //
    // we have to perform this operation whilst holding the session lock. We
    // find the VIEW_INFO then dereference it twice - once to counteract the
    // reference added by FindViewByHandle(), and once for the reference we
    // were asked to remove by the caller.
    //
    // Since we are holding the Session lock, no other thread can dereference
    // the VIEW_INFO or SESSION_INFO. The second derereference may cause the
    // SESSION_INFO to be destroyed
    //

    AcquireSessionLock();

    viewInfo = FindViewByHandle(Handle, ViewType);
    if (viewInfo != NULL) {
        DereferenceView(viewInfo);
        DereferenceView(viewInfo);
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    ReleaseSessionLock();

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\handles\autoprox.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    autoprox.cxx

Abstract:

    Contains class implementation for auto-proxy DLLs which can extent WININET's
        abilities (logic) for deciding what proxies to use.

    How auto-proxy works:
        By offloading requests to a specialized Win32 Thread which picks
        up queued up message requests for Queries, Shutdown, and Initialization


    Contents:
        InternetInitializeAutoProxyDll
        AUTO_PROXY_DLLS::CheckForTimerConfigChanges
        AUTO_PROXY_DLLS::DoNestedProxyInfoDownload
        AUTO_PROXY_DLLS::SelectAutoProxyByMime
        AUTO_PROXY_DLLS::SelectAutoProxyByFileExtension
        AUTO_PROXY_DLLS::SelectAutoProxyByDefault
        AUTO_PROXY_DLLS::ReadAutoProxyRegistrySettings
        AUTO_PROXY_DLLS::IsAutoProxyEnabled
        AUTO_PROXY_DLLS::IsAutoProxyGetProxyInfoCallNeeded
        AUTO_PROXY_DLLS::QueueAsyncAutoProxyRequest
        AUTO_PROXY_DLLS::ProcessProxyQueryForInfo
        AUTO_PROXY_DLLS::SafeThreadShutdown
        AUTO_PROXY_DLLS::DoThreadProcessing
        AUTO_PROXY_DLLS::ProcessAsyncAutoProxyRequest
        AUTO_PROXY_DLLS::SignalAsyncRequestCompleted
        AUTO_PROXY_DLLS::FreeAutoProxyInfo

        AUTO_PROXY_LIST_ENTRY::LoadEntry
        AUTO_PROXY_LIST_ENTRY::GetProxyInfoEx
        AUTO_PROXY_LIST_ENTRY::ProxyInfoInvalid
        AUTO_PROXY_LIST_ENTRY::ProxyDllInit
        AUTO_PROXY_LIST_ENTRY::ProxyDllDeInit

        (MatchFileExtensionWithUrl)
        (AutoProxyThreadFunc)

Author:

    Arthur L Bierer (arthurbi) 17-Dec-1996

Revision History:

    17-Dec-1996 arthurbi
        Created

--*/

#include <wininetp.h>
#include "autodial.h"
#include "apdetect.h"

//
// definitions
//

#define DEFAULT_SCRIPT_BUFFER_SIZE 4000 // bytes.

//
// BUGBUG [arthurbi] This structures are shared between
//  wininet.dll && jsproxy.dll, shouldn't we move them 
//  into a central file???
//

#define AUTO_PROXY_REG_FLAG_ALLOW_STRUC  0x0001

typedef struct {

    //
    // Size of struct
    //

    DWORD dwStructSize;

    //
    // Buffer to Pass
    //

    LPSTR lpszScriptBuffer;

    //
    // Size of buffer above
    //

    DWORD dwScriptBufferSize;

}  AUTO_PROXY_EXTERN_STRUC, *LPAUTO_PROXY_EXTERN_STRUC;


//
// private templates
//

PRIVATE
BOOL
MatchFileExtensionWithUrl(
    IN LPCSTR lpszFileExtensionList,
    IN LPCSTR lpszUrl
    );


//
// private vars
//


//
// functions
//

INTERNETAPI_(BOOL)
InternetInitializeAutoProxyDll(
    DWORD dwReserved
    )
/*++

Routine Description:

    Stub to make INETCPL work.  Since they expect to call this function.

Arguments:

    none.

Return Value:

    BOOL
        TRUE    - success

--*/

{

    BOOL fSuccess;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "InternetInitializeAutoProxyDll",
                ""
                ));

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
    }
    if (error == ERROR_SUCCESS) {
        GlobalProxyInfo.ClearBadProxyList();
        FixProxySettingsForCurrentConnection(TRUE);
        GlobalProxyInfo.RefreshProxySettings(TRUE);        
    }

    fSuccess = (error == ERROR_SUCCESS ) ? TRUE : FALSE;

    DEBUG_LEAVE(fSuccess);

    return fSuccess;

}


DWORD
WINAPI
AutoProxyThreadFunc(
    LPVOID lpAutoProxyObject
    )
/*++

Routine Description:

    Initialization Win32 Proc called when the auto-proxy thread is started.

Arguments:

    none.

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    return GlobalProxyInfo.DoThreadProcessing(lpAutoProxyObject);
}


//
// methods
//

DWORD
AUTO_PROXY_DLLS::CheckForTimerConfigChanges(
    IN DWORD dwMinsToPoll
    )
/*++

Routine Description:

    Exames the registry to see if a timer has been turned so
      that we poll auto-proxy every so often to check for updates

Arguments:

    none.

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD error = ERROR_SUCCESS;
    DWORD dwReloadMins = dwMinsToPoll;
    BOOL fEnableTimer = FALSE;

    //
    // Now check to determine if we have to enable the auto-proxy e
    //   this is used to force a re-download every "X" minutes.
    //

    if ( dwReloadMins != 0 )
    {
        if ( dwReloadMins >  MAX_RELOAD_DELAY  )  // too big?...
        {
            dwReloadMins = MAX_RELOAD_DELAY;
        }

        dwReloadMins *= ( 1000 * 60 ); // convert mins to miliseconds
        fEnableTimer = TRUE;
    }

    //
    // enable/disable timer for auto-proxy refresh.
    //

    ResetTimerCounter(
        fEnableTimer, // TRUE/FALSE enable/disable
        dwReloadMins  // conv-ed already to msecs
        );

    error = ERROR_SUCCESS;

    return error;
}

DWORD
AUTO_PROXY_DLLS::StartDownloadOfProxyInfo(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Does the Overall download of proxy-information from an internally accessable Web Server.
        Handles the case where we may have to redownload a secondary script also takes
        care of launching detection for proxies.

Arguments:

    fForceRefresh - TRUE if we are to attempt to refresh the auto-proxy URLs, and force a redection

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD error = ERROR_SUCCESS;
    BOOL fLocked = FALSE;
    DWORD dwcbAutoConfigProxy = 0;
    LPCSTR lpszAutoProxyUrl = NULL;
    INTERNET_PROXY_INFO_EX  ProxySettings;
    BOOL fProxySettingsAlloced = FALSE;
    BOOL fNeedRegWrite = FALSE;
    BOOL fCachedDialupDetection = FALSE;
    BOOL fNeedHostIPChk = FALSE;


    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::StartDownloadOfProxyInfo",
                "%B",
                fForceRefresh
                ));


    if ( IsOffline() ) 
    {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    LockAutoProxy();
    fLocked = TRUE;    

    error = GetProxySettings(&ProxySettings);

    if (error != ERROR_SUCCESS ) {
        goto quit;
    }

    fProxySettingsAlloced = TRUE;

    //
    // Now read from the registry, closing any stale stuff that we may still have
    //   around.  Do we still really need this?  Lets only do this for Refresh cases.
    //

    if ( fForceRefresh )
    {
        DestroyAutoProxyDll(TRUE); // unloads DLLs and frees up reg vars.
        SelectAutoProxy(NULL);

        _Error = ReadAutoProxyRegistrySettings();
        error = _Error;

        if (error != ERROR_SUCCESS ||
           !IsConfigValidForAutoProxyThread() )
        {
            SetState(AUTO_PROXY_DISABLED);
            goto quit;
        }

        if ( GetState() == AUTO_PROXY_DISABLED )
        {
            INET_ASSERT(FALSE);  // do we need this code?
            goto quit;
        }
    }

    //INET_ASSERT(GetState() == AUTO_PROXY_BLOCKED ||
    //            GetState() == AUTO_PROXY_PENDING);

    fLocked = FALSE;
    UnlockAutoProxy();

    //
    // Now begin the work, we should no longer need to touch the Proxy_DLL object
    //   settings until we grab the AutoProxy Lock again.
    //

    do
    {
        if ( IsProxyAutoDetectEnabled(&ProxySettings) )
        {
            CHAR szUrl[1024];
            BOOL fRet;
            DWORD dwDetectFlags = PROXY_AUTO_DETECT_TYPE_DNS_A;


            if ( fForceRefresh ||
                 IsProxyAutoDetectNeeded(&ProxySettings) )
            {

                //
                // Release Old Auto-config URL
                //

                if ( ProxySettings.lpszLastKnownGoodAutoConfigUrl) {
                    FREE_MEMORY(ProxySettings.lpszLastKnownGoodAutoConfigUrl);
                    ProxySettings.lpszLastKnownGoodAutoConfigUrl = NULL;
                }

                // only do dhcp on net connections
                if ( ProxySettings.lpszConnectionName == NULL ) {
                    dwDetectFlags |= PROXY_AUTO_DETECT_TYPE_DHCP;
                }

                //
                // Save out the Host IP addresses, before we start the detection,
                //  after the detection is complete, we confirm that we're still
                //  on the same set of Host IPs, in case the user switched connections.
                //

                error = GetHostAddresses(&(ProxySettings.pdwDetectedInterfaceIp),
                                         &(ProxySettings.dwDetectedInterfaceIpCount));

                if ( error != ERROR_SUCCESS) {
                    goto quit;
                }

                fNeedHostIPChk = TRUE; // because we've saved our IPs

                //
                // Do the actual Detection work
                //

                fRet = DetectAutoProxyUrl(
                         szUrl,
                         ARRAY_ELEMENTS(szUrl),
                         dwDetectFlags
                         );

                GetCurrentGmtTime(&ProxySettings.ftLastKnownDetectTime); // mark when detection was run.

                //
                // Process the Results of detection.
                //

                if ( fRet )
                {
                    ProxySettings.dwAutoDiscoveryFlags |= AUTO_PROXY_FLAG_DETECTION_RUN;

                    ProxySettings.lpszLastKnownGoodAutoConfigUrl = NewString(szUrl);
                    if ( ProxySettings.lpszLastKnownGoodAutoConfigUrl == NULL )
                    {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }

                    SetExpiredUrl(szUrl);
                    fNeedRegWrite = TRUE;
                }
                else
                {
                    //
                    // Disable auto-detection, if we failed
                    //

                    if ( ! (ProxySettings.dwAutoDiscoveryFlags & (AUTO_PROXY_FLAG_DETECTION_RUN | AUTO_PROXY_FLAG_USER_SET)) )
                    {
                        ProxySettings.dwFlags &= ~(PROXY_TYPE_AUTO_DETECT);
                    }

                    ProxySettings.dwAutoDiscoveryFlags |= AUTO_PROXY_FLAG_DETECTION_RUN;
                    fNeedRegWrite = TRUE;
                }
            } 
            else if ( ProxySettings.lpszLastKnownGoodAutoConfigUrl != NULL &&
                      ProxySettings.lpszConnectionName             != NULL )
                      
            {   
                //
                // If we're not doing any detection, and we're on a dial-up adapter,
                //   then we should remember that fact, since we may be called upon
                //   to actually force a detect, in case the cached URL was stale/bad.
                //

                INET_ASSERT(! fForceRefresh );

                fCachedDialupDetection = TRUE;
            }

            lpszAutoProxyUrl = ProxySettings.lpszLastKnownGoodAutoConfigUrl;
        }

        //
        // Falback if we are unable to detect something
        //

        if ( lpszAutoProxyUrl == NULL &&
             IsProxyAutoConfigEnabled(&ProxySettings))
        {
            lpszAutoProxyUrl = ProxySettings.lpszAutoconfigUrl;
        }

        //
        // Do the actual download of the file
        //

        if (lpszAutoProxyUrl != NULL)
        {
            error = DoNestedProxyInfoDownload(lpszAutoProxyUrl, &ProxySettings, fForceRefresh);

            if ( error != ERROR_SUCCESS )
            {

                //
                // If we're cached + on a dialup, and we fail with the URL,
                //  then perhaps the URL/net is really expired.
                //

                if ( fCachedDialupDetection &&
                     ! fForceRefresh )
                {
                    fForceRefresh = TRUE;
                    continue;
                }

                //
                // Fallback to autoconfig if we failed and we were using
                //  auto-detect
                //

                if ( IsProxyAutoConfigEnabled(&ProxySettings) &&                 
                     lpszAutoProxyUrl != ProxySettings.lpszAutoconfigUrl &&
                     ProxySettings.lpszAutoconfigUrl != NULL )
                {
                    lpszAutoProxyUrl = ProxySettings.lpszAutoconfigUrl;
                    error = DoNestedProxyInfoDownload(lpszAutoProxyUrl, &ProxySettings, fForceRefresh);
                }
            }
        }
    } while (FALSE);

    LockAutoProxy();
    fLocked = TRUE;

    if (lpszAutoProxyUrl == NULL)
    {
        SetState(AUTO_PROXY_DISABLED);
        goto quit;
    }
    else
    {
        // stamp version so we know we just ran detection
        _dwUpdatedProxySettingsVersion = 
            ProxySettings.dwCurrentSettingsVersion;
        SetState(AUTO_PROXY_ENABLED);
    }

    CheckForTimerConfigChanges(ProxySettings.dwAutoconfigReloadDelayMins);

quit:

    if ( error != ERROR_SUCCESS )
    {
        if (!fLocked)
        {
            LockAutoProxy();
            fLocked = TRUE;
        }

        SetState(AUTO_PROXY_DISABLED);
    }

    //
    // Unlock the AutoProxy 
    //

    if ( fLocked ) {
        UnlockAutoProxy();
    }

    if ( fProxySettingsAlloced )
    {
        //
        // We need to save results to registry,
        //   then stamp the version in our global we now we detected for this,
        //   and then finally clean up any allocated stuff.
        //

        SaveDetectedProxySettings(&ProxySettings, fNeedHostIPChk);        

        WipeProxySettings(&ProxySettings);
    }

    DEBUG_LEAVE(error);

    return error;
}

DWORD
AUTO_PROXY_DLLS::DoNestedProxyInfoDownload(
    IN LPCSTR lpszAutoProxy,
    IN LPINTERNET_PROXY_INFO_EX lpProxySettings,
    IN BOOL fForceRefresh
    )
/*++

Routine Description:

    Does the download of proxy-information from an internally accessable Web Server.
        Handles the case where we may have to redownload a secondary script and then
        calls on to DownloadProxyInfo to actually do the dirty work.

Arguments:

    lpszAutoProxy - URL to download

    lpProxySettings - active Proxy Settings Copy for auto-proxy thread.

    fForceRefresh - force refresh of downloaded file

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    LPCSTR lpszNestedAutoProxyUrl = NULL;
    DWORD error;
   
    _pTempProxySettings = lpProxySettings; // in case they reset proxy settings    

    if ( _fInAutoProxyThreadShutDown )
    {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;

    }

    //
    // IEAK flag, don't retry INS file unless either one of the following:
    //      1) INS URL is expired
    //      2) caching INS run is disabled
    //      3) we're not forcing a refresh
    //

    if ( !(lpProxySettings->dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_CACHE_INIT_RUN ) ||
         // !(ProxySettings.dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DETECTION_RUN ) ||
         !fForceRefresh ||         
         IsExpiredUrl(lpszAutoProxy))
    {

        //
        // Now do the actual download of the proxy info.
        //

        error =
            DownloadProxyInfo(lpszAutoProxy, fForceRefresh);

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }

    //
    // Now check to determine if we have an overriding Auto-Proxy that
    //   supersides the one we just download.  If we do, we will
    //   need to redownload auto-proxy
    //
    lpszNestedAutoProxyUrl = lpProxySettings->lpszAutoconfigSecondaryUrl;

    if ( lpszNestedAutoProxyUrl ) 
    {
        //
        // Success - now restart the download process for this special Url
        //

        error = DownloadProxyInfo(
                    lpszNestedAutoProxyUrl,
                    fForceRefresh
                    );
    }

    // fall through even in error

    error = ERROR_SUCCESS;

quit:

    INET_ASSERT(_pTempProxySettings);
    _pTempProxySettings = NULL;

    return error;
}



DWORD
AUTO_PROXY_DLLS::DownloadProxyInfo(
    IN LPCSTR lpszAutoProxy,
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Does the download of proxy-information from an internally accessable Web Server.
        The data will be checked, written to a temp file, and then an associated
        DLL will be called to handle it.

Arguments:

    lpszUrl - The URL to download.

    fForceRefresh - force file to be reloaded from the wire

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    HINTERNET hInternet = NULL;
    HINTERNET hRequest = NULL;
    HANDLE hFile = NULL;
    CHAR szTemporyFile[MAX_PATH+1];
    DWORD dwTempFileSize;

    HANDLE hLockHandle = NULL;

    BOOL fSuccess;
    DWORD error = ERROR_SUCCESS;

    CHAR szBuffer[MAX_PATH+1];
    DWORD dwBytesRead;

    BOOL fCleanupFile = FALSE;
    BOOL fLocked = FALSE;
    BOOL fBuffering = FALSE; 

    LPSTR lpszScriptBuffer = NULL;
    DWORD dwScriptBufferSize;

    DWORD dwStatusCode = ERROR_SUCCESS;
    DWORD cbSize = sizeof(DWORD);
    int nRetries = 3; // Num auth attempts

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::DownloadProxyInfo",
                "%q",
                lpszAutoProxy
                ));

    INET_ASSERT(lpszAutoProxy);

    //
    // Fire up a mini InternetOpen/InternetOpenUrl to download a
    //  config file found on some internal server.
    //

    hInternet = InternetOpen(
                    (_lpszUserAgent) ? _lpszUserAgent : gszDefaultUserAgent,
                    INTERNET_OPEN_TYPE_DIRECT,
                    NULL,
                    NULL,
                    0
                    );


    if ( !hInternet )
    {
        error = GetLastError();
        INET_ASSERT(error != ERROR_SUCCESS);
            goto quit;
    }


    do 
    {
        hRequest = InternetOpenUrl(
                            hInternet,
                            lpszAutoProxy,
                            "Accept: */*\r\n",
                            (DWORD) -1,
                            (fForceRefresh ?
                                INTERNET_FLAG_RELOAD :
                                0) |
                            INTERNET_FLAG_NEED_FILE,
                            INTERNET_NO_CALLBACK
                            );


         if ( !hRequest )
         {
            //error = ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT;
            error = GetLastError();
            if(GlobalDisplayScriptDownloadFailureUI && !GlobalIsProcessNtService)
            {
                InternetErrorDlg(
                GetDesktopWindow(),
                hRequest,
                ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT,
                FLAGS_ERROR_UI_FILTER_FOR_ERRORS,
                NULL);
            }
            goto quit;
        }

        cbSize = sizeof(dwStatusCode);
        if (HttpQueryInfo(
            hRequest,
            HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
            (LPVOID) &dwStatusCode,
            &cbSize,
            NULL
            ) && HTTP_STATUS_DENIED == dwStatusCode)
        {
            if (GlobalIsProcessNtService)
            {
                error = ERROR_INTERNET_INTERNAL_ERROR;
                goto quit;
            }

            // Check the status code and throw an InternetErrorDlg
            // if auth is needed and try again.
            if (InternetErrorDlg(
                GetDesktopWindow(), 
                hRequest,
                ERROR_INTERNET_INCORRECT_PASSWORD,
                FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
                NULL
                ) != ERROR_INTERNET_FORCE_RETRY)
            {
                nRetries = 0;
            }
            else
            {
		cbSize = sizeof(szBuffer);
		HttpQueryInfo(
			hRequest,
			HTTP_QUERY_WWW_AUTHENTICATE,
			(LPVOID) szBuffer,
			&cbSize,
			NULL
			);
		szBuffer[5]='\0';
		if (!lstrcmpi(szBuffer, "Basic"))
		{
		    HttpSendRequest(
				    hRequest, 
				    "Accept: */*\r\n",
				    (DWORD)-1,
				    NULL,
				    0);
		    cbSize = sizeof(dwStatusCode);
		    if (HttpQueryInfo(
			    hRequest,
			    HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
			    (LPVOID) &dwStatusCode,
			    &cbSize,	
			    NULL
			    ) && HTTP_STATUS_DENIED == dwStatusCode)
		    {
                        InternetCloseHandle(hRequest);
		    }
		    else
		    {
                        GlobalAutoProxyNeedsInit = FALSE;
			break;
		    }
		}
		else
                    InternetCloseHandle(hRequest);
            }
        }
        else
        {
            // Call it good
            GlobalAutoProxyNeedsInit = FALSE;
            break;
        }
    } while ( --nRetries>0);

    if(nRetries <= 0)
    {
        // Still haven't initialized.
        GlobalAutoProxyNeedsInit = TRUE;
    }

    // Reset to success
    error = ERROR_SUCCESS;

    if(HTTP_STATUS_NOT_FOUND == dwStatusCode)
    {
        error = ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT;
        if(GlobalDisplayScriptDownloadFailureUI && !GlobalIsProcessNtService)
        {
            InternetErrorDlg(
                GetDesktopWindow(),
                hRequest,
                ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT,
                FLAGS_ERROR_UI_FILTER_FOR_ERRORS,
                NULL);
        }
        goto quit;
    }


    DWORD dwIndex;
    DWORD dwTempSize;

    dwIndex = 0;
    dwTempSize = sizeof(dwScriptBufferSize);

    dwScriptBufferSize = 0;
    
    if ( ! HttpQueryInfo(hRequest, 
                       (HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER),
                       (LPVOID) &dwScriptBufferSize,
                       &dwTempSize,
                       &dwIndex) )
    {
        // failure, just defaults 
        dwScriptBufferSize = DEFAULT_SCRIPT_BUFFER_SIZE;
        fBuffering = TRUE;
    }
    else if ( dwScriptBufferSize > DEFAULT_SCRIPT_BUFFER_SIZE )
    {
        // success, but too big.
        dwScriptBufferSize = DEFAULT_SCRIPT_BUFFER_SIZE;
        fBuffering = FALSE;
    }
    else
    {
        // success, and this one is just right.
        fBuffering = TRUE; 
    }
   
    lpszScriptBuffer = (LPSTR) 
                        ALLOCATE_MEMORY(LMEM_FIXED, ((dwScriptBufferSize+1)
                            * sizeof(CHAR)));

    if ( lpszScriptBuffer == NULL ) 
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull down bytes, and write to file
    //

    DWORD dwBytes;
    dwBytesRead = 0;

    do
    {
        DWORD dwBytesLeft;
        LPSTR lpszDest;

        dwBytes = 0;
        lpszDest = lpszScriptBuffer;
        dwBytesLeft = dwScriptBufferSize;

        fSuccess = InternetReadFile(
                        hRequest,
                        lpszDest,
                        dwBytesLeft,
                        &dwBytes
                        );

        if ( ! fSuccess )
        {
            error = GetLastError();
            goto quit;
        }

        if ( _fInAutoProxyThreadShutDown )
        {
            error = ERROR_INTERNET_SHUTDOWN;
            goto quit;
        }

        if ( dwBytes > 0 )
        {
            if ( dwBytesRead > 0 ) 
            {
                fBuffering = FALSE;
            }

            dwBytesRead += dwBytes;
        }
    } while ( dwBytes != 0 );

    //
    // Figure out what kind of file we're dealing with.
    //  ONLY allow files with the correct extension or the correct MIME type.
    //

    szBuffer[0] = '\0';
    dwBytes = ARRAY_ELEMENTS(szBuffer)-1;

    fSuccess = HttpQueryInfo( hRequest,
                                 HTTP_QUERY_CONTENT_TYPE,
                                 szBuffer,
                                 &dwBytes,
                                 NULL );

    fLocked = TRUE;
    LockAutoProxy();

    if ( !(fSuccess
            && SelectAutoProxyByMime(szBuffer)) )
    {
        if ( ! SelectAutoProxyByFileExtension(lpszAutoProxy) )
        {
            if ( ! SelectAutoProxyByDefault() )
            {
                //
                // Could not find a registered handler for this data.
                //

                error = ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT;
                goto quit;
            }
        }
    }

    //
    // Now, launch the handler to tell them about the file.
    //  we downloaded it first.
    //

    AUTO_PROXY_LIST_ENTRY * papleAutoProxy;
    AUTO_PROXY_EXTERN_STRUC apeStruct;
    LPAUTO_PROXY_EXTERN_STRUC pExtraStruct;
    

    papleAutoProxy = GetSelectedAutoProxyEntry();
    pExtraStruct = NULL;

    //
    // Get a temp file from cache if we need it.
    //

    if ( fBuffering &&
         (papleAutoProxy->_dwFlags & AUTO_PROXY_REG_FLAG_ALLOW_STRUC) &&
         dwBytesRead > 0 )
    {
        // slam a \0 terminator
        INET_ASSERT(dwBytesRead <= dwScriptBufferSize);
        lpszScriptBuffer[dwBytesRead] = '\0';

        pExtraStruct = &apeStruct;
        apeStruct.dwStructSize = sizeof(AUTO_PROXY_EXTERN_STRUC);
        apeStruct.lpszScriptBuffer = lpszScriptBuffer;
        apeStruct.dwScriptBufferSize = dwBytesRead + 1;
    }
    else 
    {
        fCleanupFile = TRUE;

        //Qfe 3430: When parsing ins file, with reference to pac file, wininet needs to 
        //know the connectoid name in order to set the pac file correctly. Currently there
        //is no way for wininet to pass the connectoid name to branding dll. To workaround
        //this, we use the AUTO_PROXY_EXTERN_STRUC to pass the connectoid name in lpszScriptBuffer
        //variable. 
        if(!(papleAutoProxy->_dwFlags & AUTO_PROXY_REG_FLAG_ALLOW_STRUC))
        {
            pExtraStruct = &apeStruct;
            apeStruct.dwStructSize = sizeof(AUTO_PROXY_EXTERN_STRUC);
            apeStruct.lpszScriptBuffer = GlobalProxyInfo.GetConnectionName();
        }

        if ( ! InternetLockRequestFile(hRequest, &hLockHandle) ) 
        {
            fCleanupFile = FALSE;
        }
        
        dwTempFileSize = MAX_PATH;

        if ( ! InternetQueryOption(hRequest, INTERNET_OPTION_DATAFILE_NAME, 
                    szTemporyFile, &dwTempFileSize ) ||
               dwTempFileSize == 0 )
        {
            error = ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT;
            goto quit;
        }
    }

    //
    // The loading and unloading of DLLs is owned/allowed
    //  only by the auto-proxy thread, ONCE THIS THREAD IS RUNNING
    //  so once we're here, we can be assured its safe to
    //  make the following calls without holding the crit sec.
    //

    INET_ASSERT(fLocked);
    UnlockAutoProxy();
    fLocked = FALSE;
    fSuccess = TRUE;

    //
    // If we're not configured, or cannot match the URL
    //  with a Handler to actually run the script,
    //  then we need to error out
    //

    if ( papleAutoProxy == NULL)
    {
        error = ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT;
        goto quit;
    }

    if ( ! papleAutoProxy->_hAutoConfigDLL )
    {
        if ( _fInAutoProxyThreadShutDown )
        {
            error = ERROR_INTERNET_SHUTDOWN;
            goto quit;
        }

        error = papleAutoProxy->LoadEntry();

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }
    else if ( papleAutoProxy->_fInitializedSuccessfully &&
              papleAutoProxy->_pProxyDllInit &&
              papleAutoProxy->_pProxyDllDeInit )
    {
        //
        // If this DLL has already been loaded,
        //   then unitialize it before re-initalizeing with
        //   new data, otherwise we risk leaking some its
        //   objects
        //

        papleAutoProxy->ProxyDllDeInit(
            szBuffer,
            0
            );
        INET_ASSERT(papleAutoProxy->_fUnInited);
    }

    //
    // Make the call into the external DLL,
    //  and let it run, possibly initilization and doing a bunch
    //  of stuff.
    //


    fSuccess = papleAutoProxy->ProxyDllInit (
                            AUTO_PROXY_VERSION,
                            szTemporyFile,  // temp file we down loaded
                            szBuffer,       // mime
                            &_aphAutoProxyAPIs,
                            (DWORD_PTR) pExtraStruct
                            );

    if ( _fInAutoProxyThreadShutDown )
    {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;
    }

    if ( ! fSuccess )
    {
        error = ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT;
        goto quit;
    }


    if ( papleAutoProxy->IsGetProxyInfoEx() ||
         papleAutoProxy->IsGetProxyInfo()  )
    {
        SetState(AUTO_PROXY_ENABLED);
    }
    else
    {
        SetState(AUTO_PROXY_DISABLED);
    }

quit:

    if ( error != ERROR_SUCCESS )
    {
        if (!fLocked)
        {
            LockAutoProxy();
            fLocked = TRUE;
        }

        SetState(AUTO_PROXY_DISABLED);
    }

    if ( fLocked )
    {
        UnlockAutoProxy();
    }

    if ( fCleanupFile )
    {
        InternetUnlockRequestFile(hLockHandle);
    }

    if ( lpszScriptBuffer )
    {
        FREE_MEMORY(lpszScriptBuffer);
    }

    if ( hRequest )
    {
        InternetCloseHandle(hRequest);
    }

    if ( hInternet )
    {
        InternetCloseHandle(hInternet);
    }

    SetAbortHandle(NULL);

    DEBUG_LEAVE(error);

    return error;
}



BOOL
AUTO_PROXY_DLLS::IsAutoProxyEnabled(
    VOID
    )

/*++

Routine Description:

    Determines whether the auto-proxy thread is enabled and ready
        to accept async proxy requests.  This is needed to prevent
        senceless calls to the auto-proxy thread when the request
        could made more directly to the PROXY_INFO object.

Return Value:

    BOOL
        TRUE - the AutoProxy thread is accepting async requests

        FALSE - the AutoProxy thread is refusung async requests.

--*/

{
    BOOL fIsGetProxyCallProxyNeeded = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_DLLS::IsAutoProxyEnabled",
                ""
                ));


    LockAutoProxy();

    //
    // If we're downloading new information, OR we have a async thread ready to process
    //   autoproxy queries, then go async and do the request.  The worst case will
    //   result in the async thread being created and then returning the request
    //   unprocessed ( the FSM will resubmit it to the general proxy code )
    //

    if ( GetState() == AUTO_PROXY_ENABLED ||
         GetState() == AUTO_PROXY_BLOCKED ||
         GetState() == AUTO_PROXY_PENDING )
    {
        fIsGetProxyCallProxyNeeded = TRUE;
    }
    else
    {
        fIsGetProxyCallProxyNeeded = FALSE;
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(fIsGetProxyCallProxyNeeded);

    return fIsGetProxyCallProxyNeeded;
}


BOOL
AUTO_PROXY_DLLS::IsAutoProxyGetProxyInfoCallNeeded(
    IN AUTO_PROXY_ASYNC_MSG *pQueryForInfo
    )

/*++

Routine Description:

    Wrapper for IsAutoProxyEnabled, verifies that the message object (pQueryForInfo)
        in question is capible of going async.

Arguments:

    pQueryForInfo - Pointer to Message object that contains state information
                        used in the query.

Return Value:

    BOOL
        TRUE - the AutoProxy thread is accepting async requests

        FALSE - the AutoProxy thread is refusung async requests.

--*/

{

    INET_ASSERT(pQueryForInfo);

    //
    // The caller has explicitly banned auto-proxy calls.
    //

    if ( pQueryForInfo->IsAvoidAsyncCall() )
    {
        return FALSE;
    }

    //
    // We cannot process this request to auto-proxy unless we have an URL
    //

    if ( ! pQueryForInfo->IsUrl() )
    {
        return FALSE;
    }

    //
    // Now check to see if its really enabled.
    //

    return IsAutoProxyEnabled();

}

DWORD
AUTO_PROXY_DLLS::QueueAsyncAutoProxyRequest(
    IN OUT AUTO_PROXY_ASYNC_MSG **ppQueryForInfo
    )

/*++

Routine Description:

    Submits the *ppQueryForInfo Object on the async queue for processing
     by the async auto-proxy thread.

Arguments:

    ppQueryForInfo - Pointer to pointer to Message object that contains state information
                        used in the query.   If the object needs to be allocated on the heap
                        then the pointer will change to reflect the new object ptr.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/


{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL fLocked = FALSE;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::QueueAsyncAutoProxyRequest",
                "%x",
                ppQueryForInfo
                ));


    //
    // First allocate an object, if its not allocated,
    //  cause we can't pass local stack vars to another thread (duh..)
    //

    if ( ! (*ppQueryForInfo)->IsAlloced() )
    {
        *ppQueryForInfo = new AUTO_PROXY_ASYNC_MSG(*ppQueryForInfo);

        if ( *ppQueryForInfo == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    LockAutoProxy();  // lock object to prevent anyone messing with thread handles
    fLocked = TRUE;

    //
    // Busy wait for thread to be shutdown before restarting.
    //

    while ( _fInAutoProxyThreadShutDown )
    {
        UnlockAutoProxy();
        Sleep(100);
        LockAutoProxy();
    }

    if ( _hAutoProxyThread == NULL )
    {

        _hAutoProxyThreadEvent = CreateEvent(
                                    NULL,   // pointer to security attributes
                                    FALSE,  // flag for manual-reset event
                                    TRUE,  // flag for initial state
                                    NULL    // event-object name
                                    );


        if ( _hAutoProxyThreadEvent == NULL )
        {
            error = GetLastError();
            goto quit;
        }

        //
        // We block on this event until the thread is actually running,
        //   otherwise we may PROCESS_DETEACH while the auto-proxy
        //   thread is in this quasi-state of having been created, but not actually run.
        //

        _hAutoProxyStartEvent = CreateEvent(
                                    NULL,   // pointer to security attributes
                                    TRUE,  // flag for manual-reset event
                                    FALSE,  // flag for initial state
                                    NULL    // event-object name
                                    );


        if ( _hAutoProxyStartEvent == NULL )
        {
            error = GetLastError();
            goto quit;
        }

        ResetEvent(_hAutoProxyStartEvent);

        _hAutoProxyThread = CreateThread(
                                NULL, // pointer to thread security attributes
                                0,    // starting stack size
                                AutoProxyThreadFunc,
                                this,  // argument
                                0,     // flags
                                &_dwAutoProxyThreadId
                                );


        if ( _hAutoProxyThread == NULL )
        {
            error = GetLastError();
            CloseHandle(_hAutoProxyThreadEvent);
            CloseHandle(_hAutoProxyStartEvent);
            _hAutoProxyThreadEvent = NULL;
            _hAutoProxyStartEvent = NULL;
            goto quit;
        }

        const HANDLE aWaitHandles[2] = {_hAutoProxyStartEvent, _hAutoProxyThread};

        // wait on the thread handle too in case it terminates for some unknown reason
        error = WaitForMultipleObjects(ARRAYSIZE(aWaitHandles),
                                       aWaitHandles,
                                       FALSE,
                                       INFINITE);
        if ( error != WAIT_OBJECT_0 )
        {
            INET_ASSERT(FALSE);
            TerminateThread(_hAutoProxyThread, ERROR_SUCCESS);

            CloseHandle(_hAutoProxyThreadEvent);
            CloseHandle(_hAutoProxyStartEvent);
            CloseHandle(_hAutoProxyThread);
            _hAutoProxyStartEvent = NULL;
            _hAutoProxyThread = NULL;
            _hAutoProxyThreadEvent = NULL;
            _dwAutoProxyThreadId = NULL;

            error = ERROR_INTERNET_INTERNAL_ERROR;
            goto quit;
        }
        else
        {
            CloseHandle(_hAutoProxyStartEvent);
            _hAutoProxyStartEvent = NULL;
        }

    }

    //
    // Now Block the Thread we're on...
    //

    if ( (*ppQueryForInfo)->IsBlockUntilCompletetion() )
    {
        if ( lpThreadInfo &&
             lpThreadInfo->Fsm &&
             lpThreadInfo->IsAsyncWorkerThread &&
             !(lpThreadInfo->Fsm->IsBlocking()))
        {
            //
            // In a FSM, use FSM - thread pool handler to block this.
            //

            (*ppQueryForInfo)->SetBlockedOnFsm(TRUE);

            lpThreadInfo->Fsm->SetState(FSM_STATE_CONTINUE);
            lpThreadInfo->Fsm->SetNextState(FSM_STATE_CONTINUE);

            error = BlockWorkItem(
                lpThreadInfo->Fsm,
                (DWORD_PTR) *ppQueryForInfo,    // block the FSM on ourselves
                INFINITE                        // we block foreever
                );


            if ( error != ERROR_SUCCESS )
            {
                goto quit;
            }

            InsertAtTailOfSerializedList(&_AsyncQueueList, &(*ppQueryForInfo)->_List);
            SetEvent(_hAutoProxyThreadEvent);

            error = ERROR_IO_PENDING;
        }
        else
        {
            AcquireBlockedRequestQueue();

            InsertAtTailOfSerializedList(&_AsyncQueueList, &(*ppQueryForInfo)->_List);
            SetEvent(_hAutoProxyThreadEvent);

            UnlockAutoProxy();
            fLocked = FALSE;

            error = BlockThreadOnEvent(
                (DWORD_PTR) *ppQueryForInfo,
                INFINITE,   // we need to block forever !
                TRUE        // release BlockedRequestQueue
                );
        }
    }
    else
    {
        InsertAtTailOfSerializedList(&_AsyncQueueList, &(*ppQueryForInfo)->_List);
        SetEvent(_hAutoProxyThreadEvent);
    }

quit:

    if ( fLocked )
    {
        UnlockAutoProxy();
        fLocked = FALSE;
    }

    DEBUG_LEAVE(error);

    return error;
}

DWORD
AUTO_PROXY_DLLS::ProcessProxyQueryForInfo(
    IN OUT AUTO_PROXY_ASYNC_MSG **ppQueryForInfo
    )

/*++

Routine Description:

    Performs a query for proxy information using an external DLL's entry points to
      anwser our query.  If we are not on the correct thread, we call QueueAsyncAutoProxyRequest
      to marshall our call across to it.

Arguments:

    ppQueryForInfo - Pointer to pointer to Message object that contains state information
                        used in the query.   If the object needs to be allocated on the heap
                        then the pointer will change to reflect the new object ptr.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    AUTO_PROXY_LIST_ENTRY * papleAutoProxy;
    DWORD error = ERROR_SUCCESS;
    BOOL fUnlocked = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::ProcessProxyQueryForInfo",
                "%x",
                ppQueryForInfo
                ));


    INET_ASSERT(ppQueryForInfo);
    INET_ASSERT(*ppQueryForInfo);
    INET_ASSERT((*ppQueryForInfo)->QueryForInfoMessage() == PROXY_MSG_GET_PROXY_INFO);
    INET_ASSERT(IsOnAsyncAutoProxyThread());

    LockAutoProxy();

    //
    // this function should only ever be executed on the auto-proxy thread
    //

    if ( GetState() == AUTO_PROXY_DISABLED )
    {
        //
        // Fall back to a normal proxy query.
        //

        (*ppQueryForInfo)->SetAvoidAsyncCall(TRUE);
        goto quit;
    }

    papleAutoProxy =
            GetSelectedAutoProxyEntry();

    //
    // We should be the only ones to create or destroy
    //  auto-proxy info, therefore we release the holly
    //  lock of auto-proxy.  If I'm wrong another thread
    //  could cause us trouble ...
    //

    UnlockAutoProxy();
    fUnlocked = TRUE;

    if ( papleAutoProxy )
    {
        //
        // If GetProxyInfoEx is supported, we defer to it to handle
        //  everything.
        //

        if ( papleAutoProxy->IsGetProxyInfoEx() )
        {
            error = papleAutoProxy->GetProxyInfoEx(
                *ppQueryForInfo
                );

            goto quit;
        }
        else if ( papleAutoProxy->IsGetProxyInfo() )
        {
            error = papleAutoProxy->GetProxyInfo(
                *ppQueryForInfo
                );

            goto quit;
        }
        else
        {
            //
            // Fall back to a normal proxy query.
            //

            (*ppQueryForInfo)->SetAvoidAsyncCall(TRUE);
        }
    }
    else
    {
        //
        // Fall back to a normal proxy query.
        //

        (*ppQueryForInfo)->SetAvoidAsyncCall(TRUE);
    }


quit:

    if ( !fUnlocked )
    {
        UnlockAutoProxy();
    }

    DEBUG_LEAVE(error);

    return error;
}

VOID
AUTO_PROXY_DLLS::SafeThreadShutdown(
    BOOL fItsTheFinalShutDown
    )
/*++

Routine Description:

    Performs a shutdown of the auto-proxy thread by the auto-proxy thread itself.

Arguments:

    fItsTheFinalShutDown - TRUE, if we are shutting down at the end of a process

Return Value:

    none.

--*/
{
    DEBUG_ENTER((DBG_PROXY,
                None,
                "AUTO_PROXY_DLLS::SafeThreadShutdown",
                "%B",
                fItsTheFinalShutDown
                ));


    //
    // Attempt to Shut down thread due to no-activity OR
    //  due to process shutdown.
    //

    LockAutoProxy();

    if ( IsSerializedListEmpty(&_AsyncQueueList) ||
         fItsTheFinalShutDown )
    {
        //HANDLE hAutoProxyThreadEvent = _hAutoProxyThreadEvent;
        //HANDLE hAutoProxyThread = _hAutoProxyThread;

        //_hAutoProxyThread = NULL;
        //_hAutoProxyThreadEvent = NULL;
        _dwAutoProxyThreadId = 0;

        //CloseHandle(hAutoProxyThreadEvent);
                //CloseHandle(hAutoProxyThread);

        UnlockAutoProxy();

        if ( fItsTheFinalShutDown )
        {
            //DestroyAutoProxyMsgQueue();
            DestroyAutoProxyDll(TRUE); // unloads DLLs and frees up reg vars
        }

        DEBUG_LEAVE(0);

        ExitThread(ERROR_SUCCESS);

        INET_ASSERT(FALSE);  //we will never get here...
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(0);

}

#define NLA_ERROR_RETRY_INTERVAL    (5*60*1000)

class NLA_NET_CHANGE {
private:
    HANDLE          _hLookup;
    WSAOVERLAPPED   _ovlp;
    DWORD           _lastInitAttempt;

    BOOLEAN
    Initialize ();

    BOOLEAN
    EnumerateNetChanges ();
    
public:
    NLA_NET_CHANGE () {
        _ovlp.hEvent = NULL;
        if (GlobalPlatformWhistler &&
                _I_WSALookupServiceBeginW!=NULL) {
            _hLookup = NULL;
            _lastInitAttempt = GetTickCount ()-NLA_ERROR_RETRY_INTERVAL-1;
        }
        else {
#if DBG
            dprintf ("NLA not available: whistler-%ld, lookup:-%#x\n",
                        GlobalPlatformWhistler, _I_WSALookupServiceBeginW);
#endif
            _hLookup = INVALID_HANDLE_VALUE;
        }
    };

    ~NLA_NET_CHANGE () {
        if (_hLookup!=NULL && _hLookup!=INVALID_HANDLE_VALUE) {
#if DBG
            dprintf ("NLA - cleaning up");
#endif
            _I_WSALookupServiceEnd (_hLookup);
            CloseHandle (_ovlp.hEvent);
        }
    };

    BOOLEAN
    IsNetChanged () {
        if (_hLookup!=INVALID_HANDLE_VALUE) {
            if ((_hLookup!=NULL) || 
                    ( ((GetTickCount ()-_lastInitAttempt)
                                        >NLA_ERROR_RETRY_INTERVAL) &&
                        Initialize () ) ) {
                if (HasOverlappedIoCompleted (&_ovlp)) {
#if DBG
                    dprintf ("NLA change detected, status:%lx\n",
                            _ovlp.Internal);
#endif
                    return EnumerateNetChanges ();
                }
            }
        }
        return FALSE;
    };

    HANDLE
    GetChangeEvent () {
        return _ovlp.hEvent;
    };

};



BOOLEAN
NLA_NET_CHANGE::Initialize (
    )
/*++

Routine Description:

    Initializes Network Location Awareness lookup query.

Arguments:


Return Value:

    TRUE    - succes
    FALSE   - failure

--*/
{
    WSAQUERYSETW    qset;
    GUID    nlaServiceClassId = NLA_SERVICE_CLASS_GUID;
    DWORD   qSize;
    INT     error;

    INET_ASSERT (_ovlp.hEvent==NULL);
    INET_ASSERT (_hLookup==NULL);

    //
    // Create event for async notifications.
    //
    _ovlp.hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (_ovlp.hEvent!=NULL) {

        ZeroMemory (&qset, sizeof (qset));
        qset.dwSize = sizeof (qset);
        qset.lpServiceClassId = &nlaServiceClassId;
        qset.dwNameSpace = NS_NLA;

        if (_I_WSALookupServiceBeginW (
                        &qset,
                        LUP_RETURN_NAME|LUP_RETURN_BLOB,
                        &_hLookup)!=SOCKET_ERROR) {
            DEBUG_PRINT (PROXY, INFO, ("Nla Lookup created\n"));
#if DBG
            dprintf ("NLA Lookup created, handle:%#x\n", _hLookup);
#endif

            //
            // Just walk through the net list and setup notification.
            //
            return EnumerateNetChanges ();

        }
        else {
            error = GetLastError ();
            DEBUG_PRINT (PROXY, ERROR,
                ("NLA Lookup creation failed, err: %ld\n",
                error));
#if DBG
            dprintf ("NLA Lookup creation failed, err: %ld\n",error);
#endif
        }
        _hLookup = NULL;
        CloseHandle (_ovlp.hEvent);
        _ovlp.hEvent = NULL;
    }
    else {
        error = GetLastError ();
        DEBUG_PRINT (PROXY, ERROR,
            ("NLA notification event creation failed, err: %ld\n",
            error));
#if DBG
        dprintf ("NLA notification event creation failed, err: %ld\n",
            error);
#endif
    }

    INET_ASSERT (error!=NO_ERROR);

    //
    // Remember when we failed, so we do not retry very often.
    //
    _lastInitAttempt = GetTickCountWrap ();

    return FALSE;
}


BOOLEAN
NLA_NET_CHANGE::EnumerateNetChanges (
    )
/*++

Routine Description:

    Enumerates Network entries returned by the NLA query.
    If this is called after change notification, only
    changes since last enumeration are returned.

Arguments:
    None.

Return Value:
    TRUE    - there were any relevant changes
    FALSE   - no relevant changes.

--*/
{
    DWORD   error = NO_ERROR;

    // Stack buffer which should be sufficient for most cases.
    struct {
        WSAQUERYSETW    set;
        WCHAR           name[128];
        NLA_BLOB        blob;
    } q;
    LPWSAQUERYSETW  pqSet = &q.set;
    DWORD   qSize = sizeof (q), retSize;
    BOOLEAN changed = FALSE;

    INET_ASSERT (_hLookup!=NULL && _hLookup!=INVALID_HANDLE_VALUE);
    INET_ASSERT (_ovlp.hEvent!=NULL);
    INET_ASSERT (HasOverlappedIoCompleted (&_ovlp));

    do {// Outer loop - keep calling while we are getting notifications.

        do {// Inner loop - keep calling while enumerating through networks.
            retSize = qSize;
            error = _I_WSALookupServiceNextW (
                            _hLookup,
                            0,
                            &retSize,
                            pqSet);
            if (error!=SOCKET_ERROR) {
                INET_ASSERT (error==NO_ERROR);
                //
                // Success, see if results in this query are relevant
                //
                DEBUG_PRINT (PROXY, INFO,
                             ("NLA change for %ws-%lx\n",
                                 pqSet->lpszServiceInstanceName,
                                 pqSet->dwOutputFlags));
#if DBG
                dprintf ("NLA change for %ws-%lx\n",
                                 pqSet->lpszServiceInstanceName,
                                 pqSet->dwOutputFlags);
#endif
                if ((pqSet->lpBlob!=NULL) &&
                        (pqSet->lpBlob->pBlobData!=NULL) &&
                        (((LPNLA_BLOB)pqSet->lpBlob->pBlobData)->header.type==NLA_INTERFACE) ) {
#if DBG
                    dprintf ("    type:%ld, speed:%ld, name: %s\n",
                                ((LPNLA_BLOB)pqSet->lpBlob->pBlobData)->data.interfaceData.dwType,
                                ((LPNLA_BLOB)pqSet->lpBlob->pBlobData)->data.interfaceData.dwSpeed,
                                ((LPNLA_BLOB)pqSet->lpBlob->pBlobData)->data.interfaceData.adapterName);
#endif
                    changed = TRUE;
                }
            }
            else {
                error = GetLastError ();
                INET_ASSERT (error!=NO_ERROR);
                if (error==WSAEFAULT) {

                    INET_ASSERT (qSize<retSize);

                    //
                    // Not enough space for query results.
                    // Allocate whatever is requested.
                    // First free what we have know is necessary.
                    //
                    if (pqSet!=NULL && pqSet!=&q.set) {
                        FREE_MEMORY (pqSet);
                    }
                    pqSet = (LPWSAQUERYSETW)ALLOCATE_MEMORY (LMEM_FIXED, retSize);
                    if (pqSet!=NULL) {
                        qSize = retSize;
                        error = NO_ERROR;
                    }
                    else {
                        DEBUG_PRINT (PROXY, ERROR,
                            ("NLA - Failed to allocate %ld bytes for query\n",
                            retSize));
#if DBG
                        dprintf 
                            ("NLA - Failed to allocate %ld bytes for query\n",
                            retSize);
#endif
                        error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
        while ( error==NO_ERROR );

        if (error == WSA_E_NO_MORE) {
            WSACOMPLETION   wsacmpl;
            DWORD           count;

            //
            // This is expected error indicating that we got all that
            // was available at the moment. Set up new notification.
            //
            wsacmpl.Type = NSP_NOTIFY_EVENT;
            wsacmpl.Parameters.Event.lpOverlapped = &_ovlp;
            error = _I_WSANSPIoctl (_hLookup, SIO_NSP_NOTIFY_CHANGE, NULL, 0, NULL, 0, &count, &wsacmpl);
            if (error!=SOCKET_ERROR) {
                //
                // Something has changed, we need to enumerate again.
                //
                INET_ASSERT (error==NO_ERROR);
#if DBG
                dprintf ("NLA notification signaled immediately");
#endif
            }
            else {
                //
                // Failure, get the error and get out.
                //
                error = GetLastError ();
                INET_ASSERT (error!=NO_ERROR);
            }
        }
    }
    while (error==NO_ERROR);

    if (pqSet!=NULL && pqSet!=&q.set) {
        FREE_MEMORY (pqSet);
    }
    else {
        INET_ASSERT (qSize==sizeof (q));
    }

    if (error!=WSA_IO_PENDING) {
        DEBUG_PRINT (PROXY, ERROR,
            ("NLA - Failed to setup notification, error: %ld\n",
            error));
#if DBG
        dprintf (
            "NLA - Failed to setup notification, error: %ld\n",
            error);
#endif
        //
        // Error other then pending means that we failed.
        // Cleanup everything - query will get recreated
        // next time someone asks for changes.
        //
        CloseHandle (_ovlp.hEvent);
        _ovlp.hEvent = NULL;
        _I_WSALookupServiceEnd (_hLookup);
        _hLookup = NULL;
        //
        // Remember when we failed, so we do not retry very often.
        //
        _lastInitAttempt = GetTickCountWrap ();
    }


    return changed;
}


DWORD
AUTO_PROXY_DLLS::DoThreadProcessing(
    VOID
    )
/*++

Routine Description:

    Main function for the auto-proxy thread, maintains a generic loop
      that dispatchs events/messages sent to our thread for processing

Arguments:

    none.

Return Value:

    none.

--*/
{
    DWORD error  = ERROR_SUCCESS;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HANDLE EventArray[2];
    NLA_NET_CHANGE  nlaChange;
    BOOLEAN         needRefresh;

    EventArray[0] = _hAutoProxyThreadEvent;

    INET_ASSERT(IsOnAsyncAutoProxyThread());
    INET_ASSERT(_hAutoProxyStartEvent);

    SetEvent(_hAutoProxyStartEvent);

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // Mark ourselves as the Auto-proxy thread...
    //

    _InternetSetAutoProxy(lpThreadInfo);

    while ( TRUE )
    {
        BOOLEAN networkChanged;
        //
        // 1. Check for shut down.
        //

        if ( _fInAutoProxyThreadShutDown )
        {
            SafeThreadShutdown(GlobalDynaUnload);
        }


        //
        // 2. Check for timer causing a refresh of registry settings
        //    and network location changes,
        //      thus causing a redownload of settings
        //    Be carefull to call both functions since they have side-effects.
        //

        needRefresh = nlaChange.IsNetChanged ();
        needRefresh = ChkForAndUpdateTimerCounter() || needRefresh;
        if (needRefresh)
        {

            //
            // Finally, start a download of the new stuff.
            //

            error = StartDownloadOfProxyInfo(FALSE /*full refresh*/);
        }

        //
        // 3. Wait for new messages to come in,
        //      for shutdown we should pass right past it
        //


        error = WaitForMultipleObjects(
                    (EventArray[1]=nlaChange.GetChangeEvent())==NULL ? 1 : 2,
                    EventArray, 
                    FALSE,
                    _dwWaitTimeOut
                    );
        if (error==WAIT_OBJECT_0+1) {
            //
            // NLA change identified, skip processing, just redownload.
            //
#if DBG
            dprintf ("NLA change event signalled\n");
#endif
            continue;
        }


        //
        // 4. Check to see if we're ready to shut down the thread,
        //    due to a process termination or whatnot.
        //

        if ( _fInAutoProxyThreadShutDown )
        {
            SafeThreadShutdown(TRUE);
        }

        GlobalProxyInfo.CheckForExpiredEntries();

        //
        // 5. If we've idled let us shut down until we're needed again
        //

        //
        // BUGBUG [arthurbi] Theoredically this should work,
        //   and the thread should shutdown on idle, too risky?
        //

        //if ( error == WAIT_FAILED && GetLastError() == WAIT_TIMEOUT)
        //{
            //SafeThreadShutdown(FALSE);
        //}

        //
        // 6. Walk and process the list the messages to our thread asking for
        //     information or reinitalization
        //

        error = ProcessAsyncAutoProxyRequest();

        INET_ASSERT( (error == ERROR_INTERNET_SHUTDOWN) ? _fInAutoProxyThreadShutDown : TRUE );
    }

quit:

    return error;
}

DWORD
AUTO_PROXY_DLLS::ProcessAsyncAutoProxyRequest(
    VOID
    )

/*++

Routine Description:

    Walks the list of queued messages and processes them one by one by
      either rerunning the download/initalization or executing a query for
      proxy information

Arguments:

    none.

Return Value:

    none.

--*/

{

    DWORD error = ERROR_SUCCESS;
    BOOL fForceRefresh;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::ProcessAsyncAutoProxyRequest",
                ""
                ));

    while (!IsSerializedListEmpty(&_AsyncQueueList)) {

        //
        // If we're shuting down, then quit right away
        //

        if ( _fInAutoProxyThreadShutDown )
        {
            error = ERROR_INTERNET_SHUTDOWN;
            goto quit;

        }

        LPVOID entry = SlDequeueHead(&_AsyncQueueList);
        AUTO_PROXY_ASYNC_MSG *pQueryForInfo =
            CONTAINING_RECORD(entry, AUTO_PROXY_ASYNC_MSG, _List);


        //
        // If the request has been unblocked, then destroy
        //   the request. ( this is typically due to cancel )
        //

        if ( pQueryForInfo->IsBlockUntilCompletetion() )
        {
            DWORD dwBlockCnt;

            if ( pQueryForInfo->IsBlockedOnFsm() )
            {

                dwBlockCnt = CheckForBlockedWorkItems(
                                1,
                                (DWORD_PTR) pQueryForInfo // blocked on message
                                );

                if ( dwBlockCnt == 0 )
                {
                    delete pQueryForInfo;
                    continue;
                }
            }
        }

        switch ( pQueryForInfo->QueryForInfoMessage() )
        {
            case PROXY_MSG_INIT:

                fForceRefresh = pQueryForInfo->IsForceRefresh();

                //
                // First peak ahead to make sure we're not asked to download
                //  the same darn thing over and over again.
                //

                while (!IsSerializedListEmpty(&_AsyncQueueList))
                {

                    LPVOID entry = SlDequeueHead(&_AsyncQueueList);
                    AUTO_PROXY_ASYNC_MSG *pQueryForInfo =
                        CONTAINING_RECORD(entry, AUTO_PROXY_ASYNC_MSG, _List);

                    if ( pQueryForInfo->QueryForInfoMessage() == PROXY_MSG_INIT )
                    {
                        INET_ASSERT(!pQueryForInfo->IsBlockUntilCompletetion());
                        if ( pQueryForInfo->IsForceRefresh() ) {
                            fForceRefresh = TRUE;
                        }
                        delete pQueryForInfo;
                    }
                    else
                    {
                        InsertAtHeadOfSerializedList(&_AsyncQueueList, &pQueryForInfo->_List);
                        break;
                    }
                }

                //
                // Finally, start a download of the new stuff.
                //

                if ( error == ERROR_SUCCESS )
                {
                    error = StartDownloadOfProxyInfo(fForceRefresh);
                }

                if ( error == ERROR_INTERNET_SHUTDOWN )
                {
                    goto quit;
                }

                break;

            case PROXY_MSG_SELF_DESTRUCT:

                //
                // Destroy ourselves and AUTO_PROXY_DLLS object.
                //
                //

                SafeThreadShutdown(TRUE);

                INET_ASSERT(FALSE); // never returns...

                break;


            case PROXY_MSG_GET_PROXY_INFO:

                //
                // If we've been updated then we need refresh settings from 
                //   the net.
                //

                if ( (_dwUpdatedProxySettingsVersion != _ProxySettings.dwCurrentSettingsVersion) ) 
                {
                    error = StartDownloadOfProxyInfo(FALSE /* no full refresh*/);
                }


                //
                // The strait call into GetProxyInfo
                //

                error = ProcessProxyQueryForInfo(
                    &pQueryForInfo
                    );

                if ( error == ERROR_INTERNET_SHUTDOWN )
                {
                    goto quit;
                }

                break;


            case PROXY_MSG_SET_BAD_PROXY:
            case PROXY_MSG_DEINIT:
            case PROXY_MSG_INVALID:
            default:

                INET_ASSERT(FALSE);
                break;
        }

        //
        // Wake up the caller if they are blocking on this completeion
        //

        if ( pQueryForInfo->IsBlockUntilCompletetion() )
        {
            SignalAsyncRequestCompleted(pQueryForInfo); // the thread that gets woken up now owns the object
        }
        else
        {
            delete pQueryForInfo;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

DWORD
AUTO_PROXY_DLLS::SignalAsyncRequestCompleted(
    IN AUTO_PROXY_ASYNC_MSG *pQueryForInfo
    )
/*++

Routine Description:

    Notifies a blocked thread or FSM that we have completed its message based request and
      it now can continue.

Arguments:

    pQueryForInfo - the orginating request

Return Value:

    none.

--*/

{
    DWORD dwCntUnBlocked;

    INET_ASSERT ( pQueryForInfo );

    if ( pQueryForInfo->IsBlockedOnFsm() )
    {
        dwCntUnBlocked = UnblockWorkItems(
                            1,
                            (DWORD_PTR) pQueryForInfo, // blocked on message
                            ERROR_SUCCESS,
                            TP_NO_PRIORITY_CHANGE
                            );

        //
        // If we were unable to unblock it, then we need to free it.
        //

        if ( dwCntUnBlocked == 0 )
        {
            delete pQueryForInfo;
            pQueryForInfo = NULL;
        }

    }
    else
    {

        dwCntUnBlocked = SignalThreadOnEvent(
                            (DWORD_PTR) pQueryForInfo,  // blocked on message
                            1,                          // should only be one item thats blocked by us
                            ERROR_SUCCESS
                            );

        //if ( dwCntUnBlocked == 0 )
        //{
        //    delete pQueryForInfo;
        //    pQueryForInfo = NULL;
        //}

    }

    return ERROR_SUCCESS;
}

VOID
AUTO_PROXY_DLLS::WipeProxySettings(
    LPINTERNET_PROXY_INFO_EX lpProxySettings
    )

/*++

Routine Description:

    Frees proxy settings

Arguments:

    lpProxySettings - pointer to listing of proxy settings

Return Value:

    none.

--*/

{
    if ( lpProxySettings )
    {
        if ( lpProxySettings->lpszConnectionName ) {
            FREE_MEMORY(lpProxySettings->lpszConnectionName);
        }

        if ( lpProxySettings->lpszProxy ) {
            FREE_MEMORY(lpProxySettings->lpszProxy);
        }

        if ( lpProxySettings->lpszProxyBypass ) {
            FREE_MEMORY(lpProxySettings->lpszProxyBypass);
        }

        if ( lpProxySettings->lpszLastKnownGoodAutoConfigUrl ) {
            FREE_MEMORY(lpProxySettings->lpszLastKnownGoodAutoConfigUrl);
        }

        if (lpProxySettings->lpszAutoconfigUrl) {
            FREE_MEMORY(lpProxySettings->lpszAutoconfigUrl);
        }

        if (lpProxySettings->lpszAutoconfigSecondaryUrl) {
            FREE_MEMORY(lpProxySettings->lpszAutoconfigSecondaryUrl);
        }

        if (lpProxySettings->pdwDetectedInterfaceIp) {
            FREE_MEMORY(lpProxySettings->pdwDetectedInterfaceIp);
        }
    }
}


DWORD
AUTO_PROXY_DLLS::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess,
    IN BOOL fAllowOverwrite
    )

/*++

Routine Description:

    Write Auto-proxy Settings on the current auto-proxy object,
        this writes the settings into the object, but does not
        refresh it.

Arguments:

    lpProxySettings - List of new settings that we'd like to write

    fAllowOverwrite - Allow update of the settings in the object even if the version counter
                    hasn't changed

Return Value:

    DWORD
        ERROR_SUCCESS - if we have a valid proxy config

        other-errors - if we were not able to make the settings

--*/


{
    DWORD error = ERROR_SUCCESS;
    BOOL fGoPending = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::SetProxySettings",
                "%x %B, %B",
                lpProxySettings,
                fModifiedInProcess,
                fAllowOverwrite
                ));

    LockAutoProxy();

    if ( fAllowOverwrite ||
         lpProxySettings->dwCurrentSettingsVersion == _ProxySettings.dwCurrentSettingsVersion )
    {
        BOOL fConnectionNameChange = FALSE;

        _fModifiedInProcess = fModifiedInProcess;

        UPDATE_GLOBAL_PROXY_VERSION();

        //
        // Check to see if we're changing the connection name,
        //  if so than this means we should plan on resetting
        //  the version below, so that we can redetect the new 
        //  connection.
        //

        if ( ! IsConnectionMatch( 
                _ProxySettings.lpszConnectionName,
                lpProxySettings->lpszConnectionName))
        {
            fConnectionNameChange = TRUE;
        }

        WipeProxySettings();

        _ProxySettings = *lpProxySettings;

        if ( fModifiedInProcess ) {
            // update version, only if we don't plan to write out these settings
            _ProxySettings.dwCurrentSettingsVersion++;
        }

        //
        // minus -1 so that when we get to the auto-proxy thread,
        //  we can reload/detect or do what's needed to keep settings current
        //

        if ( _dwUpdatedProxySettingsVersion != _ProxySettings.dwCurrentSettingsVersion ||             
             _dwUpdatedProxySettingsVersion == 0 /* init state */ ||
             fConnectionNameChange /* connection switch */ ) 
        {
            _dwUpdatedProxySettingsVersion = (DWORD) (_ProxySettings.dwCurrentSettingsVersion - 1);
            fGoPending = TRUE;
        }

        //
        // we shouldn't care about these settings,
        //   but we need to copy them anyway in
        //   case we save the stuff to the registry store
        //

        _ProxySettings.lpszProxy =
            lpProxySettings->lpszProxy ?
            NewString(lpProxySettings->lpszProxy) :
            NULL;

        _ProxySettings.lpszProxyBypass =
            lpProxySettings->lpszProxyBypass ?
            NewString(lpProxySettings->lpszProxyBypass) :
            NULL;

        _ProxySettings.lpszConnectionName =
            lpProxySettings->lpszConnectionName ?
            NewString(lpProxySettings->lpszConnectionName) :
            NULL;


        //
        // Copy strings, cause we may be on another thread
        //

        _ProxySettings.lpszAutoconfigUrl =
            lpProxySettings->lpszAutoconfigUrl ?
            NewString(lpProxySettings->lpszAutoconfigUrl) :
            NULL;

        _ProxySettings.lpszAutoconfigSecondaryUrl = 
            lpProxySettings->lpszAutoconfigSecondaryUrl ?
            NewString(lpProxySettings->lpszAutoconfigSecondaryUrl) :
            NULL;

        _ProxySettings.lpszLastKnownGoodAutoConfigUrl =
            lpProxySettings->lpszLastKnownGoodAutoConfigUrl ?
            NewString(lpProxySettings->lpszLastKnownGoodAutoConfigUrl) :
            NULL;

        //
        // Copy of IP host addresses from last detection
        //

        if ( lpProxySettings->dwDetectedInterfaceIpCount > 0 &&
             lpProxySettings->pdwDetectedInterfaceIp != NULL )
        {
            _ProxySettings.pdwDetectedInterfaceIp = (LPDWORD)
                ALLOCATE_MEMORY(LMEM_FIXED, lpProxySettings->dwDetectedInterfaceIpCount
                                * sizeof(DWORD));

            if (_ProxySettings.pdwDetectedInterfaceIp == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            memcpy(_ProxySettings.pdwDetectedInterfaceIp, lpProxySettings->pdwDetectedInterfaceIp,
                        lpProxySettings->dwDetectedInterfaceIpCount * sizeof(DWORD));
        }


        if (fGoPending &&
            IsConfigValidForAutoProxyThread())            
        {
            //
            // Enable a forced refresh if the user orders it through the UI,
            //   for unknown new connections we don't block the user on auto-detect,
            //   since he didn't really order it
            //

            if ( IsStaticFallbackEnabled() ) {
                SetState(AUTO_PROXY_PENDING);
            } else {
                SetState(AUTO_PROXY_BLOCKED);
            }
        }
    }

quit:

    UnlockAutoProxy();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
AUTO_PROXY_DLLS::GetProxySettings(
    OUT LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion
    )

/*++

Routine Description:

    Reads Auto-proxy Settings off the current auto-proxy object,
        this allocates individual fields as needed to store the result

Arguments:

    lpProxySettings - Returns the result of the auto-proxy settings

Return Value:

    DWORD
        ERROR_SUCCESS - if we have a valid proxy config

        other-errors - if we were not able to make the settings

--*/

{
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::GetProxySettings",
                "%x %B",
                lpProxySettings
                ));

    LockAutoProxy();

    if ( fCheckVersion &&
         lpProxySettings->dwCurrentSettingsVersion == _ProxySettings.dwCurrentSettingsVersion )
    {
        goto quit; // no change
    }


    *lpProxySettings = _ProxySettings;

    //
    // Copy strings, cause we may be on another thread
    //

    lpProxySettings->lpszProxy =
        _ProxySettings.lpszProxy ?
        NewString(_ProxySettings.lpszProxy) :
        NULL;

    lpProxySettings->lpszProxyBypass =
        _ProxySettings.lpszProxyBypass ?
        NewString(_ProxySettings.lpszProxyBypass) :
        NULL;

    lpProxySettings->lpszConnectionName =
        _ProxySettings.lpszConnectionName ?
        NewString(_ProxySettings.lpszConnectionName) :
        NULL;

    lpProxySettings->lpszAutoconfigUrl =
        _ProxySettings.lpszAutoconfigUrl ?
        NewString(_ProxySettings.lpszAutoconfigUrl) :
        NULL;

    lpProxySettings->lpszAutoconfigSecondaryUrl = 
        _ProxySettings.lpszAutoconfigSecondaryUrl ?
        NewString(_ProxySettings.lpszAutoconfigSecondaryUrl) :
        NULL;

    lpProxySettings->lpszLastKnownGoodAutoConfigUrl =
        _ProxySettings.lpszLastKnownGoodAutoConfigUrl ?
        NewString(_ProxySettings.lpszLastKnownGoodAutoConfigUrl) :
        NULL;

    //
    // Copy of IP host addresses from last detection
    //

    if ( _ProxySettings.dwDetectedInterfaceIpCount > 0 &&
         _ProxySettings.pdwDetectedInterfaceIp != NULL )
    {
        lpProxySettings->pdwDetectedInterfaceIp = (LPDWORD)
            ALLOCATE_MEMORY(LMEM_FIXED, _ProxySettings.dwDetectedInterfaceIpCount
                            * sizeof(DWORD));

        if (lpProxySettings->pdwDetectedInterfaceIp == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        memcpy(lpProxySettings->pdwDetectedInterfaceIp, _ProxySettings.pdwDetectedInterfaceIp,
                    _ProxySettings.dwDetectedInterfaceIpCount * sizeof(DWORD));
    }

quit:

    UnlockAutoProxy();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
AUTO_PROXY_DLLS::RefreshProxySettings(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Syncronizes the Auto-Proxy engine with the state of the various settings,
      and updates the various state keepers of the results.

        - If there is no proxy settings, or auto-proxy is not needed or not detected,
          we disable the auto-proxy system.

        - If we have auto-proxy information or need to detect for some, then we fire up
            the auto-proxy thread and send it a message to initalize itself.

Arguments:

    none.

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/


{
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::RefreshProxySettings",
                "%B",
                fForceRefresh
                ));

    LockAutoProxy();

    if (! IsOnAsyncAutoProxyThread() )
    {
        AUTO_PROXY_ASYNC_MSG *pQueryForInfo;

        error = _Error;
        if ( error != ERROR_SUCCESS)
        {            
            goto quit; // obj is not initalized properly
        }

        if (!IsConfigValidForAutoProxyThread() )
        {
            goto quit; // disable & bail, we're not setup for this
        }

        pQueryForInfo = new AUTO_PROXY_ASYNC_MSG(PROXY_MSG_INIT);

        if (pQueryForInfo == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        //
        // Enabled a forced refresh if the user orders it through the UI,
        //   for unknown new connections we don't block the user on auto-detect,
        //   since he didn't really order it
        //

        pQueryForInfo->SetForceRefresh(fForceRefresh);

        if ( !fForceRefresh && IsStaticFallbackEnabled() ) {
            SetState(AUTO_PROXY_PENDING);
        } else {
            SetState(AUTO_PROXY_BLOCKED);
        }

        error = QueueAsyncAutoProxyRequest(
                &pQueryForInfo  // don't worry, this request won't block us.
                );
    }

quit:

    if ( error != ERROR_SUCCESS  && 
         error != ERROR_IO_PENDING )
    {
        SetState(AUTO_PROXY_DISABLED); // disable in case something critical happens
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(error);

    return error;
}

DWORD
AUTO_PROXY_DLLS::StartBackroundDetectionIfNeeded(
    VOID
    )
{
    DWORD error = ERROR_SUCCESS;

    LockAutoProxy();
    if ( _hAutoProxyThread == NULL ) {
        error = RefreshProxySettings(FALSE);
    }
    UnlockAutoProxy();

    return error;
}

DWORD
AUTO_PROXY_DLLS::QueryProxySettings(
    IN OUT AUTO_PROXY_ASYNC_MSG **ppQueryForInfo
    )

/*++

Routine Description:

    Performs a query for proxy information using auto-proxy to anwser our query.

    Assumes this is not called from auto-proxy thread/

Arguments:

    ppQueryForInfo - Pointer to pointer to Message object that contains state information
                        used in the query.   If the object needs to be allocated on the heap
                        then the pointer will change to reflect the new object ptr.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    AUTO_PROXY_LIST_ENTRY * papleAutoProxy;
    DWORD error = ERROR_SUCCESS;
    BOOL fUnlocked = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::QueryProxySettings",
                "%x",
                ppQueryForInfo
                ));


    INET_ASSERT(ppQueryForInfo);
    INET_ASSERT(*ppQueryForInfo);
    INET_ASSERT((*ppQueryForInfo)->QueryForInfoMessage() == PROXY_MSG_GET_PROXY_INFO);
    //INET_ASSERT(!IsOnAsyncAutoProxyThread());

    LockAutoProxy();

    //
    // ALWAYS force this function to exec it auto-proxy calls on the
    //   async auto-proxy thread.
    //

    if ( IsAutoProxy() &&
        !IsOnAsyncAutoProxyThread() &&
         IsAutoProxyGetProxyInfoCallNeeded(*ppQueryForInfo))
    {
        if ( GetState() == AUTO_PROXY_PENDING )
        {

            //
            // If we're doing a pending detection, then
            //  fallback to standby settings, and if we fail
            //  with standby settings, we should get re-called to here
            //  and if we're then still detecting, then
            //  we'll block on the detection result
            //

            if ( ! (*ppQueryForInfo)->IsBackroundDetectionPending() )
            {
                error = StartBackroundDetectionIfNeeded();
                if (error != ERROR_SUCCESS ) {
                    goto quit;
                }
                (*ppQueryForInfo)->SetBackroundDetectionPending(TRUE);
                if ( ! (*ppQueryForInfo)->IsAlloced() )
                {
                    *ppQueryForInfo = new AUTO_PROXY_ASYNC_MSG(*ppQueryForInfo);

                    if ( *ppQueryForInfo == NULL ) {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                goto quit;
            }
        }
        else if (!(_ProxySettings.dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DONT_CACHE_PROXY_RESULT) &&
                   GlobalAutoProxyCacheEnable)
        {
            (*ppQueryForInfo)->SetCanCacheResult(TRUE);
        }

        //
        // If we need to show indication during detection,
        //   then do so now before we block
        //

        if ( (*ppQueryForInfo)->IsShowIndication() &&
                (GetState() == AUTO_PROXY_PENDING ||
                 GetState() == AUTO_PROXY_BLOCKED))
        {
            UnlockAutoProxy();
            fUnlocked = TRUE;

            InternetIndicateStatus(INTERNET_STATUS_DETECTING_PROXY, NULL, 0);
        }
        else
        {
            UnlockAutoProxy();
            fUnlocked = TRUE;
        }

        // always disable unless we're ready to renter on a failure
        (*ppQueryForInfo)->SetBackroundDetectionPending(FALSE);

        error = QueueAsyncAutoProxyRequest(ppQueryForInfo);
        goto quit;
    }

    // always disabled it unless we're ready to reenter on a failure
    (*ppQueryForInfo)->SetBackroundDetectionPending(FALSE);

quit:

    if ( !fUnlocked )
    {
        UnlockAutoProxy();
    }

    DEBUG_LEAVE(error);

    return error;
}

BOOL
AUTO_PROXY_DLLS::IsConfigValidForAutoProxyThread(
    VOID
    )
/*++

Routine Description:

    Decide if we need the auto-thread to either download auto-proxy ot
      go off and detect for auto-proxy on the network

Arguments:

    none.

Return Value:

    BOOL
        TRUE - if we have a valid proxy config

        FALSE - if we not valid

--*/

{
    LPINTERNET_PROXY_INFO_EX lpProxySettings = &_ProxySettings;

    if ( (lpProxySettings->dwFlags & PROXY_TYPE_AUTO_PROXY_URL) &&
          lpProxySettings->lpszAutoconfigUrl != NULL &&
         *lpProxySettings->lpszAutoconfigUrl != '\0' )
    {
        return TRUE; // old behavior for auto-proxy URL config
    }

    if ( IsProxyAutoDetectEnabled(lpProxySettings))
    {
        return TRUE;
    }

    return FALSE; // do nothing
}

BOOL
AUTO_PROXY_DLLS::IsStaticFallbackEnabled(
    VOID
    )
/*++

Routine Description:

    Decide if we need to block on the auto-proxy information,
     or if we can fallback to static settings when auto-proxy is initalizing/detecting.

Arguments:

    none.

Return Value:

    BOOL
        TRUE - if we keep going with static settings

        FALSE - we'll need to block requests until auto-proxy is intialized

--*/

{

    if ( (_ProxySettings.dwFlags & PROXY_TYPE_AUTO_PROXY_URL) &&
          _ProxySettings.lpszAutoconfigUrl != NULL &&
         *_ProxySettings.lpszAutoconfigUrl != '\0' )
    {
        return FALSE; // block, don't bypass, this is old behavior for Auto-proxy URLs
    }

    if (  IsProxyAutoDetectEnabled() )

    {
        if ( !(_ProxySettings.dwAutoDiscoveryFlags & (AUTO_PROXY_FLAG_DETECTION_RUN | AUTO_PROXY_FLAG_USER_SET)) ) {
            return TRUE; // detection SHOULD NOT BLOCK THE FIRST TIME, in case it doesn't work
        }

        if ( _ProxySettings.lpszConnectionName != NULL )
        {
            if ( _ProxySettings.lpszLastKnownGoodAutoConfigUrl == NULL ) 
            {
                return TRUE; // detection SHOULD NOT BE DEPENDED upon with Dialup, unless it has something
            }

            if ( _ProxySettings.dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DETECTION_SUSPECT)
            {
                return TRUE; // detection should not block when we're in a hosed state.
            }
        }
    }



    return FALSE; // block
}

VOID
AUTO_PROXY_DLLS::SetExpiredUrl(
    LPCSTR lpszUrl
    )
/*++

Routine Description:

    Sets default expiry time on the if none is specified on the cached URL. 

Arguments:

    lpszUrl -

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/
{
    CACHE_ENTRY_INFOEX Cei;
    DWORD dwCeiSize = sizeof(INTERNET_CACHE_ENTRY_INFOA);
    BOOL fRet;

    fRet = GetUrlCacheEntryInfoExA(
            lpszUrl,
            (INTERNET_CACHE_ENTRY_INFOA *) &Cei,
            &dwCeiSize,
            NULL,
            NULL,
            NULL,
            INTERNET_CACHE_FLAG_GET_STRUCT_ONLY
            );


    if ( fRet && 
         (FT2LL(Cei.ExpireTime) == LONGLONG_ZERO))
    {
        //
        // Set default expiry as: current time + some default expiry
        //

        GetCurrentGmtTime(&Cei.ExpireTime);

        *(LONGLONG *) &(Cei.ExpireTime) += (12 * (24 * ONE_HOUR_DELTA));

        //
        // Re-Save Cache entry with updated default expiry time for PAC/INS file.
        //

        SetUrlCacheEntryInfoA(
                lpszUrl,
                (INTERNET_CACHE_ENTRY_INFOA *) &Cei,
                CACHE_ENTRY_EXPTIME_FC
                );

    }

}

BOOL
AUTO_PROXY_DLLS::IsExpiredUrl(
    LPCSTR lpszUrl
    )
/*++

Routine Description:

    Is Url Expired?  If it isn't don't force a reload/update of data

Arguments:

    lpszUrl -

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/
{
    CACHE_ENTRY_INFOEX Cei;
    DWORD dwCeiSize = sizeof(INTERNET_CACHE_ENTRY_INFOA);
    BOOL fRet;

    fRet = GetUrlCacheEntryInfoExA(
            lpszUrl,
            (INTERNET_CACHE_ENTRY_INFOA *) &Cei,
            &dwCeiSize,
            NULL,
            NULL,
            NULL,
            INTERNET_CACHE_FLAG_GET_STRUCT_ONLY 
            );

    if (!fRet) {
        return TRUE; // expired, not in the cache
    }

    if ( IsExpired(&Cei, 0, &fRet) )
    {
        return TRUE; // expired, like really it is
    }

    return FALSE; // not expired
}


BOOL
AUTO_PROXY_DLLS::IsProxyAutoDetectNeeded(
    LPINTERNET_PROXY_INFO_EX lpProxySettings
    )

/*++

Routine Description:

  Detects whether we need to actually run a detection on the network,
    or whether we can resuse current results from previous runs

Arguments:

    lpProxySettings - structure to fill

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD addressCount;
    LPDWORD * addressList;
    LPHOSTENT lpHostent;
    BOOL fSuspectBadDetect = FALSE;

    INET_ASSERT(IsProxyAutoDetectEnabled(lpProxySettings));

    // we haven't detected before on this connection, so we need to do it.
    if ( !(lpProxySettings->dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DETECTION_RUN) ) {
        return TRUE; // detect needed
    }

    // if we're flagged to ALWAYS force detection, then do this
    if (lpProxySettings->dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_ALWAYS_DETECT) {
        return TRUE; // detect needed
    }

    //
    // Check for an expired detected Url, detect it its expired
    //  Since this is RAS we can't rely on the host IP staying 
    //  the same everytime.
    //

    if (  lpProxySettings->lpszLastKnownGoodAutoConfigUrl && 
          lpProxySettings->lpszConnectionName &&          
        ! IsExpiredUrl(lpProxySettings->lpszLastKnownGoodAutoConfigUrl))
    {
        // if we're suspecting bad settings, make sure to redirect.
        if ( ! (lpProxySettings->dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DETECTION_SUSPECT) ) {
            return FALSE; 
        }

        //otherwise, we'll be careful
        fSuspectBadDetect = TRUE;
    }

    //
    // Check for IP addresses that no longer match, indicating a network change
    //

    __try
    {
        lpHostent = _I_gethostbyname(NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        g_fGetHostByNameNULLFails = TRUE;
        lpHostent = NULL;
    }
    ENDEXCEPT

    if (lpHostent &&
        lpProxySettings->pdwDetectedInterfaceIp == NULL)
    {
        return TRUE; // detect needed, no current IPs saved from last run
    }

    if ( lpHostent != NULL &&
         lpProxySettings->pdwDetectedInterfaceIp != NULL)
    {

        for ( addressCount = 0;
              lpHostent->h_addr_list[addressCount] != NULL;
              addressCount++ );  // gather count

        if ( addressCount != lpProxySettings->dwDetectedInterfaceIpCount ) {
            return TRUE; // detect needed, the IP count is different
        }

        if ( fSuspectBadDetect) {
            return FALSE; // detect NOT needed, because the IP addresses may change from dialup/to dialup
        }

        for (DWORD i = 0; i < addressCount; i++)
        {
            //dwAddress[iCount] = *((LPDWORD)(ph->h_addr_list[iCount]));

            if ( *((LPDWORD)(lpHostent->h_addr_list[i])) != lpProxySettings->pdwDetectedInterfaceIp[i] ) {
                return TRUE; // detect needed, mismatched values
            }
        }
    }


    return FALSE; // default, do not need to redetect
}


DWORD
AUTO_PROXY_DLLS::GetHostAddresses(
    DWORD ** ppdwDetectedInterfaceIp,
    DWORD *  pdwDetectedInterfaceIpCount
    )
/*++

Routine Description:

  Copies out the current host information into an
    a array/ProxyInfoStruct for later comparision.

Arguments:

    lpProxySettings - structure to fill

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD addressCount;
    LPDWORD * addressList;
    LPHOSTENT lpHostent;
    DWORD error = ERROR_SUCCESS;

    *pdwDetectedInterfaceIpCount = 0;

    if ( *ppdwDetectedInterfaceIp )
    {
        FREE_MEMORY(*ppdwDetectedInterfaceIp);
        *ppdwDetectedInterfaceIp = NULL;
    }

    //
    // Gather IP addresses and start copying them over
    //

    __try
    {
        lpHostent = _I_gethostbyname(NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        g_fGetHostByNameNULLFails = TRUE;
        lpHostent = NULL;
    }
    ENDEXCEPT

    if (lpHostent == NULL ) {
        goto quit;
    }

    for ( addressCount = 0;
          lpHostent->h_addr_list[addressCount] != NULL;
          addressCount++ );  // gather count

    *ppdwDetectedInterfaceIp = (LPDWORD)
        ALLOCATE_MEMORY(LMEM_FIXED, addressCount
                        * sizeof(DWORD));

    if ( *ppdwDetectedInterfaceIp == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    
    if ( *ppdwDetectedInterfaceIp != NULL)
    {
        *pdwDetectedInterfaceIpCount = addressCount;

        for (DWORD i = 0; i < addressCount; i++)
        {
            (*ppdwDetectedInterfaceIp)[i] =
                *((LPDWORD)(lpHostent->h_addr_list[i]));
        }
    }

quit:
    return error;
}


VOID
AUTO_PROXY_DLLS::FreeAutoProxyInfo(
    VOID
    )

/*++

Routine Description:

    Attempts to shutdown the auto-proxy thread (from outside of it), by first signalling
      it with an event and boolean, and then if that fails, forcibly forcing a shutdown
      with TerminateThread.

Arguments:

    none.

Return Value:

    none.

--*/

{
    DWORD dwError;

    LockAutoProxy();

    if ( _hAutoProxyThread != NULL &&
         ! IsOnAsyncAutoProxyThread() )
    {
        HANDLE hAutoProxyThread;
        BOOL fAlreadyInShutDown;

        fAlreadyInShutDown =
            InterlockedExchange((LPLONG)&_fInAutoProxyThreadShutDown, TRUE);

        INET_ASSERT ( ! fAlreadyInShutDown );

        SetEvent(_hAutoProxyThreadEvent);

        if ( _hInternetAbortHandle != NULL )
        {
            InternetCloseHandle(_hInternetAbortHandle);
        }

        hAutoProxyThread = _hAutoProxyThread;

        UnlockAutoProxy();

        //
        // Wait for shutdown of auto-proxy thread.
        //

        if ( hAutoProxyThread )
        {
            dwError = WaitForSingleObject(hAutoProxyThread,
                GlobalIsProcessNtService? INFINITE : 60000);

            if ( dwError != WAIT_OBJECT_0 )
            {
                INET_ASSERT(FALSE);
                // Whistler bug #124628: delete the autoproxy critical section
                // before terminating the autoproxy thread in case the thread
                // is holding the CS.
                SuspendThread(hAutoProxyThread);
                DeleteCriticalSection(&_CritSec);
                
                // reinitialize cs since it will be deleted in the destructor
                memset((LPVOID) &_CritSec, 0, sizeof(CRITICAL_SECTION));
                InitializeCriticalSection(&_CritSec);

                TerminateThread(hAutoProxyThread,ERROR_SUCCESS);

                _hAutoProxyThreadEvent = NULL;
                _hAutoProxyThread = NULL;

                InterlockedExchange((LPLONG)&_fInAutoProxyThreadShutDown, FALSE);
                return;
            }
        }

        LockAutoProxy();

        CloseHandle(_hAutoProxyThread);
        CloseHandle(_hAutoProxyThreadEvent);

        _hAutoProxyThreadEvent = NULL;
        _hAutoProxyThread = NULL;

        InterlockedExchange((LPLONG)&_fInAutoProxyThreadShutDown, FALSE);

        UnlockAutoProxy();
    }
    else
    {
        UnlockAutoProxy();
    }
}

BOOL
AUTO_PROXY_LIST_ENTRY::ProxyInfoInvalid(
    IN LPSTR lpszMime,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszProxyHostName,
    IN DWORD dwProxyHostNameLength
    )
{
    BOOL success = TRUE; // don't care if it doesn't succeed

    if ( ! _hAutoConfigDLL )
    {
        if ( LoadEntry() != ERROR_SUCCESS )
            return FALSE;
    }

    if ( ! _fInitializedSuccessfully )
    {
        return FALSE;
    }

    if ( _pProxyInfoInvalid )
    {

        INET_ASSERT(_hAutoConfigDLL);
        INET_ASSERT(!IsBadCodePtr((FARPROC)_pProxyInfoInvalid));

        success = (_pProxyInfoInvalid) ( lpszMime,
                                          lpszUrl,
                                          dwUrlLength,
                                          lpszProxyHostName,
                                          dwProxyHostNameLength
                                          );
    }

    return success;
}



BOOL
AUTO_PROXY_LIST_ENTRY::ProxyDllDeInit(
    IN LPSTR lpszMime,
    IN DWORD dwReserved
    )
{
    BOOL success = TRUE; // don't care if it doesn't succeed

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_LIST_ENTRY::ProxyDllDeInit",
                "%s, %u",
                lpszMime,
                dwReserved
                ));


    INET_ASSERT(_hAutoConfigDLL);

    if ( !_hAutoConfigDLL  )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    if ( ! _fInitializedSuccessfully )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    if ( _pProxyDllDeInit )
    {

        INET_ASSERT(_hAutoConfigDLL);
        INET_ASSERT(!IsBadCodePtr((FARPROC)_pProxyDllDeInit));
#ifdef INET_DEBUG
        INET_ASSERT(!_fUnInited);

        _fUnInited = TRUE;
#endif

        success = (_pProxyDllDeInit) ( lpszMime,
                                       dwReserved
                                       );
    }

    DEBUG_LEAVE(success);
    return success;
}



DWORD
AUTO_PROXY_LIST_ENTRY::GetProxyInfoEx(
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )
{
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_LIST_ENTRY::GetProxyInfoEx",
                "%x [%s, %s, %u, %s, %d, %x, %x]",
                pQueryForProxyInfo,
                InternetMapScheme(pQueryForProxyInfo->_tUrlProtocol),
                pQueryForProxyInfo->_lpszUrl,
                pQueryForProxyInfo->_dwUrlLength,
                pQueryForProxyInfo->_lpszUrlHostName,
                pQueryForProxyInfo->_dwUrlHostNameLength,
                pQueryForProxyInfo->_lpszProxyHostName,
                &pQueryForProxyInfo->_dwProxyHostNameLength
                ));

    //if ( ! _hAutoConfigDLL )
    //{
    //    if ( LoadEntry() != ERROR_SUCCESS )
    //    {
    //        DEBUG_LEAVE(FALSE);
    //        return FALSE;
    //    }
    //}

    if ( ! _fInitializedSuccessfully )
    {
        DEBUG_LEAVE(FALSE);
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    INET_ASSERT(_hAutoConfigDLL);
    INET_ASSERT(_pGetProxyInfoEx);
    INET_ASSERT(!IsBadCodePtr((FARPROC)_pGetProxyInfoEx));

    success = (_pGetProxyInfoEx) ( pQueryForProxyInfo->_tUrlProtocol,
                                    pQueryForProxyInfo->_lpszUrl,
                                    pQueryForProxyInfo->_dwUrlLength,
                                    pQueryForProxyInfo->_lpszUrlHostName,
                                    pQueryForProxyInfo->_dwUrlHostNameLength,
                                    pQueryForProxyInfo->_nUrlPort,
                                    &(pQueryForProxyInfo->_tProxyScheme),
                                    &(pQueryForProxyInfo->_lpszProxyHostName),
                                    &(pQueryForProxyInfo->_dwProxyHostNameLength),
                                    &(pQueryForProxyInfo->_nProxyHostPort)
                                    );

quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) success;

    DEBUG_LEAVE(error);
    return error;

}



DWORD
AUTO_PROXY_LIST_ENTRY::GetProxyInfo(
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )
{
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;
    LPSTR lpszAutoProxyReturnInfo;
    DWORD dwAutoProxyReturnInfoSize;

    INET_ASSERT(pQueryForProxyInfo);

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_LIST_ENTRY::GetProxyInfo",
                "%x [%s, %u, %s, %d, %x, %x]",
                pQueryForProxyInfo,
                pQueryForProxyInfo->_lpszUrl,
                pQueryForProxyInfo->_dwUrlLength,
                pQueryForProxyInfo->_lpszUrlHostName,
                pQueryForProxyInfo->_dwUrlHostNameLength,
                pQueryForProxyInfo->_lpszProxyHostName,
                &pQueryForProxyInfo->_dwProxyHostNameLength
                ));

    //if ( ! _hAutoConfigDLL )
    //{
    //    if ( LoadEntry() != ERROR_SUCCESS )
    //    {
    //        DEBUG_LEAVE(FALSE);
    //        return FALSE;
    //    }
    //}

    if ( ! _fInitializedSuccessfully )
    {
        DEBUG_LEAVE(FALSE);
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    INET_ASSERT ( _pGetProxyInfo );
    INET_ASSERT(_hAutoConfigDLL);
    INET_ASSERT(!IsBadCodePtr((FARPROC)_pGetProxyInfo));

    success = (_pGetProxyInfo) (    pQueryForProxyInfo->_lpszUrl,
                                    pQueryForProxyInfo->_dwUrlLength,
                                    pQueryForProxyInfo->_lpszUrlHostName,
                                    pQueryForProxyInfo->_dwUrlHostNameLength,
                                    &lpszAutoProxyReturnInfo,
                                    &dwAutoProxyReturnInfoSize
                                    );


    if ( success )
    {
        if ( pQueryForProxyInfo->_tUrlProtocol == INTERNET_SCHEME_HTTPS )
        {
            pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_HTTPS;
        }
        else
        {
            pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_HTTP;
        }

        INET_ASSERT(pQueryForProxyInfo->_pProxyState == NULL);

        pQueryForProxyInfo->_pProxyState = new PROXY_STATE(lpszAutoProxyReturnInfo,
                                                          dwAutoProxyReturnInfoSize,
                                                          TRUE,  // parse netscape-style proxy list
                                                          pQueryForProxyInfo->_tProxyScheme,
                                                          pQueryForProxyInfo->_nProxyHostPort
                                                          );


        INET_ASSERT(lpszAutoProxyReturnInfo);
        GlobalFree(lpszAutoProxyReturnInfo);  // clean up jsproxy.dll return string

        if ( pQueryForProxyInfo->_pProxyState  == NULL )
        {
           error = ERROR_NOT_ENOUGH_MEMORY;
           goto quit;
        }

        error = pQueryForProxyInfo->_pProxyState->GetError();

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }


quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) success;

    DEBUG_LEAVE(error);
    return error;

}


BOOL
AUTO_PROXY_LIST_ENTRY::ProxyDllInit (
    IN DWORD                  dwVersion,
    IN LPSTR                  lpszDownloadedTempFile,
    IN LPSTR                  lpszMime,
    IN AUTO_PROXY_HELPER_APIS *pAutoProxyCallbacks,
    IN DWORD_PTR              dwReserved
    )
{
    BOOL success = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_LIST_ENTRY::ProxyDllInit",
                "%u, %s, %s, %x, %u",
                dwVersion,
                lpszDownloadedTempFile,
                lpszMime,
                pAutoProxyCallbacks,
                dwReserved
                ));


    INET_ASSERT ( _hAutoConfigDLL );

    if ( _pProxyDllInit )
    {

        INET_ASSERT(_hAutoConfigDLL);
        INET_ASSERT(!IsBadCodePtr((FARPROC)_pProxyDllInit));

        success = (_pProxyDllInit) ( dwVersion,
                                     lpszDownloadedTempFile,
                                     lpszMime,
                                     pAutoProxyCallbacks,
                                     dwReserved
                                     );

#ifdef INET_DEBUG
        _fUnInited = FALSE;
#endif
        _fInitializedSuccessfully = success;

    }

    DEBUG_LEAVE(success);
    return success;
}

VOID
AUTO_PROXY_LIST_ENTRY::UnloadEntry(
    VOID
    )

/*++

Routine Description:

    Unloads the DLL function entry points for an Auto-Proxy DLL.

    WARNING: Must be called only on Auto-proxy thread context!

Arguments:

    none.

Return Value:

    none.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "AUTO_PROXY_LIST_ENTRY::UnloadEntry",
                NULL
                ));


    if ( _fInitializedSuccessfully &&
         _pProxyDllDeInit )
    {
        ProxyDllDeInit(
            _lpszMimeType,
            0
            );
    }

    if ( _hAutoConfigDLL )
    {
        // HACK HACK This call will block an dll unload time because of the 
        // loader critical section. Ideally we should move this free to the 
        // main thread, but since we are in the midst of IE5 RC's we are doing
        // the least risky change i.e. leaking jsproxy.dll in the process. 
        if (!GlobalDynaUnload)
        {
            FreeLibrary(_hAutoConfigDLL);
        }

        _pGetProxyInfo      = NULL;
        _pGetProxyInfoEx    = NULL;
        _pProxyDllInit      = NULL;
        _pProxyDllDeInit    = NULL;
        _pProxyInfoInvalid  = NULL;
    }

    DEBUG_LEAVE(0);
}


DWORD
AUTO_PROXY_LIST_ENTRY::LoadEntry(
    VOID
    )

/*++

Routine Description:

    Loads the DLL function entry points for an Auto-Proxy DLL.

Arguments:

    none.

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_LIST_ENTRY::LoadEntry",
                ""
                ));

    if ( _lpszFileExtensions == NULL  ||
         _lpszDllFilePath == NULL )
    {
        error =  ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    _pGetProxyInfo      = NULL;
    _pProxyInfoInvalid  = NULL;
    _pProxyDllDeInit    = NULL;
    _pProxyDllInit      = NULL;
    _pGetProxyInfoEx    = NULL;

    if ( _hAutoConfigDLL )
    {
        FreeLibrary(_hAutoConfigDLL);
        _hAutoConfigDLL  = NULL;
    }

    _hAutoConfigDLL = LoadLibrary(_lpszDllFilePath);

    if ( _hAutoConfigDLL == NULL )
    {
        error = GetLastError();
        goto quit;
    }



    _pGetProxyInfo     = (GET_PROXY_INFO_FN)
                        GetProcAddress(_hAutoConfigDLL, GET_PROXY_INFO_FN_NAME);


    _pGetProxyInfoEx   = (GET_PROXY_INFO_EX_FN)
                        GetProcAddress(_hAutoConfigDLL, GET_PROXY_INFO_EX_FN_NAME);


    _pProxyInfoInvalid = (PROXY_INFO_INVALID_FN)
                        GetProcAddress(_hAutoConfigDLL, PROXY_INFO_INVALID_FN_NAME);


    _pProxyDllDeInit   = (PROXY_DLL_DEINIT_FN)
                        GetProcAddress(_hAutoConfigDLL, PROXY_DLL_DEINIT_FN_NAME);


    _pProxyDllInit     = (PROXY_DLL_INIT_FN)
                        GetProcAddress(_hAutoConfigDLL, PROXY_DLL_INIT_FN_NAME );


    if ( !_pProxyDllInit && !_pProxyDllDeInit && !_pProxyInfoInvalid && !_pGetProxyInfo && !_pGetProxyInfoEx)
    {
        error = GetLastError();
        goto quit;
    }

    if ( !_pProxyDllInit )
    {
        //
        // If they don't export this entry point, than we can't initialize them, so
        //  we pretend to have initialized them.
        //

        _fInitializedSuccessfully = TRUE;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


BOOL
AUTO_PROXY_DLLS::SelectAutoProxyByMime(
    IN LPSTR lpszMimeType
    )

/*++

Routine Description:

    Sets an internal pointer inside the object to point to a found auto-proxy DLL.
        The MIME type given is used to find the match.

Arguments:

    lpszMimeType - The Mime type to search on.

Return Value:

    BOOL
        TRUE    - success

        FALSE - failure

--*/


{

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_DLLS::SelectAutoProxyByMime",
                "%s",
                lpszMimeType
                ));

    BOOL found = FALSE;
    AUTO_PROXY_LIST_ENTRY * info = NULL;

    LockAutoProxy();

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, AUTO_PROXY_LIST_ENTRY, _List);

        if (info->_lpszMimeType && lstrcmpi(lpszMimeType, info->_lpszMimeType) == 0 )
        {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

    if ( found )
    {
        SelectAutoProxy(info);
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(found);

    return found;

}

BOOL
AUTO_PROXY_DLLS::SelectAutoProxyByDefault(
    VOID
    )
{

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_DLLS::SelectAutoProxyByDefault",
                NULL
                ));

    BOOL found = FALSE;
    AUTO_PROXY_LIST_ENTRY * info = NULL;

    LockAutoProxy();

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, AUTO_PROXY_LIST_ENTRY, _List);

        if (info->IsDefault() )
        {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

    if ( found )
    {
        SelectAutoProxy(info);
    }

    DEBUG_LEAVE(found);

    UnlockAutoProxy();

    return found;
}

BOOL
AUTO_PROXY_DLLS::SelectAutoProxyByFileExtension(
    LPCSTR lpszAutoProxyPath
    )
{

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_DLLS::SelectAutoProxyByFileExtension",
                "%s",
                lpszAutoProxyPath
                ));

    BOOL found = FALSE;
    AUTO_PROXY_LIST_ENTRY * info = NULL;

    LockAutoProxy();

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, AUTO_PROXY_LIST_ENTRY, _List);

        if (info->_lpszFileExtensions &&
                MatchFileExtensionWithUrl(info->_lpszFileExtensions, lpszAutoProxyPath) )
        {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

    if ( found )
    {
        SelectAutoProxy(info);
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(found);

    return found;
}

DWORD
AUTO_PROXY_DLLS::GetAutoProxyStringEntry(
    IN LPSTR lpszRegName,
    IN OUT LPSTR * lplpszAllocatedRegValue
    )
{
    DWORD dwcbNewValue = 0;
    DWORD error = ERROR_SUCCESS;

    if ( *lplpszAllocatedRegValue )
    {
        FREE_MEMORY(*lplpszAllocatedRegValue);
        *lplpszAllocatedRegValue = NULL;
    }

    error =
        InternetReadRegistryString(
            lpszRegName,
            NULL,
            &dwcbNewValue
            );

    if ( error == ERROR_SUCCESS )
    {
        dwcbNewValue++;
        *lplpszAllocatedRegValue = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, dwcbNewValue);

        if ( *lplpszAllocatedRegValue == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        error =
            InternetReadRegistryString(
                lpszRegName,
                *lplpszAllocatedRegValue,
                &dwcbNewValue
                );

        if ( error != ERROR_SUCCESS )
        {
            INET_ASSERT((error == ERROR_SUCCESS));
            FREE_MEMORY(*lplpszAllocatedRegValue);
            *lplpszAllocatedRegValue = NULL;
        }
    }

quit:

    return error;
}



DWORD
AUTO_PROXY_DLLS::ReadAutoProxyRegistrySettings(
    VOID
    )

/*++

Routine Description:

    Scans Registry for, and builds linked list of AutoProxy DLLs.

Return Value:

  Success - ERROR_SUCCESS

  Failure -

--*/

{
    HKEY hkSecurity = NULL; // main security key
    DWORD error = ERROR_SUCCESS;
    DWORD dwcbAutoConfigProxy = 0;
    HKEY hkSPMKey = NULL;
    const static CHAR cszMainSecKey[]
        = CSZMAINSECKEY;
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::ReadAutoProxyRegistrySettings",
                ""
                ));

    LockAutoProxy();

    //
    // QFE 1169:  Use the HKCU value as the user agent string if told to do so.
    //            Yes this looks ugly, but it's just to prevent a whole bunch
    //            of ifs and handlers for failures.

    DWORD dwcbBufLen = 0;
    
    if (ERROR_SUCCESS == InternetReadRegistryDwordKey(
            HKEY_CURRENT_USER,
            "AutoConfigCustomUA",
            &dwcbBufLen) &&
        dwcbBufLen)
    {       
        if (NULL == _hInstUrlmon)
        {
            _hInstUrlmon = LoadLibrary("Urlmon.dll");
        }       
        if (_hInstUrlmon)
        {        
            typedef HRESULT (*PFNOBTAINUA)(DWORD, LPSTR, DWORD*);
            CHAR lpszUserAgent[MAX_PATH];
            DWORD cbSize = MAX_PATH;

            PFNOBTAINUA pfnUA = (PFNOBTAINUA)GetProcAddress(_hInstUrlmon,"ObtainUserAgentString");
            if (pfnUA)
            {
                HRESULT hr = (*pfnUA)(0, lpszUserAgent, &cbSize);
                if(S_OK == hr)
                {
                    if ( _lpszUserAgent && (lstrcmpi(_lpszUserAgent, lpszUserAgent) != 0) )
                    {
                        _lpszUserAgent = (LPSTR)
                            FREE_MEMORY(_lpszUserAgent);
                    }
                    if ( _lpszUserAgent == NULL )
                    {
                        _lpszUserAgent = NewString(lpszUserAgent);
                    }
                }
            }
        }
    }

    if (REGOPENKEY( HKEY_CLASSES_ROOT, cszMainSecKey, &hkSecurity ) != ERROR_SUCCESS)
    {
        error = GetLastError();
        goto quit;
    }


    DWORD dwIndex;
    dwIndex = 0;

    do
    {
        CHAR szMime[256];
#ifdef unix
        CHAR szUnixHackMime[256];
#endif /* unix */
        if ( hkSPMKey != NULL )
        {
            REGCLOSEKEY(hkSPMKey);
            hkSPMKey = NULL;
        }

        //
        // Enumerate a List of MIME types, that we accept for auto-proxy
        //

        if (RegEnumKey( hkSecurity, dwIndex, szMime, sizeof(szMime)) != ERROR_SUCCESS )
        {
            goto quit;
        }

        dwIndex++;

        //
        // Open a potential MIME type entry.
        //

        if (REGOPENKEY( hkSecurity, szMime, &hkSPMKey ) != ERROR_SUCCESS)
        {
            INET_ASSERT(0);
            continue;
        }

        //
        // Grab the DLL file name
        //

        DWORD dwType, cbBuf;

        char szDll[MAX_PATH];
        cbBuf = sizeof(szDll);
        if (ERROR_SUCCESS != RegQueryValueEx
                (hkSPMKey, "DllFile", NULL, &dwType, (LPBYTE) szDll, &cbBuf)
            ||  ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) )
        {
            continue; // no DLL name
        }


        if ( dwType == REG_EXPAND_SZ )
        {
            DWORD dwSize;
            char szDllPathBeforeExpansion[MAX_PATH];

            lstrcpy(szDllPathBeforeExpansion, szDll);

            dwSize = ExpandEnvironmentStrings(szDllPathBeforeExpansion, szDll, ARRAY_ELEMENTS(szDll));

            if (dwSize > ARRAY_ELEMENTS(szDll) || dwSize == 0 )
            {
                INET_ASSERT(FALSE);
                continue;  // not enough room to expand vars?
            }
        }

        //
        // Grab the list of File extensions that are permitted for this Mime Type
        //


        char szFileExtensions[MAX_PATH];
        cbBuf = sizeof(szFileExtensions);
        if (ERROR_SUCCESS != RegQueryValueEx
                (hkSPMKey, "FileExtensions", NULL, &dwType, (LPBYTE) szFileExtensions, &cbBuf)
            || (dwType != REG_SZ))
        {
            continue; // no DLL name
        }


        //
        // Determine whether its the defaut entry.
        //

        DWORD fIsDefault;
        cbBuf = sizeof(fIsDefault);
        if (ERROR_SUCCESS != RegQueryValueEx
                (hkSPMKey, "Default", NULL, &dwType, (LPBYTE) &fIsDefault, &cbBuf)
            || ((dwType != REG_DWORD) && (dwType != REG_BINARY)))
        {
            INET_ASSERT (cbBuf == sizeof(DWORD));
            fIsDefault = 0;
        }

        //
        // Determine whether we have any Flags that need to be read
        //  from the registry.
        //

        DWORD dwFlags;

        cbBuf = sizeof(dwFlags);
        if (ERROR_SUCCESS != RegQueryValueEx
                (hkSPMKey, "Flags", NULL, &dwType, (LPBYTE) &dwFlags, &cbBuf)
            || ((dwType != REG_DWORD) && (dwType != REG_BINARY)))
        {
            dwFlags = 0;
        }


        //
        // Now build an entry for it, and add it to our list.
        //
#ifndef unix
        AUTO_PROXY_LIST_ENTRY *apleAutoProxy
             = new AUTO_PROXY_LIST_ENTRY(szDll, szFileExtensions, szMime, fIsDefault, dwFlags);
#else
        strcpy(szUnixHackMime,"application/");
        strcat(szUnixHackMime,szMime);
        AUTO_PROXY_LIST_ENTRY *apleAutoProxy
             = new AUTO_PROXY_LIST_ENTRY(szDll, szFileExtensions, szUnixHackMime, fIsDefault, dwFlags);
#endif /* unix */
        if (!apleAutoProxy)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        if (fIsDefault)
        {
            InsertAtTailOfSerializedList(&_List, &apleAutoProxy->_List);
        }
        else
        {
            InsertAtHeadOfSerializedList(&_List, &apleAutoProxy->_List);
        }

    } while (1);

    error = ERROR_SUCCESS;

quit:

    if ( hkSPMKey != NULL )
    {
        REGCLOSEKEY(hkSPMKey);
    }

    if ( hkSecurity != NULL )
    {
        REGCLOSEKEY(hkSecurity);
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(error);

    return error;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{
    URL_COMPONENTS urlComponents;

    Initalize();

    if ( lpszUrl )
    {
        _lpszUrl      = lpszUrl;
        _dwUrlLength  = lstrlen(lpszUrl);
        _tUrlProtocol = isUrlScheme;
        _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
        _pmaAllocMode = MSG_ALLOC_STACK_ONLY;

        memset(&urlComponents, 0, sizeof(urlComponents));
        urlComponents.dwStructSize = sizeof(urlComponents);
        urlComponents.lpszHostName = lpszUrlHostName;
        urlComponents.dwHostNameLength = dwUrlHostNameLength;

        //
        // parse out the host name and port. The host name will be decoded; the
        // original URL will not be modified
        //

        if (InternetCrackUrl(lpszUrl, 0, ICU_DECODE, &urlComponents))
        {
           _nUrlPort            = urlComponents.nPort;
           _lpszUrlHostName     = urlComponents.lpszHostName;
           _dwUrlHostNameLength = urlComponents.dwHostNameLength;

           if ( _tUrlProtocol == INTERNET_SCHEME_UNKNOWN )
           {
               _tUrlProtocol = urlComponents.nScheme;
           }

        }
        else
        {
            _Error = GetLastError();
        }
    }
    else
    {
        _Error = ERROR_NOT_ENOUGH_MEMORY;
    }
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{

    Initalize();

    _tUrlProtocol = isUrlScheme;
    _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode = MSG_ALLOC_STACK_ONLY;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    Initalize();

    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;

}

VOID
AUTO_PROXY_ASYNC_MSG::SetProxyMsg(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;
}


AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN PROXY_MESSAGE_TYPE pmProxyQuery
    )
{
    Initalize();

    _pmaAllocMode = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pmProxyQuery = pmProxyQuery;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN AUTO_PROXY_ASYNC_MSG *pStaticAutoProxy
    )
{
    Initalize();

    _tUrlProtocol          = pStaticAutoProxy->_tUrlProtocol;
    _lpszUrl               = (pStaticAutoProxy->_lpszUrl) ? NewString(pStaticAutoProxy->_lpszUrl) : NULL;
    _dwUrlLength           = pStaticAutoProxy->_dwUrlLength;
    _lpszUrlHostName       =
                (pStaticAutoProxy->_lpszUrlHostName ) ?
                NewString(pStaticAutoProxy->_lpszUrlHostName, pStaticAutoProxy->_dwUrlHostNameLength) :
                NULL;
    _dwUrlHostNameLength   = pStaticAutoProxy->_dwUrlHostNameLength;
    _nUrlPort              = pStaticAutoProxy->_nUrlPort;
    _tProxyScheme          = pStaticAutoProxy->_tProxyScheme;

    //
    // ProxyHostName is something that is generated by the request,
    //   therefore it should not be copied OR freed.
    //

    INET_ASSERT( pStaticAutoProxy->_lpszProxyHostName == NULL );
    //_lpszProxyHostName     = (pStaticAutoProxy->_lpszProxyHostName ) ? NewString(pStaticAutoProxy->_lpszProxyHostName) : NULL;


    _dwProxyHostNameLength = pStaticAutoProxy->_dwProxyHostNameLength;
    _nProxyHostPort        = pStaticAutoProxy->_nProxyHostPort;
    _pmProxyQuery          = pStaticAutoProxy->_pmProxyQuery;
    _pmaAllocMode          = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pProxyState           = pStaticAutoProxy->_pProxyState;

    INET_ASSERT(_pProxyState == NULL);

    _dwQueryResult         = pStaticAutoProxy->_dwQueryResult;
    _Error                 = pStaticAutoProxy->_Error;
    _MessageFlags.Dword    = pStaticAutoProxy->_MessageFlags.Dword;
    _dwProxyVersion        = pStaticAutoProxy->_dwProxyVersion;
}

AUTO_PROXY_ASYNC_MSG::~AUTO_PROXY_ASYNC_MSG(
    VOID
    )
{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~AUTO_PROXY_ASYNC_MSG",
                NULL
                ));

    if ( IsAlloced() )
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Freeing Allocated MSG ptr=%x\n",
                    this
                    ));


        if ( _lpszUrl )
        {
            //DEBUG_PRINT(OBJECTS,
            //            INFO,
            //            ("Url ptr=%x, %q\n",
            //            _lpszUrl,
            //            _lpszUrl
            //            ));

            FREE_MEMORY(_lpszUrl);
        }

        if ( _lpszUrlHostName )
        {
            FREE_MEMORY(_lpszUrlHostName);
        }


        if ( _pProxyState )
        {
            delete _pProxyState;
        }
    }
    if (_bFreeProxyHostName && (_lpszProxyHostName != NULL)) {
        FREE_MEMORY(_lpszProxyHostName);
    }

    DEBUG_LEAVE(0);
}



//
// functions
//


PRIVATE
BOOL
MatchFileExtensionWithUrl(
    IN LPCSTR lpszFileExtensionList,
    IN LPCSTR lpszUrl
    )

/*++

Routine Description:

    Matches a Url with a string of externsions (looks like ".ins;.jv").
    Confims the Url is using one the approved externsions.

Arguments:

    lpszFileExtensionList - the list of file extensions to check the Url against.

    lpszUrl  - the url to examine.

Return Value:

    BOOL
        TRUE    - success

        FALSE   - the Url does not contain any of the extensions.

--*/


{

    LPCSTR lpszExtension, lpszExtensionOffset;
    LPCSTR lpszQuestion;

    //
    // We need to be careful about checking for a period on the end of an URL
    //   Example: if we have: "http://auto-proxy-srv/fooboo.exe?autogenator.com.ex" ?
    //

    lpszQuestion = strchr( lpszUrl, '?' );

    lpszUrl = ( lpszQuestion ) ? lpszQuestion : lpszUrl;

    lpszExtension = strrchr( lpszUrl, '.' );


    if ( lpszExtension )
    {
        lpszExtensionOffset = lpszExtension;
        BOOL fMatching = FALSE;
        BOOL fCurrentMatch = FALSE;
        BOOL fFirstByte = TRUE;

        while ( *lpszFileExtensionList && *lpszExtensionOffset )
        {

            if ( toupper(*lpszFileExtensionList) == toupper(*lpszExtensionOffset) )
            {
                fCurrentMatch = TRUE;
            }
            else
            {
                fCurrentMatch = FALSE;
            }

            if ( *lpszFileExtensionList == ';')
            {
                lpszExtensionOffset = lpszExtension-1;
                fFirstByte = TRUE;

                if ( fMatching )
                {
                    return TRUE;
                }
            }
            else if ( fFirstByte || fMatching )
            {
                fMatching = fCurrentMatch;
                fFirstByte = FALSE;
            }

            lpszExtensionOffset++;
            lpszFileExtensionList++;

            if ( *lpszExtensionOffset == '\0' )
            {
                lpszExtensionOffset = lpszExtension;
            }
        }

        if ( fMatching )
        {
            return TRUE;
        }

    }

    return FALSE;
}

#ifdef unix
static BOOL fForceAutoProxSync = TRUE;
extern "C"
void unixForceAutoProxSync()
{
    if(fForceAutoProxSync)
    {
       if (!GlobalDataInitialized)
          GlobalDataInitialize();

       if (GlobalDataInitialized)
       {
          GlobalProxyInfo.SetRefreshDisabled(FALSE);
          FixProxySettingsForCurrentConnection(TRUE);
          GlobalProxyInfo.ReleaseQueuedRefresh();
          fForceAutoProxSync = FALSE;
       }
    }
}
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\handles\gopher.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gopher.cxx

Abstract:

    Contains methods for GOPHER_FIND_HANDLE_OBJECT and GOPHER_FILE_HANDLE_OBJECT
    classes

    Contents:
        RMakeGfrFindObjectHandle
        RMakeGfrFileObjectHandle
        RMakeGfrFixedObjectHandle

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeGfrFindObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

Routine Description:

    C-callable wrapper for creating a GOPHER_FIND_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of GOPHER_FIND_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    GOPHER_FIND_HANDLE_OBJECT * hFind;

    hFind = new GOPHER_FIND_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwContext
                    );

    if (hFind != NULL) {
        error = hFind->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hFind);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hFind = NULL;
            }
        } else {
            delete hFind;
            hFind = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hFind;

    return error;
}



DWORD
RMakeGfrFixedObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN DWORD dwFixedType
    )

/*++

Routine Description:

Routine Description:

    C-callable wrapper for creating a GOPHER_FIND_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of GOPHER_FIND_HANDLE_OBJECT

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    GOPHER_FIND_HANDLE_OBJECT * hFind;

    hFind = new GOPHER_FIND_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    dwFixedType
                    );

    if (!hFind) {
        error = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        error = hFind->GetStatus();
        if (error != ERROR_SUCCESS) {
            delete hFind;
            hFind = NULL;
        }
    }

    *ChildHandle = (HINTERNET)hFind;
    return error;
}



DWORD
RMakeGfrFileObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating a GOPHER_FILE_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of GOPHER_FILE_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    GOPHER_FILE_HANDLE_OBJECT * hFile;

    hFile = new GOPHER_FILE_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwContext
                    );

    if (hFile != NULL) {
        error = hFile->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hFile);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hFile = NULL;
            }
        } else {
            delete hFile;
            hFile = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hFile;

    return error;
}

//
// GOPHER_FIND_HANDLE_OBJECT class implementation
//

GOPHER_FIND_HANDLE_OBJECT::GOPHER_FIND_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)
{
    _FindHandle = Child;
    _wCloseFunction = wCloseFunc;
    _IsHtml = FALSE;
    _dwFixedType = 0;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _Context = dwContext;
    SetObjectType(TypeGopherFindHandle);
}

//
// Constructor for poser find handle to return html form...
//

GOPHER_FIND_HANDLE_OBJECT::GOPHER_FIND_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    DWORD dwFixedType
    ) : INTERNET_CONNECT_HANDLE_OBJECT (Parent)
{
    _FindHandle = Child;
    _wCloseFunction = NULL;
    _IsHtml = FALSE;  // must set FALSE so RSetHtmlHandleType can set TRUE!
    _dwFixedType = dwFixedType;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _Context = 0;
    SetObjectType(TypeGopherFindHandle);
}


GOPHER_FIND_HANDLE_OBJECT::~GOPHER_FIND_HANDLE_OBJECT(
    VOID
    )
{
    //
    // close local handle with appropriate function.
    //

    if (_FindHandle != NULL) {
        _Status = _wCloseFunction(_FindHandle);
    } else {
        _Status = ERROR_SUCCESS;
    }

    //
    // clear out any strings we allocated
    //

    if (_lpszUrl != NULL) {
        DEL_STRING(_lpszUrl);
    }
    if (_lpszDirEntry != NULL) {
        DEL_STRING(_lpszDirEntry);
    }

    //
    // and the query buffer
    //

    FreeQueryBuffer();
}

HINTERNET
GOPHER_FIND_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _FindHandle;
}

DWORD
GOPHER_FIND_HANDLE_OBJECT::QueryHtmlDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )
{
    DWORD error;

    if (_QueryBuffer != NULL) {
        error = ERROR_SUCCESS;
    } else {
        error = AllocateQueryBuffer();
    }

    INET_ASSERT(_QueryBytesAvailable == 0);

    if (error == ERROR_SUCCESS) {

        DWORD nRead;

        _QueryOffset = 0;
        if (ReadHtmlUrlData((HINTERNET)this,
                            _QueryBuffer,
                            _QueryBufferLength,
                            lpdwNumberOfBytesAvailable
                            )) {
            _QueryBytesAvailable = *lpdwNumberOfBytesAvailable;
            //SetAvailableDataLength(_QueryBytesAvailable);
            if (_QueryBytesAvailable == 0) {
                SetEndOfFile();
            }
        } else {
            error = GetLastError();
        }
    }
    return error;
}

//
// GOPHER_FILE_HANDLE_OBJECT class implementation
//

GOPHER_FILE_HANDLE_OBJECT::GOPHER_FILE_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)
{
    _FileHandle = Child;
    _wCloseFunction = wCloseFunc;
    _IsHtml = FALSE;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _Context = dwContext;
    SetObjectType(TypeGopherFileHandle);
}

GOPHER_FILE_HANDLE_OBJECT::~GOPHER_FILE_HANDLE_OBJECT(
    VOID
    )
{
    //
    // close local handle with appropriate function.
    //

    if (_FileHandle != NULL) {
        _Status = _wCloseFunction(_FileHandle);
    } else {
        _Status = ERROR_SUCCESS;
    }

    //
    // clear out any strings we allocated
    //

    if (_lpszUrl != NULL) {
        DEL_STRING(_lpszUrl);
    }
    if (_lpszDirEntry != NULL) {
        DEL_STRING(_lpszDirEntry);
    }
}

HINTERNET
GOPHER_FILE_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _FileHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\handles\hinet.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hinet.cxx

Abstract:

    contains methods for INTERNET_HANDLE_OBJECT class

    Contents:
        ContainingHandleObject
        CancelActiveSyncRequests
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::Reference()
        HANDLE_OBJECT::Dereference()
        HANDLE_OBJECT::IsValid()
        INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT(LPCSTR, ...)
        INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT(INTERNET_HANDLE_OBJECT*)
        INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT()
        INTERNET_HANDLE_OBJECT::SetAbortHandle(ICSocket)
        INTERNET_HANDLE_OBJECT::ResetAbortHandle()
        INTERNET_HANDLE_OBJECT::AbortSocket()
        INTERNET_HANDLE_OBJECT::CheckGlobalProxyUpdated()
        INTERNET_HANDLE_OBJECT::SetProxyInfo()
        INTERNET_HANDLE_OBJECT::GetProxyInfo(LPVOID, LPDWORD)
        INTERNET_HANDLE_OBJECT::GetProxyInfo(INTERNET_SCHEME, LPINTERNET_SCHEME, LPSTR *, LPDWORD, LPINTERNET_PORT)

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "autodial.h"

//
// private manifests
//

#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// functions
//


HANDLE_OBJECT *
ContainingHandleObject(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of containing HANDLE_OBJECT from address of _List member

Arguments:

    lpAddress   - address of _List in this object

Return Value:

    HANDLE_OBJECT *

--*/

{
    return CONTAINING_RECORD(lpAddress, HANDLE_OBJECT, _List);
}


VOID
CancelActiveSyncRequests(
    IN DWORD dwError
    )

/*++

Routine Description:

    For all currently active synchronous requests, cancels them with the error
    code supplied

Arguments:

    dwError - error code to complete requests

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_INET,
                 None,
                 "CancelActiveSyncRequests",
                 "%s",
                 InternetMapError(dwError)
                 ));

    LockSerializedList(&GlobalObjectList);

    for (PLIST_ENTRY pEntry = (PLIST_ENTRY)HeadOfSerializedList(&GlobalObjectList);
         pEntry != (PLIST_ENTRY)SlSelf(&GlobalObjectList);
         pEntry = pEntry->Flink) {

        HANDLE_OBJECT * pObject = ContainingHandleObject(pEntry);
        HINTERNET_HANDLE_TYPE objectType = pObject->GetObjectType();

        //
        // check handle types in decreasing order of expectation for IE
        //

        if ((objectType == TypeHttpRequestHandle)
        || (objectType == TypeFtpFindHandleHtml)
        || (objectType == TypeFtpFindHandle)
        || (objectType == TypeFtpFileHandle)
        || (objectType == TypeGopherFindHandleHtml)
        || (objectType == TypeGopherFindHandle)
        || (objectType == TypeGopherFileHandle)) {

            //
            // all these handle types are descended from INTERNET_HANDLE_OBJECT
            // which in turn is descended from HANDLE_OBJECT
            //

            if (!((INTERNET_HANDLE_OBJECT *)pObject)->IsAsyncHandle()) {

                //
                // sync request
                //

                DEBUG_PRINT(INET,
                            INFO,
                            ("cancelling %s sync request on handle %#x (%#x) \n",
                            InternetMapHandleType(objectType),
                            pObject->GetPseudoHandle(),
                            pObject
                            ));

                pObject->InvalidateWithError(dwError);
            }
        }
    }

    UnlockSerializedList(&GlobalObjectList);

    DEBUG_LEAVE(0);
}

//
// methods
//


HANDLE_OBJECT::HANDLE_OBJECT(
    IN HANDLE_OBJECT * Parent
    )

/*++

Routine Description:

    HANDLE_OBJECT constructor

Arguments:

    Parent  - pointer to parent HANDLE_OBJECT

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "HANDLE_OBJECT",
                "%#x",
                this
                ));

    //InitializeListHead(&_List);
    InitializeSerializedList(&_Children);
    //InitializeListHead(&_Siblings);
    _Parent = Parent;
    if (_Parent != NULL) {
        _Parent->AddChild(&_Siblings);
    } else {
        InitializeListHead(&_Siblings);
    }
    _DeleteWithChild = FALSE;
    _Status = AllocateHandle(this, &_Handle);
    _ObjectType = TypeGenericHandle;
    _ReferenceCount = 1;
    _Invalid = FALSE;
    _Error = ERROR_SUCCESS;
    _Signature = OBJECT_SIGNATURE;
    _Context = INTERNET_NO_CALLBACK;
    InsertAtTailOfSerializedList(&GlobalObjectList, &_List);

    //
    // if AllocateHandle() failed then we cannot create this handle object.
    // Invalidate it ready for the destructor
    //

    if (_Status != ERROR_SUCCESS) {
        _Invalid = TRUE;
        _ReferenceCount = 0;
    }

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x created; address %#x; %d objects\n",
                _Handle,
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


HANDLE_OBJECT::~HANDLE_OBJECT(VOID)

/*++

Routine Description:

    HANDLE_OBJECT destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HANDLE_OBJECT",
                "%#x",
                this
                ));

    //
    // remove this object from global object list
    //

    LockSerializedList(&GlobalObjectList);
    RemoveFromSerializedList(&GlobalObjectList, &_List);
    if (IsSerializedListEmpty(&GlobalObjectList)) {
        OnLastHandleDestroyed();
    }
    UnlockSerializedList(&GlobalObjectList);

    INET_DEBUG_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    //
    // inform the app that this handle is completely closed, but only if we
    // can make callbacks at all
    //

    if (_Context != INTERNET_NO_CALLBACK) {

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        HINTERNET hCurrent = _InternetGetObjectHandle(lpThreadInfo);
        HINTERNET hCurrentMapped = _InternetGetMappedObjectHandle(lpThreadInfo);
        DWORD_PTR currentContext = _InternetGetContext(lpThreadInfo);

        _InternetSetObjectHandle(lpThreadInfo, _Handle, (HINTERNET)this);
        _InternetSetContext(lpThreadInfo, _Context);

        InternetIndicateStatus(INTERNET_STATUS_HANDLE_CLOSING,
                               (LPVOID)&_Handle,
                               sizeof(_Handle)
                               );

        _InternetSetObjectHandle(lpThreadInfo, hCurrent, hCurrentMapped);
        _InternetSetContext(lpThreadInfo, currentContext);
    } else {

        DEBUG_PRINT(OBJECTS,
                    WARNING,
                    ("handle %#x [%#x] no context: no callback\n",
                    _Handle,
                    this
                    ));

    }

    //
    // remove object from parent's child list (if we have a parent object)
    //

    if (_Parent != NULL) {
        _Parent->RemoveChild(&_Siblings);

        INET_DEBUG_ASSERT((_Siblings.Flink == NULL) && (_Siblings.Blink == NULL));

    }

    //
    // now we can free up the API handle value
    //

    if (_Handle != NULL) {
        _Status = FreeHandle(_Handle);

        INET_ASSERT(_Status == ERROR_SUCCESS);

    }

    //
    // there should be no child objects
    //

    INET_ASSERT(IsSerializedListEmpty(&_Children));

    TerminateSerializedList(&_Children);

    //
    // set the signature to a value that indicates the handle has been
    // destroyed (not useful in debug builds)
    //

    _Signature = DESTROYED_OBJECT_SIGNATURE;

    INET_ASSERT((_ReferenceCount == 0) && _Invalid);

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x destroyed; type %s; address %#x; %d objects\n",
                _Handle,
                InternetMapHandleType(_ObjectType),
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


DWORD
HANDLE_OBJECT::Reference(
    VOID
    )

/*++

Routine Description:

    Increases the reference count on the HANDLE_OBJECT

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Handle has already been invalidated
                  ERROR_ACCESS_DENIED
                    Handle object is being destroyed, cannot use it

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "HANDLE_OBJECT::Reference",
                 "{%#x}",
                 _Handle
                 ));

    DWORD error;

    if (_Invalid) {

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("handle object %#x [%#x] is invalid\n",
                    _Handle,
                    this
                    ));

        error = ERROR_INVALID_HANDLE;
    } else {
        error = ERROR_SUCCESS;
    }

    //
    // even if the handle has been invalidated (i.e. closed), we allow it
    // to continue to be referenced. The caller should return the fact
    // that the handle has been invalidated, but may require information
    // from the object in order to do so (e.g. in async thread)
    //

    do
    {
        LONG lRefCountBeforeIncrement = _ReferenceCount;

        //
        // refcount is > 0 means that the object's destructor has not been called yet
        //
        if (lRefCountBeforeIncrement > 0)
        {
            //
            // try to increment the refcount using compare-exchange
            //
#ifndef _WIN64
            LONG lRefCountCurrent = (LONG)SHInterlockedCompareExchange((LPVOID*)&_ReferenceCount,
                                                                       (LPVOID)(lRefCountBeforeIncrement + 1),
                                                                       (LPVOID)lRefCountBeforeIncrement);
#else
            //
            // can't use SHInterlockedCompareExchange on win64 because the values are really LONG's (32-bits) but they
            // are treated as pointers (64-bits) because SHInterlockedCompareExchange should really be called 
            // SHInterlockedCompareExchangePointer (sigh...).
            //
            LONG lRefCountCurrent = InterlockedCompareExchange(&_ReferenceCount,
                                                               lRefCountBeforeIncrement + 1,
                                                               lRefCountBeforeIncrement);
#endif        
            if (lRefCountCurrent == lRefCountBeforeIncrement)
            {
                //
                // since SHInterlockedCompareExchange returns the value in _ReferenceCount 
                // before the exchange, we know the exchange sucessfully took place (i.e. we 
                // sucessfully incremented the refrence count of the object by one)
                //
                INET_ASSERT(lRefCountCurrent > 0);
                break;
            }
        }
        else
        {
            //
            // the refcount dropped to zero before we could increment it,
            // so the object is being destroyed. 
            //
            error = ERROR_ACCESS_DENIED;
            break;
        }

    } while (TRUE);

    DEBUG_PRINT(REFCOUNT,
                INFO,
                ("handle object %#x [%#x] ReferenceCount = %d\n",
                _Handle,
                this,
                _ReferenceCount
                ));

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HANDLE_OBJECT::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count on the HANDLE_OBJECT, and if it goes to zero,
    the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - this object was deleted

        FALSE   - this object is still valid

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Bool,
                 "HANDLE_OBJECT::Dereference",
                 "{%#x}",
                 _Handle
                 ));

    //
    // by the time we get here, the reference count should not be 0. There
    // should be 1 call to Dereference() for each call to Reference()
    //

    INET_ASSERT(_ReferenceCount != 0);

    BOOL deleted = FALSE;

    if (InterlockedDecrement(&_ReferenceCount) == 0)
    {
        deleted = TRUE;
    }


    if (deleted)
    {
        //
        // if we are calling the destructor, the handle had better be invalid!
        //
        INET_ASSERT(_Invalid);
        
        //
        // this handle has now been closed. If there is no activity on it
        // then it will be destroyed
        //

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));

        delete this;
    } else {

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));
    }

    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD
HANDLE_OBJECT::IsValid(
    IN HINTERNET_HANDLE_TYPE ExpectedHandleType
    )

/*++

Routine Description:

    Checks a HANDLE_OBJECT for validity

Arguments:

    ExpectedHandleType  - type of object we are testing for. Can be
                          TypeWildHandle which matches any valid handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    The handle object is invalid

                  ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                    The handle object is valid, but not the type we want

--*/

{
    DWORD error;
    BOOL IsOkHandle = TRUE;

    //
    // test handle object within try..except in case we are given a bad address
    //

    __try {
        if (_Signature == OBJECT_SIGNATURE) {

            error = ERROR_SUCCESS;

            //
            // check handle type if we are asked to do so.
            //

            if (ExpectedHandleType != TypeWildHandle) {
                if (ExpectedHandleType != this->GetHandleType()) {
                    error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
                }
            }
        } else {
            error = ERROR_INVALID_HANDLE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_HANDLE;
    }
    ENDEXCEPT
    return error;
}


INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT(
    LPCSTR UserAgent,
    DWORD AccessMethod,
    LPSTR ProxyServerList,
    LPSTR ProxyBypassList,
    DWORD Flags
    ) : HANDLE_OBJECT(NULL)

/*++

Routine Description:

    Creates the handle object for InternetOpen()

Arguments:

    UserAgent       - name of agent (user-agent string for HTTP)

    AccessMethod    - DIRECT, PROXY or PRECONFIG

    ProxyServerList - one or more proxy servers. The string has the form:

                        [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

    ProxyBypassList - zero or more addresses which if matched will result in
                      requests NOT going via the proxy (only if PROXY access).
                      The string has the form:

                        bp_entry ::= [<scheme>"://"]<server>[":"<port>]
                        bp_macro ::= "<local>"
                        bp_list ::= [<> | bp_entry bp_macro][";"*]

    Flags           - various open flags:

                        INTERNET_FLAG_ASYNC

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT",
                 NULL
                 ));


    //
    // if the HANDLE_OBJECT constructor failed then bail out now
    //

    if (_Status != ERROR_SUCCESS) {

        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("early-exit: _Status = %d\n",
                    _Status
                    ));

        DEBUG_LEAVE(0);

        return;
    }

    //
    // BUGBUG - remove _INetHandle
    //
    _fExemptConnLimit = FALSE;

    if (GlobalPlatformWhistler)
    {
        _fDisableTweener = FALSE; // Tweener (Passport1.4 is enabled by default for Windows XP)
    }
    else
    {
        _fDisableTweener = TRUE; // by default disable Tweener for downlevels
    }

    _PPContext = 0;

    _INetHandle = INET_INVALID_HANDLE_VALUE;

    _IsCopy = FALSE;
    _UserAgent = (LPSTR)UserAgent;
    _ProxyInfo = NULL;
    _dwInternetOpenFlags = Flags;
    _WinsockLoaded = FALSE;

    //
    // BUGBUG - post-beta: move to HANDLE_OBJECT
    //

    _Context = INTERNET_NO_CALLBACK;

    //
    // initialize the timeout/retry values for this object from the
    // global (DLL) values
    //

    _ConnectTimeout = GlobalConnectTimeout;
    _ConnectRetries = GlobalConnectRetries;
    _SendTimeout = GlobalSendTimeout;
    _DataSendTimeout = GlobalDataSendTimeout;
    _ReceiveTimeout = GlobalReceiveTimeout;
    _DataReceiveTimeout = GlobalDataReceiveTimeout;
    _FromCacheTimeout = GlobalFromCacheTimeout;
    _SocketSendBufferLength = GlobalSocketSendBufferLength;
    _SocketReceiveBufferLength = GlobalSocketReceiveBufferLength;

    //
    // set _Async based on the INTERNET_FLAG_ASYNC supplied to InternetOpen()
    //

    _Async = (Flags & INTERNET_FLAG_ASYNC) ? TRUE : FALSE;

    //
    // no data available yet
    //

    SetAvailableDataLength(0);

    //
    // not yet end of file
    //

    ResetEndOfFile();

    //
    // no status callback by default
    //

    _StatusCallback = NULL;
    _StatusCallbackType = FALSE;

    //
    // the number of pending async requests is 0. The clash test variable is
    // used to test for ownership using InterlockedIncrement()
    //

    //
    // BUGBUG - RLF 03/16/98. See hinet.hxx
    //

    //_PendingAsyncRequests = 0;
    //_AsyncClashTest = -1;

    InitializeCriticalSection(&_UiCritSec);
    _dwUiBlocked = FALSE;
    SetObjectType(TypeInternetHandle);

    _ProxyInfoResourceLock.Initialize();

    _Status = SetProxyInfo(AccessMethod, ProxyServerList, ProxyBypassList);

    //
    // if _pICSocket is not NULL then this is the socket that this object handle
    // is currently working on. We close it to cancel the operation
    //

    _pICSocket = NULL;

    //
    // load winsock now. We always want to go via winsock since the demise of
    // catapult
    //

    if (_Status == ERROR_SUCCESS) {
        _INetHandle = LOCAL_INET_HANDLE;
        _Status = LoadWinsock();
        _WinsockLoaded = (_Status == ERROR_SUCCESS);

        if ( _Status == ERROR_SUCCESS )
        {
             LONG lOpenHandleCnt;

             LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

             if ( lpThreadInfo && ! lpThreadInfo->IsAutoProxyProxyThread )
             {
                 lOpenHandleCnt = InterlockedIncrement((LPLONG)&GlobalInternetOpenHandleCount);

                 if ( lOpenHandleCnt == 0 )
                 {
                    DWORD fAlreadyInInit = (DWORD) InterlockedExchange((LPLONG) &GlobalAutoProxyInInit, TRUE);

                    INET_ASSERT (! fAlreadyInInit );

                    GlobalProxyInfo.ReleaseQueuedRefresh();

                    InterlockedExchange((LPLONG)&GlobalAutoProxyInInit, FALSE);
                 }
             }
        
            // Passport's implementation is Sync and therefore only Sync session can be re-used.        
            /*
            if (!IsAsyncHandle())
            {
                _PPContext = ::PP_InitContext(L"WinInet.Dll", GetPseudoHandle());
            }
            */
        }
    }

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT(
    INTERNET_HANDLE_OBJECT *INetObj
    ) : HANDLE_OBJECT((HANDLE_OBJECT*)INetObj)

/*++

Routine Description:

    Constructor for derived handle object. We are creating this handle as part
    of an INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    INetObj - pointer to INTERNET_HANDLE_OBJECT to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT",
                 "{IsCopy}"
                 ));

    _PPContext = INetObj->_PPContext;
    _fDisableTweener = INetObj->_fDisableTweener;
    _fExemptConnLimit = INetObj->_fExemptConnLimit;

    _INetHandle = INetObj->_INetHandle;
    _IsCopy = TRUE;

    //
    // copy user agent string
    //

    //
    // BUGBUG - compiler generated copy constructor (no new string)
    //

    _UserAgent = INetObj->_UserAgent;

    //
    // do not inherit the proxy info - code must go to parent handle
    //

    _ProxyInfo = NULL;

    _dwInternetOpenFlags = INetObj->_dwInternetOpenFlags;

    //
    // creating this handle didn't load winsock
    //

    _WinsockLoaded = FALSE;

    //
    // inherit the context, timeout values, async flag and status callback from
    // the parent object handle
    //

    _Context = INetObj->_Context;

    _ConnectTimeout = INetObj->_ConnectTimeout;
    _ConnectRetries = INetObj->_ConnectRetries;
    _SendTimeout = INetObj->_SendTimeout;
    _DataSendTimeout = INetObj->_DataSendTimeout;
    _ReceiveTimeout = INetObj->_ReceiveTimeout;
    _DataReceiveTimeout = INetObj->_DataReceiveTimeout;
    _FromCacheTimeout = INetObj->_FromCacheTimeout;

    //
    // inherit the async I/O mode and callback function
    //

    _Async = INetObj->_Async;
    SetAvailableDataLength(0);
    ResetEndOfFile();
    _StatusCallback = INetObj->_StatusCallback;
    _StatusCallbackType = INetObj->_StatusCallbackType;

    //
    // this is a new object: we need a new pending async request count and clash
    // test variable
    //

    //
    // BUGBUG - RLF 03/16/98. See hinet.hxx
    //

    //_PendingAsyncRequests = 0;
    //_AsyncClashTest = -1;

    //
    // no socket operation to abort yet
    //

    _pICSocket = NULL;

    //
    // BUGBUG - this overwrites status set above?
    //

    _Status = INetObj->_Status;
    _dwUiBlocked = FALSE;

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT(
    VOID
    )

/*++

Routine Description:

    INTERNET_HANDLE_OBJECT destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT",
                 ""
                 ));

    //
    // if this handle is not a copy then delete proxy information if we are not
    // using the global proxy info, and unload the sockets package if we loaded
    // it in the first place
    //


    if (!IsCopy()) {

        if (_PPContext)
        {
            ::PP_FreeContext(_PPContext);
        }

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Not a Copy...\n"
                    ));

        DeleteCriticalSection(&_UiCritSec);

        if (IsProxy()) {

            DEBUG_PRINT(OBJECTS,
                        INFO,
                        ("A Proxy is enabled\n"
                        ));


            if (!IsProxyGlobal()) {

                DEBUG_PRINT(OBJECTS,
                            INFO,
                            ("Free-ing ProxyInfo\n"
                            ));

                delete _ProxyInfo;
                _ProxyInfo = NULL;
            }
        }

        //
        // don't unload winsock. There really is no need to unload separately
        // from process detach and if we do unload, we first have to terminate
        // async support. Dynaloading and unloading winsock is vestigial
        //

        //if (_WinsockLoaded) {
        //    UnloadWinsock();
        //}

//        if ( _Status == ERROR_SUCCESS )
//        {
//             LONG lOpenHandleCnt;
//
//             LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//
//             if ( lpThreadInfo && ! lpThreadInfo->IsAutoProxyProxyThread )
//             {
//                 lOpenHandleCnt = InterlockedDecrement((LPLONG)&GlobalInternetOpenHandleCount);
//
//                 if ( lOpenHandleCnt < 0 )
//                 {
//                     GlobalProxyInfo.FreeAutoProxyInfo();                     
//                     GlobalProxyInfo.SetRefreshDisabled(TRUE);
//                 }
//             }
//        }
    }

    DEBUG_LEAVE(0);
}

HINTERNET
INTERNET_HANDLE_OBJECT::GetInternetHandle(
    VOID
    )
{
    return _INetHandle;
}

HINTERNET
INTERNET_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _INetHandle;
}

VOID
INTERNET_HANDLE_OBJECT::SetTimeout(
    IN DWORD TimeoutOption,
    IN DWORD TimeoutValue
    )
{
    switch (TimeoutOption) {
    case INTERNET_OPTION_SEND_TIMEOUT:
        _SendTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_RECEIVE_TIMEOUT:
        _ReceiveTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_DATA_SEND_TIMEOUT:
        _DataSendTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
        _DataReceiveTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_CONNECT_TIMEOUT:
        _ConnectTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_CONNECT_RETRIES:
        _ConnectRetries = TimeoutValue;
        break;

    case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
        _FromCacheTimeout = TimeoutValue;
        break;
    }
}

DWORD
INTERNET_HANDLE_OBJECT::GetTimeout(
    IN DWORD TimeoutOption
    )
{
    switch (TimeoutOption) {
    case INTERNET_OPTION_SEND_TIMEOUT:
        return _SendTimeout;

    case INTERNET_OPTION_RECEIVE_TIMEOUT:
        return _ReceiveTimeout;

    case INTERNET_OPTION_DATA_SEND_TIMEOUT:
        return _DataSendTimeout;

    case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
        return _DataReceiveTimeout;

    case INTERNET_OPTION_CONNECT_TIMEOUT:
        return _ConnectTimeout;

    case INTERNET_OPTION_CONNECT_RETRIES:
        return _ConnectRetries;

    case INTERNET_OPTION_CONNECT_BACKOFF:
        return 0;   // Backoff no longer used

    case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
        return _FromCacheTimeout;

    case INTERNET_OPTION_LISTEN_TIMEOUT:

        //
        // BUGBUG - not per-object
        //

        return GlobalFtpAcceptTimeout;
    }

    INET_ASSERT(FALSE);

    //
    // we should not be here, but in case we are, return a random timeout
    //

    return DEFAULT_CONNECT_TIMEOUT;
}

//VOID INTERNET_HANDLE_OBJECT::AcquireAsyncSpinLock(VOID) {
//
//    //
//    // wait until we're the exclusive owner of the async info
//    //
//
//    while (TRUE) {
//        if (InterlockedIncrement(&_AsyncClashTest) == 0) {
//            return;
//        } else {
//            InterlockedDecrement(&_AsyncClashTest);
//            Sleep(0);
//        }
//    }
//}
//
//VOID INTERNET_HANDLE_OBJECT::ReleaseAsyncSpinLock(VOID) {
//    InterlockedDecrement(&_AsyncClashTest);
//}

DWORD
INTERNET_HANDLE_OBJECT::ExchangeStatusCallback(
    LPINTERNET_STATUS_CALLBACK lpStatusCallback,
    BOOL fType
    )
{
    DWORD error;

    //
    // we can only change the status callback if there are no async requests
    // pending
    //

    //AcquireAsyncSpinLock();

    //
    // BUGBUG - RFirth 03/16/98 - _PendingAsyncRequests is no longer being
    //          updated. It is always 0, hence always safe to change. Since
    //          no-one (that we know of) does this, we can let it go for
    //          now, but it needs to be fixed by RTM
    //
    //          (R)AddAsyncRequest() and (R)RemoveAsyncRequest() have been
    //          commented-out until this is fixed
    //

    //if (_PendingAsyncRequests == 0) {

        INTERNET_STATUS_CALLBACK callback;

        //
        // exchange new and current callbacks
        //

        callback = _StatusCallback;
        _StatusCallback = *lpStatusCallback;
        *lpStatusCallback = callback;
        _StatusCallbackType = fType;
        error = ERROR_SUCCESS;
    //} else {
    //    error = ERROR_INTERNET_REQUEST_PENDING;
    //}
    //
    //ReleaseAsyncSpinLock();

    return error;
}

//DWORD INTERNET_HANDLE_OBJECT::AddAsyncRequest(BOOL fNoCallbackOK) {
//    DWORD error;
//
//    AcquireAsyncSpinLock();
//
//    if (fNoCallbackOK || _StatusCallback != NULL) {
//        ++_PendingAsyncRequests;
//
//        INET_ASSERT(_PendingAsyncRequests > 0);
//
//        error = ERROR_SUCCESS;
//    } else {
//
//        INET_ASSERT(_PendingAsyncRequests == 0);
//
//        error = ERROR_INTERNET_NO_CALLBACK;
//    }
//
//    ReleaseAsyncSpinLock();
//
//    return error;
//}
//
//VOID INTERNET_HANDLE_OBJECT::RemoveAsyncRequest(VOID) {
//
//    INET_ASSERT(_PendingAsyncRequests > 0);
//
//    InterlockedDecrement(&_PendingAsyncRequests);
//}


VOID
INTERNET_HANDLE_OBJECT::SetAbortHandle(
    IN ICSocket * Socket
    )

/*++

Routine Description:

    Associates with this request handle the ICSocket object currently being used
    for network I/O

Arguments:

    Socket  - pointer to ICSocket

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_OBJECT::SetAbortHandle",
                 "{%#x} %#x [sock=%#x ref=%d]",
                 GetPseudoHandle(),
                 Socket,
                 Socket ? Socket->GetSocket() : 0,
                 Socket ? Socket->ReferenceCount() : 0
                 ));

    INET_ASSERT(Socket != NULL);

    //
    // first off, increase the socket reference count to stop any other threads
    // killing it whilst we are performing the socket operation. The only way
    // another thread can dereference the socket is by calling our AbortSocket()
    // method
    //

    Socket->Reference();

    //
    // now associate the socket object with this handle object. We should not
    // have a current association
    //

    ICSocket * pSocket;

    pSocket = (ICSocket *) InterlockedExchangePointer((PVOID*)&_pICSocket, Socket);

    //
    // because ConnectSocket() can call this method multiple times without
    // intervening calls to ResetAbortHandle(), pSocket can legitimately be
    // non-NULL at this point
    //

    //INET_ASSERT(pSocket == NULL);

    //
    // if the handle was invalidated on another thread before we got
    // chance to set the socket to close, then abort the request now
    //

    //
    // BUGBUG - screws up normal FTP close handle processing - we
    //          have to communicate with the server in order to
    //          drop the connection
    //

    //if (IsInvalidated()) {
    //    AbortSocket();
    //}

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::ResetAbortHandle(
    VOID
    )

/*++

Routine Description:

    Disassociates this request handle and the ICSocket object when the network
    operation has completed

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_OBJECT::ResetAbortHandle",
                 "{%#x}",
                 GetPseudoHandle()
                 ));

    //
    // there really should be a ICSocket associated with this object, otherwise
    // our handle close/invalidation logic is broken
    //

    //
    // however, we can call ResetAbortHandle() from paths where we completed
    // early, not having called SetAbortHandle()
    //

    //INET_ASSERT(pSocket != NULL);

    //
    // so if there was a ICSocket associated with this object then remove the
    // reference added in SetAbortHandle()
    //


    ICSocket * pICSocket;

    pICSocket = (ICSocket *)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pICSocket != NULL) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket=%#x ref=%d\n",
                    pICSocket->GetSocket(),
                    pICSocket->ReferenceCount()
                    ));

        pICSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::AbortSocket(
    VOID
    )

/*++

Routine Description:

    If there is a ICSocket associated with this handle object then abort it. This
    forces the current network operation aborted and the request to complete
    with ERROR_INTERNET_OPERATION_CANCELLED

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_OBJECT::AbortSocket",
                 "{%#x, %#x [sock=%#x, ref=%d]}",
                 GetPseudoHandle(),
                 (_pICSocket != NULL)
                    ? (LPVOID)_pICSocket
                    : (LPVOID)_pICSocket,
                 _pICSocket
                    ? _pICSocket->GetSocket()
                    : (_pICSocket
                        ? _pICSocket->GetSocket()
                        : 0),
                 _pICSocket
                    ? _pICSocket->ReferenceCount()
                    : (_pICSocket
                        ? _pICSocket->ReferenceCount()
                        : 0)
                 ));

    //
    // get the associated ICSocket. It may have already been removed by a call
    // to ResetAbortHandle()
    //

    //
    // if there is an associated ICSocket then abort it (close the socket handle)
    // which will complete the current network I/O (if active) with an error.
    // Once the ICSocket is aborted, we reduce the reference count that was added
    // in SetAbortHandle(). This may cause the ICSocket to be deleted
    //

    LPVOID pAddr;

    pAddr = (LPVOID)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pAddr != NULL) {

        ICSocket * pSocket = (ICSocket *)pAddr;
//dprintf(">>>>>>>> %#x AbortSocket %#x [%#x]\n", GetCurrentThreadId(), pSocket, pSocket->GetSocket());
        pSocket->Abort();
        pSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::CheckGlobalProxyUpdated(
    VOID
    )

/*++

Routine Description:

    Tests whether we need to update the global proxy info structure from the registry

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_INET,
                None,
                "INTERNET_HANDLE_OBJECT::CheckGlobalProxyUpdated",
                NULL
                ));

    if (IsProxyGlobal() && InternetSettingsChanged()) {

        //
        // acquire the pointer for exclusive access
        //

        AcquireProxyInfo(TRUE);

        //
        // check to make sure we are still using the global proxy info
        //

        if (IsProxyGlobal() && !GlobalProxyInfo.IsModifiedInProcess()) {
            //GlobalProxyInfo.SetProxyInfo(INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL);
        }
        ReleaseProxyInfo();

//dprintf("CheckGlobalProxyUpdated()\n");
        ChangeGlobalSettings();
    }

    DEBUG_LEAVE(0);
}

DWORD
INTERNET_HANDLE_OBJECT::Refresh(
    IN DWORD dwInfoLevel
    ) 
/*++

Routine Description:

    Refreshes the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    dwInfoLevel     -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

--*/
{

    if (dwInfoLevel == 0) {

        DWORD error;

        //
        // this refresh value means reload the proxy info from registry,
        // but we ONLY do this if we're using the global proxy info AND
        // we haven't set it to something other than the registry contents
        //

        if (IsProxyGlobal() && !GlobalProxyInfo.IsModifiedInProcess()) {

            FixProxySettingsForCurrentConnection(TRUE);
            return ERROR_SUCCESS;

        } else {

            //
            // not using global proxy or it has been set to something other
            // than the registry contents. Just return success
            //

            return ERROR_SUCCESS;
        }
    } else {
        return ERROR_INVALID_PARAMETER;
    }
}



DWORD
INTERNET_HANDLE_OBJECT::SetProxyInfo(
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL
    )

/*++

Routine Description:

    Sets the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    dwAccessType    - type of proxy access required

    lpszProxy       - pointer to proxy server list

    lpszProxyBypass - pointer to proxy bypass list

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_OBJECT::SetProxyInfo",
                "%s (%d), %#x (%q), %#x (%q)",
                InternetMapOpenType(dwAccessType),
                dwAccessType,
                lpszProxy,
                lpszProxy,
                lpszProxyBypass,
                lpszProxyBypass
                ));

    //
    // we only set proxy information on the top-level InternetOpen() handle
    //

    INET_ASSERT(!IsCopy());

/*

    We are setting the proxy information for an InternetOpen() handle. Based on
    the current and new settings we do the following (Note: the handle is
    initialized to DIRECT operation):

                                        current access
                +---------------------------------------------------------------
        new     |      DIRECT        |       PROXY        |      PRECONFIG
       access   |                    |                    |
    +-----------+--------------------+--------------------+---------------------
    | DIRECT    | No action          | Delete proxy info  | Remove reference to
    |           |                    |                    | global proxy info
    +-----------+--------------------+--------------------+---------------------
    | PROXY     | Set new proxy info | Delete proxy info. | Remove reference to
    |           |                    | Set new proxy info | global proxy info.
    |           |                    |                    | Set new proxy info
    +-----------+--------------------+--------------------+---------------------
    | PRECONFIG | Set proxy info to  | Delete proxy info. | No action
    |           | global proxy info  | Set proxy info to  |
    |           |                    | global proxy info  |
    +-----------+--------------------+--------------------+---------------------
*/

    DWORD error = ERROR_SUCCESS;
    PROXY_INFO * proxyInfo = NULL;

    //
    // acquire proxy info for exclusive access
    //

    AcquireProxyInfo(TRUE);

    if (IsProxy()) {

        //
        // delete private proxy info, or unlink from global proxy info
        //

        SafeDeleteProxyInfo();
    }

    //
    // Map Various Proxy types to their internal counterparts,
    //   note that I've ordered them in what I think is their 
    //   use frequency (how often each one is most likely to get hit).
    //

    switch (dwAccessType)
    {
        case INTERNET_OPEN_TYPE_PRECONFIG:
            proxyInfo = &GlobalProxyInfo;
            break;

        case INTERNET_OPEN_TYPE_DIRECT:
            proxyInfo = NULL;
            break;

        case INTERNET_OPEN_TYPE_PROXY:     
            {
                INET_ASSERT(!IsProxy());

                proxyInfo = new PROXY_INFO;
                if (proxyInfo != NULL) {
                    proxyInfo->InitializeProxySettings();
                    error = proxyInfo->GetError();
                    if (error == ERROR_SUCCESS &&
                        lpszProxy ) 
                    {

                        INTERNET_PROXY_INFO_EX info;
                        memset(&info, 0, sizeof(info));
                        info.dwStructSize = sizeof(info);
                        info.dwFlags = (PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY);

                        info.lpszProxy = lpszProxy;
                        info.lpszProxyBypass = lpszProxyBypass;

                        error = proxyInfo->SetProxySettings(&info, TRUE /*modified*/);

                    }
                    if (error != ERROR_SUCCESS) {
                        delete proxyInfo;
                        proxyInfo = NULL;
                    }
                } else {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }

                break;
            }

        case INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY:
            {
                proxyInfo = new PROXY_INFO_GLOBAL_WRAPPER;
                if (proxyInfo == NULL) {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
                break;
            }

        default:
            proxyInfo = NULL;
            break;
    }

    SetProxyInfo(proxyInfo);

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_OBJECT::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the current proxy information for this INTERNET_HANDLE_OBJECT

Arguments:

    lpBuffer            - pointer to buffer where INTERNET_PROXY_INFO will be
                          written, and any proxy strings (if sufficient space)

    lpdwBufferLength    - IN: number of bytes in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer doesn't have enough space to hold the proxy
                    information. *lpdwBufferLength has the required size

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_OBJECT::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                lpdwBufferLength ? *lpdwBufferLength : 0
                ));

    INET_ASSERT(!IsCopy());

    AcquireProxyInfo(FALSE);

    DWORD error;

    if (IsProxy()) {
        error = _ProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
    } else {
        if (*lpdwBufferLength >= sizeof(INTERNET_PROXY_INFO)) {

            LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

            lpInfo->dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
            lpInfo->lpszProxy = NULL;
            lpInfo->lpszProxyBypass = NULL;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        *lpdwBufferLength = sizeof(INTERNET_PROXY_INFO);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_OBJECT::GetProxyInfo(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Returns all proxy information based on a protocol scheme

Arguments:

    tProtocol           - protocol to get proxy info for

    lptScheme           - returned scheme

    lplpszHostName      - returned proxy name

    lpdwHostNameLength  - returned length of proxy name

    lpHostPort          - returned proxy port

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "INTERNET_HANDLE_OBJECT::GetProxyInfo",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT(!IsCopy());

    DWORD error;
    BOOL rc;

    //if (IsProxyGlobal()) {
    //    CheckGlobalProxyUpdated();
    //}

    AcquireProxyInfo(FALSE);

    if ( _ProxyInfo )
    {
        error = _ProxyInfo->QueryProxySettings(ppQueryForProxyInfo);
    }
    else
    {
        error = ERROR_SUCCESS;
        (*ppQueryForProxyInfo)->SetUseProxy(FALSE);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
INTERNET_HANDLE_OBJECT::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
{

    INET_ASSERT(!IsCopy());

    BOOL rc;

   AcquireProxyInfo(FALSE);

    if ( _ProxyInfo )
    {
        rc = _ProxyInfo->RedoSendRequest(
                                         lpdwError,
                                         pQueryForProxyInfo,
                                         pOriginServer,
                                         pProxyServer
                                         );
    }
    else
    {
        rc = FALSE;
    }

    ReleaseProxyInfo();

    return rc;
}

VOID
UnicodeStatusCallbackWrapper(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
)
{
    DWORD dwErr = ERROR_SUCCESS;
    INTERNET_STATUS_CALLBACK iscCallback;
    INET_ASSERT(hInternet != NULL);
    MEMORYPACKET mpBuffer;
    HINTERNET hInternetMapped = NULL;

    dwErr = MapHandleToAddress(hInternet, (LPVOID*)&hInternetMapped, FALSE);
    if (dwErr!=ERROR_SUCCESS)
        goto Cleanup;

    dwErr = ((HANDLE_OBJECT *)hInternetMapped)->IsValid(TypeWildHandle);
    if (dwErr==ERROR_SUCCESS)
    {
        iscCallback = ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->GetTrueStatusCallback();
        INET_ASSERT(iscCallback);

        switch (dwInternetStatus)
        {
        case INTERNET_STATUS_RESOLVING_NAME:
        case INTERNET_STATUS_NAME_RESOLVED:
        case INTERNET_STATUS_REDIRECT:
        case INTERNET_STATUS_CONNECTING_TO_SERVER:
        case INTERNET_STATUS_CONNECTED_TO_SERVER:
            mpBuffer.dwSize = dwStatusInformationLength;
            if (lpvStatusInformation)
            {
                mpBuffer.dwAlloc = (MultiByteToWideChar(CP_ACP,0,(LPSTR)lpvStatusInformation,-1,NULL,0)+1)
                                    *sizeof(WCHAR);
                mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc);
                if (!mpBuffer.psStr)
                {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    goto Cleanup;
                }
                mpBuffer.dwSize = MultiByteToWideChar(CP_ACP,0,(LPSTR)lpvStatusInformation,-1,
                                    (LPWSTR)mpBuffer.psStr, mpBuffer.dwAlloc/sizeof(WCHAR));
            }
            iscCallback(hInternet, dwContext, dwInternetStatus, (LPVOID)mpBuffer.psStr,
                    mpBuffer.dwSize);
            break;

        default:
            iscCallback(hInternet, dwContext, dwInternetStatus, lpvStatusInformation,
                dwStatusInformationLength);
        }
    }

Cleanup:
    if (hInternetMapped)
    {
        DereferenceObject(hInternetMapped);
    }
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\handles\ftp.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftp.cxx

Abstract:

    Contains methods for FTP_FIND_HANDLE_OBJECT and FTP_FILE_HANDLE_OBJECT classes

    Contents:
        RMakeFtpFindObjectHandle
        RMakeFtpFileObjectHandle
        RMakeFtpErrorObjectHandle
        FTP_ERROR_HANDLE_OBJECT::SetErrorText
        FTP_ERROR_HANDLE_OBJECT::QueryHtmlDataAvailable

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeFtpFindObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating an FTP_FIND_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of FTP_FIND_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    FTP_FIND_HANDLE_OBJECT * hFind;

    hFind = new FTP_FIND_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwContext
                    );

    if (hFind != NULL) {
        error = hFind->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hFind);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hFind = NULL;
            }
        } else {
            delete hFind;
            hFind = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hFind;

    return error;
}


DWORD
RMakeFtpFileObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating an FTP_FILE_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of FTP_FILE_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    FTP_FILE_HANDLE_OBJECT * hFile;
    DEBUG_PRINT(FTP,
                INFO,
                ("RMakeFtpFileObject(0x%x 0x%x 0x%x 0x%x)\r\n", 
                ParentHandle, ChildHandle, wCloseFunc, dwContext));


    hFile = new FTP_FILE_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwContext
                    );

    if (hFile != NULL) {
        error = hFile->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hFile);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hFile = NULL;
            }
        } else {
            delete hFile;
            hFile = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hFile;

    return error;
}

#ifdef EXTENDED_ERROR_HTML

DWORD
RMakeFtpErrorObjectHandle(
    IN HINTERNET hConnect,
    OUT LPHINTERNET lphError
    )

/*++

Routine Description:

    Creates an FTP_ERROR_HANDLE_OBJECT. Used to return extended error info as
    HTML

Arguments:

    hConnect    - pointer to INTERNET_CONNECT_HANDLE_OBJECT

    lphError    - pointer to returned FTP_ERROR_HANDLE_OBJECT

Return Value:

    DWORD

--*/

{
    FTP_ERROR_HANDLE_OBJECT * hError;

    hError = new FTP_ERROR_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)hConnect
                    );

    DWORD error;

    if (hError != NULL) {
        error = hError->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hError);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hError = NULL;
            }
        } else {
            delete hError;
            hError = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *lphError = (HINTERNET)hError;

    return error;
}
#endif

//
// FTP_FIND_HANDLE_OJBECT class implementation
//

FTP_FIND_HANDLE_OBJECT::FTP_FIND_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)
{
    _FindHandle = Child;
    _wCloseFunction = wCloseFunc;
    _dwFtpFindBools = 0;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _Context = dwContext;
    SetObjectType(TypeFtpFindHandle);
}

FTP_FIND_HANDLE_OBJECT::~FTP_FIND_HANDLE_OBJECT(
    VOID
    )
{
    //
    // if local internet handle, closed by local close function
    //

    if (_FindHandle != NULL) {
        _Status = _wCloseFunction(_FindHandle);

        //INET_ASSERT(_Status == ERROR_SUCCESS);

    } else {
        _Status = ERROR_SUCCESS;
    }

    //
    // clear out any strings we allocated
    //

    if (_lpszUrl != NULL) {
        DEL_STRING(_lpszUrl);
    }
    if (_lpszDirEntry != NULL) {
        DEL_STRING(_lpszDirEntry);
    }

    //
    // and the query buffer
    //

    FreeQueryBuffer();
}

HANDLE
FTP_FIND_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _FindHandle;
}

DWORD
FTP_FIND_HANDLE_OBJECT::QueryHtmlDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )
{
    DWORD error;

    if (_QueryBuffer != NULL) {
        error = ERROR_SUCCESS;
    } else {
        error = AllocateQueryBuffer();
    }

    INET_ASSERT(_QueryBytesAvailable == 0);

    if (error == ERROR_SUCCESS) {
        _QueryOffset = 0;
        if (ReadHtmlUrlData((HINTERNET)this,
                            _QueryBuffer,
                            _QueryBufferLength,
                            lpdwNumberOfBytesAvailable
                            )) {
            _QueryBytesAvailable = *lpdwNumberOfBytesAvailable;
            //SetAvailableDataLength(_QueryBytesAvailable);
            if (_QueryBytesAvailable == 0) {
                SetEndOfFile();
            }
        } else {
            error = GetLastError();
        }
    }
    return error;
}

//
// FTP_FILE_HANDLE_OJBECT class implementation
//

FTP_FILE_HANDLE_OBJECT::FTP_FILE_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)
{
    _FileHandle = Child;
    _wCloseFunction = wCloseFunc;
    _IsHtml = FALSE;
    _lpszFileName = NULL;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _Context = dwContext;
    SetObjectType(TypeFtpFileHandle);
}

FTP_FILE_HANDLE_OBJECT::~FTP_FILE_HANDLE_OBJECT(
    VOID
    )
{

    //
    // if local internet handle, closed by local close function
    //

    if (_FileHandle != NULL) {
        _Status = _wCloseFunction(_FileHandle);

        //INET_ASSERT(_Status == ERROR_SUCCESS);

    } else {
        _Status = ERROR_INVALID_HANDLE;
    }

    //
    // clear out any strings we allocated
    //

    if (_lpszUrl != NULL) {
        DEL_STRING(_lpszUrl);
    }
    if (_lpszDirEntry != NULL) {
        DEL_STRING(_lpszDirEntry);
    }
    if (_lpszFileName != NULL) {
        DEL_STRING(_lpszFileName);
    }
}

HINTERNET
FTP_FILE_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _FileHandle;
}

#ifdef EXTENDED_ERROR_HTML

//
// FTP_ERROR_HANDLE_OBJECT class implementation
//

FTP_ERROR_HANDLE_OBJECT::FTP_ERROR_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT* hConnect
    ) : INTERNET_CONNECT_HANDLE_OBJECT(hConnect)
{
    m_lpszErrorText = NULL;
    m_dwErrorTextLength = 0;
    m_QueryBuffer = NULL;
    m_QueryBufferLength = 0;
    m_QueryOffset = 0;
    m_QueryBytesAvailable = 0;
    m_HtmlState = HTML_STATE_START;
    SetObjectType(TypeFtpFileHandle);
    SetErrorText();
}

FTP_ERROR_HANDLE_OBJECT::~FTP_ERROR_HANDLE_OBJECT(
    VOID
    )
{
    //
    // clear out any strings we allocated
    //

    if (m_lpszErrorText != NULL) {
        DEL_STRING(m_lpszErrorText);
    }

    //
    // and the query buffer
    //

    FreeQueryBuffer();
}

DWORD
FTP_ERROR_HANDLE_OBJECT::SetErrorText(
    VOID
    )

/*++

Routine Description:

    Copies last error info to this handle object

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    INET_ASSERT(m_lpszErrorText == NULL);
    INET_ASSERT(m_dwErrorTextLength == 0);

    DWORD error;
    DWORD category;

    if (!InternetGetLastResponseInfo(&category, NULL, &m_dwErrorTextLength)) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            m_lpszErrorText = (LPSTR)ALLOCATE_MEMORY(
                                        LMEM_FIXED,
                                        m_dwErrorTextLength
                                        );
            if (m_lpszErrorText != NULL) {
                if (!InternetGetLastResponseInfo(&category,
                                                 m_lpszErrorText,
                                                 &m_dwErrorTextLength)) {
                    m_lpszErrorText[0] = '\0';
                    m_dwErrorTextLength = 0;
                }
                error = ERROR_SUCCESS;
            } else {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return error;
}

DWORD
FTP_ERROR_HANDLE_OBJECT::QueryHtmlDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )
{
    DWORD error;

    if (m_QueryBuffer != NULL) {
        error = ERROR_SUCCESS;
    } else {
        error = AllocateQueryBuffer();
    }

    INET_ASSERT(m_QueryBytesAvailable == 0);

    if (error == ERROR_SUCCESS) {
        m_QueryOffset = 0;
        if (ReadHtmlUrlData((HINTERNET)this,
                            m_QueryBuffer,
                            m_QueryBufferLength,
                            lpdwNumberOfBytesAvailable
                            )) {
            m_QueryBytesAvailable = *lpdwNumberOfBytesAvailable;
            if (m_QueryBytesAvailable == 0) {
                SetEndOfFile();
            }
        } else {
            error = GetLastError();
        }
    }
    return error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\handles\hutil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hutil.cxx

Abstract:

    contains outdated c-c++ interface functions

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle,
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    )
{
    BOOL fLocalHandle;
    DWORD Error;
    HANDLE_OBJECT *HandleObj;
    HINTERNET InternetHandle;

    HandleObj = (HANDLE_OBJECT *)Handle;

    Error = HandleObj->IsValid(ExpectedHandleType);
    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    InternetHandle = HandleObj->GetInternetHandle();

#if 0
    if( InternetHandle == INET_INVALID_HANDLE_VALUE ) {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }
#endif // 0

    if( InternetHandle == LOCAL_INET_HANDLE ) {
        fLocalHandle = TRUE;
    }
    else {

        //
        // is a remote handle.
        //

        fLocalHandle = FALSE;
    }

    *IsLocalHandle = fLocalHandle;
    *IsAsyncHandle = ((INTERNET_HANDLE_OBJECT *)Handle)->IsAsyncHandle();
    Error = ERROR_SUCCESS;

Cleanup:

    return( Error );
}

DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // find the handle type.
        //

        *HandleType = HandleObj->GetHandleType();
    }
    return error;
}

DWORD
RSetHtmlHandleType(
    HINTERNET Handle
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    HINTERNET_HANDLE_TYPE handleType;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // find the handle type.
    //

    handleType = HandleObj->GetHandleType();

    //
    // if the handle type is one of those that can be accessed as RAW data or
    // HTML, then set the HTML flag. HTTP requests are HTML by default. Setting
    // HTML data for any other handle type is an error.
    //
    // Originally, we allowed File and Find handles to be HTML-ised, but we now
    // only allow Find handles: files are returned via the normal mechanism
    //

    if ((handleType == TypeFtpFindHandle)
    || (handleType == TypeGopherFindHandle)) {
        HandleObj->SetHtml();
        return ERROR_SUCCESS;
    } else if (handleType == TypeHttpRequestHandle) {
        return ERROR_SUCCESS;
    } else {
        return ERROR_INTERNET_INVALID_OPERATION;
    }
}

DWORD
RSetHtmlState(
    HINTERNET Handle,
    HTML_STATE State
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        HandleObj->SetHtmlState(State);
    }
    return error;
}

DWORD
RGetHtmlState(
    HINTERNET Handle,
    LPHTML_STATE lpState
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpState = HandleObj->GetHtmlState();
    }
    return error;
}

DWORD
RSetUrl(
    HINTERNET Handle,
    LPSTR lpszUrl
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        LPSTR url;

        url = HandleObj->GetUrl();
        if (url != NULL) {
            DEL_STRING(url);
        }
        if (lpszUrl != NULL) {
            url = NEW_STRING(lpszUrl);
            if (url == NULL) {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            url = NULL;
        }
        if (error == ERROR_SUCCESS) {
            HandleObj->SetUrl(url);
        }
    }
    return error;
}

DWORD
RGetUrl(
    HINTERNET Handle,
    LPSTR* lpszUrl
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpszUrl = HandleObj->GetUrl();
    }
    return error;
}

DWORD
RSetDirEntry(
    HINTERNET Handle,
    LPSTR lpszDirEntry
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    LPSTR dirEntry;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error != ERROR_SUCCESS ) {
        return error;
    }

    dirEntry = HandleObj->GetDirEntry();

    if (dirEntry != NULL) {

        //
        // we should not be replacing one non-NULL dir entry with another
        //

        INET_ASSERT(lpszDirEntry == NULL);

        DEL_STRING(dirEntry);
    }

    //
    // make a copy of the string and add it to the object
    //

    if (lpszDirEntry != NULL) {
        dirEntry = NEW_STRING(lpszDirEntry);
        if (dirEntry == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        dirEntry = NULL;
    }
    HandleObj->SetDirEntry(dirEntry);
    return ERROR_SUCCESS;
}

DWORD
RGetDirEntry(
    HINTERNET Handle,
    LPSTR* lpszDirEntry
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpszDirEntry = HandleObj->GetDirEntry();
    }
    return error;
}

DWORD
RSetParentHandle(
    HINTERNET hChild,
    HINTERNET hParent,
    BOOL DeleteWithChild
    )
{
    DWORD error;

    //
    // ensure the child handle is valid
    //

    error = ((HANDLE_OBJECT*)hChild)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // and so too the parent
        //

        error = ((HANDLE_OBJECT*)hParent)->IsValid(TypeWildHandle);
        if (error == ERROR_SUCCESS) {

            //
            // make the association
            //

            ((HANDLE_OBJECT*)hChild)->SetParent(hParent, DeleteWithChild);
        }
    }
    return error;
}

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpdwContext = ((INTERNET_HANDLE_OBJECT*)hInternet)->GetContext();
    }
    return error;
}

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT*)hInternet)->SetContext(dwContext);
    }
    return error;
}

DWORD
RGetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    LPDWORD lpdwTimeoutValue
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpdwTimeoutValue = ((INTERNET_HANDLE_OBJECT*)hInternet)->GetTimeout(dwTimeoutOption);
    }
    return error;
}

DWORD
RSetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    DWORD dwTimeoutValue
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT*)hInternet)->SetTimeout(dwTimeoutOption, dwTimeoutValue);
    }
    return error;
}

DWORD
RGetBufferSize(
    HINTERNET hInternet,
    DWORD dwBufferSizeOption,
    LPDWORD lpdwBufferSize
    )
{
    DWORD error;

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // BUGBUG - this handle must be a connect handle, or object derived from
        //          connect handle
        //

        *lpdwBufferSize = ((INTERNET_CONNECT_HANDLE_OBJECT*)hInternet)
            ->GetBufferSize(dwBufferSizeOption);
    }
    return error;
}

DWORD
RSetBufferSize(
    HINTERNET hInternet,
    DWORD dwBufferSizeOption,
    DWORD dwBufferSize
    )
{
    DWORD error;

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // BUGBUG - this handle must be a connect handle, or object derived from
        //          connect handle
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT*)hInternet)->SetBufferSize(
            dwBufferSizeOption,
            dwBufferSize
            );
    }
    return error;
}

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPINTERNET_STATUS_CALLBACK lpStatusCallback
    )
{
    //
    // NULL handle should have been caught before we got here
    // (its in InternetQueryOption())
    //

    INET_ASSERT(Handle != NULL);

    *lpStatusCallback = ((INTERNET_HANDLE_OBJECT *)Handle)->GetStatusCallback();
    return ERROR_SUCCESS;
}

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPINTERNET_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType)
{
    DWORD error;

    //
    // NULL handle value should have been caught already
    // (in InternetSetStatusCallback())
    //

    INET_ASSERT(Handle != NULL);

    error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        error = ((INTERNET_HANDLE_OBJECT *)Handle)->
                                ExchangeStatusCallback(lpStatusCallback, fType);
    }
    return error;
}

//DWORD
//RAddAsyncRequest(
//    IN HINTERNET Handle,
//    BOOL fNoCallbackOK
//    )
//{
//    DWORD error;
//
//    if (Handle != NULL) {
//        error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
//        if (error == ERROR_SUCCESS) {
//            error = ((INTERNET_HANDLE_OBJECT *)Handle)->AddAsyncRequest(fNoCallbackOK);
//        }
//    } else {
//        error = ERROR_INVALID_HANDLE;
//    }
//    return error;
//}
//
//DWORD
//RRemoveAsyncRequest(
//    IN HINTERNET Handle
//    )
//{
//    DWORD error;
//
//    if (Handle != NULL) {
//        error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
//        if (error == ERROR_SUCCESS) {
//            ((INTERNET_HANDLE_OBJECT *)Handle)->RemoveAsyncRequest();
//        }
//    } else {
//        error = ERROR_INVALID_HANDLE;
//    }
//    return error;
//}

DWORD
RGetLocalHandle(
    HINTERNET Handle,
    HINTERNET *LocalHandle
    )
{
    DWORD Error;
    HANDLE_OBJECT *ObjectHandle = (HANDLE_OBJECT *)Handle;

#if 1
    Error = ObjectHandle->IsValid(TypeWildHandle);
    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }
#endif // DBG

    Error = ObjectHandle->GetStatus();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    *LocalHandle = ObjectHandle->GetHandle();

Cleanup:

    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\handles\proxysup.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    proxysup.cxx

Abstract:

    Contains class implementation for proxy server and proxy bypass list

    Contents:
        IsLocalMacro

        PROXY_SERVER_LIST_ENTRY::WriteEntry

        PROXY_SERVER_LIST::AddList
        PROXY_SERVER_LIST::Find
        PROXY_SERVER_LIST::Add
        PROXY_SERVER_LIST::ProxyScheme
        PROXY_SERVER_LIST::GetProxyHostName
        PROXY_SERVER_LIST::AddToBypassList
        PROXY_SERVER_LIST::GetList

        PROXY_BYPASS_LIST_ENTRY::WriteEntry

        PROXY_BYPASS_LIST::AddList
        PROXY_BYPASS_LIST::Find
        PROXY_BYPASS_LIST::Add
        PROXY_BYPASS_LIST::IsBypassed
        PROXY_BYPASS_LIST::IsHostInBypassList
        PROXY_BYPASS_LIST::GetList

        PROXY_INFO::GetProxyStringInfo
        PROXY_INFO::HostBypassesProxy
        PROXY_INFO::RedoSendRequest
        PROXY_INFO::Terminate
        PROXY_INFO::CleanOutLists

        PROXY_STATE::GetNextProxy

        (GetRegistryProxyParameter)

Author:

    Richard L Firth (rfirth) 03-Feb-1996

Revision History:

    03-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define DEFAULT_PROXY_BUFFER_LENGTH     (4 K)
#define MAX_IP_ADDRESS_STRING_LENGTH    (4 * 4 - 1) // ###.###.###.###
#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// private types
//

typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;


//
// private prototypes
//

PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    );





//
// functions
//


BOOL
IsLocalMacro(
    IN LPSTR lpszMetaName,
    IN DWORD dwMetaNameLength
    )

/*++

Routine Description:

    Checks for local macro name

Arguments:

    lpszMetaName        - name to check

    dwMetaNameLength    - length

Return Value:

    BOOL
        TRUE    - it is <local>

        FALSE   - not

--*/

{
    INET_ASSERT(lpszMetaName != NULL);

    static const char s_local[] = "<local>";

    return (strnicmp(s_local, lpszMetaName, dwMetaNameLength) == 0);
}


//PRIVATE
//BOOL
//IsNetscapeProxyListString(
//    IN LPSTR lpszProxyStr,
//    IN DWORD dwcbProxyStr
//    )
//
///*++
//
//Routine Description:
//
//    Determines if a string is part of a Netscape style multiple proxy list.
//
//Arguments:
//
//    lpszProxyStr - The string to examine
//
//    dwcbProxyStr - Size of the string to check.
//
//Return Value:
//
//    BOOL
//        TRUE    - if its a Netscape list of proxies.
//
//        FALSE   - its just a proxy name.
//
//--*/
//
//{
//    INET_ASSERT(lpszProxyStr);
//    INET_ASSERT(dwcbProxyStr > 0);
//
//    SKIPWS(lpszProxyStr);
//
//    //
//    // If it SOCKS, PROXY, or DIRECT (and) there is some delimiter
//    //  we accept it as a Netscape Proxy String.
//    //
//
//    if ( strncmp( lpszProxyStr, "DIRECT", min(dwcbProxyStr, sizeof("DIRECT")-1) ) == 0  )
//    {
//        return TRUE;
//    }
//
//    if ( strncmp( lpszProxyStr, "PROXY",  min(dwcbProxyStr, sizeof("PROXY")-1) )  == 0  ||
//         strncmp( lpszProxyStr, "SOCKS",  min(dwcbProxyStr, sizeof("SOCKS")-1) )  == 0   )
//    {
//        for ( DWORD i = 0; i < dwcbProxyStr; i++ )
//        {
//            if ( lpszProxyStr[i] == ':' || lpszProxyStr[i] == ';' )
//            {
//                return TRUE;
//            }
//        }
//    }
//
//    return FALSE;
//}


//
// member functions
//


BOOL
PROXY_SERVER_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy server list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR protocolName;
    DWORD protocolNameLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude;

    protocolName = MapUrlScheme(_Protocol, &protocolNameLength);
    if (protocolName != NULL) {
        requiredLength = protocolNameLength + 1;    // for '='
    } else {
        requiredLength = 0;
    }
    schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
    if (schemeName != NULL) {
        requiredLength += schemeNameLength + sizeof("://") - 1;
    }
    requiredLength += _ProxyName.StringLength();
    if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_ProxyPort / n) {
                requiredLength += i + 1;    // for ':'
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (protocolName != NULL) {
            memcpy(lpszBuffer, protocolName, protocolNameLength);
            lpszBuffer += protocolNameLength;
            *lpszBuffer++ = '=';
        }
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        _ProxyName.CopyTo(lpszBuffer);
        lpszBuffer += _ProxyName.StringLength();
        if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _ProxyPort, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_SERVER_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy servers and creates a PROXY_SERVER_LIST_ENTRY for
    each one

Arguments:

    lpszList    - pointer to list of proxies of the form:

                    [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    At least one entry in lpszList is bogus

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR protocolName;
    DWORD protocolLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    protocolName = lpszList;
    protocolLength = 0;
    schemeName = NULL;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_PROTOCOL;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case '=':
            if ((state == STATE_PROTOCOL) && (entryLength != 0)) {
                protocolLength = entryLength;
                entryLength = 0;
                state = STATE_SCHEME;
                schemeName = lpszList;
            } else {

                //
                // '=' can't legally appear anywhere else
                //

                state = STATE_ERROR;
            }
            break;

        case ':':
            switch (state) {
            case STATE_PROTOCOL:
                if (*lpszList == '/') {
                    schemeName = protocolName;
                    protocolName = NULL;
                    schemeLength = entryLength;
                    protocolLength = 0;
                    state = STATE_SCHEME;
                } else if (*lpszList != '\0') {
                    serverName = protocolName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = (schemeName != NULL)
                        ? schemeName
                        : protocolName;
                }

                INET_ASSERT(serverName != NULL);

                INTERNET_SCHEME protocol;

                if (protocolLength != 0) {
                    protocol = MapUrlSchemeName(protocolName, protocolLength);
                } else {
                    protocol = INTERNET_SCHEME_DEFAULT;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((protocol != INTERNET_SCHEME_UNKNOWN)
                && (scheme != INTERNET_SCHEME_UNKNOWN)

                //
                // we can only currently handle CERN (secure or unsecure) and
                // FTP proxies, so kick out anything that wants to go via any
                // other proxy scheme
                //

                && ((scheme == INTERNET_SCHEME_DEFAULT)
                || (scheme == INTERNET_SCHEME_FTP)
                || (scheme == INTERNET_SCHEME_HTTP)
                || (scheme == INTERNET_SCHEME_HTTPS))) {
                    if (!Find(protocol)) {

                        //
                        // don't worry if Add() fails - we just continue
                        //

                        Add(protocol, scheme, serverName, serverLength, port);
                    }
                }
            }
            entryLength = 0;
            protocolName = lpszList;
            protocolLength = 0;
            schemeName = NULL;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_PROTOCOL;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_SERVER_LIST::Find(
    IN INTERNET_SCHEME tScheme
    )

/*++

Routine Description:

    Find a PROXY_SERVER_LIST_ENTRY based on the scheme

Arguments:

    tScheme - protocol scheme to find

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_SERVER_LIST::Find",
                "%s",
                InternetMapScheme(tScheme)
                ));

    BOOL found = FALSE;

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        if (info->_Protocol == tScheme) {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::Add(
    IN INTERNET_SCHEME tProtocol,
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create an add a PROXY_SERVER_LIST_ENTRY to the PROXY_SERVER_LIST

Arguments:

    tProtocol           - protocol which uses the proxy

    tScheme             - scheme used to talk to the proxy

    lpszHostName        - proxy host name

    dwHostNameLength    - length of proxy host name

    nPort               - port at proxy host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::Add",
                "%s, %s, %.*q, %d, %d",
                InternetMapScheme(tProtocol),
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_SERVER_LIST_ENTRY * entry;

    entry = new PROXY_SERVER_LIST_ENTRY(tProtocol,
                                        tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error;

    if (entry != NULL) {
        //error = entry->ResolveAddress();
        //if (error == ERROR_SUCCESS) {
        //    InsertAtTailOfSerializedList(&_List, &entry->_List);
        //}
        if (entry->_Protocol == INTERNET_SCHEME_DEFAULT) {
            InsertAtTailOfSerializedList(&_List, &entry->_List);
        } else {
            InsertAtHeadOfSerializedList(&_List, &entry->_List);
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNET_SCHEME
PROXY_SERVER_LIST::ProxyScheme(
    IN INTERNET_SCHEME tProtocol
    )

/*++

Routine Description:

    Determines protocol over which tScheme goes through proxy

Arguments:

    tProtocol   - protocol scheme used to retrieve data (e.g. FTP)

Return Value:

    INTERNET_SCHEME
        Success - scheme by which protocol goes via proxy

        Failure - INTERNET_SCHEME_UNKNOWN
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Int,
                "PROXY_SERVER_LIST::ProxyScheme",
                "%s",
                InternetMapScheme(tProtocol)
                ));

    INTERNET_SCHEME tScheme = INTERNET_SCHEME_UNKNOWN;

    LockSerializedList(&_List);

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //

        if ((info->_Protocol == tProtocol)
        || (info->_Protocol == INTERNET_SCHEME_DEFAULT)) {
            tScheme = info->_Scheme;

            //
            // the default scheme is HTTP (CERN proxy)
            //

            if (tScheme == INTERNET_SCHEME_DEFAULT) {
                tScheme = INTERNET_SCHEME_HTTP;
            }
            break;
        }
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(tScheme);

    return tScheme;
}


BOOL
PROXY_SERVER_LIST::GetProxyHostName(
    IN INTERNET_SCHEME tProtocol,
    IN OUT LPINTERNET_SCHEME lptScheme,
    OUT LPSTR * lplpszHostName,
    OUT LPBOOL lpbFreeHostName,
    OUT LPDWORD lpdwHostNameLength,
    OUT LPINTERNET_PORT lpHostPort
    )

/*++

Routine Description:

    Given a protocol, map it to the proxy we use to retrieve the data

Arguments:

    tProtocol           - protocol to map (e.g. find the proxy for FTP)

    lptScheme           - IN: preferred scheme if INTERNET_SCHEME_DEFAULT
                          OUT: returned scheme

    lplpszHostName      - pointer to returned pointer to host name

    lpbFreeHostName     - returned TRUE if *lplpszHostName allocated

    lpdwHostNameLength  - pointer to returned host name length

    lpHostPort          - pointer to returned host port

Return Value:

    BOOL
        TRUE    - requested info has been returned

        FALSE   - requested info was not found

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_SERVER_LIST::GetProxyHostName",
                 "%s, %#x, %#x, %#x, %#x, %#x",
                 InternetMapScheme(tProtocol),
                 lptScheme,
                 lplpszHostName,
                 lpbFreeHostName,
                 lpdwHostNameLength,
                 lpHostPort
                 ));

    INET_ASSERT(tProtocol != INTERNET_SCHEME_UNKNOWN);

    //
    // *lptScheme must now be one of the recognized schemes, or the default
    //

    INET_ASSERT((*lptScheme == INTERNET_SCHEME_DEFAULT)
                || (*lptScheme == INTERNET_SCHEME_FTP)
                || (*lptScheme == INTERNET_SCHEME_GOPHER)
                || (*lptScheme == INTERNET_SCHEME_HTTP)
                || (*lptScheme == INTERNET_SCHEME_HTTPS)
                || (*lptScheme == INTERNET_SCHEME_SOCKS)
                );

    BOOL found = FALSE;

    LockSerializedList(&_List);

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //
        // Hack: But make sure its NOT socks since, socks must be
        //  an exact match !!! No defaults.
        //

        if ((info->_Protocol == tProtocol)
        || ((info->_Protocol == INTERNET_SCHEME_DEFAULT)
                && (tProtocol != INTERNET_SCHEME_SOCKS)  )) {

            INTERNET_SCHEME scheme = info->_Scheme;

            //
            // the returned scheme is the input preferred scheme unless it was
            // the default scheme in which case we return HTTP (CERN proxy)
            //

            if (scheme == INTERNET_SCHEME_DEFAULT) {
                scheme = (*lptScheme == INTERNET_SCHEME_DEFAULT)
                            ? INTERNET_SCHEME_HTTP
                            : *lptScheme;
            }
            *lptScheme = scheme;
            *lpbFreeHostName = FALSE;
            *lpdwHostNameLength = 0;
            *lplpszHostName = NewString(info->_ProxyName.StringAddress(),
                                        info->_ProxyName.StringLength()
                                        );
            if (*lplpszHostName != NULL) {
                *lpbFreeHostName = TRUE;
                *lpdwHostNameLength = info->_ProxyName.StringLength();
            }

            INTERNET_PORT port = info->_ProxyPort;

            //
            // map the default port value
            //

            if (port == INTERNET_INVALID_PORT_NUMBER) {
                switch (scheme) {
                case INTERNET_SCHEME_FTP:
                    port = INTERNET_DEFAULT_FTP_PORT;
                    break;

                case INTERNET_SCHEME_GOPHER:
                    port = INTERNET_DEFAULT_GOPHER_PORT;
                    break;

                case INTERNET_SCHEME_HTTP:
                    port = INTERNET_DEFAULT_HTTP_PORT;
                    break;

                case INTERNET_SCHEME_HTTPS:
                    port = INTERNET_DEFAULT_HTTPS_PORT;
                    break;

                case INTERNET_SCHEME_SOCKS:
                    port = INTERNET_DEFAULT_SOCKS_PORT;
                    break;
                }
            }
            *lpHostPort = port;
            found = TRUE;

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("proxy = %s://%s:%d\n",
                        MapUrlSchemeToName(scheme),
                        info->_ProxyName.StringAddress(),
                        port
                        ));

            break;
        }
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::AddToBypassList(
    IN PROXY_BYPASS_LIST * lpBypassList
    )

/*++

Routine Description:

    For all proxy servers in the server list, we add the details to the bypass
    list. By default, an app mustn't send a request to the proxy via the proxy!
    Additionally, the app should not have to specifically nominate the proxy
    server(s) as bypassing the proxy

Arguments:

    lpBypassList    - pointer to bypass proxy list where proxy servers will be
                      added

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error = ERROR_SUCCESS;
    PLIST_ENTRY entry = HeadOfSerializedList(&_List);

    while ((entry != (PLIST_ENTRY)SlSelf(&_List)) && (error == ERROR_SUCCESS)) {

        PROXY_SERVER_LIST_ENTRY * info = (PROXY_SERVER_LIST_ENTRY *)entry;

        if (!lpBypassList->Find(info->_Scheme,
                                info->_ProxyName.StringAddress(),
                                info->_ProxyName.StringLength(),
                                info->_ProxyPort)) {
            error = lpBypassList->Add(info->_Scheme,
                                      info->_ProxyName.StringAddress(),
                                      info->_ProxyName.StringLength(),
                                      info->_ProxyPort
                                      );
        }
        entry = entry->Flink;
    }
    return error;
}


VOID
PROXY_SERVER_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy servers to a buffer, and/or returns the required
    buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.

--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;

    UnlockSerializedList(&_List);
}


BOOL
PROXY_BYPASS_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy bypass list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude;

    if (_Scheme != INTERNET_SCHEME_DEFAULT) {
        schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
        requiredLength = schemeNameLength + sizeof("://") - 1;
    } else {
        schemeName = NULL;
        requiredLength = 0;
    }
    if (IsLocal()) {
        requiredLength += sizeof("<local>") - 1;
    } else {
        requiredLength += _Name.StringLength();
    }
    if (_Port != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_Port / n) {
                requiredLength += i + 1;
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        if (IsLocal()) {
            memcpy(lpszBuffer, "<local>", sizeof("<local>") - 1);
            lpszBuffer += sizeof("<local>") - 1;
        } else {
            _Name.CopyTo(lpszBuffer);
            lpszBuffer += _Name.StringLength();
        }
        if (_Port != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _Port, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_BYPASS_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy bypass specifiers and adds them to the list

Arguments:

    lpszList    - pointer to string containing list of proxy bypass specifiers.
                  The format is:

                    [<scheme>"://"][<server>][":"<port>"]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    schemeName = lpszList;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_SCHEME;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case ':':
            switch (state) {
            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    if (serverLength == 0) {
                        serverLength = 1;
                        serverName = "*";
                    }
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
                if ((serverLength == 0)
                && ((state == STATE_SERVER) || (state == STATE_PORT))) {

                    //
                    // we found e.g. "http://" or "http://:80". We allow this as
                    // "http://*" or "http://*:80"
                    //

                    serverLength = 1;
                    serverName = "*";
                }
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = schemeName;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((scheme != INTERNET_SCHEME_UNKNOWN)
                && !Find(scheme, serverName, serverLength, port)) {

                    //
                    // don't worry if Add() fails - we just continue
                    //

                    Add(scheme, serverName, serverLength, port);
                }
            }
            entryLength = 0;
            schemeName = lpszList;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_SCHEME;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::Find(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName OPTIONAL,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a proxy bypass entry matches the criteria.

    Currently, name matching is simplistic: e.g. "*.com" and "**.com" are
    treated as 2 separate strings, where we should collapse multiple wildcard
    specifiers, etc. Also: "w*" should replace "ww*", etc.

Arguments:

    tScheme             - scheme for this entry

    lpszHostName        - host name or address. May contain wildcards (*)

    dwHostNameLength    - length of host name or address

    nPort               - port

Return Value:

    BOOL
        TRUE    - an entry corresponding to the arguments was found

        FALSE   - didn't find entry

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::Find",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    BOOL isLocal = IsLocalMacro(lpszHostName, dwHostNameLength);
    BOOL found = FALSE;

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check for name match
        //

        if (info->_LocalSemantics) {
            if (isLocal) {
                found = TRUE;
                break;
            } else {
                continue;
            }
        }

        //
        // not local semantics, have to match target
        //

        //
        // BUGBUG - we only do simplistic matching. If the strings don't match
        //          exactly, except for case, they are deemed to be different
        //

        if (info->_Name.Strnicmp(lpszHostName, (int)dwHostNameLength) != 0) {
            continue;
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    info->_Name.StringAddress()
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_BYPASS_LIST::Add(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create and add a PROXY_BYPASS_LIST_ENTRY to the PROXY_BYPASS_LIST

Arguments:

    tScheme             - scheme to bypass. May be 0 meaning any protocol

    lpszHostName        - name of host to bypass. May be name or IP address and
                          may contain wildcard characters

    dwHostNameLength    - length of bypass name string

    nPort               - port to bypass. May be 0, meaning any port

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::Add",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_BYPASS_LIST_ENTRY * entry;

    entry = new PROXY_BYPASS_LIST_ENTRY(tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error;

    if (entry != NULL) {

        //
        // if the bypass entry uses local name matching semantics, then we add
        // it to the end of the list, else the head. The reason we do this is
        // to allow <local> to be a default after all other (possibly also
        // local) entries are checked
        //

        if (entry->IsLocal()) {
            InsertAtTailOfSerializedList(&_List, &entry->_List);
        } else {
            InsertAtHeadOfSerializedList(&_List, &entry->_List);
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::IsBypassed(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a scheme/name/port is bypassed

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    dwHostNameLength    - length of name/address part. May be 0, meaning match
                          any name/address

    nPort               - can be 0, meaning match any port

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::IsBypassed",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    INET_ASSERT(lpszHostName != NULL);
    INET_ASSERT(dwHostNameLength != 0);

    //
    // determine if what we were given is an address, in which case we don't
    // perform <local> semantics matching
    //

    BOOL isAddress = FALSE;
    LPSTR mappedName = NULL;
    LPSTR allocedName = NULL;

    if (dwHostNameLength <= MAX_IP_ADDRESS_STRING_LENGTH) {

        char addressBuffer[MAX_IP_ADDRESS_STRING_LENGTH + 1];

        //
        // make the host name/address an ASCIIZ string
        //

        memcpy((LPVOID)addressBuffer, (LPVOID)lpszHostName, dwHostNameLength);
        addressBuffer[dwHostNameLength] = '\0';
        if (_I_inet_addr(addressBuffer) != INADDR_NONE) {

            //
            // looks like we were given an IP address
            //

            //
            // maybe this is the IP address of a known server (in cache)
            //

            mappedName = MapNetAddressToName(addressBuffer, &allocedName);
            if (mappedName == addressBuffer) {

                //
                // BUGBUG - transport independence?
                //

                isAddress = TRUE;
            } else {
                lpszHostName = mappedName;
                dwHostNameLength = lstrlen(lpszHostName);
            }
        }
    }

    BOOL found;
    found = IsHostInBypassList (
                tScheme,
                lpszHostName,
                dwHostNameLength,
                nPort,
                isAddress);

    if (allocedName != NULL) {

        allocedName = (LPSTR)FREE_MEMORY(allocedName);
        INET_ASSERT(allocedName == NULL);
    }

    DEBUG_LEAVE(found);
    return found;
}


BOOL
PROXY_BYPASS_LIST::IsHostInBypassList(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort,
    IN BOOL isAddress
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    tScheme             -
    lpszHostName        -
    dwHostNameLength    -
    nPort               -
    isAddress           -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_BYPASS_LIST::IsHostInBypassList",
                 "%d (%s), %.*q, %d, %d, %B",
                 tScheme,
                 InternetMapScheme(tScheme),
                 dwHostNameLength,
                 lpszHostName,
                 dwHostNameLength,
                 nPort,
                 isAddress
                 ));

    BOOL found = FALSE;

    //
    // if not an address, determine if the name contains at least one dot
    //

    BOOL isDot;

    if (!isAddress) {
        isDot = FALSE;
        for (DWORD i = 0; i < dwHostNameLength; ++i) {
            if (lpszHostName[i] == '.') {
                isDot = TRUE;
                break;
            }
        }
    } else {

        //
        // addresses have dots
        //

        isDot = TRUE;
    }

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check local semantics
        //

        if (info->_LocalSemantics) {
            if (!isDot) {

                DEBUG_PRINT(PROXY,
                            INFO,
                            ("%q matched by <local>\n",
                            lpszHostName
                            ));

                found = TRUE;

                //
                // <local> is in the bypass list and the name does not contain a
                // dot. It bypasses the proxy
                //

                break;
            } else {

                //
                // the name contains a dot, but it may be matched by another
                // proxy bypass entry
                //

                continue;
            }
        }

        //
        // check for name match. Note that we take no special action if the host
        // name contains wildcard characters
        //

        LPSTR target = info->_Name.StringAddress();

        //
        // NULL target name matches any server name/address
        //

        if (target != NULL) {

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("trying to match %q with %q\n",
                        lpszHostName,
                        target
                        ));

            DWORD i = 0;
            DWORD j = 0;
            DWORD i_back = (DWORD)-1;

            while ((target[i] != '\0') && (j < dwHostNameLength)) {
                if (target[i] == tolower(lpszHostName[j])) {
                    ++i;
                    ++j;
                } else if (target[i] == '*') {
                    while (target[i + 1] == '*') {
                        ++i;
                    }
                    i_back = i;
                    ++i;
                    while ((tolower(lpszHostName[j]) != target[i])
                    && (j < dwHostNameLength)) {
                        ++j;
                    }
                } else if (i_back != (DWORD)-1) {

                    //
                    // '*' is greedy closure. We already saw a '*' but later we
                    // discovered a mismatch. We will go back and try to eat as
                    // many characters as we can till the next match, or we hit
                    // the end of the string
                    //

                    i = i_back;
                } else {

                    //
                    // no match; quit
                    //

                    j = 0;
                    break;
                }

                //
                // if we reached the end of the target, but not the host name
                // AND we already met a '*' then back up
                //

                if ((target[i] == '\0')
                && (j != dwHostNameLength)
                && (i_back != (DWORD)-1)) {
                    i = i_back;
                }
            }

            //
            // if we hit the end of the host name while matching any character,
            // bump the target to the next non-star character
            //

            while (target[i] == '*') {
                ++i;
            }

            //
            // the host name matched if we reached the end of the target and end
            // of the host name
            //

            if (!((target[i] == '\0') && (j == dwHostNameLength))) {
                continue;
            }
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    target
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(found);

    return found;
}


VOID
PROXY_BYPASS_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy bypass servers to a buffer, and/or returns the
    required buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.
--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;
    UnlockSerializedList(&_List);
}

//
// PROXY_INFO - methods are defined below
//

VOID 
PROXY_INFO::InitializeProxySettings(
    VOID
    )    

/*++

Routine Description:

    Initalizes Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    _ProxyServerList    = NULL;
    _ProxyBypassList    = NULL;
    _fDisableDirect     = FALSE;
    _fModifiedInProcess = FALSE;

    _Lock.Initialize();
    _Error = _Lock.IsInitialized()
                ? ERROR_SUCCESS
                : ERROR_INTERNET_INTERNAL_ERROR;
}


BOOL PROXY_INFO_GLOBAL::IsAutoProxyDownloaded(VOID)
{
    return !(IsGlobal() &&
        _AutoProxyList &&
        _AutoProxyList->IsAutoProxy() &&
        !_AutoProxyList->IsOnAsyncAutoProxyThread() &&
        GlobalAutoProxyNeedsInit);
}


VOID 
PROXY_INFO::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Cleans up and destroys Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    //DEBUG_ENTER((DBG_OBJECTS,
    //             None,
    //             "PROXY_INFO::TerminateProxySettings",
    //             NULL
    //             ));

    Lock(TRUE);
    CleanOutLists();
    Unlock();

    //DEBUG_LEAVE(0);
}




DWORD
PROXY_INFO::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info. Either creates new proxy server and bypass lists, or
    removes them (proxy to direct)

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE, if this object keeps a seperate set of values from those
                            stored in the registry store



Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    //
    // parameters should already be validated by caller
    //

    BOOL newList;
    BOOL possibleNewAutoProxy;
    LPCTSTR serverList;
    LPCTSTR bypassList;

    DWORD error = ERROR_SUCCESS;

    serverList = NULL;
    bypassList = NULL;
    newList = FALSE;
    _fModifiedInProcess = fModifiedInProcess;
    _dwSettingsVersion  = lpProxySettings->dwCurrentSettingsVersion;

    UPDATE_GLOBAL_PROXY_VERSION();

    if ( lpProxySettings->dwFlags & PROXY_TYPE_PROXY ) 
    {        
        serverList = lpProxySettings->lpszProxy;
        bypassList = lpProxySettings->lpszProxyBypass;

        if (serverList != NULL) {            
            newList = TRUE;
        }
    }

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    // remember disable direct flag...
    SetDisableDirect( (lpProxySettings->dwFlags & PROXY_TYPE_DIRECT) ? FALSE : TRUE  );

    //
    // clear out current contents,
    //

    CleanOutLists();

    //
    // Set the Static Proxy Lists
    //
        
    if (newList) 
    {

        INET_ASSERT((serverList != NULL) && (*serverList != 0));

        _ProxyServerList = new PROXY_SERVER_LIST(serverList);
        _ProxyBypassList = new PROXY_BYPASS_LIST(bypassList);

        if ((_ProxyServerList != NULL) && (_ProxyBypassList != NULL)) {
            _Error = _ProxyServerList->GetError();
            if (_Error == ERROR_SUCCESS) {
                _Error = _ProxyBypassList->GetError();
                if (_Error == ERROR_SUCCESS) {

                    //
                    // add all proxy servers to bypass list
                    //

                    _ProxyServerList->AddToBypassList(_ProxyBypassList);
                }
            }
        } else {
            _Error = ERROR_NOT_ENOUGH_MEMORY;
            CleanOutLists();
        }
        error = _Error;
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::GetProxySettings(
    OUT LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gets the proxy info. 

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - ignored 


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    DWORD error = ERROR_SUCCESS;

    if ( fCheckVersion == TRUE )
    {
        INET_ASSERT(FALSE);
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    if ( ! IsDisableDirect() ) {
        lpProxySettings->dwFlags |= PROXY_TYPE_DIRECT;
    }

    if ( IsProxySettingsConfigured() ) 
    {   
        lpProxySettings->dwFlags |= PROXY_TYPE_PROXY;

        lpProxySettings->lpszProxy       = _ProxyServerList->CopyString();
        lpProxySettings->lpszProxyBypass = _ProxyBypassList->CopyString();

        if ( lpProxySettings->lpszProxy == NULL || 
             lpProxySettings->lpszProxyBypass == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::RefreshProxySettings(
    IN BOOL fForceRefresh
    )
/*++

Routine Description:

    Refreshes the Proxy Information

    This doesn't make sense on PROXY_INFO, nothing done

Arguments:

    fForceRefresh - forces a resync of all settings, turning this on slows things down

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));


    DEBUG_LEAVE(ERROR_SUCCESS);
 
    return ERROR_SUCCESS;
}


DWORD
PROXY_INFO::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Determines what proxy type, proxy name, and port the caller should use
    given an Url, its length, a target host, a target port, and output space
    to store the result.

    The result may be a complete string containing a Netscape style string with
    a delimited set of proxies, and access methods.  An example of this may
    look like:
    "PROXY itgproxy:80; PROXY proxy:80; PROXY 192.168.100.2:1080; SOCKS 192.168.100.2; DIRECT"
    This means we must try itgproxy, if this proxy fails we go on to proxy, and on to 192.168.100.2, etc.
    Note that if itgproxy, proxy, and 192.168.100.2 all fail we can try a SOCKS proxy, and if this fails we
    can try a direct connection.

    OR

    The result can be a simply IE 3.0 proxyname.  Ex: "proxy".  You can figure out
    which by calling IsNetscapeProxyListString() on the returned proxy hostname.

    If there is an external proxy DLL registered and valid, we defer to it to decide
    what proxy to use, and thus ignore internal proxy information.

    Note this function can also be used to retrive mapping of protocol to proxy.  For example,
    if tUrlProtocol == INTERNET_SCHEME_FTP, the result *lptProxyScheme == INTERNET_SCHEME_SOCKS
    which means we should use a socks proxy/firewall for FTP accesss.

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    nPort               - can be 0, meaning match any port

    pfAutoProxy         - TRUE if an auto-proxy is being used.

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::QueryProxySettings",
                 "%#X",
                 ppQueryForProxyInfo
                 ));

    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;
    INTERNET_SCHEME tProxyScheme = pQueryForProxyInfo->_tUrlProtocol;
    BOOL fIsByPassed = FALSE;
    BOOL fProxyConnect = FALSE;
    
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    if (!IsProxySettingsConfigured())  // virtual func, perhaps replace with faster internal?
    {
        fProxyConnect = FALSE;
        goto quit;
    }

    //
    // Ok, if we're here we are NOT using the Auto-Proxy DLL.
    //  1. Determine if we are Bypassed ( and thus prevented from using a proxy )
    //  2. Map the Protocol to a Proxy type.
    //  3. Grab the hostname of the proxy we wish to use.
    //

    if ( pQueryForProxyInfo->_lpszUrlHostName && pQueryForProxyInfo->_dwUrlHostNameLength > 0 )
    {
        fIsByPassed = IsBypassed(
                        pQueryForProxyInfo->_tUrlProtocol,
                        pQueryForProxyInfo->_lpszUrlHostName,
                        pQueryForProxyInfo->_dwUrlHostNameLength,
                        pQueryForProxyInfo->_nUrlPort
                        );

        if ( fIsByPassed )
        {
            goto quit;
        }
    }

    pQueryForProxyInfo->_tProxyScheme = ProxyScheme(pQueryForProxyInfo->_tUrlProtocol);

    if ( pQueryForProxyInfo->_tProxyScheme == INTERNET_SCHEME_UNKNOWN )
    {
       pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_SOCKS;
       pQueryForProxyInfo->_tUrlProtocol = INTERNET_SCHEME_SOCKS;
    }
    if (pQueryForProxyInfo->_bFreeProxyHostName
        && (pQueryForProxyInfo->_lpszProxyHostName != NULL)) {
        FREE_MEMORY(pQueryForProxyInfo->_lpszProxyHostName);
    }

    fProxyConnect = GetProxyHostName(
                        pQueryForProxyInfo->_tUrlProtocol,
                        &(pQueryForProxyInfo->_tProxyScheme),
                        &(pQueryForProxyInfo->_lpszProxyHostName),
                        &(pQueryForProxyInfo->_bFreeProxyHostName),
                        &(pQueryForProxyInfo->_dwProxyHostNameLength),
                        &(pQueryForProxyInfo->_nProxyHostPort)
                        );

quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) fProxyConnect;

    //
    // If we've disabled direct connections, then fail
    //  when there is no proxy
    //

    if ( !fProxyConnect && IsDisableDirect() ) {         
        error = ERROR_INTERNET_CANNOT_CONNECT;
    }

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}



DWORD
PROXY_INFO::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    IMPORTANT PLEASE READ: LEGACY FUNCTION, this does not support all the new
      proxy behaviors, left here for Wininet compat with older programs

    Returns the proxy server and bypass lists in an INTERNET_PROXY_INFO. Called
    by InternetQueryOption(INTERNET_OPTION_PROXY)

    Assumes: Access to this is serialized while we are getting this info

Arguments:

    lpBuffer            - pointer to buffer where information will be returned

    lpdwBufferLength    - IN: size of lpBuffer in BYTEs
                          OUT: number of BYTEs returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the required buffer length
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_INFO::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                *lpdwBufferLength
                ));

    DEBUG_PRINT(PROXY,
                INFO,
                ("Calling Legacy GetProxyStringInfo, NEW CODE SHOULD AVOID THIS CODE PATH\n"
                ));

    DWORD requiredSize = sizeof(INTERNET_PROXY_INFO);
    LPSTR lpVariable = (LPSTR)(((LPINTERNET_PROXY_INFO)lpBuffer) + 1);
    LPSTR lpszProxy;

    Lock(FALSE);

    if (_ProxyServerList != NULL) {
        lpszProxy = lpVariable;
        _ProxyServerList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
    } else {
        lpszProxy = NULL;
    }

    LPSTR lpszProxyBypass;

    if (_ProxyBypassList != NULL) {

        DWORD size = requiredSize;

        lpszProxyBypass = lpVariable;
        _ProxyBypassList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
        if (requiredSize == size) {
            lpszProxyBypass = NULL;
        }
    } else {
        lpszProxyBypass = NULL;
    }

    DWORD error;

    if (*lpdwBufferLength >= requiredSize) {

        LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

        lpInfo->dwAccessType = (lpszProxy == NULL)
                                    ? INTERNET_OPEN_TYPE_DIRECT
                                    : INTERNET_OPEN_TYPE_PROXY;
        lpInfo->lpszProxy = lpszProxy;
        lpInfo->lpszProxyBypass = lpszProxyBypass;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredSize;

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
/*++

Routine Description:

    Determines whether a connection needs to be retried do to a failed proxy.

Arguments:


    lpdwError   - Error code of connection.

    pProxyState - Pointer to proxy_state returned when acquiring the proxy information.


Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_INFO::RedoSendRequest",
                 "%#x [%d], %#x",
                 lpdwError,
                 lpdwError ? *lpdwError : 0,
                 pQueryForProxyInfo
                 ));

    BOOL fReturn = FALSE;
    PROXY_STATE *pProxyState = NULL;
    DWORD dwVersion;
    LPSTR lpszConnection;
    BOOL fCanCache = FALSE;

    if ( pQueryForProxyInfo )
    {
        pProxyState = pQueryForProxyInfo->_pProxyState;

        //
        // On success,
        //

        if ( *lpdwError == ERROR_SUCCESS )
        {
            if ( pQueryForProxyInfo->IsCanCacheResult() && 
                 pProxyState &&                  
                 pOriginServer &&
                 pProxyServer )
            {
                
                pOriginServer->SetCachedProxyServerInfo(
                    pProxyServer,                    
                    pQueryForProxyInfo->GetVersion(),
                    pQueryForProxyInfo->IsUseProxy(),
                    pQueryForProxyInfo->_tUrlProtocol,
                    pQueryForProxyInfo->_nUrlPort,
                    pQueryForProxyInfo->_tProxyScheme,
                    pQueryForProxyInfo->_nProxyHostPort
                    );
            }
        }
        else if ( *lpdwError != ERROR_SUCCESS &&
                  *lpdwError != ERROR_INTERNET_OPERATION_CANCELLED &&
                  *lpdwError != ERROR_INTERNET_SEC_CERT_ERRORS &&
                  *lpdwError != ERROR_INTERNET_SECURITY_CHANNEL_ERROR &&
                  *lpdwError != ERROR_INTERNET_SEC_CERT_REVOKED &&
                  *lpdwError != ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED )
        {
            //
            // For backround detection, we need to retry
            //  waiting for the backround results to complete
            //
            // Otherwise, If we have additional proxies, 
            //  we need to retry them as well.
            //

            if ( pQueryForProxyInfo->IsBackroundDetectionPending() )
            {
                *lpdwError = ERROR_SUCCESS;
                fReturn = TRUE;
            }
            else if ( pProxyState &&
                     !pProxyState->IsEmpty() &&
                      pProxyState->IsAnotherProxyAvail() )               
            {
                INTERNET_PORT LastProxyUsedPort; 
                LPSTR lpszLastProxyUsed = pProxyState->GetLastProxyUsed(&LastProxyUsedPort);

                Lock(FALSE);

                if ( ( lpszLastProxyUsed == NULL ) ||
                     _BadProxyList.AddEntry(lpszLastProxyUsed, LastProxyUsedPort) != ERROR_SUCCESS )
                {
                    fReturn = FALSE;                    
                }
                else
                {
                    *lpdwError = ERROR_SUCCESS;
                    fReturn = TRUE;
                }

                Unlock();
            }
        }
    }

    DEBUG_LEAVE(fReturn);

    return fReturn;
}


VOID
PROXY_INFO::CleanOutLists(
    VOID
    )

/*++

Routine Description:

    Delete proxy server and bypass lists if not empty

    N.B. Exclusive lock MUST be acquired before calling this method

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "PROXY_INFO::CleanOutLists",
                 NULL
                 ));

    if (_ProxyServerList != NULL) {
        delete _ProxyServerList;
        _ProxyServerList = NULL;
    }
    if (_ProxyBypassList != NULL) {
        delete _ProxyBypassList;
        _ProxyBypassList = NULL;
    }

    DEBUG_LEAVE(0);
}

//
// PROXY_INFO_GLOBAL - Global Object thats inherits and expands the basic functionality 
//   of basic PROXY_INFO behavior.  The new functionality includes wrapping Auto-Proxy
///  and Auto-detection routines
//


VOID
PROXY_INFO_GLOBAL::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Destroy PROXY_INFO_GLOBAL object

Arguments:

    None.

Return Value:

    None.

--*/

{
    //DEBUG_ENTER((DBG_OBJECTS,
    //             None,
    //             "PROXY_INFO_GLOBAL::TerminateProxySettings",
    //             NULL
    //             ));

    Lock(TRUE);    
    if (_AutoProxyList != NULL) {
        _AutoProxyList->FreeAutoProxyInfo(); // free async component of object
        delete _AutoProxyList;
        _AutoProxyList = NULL;
    }
    Unlock();
    PROXY_INFO::TerminateProxySettings();

    //DEBUG_LEAVE(0);
}

DWORD
PROXY_INFO_GLOBAL::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE if this object is not from the registry, but 
                           a modifed setting for this process (that overrides reg values)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    DWORD error = ERROR_SUCCESS;

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    //
    // Once we're set to Modified, we're modified for the lifetime of the
    //   the process, and thus we no longer accept Registry settings
    //

    if ( IsModifiedInProcess() && 
         !fModifiedInProcess )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    if ( _lpszConnectionName != NULL ) {
        FREE_MEMORY(_lpszConnectionName);
    }

    _lpszConnectionName = lpProxySettings->lpszConnectionName ? 
                            NewString(lpProxySettings->lpszConnectionName) : 
                            NULL;

    _dwProxyFlags = lpProxySettings->dwFlags;

    //
    // Allocate Auto-Proxy/Auto-Detect Object, and reset its settings
    //

    if ( ((lpProxySettings->dwFlags & PROXY_TYPE_AUTO_PROXY_URL) ||
          (lpProxySettings->dwFlags & PROXY_TYPE_AUTO_DETECT)) &&
         IsGlobal() &&
         !( _AutoProxyList &&
            _AutoProxyList->IsOnAsyncAutoProxyThread()) )
    {        
        if (_AutoProxyList == NULL)
        {
            //
            // Create a new Auto-Proxy List, this will pull down registry
            //   info (for the DLLs) at initialization
            //

            _AutoProxyList = new AUTO_PROXY_DLLS();

            if ( _AutoProxyList == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            error =  _AutoProxyList->GetError();

            if ( error != ERROR_SUCCESS ) {
                goto quit;
            }
        }

        error = _AutoProxyList->SetProxySettings(
                    lpProxySettings,
                    fModifiedInProcess,
                    TRUE     // fAllowOverwrite
                    );
        if ( error != ERROR_SUCCESS ) { 
            goto quit;
        }
    }

    //
    // Set the Static Proxy Lists
    //
        
    error = PROXY_INFO::SetProxySettings(lpProxySettings, fModifiedInProcess);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::GetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gather the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - 

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    DWORD error = ERROR_SUCCESS;

    lpProxySettings->lpszConnectionName =
                        _lpszConnectionName ? 
                            NewString(_lpszConnectionName) : 
                            NULL;

    lpProxySettings->dwFlags = _dwProxyFlags;

    //
    // Check Auto-Proxy/Auto-Detect Object, and read its settings
    //

    if ( IsGlobal() &&
         _AutoProxyList)
    {        
        error = _AutoProxyList->GetProxySettings(
                    lpProxySettings,
                    fCheckVersion   
                    );

        if ( error != ERROR_SUCCESS ) { 
            goto quit;
        }
    }

    //
    // Get the Static Proxy Lists
    //
        
    error = PROXY_INFO::GetProxySettings(lpProxySettings, fCheckVersion);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::RefreshProxySettings(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect

Arguments:
    
    fForceRefresh - Forces a hard refresh

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));

    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    //
    // Force reload of registry settings and download of auto-proxy file from server
    //

    if ( IsRefreshDisabled())
    {
        QueueRefresh();
        goto quit;
    }

    //
    // Check Auto-Proxy/Auto-Detect Object, and read its settings
    //

    if ( IsGlobal() &&
         _AutoProxyList &&
         !(_AutoProxyList->IsOnAsyncAutoProxyThread()) )
    {                
        error = _AutoProxyList->RefreshProxySettings(
                    fForceRefresh
                    );

        if ( error != ERROR_SUCCESS ) { 
            goto quit;
        }
    }

    //
    // Get the Static Proxy Lists
    //
        
    //error = PROXY_INFO::RefreshProxySettings(fForceRefresh);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}

VOID
PROXY_INFO_GLOBAL::ReleaseQueuedRefresh(
    VOID
    )
/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect,
     When InternetOpen is called, allowing async threads.

Arguments:
    
    None.

Return Value:

    None.

--*/

{
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    SetRefreshDisabled(FALSE);

    if ( _fQueuedRefresh ) 
    {
        error = RefreshProxySettings(
                    FALSE
                    );

    }

    _fQueuedRefresh = FALSE;

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();
}




DWORD
PROXY_INFO_GLOBAL::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Aquries Proxy Information.

    Note: if ppProxyState returns a non-NULL pointer than the Proxy
    strings can be assumed to be allocated pointers to strings.  Freeing
    the ppProxyState object will result in the pointers being freed as well.
    Otherwise the pointers will be to global string data that will not be
    freed unexpectedly.



Arguments:

    tUrlProtocol -  Scheme type, protocol that is being used.

    lpszUrl      -  Url being accessed.

    dwUrlLength  -  size of Url.

    lpszUrlHostName - Host name of site to connect to.

    dwUrlHostNameLength - Host name length.

    nUrlPort      - Port of server to connect to.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::QueryProxySettings",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT(ppQueryForProxyInfo);

    BOOL fReturn = FALSE;
    DWORD error = ERROR_SUCCESS;
    BOOL fNeedsGetNextProxy = FALSE;
    BOOL fLocked = FALSE;
    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;

    //
    // If we're dealing with a list of Proxies, we may have already tried one
    //  proxy and failed.  So go to the next proxy in the list
    //  and see if another one is availble to try.
    //

    if ( pQueryForProxyInfo->IsProxyEnumeration() )
    {
        fNeedsGetNextProxy = TRUE;
        goto quit;
    }

    if ( pQueryForProxyInfo->IsQueryOnCallback() &&
         ! pQueryForProxyInfo->IsAvoidAsyncCall())
    {
        goto quit;
    }

    Lock(FALSE);
    fLocked = TRUE;

    //
    // Determine if we're dealing with an Auto-Proxy DLL,
    //  that needs a call into its own implimentation of GetProxyInfo
    //

    if ( _AutoProxyList &&
         ((_dwProxyFlags & PROXY_TYPE_AUTO_PROXY_URL) ||
          (_dwProxyFlags & PROXY_TYPE_AUTO_DETECT))
          )
    {
        AUTO_PROXY_DLLS  *pAutoProxyList = _AutoProxyList;

        Unlock();
        fLocked = FALSE;

        error = pAutoProxyList->QueryProxySettings(ppQueryForProxyInfo);
        if ( error == ERROR_IO_PENDING ) {
            goto fastquit;
        }

        pQueryForProxyInfo = *ppQueryForProxyInfo;
        if ( error != ERROR_SUCCESS || 
             pQueryForProxyInfo->IsUseProxy()) 
        {
           goto quit;
        }

        Lock(FALSE);
        fLocked = TRUE;
    }

    //
    // BUGBUG [arthurbi] I am NOT happy with this outragously bad logic
    //  and feel this is getting way out of hand.  This code below is to
    //  simply catch a case where we have auto-proxy and InternetOpenUrl
    //  needs to detect whether to use HTTP over proxy for {gopher, ftp}
    //  OR direct gopher, ftp.
    //

    if ( pQueryForProxyInfo->IsAvoidAsyncCall() &&
         pQueryForProxyInfo->IsDontWantProxyStrings() &&
         _AutoProxyList &&
         _AutoProxyList->IsAutoProxy() &&
         _AutoProxyList->IsAutoProxyEnabled() )
    {
       pQueryForProxyInfo->SetUseProxy(TRUE);

       //if ( pQueryForProxyInfo->_tUrlProtocol == INTERNET_SCHEME_HTTPS )
       //{
       //    pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_HTTPS;
       //}
       //else
       //{
            pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_HTTP;

       //}

       goto quit;
    }


    //
    // Use normal Proxy infomation stored in the registry
    //

    error = PROXY_INFO::QueryProxySettings(&pQueryForProxyInfo);

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

quit:

    if ( error == ERROR_SUCCESS &&
          ( fNeedsGetNextProxy ||
            pQueryForProxyInfo->IsProxyEnumeration())  )
    {
        error = pQueryForProxyInfo->GetNextProxy(_BadProxyList);
    }

    if ( fLocked )
    {
        Unlock();
    }

fastquit:

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO_GLOBAL::HostBypassesProxy(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR           lpszHostName,
    IN DWORD           cchHostName
    )

/*++

Routine Description:

    Determine if request should bypass proxy for host

Arguments:

    tScheme         -
    lpszHostName    -
    cchHostName     -

Return Value:

    BOOL

--*/

{
    BOOL bReturn = FALSE;
    DWORD dwServiceType;
    BOOL bTryByPassList = TRUE;

    // Only do this if it is for a scheme wininet supports.
    if (tScheme == INTERNET_SCHEME_HTTP ||
        tScheme == INTERNET_SCHEME_HTTPS ||
        tScheme == INTERNET_SCHEME_DEFAULT)
    {
        dwServiceType = INTERNET_SERVICE_HTTP;
    }
    else if (tScheme == INTERNET_SCHEME_FTP)
    {
        dwServiceType = INTERNET_SERVICE_FTP;
    }
    else if (tScheme == INTERNET_SCHEME_GOPHER)
    {
        dwServiceType = INTERNET_SERVICE_GOPHER;
    }
    else
    {
        return bReturn;
    }

    // LOCK
    Lock(FALSE);

    if (IsAutoProxy() && 
        _AutoProxyList->IsAutoProxyEnabled() &&
        _AutoProxyList->IsAutoProxyThreadReadyForRequests() &&
        ((_dwProxyFlags & PROXY_TYPE_AUTO_PROXY_URL) ||
         (_dwProxyFlags & PROXY_TYPE_AUTO_DETECT))
         )
    {
        CServerInfo * pServerInfo = NULL;

        DWORD error = ::GetServerInfo(lpszHostName,
                                      dwServiceType,
                                      FALSE,
                                      &pServerInfo
                                      );

        if (pServerInfo != NULL)
        {
            bTryByPassList = FALSE;

            if (pServerInfo->IsProxyByPassSet())
            {
                bReturn = pServerInfo->WasProxyByPassed();
            }
            else
            {
                // We have to know call the autoproxy code to determine if
                // the proxy is being bypassed.

                // First create an URL which corresponds to
                // scheme://hostname

                ICSTRING urlName;
                char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

                DWORD dwSchemeLength;
                LPSTR schemeName = MapUrlScheme(tScheme, &dwSchemeLength);

                int bufLength = dwSchemeLength
                             + 3              // For the ://
                             + cchHostName
                             + 1 ;            // Trailing NULL.

                urlName.CreateStringBuffer((LPVOID)schemeName, dwSchemeLength, bufLength);

                if (dwSchemeLength != 0)
                {
                    urlName += "://" ;
                }
                urlName.Strncat(lpszHostName, cchHostName);


                AUTO_PROXY_ASYNC_MSG proxyInfoQuery(tScheme,
                                               urlName.StringAddress(),
                                               hostName,
                                               sizeof(hostName));

                AUTO_PROXY_ASYNC_MSG *pProxyInfoQuery = &proxyInfoQuery;

                if ( _AutoProxyList->IsAutoProxyThreadReadyForRequests() ) {
                    proxyInfoQuery.SetBlockUntilCompletetion(TRUE);
                } else {
                    proxyInfoQuery.SetAvoidAsyncCall(TRUE);
                }

                Unlock();
                
                START_GUARD_AGAINST_ASYNC_AUTOPROXY_CALL; // Make sure corresponding END is in codepath !!!
                
                error = QueryProxySettings(&pProxyInfoQuery);

                INET_ASSERT(error != ERROR_IO_PENDING);

                END_GUARD_AGAINST_ASYNC_AUTOPROXY_CALL;
                
                // LOCK AGAIN
                Lock(FALSE);
                if (error == ERROR_SUCCESS)
                {
                    bReturn = !pProxyInfoQuery->IsUseProxy();
                    pServerInfo->SetProxyByPassed(bReturn);
                    if (pProxyInfoQuery && pProxyInfoQuery->IsAlloced())
                    {
                        delete pProxyInfoQuery;
                    }
                }
            }
            ::ReleaseServerInfo(pServerInfo);
        }
    }

    if (bTryByPassList) {        
        bReturn = IsHostInBypassList(lpszHostName, cchHostName);
    }

    Unlock();
    return bReturn;
}

//
// PROXY_STATE - an abstraction object used to provice simple string enumeration
//   given a list of proxies that need to be tested 
// 



BOOL
PROXY_STATE::GetNextProxy(
    IN  INTERNET_SCHEME   tUrlScheme,
    IN  BAD_PROXY_LIST &  BadProxyList,
    OUT LPINTERNET_SCHEME lptProxyScheme,
    OUT LPSTR * lplpszProxyHostName,
    OUT LPBOOL lpbFreeProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyHostPort
    )

/*++

Routine Description:

    Parses the current Proxy State information to acquire the
        proxy name, port, type to use.


Arguments:

    tUrlScheme   -  Scheme type, protocol that is being used.

    BadProxyList -  Reference to array of bad proxies that we can add/remove/check
                        from.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.

    lpbFreeProxyHostName - TRUE if *lplpszProxyHostName was allocated

    lpdwProxyHostNameLength - length of lplpszProxyHostName.

    lpProxyHostPort    - Host Port of Proxy.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR lpszDelimiter = NULL;
    BOOL  fReturn       = FALSE;
    LPSTR lpszPortDelim = NULL;
    LPSTR lpszPort      = NULL;


    if ( !_fIsMultiProxyList )
    {
        *lptProxyScheme = _tProxyScheme;
        *lplpszProxyHostName = _lpszAutoProxyList;
        *lpbFreeProxyHostName = FALSE;
        *lpdwProxyHostNameLength = _dwcbAutoProxyList;
        *lpProxyHostPort  = _proxyHostPort;
    }

    _fIsAnotherProxyAvail = FALSE;

    while ( *_lpszOffset != '\0' )
    {
        LPSTR lpszNewOffset ;

        //
        // Remove the delimiter so we can see the next token.
        //  ex: PROXY foo:80; DIRECT
        //  we would find DIRECT first with strstr, if we didn't
        //  delimit first.
        //

        lpszDelimiter = strchr(_lpszOffset, ';' );

        if ( lpszDelimiter == NULL )
        {
            lpszDelimiter = strchr(_lpszOffset, ',' );
        }

        if ( lpszDelimiter )
        {
            *lpszDelimiter = '\0';
        }

        lpszNewOffset=
            strstr(_lpszOffset, "DIRECT");

        if ( lpszNewOffset )
        {
            lpszNewOffset += sizeof("DIRECT");
            _lpszOffset    = lpszNewOffset;

            //
            // FALSE means direct.
            //

            fReturn = FALSE;
            goto quit;
        }

        //
        // Its not direct, try PROXY or SOCKS.
        //

        lpszNewOffset =
            strstr(_lpszOffset, "PROXY");


        if ( lpszNewOffset)
        {
            lpszNewOffset += sizeof("PROXY");
            *lpProxyHostPort = INTERNET_DEFAULT_HTTP_PORT;

            if ( tUrlScheme == INTERNET_SCHEME_HTTPS )
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTPS;
            }
            else
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTP;

            }
        }
        else
        {
            lpszNewOffset =
                strstr(_lpszOffset, "SOCKS");

            if ( lpszNewOffset )
            {
                lpszNewOffset   += sizeof("SOCKS");
                *lptProxyScheme  = INTERNET_SCHEME_SOCKS;
                *lpProxyHostPort = INTERNET_DEFAULT_SOCKS_PORT;
            }
        }

        //
        // Now do the generic common things for SOCKS, or PROXY
        // entries, ie: get port, hostname, and hostname size.
        //

        if ( lpszNewOffset )
        {
            _lpszOffset    = lpszNewOffset;

            SKIPWS(_lpszOffset);

            *lplpszProxyHostName = _lpszOffset;
            *lpbFreeProxyHostName = FALSE;

            lpszPortDelim = strchr(_lpszOffset, ':');

            if ( lpszPortDelim )
            {
                *lpszPortDelim = '\0';
                lpszPort  = lpszPortDelim+1;

                *lpProxyHostPort = (INTERNET_PORT)
                    atoi(lpszPort);
            }

            *lpdwProxyHostNameLength = lstrlen(_lpszOffset);

            if (BadProxyList.IsBadProxyName(*lplpszProxyHostName, *lpProxyHostPort))
            {
                if ( lpszDelimiter )
                {
                    _lpszOffset = (lpszDelimiter+1);
                }
                else
                {
                    _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
                }

                continue;
            }

            fReturn = TRUE;
        }

        break;
    }

quit:

    //if ( lpszPortDelim )
    //{
    //    *lpszPortDelim = ':';
    //}

    if ( lpszDelimiter )
    {
        *lpszDelimiter = ';';

        _lpszOffset = (lpszDelimiter+1);
    }
    else
    {
        _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
    }

    if ( fReturn )
    {
        _lpszLastProxyUsed = *lplpszProxyHostName;
        _LastProxyUsedPort = *lpProxyHostPort;

        //
        // If theres another possible proxy in this list,
        //   then we'll need to remember that
        //

        if ( _lpszOffset &&
             *_lpszOffset &&
                (strstr(_lpszOffset, "PROXY") ||
                 strstr(_lpszOffset, "DIRECT") ||  
                 strstr(_lpszOffset, "SOCKS"))
            )
        {
            _fIsAnotherProxyAvail = TRUE;
        }
    }

    return fReturn;
}




PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    )

/*++

Routine Description:

    Reads a string from the registry into a buffer, then shrinks the buffer

Arguments:

    lpszParameterName   - name of string to retrieve

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR buffer = NULL;
    DWORD length = PROXY_REGISTRY_STRING_LENGTH;
    BOOL done = FALSE;

    do {
        buffer = (LPSTR)ResizeBuffer(buffer, length, FALSE);
        if (done || (buffer == NULL)) {
            break;
        }

        DWORD error;

        error = InternetReadRegistryString(lpszParameterName, buffer, &length);
        length = (error == ERROR_SUCCESS) ? ((length == 0) ? 0 : (length + 1)) : 0;
        done = TRUE;
    } while (TRUE);

    return buffer;
}



//
// wrapper function for urlzones.
//

BOOLAPI IsHostInProxyBypassList (INTERNET_SCHEME tScheme, LPCSTR pszHost, DWORD cchHost)
{
    BOOL    fRet = FALSE;

    if (!GlobalDataInitialized) {
        GlobalDataInitialize();
    }

    if(ERROR_SUCCESS == LoadWinsock())
    {
        fRet = GlobalProxyInfo.HostBypassesProxy(tScheme, (LPSTR)pszHost, cchHost);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\handles\http.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    http.cxx

Abstract:

    Contains methods for HTTP_REQUEST_HANDLE_OBJECT class

    Contents:
        RMakeHttpReqObjectHandle
        HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::GetHandle
        HTTP_REQUEST_HANDLE_OBJECT::SetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::GetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::ReuseObject
        HTTP_REQUEST_HANDLE_OBJECT::ResetObject
        HTTP_REQUEST_HANDLE_OBJECT::UrlCacheUnlock
        HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated
        HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeHttpReqObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating an HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                        *** NOT USED FOR HTTP ***
                      OUT: mapped address of HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed
                        *** NOT USED FOR HTTP ***

    dwFlags         - app-supplied flags

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * hHttp;

    hHttp = new HTTP_REQUEST_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwFlags,
                    dwContext
                    );
    if (hHttp != NULL) {
        error = hHttp->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hHttp);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hHttp = NULL;
            }
        } else {
            delete hHttp;
            hHttp = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hHttp;
    if(hHttp)
    {
        hHttp->Dereference();
    }

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT class implementation
//


HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT * Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)

/*++

Routine Description:

    Constructor for direct-to-net HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    Parent      - parent object

    Child       - IN: HTTPREQ structure pointer
                  OUT: pointer to created HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc  - address of function that closes/destroys HTTPREQ structure

    dwFlags     - open flags (e.g. INTERNET_FLAG_RELOAD)

    dwContext   - caller-supplied request context value

Return Value:

    None.

--*/

{
    Reference();
    _Context = dwContext;
    _Socket = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;
    _OpenFlags = dwFlags;
    _State = HttpRequestStateCreating;
    _RequestMethod = HTTP_METHOD_TYPE_UNKNOWN;
    _dwOptionalSaved = 0;
    _lpOptionalSaved = NULL;
    _fOptionalSaved = FALSE;
        _ResponseBuffer = NULL;
    _ResponseBufferLength = 0;
    ResetResponseVariables();
    _RequestHeaders.SetIsRequestHeaders(TRUE);
    _ResponseHeaders.SetIsRequestHeaders(FALSE);
    _fTalkingToSecureServerViaProxy = FALSE;
    _fRequestUsingProxy = FALSE;
    _bWantKeepAlive = FALSE;
    _bRefresh = FALSE;
    _RefreshHeader = NULL;
    _redirectCount = GlobalMaxHttpRedirects;
    _redirectCountedOut = FALSE;
    _fIgnoreOffline = FALSE;
    _f3rdPartyCookies = FALSE;
    _fBlockedOnPrompt = FALSE;


    SetObjectType(TypeHttpRequestHandle);

    _pCacheEntryInfo = NULL;
    _dwCacheEntryType = 0;

    _pAuthCtx         = NULL;
    _pTunnelAuthCtx   = NULL;
    _pPWC             = NULL;
    _lpBlockingFilter = NULL;
    _dwCredPolicy     = 0xFFFFFFFF;

    _NoResetBits.Dword = 0;  // only here are we ever allowed to assign to Dword.

    SetDisableNTLMPreauth(GlobalDisableNTLMPreAuth);
    
    _ProxyHostName = NULL;
    _ProxyHostNameLength = NULL;
    _ProxyPort = INTERNET_INVALID_PORT_NUMBER;

    _SocksProxyHostName = NULL;
    _SocksProxyHostNameLength = NULL;
    _SocksProxyPort = INTERNET_INVALID_PORT_NUMBER;

    HttpFiltOpen(); // enumerate http filters if not already active

    _HaveReadFileExData = FALSE;
    memset(&_BuffersOut, 0, sizeof(_BuffersOut));
    _BuffersOut.dwStructSize = sizeof(_BuffersOut);
    _BuffersOut.lpvBuffer = (LPVOID)&_ReadFileExData;

    _fAutoProxyChecked = FALSE;

    m_pSecurityInfo = NULL;
    m_AuthFlag = 0x00000000;

    m_fPPAbortSend = FALSE;

    _fSendUTF8ServerNameToProxy = FALSE;

    SetPriority(0);

    _dwSecurityZone = 0xffffffff; /* initialize to invalid zone value */

#ifdef RLF_TEST_CODE

    static long l = 0;
    SetPriority(l++);

#endif

    _RTT = 0;
    _CP = CP_ACP;

    if (_Status == ERROR_SUCCESS) {
        _Status = _RequestHeaders.GetError();
        if (_Status == ERROR_SUCCESS) {
            _Status = _ResponseHeaders.GetError();
        }
    }

    _dwSocketSendBufferLength = -1;

    if ((_OpenFlags & INTERNET_FLAG_SECURE) &&
        (_Status = LoadSecurity()) == ERROR_SUCCESS)
    {
        m_pSecurityInfo = GlobalCertCache.Find(GetHostName());
        if (NULL == m_pSecurityInfo)
        {
            m_pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(GetHostName());
            // Force a net hit, since this hasn't been fully validated.
            SetCacheReadDisabled();
        }
    }
    else
    {
        m_pSecurityInfo = NULL;
    }
}


HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT(
    VOID
    )

/*++

Routine Description:

    Destructor for HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HTTP_REQUEST_HANDLE_OBJECT",
                "%#x",
                this
                ));

    //
    // close the socket (or free it to the pool if keep-alive)
    //

    //
    // Authentication Note:
    // The CloseConnection parameter to force the connection closed
    // is set if we received a challenge but didn't respond, otherwise
    // IIS will get confused when a subsequent request recycles the
    // socket from the keep-alive pool.
    //

    CloseConnection(GetAuthState() == AUTHSTATE_CHALLENGE);

    if (IsCacheWriteInProgress()) {
        LocalEndCacheWrite(IsEndOfFile());
    }

    if (IsCacheReadInProgress()) {

        INET_ASSERT (_pCacheEntryInfo);
        FREE_MEMORY (_pCacheEntryInfo);

        // Rest is cleaned up in INTERNET_CONNECT_HANDLE_OBJECT::EndCacheWrite

    } else {
        UrlCacheUnlock();
    }

    //
    // If there's an authentication context, unload the provider.
    //

    if (_pAuthCtx) {
        delete _pAuthCtx;
    }
    if (_pTunnelAuthCtx) {
        delete _pTunnelAuthCtx;
    }

    //
    // free the various buffers
    //

    FreeResponseBuffer();
    FreeQueryBuffer();
    SetProxyName(NULL,NULL,0);

    if (m_pSecurityInfo != NULL) {
        m_pSecurityInfo->Release();
    }

    DEBUG_LEAVE(0);
}


HINTERNET
HTTP_REQUEST_HANDLE_OBJECT::GetHandle(
    VOID
    )

/*++

Routine Description:

    Returns child handle value. NULL for HTTP

Arguments:

    None.

Return Value:

    HINTERNET
        NULL

--*/

{
    return NULL;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetProxyName(
    IN LPSTR lpszProxyHostName,
    IN DWORD dwProxyHostNameLength,
    IN INTERNET_PORT ProxyPort
    )

/*++

Routine Description:

    Set proxy name in object. If already have name, free it. Don't set name if
    current pointer is input

Arguments:

    lpszProxyHostName       - pointer to proxy name to add

    dwProxyHostNameLength   - length of proxy name

    ProxyPort               - port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetProxyName",
                 "{%q, %d, %d}%q, %d, %d",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lpszProxyHostName,
                 dwProxyHostNameLength,
                 ProxyPort
                 ));

    if (lpszProxyHostName != _ProxyHostName) {
        if (_ProxyHostName != NULL) {
            _ProxyHostName = (LPSTR)FREE_MEMORY(_ProxyHostName);

            INET_ASSERT(_ProxyHostName == NULL);

            SetOverrideProxyMode(FALSE);
        }
        if (lpszProxyHostName != NULL) {
            _ProxyHostName = NEW_STRING(lpszProxyHostName);
            if (_ProxyHostName == NULL) {
                dwProxyHostNameLength = 0;
            }
        }
        _ProxyHostNameLength = dwProxyHostNameLength;
        _ProxyPort = ProxyPort;
    } else if (lpszProxyHostName != NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("!!! lpszProxyHostName == _ProxyHostName (%#x)\n",
                    lpszProxyHostName
                    ));

        INET_ASSERT(dwProxyHostNameLength == _ProxyHostNameLength);
        INET_ASSERT(ProxyPort == _ProxyPort);

    }

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::GetProxyName(
    OUT LPSTR* lplpszProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyPort
    )

/*++

Routine Description:

    Return address & length of proxy name plus proxy port

Arguments:

    lplpszProxyHostName     - returned address of name

    lpdwProxyHostNameLength - returned length of name

    lpProxyPort             - returned port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetProxyName",
                 "{%q, %d, %d}%#x, %#x, %#x",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lplpszProxyHostName,
                 lpdwProxyHostNameLength,
                 lpProxyPort
                 ));

    *lplpszProxyHostName = _ProxyHostName;
    *lpdwProxyHostNameLength = _ProxyHostNameLength;
    *lpProxyPort = _ProxyPort;

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReuseObject(
    VOID
    )

/*++

Routine Description:

    Make the object re-usable: clear out any received data and headers and
    reset the state to open

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReuseObject",
                 NULL
                 ));

    _ResponseHeaders.FreeHeaders();
    FreeResponseBuffer();
    ResetResponseVariables();
    _ResponseHeaders.Initialize();
    _dwCurrentStreamPosition = 0;
    SetState(HttpRequestStateOpen);
    ResetEndOfFile();
    _ctChunkInfo.Reset();
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _dwQuerySetCookieHeader = 0;
    if (m_pSecurityInfo) {
        m_pSecurityInfo->Release();
    }
    m_pSecurityInfo = NULL;

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ResetObject(
    IN BOOL bForce,
    IN BOOL bFreeRequestHeaders
    )

/*++

Routine Description:

    This method is called when we we are clearing out a partially completed
    transaction, mainly for when we have determined that an if-modified-since
    request, or a response that has not invalidated the cache entry can be
    retrieved from cache (this is a speed issue)

    Abort the connection and clear out the response headers and response
    buffer; clear the response variables (all done by AbortConnection()).

    If bFreeRequestHeaders, clear out the request headers.

    Reinitialize the response headers. We do not reset the object state, but we
    do reset the end-of-file status

Arguments:

    bForce              - TRUE if connection is forced closed

    bFreeRequestHeaders - TRUE if request headers should be freed

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ResetObject",
                 "%B, %B",
                 bForce,
                 bFreeRequestHeaders
                 ));

    DWORD error;

    error = AbortConnection(bForce);
    if (error == ERROR_SUCCESS) {
        if (bFreeRequestHeaders) {
            _RequestHeaders.FreeHeaders();
        }
        _ResponseHeaders.Initialize();
        ResetEndOfFile();
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::UrlCacheUnlock(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    INET_ASSERT (!_CacheReadInProgress);

    if (_hCacheStream)
    {
        UnlockUrlCacheEntryStream (_hCacheStream, 0);
        _hCacheStream = NULL;
    }

    if (_pCacheEntryInfo)
    {

        if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
        {

            //
            // We can't use the partial cache entry because it is
            // stale, so delete the data file we got from cache.
            //

            INET_ASSERT (_CacheFileHandle != INVALID_HANDLE_VALUE);
            CloseHandle (_CacheFileHandle);
            _CacheFileHandle = INVALID_HANDLE_VALUE;
            DeleteFile (_pCacheEntryInfo->lpszLocalFileName);
        }

        FREE_MEMORY (_pCacheEntryInfo);
        _pCacheEntryInfo = NULL;
    }
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    SetAuthenticated    -

Return Value:

    None.

--*/

{
    if (!_Socket)
    {
        INET_ASSERT(FALSE);
    }
    else
    {
        _Socket->SetAuthenticated();
    }
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    IsAuthenticated -

Return Value:

    BOOL

--*/

{
    return (_Socket ? _Socket->IsAuthenticated() : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\add.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    add.cxx

Abstract:

    This file contains the implementation of the HttpAddRequestHeadersA API.

    The following functions are exported by this module:

        HttpAddRequestHeadersA
        HttpAddRequestHeadersW

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpAddRequestHeadersA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private manifests
//

#define VALID_ADD_FLAGS (HTTP_ADDREQ_FLAG_ADD_IF_NEW \
                        | HTTP_ADDREQ_FLAG_ADD \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA \
                        | HTTP_ADDREQ_FLAG_REPLACE \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON \
                        )

//
// functions
//


INTERNETAPI_(BOOL) HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle

Arguments:

    hRequest        - An open HTTP request handle returned by HttpOpenRequest()

    lpszHeaders     - The headers to append to the request. Each header must be
                      terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is -1L
                      then lpszHeaders is assumed to be zero terminated (ASCIIZ)

    dwModifiers     - flags controlling operation. Can be one or more of:

                        HTTP_ADDREQ_FLAG_ADD_IF_NEW
                            - add the header, but only if it does not already
                              exist. Index must be zero

                        HTTP_ADDREQ_FLAG_ADD
                            - if HTTP_ADDREQ_FLAG_REPLACE is set, but the header
                              is not found and this flag is set then the header
                              is added, so long as there is a valid header-value

                        HTTP_ADDREQ_FLAG_COALESCE
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
                            - concatenate headers of same name. E.g. if we
                              already have "Accept: text/html" then adding
                              "Accept: text/*" will create
                              "Accept: text/html, text/*"

                        HTTP_ADDREQ_FLAG_REPLACE
                            - replaces the named header. Only one header can be
                              supplied. If header-value is empty then the header
                              is removed

Return Value:

    Success - TRUE
                The header was appended successfully

    Failure - FALSE
                The operation failed. Error status is available by calling
                GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpAddRequestHeadersA",
                     "%#x, %.80q, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD error;
    HINTERNET hRequestMapped = NULL;
    DWORD nestingLevel = 0;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    if ((lpszHeaders == NULL)
    || (*lpszHeaders == '\0')
    || (dwHeadersLength == 0)
    || (dwModifiers & (HTTP_ADDREQ_FLAGS_MASK & ~VALID_ADD_FLAGS))) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // BUGBUG - we should determine whether the app is trying to give us a bogus
    //          header, and whether the header conforms to the format:
    //
    //                          "<header>[:[ <value>]]"
    //

    __try {
        if (dwHeadersLength == (DWORD)-1) {
            dwHeadersLength = (DWORD)lstrlen(lpszHeaders);
        } else {

            //
            // perform our own IsBadStringPtr() - don't have to call another
            // function or register extra exception handlers
            //

            for (DWORD i = 0; i < dwHeadersLength; ++i) {

                char ch = *((char volatile *)&lpszHeaders[i]);
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }
    ENDEXCEPT
    if (error == ERROR_SUCCESS) {
        error = wHttpAddRequestHeaders(hRequestMapped,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwModifiers
                                       );
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE_API(error == ERROR_SUCCESS);

    return error == ERROR_SUCCESS;
}


INTERNETAPI_(BOOL) HttpAddRequestHeadersW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    lpszHeaders - The headers to append to the request. Each header must be
        terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is
        -1L, then lpszHeaders is assumed to be zero terminated (ASCIIZ).

    dwModifiers     -

Return Value:

    TRUE - The header was appended successfully.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpAddRequestHeadersW",
                     "%#x, %.80wq, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!lpszHeaders || *lpszHeaders==L'\0' || !dwHeadersLength
        || IsBadStringPtrW(lpszHeaders, dwHeadersLength))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        MEMORYPACKET mpHeaders;
        ALLOC_MB(lpszHeaders, (dwHeadersLength==-1L ? 0 : dwHeadersLength), mpHeaders);
        if (mpHeaders.psStr)
        {
            UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
            fResult = HttpAddRequestHeadersA(hRequest, mpHeaders.psStr, mpHeaders.dwSize, dwModifiers);
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Worker function to append additional header(s) to an HTTP request handle

Arguents:

    hRequest        - handle of HTTP request

    lpszHeaders     - pointer to buffer containing one or more headers

    dwHeadersLength - length of lpszHeaders. Cannot be -1 at this stage

    dwModifiers     - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The header string(s) was bad after all

                  ERROR_INTERNET_INCORRECT_HANDLE_STATE
                    We can't add headers to this object at this time

                  ERROR_HTTP_HEADER_NOT_FOUND
                    We were asked to replace a header, but couldn't find it

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    We were asked to add a header, only if one of the same name
                    doesn't already exist. It does

--*/

{
    //
    // dwHeadersLength cannot be -1 or 0 at this stage. Nor can lpszHeaders be
    // NULL
    //

    INET_ASSERT(lpszHeaders != NULL);
    INET_ASSERT(dwHeadersLength != (DWORD)-1);
    INET_ASSERT(dwHeadersLength != 0);

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "wHttpAddRequestHeaders",
                 "%#x, %#x [%.80q], %d, %#x",
                 hRequest,
                 lpszHeaders,
                 lpszHeaders,
                 dwHeadersLength,
                 dwModifiers
                 ));

    //
    // get the underlying object and check that we can add headers
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    DWORD error;

    if (!IS_VALID_HTTP_STATE(pRequest, ADD, TRUE)) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    DWORD offset;
    LPSTR header;

    offset = 0;
    header = (LPSTR)lpszHeaders;

    do {

        //
        // first time: ignore any empty strings; subsequent time: clean off any
        // trailing line termination
        //

        while ((offset < dwHeadersLength)
        && ((lpszHeaders[offset] == '\r') || (lpszHeaders[offset] == '\n'))) {
            ++offset;
        }
        if (offset == dwHeadersLength) {

            //
            // even if app tried adding empty line(s), we return success
            //

            error = ERROR_SUCCESS;
            break;
        }

        DWORD length;
        DWORD nameLength;
        DWORD valueLength;
        LPSTR value;
        BOOL done;

        nameLength = 0;
        valueLength = 0;
        value = NULL;

        //
        // break the header into header-name, header-value pairs. Exclude CR-LF
        // from the header-value (if present)
        //

        for (length = 0, header = (LPSTR)&lpszHeaders[offset];
            offset < dwHeadersLength;
            ++length, ++offset) {

            char ch = header[length];

            if ((ch == '\r') || (ch == '\n')) {

                //
                // end of this particular header
                //

                break;
            } else if (ch == ':') {
                if (nameLength == 0) {

                    //
                    // found end of header name
                    //

                    nameLength = length;
                    value = &header[length];
                }
            }
        }
        if (length == 0) {

            //
            // empty string
            //

            continue;
        } else if (nameLength == 0) {

            //
            // entry consists of just header-name (e.g. "Accept[\r\n]")
            //

            nameLength = length;
        } else {

            //
            // find the start of the header-value
            //

            valueLength = (DWORD) (header + length - value);

            //
            // N.B. We are allowing any mixture of ':' and ' ' between header
            // name and value, but this is probably not a big deal...
            //

            while ((*value == ':') || (*value == ' ') && (valueLength != 0)) {
                ++value;
                --valueLength;
            }
        }
        if (dwModifiers
            & (HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD_IF_NEW)) {

            //
            // replace or remove the header
            //

            error = pRequest->ReplaceRequestHeader(
                                header,
                                nameLength,
                                value,
                                valueLength,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        } else if (valueLength != 0) {

            //
            // add a single, unterminated header string to the request headers.
            // Since these headers came from the app, we don't trust it to get
            // the header termination right (number & type of line terminators)
            // so we add it ourselves
            //

            error = pRequest->AddRequestHeader(
                                header,
                                nameLength,
                                value,
                                valueLength,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        } else {

            //
            // BUGBUG - we are adding headers, but the header-value is not
            //          present. This is a somewhat tricky situation because we
            //          we may have already added some headers, resulting in
            //          the app not really knowing which headers were good and
            //          which failed; additionally, one or more of the headers
            //          may have been added, increasing the apps confusion. The
            //          best way to handle this (if necessary) is to check the
            //          header name/value pairs w.r.t. the dwModifiers flags.
            //          HOWEVER, even then we can get into a state down here
            //          where we add a couple of headers, then fail...
            //

            error = ERROR_INVALID_PARAMETER;
        }
    } while (error == ERROR_SUCCESS);

quit:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\cache.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cache.cxx

Abstract:

    Contains HTTP cache-related functions. Cache functions pulled out of
    read.cxx and send.cxx

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::FCanWriteToCache
        HTTP_REQUEST_HANDLE_OBJECT::FAddIfModifiedSinceHeader
        HTTP_REQUEST_HANDLE_OBJECT::AddHeaderIfEtagFound
        HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheRetrieval
        HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheWrite
        HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePreNetIO
        HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePostNetIO
        HTTP_REQUEST_HANDLE_OBJECT::ResumePartialDownload
        HTTP_REQUEST_HANDLE_OBJECT::AddTimestampsFromCacheToResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::AddTimeHeader
        HTTP_REQUEST_HANDLE_OBJECT::IsPartialResponseCacheable
        HTTP_REQUEST_HANDLE_OBJECT::LocalEndCacheWrite
        HTTP_REQUEST_HANDLE_OBJECT::GetTimeStampsForCache
        (FExcludedMimeType)
        (FilterHeaders)

Author:

    Richard L Firth (rfirth) 05-Dec-1997

Environment:

    Win32 user-mode DLL

Revision History:

    05-Dec-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private prototypes
//

PRIVATE
BOOL
FExcludedMimeType(
    IN LPSTR lpszMimeType,
    IN DWORD dwMimeTypeSize
    );

PRIVATE
VOID
FilterHeaders(
    IN LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwHeaderLen
    );

//
// static data
//

LPCSTR rgszExcludedMimeTypes[] = {
    "multipart/mixed",
    "multipart/x-mixed-replace"
    };

const DWORD rgdwExcludedMimeTypeSizes[] = {
    sizeof("multipart/mixed") - 1,
    sizeof("multipart/x-mixed-replace") - 1
    };

static const char szDefaultExtension[] = "txt";

LPSTR rgszExcludeHeaders[] = {
    HTTP_SET_COOKIE_SZ,
    HTTP_LAST_MODIFIED_SZ,
    HTTP_SERVER_SZ,
    HTTP_DATE_SZ,
    HTTP_EXPIRES_SZ,
    HTTP_CONNECTION_SZ,
    HTTP_PROXY_CONNECTION_SZ,
    HTTP_VIA_SZ,
    HTTP_VARY_SZ,
    HTTP_AGE_SZ,
    HTTP_CACHE_CONTROL_SZ,
    HTTP_ACCEPT_RANGES_SZ,
    HTTP_CONTENT_DISPOSITION_SZ
    };

const char vszUserNameHeader[4] = "~U:";

//
// HTTP Request Handle Object methods
//


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FCanWriteToCache(
    VOID
    )

/*++

Routine Description:

    Determines if we can write this file to the cache

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FCanWriteToCache",
                 NULL
                 ));

    PERF_LOG(PE_CACHE_WRITE_CHECK_START);

    BOOL ok = FALSE;

    BOOL fForceToCache = FALSE;
    BOOL fCheckNeedFile = FALSE;

    BOOL fVary = FALSE;
    BOOL fContentEnc = FALSE;

    //
    // Set fNoCache if there is pragma: no-cache
    //

    BOOL fNoCache = FALSE;
    DWORD length, index;
    LPSTR lpszBuf;

    _ResponseHeaders.LockHeaders();

    if (GetOpenFlags() & INTERNET_FLAG_SECURE)
    {
        SetPerUserItem(TRUE);

        //
        // Determine if there are any Pragma: no-cache headers.
        //

        index = 0;

        while ( FastQueryResponseHeader(HTTP_QUERY_PRAGMA,
                                        (LPVOID *) &lpszBuf,
                                        &length,
                                        index) == ERROR_SUCCESS )
        {
            if (length == NO_CACHE_LEN &&
                strnicmp(NO_CACHE_SZ, lpszBuf, NO_CACHE_LEN) == 0)
            {
                fNoCache = TRUE;
                break;
            }

            index++;
        }

        if (fNoCache)
        {
            // If server disabled caching over SSL, don't even create
            // a file, let alone commit it to the cache.  Game over.
            BETA_LOG (DOWNLOAD_NO_FILE);
            goto quit;
        }
    
        //
        // If we've disabled caching for SSL servers, consider creating
        // a download file if the client insists upon it.
        //

        if (GlobalDisableSslCaching)
        {
            goto check_need_file;
        }
    }

    //
    // Also set fNoCache if there is Cache-Control: no-cache or no-store header,
    // if there is a Cache-Control: private header and we're *not* on NT with user profiles,
    // or any Vary: headers. These are only checked for HTTP 1.1 servers.
    //

    if (IsResponseHttp1_1())
    {
        CHAR *ptr, *pToken;
        index = 0;

        // Scan for Cache-Control header.
        while (FastQueryResponseHeader(HTTP_QUERY_CACHE_CONTROL,
                                    (LPVOID *) &lpszBuf,
                                    &length,
                                    index) == ERROR_SUCCESS)
        {
            // Check for no-cache or no-store or private.
            CHAR chTemp = lpszBuf[length];

            lpszBuf[length] = '\0';
            pToken = ptr = lpszBuf;
            // Parse a token from the string; test for sub headers.
            while (*pToken != '\0')
            {
                SKIPWS(pToken);

                // no-cache, no-store.
                if (strnicmp(NO_CACHE_SZ, pToken, NO_CACHE_LEN) == 0)
                {
                    fNoCache = TRUE;
                    break;
                }
                if( strnicmp(NO_STORE_SZ, pToken, NO_STORE_LEN) == 0) 
                {
                    fNoCache = TRUE;
                    fCheckNeedFile = TRUE;
                }

                // private.
                if (strnicmp(PRIVATE_SZ, pToken, PRIVATE_LEN) == 0)
                {
                    SetPerUserItem(TRUE);
                }

                while (*pToken != '\0')
                {
                    if ( *pToken == ',')
                    {
                        pToken++;
                        break;
                    }

                    pToken++;
                }

            } // while (*pToken != '\0')

            //
            // We've finished parsing it, now return our terminator back to its proper place
            //

            lpszBuf[length] = chTemp;

            // If fNoCache, we're done. Break out of switch.
            if (fNoCache)
                break;

            index++;

        } // while FastQueryResponseHeader == ERROR_SUCCESS

        if (fNoCache)
        {
            if( fCheckNeedFile ) 
            {
                // cache-control: no store
                goto check_need_file;
            }
            else 
            if (GetOpenFlags() & INTERNET_FLAG_SECURE)
            {
                // If server disabled caching over SSL, don't even create
                // a file, let alone commit it to the cache.  Game over.
                BETA_LOG (DOWNLOAD_NO_FILE);
                goto quit;
            }
            else
            {
                //
                // This is not SSL/PCT, so don't cache but consider creating a
                // download file if one was requested.
                //

                goto check_need_file;
            }
        }

        // Finally, check if any Vary: headers exist, EXCEPT "Vary: User-Agent"

        index = 0;
        if (FastQueryResponseHeader(HTTP_QUERY_VARY,
                                    (LPVOID *) &lpszBuf,
                                    &length,
                                    index) == ERROR_SUCCESS
            && !(length == USER_AGENT_LEN
               && !strnicmp (lpszBuf, USER_AGENT_SZ, length)) )
        {
            // content-encoding? 
            if (FastQueryResponseHeader(HTTP_QUERY_CONTENT_ENCODING,
                                    (LPVOID *) &lpszBuf,
                                    &length,
                                    index) == ERROR_SUCCESS ) 
            {
                fContentEnc = TRUE;
            }
            fVary = TRUE;
            goto check_need_file;
        }
    }

    if (GetCacheFlags() & INTERNET_FLAG_NO_CACHE_WRITE)
    {
        goto check_need_file;
    }

    //
    // accept HTTP/1.0 or downlevel server responses
    //

    if ((GetStatusCode() == HTTP_STATUS_OK) || (GetStatusCode() == 0))
    {
        if (FastQueryResponseHeader(HTTP_QUERY_CONTENT_TYPE, (LPVOID *) &lpszBuf, &length, 0) == ERROR_SUCCESS)
        {
            if (FExcludedMimeType(lpszBuf, length))
            {

                DEBUG_PRINT(CACHE,
                            INFO,
                            ("%s Mime Excluded from caching\n",
                            lpszBuf
                            ));

                goto check_need_file;
            }
        }

        //
        // BUGBUG should we also check for size and keep an upper bound?
        //

        ok = TRUE;
        goto quit;

    }
    else
    {
        INTERNET_SCHEME schemeType = GetSchemeType();

        if ((schemeType == INTERNET_SCHEME_FTP)
        || (schemeType == INTERNET_SCHEME_GOPHER))
        {
            ok = TRUE;
            goto quit;
        }
    }

check_need_file:

    INET_ASSERT (!ok);

    if (GetCacheFlags() & INTERNET_FLAG_NEED_FILE
        || GetCacheFlags () & INTERNET_FLAG_HYPERLINK)
    {
        //
        // Create a download file but don't commit it to the cache.
        //

        BETA_LOG (DOWNLOAD_FILE_NEEDED);

        fForceToCache = !ok;
        ok = TRUE;
        if( !fContentEnc )
        {
            // if content-enc, the client will write to cache...
            // so we should not delete the data file
            SetDeleteDataFile();
        }

        DEBUG_PRINT(CACHE, INFO, ("don't commit file\n"));
    }
    else
    {
        BETA_LOG (DOWNLOAD_FILE_NOT_NEEDED);
    }

quit:

    if ((!ok || fForceToCache) && !fVary)
    {
        SetCacheWriteDisabled();

        // Deleting originally cached files if (& only if) the server sends cache-control headers.
        // Bugs 98644 and 101578
        if (fNoCache)
        {
            _RequestHeaders.LockHeaders();

            // In 5.0, Rosebud worked like this:

            // 1. A call to CommitUrlCacheEntry with a file size of about 11 bytes.
            // 2. A call to HttpSendRequest. 
            // 3. A call to DeleteUrlCacheEntry that succeeds.
            // 4. Another call to CommitUrlCacheEntry for the same file, except it's grown.
            // 5. Repeat 3 and 4 until file is downloaded.

            // However, we made a change so that if the server sends "no-cache", we'll
            // delete any cache entry during the call in (2). This caused Rosebud to break
            // We don't want to go back to the original behaviour, since that would introduce
            // IE 94486. So we look for a Translate: F header to guide us.

            DWORD dwIndex = 0;
            BOOL fFound = FALSE;
            TCHAR szValue[MAX_PATH];
            DWORD ccValue = ARRAY_ELEMENTS(szValue);
            while (ERROR_SUCCESS==QueryRequestHeader(
                                       "Translate",
                                       ARRAY_ELEMENTS("Translate")-1,
                                       (LPVOID)szValue,
                                       &ccValue,
                                       0,
                                       &dwIndex))
            {
                if (!StrCmpI(szValue, "F"))
                {
                    fFound = TRUE;
                    break;
                }
                ccValue = ARRAY_ELEMENTS(szValue);
            }

            _RequestHeaders.UnlockHeaders();
            if (!fFound)
            {
                DeleteUrlCacheEntry(GetOriginalUrl());
            }
        }
    }
    
    _ResponseHeaders.UnlockHeaders();

    PERF_LOG(PE_CACHE_WRITE_CHECK_END);

    DEBUG_LEAVE(ok);

    return ok;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FAddIfModifiedSinceHeader(
    IN LPCACHE_ENTRY_INFO lpCEI
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpCEI   -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FAddIfModifiedSinceHeader",
                 "%#x",
                 lpCEI
                 ));

    PERF_ENTER(FAddIfModifiedSinceHeader);

    char buff[64], buffh[256];
    DWORD dwLen, error;
    BOOL success = FALSE;

    INET_ASSERT (FT2LL(lpCEI->LastModifiedTime));

    dwLen = sizeof(buff);

    if (FFileTimetoHttpDateTime(&(lpCEI->LastModifiedTime), buff, &dwLen))
    {
        LPSTR pszBuf;

        if (lpCEI->CacheEntryType & HTTP_1_1_CACHE_ENTRY)
        {
            INET_ASSERT (dwLen);
            pszBuf = buff;
        }
        else
        {
            dwLen = wsprintf(buffh, "%s; length=%d", buff, lpCEI->dwSizeLow);
            pszBuf = buffh;
        }

        DEBUG_PRINT(CACHE,
                    INFO,
                    ("%s %s - empty\n",
                    GlobalKnownHeaders[HTTP_QUERY_IF_MODIFIED_SINCE].Text,
                    buffh
                    ));

        error = ReplaceRequestHeader(HTTP_QUERY_IF_MODIFIED_SINCE,
                                     pszBuf,
                                     dwLen,
                                     0,                 // no index
                                     ADD_HEADER_IF_NEW
                                     );
        if ((error == ERROR_SUCCESS) || (error == ERROR_HTTP_HEADER_ALREADY_EXISTS))
        {
            if (error == ERROR_SUCCESS)
            {
                // we added the header on behalf of the app. This is equivalent
                // to the app having specified INTERNET_FLAG_RESYNCHRONIZE

                SetAutoSync();
            }
            success = TRUE;
        }
    }

    PERF_LEAVE(FAddIfModifiedSinceHeader);
    DEBUG_LEAVE(success);
    return success;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::AddHeaderIfEtagFound(
    IN LPCACHE_ENTRY_INFO lpCEI
    )

/*++

Routine Description:

    Adds if-modified-since header if an etag was present in the cache entry headers.

Arguments:

    lpCEI   -

Return Value:

    BOOL

--*/

{
    if (!(lpCEI->CacheEntryType & HTTP_1_1_CACHE_ENTRY))
        return TRUE;

    // BUGBUG - always parsing, use flag.
    CHAR buf[512];

    DWORD nIndex = 0, cbBuf = 512, dwError = ERROR_SUCCESS;

    HTTP_HEADER_PARSER hp((CHAR*) lpCEI->lpHeaderInfo, lpCEI->dwHeaderInfoSize);

    if (hp.FindHeader((CHAR*) lpCEI->lpHeaderInfo, HTTP_QUERY_ETAG,
            0, buf, &cbBuf, &nIndex) == ERROR_SUCCESS)
    {
        DWORD dwQueryIndex;

        if (lpCEI->CacheEntryType & SPARSE_CACHE_ENTRY)
        {
            dwQueryIndex = HTTP_QUERY_IF_RANGE;
        }
        else
        {
            dwQueryIndex = HTTP_QUERY_IF_NONE_MATCH;
        }

        dwError = ReplaceRequestHeader(dwQueryIndex,
                                       buf,
                                       cbBuf,
                                       0,
                                       ADD_HEADER_IF_NEW
                                       );
    }

    if ((dwError == ERROR_SUCCESS) || (dwError == ERROR_HTTP_HEADER_ALREADY_EXISTS))
        return TRUE;

    return FALSE;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheRetrieval(
    IN BOOL bReset,
    IN BOOL bOffline,
    IN BOOL bNoRetrieveIfExist
    )

/*++

Routine Description:

    Starts retrieving data for this object from the cache

Arguments:

    bReset  - if TRUE, forcefully reset the (keep-alive) connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheRetrieval",
                 "%B, %B",
                 bReset,
                 bOffline
                 ));

    PERF_LOG(PE_CACHE_RETRIEVE_START);

    DWORD error;
    LPSTR lpHeaders = NULL;

    if (bOffline)
    {
        if (!IsOffline() && IsCacheReadDisabled())
        {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }

        if( !bNoRetrieveIfExist )
            error = UrlCacheRetrieve (TRUE);
        else
            error = ERROR_SUCCESS;

        if (error != ERROR_SUCCESS)
            goto quit2;
    }

    INET_ASSERT(_hCacheStream && _pCacheEntryInfo);

    //
    // RecordCacheRetrieval() will set end-of-file if it succeeds
    //

    error = RecordCacheRetrieval (_pCacheEntryInfo);
    if (error != ERROR_SUCCESS)
    {
        UrlCacheUnlock();
        goto quit2;
    }


    if (bOffline && lstrcmp(_pCacheEntryInfo->lpszSourceUrlName, GetCacheKey()))
    {
        // Simulate a redirect to the client.
        InternetIndicateStatusString
            (INTERNET_STATUS_REDIRECT, _pCacheEntryInfo->lpszSourceUrlName);

        // The cache translated through a redirect.
        FreeSecondaryCacheKey (); // POST redirects must be to GET
        SetURL (_pCacheEntryInfo->lpszSourceUrlName);
    }

    if (bOffline &&
        (_pCacheEntryInfo->CacheEntryType & MUST_REVALIDATE_CACHE_ENTRY))
    {
        INET_ASSERT (_pCacheEntryInfo->CacheEntryType & HTTP_1_1_CACHE_ENTRY);
        
        // Offline mode. Check for a Cache-Control: must-revalidate header.
        // If so, allow cache data to be retrieved only if not expired.
        FILETIME ftCurrentTime;
        GetCurrentGmtTime(&ftCurrentTime);

        LONGLONG qwExpire = FT2LL(_pCacheEntryInfo->ExpireTime);
        LONGLONG qwCurrent = FT2LL(ftCurrentTime);

        if (qwCurrent > qwExpire)
        {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }
        else
        {
            goto check_if_modified_since;
        }
    }

check_if_modified_since:

    if (!IsOffline() && IsCacheReadDisabled())
    {
        //
        // We are in offline mode.  (Really should assert this.)
        // Allow cache data to be retrieved only if last-modified time is
        // STRICTLY greater than if-modified-since time added by client.
        //

        LONGLONG qwLastModified = FT2LL(_pCacheEntryInfo->LastModifiedTime);

        LONGLONG qwIfModifiedSince;
        SYSTEMTIME stIfModifiedSince;
        DWORD length = sizeof(stIfModifiedSince);
        DWORD index = 0;

        _RequestHeaders.LockHeaders();

        error = QueryRequestHeader(HTTP_QUERY_IF_MODIFIED_SINCE,
                                   &stIfModifiedSince,
                                   &length,
                                   HTTP_QUERY_FLAG_SYSTEMTIME,
                                   &index
                                   );

        _RequestHeaders.UnlockHeaders();

        if (error != ERROR_SUCCESS)
        {
            // It's theoretically possible the client was redirected,
            // removed i-m-s on redirect callback, then went offline.
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }

        if (!SystemTimeToFileTime(&stIfModifiedSince,
                                  (FILETIME*)&qwIfModifiedSince))
        {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }

        if (qwLastModified <= qwIfModifiedSince)
        {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }
    }

    // allocate buffer for headers

    lpHeaders = (LPSTR)ALLOCATE_FIXED_MEMORY(_pCacheEntryInfo->dwHeaderInfoSize);
    if (!lpHeaders)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    memcpy(lpHeaders, _pCacheEntryInfo->lpHeaderInfo, _pCacheEntryInfo->dwHeaderInfoSize);

    // we are hijacking the HTTP request object. If there is already
    // a pending network operation (we started a network transaction
    // but realised that we have the same data in cache (i.e. the
    // data has not expired since we last wrote it to cache)) then
    // we need to kill it

    if (bReset)
    {   
        // if we have a keep-alive connection AND the server returned
        // 304 then the parameter can be FALSE so that we don't kill
        // the connection, just release it
        //
        // ResetObject() will reset end-of-file if it succeeds
        //
        // We DO NOT clear out the request headers so that the app can still
        // query them if necessary

//dprintf(">>> resetting %s\n", GetURL());
        error = ResetObject(!(IsKeepAlive() && (GetBytesInSocket() == 0)), FALSE);
        if (error != ERROR_SUCCESS)
            goto quit;
    }

    error = CreateResponseHeaders(&lpHeaders, _pCacheEntryInfo->dwHeaderInfoSize);
    if (error != ERROR_SUCCESS)
        goto quit;

    error = AddTimestampsFromCacheToResponseHeaders(_pCacheEntryInfo);
    if (error != ERROR_SUCCESS) 
        goto quit;

    /* Send notification about past cookie-events on this URL */
    InternetCookieHistory history;
    DWORD dwEntryType = _pCacheEntryInfo->CacheEntryType;

    history.fAccepted   = (dwEntryType & COOKIE_ACCEPTED_CACHE_ENTRY);
    history.fLeashed    = (dwEntryType & COOKIE_LEASHED_CACHE_ENTRY);
    history.fDowngraded = (dwEntryType & COOKIE_DOWNGRADED_CACHE_ENTRY);
    history.fRejected   = (dwEntryType & COOKIE_REJECTED_CACHE_ENTRY);    

    if (history.fAccepted   || 
        history.fLeashed    ||
        history.fDowngraded ||
        history.fRejected)
        InternetIndicateStatus (INTERNET_STATUS_COOKIE_HISTORY, 
                                (void*) &history, 
                                sizeof(history));

    /* Reevaluate P3P policy to generate policy notifications */ 
    ExtractSetCookieHeaders(NULL);

    // we have to set end-of-file again: RecordCacheRetrieval() set
    // it, then we wiped it out in ResetObject()
    // FYI: We set end-of-file because we have all the data in the
    // stream available locally; it doesn't mean that our virtual
    // stream pointer is positioned at the end of the file

    DEBUG_PRINT(CACHE, INFO, ("Found in the cache\n"));

    SetState(HttpRequestStateObjectData);
    SetFromCache();
    SetEndOfFile();
    SetHaveContentLength(TRUE);
    _VirtualCacheFileSize =
        _RealCacheFileSize =
            _BytesRemaining =
                _ContentLength = _pCacheEntryInfo->dwSizeLow;

    INET_ASSERT (error == ERROR_SUCCESS);

quit:
    if (error != ERROR_SUCCESS)
        EndCacheRetrieval();
    if (lpHeaders)
        FREE_MEMORY(lpHeaders);

quit2:

    PERF_LOG(PE_CACHE_RETRIEVE_END);
    DEBUG_LEAVE(error);
    return error;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheWrite(
    VOID
    )

/*++

Routine Description:

    Preps the cache for writing. Sets up the cache filename with an extension
    based on the MIME type and optionally writes the headers to the cache data
    stream

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - Success

        FALSE   - Failure

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheWrite",
                 NULL
                 ));

    PERF_ENTER(FHttpBeginCacheWrite);

    INET_ASSERT(!IsCacheReadInProgress());
    INET_ASSERT(!IsCacheWriteInProgress());

    PERF_TRACE(FHttpBeginCacheWrite, 1);

    _ResponseHeaders.LockHeaders();

    LPSTR lpszFileExtension = NULL;
    BOOL fIsUncertainMime = FALSE;
    char cExt[DEFAULT_MAX_EXTENSION_LENGTH + 1];
    char buf[256];

    DWORD dwLen, cbFileName, dwIndex;
    CHAR *ptr, *pToken, *pszFileName = NULL;
    CHAR szFileName[MAX_PATH];
    LPSTR lpszBuf;

    // Create a temp local cache file.

    // If we find a Content-Disposition header, parse out any filename and use it.
    if (QueryResponseHeader (HTTP_QUERY_CONTENT_DISPOSITION,
        buf, &(dwLen = sizeof(buf)), 0, &(dwIndex = 0) ) == ERROR_SUCCESS)
    {
        // Could have multiple tokens in it. Scan for the "filename" token.
        ptr = pToken = buf;
        while (ptr = StrTokEx2(&pToken, ";"))
        {
            // Skip any leading ws in token.
            SKIPWS(ptr);

            // Compare against "filename".
            if (!strnicmp(ptr, FILENAME_SZ, FILENAME_LEN))
            {
                // Found it.
                ptr += FILENAME_LEN;

                // Skip ws before '='.
                SKIPWS(ptr);

                // Must have '='
                if (*ptr == '=')
                {
                    // Skip any ws after '=' and point
                    // to beginning of the file name
                    ptr++;
                    SKIPWS(ptr);

                    // Skip past any quotes
                    if (*ptr == '\"')
                        ptr++;

                    SKIPWS(ptr);

                    cbFileName = strlen(ptr);

                    if (cbFileName)
                    {
                        // Ignore any trailing quote.
                        if (ptr[cbFileName-1] == '\"')
                            cbFileName--;
                            
                        memcpy(szFileName, ptr, cbFileName);
                        szFileName[cbFileName] = '\0';
                        pszFileName = szFileName;
                    }
                }
                break;
            }
        }
    }

    // Either no Content-disposition header or filename not parsed.
    if (!pszFileName)
    {
        DWORD dwMimeLen;
        if ((FastQueryResponseHeader(HTTP_QUERY_CONTENT_ENCODING, (LPVOID *) &lpszBuf, &dwMimeLen, 0) == ERROR_SUCCESS) && 
            StrCmpNI(lpszBuf,"binary",6) )
        {
            // if there is content encoding, we should not use
            // content-type for file extension

            //Modifying this for bug 98611.
            //For 'binary' encoding use the Content-Type to find extension
            lpszFileExtension = NULL;
        }

        else if (FastQueryResponseHeader(HTTP_QUERY_CONTENT_TYPE, (LPVOID *) &lpszBuf, &dwMimeLen, 0) == ERROR_SUCCESS)
        {
            dwLen = sizeof(cExt);
            fIsUncertainMime = strnicmp(lpszBuf, "text/plain", dwMimeLen)==0;

            PERF_TRACE(FHttpBeginCacheWrite, 2);

            if (!fIsUncertainMime &&
                GetFileExtensionFromMimeType(lpszBuf, dwMimeLen, cExt, &dwLen))
            {

                //
                // get past the '.' because the cache expects it that way
                //

                lpszFileExtension = &cExt[1];
            }
        }

        //
        // if we couldn't get the MIME type or failed to map it then try to get
        // the file extension from the object name requested
        //

        if (lpszFileExtension == NULL)
        {
            dwLen = sizeof(cExt);

            PERF_TRACE(FHttpBeginCacheWrite, 3);

            lpszFileExtension = GetFileExtensionFromUrl(GetURL(), &dwLen);
            if (lpszFileExtension != NULL)
            {
                memcpy(cExt, lpszFileExtension, dwLen);
                cExt[dwLen] = '\0';
                lpszFileExtension = cExt;
            }

            PERF_TRACE(FHttpBeginCacheWrite, 4);

        }

        if ((lpszFileExtension == NULL) && fIsUncertainMime)
        {

            INET_ASSERT(sizeof(szDefaultExtension) < DEFAULT_MAX_EXTENSION_LENGTH);

            strcpy(cExt, szDefaultExtension);
            lpszFileExtension = cExt;
        }
    }

    //
    // BUGBUG - BeginCacheWrite() wants the estimated file size, but we just
    //          give it 0 for now
    //

    //dwError = pRequest->BeginCacheWrite(dwLen, lpszFileExtension);

    PERF_TRACE(FHttpBeginCacheWrite, 5);

    DWORD dwError = BeginCacheWrite(0, lpszFileExtension, pszFileName);

    PERF_TRACE(FHttpBeginCacheWrite, 6);

    _ResponseHeaders.UnlockHeaders();

    PERF_LEAVE(FHttpBeginCacheWrite);

    BOOL success = (dwError == ERROR_SUCCESS);

    DEBUG_LEAVE(success);

    return success;
}


/*============================================================================
IsExpired (...)

4/17/00 (RajeevD) Corrected back arrow behavior and wrote detailed comment.
 
We have a cache entry for the URL.  This routine determines whether we should
synchronize, i.e. do an if-modified-since request.  This answer depends on 3
factors: navigation mode, expiry on cache entry if any, and syncmode setting.

1. There are two navigation modes:
a. hyperlinking - clicking on a link, typing a URL, starting browser etc.
b. back/forward - using the back or forward buttons in the browser.

In b/f case we generally want to display what was previously shown.  Ideally
wininet would cache multiple versions of a given URL and trident would specify
which one to use when hitting back arrow.  For now, the best we can do is use
the latest (only) cache entry or resync with the server.

EXCEPTION: if the cache entry sets http/1.1 cache-control: must-revalidate,
we treat as if we were always hyperlinking to the cache entry.  This is 
normally used during offline mode to suppress using a cache entry after
expiry.  This overloaded usage gives sites a workaround if they dislike our
new back button behavior.

2. Expiry may fall into one of 3 buckets:
a. no expiry information
b. expiry in past of current time (hyperlink) or last-access time (back/fwd)
c. expiry in future of current time (hyperlink) or-last access time (back/fwd)

3. Syncmode may have 3 settings
a. always - err on side of freshest data at expense of net perf.
b. never - err on side of best net perf at expense of stale data.
c. once-per-session - middle-of-the-road setting
d. automatic - slight variation of once-per-session where we decay frequency
of i-m-s for images that appear to be static.  This is the default.

Based on these factors, there are 5 possible result values in matrices below:
1   synchronize
0   don't synchronize
?   synchronize if last-sync time was before start of the current session, 
?-  Like per-session except if URL is marked static and has a delay interval.
0+  Don't sync if URL is marked static, else fall back to per-session


HYPERLINKING

When hyperlinking, expiry takes precedence, then we look at syncmode.

                No Expiry       Expiry in Future    Expiry in Past
Syncmode                        of Current Time     of Current Time
                               
   Always           1                   0                   1  


   Never            0                   0                   1


   Per-Session      ?                   0                   1


   Automatic        ?-                  0                   1

   
BACK/FORWARD

When going back or forward, we generally don't sync.  The exception is if
we should have sync'ed the URL on the previous navigate but didn't.  We
deduce this by looking at the last-sync time of the entry.


                No Expiry       Expiry in Future    Expiry in Past
Syncmode                        of Last-Access Time of Last-Access Time
    
   Always           ?                   0                   ?


   Never            0                   0                   ?


   Per-Session      ?                   0                   ?


   Automatic        0+                  0                   ?


When considering what might have happened when hyperlinking to this URL,
the decision tree has 5 outcomes:
1. We might have had no cache entry and downloaded to cache for the first time
2. Else we might have had a cache entry and used it w/o i-m-s
3. Else we did i-m-s but the download was aborted
4. Or the i-m-s returned not modified
5. Or the i-m-s returned new content
Only in case 3 do we want to resync the cache entry.

============================================================================*/

BOOL IsExpired (
        CACHE_ENTRY_INFOEX* pInfo, 
        DWORD dwCacheFlags, 
        BOOL* pfLazyUpdate )
{
    BOOL fExpired;
    FILETIME ftCurrentTime;
    GetCurrentGmtTime (&ftCurrentTime);

    if ((dwCacheFlags & INTERNET_FLAG_FWD_BACK)
        && !(pInfo->CacheEntryType & MUST_REVALIDATE_CACHE_ENTRY))
    {
        // BACK/FORWARD CASE

        if (FT2LL (pInfo->ExpireTime) != LONGLONG_ZERO)
        {
            // We have an expires time.
            if (FT2LL (pInfo->ExpireTime) > FT2LL(pInfo->LastAccessTime))
            {
                // Expiry was in future of last access time, so don't resync.
                fExpired = FALSE;
            }                
            else
            {
                // Entry was originally expired.  Make sure it was sync'ed once.
                fExpired = (FT2LL(pInfo->LastSyncTime) < dwdwSessionStartTime);
            }
        }
        else switch (GlobalUrlCacheSyncMode)
        {
            default:
            case WININET_SYNC_MODE_AUTOMATIC:
                if (pInfo->CacheEntryType & STATIC_CACHE_ENTRY)
                {
                    fExpired = FALSE;
                    break;
                }
            // else intentional fall-through...
        
            case WININET_SYNC_MODE_ALWAYS:
            case WININET_SYNC_MODE_ONCE_PER_SESSION:
                fExpired = (FT2LL(pInfo->LastSyncTime) < dwdwSessionStartTime);
                break;

            case WININET_SYNC_MODE_NEVER:
                fExpired = FALSE;
                break;
                
        } // end switch
    }
    else
    {
        // HYPERLINKING CASE

        // Always strictly honor expire time from the server.
        INET_ASSERT(pfLazyUpdate);
        *pfLazyUpdate = FALSE;
        
        if(   (pInfo->CacheEntryType & POST_CHECK_CACHE_ENTRY ) &&
             !(dwCacheFlags & INTERNET_FLAG_BGUPDATE) )
        {
            //
            // this is the (instlled) post check cache entry, so we will do
            // post check on this ietm
            //
            fExpired = FALSE;
            *pfLazyUpdate = TRUE;
            
        }
        else if (FT2LL(pInfo->ExpireTime) != LONGLONG_ZERO)
        {
            // do we have postCheck time?
            //
            //           ftPostCheck                   ftExpire
            //               |                            |
            // --------------|----------------------------|-----------> time
            //               |                            | 
            //   not expired |   not expired (bg update)  |   expired
            //
            //               
            LONGLONG qwPostCheck = FT2LL(pInfo->ftPostCheck);
            if( qwPostCheck != LONGLONG_ZERO )
            {
                LONGLONG qwCurrent = FT2LL(ftCurrentTime);

                if( qwCurrent < qwPostCheck )
                {
                    fExpired = FALSE;
                }
                else
                if( qwCurrent < FT2LL(pInfo->ExpireTime) ) 
                {
                    fExpired = FALSE;

                    // set background update flag  
                    // (only if we are not doing lazy updating ourselfs)
                    if ( !(dwCacheFlags & INTERNET_FLAG_BGUPDATE) )
                    {
                        *pfLazyUpdate = TRUE;
                    }
                }
                else
                {
                    fExpired = TRUE;
                }
            }
            else 
                fExpired = FT2LL(pInfo->ExpireTime) <= FT2LL(ftCurrentTime);
        }
        else switch (GlobalUrlCacheSyncMode)
        {

            case WININET_SYNC_MODE_NEVER:
                // Never check, unless the page has expired
                fExpired = FALSE;
                break;

            case WININET_SYNC_MODE_ALWAYS:
                fExpired = TRUE;
                break;

            default:
            case WININET_SYNC_MODE_AUTOMATIC:

                if (pInfo->CacheEntryType & STATIC_CACHE_ENTRY)
                {
                    // We believe this entry never actually changes.
                    // Check the entry if interval since last checked
                    // is less than 25% of the time we had it cached.
                    LONGLONG qwTimeSinceLastCheck = FT2LL (ftCurrentTime)
                        - FT2LL(pInfo->LastSyncTime);
                    LONGLONG qwTimeSinceDownload = FT2LL (ftCurrentTime)
                        - FT2LL (pInfo->ftDownload);
                    fExpired = qwTimeSinceLastCheck > qwTimeSinceDownload/4;
                    break;
                }
                // else intentional fall through to once-per-session rules.

            case WININET_SYNC_MODE_ONCE_PER_SESSION:

                fExpired = TRUE;

                // Huh. We don't have an expires, so we'll improvise
                // but wait! if we are hyperlinking then there is added
                // complication. This semantic has been figured out
                // on Netscape after studying various sites
                // if the server didn't send us expiry time or lastmodifiedtime
                // then this entry expires when hyperlinking
                // this happens on queries

                if (dwCacheFlags & INTERNET_FLAG_HYPERLINK
                    && !FT2LL(pInfo->LastModifiedTime))
                {
                    // shouldn't need the hyperlink test anymore
                    DEBUG_PRINT(UTIL, INFO, ("Hyperlink semantics\n"));
                    INET_ASSERT(fExpired==TRUE);
                    break;
                }

                // We'll assume the data could change within a day of the last time
                // we sync'ed.
                // We want to refresh UNLESS we've seen the page this session
                // AND the session's upper bound hasn't been exceeded.
                if      ((dwdwSessionStartTime < FT2LL(pInfo->LastSyncTime))
                    &&
                        (FT2LL(ftCurrentTime) < FT2LL(pInfo->LastSyncTime) + 
                            dwdwHttpDefaultExpiryDelta))
                {                    
                    fExpired = FALSE;
                }            
                break;

        } // end switch
        
    } // end else for hyperlinking case
        

#ifdef DBG
        char buff[64];
        PrintFileTimeInInternetFormat(&ftCurrentTime, buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Current Time: %s\n", buff));
        PrintFileTimeInInternetFormat(&(pInfo->ExpireTime), buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Expiry Time: %s\n", buff));
        PrintFileTimeInInternetFormat(&(pInfo->ftPostCheck), buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("PostCheck Time: %s\n", buff));
        PrintFileTimeInInternetFormat(&(pInfo->LastSyncTime), buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Last Sync Time: %s\n", buff));
        PrintFileTimeInInternetFormat(&(pInfo->ftDownload), buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Last Download Time: %s\n", buff));
        PrintFileTimeInInternetFormat((FILETIME *)&dwdwSessionStartTime, buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Session start Time: %s\n", buff));
        DEBUG_PRINT(UTIL, INFO, ("CacheFlags=%x\n", dwCacheFlags));
        DEBUG_PRINT(HTTP, INFO,
            ("CheckExpired: Url %s Expired \n", (fExpired ? "" : "Not")));
#endif //DBG
        
    return fExpired;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePreNetIO(
    VOID
    )

/*++

Routine Description:

    Check if in the cache. If so, check for expired, if expired do if-modified
    -since, else get from the cache.

Arguments:

    None.

Return Value:

    DWORD   Windows Error Code
        ERROR_SUCCESS: started retrieval from the cache
        ERROR_FILE_NOT_FOUND: go to the wire

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePreNetIO",
                 NULL
                 ));

    PERF_LOG(PE_CACHE_EXPIRY_CHECK_START);

    DWORD error = ERROR_FILE_NOT_FOUND;

    if (_pCacheEntryInfo || IsCacheReadDisabled())
    {
        INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
        goto done;
    }

    PERF_LOG(PE_TRACE, 0x91);

    //
    // See if we have a cache entry and if so lock it.
    //

    // Check for the cdrom insertion case Set error to
    // ERROR_INTERNET_INSERT_CDROM ONLY only in this
    // case, since this will be handled. Otherwise,
    // error defaults to ERROR_FILE_NOT_FOUND.
    DWORD dwError;
    dwError = UrlCacheRetrieve(FALSE);
    if (dwError != ERROR_SUCCESS)
    {
        if (dwError == ERROR_INTERNET_INSERT_CDROM)
            error = dwError;
        else
            BETA_LOG (CACHE_MISS);
        goto done;
    }

    if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
    {

        //
        // Open the file so it can't be deleted.
        //

        _CacheFileHandle =
            CreateFile
            (
                _pCacheEntryInfo->lpszLocalFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

        //
        // Check the file size.
        //

        if (_CacheFileHandle == INVALID_HANDLE_VALUE
            || (_pCacheEntryInfo->dwSizeLow !=
               SetFilePointer (_CacheFileHandle, 0, NULL, FILE_END)))
        {

            FREE_MEMORY (_pCacheEntryInfo);
            _pCacheEntryInfo = NULL;
            INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
            goto done;
        }

        // We have a partial cache entry for this URL.  No need to check
        // for expiry or correct user.  Add a Range: header to get the
        // rest of the data.

        char szBuf[64];
        DWORD cbBuf =
            wsprintf (szBuf, "bytes=%d-", _pCacheEntryInfo->dwSizeLow);
        if (ERROR_SUCCESS != ReplaceRequestHeader
            (HTTP_QUERY_RANGE, szBuf, cbBuf, 0, ADD_HEADER))
        {
            goto done;
        }

        //
        // If there was Last-Modified-Time, add Unless-Modified-Since header,
        // which assures coherency in the event the URL data changed since
        // the partial download.
        //
        if (FT2LL(_pCacheEntryInfo->LastModifiedTime) != LONGLONG_ZERO)
        {
            cbBuf = sizeof(szBuf);
            FFileTimetoHttpDateTime(&(_pCacheEntryInfo->LastModifiedTime),
                szBuf, &cbBuf);

            ReplaceRequestHeader (
                HTTP_QUERY_UNLESS_MODIFIED_SINCE,
                szBuf, cbBuf, 0, ADD_HEADER
            );
        }

        //
        // Similarly, if the entry has a 1.1 ETag, add the If-Range header.
        //

        AddHeaderIfEtagFound(_pCacheEntryInfo);

    }
    else
    {
        PERF_LOG(PE_TRACE, 0x93);

        BOOL fIsExpired = IsExpired 
            (_pCacheEntryInfo, GetCacheFlags(), &_fLazyUpdate);


        PERF_LOG(PE_TRACE, 0x94);

        //
        // found the cache entry
        // if it is expired, or we are asked to do if-modified-since
        // then we do it. However, if the entry is an Installed entry,
        // we skip netio unless the entry is also marked EDITED_CACHE_ENTRY
        // and the client has specifically asked for
        // INTERNET_OPTION_BYPASS_EDITED_ENTRY.

        if ((!(_pCacheEntryInfo->CacheEntryType & INSTALLED_CACHE_ENTRY)
            || ((_pCacheEntryInfo->CacheEntryType & EDITED_CACHE_ENTRY)
            && GlobalBypassEditedEntry))
             && (fIsExpired || (GetCacheFlags() & INTERNET_FLAG_RESYNCHRONIZE)
             ))
        {

            //
            // add if-modified-since only if there is lastmodifiedtime
            // sent back by the site. This way you never get into trouble
            // where the sitedoesn't send you an lastmodtime and you
            // send if-modified-since based on a clock which might be ahead
            // of the site. So the site might say nothing is modified even though
            // something might be. www.microsoft.com is one such example
            //
            if (FT2LL(_pCacheEntryInfo->LastModifiedTime) != LONGLONG_ZERO)
            {
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("%s expired, doing IF-MODIFIED-SINCE\n",
                            GetURL()
                            ));

                PERF_LOG(PE_TRACE, 0x97);
                FAddIfModifiedSinceHeader(_pCacheEntryInfo);
                PERF_LOG(PE_TRACE, 0x98);
            }

            // If this is an HTTP 1.1 then check to see if an Etag:
            // header is present and add an If-None-Match header.
            AddHeaderIfEtagFound(_pCacheEntryInfo);

            INET_ASSERT(error == ERROR_FILE_NOT_FOUND);

        }
        else
        {

            //
            // The cache entry is not expired, so we don't hit the net.
            //

            BETA_LOG (CACHE_NOT_EXPIRED);
            PERF_LOG(PE_TRACE, 0x99);
            ReuseObject();
            error = FHttpBeginCacheRetrieval(FALSE, FALSE);
            INET_ASSERT (error == ERROR_SUCCESS);
        }
    }

done:
    PERF_LOG(PE_CACHE_EXPIRY_CHECK_END);
    DEBUG_LEAVE(error);
    return (error);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePostNetIO(
    IN DWORD dwStatusCode,
    IN BOOL fVariation
    )

/*++

Routine Description:

    Check if this response needs to be cached or pulled from the cache
    after we have received the response from the net. Here we check for
    if-modified-since.

Arguments:

    dwStatusCode    - HTTP status code

Return Value:

    DWORD   Windows Error Code

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePostNetIO",
                 "%d",
                 dwStatusCode
                 ));

    DWORD error = ERROR_FILE_NOT_FOUND;
    BOOL fLastModTimeFromServer = FALSE;
    BOOL fExpireTimeFromServer = FALSE;
    BOOL fPostCheckTimeFromServer = FALSE;

    //
    // check if
    // we can actually read the data from the cache after all. The idea here is
    // to improve efficiency by returning data from the cache if it hasn't
    // changed at the server. We determine this by the server returning a 304
    // response, or by determining that the date on the response is less than or
    // equal to the expires timestamp on the data we already wrote to cache
    //

    INET_ASSERT((dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
                || (dwStatusCode == HTTP_STATUS_PRECOND_FAILED)
                || (dwStatusCode == HTTP_STATUS_OK)
                || (dwStatusCode == HTTP_STATUS_PARTIAL_CONTENT)
                || (dwStatusCode == 0));

    GetTimeStampsForCache(&_ftExpires,
                          &_ftLastModified,
                          &_ftPostCheck,
                          &fExpireTimeFromServer,
                          &fLastModTimeFromServer,
                          &fPostCheckTimeFromServer
                          );

    if (IsCacheReadDisabled())
    {
        INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
        goto quit;
    }

    //
    // we may have no cache entry info, so no point in continuing - this file
    // was not in the cache when we started. (We could try to retrieve again
    // in case another download has put it in the cache)
    //

    if (_pCacheEntryInfo == NULL)
    {
        if (fVariation)
        {
            error = UrlCacheRetrieve(TRUE);
        }
        if (error!=ERROR_SUCCESS)
        {
            goto quit;
        }
    }

    if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
    {

        if (dwStatusCode == HTTP_STATUS_PARTIAL_CONTENT)
        {
            BETA_LOG (CACHE_RESUMED);
            error = ResumePartialDownload();
        }
        else
        {
            BETA_LOG (CACHE_NOT_RESUMED);
            INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
        }

        goto quit;
    }

    //
    // we are optimizing further here
    // if the return status is OK and the server sent us a
    // last modified time and this time is the same as
    // what we got earlier then we use the entry from the cache
    //

    if ((dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
        || ((fLastModTimeFromServer)
            && (FT2LL(_ftLastModified)
                == FT2LL(_pCacheEntryInfo->LastModifiedTime))
            && GetMethodType() == HTTP_METHOD_TYPE_GET))
    {
        BETA_LOG (CACHE_NOT_MODIFIED);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("response code=%d %s, using cache entry\n",
                    GetStatusCode(),
                    GetURL()
                    ));

        DWORD dwAction = CACHE_ENTRY_SYNCTIME_FC;
        GetCurrentGmtTime(&(_pCacheEntryInfo->LastSyncTime));

        if (fExpireTimeFromServer)
        {
            (_pCacheEntryInfo->ExpireTime).dwLowDateTime = _ftExpires.dwLowDateTime;
            (_pCacheEntryInfo->ExpireTime).dwHighDateTime = _ftExpires.dwHighDateTime;
            dwAction |= CACHE_ENTRY_EXPTIME_FC;
        }

        // update the cache entry type if needed
        DWORD dwType;
        dwType = GetCacheEntryType();
        if (dwType)
            _pCacheEntryInfo->CacheEntryType |= dwType;
        dwAction |= CACHE_ENTRY_TYPE_FC;

        //
        // Update the last sync time to the current time
        // so we can do once_per_session logic
        //
        if (!SetUrlCacheEntryInfoA(_pCacheEntryInfo->lpszSourceUrlName, _pCacheEntryInfo, dwAction))
        {
            // NB if this call fails, the worst that could happen is
            // that next time around we will do an if-modified-since
            // again
            INET_ASSERT(FALSE);
        }
        
        error = FHttpBeginCacheRetrieval(TRUE, FALSE);
        
        if (error != ERROR_SUCCESS)
        {
            //
            // if we failed to abort the transaction, or to retrieve the
            // data from the cache, then return the error only if the
            // response if not OK. Otherwise we can continue and
            // get the data
            //

            if (dwStatusCode != HTTP_STATUS_OK)
            {
                // this should never happen to us

                INET_ASSERT(FALSE);

                error = ERROR_FILE_NOT_FOUND;
            }
        }

    }
    else // We could not use the cache entry so release it.
    {
        BETA_LOG (CACHE_MODIFIED);
        INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
    }

quit:

    if (error != ERROR_SUCCESS)
        UrlCacheUnlock();
    DEBUG_LEAVE(error);
    return error;
}


DWORD HTTP_REQUEST_HANDLE_OBJECT::ResumePartialDownload(void)

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ResumePartialDownload",
                 NULL));

    _ResponseHeaders.LockHeaders();

    const static char sz200[] = "200";

    INET_ASSERT (!_CacheWriteInProgress);

    LPSTR pszHeader;
    DWORD cbHeader;

    // Retrieve the start and end of Content-Range header
    if (!_iSlotContentRange)
        goto quit;
    pszHeader = _ResponseHeaders.GetHeaderPointer
        (_ResponseBuffer, _iSlotContentRange);
    INET_ASSERT (pszHeader);
    PSTR pszLimit;
    pszLimit = StrChr (pszHeader, '\n');
    INET_ASSERT (pszLimit);
    *pszLimit = 0;

    // Extract the document length as a string and number.
    // The http 1.1 spec is very explicit that we MUST parse
    // the header and return an error if invalid.  We expect
    // it to be of the form Content-Range: bytes xxx-yyy/zzz.
    PSTR pszStart, pszEnd, pszLength;
    DWORD dwStart, dwEnd, dwLength;

    // Ensure that value is prefixed with "bytes"
    PSTR pszBytes;
    pszBytes = pszHeader + (GlobalKnownHeaders[HTTP_QUERY_CONTENT_RANGE].Length+1); // +1 for the ':'
    SKIPWS (pszBytes);
    if (strnicmp (pszBytes, BYTES_SZ, BYTES_LEN))
        goto quit;

    // Parse and validate start of range.
    pszStart = pszBytes + BYTES_LEN;
    SKIPWS (pszStart);
    dwStart = StrToInt (pszStart);
    if (dwStart != _pCacheEntryInfo->dwSizeLow)
        goto quit;

    // Parse and validate end of range.
    pszEnd = StrChr (pszStart, '-');
    if (!pszEnd++)
        goto quit;
    dwEnd = StrToInt (pszEnd);
    if (dwStart > dwEnd)
        goto quit;

    // Parse and validate length.
    pszLength = StrChr (pszEnd, '/');
    if (!pszLength)
        goto quit;
    pszLength++;
    dwLength = StrToInt (pszLength);
    if (dwEnd + 1 != dwLength)
        goto quit;

    // The Content-Length header is the amount transmitted, however
    // as far as the client is concerned only the total amount of
    // data matters, so we fix it up from the Content-Range header.
    // Use the Content-Range buffer for the new Content-Length.
    // We know the buffer is big enough because the last number
    // in the Content-Range header is the new Content-Length value.
    _ContentLength = dwLength;

    // Remove the old Content-Length header, if any.
    if (_iSlotContentLength)
    {
        _ResponseHeaders.RemoveAllByIndex(HTTP_QUERY_CONTENT_LENGTH);
        //_ResponseHeaders.RemoveHeader (_iSlotContentLength, HTTP_QUERY_CONTENT_LENGTH, &_bKnownHeaders[dwQueryIndex]);
    }
    
    cbHeader = wsprintf (pszHeader, "%s: %d", GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Text,
            dwLength);
    _ResponseHeaders.ShrinkHeader
            (_ResponseBuffer, _iSlotContentRange, HTTP_QUERY_CONTENT_RANGE, HTTP_QUERY_CONTENT_LENGTH, cbHeader);

    // Fix up the response headers to appear same as a 200 response.
    // Revise the status line from 206 to 200.  The status code
    // starts after the first space, e.g. "HTTP/1.0 206 Partial Content"
    pszHeader = _ResponseHeaders.GetHeaderPointer (_ResponseBuffer, 0);
    INET_ASSERT (pszHeader);
    LPSTR pszStatus;
    pszStatus = StrChr (pszHeader, ' ');
    SKIPWS (pszStatus);
    INET_ASSERT (!memcmp(pszStatus, "206", 3));
    memcpy (pszStatus, sz200, sizeof(sz200));
    _ResponseHeaders.ShrinkHeader (_ResponseBuffer, 0,
            HTTP_QUERY_STATUS_TEXT, HTTP_QUERY_STATUS_TEXT,
            (DWORD) (pszStatus - pszHeader) + sizeof(sz200) - 1);
    _StatusCode = HTTP_STATUS_OK;

    // Some servers omit "Accept-Ranges: bytes" since it is implicit
    // in a 206 response.  This is important to Adobe Amber ActiveX
    // control and other clients that may issue their own range
    // requests. Add the header if not present.
    if (!IsResponseHeaderPresent(HTTP_QUERY_ACCEPT_RANGES))
    {
        const static char szAccept[] = "Accept-Ranges: bytes";
        DWORD dwErr = AddInternalResponseHeader
            (HTTP_QUERY_ACCEPT_RANGES, (LPSTR) szAccept, CSTRLEN(szAccept));
        INET_ASSERT (dwErr == ERROR_SUCCESS);
    }    

    // Adjust the handle values for socket read and file write positions.
    if (IsKeepAlive())
        _BytesRemaining = _ContentLength;
    _VirtualCacheFileSize = dwStart;
    _RealCacheFileSize    = dwStart;
    SetAvailableDataLength (dwStart);

    // Save the cache file path.
    INET_ASSERT(!_CacheFileName);
    _CacheFileName = NewString(_pCacheEntryInfo->lpszLocalFileName);
    if (!_CacheFileName)
        goto quit;

    // Open the file for read (should already be open for write)
    INET_ASSERT (_CacheFileHandle != INVALID_HANDLE_VALUE);

    _CacheFileHandleRead = CreateFile (_CacheFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, NULL);
    if (_CacheFileHandleRead == INVALID_HANDLE_VALUE)
        goto quit;

    // We can discard the partial cache entry info.
    FREE_MEMORY (_pCacheEntryInfo);
    _pCacheEntryInfo = NULL;

    _CacheWriteInProgress = TRUE;

quit:

    _ResponseHeaders.UnlockHeaders();

    DWORD dwErr;

    if (_CacheWriteInProgress)
    {
        dwErr = ERROR_SUCCESS;
    }
    else
    {
        INET_ASSERT (FALSE);

        dwErr = ERROR_HTTP_INVALID_SERVER_RESPONSE;

        if (_CacheFileName)
        {
            FREE_MEMORY (_CacheFileName);
            _CacheFileName = NULL;
        }
        if (_CacheFileHandleRead != INVALID_HANDLE_VALUE)
        {
            CloseHandle (_CacheFileHandleRead);
            _CacheFileHandleRead = INVALID_HANDLE_VALUE;
        }
    }

    DEBUG_LEAVE (dwErr);
    return dwErr;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::AddTimestampsFromCacheToResponseHeaders(
    IN LPCACHE_ENTRY_INFO lpCacheEntryInfo
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpCacheEntryInfo    -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::AddTimestampsFromCacheToResponseHeaders",
                 "%#x",
                 lpCacheEntryInfo
                 ));

    PERF_LOG(PE_TRACE, 0x701);

    _ResponseHeaders.LockHeaders();

    DWORD error = AddTimeHeader(lpCacheEntryInfo->ExpireTime,
                                HTTP_QUERY_EXPIRES
                                );

    if (error == ERROR_SUCCESS) {
        error = AddTimeHeader(lpCacheEntryInfo->LastModifiedTime,
                              HTTP_QUERY_LAST_MODIFIED
                              );
    }

    if (error == ERROR_INVALID_PARAMETER) {
        error = ERROR_SUCCESS;
    }

    _ResponseHeaders.UnlockHeaders();

    PERF_LOG(PE_TRACE, 0x702);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::AddTimeHeader(
    IN FILETIME fTime,
    IN DWORD dwHeaderIndex
    )

/*++

Routine Description:

    Adds a time header to this object

Arguments:

    fTime               - FILETIME value to add as header value

    dwHeaderIndex       - contains an index into a global array of Header strings.

    NOTE: Must be called under Header Critical Section!!!

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    Couldn't convert fTime

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::AddTimeHeader",
                 "%#x:%#x, %u [%q]",
                 fTime.dwLowDateTime,
                 fTime.dwHighDateTime,
                 dwHeaderIndex,
                 GlobalKnownHeaders[dwHeaderIndex].Text
                 ));

    char buf[MAX_PATH];
    SYSTEMTIME systemTime;
    DWORD error = ERROR_SUCCESS;

    if (FT2LL(fTime) != LONGLONG_ZERO) {
        if (FileTimeToSystemTime((CONST FILETIME *)&fTime, &systemTime)) {
            memcpy(buf, GlobalKnownHeaders[dwHeaderIndex].Text, GlobalKnownHeaders[dwHeaderIndex].Length);
            buf[GlobalKnownHeaders[dwHeaderIndex].Length]   = ':';
            buf[GlobalKnownHeaders[dwHeaderIndex].Length+1] = ' ';
            if (InternetTimeFromSystemTime((CONST SYSTEMTIME *)&systemTime,
                                           INTERNET_RFC1123_FORMAT,
                                           buf + (GlobalKnownHeaders[dwHeaderIndex].Length+2),
                                           sizeof(buf) - (GlobalKnownHeaders[dwHeaderIndex].Length+2)
                                           )) {
                error = AddInternalResponseHeader(dwHeaderIndex, buf, lstrlen(buf));

                INET_ASSERT(error == ERROR_SUCCESS);

                //
                // if it came upto here and all went well, only then would
                // the error be set to ERROR_SUCCESS
                //

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Cache: Adding header %s, errorcode=%d\n",
                            buf,
                            error
                            ));

            } else {

                INET_ASSERT(FALSE);

                error = ERROR_INVALID_PARAMETER;
            }
        } else {

            INET_ASSERT(FALSE);

            error = ERROR_INVALID_PARAMETER;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL HTTP_REQUEST_HANDLE_OBJECT::IsPartialResponseCacheable(void)

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    LPSTR lpszHeader;
    DWORD cbHeader;
    DWORD dwIndex;

    BOOL fRet = FALSE;
    DWORD err;

    _ResponseHeaders.LockHeaders();

    if (GlobalDisableReadRange || GetMethodType() != HTTP_METHOD_TYPE_GET)
    {
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }

    if (_RealCacheFileSize >= _ContentLength)
    {
        // We don't handle chunked transfer upon resuming a partial
        // download, so we require a Content-Length header.  Also,
        // if download file is actually complete, yet not committed
        // to cache (possibly because the client didn't read to eof)
        // then we don't want to save a partial download.  Otherwise
        // we might later start a range request for the file starting
        // one byte beyond eof.  MS Proxy 1.0 will return an invalid
        // 206 response containing the last byte of the file.  Other
        // servers or proxies that follow the latest http spec might
        // return a 416 response which is equally useless to us.
        
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }

    // For HTTP/1.0, must have last-modified time, otherwise we
    // don't have a way to tell if the partial downloads are coherent.
    if (!IsResponseHttp1_1() && (FT2LL(_ftLastModified) == 0))
    {
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }

    if (!_iSlotContentRange)
    {
        // We didn't get a Content-Range header which implies the server
        // supports byte range for this URL, so we must look for the
        // explicit invitation of "Accept-Ranges: bytes" response header.

        dwIndex = 0;
        err = FastQueryResponseHeader (HTTP_QUERY_ACCEPT_RANGES,
            (LPVOID *) &lpszHeader,&cbHeader, dwIndex);
        if (err != ERROR_SUCCESS || !(cbHeader == BYTES_LEN && !strnicmp(lpszHeader, BYTES_SZ, cbHeader)) )
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    if (!IsResponseHttp1_1())
    {
        // For HTTP/1.0, only cache responses from Server: Microsoft-???/*
        // Microsoft-PWS-95/*.* will respond with a single range but
        // with incorrect Content-Length and Content-Range headers.
        // Other 1.0 servers may return single range in multipart response.

        const static char szPrefix[] = "Microsoft-";
        const static DWORD ibSlashOffset = sizeof(szPrefix)-1 + 3;

        dwIndex = 0;
        if (    ERROR_SUCCESS != FastQueryResponseHeader (HTTP_QUERY_SERVER,
                    (LPVOID *) &lpszHeader, &cbHeader, dwIndex)
            ||  cbHeader <= ibSlashOffset
            ||  lpszHeader[ibSlashOffset] != '/'
            ||  memcmp (lpszHeader, szPrefix, sizeof(szPrefix) - 1)
           )
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    else // if (IsResponseHttp1_1())
    {
        // For http 1.1, must have strong etag.  A weak etag starts with
        // a character other than a quote mark and cannot be used as a 
        // coherency validator.  IIS returns a weak etag when content is
        // modified within a single file system time quantum.
        
        if (ERROR_SUCCESS != FastQueryResponseHeader (HTTP_QUERY_ETAG,
                (LPVOID *) &lpszHeader, &cbHeader, 0)
            || *lpszHeader != '\"')
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    fRet = TRUE;

quit:

    _ResponseHeaders.UnlockHeaders();

    return fRet;
 }


DWORD
HTTP_REQUEST_HANDLE_OBJECT::LocalEndCacheWrite(
    IN BOOL fNormal
    )

/*++

Routine Description:

    Finishes up the cache-write operation, either committing the cache entry or
    deleting it (because we failed)

Arguments:

    fNormal - TRUE if normal end-cache-write operation (i.e. FALSE if error)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                  ERROR_INTERNET_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::LocalEndCacheWrite",
                 "%B",
                 fNormal
                 ));

    PERF_LOG(PE_TRACE, 0x2001);

    LPSTR lpszBuf = NULL;
    char buff[256];
    DWORD dwBuffLen;
    DWORD dwError;
    DWORD dwUserNameHeader = 0;
    LPSTR lpszHeaderInfo = NULL;

    DWORD dwEntryType = GetCacheEntryType();

    if (!fNormal)
    {
        if (!IsPartialResponseCacheable())
        {
            BETA_LOG (DOWNLOAD_ABORTED);
        }
        else
        {
            //
            // Flush any buffered data to disk.
            // BUGBUG: doesn't work with chunked transfer
            // WriteResponseBufferToCache();
            // WriteQueryBufferToCache();
            //

            // dprintf ("wininet: partial cached %s\n", GetURL());

            BETA_LOG (DOWNLOAD_PARTIAL);

            fNormal = TRUE;
            dwEntryType = SPARSE_CACHE_ENTRY;

            //
            // Disable InternetUnlockRequest
            //

            LOCK_REQUEST_INFO* pLock =
                (LOCK_REQUEST_INFO*) GetLockRequestHandle();
            if (pLock)
                pLock->fNoDelete = TRUE;
        }
    }

    if (fNormal)
    {
        if (GetCacheFlags() & INTERNET_FLAG_MAKE_PERSISTENT)
            dwEntryType |= STICKY_CACHE_ENTRY;

        if (GetSecondaryCacheKey())
            dwEntryType |= POST_RESPONSE_CACHE_ENTRY;

        if (IsResponseHttp1_1())
        {
            dwEntryType |= HTTP_1_1_CACHE_ENTRY;
            if (IsMustRevalidate())
                dwEntryType |= MUST_REVALIDATE_CACHE_ENTRY;
        }                
        
        if (IsPerUserItem())
        {
            //
            // create per-user header, e.g. "~U:JoeBlow\r\n", if it fits in the
            // buffer
            //

            INET_ASSERT(vdwCurrentUserLen);

            dwUserNameHeader = sizeof(vszUserNameHeader) - 1
                             + vdwCurrentUserLen
                             + sizeof("\r\n");
            if (sizeof(buff) >= dwUserNameHeader)
            {
                memcpy(buff, vszUserNameHeader, sizeof(vszUserNameHeader) - 1);

                DWORD dwSize = lstrlen(vszCurrentUser);

                memcpy(&buff[sizeof(vszUserNameHeader) - 1],
                       vszCurrentUser,
                       dwSize);
                dwSize += sizeof(vszUserNameHeader) - 1;
                memcpy(&buff[dwSize], "\r\n", sizeof("\r\n"));
            }
            else
            {
                // if it failed, mark it as expired

                dwUserNameHeader = 0;
                GetCurrentGmtTime(&_ftExpires);
                AddLongLongToFT(&_ftExpires, (-1)*(ONE_HOUR_DELTA));
            }
        }

        //
        // start off with 512 byte buffer (used to be 256, but headers are
        // getting larger)
        //

        dwBuffLen = 512;

        do
        {
            DWORD dwPreviousLength;

            lpszBuf = (LPSTR)ResizeBuffer(lpszBuf, dwBuffLen, FALSE);
            if (lpszBuf == NULL)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            dwBuffLen -= dwUserNameHeader;

            dwPreviousLength = dwBuffLen;
            lpszHeaderInfo = lpszBuf;
            lpszBuf[0] = '\0';

            dwError = QueryRawResponseHeaders(TRUE,
                                              (LPVOID)lpszHeaderInfo,
                                              &dwBuffLen
                                              );
            if (dwError == ERROR_SUCCESS)
            {

                FilterHeaders(lpszHeaderInfo, &dwBuffLen);
                if (dwUserNameHeader)
                {
                    lstrcat(lpszHeaderInfo, buff);
                    dwBuffLen += dwUserNameHeader;
                }
                break; // get out
            }

            //
            // we have the right error and we haven't allocated more memory yet
            //

            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                if (dwBuffLen <= dwPreviousLength)
                {
                    dwError = ERROR_INTERNET_INTERNAL_ERROR;
                    break;
                }

                dwBuffLen += dwUserNameHeader;
            }
            else
            {
                //
                // if HttpQueryInfo() returned ERROR_HTTP_DOWNLEVEL_SERVER
                // or we are making CERN proxy requests for FTP or gopher, then
                // there are no headers from the origin server, but the
                // operation succeeded
                //

                if (dwError == ERROR_HTTP_DOWNLEVEL_SERVER)
                    dwError = ERROR_SUCCESS;

                //
                // either allready tried once with allocation or
                // we got some error other than ERROR_INSUFFICIENT_BUFFER
                //

                INET_ASSERT(*lpszHeaderInfo == '\0');

                lpszHeaderInfo = NULL;
                dwBuffLen = 0;
                break;
            }

        } while (TRUE);

        fNormal = (dwError == ERROR_SUCCESS);
    }

    if (!fNormal)
    {
        dwEntryType = 0xffffffff;
        lpszHeaderInfo = NULL;
    }

    //
    // Simulate a redirect if the original object was the root
    // ("" or "/") and we did not otherwise get a redirect.
    //

    if (IsObjectRoot() && _OriginalUrl && !lstrcmpi (_OriginalUrl, GetURL()))
    {
        DWORD dwLen = lstrlen (_OriginalUrl);
        INET_ASSERT (_OriginalUrl[dwLen - 1] == '/');
        _OriginalUrl[dwLen - 1] = 0;
    }

    //
    // Let the cache know if the item is likely to be a static image.
    // 1. No expire time.
    // 2. Has last-modified time.
    // 3. The content-type is image/*
    // 4. No '?' in the URL.
    //

    LPSTR lpszHeader;
    DWORD cbHeader;
    BOOL fImage =
        (  !FT2LL(_ftExpires)
        && FT2LL(_ftLastModified)
        && (ERROR_SUCCESS == FastQueryResponseHeader (HTTP_QUERY_CONTENT_TYPE,
                (LPVOID *) &lpszHeader, &cbHeader, 0))
        && (StrCmpNI (lpszHeader, "image/", sizeof("image/")-1) == 0)
        && (!StrChr (GetURL(), '?'))
        );

    DEBUG_PRINT(CACHE,
                INFO,
                ("Cache write EntryType = %x\r\n",
                dwEntryType
                ));

    dwError = EndCacheWrite(&_ftExpires,
                            &_ftLastModified,
                            &_ftPostCheck,
                            dwEntryType,
                            dwBuffLen,
                            lpszHeaderInfo,
                            NULL,
                            fImage
                            );

    if (fNormal && !(dwEntryType & SPARSE_CACHE_ENTRY))
    {
        if (dwError == ERROR_SUCCESS)
        {
            BETA_LOG (DOWNLOAD_CACHED);
        }
        else
        {
            BETA_LOG (DOWNLOAD_NOT_CACHED);
        }
    }

    if (lpszBuf != NULL) {

        lpszBuf = (LPSTR)FREE_MEMORY(lpszBuf);

        INET_ASSERT(lpszBuf == NULL);

    }

    PERF_LOG(PE_TRACE, 0x2002);

    DEBUG_LEAVE(dwError);

    return dwError;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::GetTimeStampsForCache(
    OUT LPFILETIME lpftExpiryTime,
    OUT LPFILETIME lpftLastModTime,
    OUT LPFILETIME lpftPostCheckTime,
    OUT LPBOOL lpfHasExpiry,
    OUT LPBOOL lpfHasLastModTime,
    OUT LPBOOL lpfHasPostCheck
    )

/*++

Routine Description:

    extracts timestamps from the http response. If the timestamps don't exist,
    does the default thing. has additional goodies like checking for expiry etc.

Arguments:

    lpftExpiryTime      - returned expiry time

    lpftLatsModTime     - returned last-modified time

    lpfHasExpiry        - returned TRUE if the response header contains an expiry
                          timestamp. This patameter can be NULL

    lpfHasLastModTime   - returned TRUE if the response header contains a
                          last-modified timestamp. This patameter can be NULL


Return Value:

    None.

Comment:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetTimeStampsForCache",
                 "%#x, %#x, %#x, %#x",
                 lpftExpiryTime,
                 lpftLastModTime,
                 lpfHasExpiry,
                 lpfHasLastModTime
                 ));

    PERF_LOG(PE_TRACE, 0x9001);

    char buf[512];
    LPSTR lpszBuf;
    BOOL fRet;

    DWORD length, index = 0;
    BOOL fPostCheck = FALSE;
    BOOL fPreCheck = FALSE;
    FILETIME ftPreCheckTime;
    FILETIME ftPostCheckTime;

    fRet = FALSE;

    _ResponseHeaders.LockHeaders();

    // Determine if a Cache-Control: max-age header exists. If so, calculate expires
    // time from current time + max-age minus any delta indicated by Age:

    //
    // we really want all the post-fetch stuff works with 1.0 proxy
    // so we loose our grip a little bit here: enable all Cache-Control
    // max-age work with 1.0 response.
    //
    //if (IsResponseHttp1_1())
    {
        CHAR  *ptr, *pToken;
        INT nDeltaSecsPostCheck = 0;
        INT nDeltaSecsPreCheck = 0;

        while (1)
        {
            // Scan headers for Cache-Control: max-age header.
            length = sizeof(buf);
            switch (QueryResponseHeader(HTTP_QUERY_CACHE_CONTROL,
                buf,
                &length,
                0,
                &index))
            {
                case ERROR_SUCCESS:

                    buf[length] = '\0';
                    pToken = ptr = buf;

                    // Parse a token from the string; test for sub headers.
                    while (pToken = StrTokEx(&ptr, ","))
                    {
                        SKIPWS(pToken);

                        if (strnicmp(POSTCHECK_SZ, pToken, POSTCHECK_LEN) == 0)
                        {
                            pToken += POSTCHECK_LEN;

                            SKIPWS(pToken);

                            if (*pToken != '=')
                                break;

                            pToken++;

                            SKIPWS(pToken);

                            nDeltaSecsPostCheck = atoi(pToken);

                            // Calculate post fetch time 
                            GetCurrentGmtTime(&ftPostCheckTime);
                            AddLongLongToFT(&ftPostCheckTime, (nDeltaSecsPostCheck * (LONGLONG) 10000000));
                
                            fPostCheck = TRUE;
                        }

                        else if (strnicmp(PRECHECK_SZ, pToken, PRECHECK_LEN) == 0)
                        {
                            // found
                            pToken += PRECHECK_LEN;

                            SKIPWS(pToken);

                            if (*pToken != '=')
                                break;

                            pToken++;

                            SKIPWS(pToken);

                            nDeltaSecsPreCheck = atoi(pToken);

                            // Calculate pre fetch time (overwrites ftExpire ) 
                            GetCurrentGmtTime(&ftPreCheckTime);
                            AddLongLongToFT(&ftPreCheckTime, (nDeltaSecsPreCheck * (LONGLONG) 10000000));

                            fPreCheck = TRUE;
                        }

                        else if (strnicmp(MAX_AGE_SZ, pToken, MAX_AGE_LEN) == 0)
                        {
                            // Found max-age. Convert to integer form.
                            // Parse out time in seconds, text and convert.
                            pToken += MAX_AGE_LEN;

                            SKIPWS(pToken);

                            if (*pToken != '=')
                                break;

                            pToken++;

                            SKIPWS(pToken);

                            INT nDeltaSecs = atoi(pToken);
                            INT nAge;

                            // See if an Age: header exists.

							// Using a local index variable:
                            DWORD indexAge = 0;
                            length = sizeof(INT)+1;

                            if (QueryResponseHeader(HTTP_QUERY_AGE,
                                &nAge,
                                &length,
                                HTTP_QUERY_FLAG_NUMBER,
                                &indexAge) == ERROR_SUCCESS)

                            {
                                // Found Age header. Convert and subtact from max-age.
                                // If less or = 0, attempt to get expires header.
                                nAge = ((nAge < 0) ? 0 : nAge);

                                nDeltaSecs -= nAge;
                                if (nDeltaSecs <= 0)
									// The server (or some caching intermediary) possibly sent an incorrectly
									// calculated header. Use "Expires", if no "max-age" directives at higher indexes.
									// Note: This behaviour could cause a situation where the "pre-check"
									// and "post-check" are picked up from the current index, and "max-age" is
									// picked up from a higher index. "pre-check" and "post-check" are IE 5.x 
									// extensions, and generally not bunched together with "max-age", so this
									// should work fine. More info on "pre-check" and "post-check":
									// <http://msdn.microsoft.com/workshop/author/perf/perftips.asp#Use_Cache-Control_Extensions>
                                    continue;
                            }

                            // Calculate expires time from max age.
                            GetCurrentGmtTime(lpftExpiryTime);
                            //*((LONGLONG *)lpftExpiryTime) += (nDeltaSecs * (LONGLONG) 10000000);
                            AddLongLongToFT(lpftExpiryTime, (nDeltaSecs * (LONGLONG) 10000000));
                            fRet = TRUE;
                        }

                        else if (strnicmp(MUST_REVALIDATE_SZ, pToken, MUST_REVALIDATE_LEN) == 0)
                        {
                            pToken += MUST_REVALIDATE_LEN;
                            SKIPWS(pToken);
                            if (*pToken == 0 || *pToken == ',')
                                SetMustRevalidate();
                        }
                    }

                    // If an expires time has been found, break switch.
                    if (fRet)
                        break;
					
					// Need to bump up index to prevent possibility of never-ending outer while(1) loop.
					// Otherwise, on exit from inner while, we could be stuck here reading the 
					// Cache-Control at the same index.
					// QueryResponseHeader(HTTP_QUERY_CACHE_CONTROL, ...) will return either the next index,
					// or an error, and we'll be good to go:
					index++;
                    continue;

                case ERROR_INSUFFICIENT_BUFFER:
                    index++;
                    continue;

                default:
                    break; // no more Cache-Control headers.
            }

            //
            // pre-post fetch headers must come in pair, also
            // pre fetch header overwrites the expire 
            // and make sure postcheck < precheck
            //
            if( fPreCheck && fPostCheck && 
                ( nDeltaSecsPostCheck < nDeltaSecsPreCheck ) ) 
            {
                fRet = TRUE;
                *lpftPostCheckTime  = ftPostCheckTime;
                *lpftExpiryTime     = ftPreCheckTime;
                if( lpfHasPostCheck )
                    *lpfHasPostCheck = TRUE;

                if( nDeltaSecsPostCheck == 0 && 
                    !(GetCacheFlags() & INTERNET_FLAG_BGUPDATE) )
                {
                    //
                    // "post-check = 0"
                    // this page has already passed the lazy update time
                    // this means server wants us to do background update 
                    // after the first download  
                    //
                    // (bg fsm will be created at the end of the cache write)
                    //
                    _fLazyUpdate = TRUE;
                }

            }
            else
            {
                fPreCheck = FALSE;
                fPostCheck = FALSE;
            }

            break; // no more Cache-Control headers.
        }

    } // Is http 1.1


    // If no expires time is calculated from max-age, check for expires header.
    if (!fRet)
    {
        length = sizeof(buf) - 1;
        index = 0;
        if (QueryResponseHeader(HTTP_QUERY_EXPIRES, buf, &length, 0, &index) == ERROR_SUCCESS)
        {
            fRet = FParseHttpDate(lpftExpiryTime, buf);

            //
            // as per HTTP spec, if the expiry time is incorrect, then the page is
            // considered to have expired
            //

            if (!fRet)
            {
                GetCurrentGmtTime(lpftExpiryTime);
                AddLongLongToFT(lpftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
                fRet = TRUE;
            }
        }
    }

    // We found or calculated a valid expiry time, let us check it against the
    // server date if possible
    FILETIME ft;
    length = sizeof(buf) - 1;
    index = 0;

    if (QueryResponseHeader(HTTP_QUERY_DATE, buf, &length, 0, &index) == ERROR_SUCCESS
        && FParseHttpDate(&ft, buf))
    {

        // we found a valid Data: header

        // if the expires: date is less than or equal to the Date: header
        // then we put an expired timestamp on this item.
        // Otherwise we let it be the same as was returned by the server.
        // This may cause problems due to mismatched clocks between
        // the client and the server, but this is the best that can be done.

        // Calulating an expires offset from server date causes pages
        // coming from proxy cache to expire later, because proxies
        // do not change the date: field even if the reponse has been
        // sitting the proxy cache for days.

        // This behaviour is as-per the HTTP spec.


        if (FT2LL(*lpftExpiryTime) <= FT2LL(ft))
        {
            GetCurrentGmtTime(lpftExpiryTime);
            AddLongLongToFT(lpftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
        }
    }

    if (lpfHasExpiry)
    {
        *lpfHasExpiry = fRet;
    }

    if (!fRet)
    {
        lpftExpiryTime->dwLowDateTime = 0;
        lpftExpiryTime->dwHighDateTime = 0;
    }

    fRet = FALSE;
    length = sizeof(buf) - 1;
    index = 0;

    if (QueryResponseHeader(HTTP_QUERY_LAST_MODIFIED, buf, &length, 0, &index) == ERROR_SUCCESS)
    {
        DEBUG_PRINT(CACHE,
                    INFO,
                    ("Last Modified date is: %q\n",
                    buf
                    ));

        fRet = FParseHttpDate(lpftLastModTime, buf);

        if (!fRet)
        {
            DEBUG_PRINT(CACHE,
                        ERROR,
                        ("FParseHttpDate() returns FALSE\n"
                        ));
        }
    }

    if (lpfHasLastModTime)
    {
        *lpfHasLastModTime = fRet;
    }

    if (!fRet)
    {
        lpftLastModTime->dwLowDateTime = 0;
        lpftLastModTime->dwHighDateTime = 0;
    }

    _ResponseHeaders.UnlockHeaders();

    PERF_LOG(PE_TRACE, 0x9002);

    DEBUG_LEAVE(0);
}

//
// private functions
//


PRIVATE
VOID
FilterHeaders(
    IN LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwHeaderLen
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpszHeaderInfo  -
    lpdwHeaderLen   -

Return Value:

    None.

--*/

{
    PERF_LOG(PE_TRACE, 0x3001);

    DWORD i, len, lenT, reduced = 0, dwHeaderTableCount;
    LPSTR lpT, lpMark, lpNext, *lprgszHeaderExcludeTable;

    //
    // skip over the status line
    // NB this assumes that the raw buffer is nullterminated
    //

    if (lpvrgszHeaderExclusionTable) {
        lprgszHeaderExcludeTable = lpvrgszHeaderExclusionTable;
        dwHeaderTableCount = vdwHeaderExclusionTableCount;
    } else {
        lprgszHeaderExcludeTable = rgszExcludeHeaders;
        dwHeaderTableCount = sizeof(rgszExcludeHeaders) / sizeof(LPSTR);
    }

    lpT = strchr(lpszHeaderInfo, '\r');
    if (!lpT) {

        PERF_LOG(PE_TRACE, 0x3002);

        return;
    }

    INET_ASSERT(*(lpT + 1) == '\n');

    lpT += 2;

    do {

        //
        // find the header portion
        //

        lpMark = strchr(lpT, ':');
        if (!lpMark) {
            break;
        }

        //
        // get the end of the header line
        //

        lpNext = strchr(lpMark, '\r');

        if (!lpNext)
        {
            INET_ASSERT(FALSE);
            // A properly formed header _should_ terminate with \r\n, but sometimes
            // that just doesn't happen
            lpNext = lpMark;
            while (*lpNext)
            {
                lpNext++;
            }
        }
        else
        {
            INET_ASSERT(*(lpNext + 1) == '\n');
            lpNext += 2;
        }


        len = (DWORD) PtrDifference(lpMark, lpT) + 1; 
        lenT = *lpdwHeaderLen;  // doing all this to see it properly in debugger

        BOOL bFound = FALSE;

        for (i = 0; i < dwHeaderTableCount; ++i) {
            if (!strnicmp(lpT, lprgszHeaderExcludeTable[i], len)) {
                bFound = TRUE;
                break;
            }
        }
        if (bFound) {

            //
            // nuke this header
            //

            len = lenT - (DWORD)PtrDifference(lpNext, lpszHeaderInfo) + 1; // for NULL character

            //
            // ACHTUNG memove because of overlapped copies
            //

            memmove(lpT, lpNext, len);

            //
            // keep count of how much we reduced the header by
            //

            reduced += (DWORD) PtrDifference(lpNext, lpT);

            //
            // lpT is already properly positioned because of the move
            //

        } else {
            lpT = lpNext;
        }
    } while (TRUE);
    *lpdwHeaderLen -= reduced;

    PERF_LOG(PE_TRACE, 0x3003);
}


PRIVATE
BOOL
FExcludedMimeType(
    IN LPSTR lpszMimeType,
    IN DWORD dwMimeTypeSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpszMimeType    -

Return Value:

    BOOL

--*/

{
    PERF_LOG(PE_TRACE, 0x501);

    DWORD i;
    LPCSTR * lprgszMimeExcludeTable = rgszExcludedMimeTypes;
    DWORD dwMimeExcludeCount = (sizeof(rgszExcludedMimeTypes)/sizeof(LPSTR));
    const DWORD *lprgdwMimeExcludeTableOfSizes = rgdwExcludedMimeTypeSizes;

    if (lpvrgszMimeExclusionTable) {
        lprgszMimeExcludeTable = (LPCSTR *)lpvrgszMimeExclusionTable;
        dwMimeExcludeCount = vdwMimeExclusionTableCount;
        lprgdwMimeExcludeTableOfSizes = lpvrgdwMimeExclusionTableOfSizes;
    }
    for (i = 0; i < dwMimeExcludeCount; ++i) {
        if ((dwMimeTypeSize == lprgdwMimeExcludeTableOfSizes[i]) &&
            !strnicmp(lpszMimeType,
                      lprgszMimeExcludeTable[i],
                      lprgdwMimeExcludeTableOfSizes[i])) {

            PERF_LOG(PE_TRACE, 0x502);

            return TRUE;
        }
    }

    PERF_LOG(PE_TRACE, 0x503);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\cookieprompt.h ===
#include <wininetp.h>

/* 
 * Object for persisting cookie-decisions made by the user at prompt
 * Current implementation uses the registry for storage.
 */
class CCookiePromptHistory {

public:
    CCookiePromptHistory(const char *pchRegistryPath, bool fUseHKLM=false);
    ~CCookiePromptHistory();
    
    BOOL    lookupDecision(const char *pchHostName, 
                           const char *pchPolicyID, 
                           unsigned long *pdwDecision);

    BOOL    saveDecision(const char *pchHostName, 
                         const char *pchPolicyID, 
                         unsigned long dwDecision);

    BOOL    clearDecision(const char *pchHostName,
                          const char *pchPolicyID);

    BOOL    clearAll();

    /* Enumerate decisions in the prompt history.
       Only supports enumerating the default decision (eg policyID=empty) */
    unsigned long enumerateDecisions(char *pchSiteName, 
                                     unsigned long *pcbName, 
                                     unsigned long *pdwDecision,
                                     unsigned long dwIndex);

private:
    HKEY    OpenRootKey();
    BOOL    CloseRootKey(HKEY hkeyRoot);
    HKEY    lookupSiteKey(HKEY hkHistoryRoot, const char *pchName, bool fCreate=false);

    BOOL    _fUseHKLM;
    char    _szRootKeyName[MAX_PATH];
    HKEY    _hkHistoryRoot;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\cookiepolicy.cxx ===
#include <wininetp.h>

#include "cookiepolicy.h"
#include "urlmon.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) ((sizeof(x)/sizeof(x[0])))
#endif

extern IInternetSecurityManager* g_pSecMgr;
extern "C" DWORD GetZoneFromUrl(LPCSTR pszUrl);

GUID guidCookieSettings = {0xaeba21fa, 0x782a, 0x4a90, 0x97, 0x8d, 
                           0xb7, 0x21, 0x64, 0xc8, 0x01, 0x20};

GUID guid3rdPartySettings = {0xa8a88c49, 0x5eb2, 0x4990,
                             0xa1, 0xa2, 0x08, 0x76, 0x02, 0x2c, 0x85, 0x4f};

const wchar_t *SettingTemplate[];

/* static member definition */
CP3PSettingsCache  CCookieSettings::cookiePrefsCache;

/* settings signature strings */
const char gszP3PV1Signature[] = "IE6-P3PV1/settings:";
const wchar_t gszUnicodeSignature[] = L"IE6-P3PV1/settings:";

BOOL IsNoCookies(DWORD dwZone);
void SetNoCookies(DWORD dwZone, DWORD dwNewPolicy);

struct P3PSymbol {

    const char *pszAcronym;
    unsigned long dwSymIndex;
    unsigned long dwHashCode;
};

/* Macro for determining precedence of cookie actions.
   In IE6 the COOKIE_STATE_* enumeration is arranged such that higher values 
   take precedence. For example, downgrade overrides prompt.
   If one rule evaluates to "downgrade" while others evaluate to "prompt",
   the final decision is "downgrade". */
#define precedence(d)       (d)


 /* special symbols used for defining settings */
const char 
    SymNoPolicy[]       = "###",        /* No-policy */
    SymMissingCP[]      = "nopolicy",   /* Same as "no-policy" */
    SymConstDecision[]  = "%%%",        /* Constant settings */
    SymApplyAll[]       = "always",     /* Same as constant settings */
    SymSession[]        = "session";    /* exclude P3P from session-cookies */

const char *acronymSet[] = {

 /* purposes */
"CURa", "CURi", "CURo",
"ADMa", "ADMi", "ADMo",
"DEVa", "DEVi", "DEVo",
"CUSa", "CUSi", "CUSo",
"TAIa", "TAIi", "TAIo",
"PSAa", "PSAi", "PSAo",
"PSDa", "PSDi", "PSDo",
"IVAa", "IVAi", "IVAo",
"IVDa", "IVDi", "IVDo",
"CONa", "CONi", "CONo",
"HISa", "HISi", "HISo",
"TELa", "TELi", "TELo",
"OTPa", "OTPi", "OTPo",
 
 /* recipients */
"OURa", "OURi", "OURo",
"DELa", "DELi", "DELo",
"SAMa", "SAMi", "SAMo",
"OTRa", "OTRi", "OTRo",
"UNRa", "UNRi", "UNRo",
"PUBa", "PUBi", "PUBo",

 /* retention */
 "NOR", "STP", "LEG", "BUS", "IND", 

 /* categories */
 "PHY", "ONL", "UNI", "PUR", "FIN", "COM", "NAV", "INT", 
 "DEM", "CNT", "STA", "POL", "HEA", "PRE", "GOV", "OTC", 

 /* non-identifiable */
 "NID",

 /* disputes section */
 "DSP", 

 /* access */
 "NOI", "ALL", "CAO", "IDC", "OTI", "NON", 
 
 /* dispute resolution */
 "COR", "MON", "LAW",

 /* TST: token for indicating that a policy is test-version */
 "TST",
};


const int symbolCount = sizeof(acronymSet)/sizeof(char*);

P3PSymbol symbolIndex[symbolCount];

/* 537 is the smallest modulus number which makes the function 1-1 */
const int   HashModulus = 537;
unsigned char lookupArray[HashModulus];

/* This hash function is designed to be collision-free on the P3P 
compact-policy tokens. If new tokens are introduced, MUST
verify that the hash-values remain unique. */
unsigned int hashP3PSymbol(const char *symbol) {

    unsigned long ulValue = (symbol[0]<<24)  |
                            (symbol[1]<<16)  |
                            (symbol[2]<<8)   |
                            (symbol[3]);
    return (ulValue%HashModulus);
}

bool buildSymbolTable(void) {

    memset(lookupArray, 0xFF, sizeof(lookupArray));

    for (int si=0; si<symbolCount; si++) {

        const char *pstr = acronymSet[si];

        symbolIndex[si].pszAcronym = pstr;
        symbolIndex[si].dwSymIndex = si;

        /* Compute unique hash-code from first 3 letters, used for fast comparison */
        symbolIndex[si].dwHashCode = (pstr[0]<<16) | (pstr[1]<<8) | (pstr[2]);

        unsigned int hashIndex = hashP3PSymbol(pstr);
        lookupArray[hashIndex] = (unsigned char) si;
    }
    return true;
}

/* Search the symbol set used in P3P compact-policy declarations
   This function correctly deals with the optional "a" extension
   which can be added to some of the symbols.
   Returns index into the symbol-table or negative value for failure */
int findSymbol(const char *pstr) {

    static bool fReady = buildSymbolTable();

    /* all symbols recognized in P3P-V1 have 3 or 4 characters */
    int symlen = strlen(pstr);
    if (symlen<3 || symlen>4)
        return -1;

    /* compute hash-code for first 3 letters */
    unsigned long dwHashCode = (pstr[0]<<16) | (pstr[1]<<8) | (pstr[2]);

    for (int i=0; i<symbolCount; i++) {

        const char *pSymbol = acronymSet[i];

        /* first three letters MUST match exactly-- otherwise move to next symbol */
        if (symbolIndex[i].dwHashCode != dwHashCode)
            continue;

        /* if no extension is given "a" is implied */
        if (pSymbol[3]==pstr[3] || (pSymbol[3]=='a' && pstr[3]==0))
           return i;
    }

    return -1;
}

/* Semi-public version of the above function (exported by ordinal) */
INTERNETAPI_(int)   FindP3PPolicySymbol(const char *pszSymbol) {
    
    if (pszSymbol)
    {
        return findSymbol(pszSymbol);
    }
    else
    {
        return -1;
    }
}

int mapCookieAction(char ch) {

    int iAction = COOKIE_STATE_UNKNOWN;

    switch (ch) {

    case 'a': iAction = COOKIE_STATE_ACCEPT;      break;
    case 'p': iAction = COOKIE_STATE_PROMPT;      break;
    case 'l': iAction = COOKIE_STATE_LEASH;       break;
    case 'd': iAction = COOKIE_STATE_DOWNGRADE;   break;
    case 'r': iAction = COOKIE_STATE_REJECT;      break;

    default:
        break;
    };

    return iAction;
}

const char *getNextToken(const char *pch, char *pszToken, int cbToken, bool fWhiteSpc, int *pLength) {

    if (pch==NULL || pszToken==NULL || cbToken==0)
        return NULL;

    /* clear token and set optional length to zero */
    *pszToken = '\0';
    if (pLength)
        *pLength = 0;

    /* locate beginning of next token by skipping over white space */
    while (*pch && isspace(*pch))
        pch++;

    int tksize = 0;
    char chStart = *pch;

    if (fWhiteSpc) {    
        /* copy whole token to the space provided */
        while (*pch && !isspace(*pch) && tksize<cbToken)
            pszToken[tksize++] = *pch++;
    }
    else if (ispunct(*pch))
        pszToken[tksize++] = *pch++;
    else {
        /* copy alphanumeric token-- other characters are not included */
        while (*pch && isalnum(*pch) && tksize<cbToken)
            pszToken[tksize++] = *pch++;        
    }

    pszToken[tksize] = '\0';    /* zero-terminate string */

    /* store size of token in optional parameter */
    if (pLength)
        *pLength = tksize;

    /* Return the current position after token last-scanned */
    return pch;
}

void RefreshP3PSettings() {

    CCookieSettings::RefreshP3PSettings();
}

void CCookieSettings::RefreshP3PSettings() {

    cookiePrefsCache.evictAll();
}

bool CCookieSettings::extractCompactPolicy(const char *pszP3PHeader, char *pszPolicy, DWORD *pPolicyLen)
{
    static const char gszPolicyFieldName[] = "CP";

    unsigned long dwFieldLen = 0;
    char *pszValue = FindNamedValue((char*) pszP3PHeader, gszPolicyFieldName, &dwFieldLen);

    if (pszValue && dwFieldLen<*pPolicyLen) {

        *pPolicyLen = dwFieldLen;
        strncpy(pszPolicy, pszValue, dwFieldLen+1);
        pszPolicy[dwFieldLen] = '\0';
        return true;
    }

    /* Reaching this point implies header was incorrectly formatted or
       there is insufficient space to copy the policy */
    *pPolicyLen = dwFieldLen;
    return false;
}

/*
 * Converts a Unicode representation of P3P-V1 settings to ASCII.
 * The settings format is guaranteed to contain only ASCII characters,
 * which allows for the more efficient conversion below instead of
 * calling WideCharToMultiByte()
 */
void CCookieSettings::convertToASCII(char *pszSettings, int cbBytes) {

    wchar_t *pwszUC = (wchar_t*) pszSettings;

    for (int i=0; i<cbBytes/2; i++)
        *pszSettings++ = (char) *pwszUC++;

    *pszSettings = '\0'; // nil-terminate the string
}

/* 
 * Input: pointer to P3P header (contained in the struct P3PCookieState)
 * This functions parses the policy header, extracts and evaluates the
 * compact policy. Eval results are stored in the struct.
 */
int CCookieSettings::EvaluatePolicy(P3PCookieState *pState) {
    int nResult = dwNoPolicyDecision;
    char *pchCompactPolicy = NULL;
    unsigned long dwPolicySize = 2048;
    CompactPolicy sitePolicy;

    if (!pState)
        goto Cleanup;

    pState->fEvaluated = FALSE;

    pchCompactPolicy = (char *) ALLOCATE_FIXED_MEMORY(dwPolicySize);
    if (pchCompactPolicy == NULL)
        goto Cleanup;

    pState->fValidPolicy = pState->pszP3PHeader && 
                           extractCompactPolicy(pState->pszP3PHeader, pchCompactPolicy, &dwPolicySize);

    pState->fIncSession = fApplyToSC ? TRUE : FALSE;

    /* Are the settings independent of policy? */
    if (fConstant) {
        pState->fEvaluated = TRUE;  /* set privacy-eval flag */
        nResult = (pState->dwPolicyState = dwFixedDecision);
        goto Cleanup;
    }

    /* If there is no compact policy in the P3P header return
       the decision which would apply in the case of missing policy */
    if (! pState->fValidPolicy) {
        nResult = (pState->dwPolicyState = dwNoPolicyDecision);
        goto Cleanup;
    }

    /* Otherwise: found compact policy with valid syntax in P3P: header */
    pState->fEvaluated = TRUE;

    const char *pszCompactPolicy = pchCompactPolicy;

    int numTokens = 0;
    int finalDecision = COOKIE_STATE_ACCEPT;
    char achToken[128];

    while (*pszCompactPolicy) {

        pszCompactPolicy = getNextToken(pszCompactPolicy, achToken, sizeof(achToken));

        /* An empty token means we reached end of the header */
        if (!achToken[0])
            break;

        numTokens++;

        int symindex = findSymbol(achToken);

        if (symindex<0)     /* Unrecognized token? */
            continue;       /* Ignore-- equivalent to ACCEPT decision for that token */
        
        /* Update binary representation of compact-policy */
        sitePolicy.addToken(symindex);

        int tokenDecision = MPactions[symindex];

        if (precedence(tokenDecision) > precedence(finalDecision))
            finalDecision = tokenDecision;

        /* REJECT decisions are irreversible: no other value can override this */
        if (finalDecision==COOKIE_STATE_REJECT)
            break;
    }

    /* If there were no tokens in the policy, it is considered invalid.
       Note that unrecognized tokens also count towards the tally. */
    if (numTokens==0) {
        finalDecision = dwNoPolicyDecision;
        pState->fValidPolicy = FALSE;
    }
    else  {
        /* Additional evaluation rules */
        for (CPEvalRule *pRule = pRuleSet;
             pRule; 
             pRule=pRule->pNext) {

            int outcome = pRule->evaluate(sitePolicy);
    
            if (outcome != COOKIE_STATE_UNKNOWN) {
                finalDecision = outcome;
                break;
            }
        }
    }

    pState->cpSitePolicy = sitePolicy;

    nResult = (pState->dwPolicyState = finalDecision);

Cleanup:
    if (pchCompactPolicy)
        FREE_MEMORY(pchCompactPolicy);

    return nResult;
}

bool CCookieSettings::GetSettings(CCookieSettings **ppCookiePref, DWORD dwZone, BOOL f3rdParty) {

    /* symbolic value for corrupt settings */
    static CCookieSettings InvalidSettings(NULL, 0);

    bool fSuccess = false;

    *ppCookiePref = NULL;

    CCookieSettings *pCachedPref = cookiePrefsCache.lookupCookieSettings(dwZone, f3rdParty);

    if (pCachedPref && pCachedPref != &InvalidSettings) {
        *ppCookiePref = pCachedPref;
        fSuccess = true;
        goto ExitPoint;
    }
    else if (pCachedPref==&InvalidSettings)
        goto ExitPoint;

    if(WCHAR *pszSettings = new WCHAR[MaxPrivacySettings])
    {
        DWORD   dwSize = MaxPrivacySettings;

        if(ERROR_SUCCESS == PrivacyGetZonePreferenceW(
                                dwZone,
                                f3rdParty ? PRIVACY_TYPE_THIRD_PARTY : PRIVACY_TYPE_FIRST_PARTY,
                                NULL,
                                pszSettings,
                                &dwSize)
            && *pszSettings)
        {
            *ppCookiePref = new CCookieSettings((BYTE *)pszSettings, sizeof(WCHAR) * lstrlenW(pszSettings));
            cookiePrefsCache.saveCookieSettings(dwZone, f3rdParty, *ppCookiePref);
            fSuccess = true;
        }
        else {
            InvalidSettings.AddRef();
            cookiePrefsCache.saveCookieSettings(dwZone, f3rdParty, &InvalidSettings);
        }

        delete [] pszSettings;
    }

ExitPoint:
    return fSuccess;
}

bool CCookieSettings::GetSettings(CCookieSettings **pCookiePref, const char *pszURL, BOOL f3rdParty, BOOL fRestricted) {

    INET_ASSERT(pszURL);
    INET_ASSERT(pCookiePref);

    DWORD dwZone;

    if (fRestricted)
        dwZone = URLZONE_UNTRUSTED;
    else
        dwZone = GetZoneFromUrl(pszURL);

    return GetSettings(pCookiePref, dwZone, f3rdParty);
}

/* Constructor for interpreting settings in binary format */
CCookieSettings::CCookieSettings(unsigned char *pBinaryRep, int cb) {

    const int siglen = sizeof(gszP3PV1Signature)/sizeof(char);
   
    MPactions = NULL;
    pRuleSet = NULL;
    ppLast = &pRuleSet;

    iRefCount = 1;
    dwNoPolicyDecision = COOKIE_STATE_REJECT;
    fConstant = false;
    fApplyToSC = true;

    if (!pBinaryRep || cb<=0) {

        fConstant = true;
        dwFixedDecision = COOKIE_STATE_ACCEPT;
        return;
    }

    /* Create new zero-terminated copy of the settings which
       can be modified for parsing steps below */
    char *pszBuffer = new char[cb+2];
    
    memcpy(pszBuffer, pBinaryRep, cb);

    pszBuffer[cb] = pszBuffer[cb+1] = '\0';

    /* create and initialize array for token-settings
       default behavior for tokens not listed is ACCEPT */
    MPactions = new unsigned char[symbolCount];
    memset(MPactions, COOKIE_STATE_ACCEPT, sizeof(unsigned char)*symbolCount);

    wchar_t *pwszSettings = (wchar_t*) pszBuffer;
    
    /* convert Unicode representation to ASCII */
    convertToASCII(pszBuffer, cb);

    char *pszSettings = pszBuffer;

    /* check for signature at the beginning of the string */
    if (pszSettings == strstr(pszSettings, gszP3PV1Signature)) {

        /* signature found: advance to first token */
        pszSettings += siglen;

        /* loop over the string, examining individual tokens */
        while (*pszSettings) {

            char achToken[1024], *pEqSign;

            pszSettings = (char*) getNextToken(pszSettings, achToken, sizeof(achToken));

            if (!achToken[0])
                break;

            /* logical-expression rules are enclosed in forward slashes */
            if (achToken[0]=='/') {
                
                if (CPEvalRule *pRule = parseEvalRule(achToken+1))
                    addEvalRule(pRule);
                continue;
            }

            /* each setting has the format:  <acronym>[a|i|o]=[a|p|l|d|r] */
            pEqSign = strchr(achToken, '=');

            /* skip badly formatted settings */
            if (!pEqSign)
                continue;

            *pEqSign = '\0';

            /* determine cookie state for current token.
               its given by the character after the equal sign */
            int iTokenSetting = mapCookieAction(pEqSign[1]);

            if (iTokenSetting == COOKIE_STATE_UNKNOWN)
                continue;

            int symIndex = findSymbol(achToken);

            if (symIndex<0) { /* not one of standard compact-policy tokens? */
                /* meta-symbols are handled in a separate function */
                parseSpecialSymbol(achToken, iTokenSetting);
                continue;             /* otherwise ignore */
            }

            MPactions[symIndex] = (unsigned char) iTokenSetting;
        }
    }

    delete [] pszBuffer;
}

bool CCookieSettings::parseSpecialSymbol(char *pszToken, int iSetting) {

    if (!strcmp(pszToken, SymNoPolicy)  ||
        !strcmp(pszToken, SymMissingCP))
        dwNoPolicyDecision = iSetting;
    else if (!strcmp(pszToken, SymConstDecision) ||
             !strcmp(pszToken, SymApplyAll)) {
        fConstant = true;
        dwFixedDecision = iSetting;
    }
    else if (!strcmp(pszToken, SymSession) && iSetting==COOKIE_STATE_ACCEPT)
        fApplyToSC = false;
    else
        return false;

    return true;
}

void CCookieSettings::addEvalRule(CPEvalRule *pRule) {

    /* add evaluation rule at end of linked list */
    *ppLast = pRule;
    pRule->pNext = NULL;
    ppLast = & (pRule->pNext);    
}

void CCookieSettings::Release() {
    
    if (! --iRefCount)
        delete this;
}

CCookieSettings::~CCookieSettings() {

    /* Free array of token decisions */
    if (MPactions)
        delete [] MPactions;

    /* Free linked-list of evaluation rules */
    while (pRuleSet) {
        CPEvalRule *pNext = pRuleSet->pNext;
        delete pRuleSet;
        pRuleSet = pNext;
    }
}

/*
Implementation of CP3PSettingsCache
*/
CP3PSettingsCache::CP3PSettingsCache() {

    memset (stdCookiePref, 0 ,sizeof(stdCookiePref));
    memset (std3rdPartyPref, 0, sizeof(std3rdPartyPref));

    InitializeCriticalSection(&csCache);
}

CP3PSettingsCache::~CP3PSettingsCache() {

    DeleteCriticalSection(&csCache);
}

CCookieSettings *CP3PSettingsCache::lookupCookieSettings(DWORD dwZone, BOOL f3rdParty) {

    if (dwZone>MaxKnownZone)
        return NULL;

    CriticalSectOwner csOwner(&csCache);

    CCookieSettings **ppStore;

    // Choose storage based on whether cookie is 3rd-party
    if (f3rdParty)
        ppStore = std3rdPartyPref;
    else
        ppStore = stdCookiePref;

    // Increase reference count before returning pointer
    if (ppStore[dwZone])
        ppStore[dwZone]->AddRef();

    return ppStore[dwZone];
}

void    CP3PSettingsCache::saveCookieSettings(DWORD dwZone, BOOL f3rdParty, CCookieSettings *pSettings) {

    if (dwZone>MaxKnownZone)
        return;

    CriticalSectOwner csOwner(&csCache);

    CCookieSettings **ppStore;

    // Choose storage based on whether cookie is 3rd-party
    if (f3rdParty)
        ppStore = std3rdPartyPref;
    else
        ppStore = stdCookiePref;

    pSettings->AddRef();

    ppStore[dwZone] = pSettings;
}


void CP3PSettingsCache::evictAll() {

    CriticalSectOwner csOwner(&csCache);

    /* Release all settings.
       Destructors are not invoked if there are outstanding
       references left. (eg the settings are being used for evaluation)
       Object will be freed when all references are gone. */

    for (int i=0; i<MaxKnownZone; i++) {

        if (stdCookiePref[i])
            stdCookiePref[i]->Release();

        if (std3rdPartyPref[i])
            std3rdPartyPref[i]->Release();
    }

    /* zero-out the arrays */
    memset (stdCookiePref, 0 ,sizeof(stdCookiePref));
    memset (std3rdPartyPref, 0, sizeof(std3rdPartyPref));
}


/*
Implementation of CompactPolicy structure
*/
CompactPolicy CompactPolicy::operator & (const CompactPolicy &ps)   const {

    CompactPolicy result;

    result.qwLow = qwLow & ps.qwLow;
    result.qwHigh = qwHigh & ps.qwHigh;
    return result;
}

bool CompactPolicy::operator == (const CompactPolicy &ps)  const {

    return (qwLow==ps.qwLow)    &&
           (qwHigh==ps.qwHigh);
}

bool CompactPolicy::operator != (const CompactPolicy &ps)  const {

    return (qwLow!=ps.qwLow)    ||
           (qwHigh!=ps.qwHigh);
}

void CompactPolicy::addToken(int index) {

    const quadword mask = 1;

    if (index<64)
        qwLow |= mask << index;
    else if (index<128)
        qwHigh |= mask << (index-64);
}

int CompactPolicy::contains(int index) {

    quadword mask = 1 << (index%64);

    if (index<64)
        mask &= qwLow;
    else
        mask &= qwHigh;

    return (mask!=0);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Privacy settings API and helper functions
//
//////////////////////////////////////////////////////////////////////////////////////////////////

#define REGSTR_PATH_ZONE        L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones"
#define REGSTR_VAL_FIRST_PARTY  L"{AEBA21FA-782A-4A90-978D-B72164C80120}"
#define REGSTR_VAL_THIRD_PARTY  L"{A8A88C49-5EB2-4990-A1A2-0876022C854F}"

#define SIGNATURE_NONE          0
#define SIGNATURE_UNICODE       1
#define SIGNATURE_MULTIBYTE     2

#define MIN(a,b) (((DWORD_PTR)a) < ((DWORD_PTR)b) ? (a) : (b))

DWORD IsSignaturePresent(BYTE *pbBuffer, DWORD dwBufferBytes)
{
    if(dwBufferBytes && 0 == StrCmpNIW(
                (LPCWSTR)pbBuffer,
                gszUnicodeSignature,
                MIN(dwBufferBytes / sizeof(WCHAR), lstrlenW(gszUnicodeSignature))
                ))
    {
        return SIGNATURE_UNICODE;
    }

    if(dwBufferBytes && 0 == StrCmpNI(
                (LPCSTR)pbBuffer,
                gszP3PV1Signature,
                MIN(dwBufferBytes / sizeof(CHAR), lstrlenA(gszP3PV1Signature))
                ))
    {
        return SIGNATURE_MULTIBYTE;
    }

    return SIGNATURE_NONE;
}

void
CheckPrivacyDefaults(void)
{
    WCHAR   szRegPath[MAX_PATH], szValue[MAX_PATH];
    BOOL    fWriteSettings = TRUE;
    DWORD   dwError, dwLen = MAX_PATH;

    // build reg path
    wnsprintfW(szRegPath, MAX_PATH, L"%ws\\3", REGSTR_PATH_ZONE);

    dwError = SHGetValueW(
                    HKEY_CURRENT_USER,
                    szRegPath,
                    REGSTR_VAL_FIRST_PARTY,
                    NULL,
                    szValue,
                    &dwLen);

    switch(dwError)
    {
    case ERROR_SUCCESS:
        // check to see if the plaintext signature is present
        if(SIGNATURE_NONE == IsSignaturePresent((BYTE *)szValue, dwLen))
        {
            // plaintext signature not present, don't overwrite.
            fWriteSettings = FALSE;
        }
        break;
    case ERROR_FILE_NOT_FOUND:
        // no existing settings, write defaults
        break;
    case ERROR_MORE_DATA:
        // longer than max_path... not an old setting, so leave it alone
        fWriteSettings = FALSE;
        break;
    default:
        // unknown error, write defaults
        break;
    }

    if(fWriteSettings)
    {
        // Internet to Medium
        PrivacySetZonePreferenceW(URLZONE_INTERNET, PRIVACY_TYPE_FIRST_PARTY, PRIVACY_TEMPLATE_MEDIUM, NULL);
        PrivacySetZonePreferenceW(URLZONE_INTERNET, PRIVACY_TYPE_THIRD_PARTY, PRIVACY_TEMPLATE_MEDIUM, NULL);

        // Restriced to High
        PrivacySetZonePreferenceW(URLZONE_UNTRUSTED, PRIVACY_TYPE_FIRST_PARTY, PRIVACY_TEMPLATE_NO_COOKIES, NULL);
        PrivacySetZonePreferenceW(URLZONE_UNTRUSTED, PRIVACY_TYPE_THIRD_PARTY, PRIVACY_TEMPLATE_NO_COOKIES, NULL);
    }
}


//
// Obfuscation of settings string
//
// GetNextObsByte takes an OBS struct detailing the current placement.  4 bits of each value in bCode are
// taken to compute the substring length to contribute to the entire code.  The following bytes give
// the following contributions:
//
// 53 71 59 69 77 6a 63 51 43 67 51 78 72 45 67 4f
// 0b 0a 0d 05 0b 04 03 0b 02 04 08 0b 0b 04 04 08
//
// Total length: 119
//
// GetNextObsByte returns the 11 bytes of the array followed by the first 10,
// then 13, etc.


BYTE bCode[16] = {0x53, 0x71, 0x59, 0x69, 0x77, 0x6a, 0x63, 0x51, 0x43, 0x67, 0x51, 0x78, 0x72, 0x45, 0x67, 0x4f};

typedef struct _obs {
    INT     iCurNode;
    INT     iCurIndex;
} OBS, *POBS;

BYTE GetNextObsByte(POBS pobs)
{
    BYTE    bTarget = bCode[pobs->iCurIndex];

    pobs->iCurIndex++;
    if(pobs->iCurIndex > ((bCode[pobs->iCurNode] & 0x1e) >> 1))
    {
        // move to next node
        pobs->iCurIndex = 0;
        pobs->iCurNode++;

        // move back to beginning if all done
        if(pobs->iCurNode > 15)
        {
            pobs->iCurNode = 0;
        }
    }

    return bTarget;
}

//
// Obfuscate a string in place and collapse out 0-bytes in unicode string
//
void ObfuscateString(LPWSTR pszString, int iLen)
{
    OBS     obs = {0};
    INT     iCur = 0;
    BYTE    *pbStream;
    INT     iIndex;

    pbStream = (BYTE *)pszString;

    while(iCur < iLen)
    {
        iIndex = obs.iCurIndex;
        pbStream[iCur] = (((BYTE)(pszString[iCur]) + iIndex) ^ GetNextObsByte(&obs));
        iCur++;
    }
}

//
// Unobfuscate a string - undo what obfuscate does
//
void UnobfuscateString(BYTE *pbStream, LPWSTR pszString, int iLen)
{
    OBS     obs = {0};
    INT     iIndex;
    INT     iCur = 0;

    while(iCur < iLen)
    {
        iIndex = obs.iCurIndex;
        pszString[iCur] = (pbStream[iCur] ^ GetNextObsByte(&obs)) - iIndex;
        iCur++;
    }

    // null terminate string
    pszString[iCur] = 0;
}

//
// Set and query advanced mode
//
#define REGSTR_VAL_PRIVADV      TEXT("PrivacyAdvanced")

BOOL IsAdvanced(void)
{
    DWORD   dwValue = 0;
    BOOL    fAdvanced = FALSE;

    InternetReadRegistryDword(REGSTR_VAL_PRIVADV, &dwValue);

    if(dwValue)
    {
        fAdvanced = TRUE;
    }

    return fAdvanced;
}

void SetAdvancedMode(BOOL fAdvanced)
{
    DWORD   dwAdvanced = fAdvanced? 1 : 0;

    // save advanced flag
    InternetWriteRegistryDword(REGSTR_VAL_PRIVADV, dwAdvanced);
}

//
// Public APIs
//

INTERNETAPI_(DWORD)
PrivacySetZonePreferenceW(
    DWORD       dwZone, 
    DWORD       dwType,
    DWORD       dwTemplate,
    LPCWSTR     pszPreference
    )
{
    DEBUG_ENTER_API((DBG_DIALUP,
                Dword,
                "PrivacySetZonePreferenceW",
                "%#x, %#x, %#x, %#x (%q)",
                dwZone,
                dwType,
                dwTemplate,
                pszPreference
                ));

    DWORD dwError = ERROR_INVALID_PARAMETER;

    //
    // validate parameters
    //
    if(dwZone > URLZONE_UNTRUSTED && (dwZone < URLZONE_USER_MIN || dwZone > URLZONE_USER_MAX))
    {
        goto exit;
    }

    if(dwType > PRIVACY_TYPE_THIRD_PARTY)
    {
        goto exit;
    }

    if( dwTemplate > PRIVACY_TEMPLATE_MAX
        && (dwTemplate < PRIVACY_TEMPLATE_CUSTOM || dwTemplate > PRIVACY_TEMPLATE_ADVANCED))
    {
        goto exit;
    }

    if(pszPreference && IsBadStringPtrW(pszPreference, MaxPrivacySettings))  
    // in debug, verifies string is readable up to '\0' or pszPreference[MaxPrivacySettings].
    {
        goto exit;
    }

    if(pszPreference && (dwTemplate != PRIVACY_TEMPLATE_CUSTOM && dwTemplate != PRIVACY_TEMPLATE_ADVANCED))
    {
        goto exit;
    }

    if(NULL == pszPreference && dwTemplate == PRIVACY_TEMPLATE_CUSTOM)
    {
        // custom needs a preference string
        goto exit;
    }

    //
    // Make buffer with new preference
    //
    WCHAR   *pszRegPref;
    LPCWSTR pszCopyStr;
    DWORD   dwPrefLen;

    if(dwTemplate < PRIVACY_TEMPLATE_CUSTOM)
    {
        // figure out appropriate template string
        // Strings are organized as follows:
        //
        // high first
        // high third
        // med-hi first
        // med-hi third
        // ...
        pszCopyStr = SettingTemplate[2 * dwTemplate + dwType];
    }
    else
    {
        // copy passed pref string to new buffer
        pszCopyStr = pszPreference;
    }

    //
    // alloc buffer, copy appropriate string
    //
    dwPrefLen = lstrlenW(pszCopyStr);
    pszRegPref = new WCHAR[dwPrefLen + 1];
    if(pszRegPref == NULL)
    {
        goto exit;
    }
    StrCpyNW(pszRegPref, pszCopyStr, dwPrefLen + 1);

    //
    // Obfuscate string in place, dwPrefLen *BYTES* (NOT unicode chars) left afterwards
    //
    dwPrefLen = lstrlenW(pszRegPref);
    ObfuscateString(pszRegPref, dwPrefLen);

    //
    // Build reg path for appropriate setting
    //
    WCHAR   *pszRegPath = new WCHAR[MAX_PATH];

    if(pszRegPath)
    {
        wnsprintfW(pszRegPath, MAX_PATH, L"%ws\\%d", REGSTR_PATH_ZONE, dwZone);

        //
        // Stuff it in the registry
        //
        dwError = SHSetValueW(
                    HKEY_CURRENT_USER,
                    pszRegPath,
                    (dwType == PRIVACY_TYPE_FIRST_PARTY) ? REGSTR_VAL_FIRST_PARTY : REGSTR_VAL_THIRD_PARTY,
                    REG_BINARY,
                    pszRegPref,
                    dwPrefLen);     // write out dwPrefLen *BYTES*

        delete [] pszRegPath;

        // update advanced and no cookies settings
        BOOL fAdvanced = FALSE;
        DWORD dwPolicy = URLPOLICY_QUERY;

        if(URLZONE_INTERNET == dwZone && PRIVACY_TEMPLATE_ADVANCED == dwTemplate)
        {
            fAdvanced = TRUE;
        }

        if(PRIVACY_TEMPLATE_NO_COOKIES == dwTemplate)
        {
            dwPolicy = URLPOLICY_DISALLOW;
        }

        if(PRIVACY_TEMPLATE_LOW == dwTemplate)
        {
            dwPolicy = URLPOLICY_ALLOW;
        }

        SetAdvancedMode(fAdvanced);
        SetNoCookies(dwZone, dwPolicy);
    }
    else
    {
        dwError = ERROR_OUTOFMEMORY;
    }

    delete [] pszRegPref;

exit:
    DEBUG_LEAVE_API(dwError);
    return dwError;
}


INTERNETAPI_(DWORD)
PrivacyGetZonePreferenceW(
    DWORD       dwZone,
    DWORD       dwType,
    LPDWORD     pdwTemplate,
    LPWSTR      pszBuffer,
    LPDWORD     pdwBufferLength
    )
{
    DEBUG_ENTER_API((DBG_DIALUP,
                Dword,
                "PrivacyGetZonePreferenceW",
                "%#x, %#x, %#x, %#x, %#x",
                dwZone,
                dwType,
                pdwTemplate,
                pszBuffer,
                pdwBufferLength
                ));

    DWORD dwError = ERROR_INVALID_PARAMETER;

    //
    // validate parameters
    //
    if(dwZone > URLZONE_UNTRUSTED && (dwZone < URLZONE_USER_MIN || dwZone > URLZONE_USER_MAX))
    {
        goto exit;
    }

    if(dwType > PRIVACY_TYPE_THIRD_PARTY)
    {
        goto exit;
    }

    if(pdwTemplate && IsBadWritePtr(pdwTemplate, sizeof(DWORD)))
    {
        goto exit;
    }

    // both pszBuffer and pdwBufferLength must be non-null and valid or both much be null
    if(pszBuffer || pdwBufferLength)
    {
        if(IsBadWritePtr(pdwBufferLength, sizeof(DWORD)) || IsBadWritePtr(pszBuffer, *pdwBufferLength))
        {
            goto exit;
        }
    }

    //
    // Allocate buffers for registry read and build path
    //
    WCHAR   *pszRegPath = new WCHAR[MAX_PATH];
    WCHAR   *pszRegPref;
    DWORD   dwRegPrefLen = MaxPrivacySettings;      // BYTES
    BYTE    *pbRegReadLoc;
    
    if(NULL == pszRegPath)
    {
        dwError = ERROR_OUTOFMEMORY;
        goto exit;
    }

    pszRegPref = new WCHAR[MaxPrivacySettings];
    if(NULL == pszRegPref)
    {
        delete [] pszRegPath;
        dwError = ERROR_OUTOFMEMORY;
        goto exit;
    }

    wnsprintfW(pszRegPath, MAX_PATH, L"%ws\\%d", REGSTR_PATH_ZONE, dwZone);

    //
    // Read registry value.
    //
    // Since the written value (assuming it's valid) is at most MaxPrivacySettings BYTES, read
    // it in to the second half of the buffer so it can be expanded to unicode chars in place.
    //
    // Note buffer is allocated to hold MaxPrivacySettings WCHARs
    //
    pbRegReadLoc = (BYTE *)(pszRegPref + (MaxPrivacySettings / sizeof(WCHAR)));

    dwError = SHGetValueW(
        HKEY_CURRENT_USER,
        pszRegPath,
        (dwType == PRIVACY_TYPE_FIRST_PARTY) ? REGSTR_VAL_FIRST_PARTY : REGSTR_VAL_THIRD_PARTY,
        NULL,
        pbRegReadLoc,
        &dwRegPrefLen);

    if( ERROR_SUCCESS != dwError
        || IsSignaturePresent(pbRegReadLoc, dwRegPrefLen)
        )
    {
        // no reg setting => not fatal
        // buffer too small => invalid settings string
        // any other reg error => opps
        // found plaintext signature => someone bogarting registry
        // in any case, return empty string
        dwRegPrefLen = 0;
        dwError = ERROR_SUCCESS;
    }

    delete [] pszRegPath;

    //
    // Unobfuscate it
    //
    UnobfuscateString(pbRegReadLoc, pszRegPref, dwRegPrefLen);
    if(SIGNATURE_NONE == IsSignaturePresent((BYTE *)pszRegPref, dwRegPrefLen * sizeof(WCHAR)))
    {
        // internal error.. never expect this to happen
        *pszRegPref = 0;
        dwRegPrefLen = 0;
        dwError = ERROR_SUCCESS;
    }

    //
    // Try to copy to callers buffer if necessary
    //
    if(pszBuffer)
    {
        if(dwRegPrefLen < *pdwBufferLength)
        {
            StrCpyNW(pszBuffer, pszRegPref, *pdwBufferLength);
        }
        else
        {
            dwError = ERROR_MORE_DATA;
        }

        *pdwBufferLength = dwRegPrefLen + 1;
    }

    //
    // Try to match it to a template if necessary
    //
    if(pdwTemplate)
    {
        *pdwTemplate = PRIVACY_TEMPLATE_CUSTOM;

        if(URLZONE_INTERNET == dwZone && IsAdvanced())
        {
            *pdwTemplate = PRIVACY_TEMPLATE_ADVANCED;
        }
        else if(IsNoCookies(dwZone))
        {
            *pdwTemplate = PRIVACY_TEMPLATE_NO_COOKIES;
        }
        else if(*pszRegPref)
        {
            DWORD   dwTemplate;
            DWORD   dwTemplateId;
            
            for(dwTemplate = 0; dwTemplate <= PRIVACY_TEMPLATE_MAX; dwTemplate++)
            {
                dwTemplateId = 2 * dwTemplate + dwType;

                if(0 == StrCmpIW(SettingTemplate[dwTemplateId], pszRegPref))
                {
                    *pdwTemplate = dwTemplate;
                    break;
                }
            }
        }
    }

    delete [] pszRegPref;

exit:
    DEBUG_LEAVE_API(dwError);
    return dwError;
}


/* 
templates for default cookie settings 
Consistency condition: decision for TST token == decision for no-policy
In other words, presence of "TST" token invalidates the entire policy 
*/

/*
** WARNING:  Settings code assumes all the first party templates are distinct and all the third party
**           templates are distinct.  If you're changing a template, ensure this is true.  You can simply
**           swap clauses if necessary.
**
** Contact darrenmi for more info.
*/

/*
BEGIN low -- see warning above before changing
*/

const wchar_t achLow1stParty[] =

L"IE6-P3PV1/settings: always=a";

const wchar_t achLow3rdParty[] =

L"IE6-P3PV1/settings: always=a";

/*
END low
*/


/* BEGIN medium-low -- see warning above before changing */

const wchar_t achMedLow1stParty[] =

L"IE6-P3PV1/settings: nopolicy=l session=a /TST=l/ /=a/"
;


const wchar_t achMedLow3rdParty[] =

L"IE6-P3PV1/settings: nopolicy=d /TST=d/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=d/ /PHY&OTR=d/ /PHY&UNR=d/ /PHY&PUB=d/ /PHY&CUS=d/ /PHY&IVA=d/ /PHY&IVD=d/"
L" /PHY&CON=d/ /PHY&TEL=d/ /PHY&OTP=d/ /ONL&SAM=d/ /ONL&OTR=d/ /ONL&UNR=d/ /ONL&PUB=d/"
L" /ONL&CUS=d/ /ONL&IVA=d/ /ONL&IVD=d/ /ONL&CON=d/ /ONL&TEL=d/ /ONL&OTP=d/ /GOV&SAM=d/"
L" /GOV&OTR=d/ /GOV&UNR=d/ /GOV&PUB=d/ /GOV&CUS=d/ /GOV&IVA=d/ /GOV&IVD=d/ /GOV&CON=d/ /GOV&TEL=d/"
L" /GOV&OTP=d/ /FIN&SAM=d/ /FIN&OTR=d/ /FIN&UNR=d/ /FIN&PUB=d/ /FIN&CUS=d/ /FIN&IVA=d/"
L" /FIN&IVD=d/ /FIN&CON=d/ /FIN&TEL=d/ /FIN&OTP=d/ /=a/"
;

/* END medium-low */

/* BEGIN medium -- see warning above before changing */

const wchar_t achMedium1stParty[] =

L"IE6-P3PV1/settings: nopolicy=l session=a /TST=l/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=d/ /PHY&OTR=d/ /PHY&UNR=d/ /PHY&PUB=d/ /PHY&CUS=d/ /PHY&IVA=d/ /PHY&IVD=d/"
L" /PHY&CON=d/ /PHY&TEL=d/ /PHY&OTP=d/ /ONL&SAM=d/ /ONL&OTR=d/ /ONL&UNR=d/ /ONL&PUB=d/"
L" /ONL&CUS=d/ /ONL&IVA=d/ /ONL&IVD=d/ /ONL&CON=d/ /ONL&TEL=d/ /ONL&OTP=d/ /GOV&SAM=d/"
L" /GOV&OTR=d/ /GOV&UNR=d/ /GOV&PUB=d/ /GOV&CUS=d/ /GOV&IVA=d/ /GOV&IVD=d/ /GOV&CON=d/ /GOV&TEL=d/"
L" /GOV&OTP=d/ /FIN&SAM=d/ /FIN&OTR=d/ /FIN&UNR=d/ /FIN&PUB=d/ /FIN&CUS=d/ /FIN&IVA=d/"
L" /FIN&IVD=d/ /FIN&CON=d/ /FIN&TEL=d/ /FIN&OTP=d/ /=a/"
;

const wchar_t achMedium3rdParty[] =

L"IE6-P3PV1/settings: nopolicy=r /TST=r/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/"
L" /PHY&CON=r/ /PHY&TEL=r/ /PHY&OTP=r/ /ONL&SAM=r/ /ONL&OTR=r/ /ONL&UNR=r/ /ONL&PUB=r/"
L" /ONL&CUS=r/ /ONL&IVA=r/ /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/ /GOV&SAM=r/"
L" /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/ /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/"
L" /GOV&OTP=r/ /FIN&SAM=r/ /FIN&OTR=r/ /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/"
L" /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /=a/"
;

/* END medium */


/* BEGIN medium-high -- see warning above before changing */

const wchar_t achMedHigh1stParty[] = 

L"IE6-P3PV1/settings: nopolicy=l session=a /TST=l/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/ /PHY&CON=r/"
L" /PHY&TEL=r/ /PHY&OTP=r/ /ONL&SAM=r/ /ONL&OTR=r/ /ONL&UNR=r/ /ONL&PUB=r/ /ONL&CUS=r/ /ONL&IVA=r/"
L" /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/ /GOV&SAM=r/ /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/"
L" /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/ /GOV&OTP=r/ /FIN&SAM=r/ /FIN&OTR=r/"
L" /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/ /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /=a/"
;

const wchar_t achMedHigh3rdParty[] = 

/* CAUTION: this setting is identical to 3rd party HIGH.
   We need a cosmetic change to the string to distinguish template levels. */
L"IE6-P3PV1/settings: /TST=r/ nopolicy=r"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/ /PHY&CON=r/"
L" /PHY&TEL=r/ /PHY&OTP=r/ /PHY&SAMo=r/ /PHY&OTRo=r/ /PHY&UNRo=r/ /PHY&PUBo=r/ /PHY&CUSo=r/"
L" /PHY&IVAo=r/ /PHY&IVDo=r/ /PHY&CONo=r/ /PHY&TELo=r/ /PHY&OTPo=r/ /ONL&SAM=r/ /ONL&OTR=r/"
L" /ONL&UNR=r/ /ONL&PUB=r/ /ONL&CUS=r/ /ONL&IVA=r/ /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/"
L" /ONL&SAMo=r/ /ONL&OTRo=r/ /ONL&UNRo=r/ /ONL&PUBo=r/ /ONL&CUSo=r/ /ONL&IVAo=r/ /ONL&IVDo=r/"
L" /ONL&CONo=r/ /ONL&TELo=r/ /ONL&OTPo=r/ /GOV&SAM=r/ /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/"
L" /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/ /GOV&OTP=r/ /GOV&SAMo=r/"
L" /GOV&OTRo=r/ /GOV&UNRo=r/ /GOV&PUBo=r/ /GOV&CUSo=r/ /GOV&IVAo=r/ /GOV&IVDo=r/ /GOV&CONo=r/ /GOV&TELo=r/"
L" /GOV&OTPo=r/ /FIN&SAM=r/ /FIN&OTR=r/ /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/"
L" /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /FIN&SAMo=r/ /FIN&OTRo=r/ /FIN&UNRo=r/"
L" /FIN&PUBo=r/ /FIN&CUSo=r/ /FIN&IVAo=r/ /FIN&IVDo=r/ /FIN&CONo=r/ /FIN&TELo=r/ /FIN&OTPo=r/ /=a/"
;

/* END medium-high */


/* BEGIN high -- see warning above before changing */

const wchar_t achHigh1stParty[] =

L"IE6-P3PV1/settings: nopolicy=r /TST=r/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/"
L" /PHY&CON=r/ /PHY&TEL=r/ /PHY&OTP=r/ /PHY&SAMo=r/ /PHY&OTRo=r/ /PHY&UNRo=r/ /PHY&PUBo=r/"
L" /PHY&CUSo=r/ /PHY&IVAo=r/ /PHY&IVDo=r/ /PHY&CONo=r/ /PHY&TELo=r/ /PHY&OTPo=r/ /ONL&SAM=r/ "
L" /ONL&OTR=r/ /ONL&UNR=r/ /ONL&PUB=r/ /ONL&CUS=r/ /ONL&IVA=r/ /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/"
L" /ONL&SAMo=r/ /ONL&OTRo=r/ /ONL&UNRo=r/ /ONL&PUBo=r/ /ONL&CUSo=r/ /ONL&IVAo=r/ /ONL&IVDo=r/"
L" /ONL&CONo=r/ /ONL&TELo=r/ /ONL&OTPo=r/ /GOV&SAM=r/ /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/"
L" /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/ /GOV&OTP=r/ /GOV&SAMo=r/ "
L" /GOV&OTRo=r/ /GOV&UNRo=r/ /GOV&PUBo=r/ /GOV&CUSo=r/ /GOV&IVAo=r/ /GOV&IVDo=r/ /GOV&CONo=r/ /GOV&TELo=r/"
L" /GOV&OTPo=r/ /FIN&SAM=r/ /FIN&OTR=r/ /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/"
L" /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /FIN&SAMo=r/ /FIN&OTRo=r/ /FIN&UNRo=r/"
L" /FIN&PUBo=r/ /FIN&CUSo=r/ /FIN&IVAo=r/ /FIN&IVDo=r/ /FIN&CONo=r/ /FIN&TELo=r/ /FIN&OTPo=r/ /=a/"
;

const wchar_t achHigh3rdParty[] =

L"IE6-P3PV1/settings: nopolicy=r /TST=r/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/ /PHY&CON=r/"
L" /PHY&TEL=r/ /PHY&OTP=r/ /PHY&SAMo=r/ /PHY&OTRo=r/ /PHY&UNRo=r/ /PHY&PUBo=r/ /PHY&CUSo=r/"
L" /PHY&IVAo=r/ /PHY&IVDo=r/ /PHY&CONo=r/ /PHY&TELo=r/ /PHY&OTPo=r/ /ONL&SAM=r/ /ONL&OTR=r/"
L" /ONL&UNR=r/ /ONL&PUB=r/ /ONL&CUS=r/ /ONL&IVA=r/ /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/"
L" /ONL&SAMo=r/ /ONL&OTRo=r/ /ONL&UNRo=r/ /ONL&PUBo=r/ /ONL&CUSo=r/ /ONL&IVAo=r/ /ONL&IVDo=r/"
L" /ONL&CONo=r/ /ONL&TELo=r/ /ONL&OTPo=r/ /GOV&SAM=r/ /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/"
L" /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/ /GOV&OTP=r/ /GOV&SAMo=r/ "
L" /GOV&OTRo=r/ /GOV&UNRo=r/ /GOV&PUBo=r/ /GOV&CUSo=r/ /GOV&IVAo=r/ /GOV&IVDo=r/ /GOV&CONo=r/ /GOV&TELo=r/"
L" /GOV&OTPo=r/ /FIN&SAM=r/ /FIN&OTR=r/ /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/"
L" /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /FIN&SAMo=r/ /FIN&OTRo=r/ /FIN&UNRo=r/"
L" /FIN&PUBo=r/ /FIN&CUSo=r/ /FIN&IVAo=r/ /FIN&IVDo=r/ /FIN&CONo=r/ /FIN&TELo=r/ /FIN&OTPo=r/ /=a/"
;

/* END high */

/* BEGIN NO COOKIES -- see warning above before changing */

const wchar_t achNoCookies1stParty[] =

L"IE6-P3PV1/settings: always=r";

const wchar_t achNoCookies3rdParty[] =

L"IE6-P3PV1/settings: always=r";

/* END NO COOKIES */


const wchar_t *SettingTemplate[] = {

    achNoCookies1stParty,
    achNoCookies3rdParty,
    achHigh1stParty,
    achHigh3rdParty,
    achMedHigh1stParty,
    achMedHigh3rdParty,
    achMedium1stParty,
    achMedium3rdParty,
    achMedLow1stParty,
    achMedLow3rdParty,
    achLow1stParty,
    achLow3rdParty,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\chunk.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    chunk.cxx

Abstract:

    Contains a generic chunked transfer implimentation

Author:

    Arthur L Bierer (arthurbi) 03-May-1997

Revision History:

    03-May-1997 arthurbi
        Created

--*/


#include <wininetp.h>


inline
CHUNK_TOKEN
CHUNK_TRANSFER::GetToken(
    IN OUT LPSTR *lplpInputBuffer,
    IN LPSTR     lpEndOfInputBuffer,
    OUT LPDWORD  lpdwValue,
    IN DWORD     dwExpectedTokenSize,
    OUT LPDWORD  lpdwBytesTokenized
    )

/*++

Routine Description:

    Lexes through a byte stream, seperating data into tokens.  Data is special cased for efficency.


Arguments:

    lplpInputBuffer - Pointer to Pointer of Buffer that should be lexed, on return contains
        an offset where the next character to lex is.

    lpEndofInputBuffer - Pointer to last character to passed in Buffer.

    lpdwValue   - On return, MAY contain numerical conversion of a text number (digit) token

    dwExpectedTokenSize - Expected size of token, in all cases except for data should be 1

    lpdwBytesTokenized - On return, contains size of token


Return Value:

    CHUNK_TOKEN
    Success - The Correct token.

    Failure - CHUNK_TOKEN_INVALID

--*/

{
    BOOL fFirstIteration = TRUE;
    CHUNK_TOKEN ctToken = CHUNK_TOKEN_INVALID;

    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "CHUNK_TRANSFER::GetToken",
                "%x [%x, %.10q], %x, %x, %u, %x",
                lplpInputBuffer,
                *lplpInputBuffer,
                *lplpInputBuffer,
                lpEndOfInputBuffer,
                lpdwValue,
                dwExpectedTokenSize,
                lpdwBytesTokenized
                ));

    *lpdwBytesTokenized = 0;

    while ( *lplpInputBuffer    < lpEndOfInputBuffer
            && *lpdwBytesTokenized < dwExpectedTokenSize )
    {
        //
        // Set Default Token type
        //

        ctToken = CHUNK_TOKEN_DATA;

        //
        // Handle Other, "special" tokens, only if asked for by the parser.
        //

        if ( dwExpectedTokenSize == 1 )
        {

            if ( **lplpInputBuffer == '\r' )
            {
                ctToken = CHUNK_TOKEN_CR;
                goto quit;
            }

            if ( **lplpInputBuffer == '\n' )
            {
                ctToken = CHUNK_TOKEN_LF;
                goto quit;
            }

            if ( **lplpInputBuffer == ':' )
            {
                ctToken = CHUNK_TOKEN_COLON;
                goto quit;
            }

            if ( **lplpInputBuffer >= '0' && **lplpInputBuffer <= '9' )
            {
                *lpdwValue = (DWORD) (**lplpInputBuffer - '0');
                ctToken = CHUNK_TOKEN_DIGIT;
                goto quit;
            }


            if ( **lplpInputBuffer >= 'A' && **lplpInputBuffer <= 'F' )
            {
                *lpdwValue = (DWORD) (**lplpInputBuffer - 'A') + 10;
                ctToken = CHUNK_TOKEN_DIGIT;
                goto quit;
            }

            if ( **lplpInputBuffer >= 'a' && **lplpInputBuffer <= 'f' )
            {
                *lpdwValue = (DWORD) (**lplpInputBuffer - 'a') + 10;
                ctToken = CHUNK_TOKEN_DIGIT;
                goto quit;
            }
        }

        fFirstIteration = FALSE;
        (*lplpInputBuffer)++;
        (*lpdwBytesTokenized)++;
    }


quit:

    if (ctToken != CHUNK_TOKEN_DATA && ctToken != CHUNK_TOKEN_INVALID)
    {
        if ( !fFirstIteration)
        {
            ctToken = CHUNK_TOKEN_DATA;
        }
        else
        {
            //
            // Advance past this token, since we've only
            //  lexed one token
            //

            (*lplpInputBuffer)++;
            (*lpdwBytesTokenized)++;
        }
    }

    DEBUG_PRINT(HTTP,
                INFO,
                ("GetToken: %q, expected=%u, actual=%u\n",
                InternetMapChunkToken(ctToken),
                dwExpectedTokenSize,
                *lpdwBytesTokenized
                ));

    DEBUG_LEAVE((DWORD)ctToken);

    return ctToken;
}



DWORD
CHUNK_TRANSFER::ParseChunkInput(
    LPSTR lpInputBuffer,
    DWORD dwInputBufferSize,
    LPSTR *lplpInputBufferNew,
    LPDWORD lpdwInputBufferNewSize
    )

/*++

Routine Description:

    Parses a buffer of an assumed chunked encoding byte stream.  Seperates out data from header information.


Arguments:

    lpInputBuffer - Pointer to buffer containing a stream of bytes to parse

    dwInputBufferSize - size of byte lpInputBuffer

    lplpInputBufferNew - Offset into passed in lpInputBuffer, (not used, yet)

    lpdwInputBufferNewSize - On Return, cotains the size of lpInputBuffer ( data is compressed )

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure -

--*/


{
    CHUNK_TOKEN ctToken;
    DWORD dwValue;
    DWORD dwExpectedTokenSize = 1;
    DWORD dwActualTokenSize   = 0;
    LPSTR lpszEndOfInputBuffer = (LPSTR) (lpInputBuffer + dwInputBufferSize);
    LPSTR lpszStartOfFirstDataBuffer = NULL;
    DWORD dwFirstDataBufferSize = 0;
    LPSTR lpszStartOfNextDataBuffer = NULL;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "CHUNK_TRANSFER::ParseChunkInput",
                "%x [%.10q], %u, %x, %x",
                lpInputBuffer,
                lpInputBuffer,
                dwInputBufferSize,
                lplpInputBufferNew,
                lpdwInputBufferNewSize
                ));

    *lplpInputBufferNew = lpInputBuffer;

    while ( *lplpInputBufferNew < lpszEndOfInputBuffer)
    {

        //
        // Calculate the max size of the token can be, only
        //  relevant for data, since all other tokens are assumed
        //  to be size of 1.
        //

        if (_csState == CHUNK_STATE_DATA_PARSE)
        {
            dwExpectedTokenSize = (_dwChunkDataSize - _dwChunkDataRead);
            lpszStartOfNextDataBuffer = *lplpInputBufferNew;
        }
        else
        {
            dwExpectedTokenSize = 1;
        }

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("ParseChunk: %q, %u/%u\n",
                    InternetMapChunkState(_csState),
                    _dwChunkDataRead,
                    _dwChunkDataSize
                    ));


        //
        //  Lex through the byte stream looking for our next token.
        //

        ctToken = GetToken( lplpInputBufferNew,
                            lpszEndOfInputBuffer,
                            &dwValue,
                            dwExpectedTokenSize,
                            &dwActualTokenSize
                            );

        if ( ctToken == CHUNK_TOKEN_INVALID )
        {
            //
            // Need more data to parse...
            //

            error = ERROR_SUCCESS;
            goto quit;
        }

        //
        // Based on our current state, evalulate the token,
        //  and figure out what to do next.
        //

        switch ( _csState )
        {
            case CHUNK_STATE_START:

                ResetSubStateInfo();

                if ( ctToken != CHUNK_TOKEN_DIGIT )
                {
                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("-->CHUNK err: Got %q, while looking for NOT %q\n",
                                InternetMapChunkToken(ctToken),
                                InternetMapChunkToken(CHUNK_TOKEN_DIGIT)
                                ));

                    error = ERROR_INTERNET_INTERNAL_ERROR;
                    goto quit;
                }

                SetState(CHUNK_STATE_SIZE_PARSE);
                // otherwise fall through

            case CHUNK_STATE_SIZE_PARSE:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_DIGIT:
                        _dwCalculatedChunkSize *= BASE_HEX;
                        _dwCalculatedChunkSize += dwValue;
                        break;

                    case CHUNK_TOKEN_CR:
                        _dwCr++;
                        // fall through

                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_COLON:


                        _dwChunkDataSize = _dwCalculatedChunkSize;
                        _dwChunkDataRead = 0;


                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("ChunkParse-GotChunksize: size=%u, %x\n",
                                    _dwCalculatedChunkSize,
                                    _dwCalculatedChunkSize
                                    ));

                        if (ctToken == CHUNK_TOKEN_CR)
                        {
                            SetState(CHUNK_STATE_SIZE_CRLF);
                        }
                        else
                        {
                            SetState(CHUNK_STATE_EXT_PARSE);
                        }

                        break;

                    default:
                        // ERROR
                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_EXT_PARSE:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_CR:
                        _dwCr++;
                        SetState(CHUNK_STATE_SIZE_CRLF);
                        break;

                    case CHUNK_TOKEN_DIGIT:
                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_COLON:

                        break;

                    default:
                        // ERROR
                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_SIZE_CRLF:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_LF:

                        _dwLf++;

                        if ( IsCrLf() )
                        {
                            ClearCrLf();
                            if ( _dwCalculatedChunkSize == 0 )
                            {
                                SetState(CHUNK_STATE_ZERO_FOOTER);
                            }
                            else
                            {
                                SetState(CHUNK_STATE_DATA_PARSE);
                            }
                        }
                        else
                        {
                            DEBUG_PRINT(HTTP,
                                        INFO,
                                        ("-->CHUNK err: Got %q, But CRLF not matched, CR=%u, LF=%u\n",
                                        InternetMapChunkToken(ctToken),
                                        _dwCr,
                                        _dwLf
                                        ));

                            error = ERROR_INTERNET_INTERNAL_ERROR;
                            goto quit;
                        }

                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for %q\n",
                                    InternetMapChunkToken(ctToken),
                                    InternetMapChunkToken(CHUNK_TOKEN_LF)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_DATA_PARSE:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_CR:
                    case CHUNK_TOKEN_LF:
                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_DIGIT:
                    case CHUNK_TOKEN_COLON:

                        //
                        // If this is the first piece of data we receive
                        //  than save it off, so we know the start of the
                        //  buffer we are returning as data.
                        //

                        if ( lpszStartOfFirstDataBuffer == NULL )
                        {
                            lpszStartOfFirstDataBuffer = lpInputBuffer;
                        }

                        //
                        // If this is not the first block of data in the passed in buffer,
                        //  we must move the block of data OVER any Chunked-tranfer header
                        //  information.
                        //

                        if ( (lpszStartOfFirstDataBuffer+dwFirstDataBufferSize) != lpszStartOfNextDataBuffer )
                        {
                            MoveMemory((LPVOID) (lpszStartOfFirstDataBuffer+dwFirstDataBufferSize), // Dest
                                       (LPVOID) lpszStartOfNextDataBuffer,                          // Source
                                       dwActualTokenSize                                            // size
                                       );
                        }

                        //
                        // Update the size of data we've parsed out, and
                        //  check to see if we've completely received all data.
                        //

                        dwFirstDataBufferSize += dwActualTokenSize;
                        _dwChunkDataRead += dwActualTokenSize;

                        if ( _dwChunkDataRead == _dwChunkDataSize )
                        {
                            SetState(CHUNK_STATE_DATA_CRLF);
                        }

                        INET_ASSERT(_dwChunkDataRead <= _dwChunkDataSize);

                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for CR,LF,DATA,DIGIT,COLON\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;

                }

                break;

            case CHUNK_STATE_DATA_CRLF:

                switch (ctToken)
                {
                    case CHUNK_TOKEN_CR:
                        _dwCr++;
                        break;

                    case CHUNK_TOKEN_LF:
                        _dwLf++;

                        if ( IsCrLf() )
                        {
                            ClearCrLf();
                            SetState(CHUNK_STATE_START);
                        }
                        else
                        {
                            DEBUG_PRINT(HTTP,
                                        INFO,
                                        ("-->CHUNK err: Got %q, BUT CRLF not matched, CR=%u, LF=%u\n",
                                        InternetMapChunkToken(ctToken),
                                        _dwCr,
                                        _dwLf
                                        ));

                            error = ERROR_INTERNET_INTERNAL_ERROR;
                            goto quit;
                        }

                        break;

                    default:
                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for CR or LF (CHUNK DATA SIZE INCORRECT??)\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_ZERO_FOOTER:

                switch (ctToken)
                {
                    case CHUNK_TOKEN_CR:

                        _dwCr++;
                        SetState(CHUNK_STATE_ZERO_FOOTER_FINAL_CRLF);
                        break;

                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_DIGIT:
                    case CHUNK_TOKEN_COLON:

                        SetState(CHUNK_STATE_ZERO_FOOTER_NAME);
                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for DATA or CR\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_ZERO_FOOTER_NAME:

                switch (ctToken)
                {
                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_DIGIT:
                        break;

                    case CHUNK_TOKEN_COLON:
                        SetState(CHUNK_STATE_ZERO_FOOTER_VALUE);
                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for DATA, DIGIT, COLON\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_ZERO_FOOTER_VALUE:
                switch (ctToken)
                {
                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_DIGIT:
                        break;

                    case CHUNK_TOKEN_CR:
                        _dwCr++;
                        SetState(CHUNK_STATE_ZERO_FOOTER_CRLF);
                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for DATA, DIGIT, CR\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_ZERO_FOOTER_CRLF:
            case CHUNK_STATE_ZERO_FOOTER_FINAL_CRLF:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_LF:

                        _dwLf++;

                        if ( IsCrLf() )
                        {
                            ClearCrLf();

                            if ( _csState == CHUNK_STATE_ZERO_FOOTER_CRLF)
                            {
                                SetState(CHUNK_STATE_ZERO_FOOTER);
                            }
                            else
                            {
                                INET_ASSERT( _csState == CHUNK_STATE_ZERO_FOOTER_FINAL_CRLF);
                                //Done?
                                SetState(CHUNK_STATE_FINISHED);

                                DEBUG_PRINT(HTTP,
                                            INFO,
                                            ("EOF chunk\n"
                                            ));

                                error = ERROR_SUCCESS;
                                goto quit;
                            }
                        }
                        else
                        {
                            DEBUG_PRINT(HTTP,
                                        INFO,
                                        ("-->CHUNK err: Got %q, But CRLF not matched, CR=%u, LF=%u\n",
                                        InternetMapChunkToken(ctToken),
                                        _dwCr,
                                        _dwLf
                                        ));

                            error = ERROR_INTERNET_INTERNAL_ERROR;
                            goto quit;
                        }

                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for LF\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_FINISHED:
                INET_ASSERT(FALSE);
                error = ERROR_SUCCESS;
                goto quit;

            default:
                INET_ASSERT(FALSE);
                error = ERROR_INTERNET_INTERNAL_ERROR;
                goto quit;

        }
    }

quit:

    if ( error == ERROR_SUCCESS)
    {
        if ( dwFirstDataBufferSize > 0 )
        {
            INET_ASSERT(lpInputBuffer == lpszStartOfFirstDataBuffer);
        }

        *lplpInputBufferNew     = lpInputBuffer;
        *lpdwInputBufferNewSize = dwFirstDataBufferSize;
    }


    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\cookieprompt.cxx ===
#include <wininetp.h>

#include "cookieprompt.h"


//  checks a string to see if its a domain
BOOL IsStringADomain( LPCSTR pszString)
{
    int iLength = 0;
    bool fLastCharWasDot = false;

    while( pszString[iLength] != '\0')
    {
        if( fLastCharWasDot && pszString[iLength] == '.')
            return FALSE;
        
        fLastCharWasDot = pszString[iLength] == '.';

        if( !(IsCharAlphaNumericA( pszString[iLength])
              || pszString[iLength] == '.'
              || pszString[iLength] == '-'))
        {
            return FALSE;
        }

        iLength++;
    }

    return iLength > 0 ? TRUE : FALSE;
}


LPCSTR FindMinimizedCookieDomainInDomain( LPCSTR pszDomain)
{
    LPCSTR pMinimizedDomain = pszDomain + strlen( pszDomain);

    do
    {
        pMinimizedDomain--;
        while( pszDomain < pMinimizedDomain
               && *(pMinimizedDomain-1) != L'.')
        {
            pMinimizedDomain--;
        }
    } while( !IsDomainLegalCookieDomainA( pMinimizedDomain, pszDomain)
             && pszDomain < pMinimizedDomain);

    return pMinimizedDomain;
}


CCookiePromptHistory::CCookiePromptHistory(const char *pchRegistryPath, bool fUseHKLM) {

    _fUseHKLM = fUseHKLM;    
    lstrcpyn(_szRootKeyName, pchRegistryPath, sizeof(_szRootKeyName)/sizeof(_szRootKeyName[0]));
    _hkHistoryRoot = NULL;
}

CCookiePromptHistory::~CCookiePromptHistory() {

    if (_hkHistoryRoot)
    {
        RegCloseKey(_hkHistoryRoot);
        _hkHistoryRoot = NULL;
    }
}

HKEY    CCookiePromptHistory::OpenRootKey()
{
    HKEY hkey;

    if (_hkHistoryRoot == NULL)
    {
        if (RegCreateKeyEx(_fUseHKLM ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                           _szRootKeyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                           NULL,
                           &hkey,
                           NULL) == ERROR_SUCCESS)
        {
            // if we aren't running in a service, we can cache the key
            if (!GlobalIsProcessNtService)
            {
                if (InterlockedCompareExchangePointer((void**)&_hkHistoryRoot, (void*)hkey, NULL))
                {
                    // someone beat us in the race to fill in _hkHistoryRoot, close ours since we
                    // failed to set it into _hkHistoryRoot
                    RegCloseKey(hkey);
                    hkey = _hkHistoryRoot;
                }
            }
        }
        else
        {
            hkey = NULL;
        }
    }
    else
    {
        // use the cached value
        hkey = _hkHistoryRoot;
    }

    return hkey;
}

BOOL    CCookiePromptHistory::CloseRootKey(HKEY hkeyRoot)
{
    BOOL bClosedKey = FALSE;

    if (hkeyRoot)
    {
        if (GlobalIsProcessNtService)
        {
            // we never cache the key when runnint in a service!
            INET_ASSERT(_hkHistoryRoot == NULL);

            RegCloseKey(hkeyRoot);
            bClosedKey = TRUE;
        }
        else
        {
            INET_ASSERT(_hkHistoryRoot == hkeyRoot);
        }
    }

    return bClosedKey;
}

/* 
 Lookup user-decision for given host+policy combination.
 If "pchPolicyID" is NULL the decision applies regardless of policy.
 */
BOOL    CCookiePromptHistory::lookupDecision(const char *pchHostName, 
                                             const char *pchPolicyID,
                                             unsigned long *pdwDecision) {

    BOOL fRet = FALSE;
    HKEY hSiteKey;
    CHAR szBuffer[ INTERNET_MAX_URL_LENGTH];
    DWORD dwBufferSize = INTERNET_MAX_URL_LENGTH;


    if (SUCCEEDED( UrlUnescape( (LPSTR)pchHostName, szBuffer, &dwBufferSize, 0))  // forced LPSTR conv necessary because COULD be inplace unescape
        && IsStringADomain( szBuffer))
    {
        HKEY hkHistoryRoot = OpenRootKey();

        if (hSiteKey = lookupSiteKey(hkHistoryRoot, FindMinimizedCookieDomainInDomain(szBuffer)))
        {

            DWORD dwType, dwCookieState;
            DWORD dwSize = sizeof(dwCookieState);

            if (ERROR_SUCCESS == RegQueryValueEx(hSiteKey, pchPolicyID, 0, &dwType, (LPBYTE) &dwCookieState, &dwSize)
                && (dwType==REG_DWORD)) {

                *pdwDecision =  dwCookieState;
                fRet = TRUE;
            }

            RegCloseKey(hSiteKey);
        }

        CloseRootKey(hkHistoryRoot);
    }

//commented code - legacy design where we allowed rules on a non-minimized domain
//    while (pchHostName && !fRet)
//    {
//        if (hSiteKey=lookupSiteKey(pchHostName)) {
//
//            DWORD dwType, dwCookieState;
//            DWORD dwSize = sizeof(dwCookieState);
//
//            if (ERROR_SUCCESS == RegQueryValueEx(hSiteKey, pchPolicyID, 0, &dwType, (LPBYTE) &dwCookieState, &dwSize)
//                && (dwType==REG_DWORD)) {
//
//                *pdwDecision =  dwCookieState;
//                fRet = TRUE;
//            }
//
//            RegCloseKey(hSiteKey);
//        }
//
//        /* Find and skip over next dot if there is one */
//        if (pchHostName = strchr(pchHostName, '.'))
//            pchHostName++;
//    }

    return fRet;
}

/* 
 Save user-decision for given host+policy combination.
 If "pchPolicyID" is NULL the decision applies to all policies
 */
BOOL    CCookiePromptHistory::saveDecision(const char *pchHostName,
                                           const char *pszPolicyID,
                                           unsigned long dwDecision) {

    BOOL fRet = FALSE;
    HKEY hSiteKey;
    CHAR szBuffer[ INTERNET_MAX_URL_LENGTH];
    DWORD dwBufferSize = INTERNET_MAX_URL_LENGTH;


    if (SUCCEEDED( UrlUnescape( (LPSTR)pchHostName, szBuffer, &dwBufferSize, 0))  // forced LPSTR conv necessary because COULD be inplace unescape
        && IsStringADomain( szBuffer))
    {
        HKEY hkHistoryRoot = OpenRootKey();

        if (hSiteKey = lookupSiteKey(hkHistoryRoot, FindMinimizedCookieDomainInDomain( szBuffer), true))
        {
            if (ERROR_SUCCESS == RegSetValueEx(hSiteKey, pszPolicyID, 0, REG_DWORD, 
                                               (LPBYTE) &dwDecision, sizeof(dwDecision)))
                fRet = TRUE;

            RegCloseKey(hSiteKey);
        }

        CloseRootKey(hkHistoryRoot);
    }

    return fRet;
}

/*
Clear previously saved decision for given hostname+policy combination.
If the policy-ID is "*" all decisions about the site are cleared.
*/
BOOL   CCookiePromptHistory::clearDecision(const char *pchHostName, const char *pchPolicyID) {

    BOOL fRet = FALSE;
    int error = ERROR_SUCCESS;
    HKEY hkHistoryRoot = OpenRootKey();

    if ( pchPolicyID != NULL && !strcmp(pchPolicyID, "*")) {
        
        error = SHDeleteKey(hkHistoryRoot, pchHostName);
    }
    else if (HKEY hSiteKey = lookupSiteKey(hkHistoryRoot, pchHostName, false)) {

        error = RegDeleteValue(hSiteKey, pchPolicyID);
        RegCloseKey(hSiteKey);
    }

    CloseRootKey(hkHistoryRoot);

    /* If neither of the previous conditionals were TRUE, then there is
       no decision corresponding to that hostname */
    return (error==ERROR_SUCCESS);
}

HKEY    CCookiePromptHistory::lookupSiteKey(HKEY hkHistoryRoot, const char *pchHostName, bool fCreate) {

    HKEY hSiteKey = NULL;

    if (hkHistoryRoot)
    {
        LONG error;

        if (fCreate)
        {
            RegCreateKeyEx(hkHistoryRoot,
                           pchHostName,
                           0,
                           NULL,
                           0,
                           KEY_QUERY_VALUE | KEY_SET_VALUE,
                           NULL,
                           &hSiteKey,
                           NULL);
        }
        else
        {
            RegOpenKeyEx(hkHistoryRoot,
                         pchHostName,
                         0,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &hSiteKey);
        }
    }

    return hSiteKey;
}

BOOL   CCookiePromptHistory::clearAll() {

    DWORD dwIndex = 0;
    DWORD dwRet;
    HKEY hkHistoryRoot = OpenRootKey();

    do {

        FILETIME ft;
        char  achHostName[INTERNET_MAX_HOST_NAME_LENGTH];
        DWORD dwNameLen = sizeof(achHostName);

        dwRet = RegEnumKeyEx(hkHistoryRoot,
                             dwIndex,
                             achHostName,
                             & dwNameLen,
                             NULL, NULL, NULL,
                             &ft);

        if (dwRet == ERROR_SUCCESS)
        {
            if (SHDeleteKey(hkHistoryRoot, achHostName) != ERROR_SUCCESS)
            {
                dwIndex++;
            }
        }
    }
    while (dwRet == ERROR_SUCCESS);

    CloseRootKey(hkHistoryRoot);

    return TRUE;
}

unsigned long CCookiePromptHistory::enumerateDecisions(char *pchSiteName, unsigned long *pcbName, 
                                                       unsigned long *pdwDecision, 
                                                       unsigned long dwIndex) {

    FILETIME ft;
    HKEY hkHistoryRoot = OpenRootKey();

    DWORD dwRet = RegEnumKeyEx(hkHistoryRoot, dwIndex, pchSiteName, pcbName, NULL, NULL, NULL, &ft);

    if (dwRet==ERROR_SUCCESS) {

        if (HKEY hSiteKey = lookupSiteKey(hkHistoryRoot, pchSiteName, false)) {

            DWORD dwType;
            DWORD dwSize = sizeof(DWORD);

            dwRet = RegQueryValueEx(hSiteKey, NULL, 0, &dwType, (LPBYTE) pdwDecision, &dwSize);
            RegCloseKey(hSiteKey);
        }
        else
        {
            dwRet = ERROR_NO_DATA;
        }
    }
    
    CloseRootKey(hkHistoryRoot);

    return dwRet;
}


/*
Exported APIs for manipulating per-site cookie settings
*/
extern CCookiePromptHistory cookieUIhistory;

BOOL DeletePersistentCookies(const char *pszDomainSuffix);


INTERNETAPI_(BOOL) InternetSetPerSiteCookieDecisionA( IN LPCSTR pchHostName, DWORD dwDecision)
{
    BOOL retVal = FALSE;
    
    if( !pchHostName 
        || IsBadStringPtr(pchHostName, INTERNET_MAX_URL_LENGTH))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    

    if( dwDecision == COOKIE_STATE_UNKNOWN)
    {
        retVal = cookieUIhistory.clearDecision( pchHostName, "*");
    }
    else if ( (dwDecision == COOKIE_STATE_ACCEPT) || (dwDecision == COOKIE_STATE_REJECT))
    {
        retVal = cookieUIhistory.saveDecision( pchHostName, NULL, dwDecision);

        /* side-effect: choosing to reject all future cookies for a given website 
           implicitly deletes existing cache cookies from that site*/
        if (dwDecision==COOKIE_STATE_REJECT)
            DeletePersistentCookies(pchHostName);
    }

    return retVal;
}

INTERNETAPI_(BOOL) InternetSetPerSiteCookieDecisionW( IN LPCWSTR pwchHostName, DWORD dwDecision)
{
    if( !pwchHostName || IsBadStringPtrW( pwchHostName, INTERNET_MAX_URL_LENGTH))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    MEMORYPACKET mpHostName;
    ALLOC_MB(pwchHostName,0,mpHostName);
    if (!mpHostName.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(pwchHostName, mpHostName);

    return InternetSetPerSiteCookieDecisionA( mpHostName.psStr, dwDecision);
}

INTERNETAPI_(BOOL) InternetGetPerSiteCookieDecisionA( IN LPCSTR pchHostName, unsigned long* pResult)
{
    if( IsBadWritePtr( pResult, sizeof(unsigned long))
        || !pchHostName
        || IsBadStringPtr(pchHostName, INTERNET_MAX_URL_LENGTH))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return cookieUIhistory.lookupDecision( pchHostName, NULL, pResult);
}

INTERNETAPI_(BOOL) InternetGetPerSiteCookieDecisionW( IN LPCWSTR pwchHostName, unsigned long* pResult)
{
    if( IsBadWritePtr( pResult, sizeof(unsigned long))
        || !pwchHostName
        || IsBadStringPtrW(pwchHostName, INTERNET_MAX_URL_LENGTH))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    MEMORYPACKET mpHostName;
    ALLOC_MB(pwchHostName,0,mpHostName);
    if (!mpHostName.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(pwchHostName, mpHostName);

    return InternetGetPerSiteCookieDecisionA( mpHostName.psStr, pResult);
}

INTERNETAPI_(BOOL) InternetEnumPerSiteCookieDecisionA(OUT LPSTR pszSiteName, IN OUT unsigned long *pcSiteNameSize, OUT unsigned long *pdwDecision, IN unsigned long dwIndex) {

    int error = ERROR_INVALID_PARAMETER;

    if( !pcSiteNameSize || IsBadWritePtr( pcSiteNameSize, sizeof(DWORD)))
    {
        goto doneInternetEnumPerSiteCookieDecisionA;
    }

    if( !pszSiteName || IsBadWritePtr( pszSiteName, *pcSiteNameSize))
    {
        goto doneInternetEnumPerSiteCookieDecisionA;
    }

    if( !pdwDecision || IsBadWritePtr(pdwDecision, sizeof(DWORD)))
    {
        goto doneInternetEnumPerSiteCookieDecisionA;
    }

    error = cookieUIhistory.enumerateDecisions(pszSiteName, pcSiteNameSize, pdwDecision, dwIndex);

    if( error == ERROR_SUCCESS)
        *pcSiteNameSize += 1;  //  reg function doesn't count null terminator in size, it should

doneInternetEnumPerSiteCookieDecisionA:
    if (error!=ERROR_SUCCESS)
        SetLastError(error);

    return (error==ERROR_SUCCESS);
}

INTERNETAPI_(BOOL) InternetEnumPerSiteCookieDecisionW(LPWSTR pwszSiteName, unsigned long *pcSiteNameSize, unsigned long *pdwDecision, unsigned long dwIndex) {

    DWORD dwErr = ERROR_INVALID_PARAMETER;
    BOOL fRet = FALSE;
    LPSTR pszSiteName = NULL;

    if( !pcSiteNameSize || IsBadWritePtr( pcSiteNameSize, sizeof(DWORD)))
        goto cleanup;

    if( !pwszSiteName || IsBadWritePtr( pwszSiteName, *pcSiteNameSize * sizeof(WCHAR)))
        goto cleanup;

    if( !pdwDecision || IsBadWritePtr( pdwDecision, sizeof(DWORD)))
        goto cleanup;

    pszSiteName = new char[*pcSiteNameSize];
    if( !pszSiteName)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    fRet = InternetEnumPerSiteCookieDecisionA( pszSiteName, pcSiteNameSize, pdwDecision, dwIndex);

    if (fRet)
    {
        SHAnsiToUnicode( pszSiteName, pwszSiteName, *pcSiteNameSize);
    }

    dwErr = ERROR_SUCCESS;

cleanup:
    if (dwErr!=ERROR_SUCCESS)
        SetLastError(dwErr);
    if ( pszSiteName != NULL)
        delete [] pszSiteName;

    return fRet;
}

INTERNETAPI_(BOOL) InternetClearAllPerSiteCookieDecisions()
{
    return cookieUIhistory.clearAll();
}

BOOL DeletePersistentCookies(const char *pszDomainSuffix)
{
    BOOL bRetval = TRUE;
    DWORD dwEntrySize, dwLastEntrySize;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntry;
    
    HANDLE hCacheDir = NULL;
    dwEntrySize = dwLastEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) new BYTE[dwEntrySize];
    if( lpCacheEntry == NULL)
    {
        bRetval = FALSE;
        goto Exit;
    }
    lpCacheEntry->dwStructSize = dwEntrySize;

Again:
    if (!(hCacheDir = FindFirstUrlCacheEntryA("cookie:",lpCacheEntry,&dwEntrySize)))
    {
        delete [] lpCacheEntry;
        switch(GetLastError())
        {
            case ERROR_NO_MORE_ITEMS:
                goto Exit;
            case ERROR_INSUFFICIENT_BUFFER:
                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                new BYTE[dwEntrySize];
                if( lpCacheEntry == NULL)
                {
                    bRetval = FALSE;
                    goto Exit;
                }
                lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                goto Again;
            default:
                bRetval = FALSE;
                goto Exit;
        }
    }

    do 
    {
        if (lpCacheEntry->CacheEntryType & COOKIE_CACHE_ENTRY) {

            const char achEmpty[] = "";
            const char *pszFind = NULL;
            const char *pszAtSign = strchr(lpCacheEntry->lpszSourceUrlName, '@');

            /* 
            The source URL for a cookie has the format:
            cookie:username@domain/path
            The logic for determining whether to delete the cookie checks for
            the following conditions on source URL:
                1. presence of the @ sign
                2. presence of argument passed in "pszDomainSuffix" as substring
                3. the substring must occur after a dot or the @ sign
                   (this avoids partial name matching on domains)
                4. substring must occur as suffix, eg only at the end
                   this happens IFF the match is followed by forward slash 
            */
            if (pszDomainSuffix==NULL ||    /* null argument means "delete all cookies" */
                  (pszAtSign &&
                  (pszFind=strstr(pszAtSign+1, pszDomainSuffix)) &&
                  (pszFind[-1]=='.' || pszFind[-1]=='@') &&
                   pszFind[strlen(pszDomainSuffix)]=='/'))
                DeleteUrlCacheEntryA(lpCacheEntry->lpszSourceUrlName);
        }

        dwEntrySize = dwLastEntrySize;
Retry:
        if (!FindNextUrlCacheEntryA(hCacheDir,lpCacheEntry, &dwEntrySize))
        {
            delete [] lpCacheEntry;
            switch(GetLastError())
            {
                case ERROR_NO_MORE_ITEMS:
                    goto Exit;
                case ERROR_INSUFFICIENT_BUFFER:
                    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                    new BYTE[dwEntrySize];
                    if( lpCacheEntry == NULL)
                    {
                        bRetval = FALSE;
                        goto Exit;
                    }
                    lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                    goto Retry;
                default:
                    bRetval = FALSE;
                    goto Exit;
            }
        }
    }
    while (TRUE);

Exit:
    if (hCacheDir)
        FindCloseUrlCache(hCacheDir);
    return bRetval;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\cookiepolicy.h ===
#include <wininetp.h>

/* Forward declarations */
class CP3PSettingsCache;
struct P3PCookieState;
struct CompactPolicy;
class CPEvalRule;



/* Abstract base class for representing evaluation rules */
class CPEvalRule {

public:
    /* virtual destructor is necessary... */
    virtual ~CPEvalRule() { } 

    /* Derived class MUST provide an implementation */
    virtual int evaluate(const CompactPolicy &sitePolicy) = 0;

protected:
    CPEvalRule *pNext;  /* used for keeping linked list of rules */

    friend  class CCookieSettings;
};


/* User-settings for handling cookies */
class CCookieSettings {

public:
    int    EvaluatePolicy(P3PCookieState *pState);
    
    void   AddRef() { iRefCount++; }
    void   Release();

  /* Externally used function for clearing memory cache.
     Called when internet options are changed */    
    static void RefreshP3PSettings();
    
    static bool GetSettings(CCookieSettings **pSettings, const char *pszURL, BOOL fis3rdParty, BOOL fRestricted=FALSE);

    static bool GetSettings(CCookieSettings **pSettings, DWORD dwSecZone, BOOL fis3rdParty);

    static bool extractCompactPolicy(const char *pszP3PHeader, char *pszPolicy, DWORD *pPolicyLen);

protected:
    CCookieSettings(unsigned char *pBinaryRep, int cb);
    ~CCookieSettings();

    bool   parseSpecialSymbol(char *pszToken, int iSetting);
    int    evaluateToken(const char *pszToken);

    void   addEvalRule(CPEvalRule *pRule);

    static void convertToASCII(char *pstrSettings, int cbBytes);

private:
    int     iRefCount;

    /* The flag determines if the settings always make the
       same decision regardless of policy.
       In that case the decision is stored in the next field */
    bool    fConstant;
    unsigned long dwFixedDecision;

    /* Decision in the absence of compact-policy */
    unsigned long dwNoPolicyDecision;

    /* Does the evaluation result apply to session cookies? */
    bool    fApplyToSC;

    unsigned char *MPactions;
    CPEvalRule    *pRuleSet, **ppLast;

    static  CP3PSettingsCache  cookiePrefsCache;
};

/*
 * Utility class that controls ownership of a critical section 
 * through its lifetime.
 * constructor invoked --> enter CS
 * destructor invoked --> leave CS
 */
class CriticalSectOwner {

public:
    CriticalSectOwner(CRITICAL_SECTION *pcs)
        { EnterCriticalSection(pSection=pcs); }

    ~CriticalSectOwner()    
        { LeaveCriticalSection(pSection); }

private:
    CRITICAL_SECTION *pSection;    
};


class CP3PSettingsCache {

public:
    CP3PSettingsCache();
    ~CP3PSettingsCache();

    CCookieSettings *lookupCookieSettings(DWORD dwZone, BOOL f3rdParty);
    void saveCookieSettings(DWORD dwZone, BOOL f3rdParty, CCookieSettings *pSettings);

    void evictAll();

private:

    enum { MaxKnownZone = 5 };

    CCookieSettings *stdCookiePref[MaxKnownZone+1];
    CCookieSettings *std3rdPartyPref[MaxKnownZone+1];

    CRITICAL_SECTION csCache;
};

/* 
 Data type for binary representation of compact-policies
 Since compact policy in V1 spec is simply a set of predefined
 tokens, we use a bit-set representation.
 */
struct CompactPolicy {

    typedef unsigned __int64 quadword;

    CompactPolicy()    { qwLow = qwHigh = 0; }

    CompactPolicy(quadword high, quadword low) : qwLow(low), qwHigh(high) { }

    CompactPolicy operator & (const CompactPolicy &ps)   const;
    bool   operator == (const CompactPolicy &ps)  const;
    bool   operator != (const CompactPolicy &ps)  const;

    void   addToken(int index);
    int    contains(int index);

    /* Two quadwords are sufficient provided # of tokens <= 128 */
    quadword qwLow;
    quadword qwHigh;
};

/* structure used for communicating with CCookieSettings::Evaluate */
struct P3PCookieState {

    const char     *pszP3PHeader;
    unsigned long   dwPolicyState;

    int fValidPolicy      : 1;  /* is there a syntactically valid policy? */
    int fEvaluated        : 1;  /* was the compact-policy evaluated? */
    int fIncSession       : 1;  /* does the outcome apply to session-cookies? */

    unsigned long   dwEvalMode; /* {accept, evaluate, reject} */

    CompactPolicy   cpSitePolicy;
};

/* Utility functions */
const char *getNextToken(const char *pch, char *pszToken, int cbToken, bool fWhiteSpc=true, int *pLength=NULL);
int mapCookieAction(char ch);
int findSymbol(const char *pstr);
CPEvalRule *parseEvalRule(char *pszRule, char **ppEndRule=NULL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\cookie.cxx ===
//---------------------------------------------------------------------------
//
// COOKIE.CXX
//
//     Cookie Jar
//
//     This file implements cookies as defined by Navigator 4 behavior and the
//     specification at http://www.netscape.com/newsref/std/cookie_spec.html.
//     If Navigator 4 and the specification are not in agreement, we try to
//     match the Navigator 4 behavior.
//
//     The following describes some interesting aspects of cookie behavior.
//
// SYNTAX
//
//    Syntax for cookie is
//
//          [[name]=] value [; options]
//
//    The name is everything before "=" with leading and  trailing whitespace
//    removed.  The value is everything after "=" and before ";" with leading
//    and trailing whitespace removed.  The name and value can contain spaces,
//    quotes or any other character except ";" and "=".  The name and equal
//    sign are optional.
//
//    Example:  =foo  ->  name: <blank> value: foo
//              foo   ->  name: <blank> value: foo
//              foo=  ->  name: foo     value: <blank>
//              ;     ->  name: <blank> value: <blank>
//
// ORDER
//
//    Cookies with a more specific path are sent before cookies with
//    a less specific path mapping.  The domain does not contibute
//    to the ordering of cookies.
//
//    If the path length of two cookies are equal, then the cookies
//    are ordered by time of creation.  Navigator maintains this
//    ordering across domain and path boundaries.  IE maintains this
//    ordering for a specific domain and path. It is difficult to match
//    the Navigator behavior and there are no known bugs because of
//    this difference.
//
// MATCHING
//
//    Path matches are done at the character level.  Any
//    directory structure in the path is ignored.
//
//    Navigator matches domains at the character level and ignores
//    the structure of the domain name.
//
//    Previous versions of IE tossed the leading "." on a domain name.
//    With out this information, character by character compares are
//    can produce incorrect results.  For backwards compatibilty with
//    old cookie we continue to match on a component by component basis.
//
//    Some examples of the difference are:
//
//       Cookie domain   Document domain  Navigator match  IE match
//       .foo.com        foo.com          no               yes
//       bar.x.com       foobar.x.com     yes              no
//
// ACCEPTING COOKIES
//
//    A cookie is rejected if the path specified in the set cookie
//    header is not a prefix of document's path.
//
//    Navigator rejects a cookie if the domain specified in the
//    set cookie header does not contain at least two periods
//    or the domain is not a suffix of the document's domain.
//    The suffix match is done on a character by character basis.
//
//    Navigator ignores all the stuff in the specification about
//    three period matching and the seven special top level domains.
//
//    IE rejects a cookie if the domain specified by the cookie
//    header does not contain at least one embedded period or the
//    domain is not a suffix of the documents domain.
//
//    Cookies are accepted if the path specified in the set cookie
//    header is a prefix of the document's path and the domain
//    specified in the set cookie header.
//
//    The difference in behavior is a result of the matching rules
//    described in the previous section.
//
//---------------------------------------------------------------------------

#include <wininetp.h>
#include "httpp.h"

#include "cookiepolicy.h"
#include "cookieprompt.h"


extern DWORD ConfirmCookie(HWND hwnd, HTTP_REQUEST_HANDLE_OBJECT *lpRequest, DWORD dwFlags, LPVOID *lppvData, LPDWORD pdwStopWarning);

#define CCH_COOKIE_MAX  (5 * 1024)

CRITICAL_SECTION s_csCookieJar;

static class CCookieJar *s_pJar;
static char s_achEmpty[] = "";
static char s_cCacheModify;
static const char s_achCookieScheme[] = "Cookie:";
static DWORD s_dwCacheVersion;
static BOOL s_fFirstTime = TRUE;

// Registry path for prompt-history
static const char  regpathPromptHistory[] = INTERNET_SETTINGS_KEY "\\P3P\\History";

// Prompt history-- persists user decisions about cookies
CCookiePromptHistory cookieUIhistory(regpathPromptHistory);

// Hard-coded list of special domains. If any of these are present between the
// second-to-last and last dot we will require 2 embedded dots.
// The domain strings are reversed to make the compares easier

static const char *s_pachSpecialRestrictedDomains[] =
    {"MOC", "UDE", "TEN", "GRO", "VOG", "LIM", "TNI" };

static const char s_chSpecialAllowedDomains[] = "vt.";  // domains ending with ".tv" always only need one dot

/* Non-scriptable cookies */
#define COOKIE_NONSCRIPTABLE    0x00002000

const char gcszNoScriptField[] = "httponly";

#if INET_DEBUG
DWORD s_dwThreadID;
#endif

// values returned from cookie UI
#define COOKIE_DONT_ALLOW   1
#define COOKIE_ALLOW        2
#define COOKIE_ALLOW_ALL    4
#define COOKIE_DONT_ALLOW_ALL 8

// Function declaration
BOOL EvaluateCookiePolicy(const char *pszURL, BOOL f3rdParty, BOOL fRestricted,
                          P3PCookieState *pState,
                          const char *pszHostName=NULL);

DWORD getImpliedCookieFlags(P3PCookieState *pState);

DWORD   GetCookieMainSwitch(DWORD dwZone);
DWORD   GetCookieMainSwitch(LPCSTR pszURL);

#define     IsLegacyCookie(pc)  ((pc->_dwFlags & INTERNET_COOKIE_IE6) == 0)

//---------------------------------------------------------------------------
//
// CACHE_ENTRY_INFO_BUFFER
//
//---------------------------------------------------------------------------

class CACHE_ENTRY_INFO_BUFFER : public INTERNET_CACHE_ENTRY_INFO
{
    BYTE _ab[5 * 1024];
};

//---------------------------------------------------------------------------
//
// CCookieCriticalSection
//
// Enter / Exit critical section.
//
//---------------------------------------------------------------------------

class CCookieCriticalSection
{
private:
    int Dummy; // Variable needed to force compiler to generate code for const/dest.
public:
    CCookieCriticalSection()
        {
            EnterCriticalSection(&s_csCookieJar);
            #if INET_DEBUG
                s_dwThreadID = GetCurrentThreadId();
            #endif
        }
    ~CCookieCriticalSection()
        {
            #if INET_DEBUG
                s_dwThreadID = 0;
            #endif
            LeaveCriticalSection(&s_csCookieJar);
        }
};

#define ASSERT_CRITSEC() INET_ASSERT(GetCurrentThreadId() == s_dwThreadID)

//---------------------------------------------------------------------------
//
// CCookieBase
//
// Provides operator new which allocates extra memory
// after object and initializes the memory to zero.
//
//---------------------------------------------------------------------------

class CCookieBase
{
public:

    void * operator new(size_t cb, size_t cbExtra);
    void operator delete(void *pv);
};

//---------------------------------------------------------------------------
//
// CCookie
//
// Holds a single cookie value.
//
//---------------------------------------------------------------------------


class CCookie : public CCookieBase
{
public:

    ~CCookie();
    static CCookie *Construct(const char *pchName);

    BOOL            SetValue(const char *pchValue);
    BOOL            WriteCacheFile(HANDLE hFile, char *pchRDomain, char *pchPath);
    BOOL            CanSend(FILETIME *pftCurrent, BOOL fSecure);
    BOOL            IsPersistent() { return (_dwFlags & COOKIE_SESSION) == 0; }
    BOOL            IsRestricted() { return (_dwFlags & COOKIE_RESTRICT)!= 0; }
    BOOL            IsLegacy()     { return (_dwFlags & INTERNET_COOKIE_IS_LEGACY) != 0; }

    BOOL            PurgePersistent(void *);
    BOOL            PurgeSession(void *);
    BOOL            PurgeAll(void *);
    BOOL            PurgeByName(void *);
    BOOL            PurgeThis(void *);
    BOOL            PurgeExpired(void *);

    FILETIME        _ftExpire;
    FILETIME        _ftLastModified;
    DWORD           _dwFlags;
    CCookie *       _pCookieNext;
    char *          _pchName;
    char *          _pchValue;
    DWORD           _dwPromptMask;      // never persisted, only used in session

};

//---------------------------------------------------------------------------
//
// CCookieLocation
//
// Holds all cookies for a given domain and path.
//
//---------------------------------------------------------------------------

class CCookieLocation : public CCookieBase
{
public:

    ~CCookieLocation();
    static CCookieLocation *Construct(const char *pchRDomain, const char *pchPath);

    CCookie *       GetCookie(const char *pchName, BOOL fCreate);
    BOOL            WriteCacheFile();
    BOOL            ReadCacheFile();
    BOOL            ReadCacheFileIfNeeded();
    BOOL            Purge(BOOL (CCookie::*)(void *), void *);
    BOOL            Purge(FILETIME *pftCurrent, BOOL fSession);
    BOOL            IsMatch(char *pchRDomain, char *pchPath);
    char *          GetCacheURL();

    FILETIME        _ftCacheFileLastModified;
    CCookie *       _pCookieKids;
    CCookieLocation*_pLocationNext;
    char *          _pchRDomain;
    char *          _pchPath;
    int             _cchPath;
    BYTE            _fCacheFileExists;
    BYTE            _fReadFromCacheFileNeeded;
};


//---------------------------------------------------------------------------
//
// CCookieJar
//
// Maintains fixed size hash table of cookie location objects.
//
//---------------------------------------------------------------------------
enum COOKIE_RESULT
{
    COOKIE_FAIL     = 0,
    COOKIE_SUCCESS  = 1,
    COOKIE_DISALLOW = 2,
    COOKIE_PENDING  = 3
};

class CCookieJar : public CCookieBase
{
public:

    static CCookieJar * Construct();
    ~CCookieJar();

    struct CookieInfo {

        const char *pchURL;
        char *pchRDomain;
        char *pchPath;
        char *pchName;
        char *pchValue;
        DWORD dwFlags;
        FILETIME ftExpire;

        P3PCookieState *pP3PState;
    };

    DWORD
    CheckCookiePolicy(
        HTTP_REQUEST_HANDLE_OBJECT *pRequest,
        CookieInfo *pInfo,
        DWORD dwOperation
        );

    void              EnforceCookieLimits(CCookieLocation *pLocation, char *pchName, BOOL *pfWriteCacheFileNeeded);
    DWORD             SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader,
                                DWORD &dwFlags, P3PCookieState *pState, LPDWORD pdwAction);
    void              Purge(FILETIME *pftCurrent, BOOL fSession);
    BOOL              SyncWithCache();
    BOOL              SyncWithCacheIfNeeded();
    void              CacheFilesModified();
    CCookieLocation** GetBucket(const char *pchRDomain);
    CCookieLocation * GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate);

    CCookieLocation * _apLocation[128];
};

//---------------------------------------------------------------------------
//
// Track cache modificaitons.
//
//---------------------------------------------------------------------------

inline void
MarkCacheModified()
{
    IncrementUrlCacheHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &s_dwCacheVersion);
}

inline BOOL
IsCacheModified()
{
    DWORD dwCacheVersion;

    if (s_fFirstTime)
    {
        s_fFirstTime = FALSE;
        GetUrlCacheHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &s_dwCacheVersion);
        return TRUE;
    }
    else
    {
        dwCacheVersion = s_dwCacheVersion;
        GetUrlCacheHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &s_dwCacheVersion);

        return dwCacheVersion != s_dwCacheVersion;
    }
}

//---------------------------------------------------------------------------
//
// String utilities
//
//---------------------------------------------------------------------------

static BOOL
IsZero(FILETIME *pft)
{
    return pft->dwLowDateTime == 0 && pft->dwHighDateTime == 0;
}

static char *
StrnDup(const char *pch, int cch)
{
    char *pchAlloc = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cch + 1);
    if (!pchAlloc)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memcpy(pchAlloc, pch, cch);
    pchAlloc[cch] = 0;

    return pchAlloc;
}

static BOOL
IsPathMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0;
}

static BOOL
IsDomainMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0 && (*pchStr == 0 || *pchStr == '.');
}

static BOOL
IsPathLegal(const char *pchHeader, const char *pchDocument)
{
    return TRUE;

    /*

    We attempted to implement the specification here.
    It looks like Navigator does not reject cookies
    based on the path attribute.  We now consider
    all path attributes to be legal.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    if (*pchDocument == 0)
    {
        while (*pchHeader && *pchHeader != '/' && *pchHeader != '\\')
        {
            pchHeader += 1;
        }
    }
    return *pchHeader == 0;
    */
}

//
// DarrenMi: No longer need IsVerySpecialDomain


extern PTSTR GlobalSpecialDomains;
extern PTSTR *GlobalSDOffsets;

static BOOL
IsVerySpecialDomain(const char *pch, int nTopLevel, int nSecond)
{
    if (!GlobalSpecialDomains)
    {
        HKEY hk;
        if (ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0"),
                                        0,
                                        KEY_READ,
                                        &hk))
        {
            DWORD dwType, dwSize;

            if ((ERROR_SUCCESS==RegQueryValueEx(hk, "SpecialDomains", NULL, &dwType, NULL, &dwSize))
                && (REG_SZ==dwType))
            {
                GlobalSpecialDomains = new TCHAR[dwSize];
                if (GlobalSpecialDomains
                    && (ERROR_SUCCESS==RegQueryValueEx(hk, "SpecialDomains", NULL, &dwType, (LPBYTE)GlobalSpecialDomains, &dwSize)))
                {

                    // We're going to scan a string stored in the registry to gather the domains we should
                    // allow. Format:
                    // [domain] [domain] [domain]
                    // The delimiter is a space character.

                    PTSTR psz = GlobalSpecialDomains;
                    DWORD dwDomains = 0;
                    BOOL fWord = FALSE;
                    while (*psz)
                    {
                        if (*psz==TEXT(' '))
                        {
                            if (fWord)
                            {
                                fWord = FALSE;
                                dwDomains++;
                            }
                        }
                        else
                        {
                            fWord = TRUE;
                        }
                        psz++;
                    }
                    if (fWord)
                    {
                        dwDomains++;
                    }
                    GlobalSDOffsets = (PTSTR*)new PTSTR[dwDomains+1];
                    if (GlobalSDOffsets)
                    {
                        psz = GlobalSpecialDomains;
                        for (DWORD dw = 0; dw < dwDomains; dw++)
                        {
                            INET_ASSERT(*psz);

                            while (*psz==TEXT(' '))
                                psz++;

                            INET_ASSERT(*psz);
                            GlobalSDOffsets[dw] = psz;

                            while (*psz && *psz!=TEXT(' '))
                            {
                                psz++;
                            }
                            if (*psz)
                            {
                                *psz = TEXT('\0');
                                psz++;
                            }
                        }
                        GlobalSDOffsets[dwDomains] = NULL;
                    }
                }
            }
            RegCloseKey(hk);
        }
    }

    // WARNING: The following lines of code make it possible for cookies to be set for *.uk,
    // (for example) if "ku." is in the registry
    BOOL fRet = FALSE;
    if (GlobalSDOffsets)
    {
        for (DWORD i = 0; GlobalSDOffsets[i]; i++)
        {
            if (!StrCmpNI(pch, GlobalSDOffsets[i], nTopLevel)
                || !StrCmpNI(pch, GlobalSDOffsets[i], nTopLevel+nSecond+1))
            {
                fRet = TRUE;
                break;
            }
        }
    }
    return fRet;
}


static BOOL
IsSpecialDomain(const char *pch, int nCount)
{
    for (int i = 0 ; i < ARRAY_ELEMENTS(s_pachSpecialRestrictedDomains) ; i++ )
    {
        if (StrCmpNIC(pch, s_pachSpecialRestrictedDomains[i], nCount) == 0)
            return TRUE;
    }

    return FALSE;
}

static BOOL
IsDomainLegal(const char *pchHeader, const char *pchDocument)
{
    const char *pchCurrent = pchHeader;
    int nSegment = 0;
    int dwCharCount = 0;
    int rgcch[2] = { 0, 0 };  // How many characters between dots

    // Must have at least one period in name.
    // and contains nothing but '.' is illegal

    int dwSegmentLength = 0;
    const char * pchSecondPart = NULL; // for a domain string such as
    BOOL fIPAddress = TRUE;
    for (; *pchCurrent; pchCurrent++)
    {
        if (isalpha(*pchCurrent))
        {
            fIPAddress = FALSE;
        }

        if (*pchCurrent == '.')
        {
            if (nSegment < 2)
            {
                // Remember how many characters we have between the last two dots
                // For example if domain header is .microsoft.com
                // rgcch[0] should be 3 for "com"
                // rgcch[1] should be 9 for "microsoft"
                rgcch[nSegment] = dwSegmentLength;

                if (nSegment == 1)
                {
                    pchSecondPart = pchCurrent - dwSegmentLength;
                }
            }
            dwSegmentLength = 0;
            nSegment += 1;
        }
        else
        {
            dwSegmentLength++;
        }
        dwCharCount++;
    }

    // The code below depends on the leading dot being removed from the domain header.
    // The parse code does that, but an assert here just in case something changes in the
    // parse code.
    INET_ASSERT(*(pchCurrent - 1) != '.');

    if (fIPAddress)
    {
        // If we're given an IP address, we must match the entire IP address, not just a part
        while (*pchHeader == *pchDocument && *pchDocument)
        {
            pchHeader++;
            pchDocument++;
        }
        return !(*pchHeader || *pchDocument);
    }

    // Remember the count of the characters between the begining of the header and
    // the first dot. So for domain=abc.com this will set rgch[1] = 3.
    // Note that this assumes that if domain=.abc.com the leading dot has been stripped
    // out in the parse code. See assert above.
    if (nSegment < 2 )
    {
        rgcch[nSegment] = dwSegmentLength;
        if (nSegment==1)
        {
            pchSecondPart = pchCurrent - dwSegmentLength;
        }
    }

    // If the domain name is of the form abc.xx.yy where the number of characters between the last two dots is less than
    // 2 we require a minimum of two embedded dots. This is so you are not allowed to set cookies readable by all of .co.nz for
    // example. However this rule is not sufficient and we special case things like .edu.nz as well.

    // darrenmi:  new semantics:  if segment 0 is less than or equal to 2, you need 2 embedded dots if segment 1 is a
    // "well known" string including edu, com, etc. and co.

    // fschwiet:  An exception is now being made so that domains of the form "??.tv" are allowed.

    int cEmbeddedDotsNeeded = 1;
    BOOL fIsVerySpecialDomain = FALSE;

    if (rgcch[0] <= 2 && rgcch[1] <= 2)
    {
        fIsVerySpecialDomain = IsVerySpecialDomain(pchHeader, rgcch[0], rgcch[1]);
    }


    if(!fIsVerySpecialDomain
       && rgcch[0] <= 2
       && 0 != StrCmpNIC( pchHeader, s_chSpecialAllowedDomains, sizeof( s_chSpecialAllowedDomains) - 1)
       && (rgcch[1] <= 2
           || IsSpecialDomain(pchSecondPart, rgcch[1])))
    {
        cEmbeddedDotsNeeded = 2;
    }

    if (nSegment < cEmbeddedDotsNeeded || dwCharCount == nSegment)
        return FALSE;

    // Mismatch between header and document not allowed.
    // Must match full components of domain name.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    return *pchHeader == 0 && (*pchDocument == 0 || *pchDocument == '.' );
}


void
LowerCaseString(char *pch)
{
    for (; *pch; pch++)
    {
        if (*pch >= 'A' && *pch <= 'Z')
            *pch += 'a' - 'A';
    }
}

static void
ReverseString(char *pchFront)
{
    char *pchBack;
    char  ch;
    int   cch;

    cch = strlen(pchFront);

    pchBack = pchFront + cch - 1;

    cch = cch / 2;
    while (--cch >= 0)
    {
        ch = tolower(*pchFront);
        *pchFront = tolower(*pchBack);
        *pchBack = ch;

        pchFront += 1;
        pchBack -= 1;
    }
}

static BOOL
PathAndRDomainFromURL(const char *pchURL, char **ppchRDomain, char **ppchPath, BOOL *pfSecure, BOOL bStrip = TRUE)
{
    char *pchDomainBuf;
    char *pchRDomain = NULL;
    char *pchPathBuf;
    char *pchPath = NULL;
    char *pchExtra;
    DWORD cchDomain;
    DWORD cchPath;
    DWORD cchExtra;
    BOOL  fSuccess = FALSE;
    DWORD dwError;
    INTERNET_SCHEME ustScheme;
    char *pchURLCopy = NULL;

    pchURLCopy = NewString(pchURL);
    if (!pchURLCopy)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    dwError = CrackUrl((char *)pchURLCopy,
             0,
             FALSE,
             &ustScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Lenth
             &pchDomainBuf,
             &cchDomain,
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             &pchPathBuf,
             &cchPath,
             &pchExtra,     //  Extra
             &cchExtra,     //  Extra Length
             NULL);

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        goto Cleanup;
    }

    if ( ustScheme != INTERNET_SCHEME_HTTP &&
         ustScheme != INTERNET_SCHEME_HTTPS &&
         ustScheme != INTERNET_SCHEME_FILE)
    {
        //
        // known scheme should be supported
        // e.g. 3rd party pluggable protocol should be able to
        // call cookie api to setup cookies...
        //
     
        //a-thkesa.  Allowing all of the pluggable protocols to setcookie creates security concerns.
        //So we only allow this "hcp" to qualify to setup cookie apart from 'file', Http, Https.
        //WinSE BUG: 24011 . In The windows help system they are setting cookie on a HCP protocol!.
        //we don't expect any protocol other then HTTP, HTTPS ,and File setting cookie here. But
        //we also have to allow the pluggable protocols to set cookie. Since allowing that causes security
        //problem, we only allow HCP which is a pluggable protocol used in windows Help and Support.
        //In future, we have to make sure to allow all of the pluggable protocol to set cookie, or 
        //document only http, https and file can set cookies!
        //pluggable protocols returns INTERNET_SCHEME_UNKNOWN.
        //If so check if it returns INTERNET_SCHEME_UNKNOWN and check the protocols is a HCP protocol. If it is HCP
        // then do not set error.
        if( INTERNET_SCHEME_UNKNOWN == ustScheme ) // HCP returns INTERNET_SCHEME_UNKNOWN
        {
          char szProtocolU[]= "HCP:"; 
          char szProtocolL[]= "hcp:";
          short ilen = 0;
          while(4 > ilen) // check only the first four char.
          {
            if(*(pchURLCopy+ilen) != *(szProtocolU+ilen) && 
            *(pchURLCopy+ilen) != *(szProtocolL+ilen) )
             {
              SetLastError(ERROR_INVALID_PARAMETER);
              goto Cleanup;
             }
            ilen++;
          }
        }
        else
        {
         SetLastError(ERROR_INVALID_PARAMETER);
         goto Cleanup;
        }
     }

    *pfSecure = ustScheme == INTERNET_SCHEME_HTTPS;

    if (ustScheme == INTERNET_SCHEME_FILE)
    {
        pchDomainBuf = "~~local~~";
        cchDomain = sizeof("~~local~~") - 1;
    }
    else
    {
        // SECURITY:  It's possible for us to navigate to a carefully
        //            constructed URL such as http://server%3F.microsoft.com.
        //            This results in a cracked hostname of server?.microsoft.com.
        //            Given the current architecture, it would probably be best to
        //            make CrackUrl smarter.  However, the minimal fix below prevents
        //            the x-domain security violation without breaking escaped cases
        //            that work today that customers may expect to be allowed.
        DWORD n;
        for (n = 0; n < cchDomain; n++)
        {
            // RFC 952 as amended by RFC 1123: the only valid chars are
            // a-z, A-Z, 0-9, '-', and '.'.  The last two are delimiters
            // which cannot start or end the name, but this detail doesn't
            // matter for the security fix.
            if (!((pchDomainBuf[n] >= 'a' && pchDomainBuf[n] <= 'z') ||
                  (pchDomainBuf[n] >= 'A' && pchDomainBuf[n] <= 'Z') ||
                  (pchDomainBuf[n] >= '0' && pchDomainBuf[n] <= '9') ||
                  (pchDomainBuf[n] == '-') ||
                  (pchDomainBuf[n] == '.')))
            {
                // Since we're incorrectly cracking the URL, don't worry
                // about fixing up the path.
                fSuccess = FALSE;
                goto Cleanup;
            }
        }
    }

    if(bStrip)
    {
        while (cchPath > 0)
        {
            if (pchPathBuf[cchPath - 1] == '/' || pchPathBuf[cchPath - 1] == '\\')
            {
                break;
            }
        cchPath -= 1;
        }
    }

    pchRDomain = StrnDup(pchDomainBuf, cchDomain);
    if (!pchRDomain)
        goto Cleanup;

    LowerCaseString(pchRDomain);
    ReverseString(pchRDomain);

    pchPath = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchPath + 2);
    if (!pchPath)
        goto Cleanup;

    if (*pchPathBuf != '/')
    {
        *pchPath = '/';
        memcpy(pchPath + 1, pchPathBuf, cchPath);
        pchPath[cchPath + 1] = TEXT('\0');
    }
    else
    {
        memcpy(pchPath, pchPathBuf, cchPath);
        pchPath[cchPath] = TEXT('\0');
    }

    fSuccess = TRUE;

Cleanup:
    if (!fSuccess)
    {
        if (pchRDomain)
            FREE_MEMORY(pchRDomain);
        if (pchPath)
            FREE_MEMORY(pchPath);
    }
    else
    {
        *ppchRDomain = pchRDomain;
        *ppchPath = pchPath;
    }

    if (pchURLCopy)
        FREE_MEMORY(pchURLCopy);

    return fSuccess;
}

//---------------------------------------------------------------------------
//
// CCookieBase implementation
//
//---------------------------------------------------------------------------

void *
CCookieBase::operator new(size_t cb, size_t cbExtra)
{
    void *pv = ALLOCATE_MEMORY(LMEM_FIXED, cb + cbExtra);
    if (!pv)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memset(pv, 0, cb);
    return pv;
}

inline void
CCookieBase::operator delete(void *pv)
{
    FREE_MEMORY(pv);
}

//---------------------------------------------------------------------------
//
// CCookie implementation
//
//---------------------------------------------------------------------------

CCookie *
CCookie::Construct(const char *pchName)
{
    CCookie *pCookie = new(strlen(pchName) + 1) CCookie();
    if (!pCookie)
        return NULL;

    pCookie->_pchName = (char *)(pCookie + 1);
    pCookie->_pchValue = s_achEmpty;
    strcpy(pCookie->_pchName, pchName);

    pCookie->_dwFlags = COOKIE_SESSION;
    pCookie->_dwPromptMask = 0;

    return pCookie;
}

CCookie::~CCookie()
{
    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);
}

BOOL
CCookie::SetValue(const char *pchValue)
{
    int   cchValue;

    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);

    if (!pchValue || !*pchValue)
    {
        _pchValue = s_achEmpty;
    }
    else
    {
        cchValue = strlen(pchValue) + 1;
        _pchValue = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchValue);
        if (!_pchValue)
        {
            _pchValue = s_achEmpty;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        memcpy(_pchValue, pchValue, cchValue);
    }
    return TRUE;
}

BOOL
CCookie::CanSend(FILETIME *pftCurrent, BOOL fSecure)
{
    return (fSecure || !(_dwFlags & COOKIE_SECURE)) &&
            (CompareFileTime(_ftExpire, *pftCurrent) >= 0);
}

BOOL CCookie::PurgePersistent(void *)
{
    return IsPersistent();
}

BOOL CCookie::PurgeAll(void *)
{
    return TRUE;
}

BOOL CCookie::PurgeByName(void *pvName)
{
    return strcmp((char *)pvName, _pchName) == 0;
}

BOOL CCookie::PurgeThis(void *pvThis)
{
    return this == (CCookie *)pvThis;
}

BOOL CCookie::PurgeExpired(void *pvCurrent)
{
    return CompareFileTime(_ftExpire, *(FILETIME *)pvCurrent) < 0;
}

static BOOL
WriteString(HANDLE hFile, const char *pch)
{
    DWORD cb;
    return pch && *pch ? WriteFile(hFile, pch, strlen(pch), &cb, NULL) : TRUE;
}

static BOOL
WriteStringLF(HANDLE hFile, const char *pch)
{
    DWORD cb;

    if (!WriteString(hFile, pch)) return FALSE;
    return WriteFile(hFile, "\n", 1, &cb, NULL);
}

BOOL
CCookie::WriteCacheFile(HANDLE hFile, char *pchRDomain, char *pchPath)
{
    BOOL fSuccess = FALSE;
    char achBuf[128];

    ReverseString(pchRDomain);

    if (!WriteStringLF(hFile, _pchName)) goto Cleanup;
    if (!WriteStringLF(hFile, _pchValue)) goto Cleanup;
    if (!WriteString(hFile, pchRDomain)) goto Cleanup;
    if (!WriteStringLF(hFile, pchPath)) goto Cleanup;

    wsprintf(achBuf, "%u\n%u\n%u\n%u\n%u\n*\n",
            _dwFlags,
            _ftExpire.dwLowDateTime,
            _ftExpire.dwHighDateTime,
            _ftLastModified.dwLowDateTime,
            _ftLastModified.dwHighDateTime);

    if (!WriteString(hFile, achBuf)) goto Cleanup;

    fSuccess = TRUE;

Cleanup:
    ReverseString(pchRDomain);
    return fSuccess;
}

//---------------------------------------------------------------------------
//
// CCookieLocation implementation
//
//---------------------------------------------------------------------------

CCookieLocation *
CCookieLocation::Construct(const char *pchRDomain, const char *pchPath)
{
    int cchPath = strlen(pchPath);

    CCookieLocation *pLocation = new(strlen(pchRDomain) + cchPath + 2) CCookieLocation();
    if (!pLocation)
        return NULL;

    pLocation->_cchPath = cchPath;
    pLocation->_pchPath = (char *)(pLocation + 1);
    pLocation->_pchRDomain = pLocation->_pchPath + cchPath + 1;

    strcpy(pLocation->_pchRDomain, pchRDomain);
    strcpy(pLocation->_pchPath, pchPath);

    return pLocation;
}

CCookieLocation::~CCookieLocation()
{
    Purge(CCookie::PurgeAll, NULL);
}

CCookie *
CCookieLocation::GetCookie(const char *pchName, BOOL fCreate)
{
    CCookie *pCookie;

    CCookie **ppCookie = &_pCookieKids;

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (strcmp(pchName, pCookie->_pchName) == 0)
            return pCookie;
        ppCookie = &pCookie->_pCookieNext;
    }

    if (!fCreate)
        return NULL;

    pCookie = CCookie::Construct(pchName);
    if (!pCookie)
        return NULL;

    //
    // Insert cookie at end of list to match Navigator's behavior.
    //

    pCookie->_pCookieNext = NULL;
    *ppCookie = pCookie;

    return pCookie;
}

BOOL
CCookieLocation::Purge(BOOL (CCookie::*pfnPurge)(void *), void *pv)
{
    CCookie **ppCookie = &_pCookieKids;
    CCookie *pCookie;
    BOOL     fPersistentDeleted = FALSE;

    while ((pCookie = *ppCookie) != NULL)
    {
        if ((pCookie->*pfnPurge)(pv))
        {
            *ppCookie = pCookie->_pCookieNext;
            fPersistentDeleted |= pCookie->IsPersistent();
            delete pCookie;
        }
        else
        {
            ppCookie = &pCookie->_pCookieNext;
        }
    }

    return fPersistentDeleted;
}

BOOL
CCookieLocation::Purge(FILETIME *pftCurrent, BOOL fSession)
{
    if (!_fCacheFileExists)
    {
        // If cache file is gone, then delete all persistent
        // cookies. If there's no cache file, then it's certainly
        // the case that we do not need to read the cache file.

        Purge(CCookie::PurgePersistent, NULL);
        _fReadFromCacheFileNeeded = FALSE;
    }

    // This is a good time to check for expired persistent cookies.

    if (!_fReadFromCacheFileNeeded && Purge(CCookie::PurgeExpired, pftCurrent))
    {
        WriteCacheFile();
    }

    if (fSession)
    {
        // If we are purging because a session ended, nuke
        // everything in sight.  If we deleted a persistent
        // cookie, note that we need to read the cache file
        // on next access.

        _fReadFromCacheFileNeeded |= Purge(CCookie::PurgeAll, NULL);
    }

    return !_fReadFromCacheFileNeeded && _pCookieKids == NULL;
}

char *
CCookieLocation::GetCacheURL()
{
    char *pchURL;
    char *pch;
    int cchScheme = sizeof(s_achCookieScheme) - 1;

    int cchUser = vdwCurrentUserLen;
    int cchAt = 1;
    int cchDomain = strlen(_pchRDomain);
    int cchPath = strlen(_pchPath);

    pchURL = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchScheme + cchUser + cchAt + cchDomain + cchPath + 1);
    if (!pchURL)
        return NULL;

    pch = pchURL;

    memcpy(pch, s_achCookieScheme, cchScheme);
    pch += cchScheme;

    memcpy(pch, vszCurrentUser, cchUser);
    pch += cchUser;

    memcpy(pch, "@", cchAt);
    pch += cchAt;

    ReverseString(_pchRDomain);
    memcpy(pch, _pchRDomain, cchDomain);
    ReverseString(_pchRDomain);
    pch += cchDomain;

    strcpy(pch, _pchPath);

    return pchURL;
}

BOOL
CCookieLocation::WriteCacheFile()
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    char        achFile[MAX_PATH];
    char *      pchURL = NULL;
    BOOL        fSuccess = FALSE;
    CCookie *   pCookie;
    FILETIME    ftLastExpire =  { 0, 0 };

    achFile[0] = 0;

    GetCurrentGmtTime(&_ftCacheFileLastModified);

    //
    // Determine the latest expiry time and if we have something to write.
    //

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (pCookie->IsPersistent() && CompareFileTime(pCookie->_ftExpire, ftLastExpire) > 0)
        {
            ftLastExpire = pCookie->_ftExpire;
        }
    }

    pchURL = GetCacheURL();
    if (!pchURL)
        goto Cleanup;

    if (CompareFileTime(ftLastExpire, _ftCacheFileLastModified) < 0)
    {
        fSuccess = TRUE;
        DeleteUrlCacheEntry(pchURL);
        _fCacheFileExists = FALSE;
        goto Cleanup;
    }

    _fCacheFileExists = TRUE;

    if (!CreateUrlCacheEntry(pchURL,
            0,              // Estimated size
            "txt",          // File extension
            achFile,
            0))
        goto Cleanup;

    hFile = CreateFile(
            achFile,
            GENERIC_WRITE,
            0, // no sharing.
            NULL,
            TRUNCATE_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL );
    if (hFile == INVALID_HANDLE_VALUE)
        goto Cleanup;

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (pCookie->IsPersistent() && CompareFileTime(pCookie->_ftExpire, _ftCacheFileLastModified) >= 0)
        {
            if (!pCookie->WriteCacheFile(hFile, _pchRDomain, _pchPath))
                goto Cleanup;
        }
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    if (!CommitUrlCacheEntry(pchURL,
            achFile,
            ftLastExpire,
            _ftCacheFileLastModified,
            NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY,
            NULL,
            0,
            NULL,
            0 ))
        goto Cleanup;

    MarkCacheModified();

    fSuccess = TRUE;

Cleanup:

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (!fSuccess)
    {
        if (achFile[0])
            DeleteFile(achFile);

        if (pchURL)
            DeleteUrlCacheEntry(pchURL);
    }

    if (pchURL)
        FREE_MEMORY(pchURL);

    return fSuccess;
}

static char *
ScanString(char *pch, char **pchStr)
{
    *pchStr = pch;

    for (; *pch; *pch++)
    {
        if (*pch == '\n')
        {
            *pch = 0;
            pch += 1;
            break;
        }
    }

    return pch;
}

static char *
ScanNumber(char *pch, DWORD *pdw)
{
    DWORD dw = 0;
    char *pchJunk;

    for (; *pch >= '0' && *pch <= '9'; *pch++)
    {
        dw = (dw * 10) + *pch - '0';
    }

    *pdw = dw;

    return ScanString(pch, &pchJunk);
}

BOOL
CCookieLocation::ReadCacheFile()
{
    char *      pchURL = NULL;
    char *      pch;
    DWORD       cbCEI;
    HANDLE      hCacheStream = NULL;
    char *      pchBuffer = NULL;
    CCookie *   pCookie;
    CACHE_ENTRY_INFO_BUFFER *pcei = new CACHE_ENTRY_INFO_BUFFER;

    if (pcei == NULL)
        goto Cleanup;

    _fReadFromCacheFileNeeded = FALSE;

    pchURL = GetCacheURL();
    if (!pchURL)
        goto Cleanup;

    cbCEI = sizeof(*pcei);

    hCacheStream = RetrieveUrlCacheEntryStream(
            pchURL,
            pcei,
            &cbCEI,
            FALSE, // sequential access
            0);

    if (!hCacheStream)
    {
        // If we failed to get the entry, try to nuke it so it does not
        // bother us in the future.

        DeleteUrlCacheEntry(pchURL);
        goto Cleanup;
    }

    // Old cache files to not have last modified time set.
    // Bump the time up so that we can use file times to determine
    // if we need to resync a file.

    if (IsZero(&(pcei->LastModifiedTime)))
    {
        pcei->LastModifiedTime.dwLowDateTime = 1;
    }

    _ftCacheFileLastModified = pcei->LastModifiedTime;

    // Read cache file into a null terminated buffer.

    pchBuffer = (char *)ALLOCATE_MEMORY(LMEM_FIXED, pcei->dwSizeLow + 1 * sizeof(char));
    if (!pchBuffer)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    if (!ReadUrlCacheEntryStream(hCacheStream, 0, pchBuffer, &pcei->dwSizeLow, 0))
        goto Cleanup;

    pchBuffer[pcei->dwSizeLow] = 0;

    // Blow away all existing persistent cookies.

    Purge(CCookie::PurgePersistent, NULL);

    // Parse cookies from the buffer;

    for (pch = pchBuffer; *pch; )
    {
        char *pchName;
        char *pchValue;
        char *pchLocation;
        char *pchStar;
        DWORD dwFlags;
        FILETIME ftExpire;
        FILETIME ftLast;

        pch = ScanString(pch, &pchName);
        pch = ScanString(pch, &pchValue);
        pch = ScanString(pch, &pchLocation);

        pch = ScanNumber(pch, &dwFlags);
        pch = ScanNumber(pch, &ftExpire.dwLowDateTime);
        pch = ScanNumber(pch, &ftExpire.dwHighDateTime);
        pch = ScanNumber(pch, &ftLast.dwLowDateTime);
        pch = ScanNumber(pch, &ftLast.dwHighDateTime);

        pch = ScanString(pch, &pchStar);

        if (strcmp(pchStar, "*"))
        {
            goto Cleanup;
        }

        pCookie = GetCookie(pchName, TRUE);
        if (!pCookie)
            goto Cleanup;

        // Initialize the cookie.

        pCookie->SetValue(pchValue);
        pCookie->_ftExpire = ftExpire;
        pCookie->_ftLastModified = ftLast;
        pCookie->_dwFlags = dwFlags;
    }

Cleanup:
    if (pcei)
        delete pcei;

    if (hCacheStream)
        UnlockUrlCacheEntryStream(hCacheStream, 0);

    if (pchURL)
        FREE_MEMORY(pchURL);

    if (pchBuffer)
        FREE_MEMORY(pchBuffer);

    return TRUE;
}

BOOL
CCookieLocation::IsMatch(char *pchRDomain, char *pchPath)
{
    return IsDomainMatch(_pchRDomain, pchRDomain) &&
        IsPathMatch(_pchPath, pchPath);
}

BOOL
CCookieLocation::ReadCacheFileIfNeeded()
{
    return _fReadFromCacheFileNeeded ? ReadCacheFile() : TRUE;
}


//---------------------------------------------------------------------------
//
// CCookieJar implementation
//
//---------------------------------------------------------------------------


CCookieJar *
CCookieJar::Construct()
{
    CCookieJar *s_pJar = new(0) CCookieJar();
    if (!s_pJar)
        return NULL;

    return s_pJar;
}

CCookieJar::~CCookieJar()
{
    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        CCookieLocation *pLocation = _apLocation[i];
        while (pLocation)
        {
            CCookieLocation *pLocationT = pLocation->_pLocationNext;
            delete pLocation;
            pLocation = pLocationT;
        }
    }
}

CCookieLocation **
CCookieJar::GetBucket(const char *pchRDomain)
{
    int ch;
    int cPeriod = 0;
    unsigned int hash = 0;

    ASSERT_CRITSEC();

    for (; (ch = *pchRDomain) != 0; pchRDomain++)
    {
        if (ch == '.')
        {
            cPeriod += 1;
            if (cPeriod >= 2)
                break;
        }
        hash = (hash * 29) + ch;
    }

    hash = hash % ARRAY_ELEMENTS(_apLocation);

    return &_apLocation[hash];
}

CCookieLocation *
CCookieJar::GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate)
{
    ASSERT_CRITSEC();

    int cchPath = strlen(pchPath);
    CCookieLocation *pLocation = NULL;
    CCookieLocation **ppLocation = GetBucket(pchRDomain);

    // To support sending more specific cookies before less specific,
    // we keep list sorted by path length.

    while ((pLocation = *ppLocation) != NULL)
    {
        if (pLocation->_cchPath < cchPath)
            break;

        if (strcmp(pLocation->_pchPath, pchPath) == 0 &&
            strcmp(pLocation->_pchRDomain, pchRDomain) == 0)
            return pLocation;

        ppLocation = &pLocation->_pLocationNext;
    }

    if (!fCreate)
        goto Cleanup;

    pLocation = CCookieLocation::Construct(pchRDomain, pchPath);
    if (!pLocation)
        goto Cleanup;

    pLocation->_pLocationNext = *ppLocation;
    *ppLocation = pLocation;

Cleanup:
    return pLocation;
}

void
CCookieJar::Purge(FILETIME *pftCurrent, BOOL fSession)
{
    ASSERT_CRITSEC();

    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        CCookieLocation **ppLocation = &_apLocation[i];
        CCookieLocation *pLocation;

        while ((pLocation = *ppLocation) != NULL)
        {
            if (pLocation->Purge(pftCurrent, fSession))
            {
                *ppLocation = pLocation->_pLocationNext;
                delete pLocation;
            }
            else
            {
                ppLocation = &pLocation->_pLocationNext;
            }
        }
    }
}

BOOL
CCookieJar::SyncWithCache()
{
    DWORD       dwBufferSize;
    HANDLE      hEnum = NULL;
    int         cchUserNameAt;
    char        achUserNameAt[MAX_PATH + 2];
    FILETIME    ftCurrent;
    char *      pchRDomain;
    char *      pchPath;
    char *      pch;
    CACHE_ENTRY_INFO_BUFFER *pcei;
    CCookieLocation *pLocation;

    ASSERT_CRITSEC();

    pcei = new CACHE_ENTRY_INFO_BUFFER;
    if (pcei == NULL)
        goto Cleanup;

    if (!vdwCurrentUserLen)
        GetWininetUserName();

    strcpy(achUserNameAt, vszCurrentUser);
    strcat(achUserNameAt, "@");
    cchUserNameAt = vdwCurrentUserLen+1;

    dwBufferSize = sizeof(*pcei);
    hEnum = FindFirstUrlCacheEntry(s_achCookieScheme, pcei, &dwBufferSize);

    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        for (pLocation = _apLocation[i];
                pLocation;
                pLocation = pLocation->_pLocationNext)
        {
            pLocation->_fCacheFileExists = FALSE;
        }
    }

    if (hEnum)
    {
        do
        {
            if ( pcei->lpszSourceUrlName &&
                (strnicmp(pcei->lpszSourceUrlName, s_achCookieScheme, sizeof(s_achCookieScheme) - 1 ) == 0) &&
                (strnicmp(pcei->lpszSourceUrlName+sizeof(s_achCookieScheme) - 1,achUserNameAt, cchUserNameAt) == 0))
            {

                // Split domain name from path in buffer.
                // Slide domain name down to make space for null terminator
                // between domain and path.

                pchRDomain = pcei->lpszSourceUrlName+sizeof(s_achCookieScheme) - 1 + cchUserNameAt - 1;

                for (pch = pchRDomain + 1; *pch && *pch != '/'; pch++)
                {
                    pch[-1] = pch[0];
                }
                pch[-1] = 0;

                pchPath = pch;

                ReverseString(pchRDomain);

                pLocation = GetLocation(pchRDomain, pchPath, TRUE);
                if (!pLocation)
                {
                    continue;
                }

                // Old cache files to not have last modified time set.
                // Bump the time up so that we can use file times to determine
                // if we need to resync a file.

                if (IsZero(&pcei->LastModifiedTime))
                {
                    pcei->LastModifiedTime.dwLowDateTime = 1;
                }

                if (CompareFileTime(pLocation->_ftCacheFileLastModified, pcei->LastModifiedTime) < 0)
                {
                    pLocation->_fReadFromCacheFileNeeded = TRUE;
                }

                pLocation->_fCacheFileExists = TRUE;

            }

            dwBufferSize = sizeof(*pcei);

        } while (FindNextUrlCacheEntryA(hEnum, pcei, &dwBufferSize));

        FindCloseUrlCache(hEnum);
    }

    // Now purge everthing we didn't get .

    GetCurrentGmtTime(&ftCurrent);
    Purge(&ftCurrent, FALSE);

Cleanup:
    if (pcei)
        delete pcei;

    return TRUE;
}

BOOL
CCookieJar::SyncWithCacheIfNeeded()
{
    return IsCacheModified() ? SyncWithCache() : TRUE;
}

struct PARSE
{
    char *pchBuffer;
    char *pchToken;
    BOOL fEqualFound;
};

static char *
SkipWS(char *pch)
{
    while (*pch == ' ' || *pch == '\t')
        pch += 1;

    return pch;
}

static BOOL
ParseToken(PARSE *pParse, BOOL fBreakOnSpecialTokens, BOOL fBreakOnEqual)
{
    char ch;
    char *pch;
    char *pchEndToken;

    pParse->fEqualFound = FALSE;

    pch = SkipWS(pParse->pchBuffer);
    if (*pch == 0)
    {
        pParse->pchToken = pch;
        return FALSE;
    }

    pParse->pchToken = pch;
    pchEndToken = pch;

    while ((ch = *pch) != 0)
    {
        pch += 1;
        if (ch == ';')
        {
            break;
        }
        else if (fBreakOnEqual && ch == '=')
        {
            pParse->fEqualFound = TRUE;
            break;
        }
        else if (ch == ' ' || ch == '\t')
        {
            if (fBreakOnSpecialTokens)
            {
                if ((strnicmp(pch, "expires", sizeof("expires") - 1) == 0) ||
                    (strnicmp(pch, "path", sizeof("path") - 1) == 0) ||
                    (strnicmp(pch, "domain", sizeof("domain") - 1) == 0) ||
                    (strnicmp(pch, "secure", sizeof("secure") - 1) == 0)    ||
                    (strnicmp(pch, gcszNoScriptField, sizeof(gcszNoScriptField) - 1) == 0))
                {
                    break;
                }
            }
        }
        else
        {
            pchEndToken = pch;
        }
    }

    *pchEndToken = 0;
    pParse->pchBuffer = pch;
    return TRUE;
}


static void
ParseHeader(
    char *pchHeader,
    char **ppchName,
    char **ppchValue,
    char **ppchPath,
    char **ppchRDomain,
    DWORD *pdwFlags,
    FILETIME *pftExpire)
{
    PARSE parse;

    parse.pchBuffer = pchHeader;

    *ppchName = NULL;
    *ppchValue = NULL;
    *ppchPath = NULL;
    *ppchRDomain = NULL;
    *pdwFlags = COOKIE_SESSION;

    // If only one of name or value is specified, Navigator
    // uses name=<blank> and value as what ever was specified.
    // Example:  =foo  ->  name: <blank> value: foo
    //           foo   ->  name: <blank> value: foo
    //           foo=  ->  name: foo     value: <blank>

    if (ParseToken(&parse, FALSE, TRUE))
    {
        *ppchName = parse.pchToken;
        if (parse.fEqualFound)
        {
            if (ParseToken(&parse, FALSE, FALSE))
            {
                *ppchValue = parse.pchToken;
            }
            else
            {
                *ppchValue = s_achEmpty;
            }
        }
        else
        {
            *ppchValue = *ppchName;
            *ppchName = s_achEmpty;
        }
    }

    while (ParseToken(&parse, FALSE, TRUE))
    {
        if (stricmp(parse.pchToken, "expires") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE))
            {
                if (FParseHttpDate(pftExpire, parse.pchToken))
                {
                    // Don't make the cookie persistent if the parsing fails
                    *pdwFlags &= ~COOKIE_SESSION;
                }
            }
        }
        else if (stricmp(parse.pchToken, "domain") == 0)
        {
            if (parse.fEqualFound )
            {
                if( ParseToken(&parse, TRUE, FALSE))
                {
                    // Previous versions of IE tossed the leading
                    // "." on domain names.  We continue this behavior
                    // to maintain compatiblity with old cookie files.
                    // See comments at the top of this file for more
                    // information.

                    if (*parse.pchToken == '.') parse.pchToken += 1;
                    ReverseString(parse.pchToken);
                    *ppchRDomain = parse.pchToken;
                }
                else
                {
                    *ppchRDomain = parse.pchToken;
                }
            }
        }
        else if (stricmp(parse.pchToken, "path") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE))
            {
                *ppchPath = parse.pchToken;
            }
            else
            {
                *ppchPath = s_achEmpty;
            }
        }
        else if (stricmp(parse.pchToken, "secure") == 0)
        {
            *pdwFlags |= COOKIE_SECURE;

            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
        else if (stricmp(parse.pchToken, gcszNoScriptField) == 0)
        {
            *pdwFlags |= COOKIE_NONSCRIPTABLE;

            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
        else
        {
            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
    }

    if (!*ppchName)
    {
        *ppchName = *ppchValue = s_achEmpty;
    }

    if (*pdwFlags & COOKIE_SESSION)
    {
        pftExpire->dwLowDateTime = 0xFFFFFFFF;
        pftExpire->dwHighDateTime = 0x7FFFFFFF;
    }
}

/* Replace non-printable characters in a string with given char
   This is used to enforce the RFC requirement that cookie header
   tokens can only contain chars in the range 0x20-0x7F.

   DCR: For compatability reasons we only replace control characters
   in the range 0x00 - 0x1F inclusive.
   There are international websites which depend on being able to
   set cookies with DBCS characters in name and value.
   (That assumption is wishful thinking and a violation of RFC2965.)
*/
void replaceControlChars(char *pszstr, char chReplace='_') {

    if (!pszstr)
        return;

    while (*pszstr) {
        if (*pszstr>=0x00 && *pszstr<=0x1F)
            *pszstr = chReplace;
        pszstr++;
    }
}

// free's an INTERNET_COOKIE structure
static VOID
DestroyInternetCookie(INTERNET_COOKIE *pic)
{
    if ( pic != NULL )
    {
        if ( pic->pszDomain ) {
            FREE_MEMORY(pic->pszDomain);
        }
        if ( pic->pszPath ) {
            FREE_MEMORY(pic->pszPath);
        }
        if ( pic->pszName ) {
            FREE_MEMORY(pic->pszName);
        }
        if ( pic->pszData ) {
            FREE_MEMORY(pic->pszData);
        }
        if ( pic->pszUrl ) {
            FREE_MEMORY(pic->pszUrl);
        }
        if( pic->pftExpires ) {
            delete pic->pftExpires;
            pic->pftExpires = NULL;
        }
        if (pic->pszP3PPolicy)
            FREE_MEMORY(pic->pszP3PPolicy);

        FREE_MEMORY(pic);
    }
}

// allocate's an INTERNET_COOKIE structure
static INTERNET_COOKIE *
MakeInternetCookie(
    const char *pchURL,
    char *pchRDomain,
    char *pchPath,
    char *pchName,
    char *pchValue,
    DWORD dwFlags,
    FILETIME ftExpire,
    const char *pchPolicy
    )
{
    INTERNET_COOKIE *pic = NULL;

    pic = (INTERNET_COOKIE *) ALLOCATE_MEMORY(LMEM_ZEROINIT, sizeof(INTERNET_COOKIE));

    if ( pic == NULL ) {
        return NULL;
    }

    pic->cbSize = sizeof(INTERNET_COOKIE);

    pic->pszDomain = pchRDomain ? NewString(pchRDomain) : NULL;
    if (pic->pszDomain) {
        ReverseString(pic->pszDomain);
    }
    pic->pszPath = pchPath ? NewString(pchPath) : NULL;
    pic->pszName = pchName ? NewString(pchName) : NULL;
    pic->pszData = pchValue ? NewString(pchValue) : NULL;
    pic->pszUrl = pchURL ? NewString(pchURL) : NULL;
    pic->pszP3PPolicy = pchPolicy? NewString(pchPolicy) : NULL;

#if COOKIE_SECURE != INTERNET_COOKIE_IS_SECURE
#error MakeInternetCookie depends on cookie flags to remain the same
#endif
    pic->dwFlags = dwFlags;

    if( dwFlags & COOKIE_SESSION )
    {
        pic->pftExpires = NULL;
    }
    else
    {
        pic->pftExpires = new FILETIME;
        if( pic->pftExpires )
        {
            memcpy(pic->pftExpires, &ftExpire, sizeof(FILETIME));
        }
    }

    return pic;
}

DWORD
GetPromptMask(BOOL fIsSessionCookie, BOOL fIs3rdPartyCookie)
{
    DWORD   dwMask = 0x01;      // prompted bit

    if(fIsSessionCookie)
        dwMask |= 0x02;

    if(fIs3rdPartyCookie)
        dwMask |= 0x04;

    return dwMask;
}


void
SetCookiePromptMask(
    LPSTR  pchRDomain,
    LPSTR  pchPath,
    BOOL    fSecure,
    BOOL    f3rdParty
    )
{
    CCookieLocation *pLocation;
    CCookie     *pCookie;
    FILETIME    ftCurrent;

    GetCurrentGmtTime(&ftCurrent);

    CCookieCriticalSection cs;

    if(s_pJar->SyncWithCacheIfNeeded())
    {
        for (pLocation = *s_pJar->GetBucket(pchRDomain); pLocation; pLocation = pLocation->_pLocationNext)
        {
            if (pLocation->IsMatch(pchRDomain, pchPath))
            {
                pLocation->ReadCacheFileIfNeeded();

                for (pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
                {
                    if (pCookie->CanSend(&ftCurrent, fSecure))
                    {
                        DWORD dwMask = GetPromptMask(!pCookie->IsPersistent(), f3rdParty);
                        DEBUG_PRINT(HTTP, INFO, ("[MASK] SetCookiePromptMask: Domain=%s, pCookie=%#x, dwMask=%#x\n", pchRDomain, pCookie, dwMask));
                        pCookie->_dwPromptMask = dwMask;
                    }
                }
            }
        }
    }
}


BOOL IsCookieIdentical(CCookie *pCookie, char *pchValue, DWORD dwFlags, FILETIME ftExpire)
{
    //
    // Decide if we need to prompt for a cookie when one already exists.  Basic idea is
    // if the cookie is identical, nothing is happening, so we don't need to prompt.
    // Change of value or expiry time (inc. session <-> persistent) means we need to
    // prompt again based on the new cookie type.
    //

    // no existing cookie ==> different
    if(NULL == pCookie)
    {
        return FALSE;
    }

    // if existing cookie has non-empty value and new value is NULL ==> different
    if(NULL == pchValue && pCookie->_pchValue != s_achEmpty)
    {
        return FALSE;
    }

    // different values ==> different (catches new non-empty value and existing empty value)
    if(pchValue && lstrcmp(pCookie->_pchValue, pchValue))
    {
        return FALSE;
    }

    // different flags ==> different
    if(dwFlags != pCookie->_dwFlags)
    {
        return FALSE;
    }

    // if persistant, different expires ==> different
    if(memcmp(&ftExpire, &pCookie->_ftExpire, sizeof(FILETIME)))
    {
        return FALSE;
    }

    return TRUE;
}

DWORD
CCookieJar::CheckCookiePolicy(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    CookieInfo *pInfo,
    DWORD dwOperation
    )
{
    /* Assumption: policy is checked at time of accepting cookies.
       Existing cookies are sent without prompt after that point */
    if (dwOperation & COOKIE_OP_GET)
        return COOKIE_SUCCESS;

    DWORD dwError;
    DWORD dwCookiesPolicy;
    BOOL fCleanupPcdi = FALSE;
    COOKIE_DLG_INFO *pcdi = NULL, *pcdi_result = NULL;

    SetLastError(ERROR_SUCCESS);

    //
    // Deal first with the basic quick cases to determine if we need UI here.
    //  they are:
    ///  - Do we allow UI for this given request?
    //
    if (pInfo->pchURL == NULL)
    {
        return COOKIE_FAIL;
    }

    if (pRequest && (pRequest->GetOpenFlags() & INTERNET_FLAG_NO_UI))
    {
        return COOKIE_FAIL;
    }

    //
    // Now look up the cookie and confirm that it hasn't just been added,
    //  if its already added to the Cookie list, then we don't show UI,
    //  since once the user has chosen to add a given Cookie, we don't repeatly re-prompt
    //

    if(dwOperation & COOKIE_OP_SET)
    {
        CCookieCriticalSection cs;
        CCookieLocation *pLocation;

        if (!SyncWithCacheIfNeeded())
            return COOKIE_FAIL;

        pLocation = GetLocation(pInfo->pchRDomain, pInfo->pchPath, FALSE /* no creation*/);

        if (pLocation)
        {
            CCookie *pCookie;

            pLocation->ReadCacheFileIfNeeded();
            pCookie = pLocation->GetCookie(pInfo->pchName, FALSE /* no creation */);
            if(IsCookieIdentical(pCookie, pInfo->pchValue, pInfo->dwFlags, pInfo->ftExpire))
            {
                return COOKIE_SUCCESS;
            }
        }
    }

    //
    // Now make the async request, to see if we can put up UI
    //

    {
        DWORD dwAction;
        DWORD dwResult;
        DWORD dwDialogToShow;
        LPVOID *ppParams;

        pcdi = new COOKIE_DLG_INFO;
        if(NULL == pcdi)
        {
            return COOKIE_FAIL;
        }

        memset(pcdi, 0, sizeof(*pcdi));

        pcdi->dwOperation = dwOperation;

        fCleanupPcdi = TRUE;

        if(dwOperation & COOKIE_OP_SESSION)
        {
            // make sure flags have session so it shows up right in the UI
            pInfo->dwFlags |= COOKIE_SESSION;
        }

        // create data to pass to dialog
        pcdi->pic = MakeInternetCookie(pInfo->pchURL,
                                       pInfo->pchRDomain,
                                       pInfo->pchPath,
                                       pInfo->pchName,
                                       pInfo->pchValue,
                                       pInfo->dwFlags,
                                       pInfo->ftExpire,
                                       pInfo->pP3PState ? pInfo->pP3PState->pszP3PHeader : NULL
                                       );

        if(pcdi->pic == NULL)
        {
            delete pcdi;
            return COOKIE_FAIL;
        }

        pcdi_result = pcdi;

        dwError = ChangeUIBlockingState(
                    (HINTERNET) pRequest,
                    ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION_EX,
                    &dwAction,
                    &dwResult,
                    (LPVOID *)&pcdi_result
                    );

        if(dwError != ERROR_IO_PENDING && dwError != ERROR_SUCCESS)
        {
            goto quit;
        }

        switch (dwAction)
        {
            case UI_ACTION_CODE_NONE_TAKEN:
            {
                // fallback to old behavior
                const int MaxConcurrentDialogs = 10;
                static HANDLE hUIsemaphore = CreateSemaphore(NULL, MaxConcurrentDialogs, MaxConcurrentDialogs, NULL);

                // restrict number of concurrent dialogs
                // NOTE: this is a *temporary* solution for #13393
                // revisit the problem of serializing dialogs when prompting behavior
                // for script is finalized.
                if (WAIT_TIMEOUT==WaitForSingleObject(hUIsemaphore, 0))
                {
                    dwError = ERROR_INTERNET_NEED_UI;
                    break;
                }

                dwError = ConfirmCookie(NULL, pRequest, pcdi);

                ReleaseSemaphore(hUIsemaphore, 1, NULL);

                // If user requested decision to persist, save prompt result in history
                // "dwStopWarning" may contain 0 (no policy change) or COOKIE_ALLOW_ALL
                // or COOKIE_DONT_ALLOW_ALL
                if(pcdi->dwStopWarning)
                {
                    int decision = (pcdi->dwStopWarning == COOKIE_ALLOW_ALL) ?
                                   COOKIE_STATE_ACCEPT :
                                   COOKIE_STATE_REJECT;

                    ReverseString(pInfo->pchRDomain);
                    cookieUIhistory.saveDecision(pInfo->pchRDomain, NULL, decision);
                    ReverseString(pInfo->pchRDomain);
                }

                break;
            }

            case UI_ACTION_CODE_USER_ACTION_COMPLETED:

                // If user requested decision to persist, save prompt result in history
                // "dwStopWarning" may contain 0 (no policy change) or COOKIE_ALLOW_ALL
                // or COOKIE_DONT_ALLOW_ALL
                if(pcdi_result->dwStopWarning)
                {
                    int decision = (pcdi_result->dwStopWarning == COOKIE_ALLOW_ALL) ?
                                   COOKIE_STATE_ACCEPT :
                                   COOKIE_STATE_REJECT;

                    ReverseString(pInfo->pchRDomain);
                    cookieUIhistory.saveDecision(pInfo->pchRDomain, NULL, decision);
                    ReverseString(pInfo->pchRDomain);
                }

                if (pcdi != pcdi_result)
                {
                    // got an old pcdi back, clean it
                    if(pcdi_result->pic)
                    {
                        DestroyInternetCookie(pcdi_result->pic);
                    }
                    delete pcdi_result;
                }

                // make sure we clean current, too
                INET_ASSERT(fCleanupPcdi);

                dwError = dwResult;
                break;

            case UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT:

                //
                // Go pending while we wait for the UI to be shown
                //
                INET_ASSERT(pcdi == pcdi_result);
                fCleanupPcdi = FALSE; // the UI needs this info, don't delete

                // fall through ...

            case UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE:

                INET_ASSERT(dwError == ERROR_IO_PENDING);
                break;
        }
    }

quit:
    if ( fCleanupPcdi )
    {
        if(pcdi->pic)
        {
            DestroyInternetCookie(pcdi->pic);
        }
        delete pcdi;
    }

    SetLastError(dwError);

    if (dwError != ERROR_SUCCESS)
    {
        if ( dwError == ERROR_IO_PENDING ) {
            return COOKIE_PENDING;
        } else {
            return COOKIE_FAIL;
        }
    }
    else
    {
        return COOKIE_SUCCESS;
    }

}


DWORD
CCookieJar::SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader,
                      DWORD &dwFlags, P3PCookieState *pState = NULL, LPDWORD pdwAction = NULL)
{
    FILETIME ftExpire;
    FILETIME ftCurrent;
    char *pchName;
    char *pchValue;
    char *pchHeaderPath;
    char *pchHeaderRDomain;
    char *pchDocumentRDomain = NULL;
    char *pchDocumentPath = NULL;
    DWORD dwFlagsFromParse;
    BOOL  fDocumentSecure;
    BOOL  fDelete;
    DWORD dwRet = COOKIE_FAIL;
    BOOL  fWriteToCacheFileNeeded;
    CCookieLocation *pLocation;
    DWORD dwOperation = COOKIE_OP_SET;
    DWORD dwReqAction = COOKIE_STATE_UNKNOWN;

    ParseHeader(pchHeader, &pchName, &pchValue, &pchHeaderPath, &pchHeaderRDomain, &dwFlagsFromParse, &ftExpire);
    // merge flags given with those found by the parser.
    dwFlags |= dwFlagsFromParse;

    if (!PathAndRDomainFromURL(pchURL, &pchDocumentRDomain, &pchDocumentPath, &fDocumentSecure))
        goto Cleanup;

    //
    // Verify domain and path
    //

    if ((pchHeaderRDomain && !IsDomainLegal(pchHeaderRDomain, pchDocumentRDomain)) ||
        (pchHeaderPath && !IsPathLegal(pchHeaderPath, pchDocumentPath)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    // Remove control-characters and other non-ASCII symbols
    replaceControlChars(pchName);
    replaceControlChars(pchValue);
    replaceControlChars(pchHeaderPath);
    replaceControlChars(pchHeaderRDomain);

    if (!pchHeaderRDomain)
        pchHeaderRDomain = pchDocumentRDomain;

    if (!pchHeaderPath)
        pchHeaderPath = pchDocumentPath;

    // We need to discard any extra info (i.e. query strings and fragments)
    // from the url.
    if (pchHeaderPath)
    {
        PTSTR psz = pchHeaderPath;
        while (*psz)
        {
            if (*psz==TEXT('?') || *psz==TEXT('#'))
            {
                *psz = TEXT('\0');
                break;
            }
            psz++;
        }
    }

    //
    // Delete the cookie?
    //

    GetCurrentGmtTime(&ftCurrent);
    fDelete = CompareFileTime(ftCurrent, ftExpire) > 0;

    // get 3rd part flag
    BOOL f3rdParty = (pRequest && pRequest->Is3rdPartyCookies())    ||
                     (dwFlags & INTERNET_COOKIE_THIRD_PARTY);

    if (f3rdParty)
    {
        dwOperation |= COOKIE_OP_3RD_PARTY;
    }

    // check session vs. persistent
    if(dwFlagsFromParse & COOKIE_SESSION)
    {
        dwOperation |= COOKIE_OP_SESSION;
    }
    else
    {
        dwOperation |= COOKIE_OP_PERSISTENT;
    }


    BOOL fSessionCookie = dwFlags & COOKIE_SESSION;

    /* DELETE operations are not subject to P3P, except for leashed cookies */
    BOOL fP3PApplies = !fDelete && pState && (!fSessionCookie || pState->fIncSession);

    /* Check for the "anything-goes" mode */
    BOOL fAllowAll = pState && (pState->dwEvalMode==URLPOLICY_ALLOW);

    /* if cookie operations are disabled, fail the operation */
    if (pState && pState->dwEvalMode==URLPOLICY_DISALLOW)
        dwReqAction = COOKIE_STATE_REJECT;
    else if (fP3PApplies && !fAllowAll) {

        /* Since downgrading a session cookie is a NOOP,
           report the action as ACCEPT in that case */
        if (fSessionCookie && pState->dwPolicyState==COOKIE_STATE_DOWNGRADE)
            dwReqAction = COOKIE_STATE_ACCEPT;
        dwFlags |= getImpliedCookieFlags(pState);
        dwReqAction = pState->dwPolicyState;
    }
    else
        dwReqAction = COOKIE_STATE_ACCEPT;

    // If prompt is required, show UI
    if((dwFlags & INTERNET_COOKIE_PROMPT_REQUIRED) ||
        dwReqAction==COOKIE_STATE_PROMPT)
    {
        CookieInfo ckInfo =
        {
            pchURL,
            pchHeaderRDomain, pchHeaderPath,
            pchName, pchValue,
            dwFlags
        };

        ckInfo.ftExpire = ftExpire;
        ckInfo.pP3PState = pState;

        dwRet = CheckCookiePolicy(pRequest, &ckInfo, dwOperation);

        if (dwRet != COOKIE_SUCCESS) {
            dwReqAction = COOKIE_STATE_REJECT;
            goto Cleanup;
        }
        else
            dwReqAction = COOKIE_STATE_ACCEPT;
    }

    if (dwReqAction==COOKIE_STATE_REJECT) {
        dwRet = COOKIE_FAIL;
        goto Cleanup;
    }

    //
    // Finally, we can add the cookie!
    //

    {
        CCookieCriticalSection cs;

        if (!SyncWithCacheIfNeeded())
            goto Cleanup;

        pLocation = GetLocation(pchHeaderRDomain, pchHeaderPath, !fDelete);

        if (pLocation)
        {
            pLocation->ReadCacheFileIfNeeded();
            fWriteToCacheFileNeeded = FALSE;

            if (fDelete)
            {
                CCookie *pCookie = pLocation->GetCookie(pchName, FALSE);

                // If the cookie we are attempting to delete does not exist,
                // return success code
                if (!pCookie) {
                    dwRet = COOKIE_SUCCESS;
                    goto Cleanup;
                }

                /* Leashed cookies cannot be deleted from 3rd party context
                   unless P3P is disabled completely eg when "fAllowAll" is true.
                   EXCEPTION: allow *legacy* leashed cookies to be deleted from 3rd party */
                if (pCookie->IsRestricted()
                    && f3rdParty
                    && !(fAllowAll || pCookie->IsLegacy()))
                {
                    dwReqAction = COOKIE_STATE_REJECT;
                    goto Cleanup;
                }

                fWriteToCacheFileNeeded |= pLocation->Purge(CCookie::PurgeByName, pchName);
            }
            else
            {
                CCookie *pCookie;

                EnforceCookieLimits(pLocation, pchName, &fWriteToCacheFileNeeded);

                pCookie = pLocation->GetCookie(pchName, TRUE);

                if (!pCookie)
                    goto Cleanup;

                pCookie->_ftLastModified = ftCurrent;

                if (memcmp(&ftExpire, &pCookie->_ftExpire, sizeof(FILETIME)) ||
                    strcmp(pchValue, pCookie->_pchValue) ||
                    dwFlags != pCookie->_dwFlags)
                {
                    fWriteToCacheFileNeeded |= pCookie->IsPersistent();

                    pCookie->_ftExpire = ftExpire;
                    pCookie->_dwFlags = dwFlags;
                    pCookie->SetValue(pchValue);
                    pCookie->_dwPromptMask = GetPromptMask(dwOperation & COOKIE_OP_SESSION, dwOperation & COOKIE_OP_3RD_PARTY);

                    DEBUG_PRINT(HTTP, INFO, ("[MASK] SetCookie: Domain=%s, Updating cookie mask, pCookie=%#x, new mask=%#x\n", pchHeaderRDomain, pCookie, pCookie->_dwPromptMask));

                    fWriteToCacheFileNeeded |= pCookie->IsPersistent();
                }
            }

            if (fWriteToCacheFileNeeded)
            {
                if (!pLocation->WriteCacheFile())
                    goto Cleanup;
            }
        }
    }

    dwRet = COOKIE_SUCCESS;

Cleanup:
    if (pchDocumentRDomain)
        FREE_MEMORY(pchDocumentRDomain);
    if (pchDocumentPath)
        FREE_MEMORY(pchDocumentPath);

    if (pdwAction)
        *pdwAction = dwReqAction;

    return dwRet;
}

void
CCookieJar::EnforceCookieLimits(CCookieLocation *pLocationNew, char *pchNameNew, BOOL *fWriteToCacheFileNeeded)
{
    CCookieLocation *pLocation;
    CCookieLocation *pLocationVictim;
    CCookie *pCookie;
    CCookie *pCookieVictim = NULL;
    int nCookie = 0;

    for (pLocation = *GetBucket(pLocationNew->_pchRDomain); pLocation; pLocation = pLocation->_pLocationNext)
    {
        // Same domain?

        if (stricmp(pLocationNew->_pchRDomain, pLocation->_pchRDomain) == 0)
        {
            pLocation->ReadCacheFileIfNeeded();
            for (pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
            {
                nCookie += 1;

                if (pLocation == pLocationNew && strcmp(pCookie->_pchName, pchNameNew) == 0)
                {
                    // No need to enforce limits when resetting existing cookie value.
                    return;
                }

                if (!pCookieVictim ||
                    CompareFileTime(pCookie->_ftLastModified, pCookieVictim->_ftLastModified) < 0)
                {
                    pCookieVictim = pCookie;
                    pLocationVictim = pLocation;
                }
            }
        }
    }

    if (nCookie >= 20)
    {
        INET_ASSERT(pCookieVictim != NULL && pLocationVictim != NULL);

        if (pLocationVictim->Purge(CCookie::PurgeThis, pCookieVictim))
        {
            pLocationVictim->WriteCacheFile();
        }
    }
}

//---------------------------------------------------------------------------
//
// External APIs
//
//---------------------------------------------------------------------------

BOOL
OpenTheCookieJar()
{
    if (s_pJar)
        return TRUE;

    s_pJar = CCookieJar::Construct();
    if (!s_pJar)
        return FALSE;

    InitializeCriticalSection(&s_csCookieJar);

    return TRUE;
}

void
CloseTheCookieJar()
{
    if (s_pJar)
    {
        DeleteCriticalSection(&s_csCookieJar);
        delete s_pJar;
    }

    s_fFirstTime = TRUE;
    s_pJar = NULL;
}

void
PurgeCookieJarOfStaleCookies()
{
    FILETIME ftCurrent;

    if (s_pJar)
    {
        CCookieCriticalSection cs;
        GetCurrentGmtTime(&ftCurrent);
        s_pJar->Purge(&ftCurrent, TRUE);
    }
}

INTERNETAPI_(BOOL) InternetGetCookieW(
    LPCWSTR  lpszUrl,
    LPCWSTR  lpszCookieName,
    LPWSTR   lpszCookieData,
    LPDWORD lpdwSize
    )
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetGetCookieW",
                     "%wq, %#x, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData,
                     lpdwSize
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrl, mpCookieName, mpCookieData;

    ALLOC_MB(lpszUrl,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszUrl,mpUrl);
    if (lpszCookieName)
    {
        ALLOC_MB(lpszCookieName,0,mpCookieName);
        if (!mpCookieName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieName,mpCookieName);
    }
    if (lpszCookieData)
    {
        mpCookieData.dwAlloc = mpCookieData.dwSize = *lpdwSize;
        mpCookieData.psStr = (LPSTR)ALLOC_BYTES(*lpdwSize);
        if (!mpCookieData.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    fResult = InternetGetCookieA(mpUrl.psStr, mpCookieName.psStr, mpCookieData.psStr, &mpCookieData.dwSize);

    *lpdwSize = mpCookieData.dwSize*sizeof(WCHAR);
    if (lpszCookieData)
    {
        if (mpCookieData.dwSize <= mpCookieData.dwAlloc)
        {
            //Bug 2110: InternetGetCookieA already considered '\0' at the end of URL. MAYBE_COPY_ANSI does it again.
            //We don't want to change MAYBE_COPY_ANSI, so we mpCookieData.dwSize -= 1 here. Otherwise we will overflow the heap
            mpCookieData.dwSize -= 1;
            MAYBE_COPY_ANSI(mpCookieData,lpszCookieData,*lpdwSize);
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            fResult = FALSE;
        }
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

void    convertLegacyCookie(CCookie *pCookie, CCookieLocation *pLocation) {

    const char* gasz_OptOutName[] = {"ID", "AA002", "id", "CyberGlobalAnonymous"};
    const char* gasz_OptOutValue[] = {"OPT_OUT", "optout", "OPT_OUT", "optout"};

    if (GlobalLeashLegacyCookies)
        pCookie->_dwFlags |= INTERNET_COOKIE_IS_RESTRICTED;

    /* special-case opt-out cookies-- these will never get leashed */
    for( int i = 0;
         i < sizeof( gasz_OptOutName)/sizeof(gasz_OptOutName[0]);
         i++)
    {
        if (!strcmp(pCookie->_pchName, gasz_OptOutName[i])
            && !strcmp(pCookie->_pchValue, gasz_OptOutValue[i]))
        {
            pCookie->_dwFlags &= ~INTERNET_COOKIE_IS_RESTRICTED;
            break;
        }
    }

    // Legacy cookies are special-cased for one time only
    // After that they are subject to P3P.
    pCookie->_dwFlags |= INTERNET_COOKIE_IE6;

    /* we need to remember which cookies are genuine IE6 vs. upgraded legacy... */
    pCookie->_dwFlags |= INTERNET_COOKIE_IS_LEGACY;

    pLocation->WriteCacheFile();
}


//
//  InternetGetCookieEx only returns those cookies within domain pchURL
//with a name that maches pchCookieName
//

INTERNETAPI_(BOOL) InternetGetCookieEx(
    IN LPCSTR pchURL,
    IN LPCSTR pchCookieName OPTIONAL,
    IN LPSTR pchCookieData OPTIONAL,
    IN OUT LPDWORD pcchCookieData,
    IN DWORD dwFlags,
    IN LPVOID lpReserved)
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetGetCookieA",
                     "%q, %#x, %#x, %#x",
                     pchURL,
                     pchCookieName,
                     pchCookieData,
                     pcchCookieData
                     ));

    //  force everyone to not give anything in lpReserved
    INET_ASSERT( lpReserved == NULL);
    if( lpReserved != NULL)
    {
        DEBUG_LEAVE_API(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    /*
    //  force everyone to not give anything in dwFlags
    INET_ASSERT( dwFlags == 0);
    if( dwFlags != 0)
    {
        DEBUG_LEAVE_API(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    */


    BOOL    fSuccess = FALSE;
    char *  pchRDomain = NULL;
    char *  pchPath = NULL;
    BOOL    fSecure;
    DWORD   cch = 0;
    BOOL    fFirst;
    int     cchName;
    int     cchValue;
    FILETIME ftCurrent;
    CCookieLocation *pLocation;
    CCookie *pCookie;
    DWORD dwErr = ERROR_SUCCESS;

    if (!pcchCookieData || !pchURL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if (!GlobalDataInitialized) {

        dwErr = GlobalDataInitialize();
        if (dwErr!= ERROR_SUCCESS) {
            goto done;
        }
    }

    // NOTE THIS SEEMS TO BE A BUG BUG BUG
    if (!PathAndRDomainFromURL(pchURL, &pchRDomain, &pchPath, &fSecure))
        goto Cleanup;

    DWORD dwMainSwitch = (dwFlags & INTERNET_FLAG_RESTRICTED_ZONE) ?
                         GetCookieMainSwitch(URLZONE_UNTRUSTED) :
                         GetCookieMainSwitch(pchURL);

    fFirst = TRUE;
    GetCurrentGmtTime(&ftCurrent);

    {
        CCookieCriticalSection cs;

        if (!s_pJar->SyncWithCacheIfNeeded())
            goto Cleanup;

        for (pLocation = *s_pJar->GetBucket(pchRDomain); pLocation; pLocation = pLocation->_pLocationNext)
        {
            if (pLocation->IsMatch(pchRDomain, pchPath))
            {
                pLocation->ReadCacheFileIfNeeded();

                for (pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
                {
                    if (IsLegacyCookie(pCookie))
                        convertLegacyCookie(pCookie, pLocation);

                    BOOL fAllow;

                    if (dwMainSwitch==URLPOLICY_ALLOW)              /* replay all cookies-- even leashed ones */
                        fAllow = TRUE;
                    else if (dwMainSwitch==URLPOLICY_DISALLOW)      /* suppress everything */
                        fAllow = FALSE;
                    else
                    {
                        /* default behavior: replay the cookie, provided its not leashed
                                             or we are in 1st party context */
                        fAllow = !pCookie->IsRestricted() ||
                                 (dwFlags & INTERNET_COOKIE_THIRD_PARTY) == 0;
                    }

                    BOOL fNonScriptable = (pCookie->_dwFlags & COOKIE_NONSCRIPTABLE);

                    if (fAllow
                        && !fNonScriptable  // Check for non-scriptable cookies
                        && pCookie->CanSend(&ftCurrent, fSecure)
                        && (pchCookieName == NULL
                            || StrCmp( pCookie->_pchName, pchCookieName) == 0))

                    {
                        if (!fFirst) cch += 2; // for ; <space>
                        cch += cchName = strlen(pCookie->_pchName);
                        cch += cchValue = strlen(pCookie->_pchValue);
                        if (cchName && cchValue) cch += 1; // for equal sign

                        if (pchCookieData && cch < *pcchCookieData)
                        {
                            if (!fFirst)
                            {
                                *pchCookieData++ = ';';
                                *pchCookieData++ = ' ';
                            }

                            if (cchName > 0)
                            {
                                memcpy(pchCookieData, pCookie->_pchName, cchName);
                                pchCookieData += cchName;

                                if (cchValue > 0)
                                {
                                    *pchCookieData++ = '=';
                                }
                            }

                            if (cchValue > 0)
                            {
                                memcpy(pchCookieData, pCookie->_pchValue, cchValue);
                                pchCookieData += cchValue;
                            }
                        }

                        fFirst = FALSE;
                    }
                }
            }
        }
    }

//TerminateBuffer:

    cch += 1;

    if (pchCookieData)
    {
        if (cch > *pcchCookieData)
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            *pchCookieData = 0;
            fSuccess = TRUE;
        }
    }
    else
    {
        fSuccess = TRUE;
    }

    if (cch == 1)
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        fSuccess = FALSE;
        cch = 0;
    }

    *pcchCookieData = cch;

Cleanup:

    if (pchRDomain)
        FREE_MEMORY(pchRDomain);
    if (pchPath)
        FREE_MEMORY(pchPath);

done:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fSuccess);
    return fSuccess;
}

/*
 UNICODE version for InternetGetCookieEx
 Difference from the standard InternetGetCookie* function is
 addition of two parameters.
 Supported flags: third-party, prompt-required.
 */
INTERNETAPI_(BOOL) InternetGetCookieExW(
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszCookieName OPTIONAL,
    IN LPWSTR lpszCookieData OPTIONAL,
    IN OUT LPDWORD lpdwSize,
    IN DWORD dwFlags,
    IN LPVOID lpReserved)
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetGetCookieExW",
                     "%wq, %#x, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData,
                     lpdwSize
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrl, mpCookieName, mpCookieData;

    ALLOC_MB(lpszUrl,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszUrl,mpUrl);
    if (lpszCookieName)
    {
        ALLOC_MB(lpszCookieName,0,mpCookieName);
        if (!mpCookieName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieName,mpCookieName);
    }
    if (lpszCookieData)
    {
        mpCookieData.dwAlloc = mpCookieData.dwSize = *lpdwSize;
        mpCookieData.psStr = (LPSTR)ALLOC_BYTES(*lpdwSize);
        if (!mpCookieData.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    fResult = InternetGetCookieExA(mpUrl.psStr, mpCookieName.psStr, mpCookieData.psStr, &mpCookieData.dwSize, dwFlags, lpReserved);

    *lpdwSize = mpCookieData.dwSize*sizeof(WCHAR);
    if (lpszCookieData)
    {
        if (mpCookieData.dwSize <= mpCookieData.dwAlloc)
        {
            MAYBE_COPY_ANSI(mpCookieData,lpszCookieData,*lpdwSize);
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            fResult = FALSE;
        }
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;

    return FALSE;
}

INTERNETAPI_(BOOL) InternetGetCookieA(
    IN LPCSTR pchURL,
    IN LPCSTR pchCookieName OPTIONAL,
    IN LPSTR pchCookieData OPTIONAL,
    IN OUT LPDWORD pcchCookieData
    )
{
    //  Because the value in pchCookieName had no effect on
    //the previously exported API, Ex gets NULL to ensure
    //the behavior doesn't change.
    return InternetGetCookieEx( pchURL, NULL, pchCookieData,
                                pcchCookieData, 0, NULL);
}


INTERNETAPI_(BOOL) InternetSetCookieW(
    LPCWSTR  lpszUrl,
    LPCWSTR  lpszCookieName,
    LPCWSTR  lpszCookieData)
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetSetCookieW",
                     "%wq, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrl, mpCookieName, mpCookieData;

    if (lpszUrl)
    {
        ALLOC_MB(lpszUrl,0,mpUrl);
        if (!mpUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszUrl,mpUrl);
    }
    if (lpszCookieName)
    {
        ALLOC_MB(lpszCookieName,0,mpCookieName);
        if (!mpCookieName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieName,mpCookieName);
    }
    if (lpszCookieData)
    {
        ALLOC_MB(lpszCookieData,0,mpCookieData);
        if (!mpCookieData.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieData,mpCookieData);
    }

    fResult = InternetSetCookieA(mpUrl.psStr, mpCookieName.psStr, mpCookieData.psStr);

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}



BOOL InternalInternetSetCookie(
    LPCSTR  pchURL,
    LPCSTR  pchCookieName,
    LPCSTR  pchCookieData,
    DWORD   dwFlags,
    LPVOID   lpReserved
    )
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetSetCookieA",
                     "%q, %#x, %#x",
                     pchURL,
                     pchCookieName,
                     pchCookieData
                     ));

    char *  pch      = NULL;
    char *  pchStart = NULL;

    int     cch;
    int     cchT;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fResult = FALSE;

    P3PCookieState CS;
    DWORD FlagsWithParam    = INTERNET_COOKIE_EVALUATE_P3P |
                              INTERNET_COOKIE_APPLY_P3P;

    BOOL fPolicy = (dwFlags & INTERNET_COOKIE_EVALUATE_P3P);
    BOOL fDecision = (dwFlags & INTERNET_COOKIE_APPLY_P3P);

    if (!pchURL || !pchCookieData || (fPolicy && fDecision))
    {
        fResult = FALSE;
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if (!GlobalDataInitialized) {
        dwErr = GlobalDataInitialize();
        if (dwErr!= ERROR_SUCCESS) {
            fResult = FALSE;
            goto done;
        }
    }

    pch = (char *) ALLOCATE_FIXED_MEMORY(CCH_COOKIE_MAX);
    if (pch == NULL)
    {
        fResult = FALSE;
        dwErr   = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    pchStart = pch;

    /* The reserved parameter is used for passing in P3P header or decision */
    if (fPolicy) {

        CS.pszP3PHeader = (char*) lpReserved;

        EvaluateCookiePolicy(pchURL,
                             dwFlags & INTERNET_COOKIE_THIRD_PARTY,
                             dwFlags & INTERNET_FLAG_RESTRICTED_ZONE,
                             &CS);
    }
    else if (fDecision) {

        CookieDecision *pDecision = (CookieDecision*) lpReserved;

        CS.fEvaluated = TRUE;
        CS.dwPolicyState = pDecision->dwCookieState;
        CS.fIncSession = ! pDecision->fAllowSession;
        CS.dwEvalMode = GetCookieMainSwitch(pchURL);
    }

    cch = CCH_COOKIE_MAX - 2;  // one for null terminator, one for "="
    if (pchCookieName)
    {
        cchT = strlen(pchCookieName);
        if (cchT > cch)
            cchT = cch;
        memcpy(pch, pchCookieName, cchT);

        pch += cchT;
        cch -= cchT;

        memcpy(pch, "=", 1);
        pch += 1;
        cch -= 1;
    }

    // Ensure null termination upon overflow.
    if (cch <= 0)
        cch = 1;

    // Append the cookie data.
    lstrcpyn (pch, pchCookieData, cch);

    // All IE6 cookies are marked with this flag to distinguish
    // from legacy cookies inherited from past versions.
    if (fPolicy || fDecision)
        dwFlags |= INTERNET_COOKIE_IE6;

    DWORD dwAction = 0;

    if(s_pJar->SetCookie(NULL, pchURL, pchStart, dwFlags,
                         (fPolicy||fDecision) ? &CS : NULL,
                         &dwAction) == COOKIE_FAIL)
    {
        if( dwAction == COOKIE_STATE_REJECT)
            fResult = COOKIE_STATE_REJECT;
        else
            fResult = FALSE;
    }
    else
    {
        /* Return the action taken (accept, downgrade, etc.) */
        fResult = dwAction;
    }

done:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }

    if (pchStart)
        FREE_MEMORY(pchStart);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetSetCookieA(
    LPCSTR  pchURL,
    LPCSTR  pchCookieName,
    LPCSTR  pchCookieData
    )
{
    DWORD dwResult = InternalInternetSetCookie( pchURL, pchCookieName, pchCookieData, 0, NULL);

    // For IE6 InternalInternetSetCookie returns the action taken.
    // When the API fails or cookie is rejected, that would be REJECT which is a positive value.
    // Convert this to FALSE to retain semantics compatible with IE5.5
    return (dwResult==COOKIE_STATE_REJECT) ? FALSE : dwResult;
}

BOOL  seekPolicyRef(const char *pszP3PHeader, char **pszPolicyRef, LPDWORD pdwLength) {

    static const char gszPolicyRefField[] = "policyref";

    *pszPolicyRef = FindNamedValue((char*)pszP3PHeader, gszPolicyRefField, pdwLength);

    return (*pszPolicyRef != NULL);
}

DWORD extractP3PHeader(HTTP_REQUEST_HANDLE_OBJECT *pRequest, char *pszHeader, DWORD *pdwHeaderSize)
{
    const char gszPolicyHeaderName[] = "P3P";
    const int  gszHeaderSize = sizeof(gszPolicyHeaderName)-1;

    DWORD dwIndex = 0;

    return  pRequest->QueryResponseHeader((LPSTR) gszPolicyHeaderName, gszHeaderSize,
                                           pszHeader, pdwHeaderSize, 0, &dwIndex);
}

DWORD getImpliedCookieFlags(P3PCookieState *pState) {

    if (!pState)
        return 0;

    DWORD dwImpliedFlags = 0;

    // "leash" means that the cookie will only be used in 1st party context
    if (pState->dwPolicyState==COOKIE_STATE_LEASH)
        dwImpliedFlags |= INTERNET_COOKIE_IS_RESTRICTED;

    // "downgrade" option forces cookies to session
    if (pState->dwPolicyState==COOKIE_STATE_DOWNGRADE)
        dwImpliedFlags |= INTERNET_COOKIE_IS_SESSION;

    return dwImpliedFlags;
}

BOOL EvaluateCookiePolicy(const char *pszURL, BOOL f3rdParty, BOOL fRestricted,
                          P3PCookieState *pState,
                          const char *pszHostName) {

    char achHostName[INTERNET_MAX_HOST_NAME_LENGTH];

    // If hostname is not given, it will be derived from the URL
    if (!pszHostName) {

        URL_COMPONENTS uc;

        memset(&uc, 0, sizeof(uc));
        uc.dwStructSize = sizeof(URL_COMPONENTS);
        uc.lpszHostName = achHostName;
        uc.dwHostNameLength = sizeof(achHostName);

        InternetCrackUrl(pszURL, 0, 0, &uc);
        pszHostName = achHostName;
    }

    /* For compatibility purposes--
       If registry settings are not available default behavior is:
       ACCEPT all cookies without restrictions */
    pState->dwPolicyState = COOKIE_STATE_ACCEPT;
    pState->fValidPolicy = FALSE;
    pState->fEvaluated = FALSE;
    pState->fIncSession = TRUE;
    pState->dwEvalMode = URLPOLICY_QUERY;

    DWORD dwMainSwitch = fRestricted ?
                           GetCookieMainSwitch(URLZONE_UNTRUSTED) :
                           GetCookieMainSwitch(pszURL);

    if (dwMainSwitch!=URLPOLICY_QUERY)
    {
        pState->dwEvalMode = dwMainSwitch;
        pState->dwPolicyState = (dwMainSwitch==URLPOLICY_ALLOW) ?
                                COOKIE_STATE_ACCEPT :
                                COOKIE_STATE_REJECT;
        return TRUE;
    }

    /* Check prompt history for past decisions made by the user about this website. */
    if (cookieUIhistory.lookupDecision(pszHostName, NULL, & pState->dwPolicyState))
    {
        pState->fValidPolicy = FALSE;
    }
    else
    {
        CCookieSettings *pSettings = NULL;
        CCookieSettings::GetSettings(&pSettings, pszURL, f3rdParty, fRestricted);

        if (pSettings)
        {
            pSettings->EvaluatePolicy(pState);
            pSettings->Release();
        }
    }

    return TRUE;
}

DWORD cacheFlagFromAction(DWORD dwAction) {

    switch (dwAction) {

    case COOKIE_STATE_ACCEPT:       return COOKIE_ACCEPTED_CACHE_ENTRY;
    case COOKIE_STATE_LEASH:        return COOKIE_LEASHED_CACHE_ENTRY;
    case COOKIE_STATE_DOWNGRADE:    return COOKIE_DOWNGRADED_CACHE_ENTRY;
    case COOKIE_STATE_REJECT:       return COOKIE_REJECTED_CACHE_ENTRY;
    }
    return 0;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::ExtractSetCookieHeaders(LPDWORD lpdwHeaderIndex)
{
    DWORD error = ERROR_HTTP_COOKIE_DECLINED;
    P3PCookieState CS;

    char  *pchP3PHeader = (char *) ALLOCATE_ZERO_MEMORY(CCH_COOKIE_MAX);
    char  *pchHeader    = (char *) ALLOCATE_ZERO_MEMORY(CCH_COOKIE_MAX);
    if (pchP3PHeader == NULL || pchHeader == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DWORD cbPolicy = CCH_COOKIE_MAX;

    if (ERROR_SUCCESS == extractP3PHeader(this, pchP3PHeader, &cbPolicy))
    {
        CS.pszP3PHeader = pchP3PHeader;
        InternetIndicateStatus(INTERNET_STATUS_P3P_HEADER,
                               (LPBYTE) CS.pszP3PHeader,
                               cbPolicy+1);
    }
    else
        CS.pszP3PHeader = NULL;

    if (!IsResponseHeaderPresent(HTTP_QUERY_SET_COOKIE))
    {
        error = ERROR_SUCCESS;
        goto CheckForPolicyRef;
    }

    BOOL fRestricted = GetOpenFlags() & INTERNET_FLAG_RESTRICTED_ZONE;

    EvaluateCookiePolicy(GetURL(),
                         Is3rdPartyCookies(),
                         fRestricted,
                         &CS,
                         GetHostName());

    /* NULL index pointer indicates that only P3P policy is evaluated,
       cookies are not processed */
    if (!lpdwHeaderIndex)
        goto SendNotification;

    DWORD iQuery = *lpdwHeaderIndex;
    DWORD cbHeader = CCH_COOKIE_MAX - 1;

    int cPersistent = 0;            /* # of persistent cookies */
    int cSession = 0;               /* # of session cookies */

    /* Array for storing # of cookies subject to each action */
    int cCount[COOKIE_STATE_MAX+1] = { 0 };

    _ResponseHeaders.LockHeaders();

    while ( QueryResponseHeader(
            HTTP_QUERY_SET_COOKIE,
            pchHeader,
            &cbHeader,
            0,
            &iQuery) == ERROR_SUCCESS)
    {
        // All IE6 cookies are marked with this flag to distinguish
        // from legacy cookies inherited from past versions.
        DWORD dwCookieFlags = INTERNET_COOKIE_IE6;

        if (_fBlockedOnPrompt)
            dwCookieFlags |= INTERNET_COOKIE_PROMPT_REQUIRED;

        pchHeader[cbHeader] = 0;

        DWORD dwAction;
        DWORD dwRet = s_pJar->SetCookie(this, GetURL(), pchHeader, dwCookieFlags, &CS, &dwAction);

        /* The cookie flags are passed by reference to the SetCookie() function.
           Upon return the requested flags will have been merged with flags from parsing */
        BOOL fSession = (dwCookieFlags & COOKIE_SESSION);
        fSession ? cSession++ : cPersistent++;

        INET_ASSERT(dwAction<=COOKIE_STATE_MAX);

        if (dwRet == COOKIE_SUCCESS)
        {
            *lpdwHeaderIndex = iQuery;
            error = ERROR_SUCCESS;
            cCount[dwAction]++;
            AddCacheEntryType(cacheFlagFromAction(dwAction));
        }
        else if (dwRet == COOKIE_PENDING)
        {
            error = ERROR_IO_PENDING;

            INET_ASSERT(iQuery != 0);
            *lpdwHeaderIndex = iQuery - 1; // back up and retry this cookie
            _fBlockedOnPrompt = TRUE;
            break;
        }
        else if (dwRet == COOKIE_FAIL)
        {
            /* Only consider cookies blocked because of privacy reasons.
               Other reasons for rejecting the cookie (syntax errors,
               incorrect domain/path etc.) are not reported */
            if (dwAction==COOKIE_STATE_REJECT)
            {
                cCount[dwAction]++;
                AddCacheEntryType(COOKIE_REJECTED_CACHE_ENTRY);
            }
        }

        cbHeader = CCH_COOKIE_MAX - 1;
        _fBlockedOnPrompt = FALSE;
    }

    _ResponseHeaders.UnlockHeaders();

SendNotification:
    // Postpone notifications if user has not answered the prompt yet
    if (error == ERROR_IO_PENDING)
        goto Cleanup;
    else
    {
        IncomingCookieState recvState = {0};

        recvState.cPersistent  = cPersistent;
        recvState.cSession = cSession;

        recvState.cAccepted     = cCount[COOKIE_STATE_ACCEPT];
        recvState.cLeashed      = cCount[COOKIE_STATE_LEASH];
        recvState.cDowngraded   = cCount[COOKIE_STATE_DOWNGRADE];
        recvState.cBlocked      = cCount[COOKIE_STATE_REJECT];

        // performance optimization-- same URL as the request
        recvState.pszLocation   = NULL;

        // Send notification about P3P state
        InternetIndicateStatus(INTERNET_STATUS_COOKIE_RECEIVED,
                               (LPBYTE) & recvState,
                               sizeof(recvState));
    }

CheckForPolicyRef:
    /* If P3P header contains URL of the policy-ref, this information
    must be communicated to WININET clients */
    char *pszPolicyRef = NULL;
    unsigned long dwLength = 0;

    if (CS.pszP3PHeader && seekPolicyRef(CS.pszP3PHeader, &pszPolicyRef, &dwLength))
    {
        pszPolicyRef[dwLength] = '\0';   // create nil-terminated string containing policy-ref URL
        InternetIndicateStatus(INTERNET_STATUS_P3P_POLICYREF,
                               (LPBYTE) pszPolicyRef,
                               dwLength+1);
    }

Cleanup:
    if (pchHeader)
        FREE_MEMORY(pchHeader);

    if (pchP3PHeader)
        FREE_MEMORY(pchP3PHeader);

    return error;
}

INTERNETAPI_(DWORD) InternetSetCookieExW(
    LPCWSTR     lpszUrl,
    LPCWSTR     lpszCookieName,
    LPCWSTR     lpszCookieData,
    DWORD       dwFlags,
    DWORD_PTR   dwReserved
    )
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetSetCookieExW",
                     "%wq, %#x, %#x, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData,
                     dwFlags,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwResult = FALSE;
    MEMORYPACKET mpUrl, mpCookieName, mpCookieData, mpP3PHeader;
    void *lpReserved = (void*) dwReserved;

    if (lpszUrl)
    {
        ALLOC_MB(lpszUrl,0,mpUrl);
        if (!mpUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszUrl,mpUrl);
    }
    if (lpszCookieName)
    {
        ALLOC_MB(lpszCookieName,0,mpCookieName);
        if (!mpCookieName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieName,mpCookieName);
    }
    if (lpszCookieData)
    {
        ALLOC_MB(lpszCookieData,0,mpCookieData);
        if (!mpCookieData.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieData,mpCookieData);
    }

    /* Reserved parameter is used for passing in the P3P header */
    if (dwReserved && (dwFlags & INTERNET_COOKIE_EVALUATE_P3P))
    {
        LPWSTR pwszP3PHeader = (LPWSTR) dwReserved;

        ALLOC_MB(pwszP3PHeader, 0, mpP3PHeader);
        if (!mpP3PHeader.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszP3PHeader, mpP3PHeader);

        lpReserved = mpP3PHeader.psStr;
    }

    dwResult = InternalInternetSetCookie(mpUrl.psStr, mpCookieName.psStr, mpCookieData.psStr, dwFlags, lpReserved);

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(dwResult);
    return dwResult;
}


INTERNETAPI_(DWORD) InternetSetCookieExA(
    LPCSTR      lpszUrl,
    LPCSTR      lpszCookieName,
    LPCSTR      lpszCookieData,
    DWORD       dwFlags,
    DWORD_PTR   dwReserved
    )
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetSetCookieExA",
                     "%wq, %#x, %#x, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData,
                     dwFlags,
                     dwReserved
                     ));

    DWORD dwResult = InternalInternetSetCookie(lpszUrl, lpszCookieName, lpszCookieData, dwFlags, (void*) dwReserved);

    DEBUG_LEAVE_API(dwResult);
    return dwResult;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::CreateCookieHeaderIfNeeded(int *pcCookie)
{
    char *  pchRDomain = NULL;
    char *  pchPath = NULL;
    DWORD   cch;
    int     cchName;
    int     cchValue;
    FILETIME ftCurrent, ftExpire;
    BOOL     fSecure;
    CCookieLocation *pLocation;
    CCookie *pCookie;
    DWORD   dwError = 0;

    DWORD dwMainSwitch =  GetCookieMainSwitch(GetSecurityZone());

    BOOL fNoReplay  = (dwMainSwitch==URLPOLICY_DISALLOW);
    BOOL fReplayAll = (dwMainSwitch==URLPOLICY_ALLOW);

    BOOL f3rdPartyRequest = Is3rdPartyCookies();

    int cCookie     = 0;    // # of cookies added
    int cSuppressed = 0;    // # of cookies suppressed

    char *  pchHeader = (char *) ALLOCATE_FIXED_MEMORY(CCH_COOKIE_MAX);
    if (pchHeader == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    char *pchHeaderStart = pchHeader;

    // remove cookie header if it exists
    // BUGBUG - we are overriding the app. Original cookie code has this.  Don't know why.

    ReplaceRequestHeader(HTTP_QUERY_COOKIE, NULL, 0, 0, 0);

    memset(&ftExpire, 0, sizeof(FILETIME));

    if (!PathAndRDomainFromURL(GetURL(), &pchRDomain, &pchPath, &fSecure, FALSE))
        goto Cleanup;

    fSecure = GetOpenFlags() & INTERNET_FLAG_SECURE;
    GetCurrentGmtTime(&ftCurrent);

    {
        CCookieCriticalSection cs;

        if (!s_pJar->SyncWithCacheIfNeeded())
            goto Cleanup;

        LockHeaders();

        for (pLocation = *s_pJar->GetBucket(pchRDomain); pLocation; pLocation = pLocation->_pLocationNext)
        {
            if (pLocation->IsMatch(pchRDomain, pchPath))
            {
                pLocation->ReadCacheFileIfNeeded();

                for (pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
                {
                    if (IsLegacyCookie(pCookie))
                        convertLegacyCookie(pCookie, pLocation);

                    if (pCookie->CanSend(&ftCurrent, fSecure))
                    {
                        pchHeader = pchHeaderStart;
                        cch = 0;
                        cch += cchName = strlen(pCookie->_pchName);
                        cch += cchValue = strlen(pCookie->_pchValue);
                        if (cchName) cch += 1; // for equal sign

                        if (cch < CCH_COOKIE_MAX)
                        {
                            if (cchName > 0)
                            {
                                memcpy(pchHeader, pCookie->_pchName, cchName);
                                pchHeader += cchName;

                                *pchHeader++ = '=';
                            }

                            if (cchValue > 0)
                            {
                                memcpy(pchHeader, pCookie->_pchValue, cchValue);
                                pchHeader += cchValue;
                            }

                            /* IF the cookie is marked 1st party only,
                               OR cookie feature is not enabled for this zone,
                               suppress the cookie */
                            if (fNoReplay ||
                                (!fReplayAll && f3rdPartyRequest && pCookie->IsRestricted()))
                            {
                                cSuppressed++;
                                continue;
                            }

                            cCookie += 1;

                            AddRequestHeader(HTTP_QUERY_COOKIE,
                                pchHeaderStart,
                                cch,
                                0,
                                HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON);
                        }
                    } // if CanSend
                } // for pCookie
            } // if IsMatch
        } // for

        UnlockHeaders();
    }

Cleanup:

    // Send notification about sent/suppressed in this request
    if (cCookie || cSuppressed)
    {
        OutgoingCookieState sendState = { cCookie, cSuppressed };

        InternetIndicateStatus(INTERNET_STATUS_COOKIE_SENT, (LPBYTE) &sendState, sizeof(sendState));
    }

    if (pchHeaderStart)
        FREE_MEMORY(pchHeaderStart);
    if (pchRDomain)
        FREE_MEMORY(pchRDomain);
    if (pchPath)
        FREE_MEMORY(pchPath);

    if(pcCookie)
    {
        *pcCookie = cCookie;
    }

    return dwError;
}


//  IsDomainLegalCookieDomain  - exported in wininet.w for private use..
//
//  example:  ( "yahoo.com", "www.yahoo.com") -> TRUE
//            ( "com", "www.yahoo.com") -> FALSE
//            ( "0.255.192", "255.0.255.192") -> FALSE
//            ( "255.0.255.192", "255.0.255.192") -> TRUE
BOOLAPI IsDomainLegalCookieDomainA( IN LPCSTR pchDomain, IN LPCSTR pchFullDomain)
{
    BOOL returnValue = FALSE;
    DWORD dwError = ERROR_SUCCESS;

    LPSTR pchReversedDomain = NULL;
    LPSTR pchReversedFullDomain = NULL;
    long iDomainSize, iFullDomainSize;

    if(!pchDomain || IsBadStringPtr( pchDomain, INTERNET_MAX_URL_LENGTH))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto doneIsDomainLegalCookieDomainA;
    }

    if(!pchFullDomain || IsBadStringPtr( pchFullDomain, INTERNET_MAX_URL_LENGTH))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto doneIsDomainLegalCookieDomainA;
    }

    iDomainSize = strlen( pchDomain) + 1;
    iFullDomainSize = strlen( pchFullDomain) + 1;

    pchReversedDomain = new char[ iDomainSize];
    pchReversedFullDomain = new char[ iFullDomainSize];

    if( pchReversedDomain == NULL || pchReversedFullDomain == NULL)
        goto doneIsDomainLegalCookieDomainA;

    memcpy( pchReversedDomain, pchDomain, iDomainSize);
    memcpy( pchReversedFullDomain, pchFullDomain, iFullDomainSize);
    ReverseString( pchReversedDomain);
    ReverseString( pchReversedFullDomain);

    returnValue = IsDomainLegal( pchReversedDomain, pchReversedFullDomain);

doneIsDomainLegalCookieDomainA:
    if( dwError != ERROR_SUCCESS)
        SetLastError( dwError);

    if( pchReversedDomain != NULL)
        delete [] pchReversedDomain;

    if( pchReversedFullDomain != NULL)
        delete [] pchReversedFullDomain;

    return returnValue;
}


BOOLAPI IsDomainLegalCookieDomainW( IN LPCWSTR pwchDomain, IN LPCWSTR pwchFullDomain)
{
    MEMORYPACKET mpDomain;
    ALLOC_MB(pwchDomain,0,mpDomain);
    if (!mpDomain.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(pwchDomain, mpDomain);

    MEMORYPACKET mpFullDomain;
    ALLOC_MB(pwchFullDomain,0,mpFullDomain);
    if (!mpFullDomain.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(pwchFullDomain, mpFullDomain);

    return IsDomainLegalCookieDomainA( mpDomain.psStr, mpFullDomain.psStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\cpevalrule.cxx ===
#include <wininetp.h>
#include "cpevalrule.h"

/*
Evaluation-rule parser
For IE6 the only type of rules accepted are include-exclude rules.
These rules have the format FOO&BAR&!XYZ=r
This translates to "if policy has FOO and BAR but not XYZ, then reject"
Important points:
- Logical rules are enclosed in forward slashes.
- No white spaces allowed in a rule.
*/
CPEvalRule *parseEvalRule(char *pszRule, char **ppEndRule) {

    const char *pch = pszRule;

    /* skip over white space */
    while (isspace(*pch))
        pch++;

    IncludeExcludeRule *pRule = new IncludeExcludeRule();

    /* If no explicit decision is given, we will assume REJECT */
    pRule->setDecision(COOKIE_STATE_REJECT);

    /* This flag keeps track of whether the next symbol is in the
       include-set or exclude-set */
    bool fNegate = false;
    
    do {
        int symindex;
        char achToken[64];

        /* when parsing rules, the tokens are not always seperated by
           white space-- instead the character class (eg. alphabetic,
           numeric, punctuation, etc.) is significant */
        pch = getNextToken(pch, achToken, sizeof(achToken), false);

        char ch = achToken[0];

        if (ch=='!')
            fNegate = true;
        else if (ch=='&')
            fNegate = false;
        else if (ch=='=') {

            int outcome = mapCookieAction(*pch);

            if (outcome==COOKIE_STATE_UNKNOWN) {
                delete pRule;
                pRule = NULL;
            }
            else
                pRule->setDecision(outcome);
            pch++;
            break;
        }
        else if ( (symindex=findSymbol(achToken)) >= 0) {

            /* this is a recognized P3P compact-policy symbol--
               depending on existence of preceding NOT operator,
               modify rule to include or exclude the token */
            if (fNegate)
                pRule->exclude(symindex);
            else
                pRule->include(symindex);
        }
    }
    while (*pch);

    /* indicate end of the rule in optional out parameter */
    if (ppEndRule)
        *ppEndRule = (char*) pch;

    return pRule;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\cpevalrule.h ===
#include "cookiepolicy.h"

/* 
Logical conjunction eval-rule
This evaluation rule is capable of expressing statements such as
"if all of the tokens {X, Y, Z} appear in the policy and none of
the tokens {A, B, C} appear, then prompt"
 */
class IncludeExcludeRule : public CPEvalRule {

public:
    virtual int evaluate(const CompactPolicy &sitePolicy) {

        static const CompactPolicy empty;

        // This rule is triggered IFF:
        // 1. Site policy contains all tokens from the include set, AND
        // 2. Site policy contains no tokens from exclude set
        bool fApplies = (cpInclude & sitePolicy) == cpInclude &&
                        (cpExclude & sitePolicy) == empty;

        // By convention, if the rule does not apply evaluate()
        // function returns the UNKNOWN state
        return fApplies ? decision : COOKIE_STATE_UNKNOWN;
    }

    // These two functions are used to build up the set of tokens
    // that MUST be included/excluded for the rule to apply
    inline void include(int symindex) { cpInclude.addToken(symindex); }
    inline void exclude(int symindex) { cpExclude.addToken(symindex); }

    inline void setDecision(int decision)   { this->decision = decision; }
    inline int  getDecision(void)           { return decision; }

protected:
    CompactPolicy cpInclude;
    CompactPolicy cpExclude;
    unsigned long decision;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\httpp.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httpp.h

Abstract:

    Private master include file for the HTTP API project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

//
//  Local include files.
//

#include "proc.h"
#include "headers.h"

// Beta logging
#ifdef BETA_LOGGING
#define BETA_LOG(stat) \
    {DWORD dw; IncrementUrlCacheHeaderData (CACHE_HEADER_DATA_##stat, &dw);}
#else
#define BETA_LOG(stat) do { } while(0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\httptime.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httptime.h

Abstract:

    This file contains the numerical defines for the date/parsing routines located
    in the httptime.cxx file.

Author:

    Arthur Bierer (arthurbi) 12-Dec-1997

Revision History:

--*/


#ifndef _HTTPTIME_H_
#define _HTTPTIME_H_

#define BASE_DEC 10 // base 10

//
// Date indicies used to figure out what each entry is.
//


#define DATE_INDEX_DAY_OF_WEEK     0

#define DATE_1123_INDEX_DAY        1
#define DATE_1123_INDEX_MONTH      2
#define DATE_1123_INDEX_YEAR       3
#define DATE_1123_INDEX_HRS        4
#define DATE_1123_INDEX_MINS       5
#define DATE_1123_INDEX_SECS       6

#define DATE_ANSI_INDEX_MONTH      1
#define DATE_ANSI_INDEX_DAY        2
#define DATE_ANSI_INDEX_HRS        3
#define DATE_ANSI_INDEX_MINS       4
#define DATE_ANSI_INDEX_SECS       5
#define DATE_ANSI_INDEX_YEAR       6

#define DATE_INDEX_TZ              7

#define DATE_INDEX_LAST            DATE_INDEX_TZ
#define MAX_DATE_ENTRIES           (DATE_INDEX_LAST+1)




//
// DATE_TOKEN's DWORD values used to determine what day/month we're on
//

#define DATE_TOKEN_JANUARY      1
#define DATE_TOKEN_FEBRUARY     2
#define DATE_TOKEN_MARCH        3
#define DATE_TOKEN_APRIL        4
#define DATE_TOKEN_MAY          5
#define DATE_TOKEN_JUNE         6
#define DATE_TOKEN_JULY         7
#define DATE_TOKEN_AUGUST       8
#define DATE_TOKEN_SEPTEMBER    9
#define DATE_TOKEN_OCTOBER      10
#define DATE_TOKEN_NOVEMBER     11
#define DATE_TOKEN_DECEMBER     12       

#define DATE_TOKEN_LAST_MONTH   (DATE_TOKEN_DECEMBER+1)

#define DATE_TOKEN_SUNDAY       0
#define DATE_TOKEN_MONDAY       1
#define DATE_TOKEN_TUESDAY      2                  
#define DATE_TOKEN_WEDNESDAY    3
#define DATE_TOKEN_THURSDAY     4
#define DATE_TOKEN_FRIDAY       5
#define DATE_TOKEN_SATURDAY     6

#define DATE_TOKEN_LAST_DAY     (DATE_TOKEN_SATURDAY+1)
 
#define DATE_TOKEN_GMT          0xFFFFFFFD

#define DATE_TOKEN_LAST         DATE_TOKEN_GMT

#define DATE_TOKEN_ERROR        (DATE_TOKEN_LAST+1)

                            
#endif  // _HTTPTIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\dav.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dav.cxx

Abstract:

    This file contains the implementations of 
        HttpCheckDavCompliance
        HttpCheckDavCollection
        HttpCheckCachedDavStatus
        
    The following functions are exported by this module:

        HttpCheckDavComplianceA
        HttpCheckDavCollectionA
        HttpCheckCachedDavStatusA
        HttpCheckDavComplianceW
        HttpCheckDavCollectionW
        HttpCheckCachedDavStatusW

Author:

    Mead Himelstein (Meadh) 01-Jun-1998

Revision History:


--*/


#include <wininetp.h>
#include "httpp.h"

#undef DAVCACHING //IE5 bug 15696, removing unused code but may add back in later

INTERNETAPI_(BOOL) HttpCheckDavComplianceA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszComplianceToken,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    )

/*++

Routine Description:

    Determines if the resource identified by lpszUrl is DAV compliant (level determined by lpszComplianceToken).
    Returns TRUE in lpfFound if detected. Furthermore, if the token is "1" we also cache todays date
    and whether or not we found the server to be DAV level 1 compliant in the visited links cache.
    
Arguments:

    lpszUrl             - URL to the resource to check for DAV compliance, i.e. "http://webdav/davfood/"

    lpszComplianceToken - DAV compliance class identifier (i.e. "1") BUGBUG MUST NOT CONTAIN INTERNAL WHITE SPACE "foo bar" = bad, "  foo  " = ok
    
    lpfFound            - address of a BOOL to receive TRUE if DAV compliance is found or FALSE otherwise.

    hWnd                - Handle to window for displaying authentication dialog if needed. May be NULL indicating
                          no UI is to be displayed and authentication failures should be quietly handled.
                          
    lpvReserved         - Reserved, must be NULL
    
Return Value:

    TRUE - Success, check lpfFound for results.
    FALSE - failure, GetLastError returns the error code

--*/

{
    BOOL            fRet = TRUE;


    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckDavComplianceA",
                 "%sq, %sq, %#x, %#x, %#x",
                 lpszUrl,
                 lpszComplianceToken,
                 lpfFound,
                 hWnd,
                 lpvReserved
                 ));


    DWORD           dwStatusCode, dwHeaderLength, dwIndex = 0;
    DWORD           dwError = ERROR_SUCCESS, dwStatusLength = sizeof(DWORD);
    HINTERNET       hSession = NULL, hConnection = NULL, hHTTPReq = NULL;
    LPSTR           lpszDavHeader = NULL, lpszRead = NULL, lpszWrite = NULL, lpszVisitedUrl=NULL;
   	LPCACHE_ENTRY_INFO lpCEI = NULL;
    FILETIME        ftNow;
    WORD            wDate, wTime;
    URL_COMPONENTS  ucUrl;

    #define CEI_BUFFER_SIZE 512
    #define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)

    // Debug param checking
    INET_ASSERT(lpszUrl && lpszComplianceToken && lpfFound && !lpvReserved);

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpCheckDavComplianceA",
                     "%s %s %x %x %x",
                     (lpszUrl)?lpszUrl :"NULL Url",
                     (lpszComplianceToken)?lpszComplianceToken :"NULL ComplianceToken",
                     hWnd,
                     lpfFound, lpvReserved
                     ));

    // non-debug param checking
    if (!lpszUrl || !lpszComplianceToken || !lpfFound || lpvReserved) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    *lpfFound = FALSE;
    
    // Build the URL_COMPONENTS struct
	memset(&ucUrl, 0, sizeof(ucUrl));
    ucUrl.dwStructSize = sizeof(ucUrl);
    // non-zero length enables retrieval during CrackUrl
    ucUrl.dwSchemeLength = 1;
	ucUrl.dwHostNameLength = 1;
	ucUrl.dwUrlPathLength = 1;
	if (!InternetCrackUrl(lpszUrl, 0, 0, &ucUrl))
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
    }

    DEBUG_PRINT_API(API,
                    INFO,
                    ("URL Cracked. Host = %q Path = %q\n ",
                    ucUrl.lpszHostName, ucUrl.lpszUrlPath
                    ));

    // Ensures the global vszCurrentUser is set
    GetWininetUserName();   
    INET_ASSERT(vszCurrentUser);
    
    // Perform an OPTIONS call on the server and check for a DAV header
	hSession = InternetOpen(NULL,
						  INTERNET_OPEN_TYPE_PRECONFIG,
						  NULL,
						  NULL,
						  NULL);
	if(!hSession)
	{
		dwError = GetLastError();
	    fRet = FALSE;
		goto cleanup;
	}
	
	hConnection = InternetConnect(hSession,
								   ucUrl.lpszHostName,
								   INTERNET_DEFAULT_HTTP_PORT,
								   (LPCSTR) vszCurrentUser,
								   NULL,
								   INTERNET_SERVICE_HTTP,
								   NULL,
								   NULL);

	if(!hConnection)
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

	hHTTPReq = HttpOpenRequest(hConnection,
							   "OPTIONS",
							   ucUrl.lpszUrlPath,
							   "HTTP/1.0",
							   NULL,
							   NULL,
							   INTERNET_FLAG_PRAGMA_NOCACHE,NULL);

	if(!hHTTPReq)
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

	if (!HttpSendRequest(hHTTPReq,NULL, 0L, NULL, NULL))
	{
		dwError = GetLastError();
		fRet = FALSE;
		goto cleanup;
	}
        

    // Authentication handling
	if (HttpQueryInfo(hHTTPReq,
					  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
					  &dwStatusCode,
					  &dwStatusLength,
					  &dwIndex))
	{
        // fRet = TRUE at this point  
        // If request was denied or proxy auth required and callee has said
        // we can display UI, we put up the InternetErrorDlg and ask for
        // credentials. Otherwise, if dwStatus != success we cache that
        // this resource is not DAV compliant
        if ((hWnd) && ((dwStatusCode == HTTP_STATUS_DENIED) || (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ)))
        {
            DWORD dwRetval;
            DWORD dwAuthTries = 0;
            BOOL fDone;
            fDone = FALSE;
            while ((!fDone) && (dwAuthTries < 3))
            {
                dwRetval = InternetErrorDlg(hWnd,
                                            hHTTPReq,
                                            ERROR_INTERNET_INCORRECT_PASSWORD,
                                            0L,
                                            NULL);
                if (dwRetval == ERROR_INTERNET_FORCE_RETRY) // User pressed ok on credentials dialog
                {   // Resend request, new credentials are cached and will be replayed by HSR()
                	if (!HttpSendRequest(hHTTPReq,NULL, 0L, NULL, NULL))
                	{
                		dwError = GetLastError();
                		fRet = FALSE;
                		goto cleanup;
                	}

                    dwStatusCode = 0;

                	if (!HttpQueryInfo(hHTTPReq,
                					  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
                					  &dwStatusCode,
                					  &dwStatusLength,
                					  &dwIndex))
                	{
                		dwError = GetLastError();
                	    fRet = FALSE;
                	    goto cleanup;
                	}

                    if ((dwStatusCode != HTTP_STATUS_DENIED) && (dwStatusCode != HTTP_STATUS_PROXY_AUTH_REQ))
                    {
                        fDone = TRUE;
                    }
                }
                else    // User pressed cancel from dialog (note ERROR_SUCCESS == ERROR_CANCELLED from IED())
                {
                    fDone = TRUE;
                }
                dwAuthTries++;
            }
        }

        if ((dwStatusCode == HTTP_STATUS_DENIED) || (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ))
        {   // Don't want to cache this (user might have forgotten password or we may not
            // be able to show credential UI)
            goto cleanup;
        }
        else if (dwStatusCode != HTTP_STATUS_OK)
        {   // Either initial request failed for non-auth issue, cache as not compliant
            goto update_cache; //note update_cache NOT cleanup, want to cache this as non compliant
        }
	}
	else
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

    // If we received a DAV header, snag it and check for compliance level
    dwHeaderLength = INTERNET_MAX_URL_LENGTH;
    lpszDavHeader = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, dwHeaderLength);
    if (!lpszDavHeader) 
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    lstrcpy(lpszDavHeader,"DAV");
	if (!HttpQueryInfo(hHTTPReq,
					  HTTP_QUERY_CUSTOM,
					  lpszDavHeader,
					  &dwHeaderLength,
					  &dwIndex))
	{
   		dwError = GetLastError();
	    fRet = FALSE;
	    goto update_cache; //note update_cache NOT cleanup, want to cache this as non compliant

    }
    INET_ASSERT(fRet); // sb TRUE if it made it this far
    
    // Walk the DAV header looking for the token by itself, indicating DAV compliance
    // Note: DAV header is comma delimited, but otherwise we can make no assumptions on formatting.
    // BUGBUG Currently will not work for tokens with internal white space i.e. "foo bar" = bad, " foobar " = good

    lpszRead = lpszDavHeader;
    lpszWrite = lpszDavHeader;
    INET_ASSERT(!*lpfFound);
    INET_ASSERT(fRet);
    while(*lpszRead && !*lpfFound) 
    {
        if (IsWhite(*lpszRead)) 
        {
            while ((*(++lpszRead))&&(IsWhite(*lpszRead)));
        }
        if (*lpszRead) 
        {
            if(*lpszRead == ',') 
            {
                *(lpszRead++) = '\0';
                if (*lpfFound = (lstrcmp(lpszDavHeader, lpszComplianceToken) == 0) ? TRUE:FALSE)
                {   
                    goto update_cache;
                }
                lpszWrite = lpszRead;
                lpszDavHeader = lpszRead;
            }
            else *(lpszWrite++) = *(lpszRead++);    
        }
    }
    *lpszWrite = *lpszRead; // copy the terminator
    INET_ASSERT(!*lpfFound);
    *lpfFound = (lstrcmp(lpszDavHeader, lpszComplianceToken) == 0) ? TRUE:FALSE;    //Final compare on last fragment

update_cache :
#ifdef DAVCACHING //  Commenting out as per bug 15696

    if (lstrcmp("1", lpszComplianceToken) == 0) 
    // Cache if this is a known DAV level 1 server or atleast the last time we tried
    {

        // Update visited links cache
        // We store the cached info as:
        //  CacheEntryInfo.dwExemptDelta(HiWord) = Date DAV discovery was last run
        //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_LEVEL1_STATUS = Is DAV server (*lpfFound)
        //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_COLLECTION_STATUS = Is DAV collection (set in HttpCheckDavCollection)

        // Assemble the URL to the visited links container "VISITED: username@URL"
        DWORD cbNeededBuf = lstrlen("Visited: ") + lstrlen(vszCurrentUser) + lstrlen(lpszUrl) + 32;
        lpszVisitedUrl = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, cbNeededBuf);
    	if (!lpszVisitedUrl)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        lstrcpy(lpszVisitedUrl, "Visited: "); // For compatibility with urlhist.c visited URLs
        lstrcat(lpszVisitedUrl, vszCurrentUser);
        lstrcat(lpszVisitedUrl, "@");
        lstrcat(lpszVisitedUrl, lpszUrl);

        lpCEI = (LPCACHE_ENTRY_INFO) ALLOCATE_MEMORY(LMEM_FIXED, CEI_BUFFER_SIZE);
    	if (!lpCEI)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        GetSystemTimeAsFileTime(&ftNow);
        if (!FileTimeToDosDateTime(&ftNow,
                                   &wDate,
                                   &wTime
                                   ))
        {                          
            INET_ASSERT(FALSE); // Should "never" hit this
            goto cleanup;                              
        }

        // Stuff our 16-bit Date into the upper 16-bits of dwExemptDelta
        lpCEI->dwExemptDelta = (DWORD)wDate <<16;

        // Set the DAV_LEVEL1_STATUS_BIT if the resource was found compliant above
        if (*lpfFound)
        {
            lpCEI->dwExemptDelta |= (DWORD) DAV_LEVEL1_STATUS;
        }
    

        if (!SetUrlCacheEntryInfo (lpszVisitedUrl, 
	  	    					   lpCEI,
		        				   CACHE_ENTRY_EXEMPT_DELTA_FC
			        				))
        {
	       	if (GetLastError() == ERROR_FILE_NOT_FOUND)
	   	    // No existing cache entry, so create one and try again
    	    {
	            FILETIME ftNone;
                if (CommitUrlCacheEntry (lpszVisitedUrl,
                                         NULL,
                                         ftNone,
                                         ftNone,
                                         0,
                                         NULL,
                                         0,
                                         NULL,
                                         0
                                         ))
                {
                    // Entry is now created, so try one more time
                    SetUrlCacheEntryInfo (lpszVisitedUrl, 
	       			    			      lpCEI,
                		    			  CACHE_ENTRY_EXEMPT_DELTA_FC
			               	    		 );
                }
  	    	}
        }
    }

#endif //DAVCACHING
    
cleanup:    
    // Free memory
    if (lpCEI) FREE_MEMORY (lpCEI);
    if (lpszVisitedUrl) FREE_MEMORY (lpszVisitedUrl);
    if (lpszDavHeader != NULL) FREE_MEMORY(lpszDavHeader);

    // Close the handles
	if (hHTTPReq) InternetCloseHandle(hHTTPReq);
	if (hConnection) InternetCloseHandle(hConnection);

    SetLastError(dwError);


    DEBUG_LEAVE_API(fRet);
	return fRet;
}


INTERNETAPI_(BOOL) HttpCheckDavCollectionA(
    IN LPCSTR lpszUrl,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    )

/*++

Routine Description:

    Checks the resource at lpszUrl to see if it is a DAV collection. Typically, callee has 
    already called HttpCheckDavCompliance or HttpCheckCachedDavStatus to determine 
    the resource supports DAV level 1, although it is not necessary to do so. Note this method
    will blindly attempt either way.
    
Arguments:

    lpszUrl             - URL of the resource to check

    lpfFound            - address of a BOOL to receive TRUE if DAV compliance is found or FALSE otherwise.

    hWnd                - Handle to window for displaying authentication dialog if needed. May be NULL indicating
                          no UI is to be displayed and authentication failures should be quietly handled.
                          
    lpvReserved         - Reserved, must be NULL
    
Return Value:

    TRUE - Success, check lpfFound for results.
    FALSE - failure, GetLastError returns the error code

--*/

{
    #define CEI_BUFFER_SIZE 512
    #define READ_BUFFER_SIZE 4096
    #define READ_BUFFER_AVAILABLE  (READ_BUFFER_SIZE - sizeof(LPSTR))
    BOOL            fRet = TRUE, fDone=FALSE;

    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckDavCollectionA",
                 "%sq, %#x, %#x, %#x",
                 lpszUrl,
                 lpfFound,
                 hWnd,
                 lpvReserved
                 ));


    DWORD           dwRead=0, dwBuffers =1;
    DWORD           dwStatusCode, dwIndex = 0;
    DWORD           dwError = ERROR_SUCCESS, dwStatusLength = sizeof(DWORD);
    HINTERNET       hSession = NULL, hConnection = NULL, hHTTPReq = NULL;
    LPSTR           lpszVisitedUrl=NULL, lpszXmlResponse=NULL, lpszBufferHead=NULL;
   	LPCACHE_ENTRY_INFO lpCEI = NULL;
    FILETIME        ftNow;
    WORD            wDate, wTime;
    URL_COMPONENTS  ucUrl;
    char lpszHeaders[] = "Depth:0\r\n";

    // Debug param checking
    INET_ASSERT(lpszUrl && lpfFound && !lpvReserved);

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpCheckDavCollectionA",
                     "%s %x %x",
                     (lpszUrl)?lpszUrl :"NULL Url",
                     lpfFound, lpvReserved
                     ));

    // non-debug param checking
    if (!lpszUrl || !lpfFound || lpvReserved) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    *lpfFound = FALSE;
    
    // Build the URL_COMPONENTS struct
	memset(&ucUrl, 0, sizeof(ucUrl));
    ucUrl.dwStructSize = sizeof(ucUrl);
    // non-zero length enables retrieval during CrackUrl
    ucUrl.dwSchemeLength = 1;
	ucUrl.dwHostNameLength = 1;
	ucUrl.dwUrlPathLength = 1;
	if (!InternetCrackUrl(lpszUrl, 0, 0, &ucUrl))
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
    }

    INET_ASSERT(ucUrl.lpszHostName && ucUrl.lpszUrlPath);
    DEBUG_PRINT_API(API,
                    INFO,
                    ("URL Cracked. Host = %q Path = %q\n ",
                    ucUrl.lpszHostName, ucUrl.lpszUrlPath
                    ));

    // Ensures the global vszCurrentUser is set
    GetWininetUserName();   
    INET_ASSERT(vszCurrentUser);
    
    // Build the XML request body for a PROPFIND
    //<?xml version='1.0' ?>
    //<?xml:namespace ns='DAV:' prefix='D' ?>
    //<D:propfind>
    //  <D:prop>
    //    <D:resourcetype/>
    //  </D:prop>
    //</D:propfind>    
    
    #define REQUEST_RESOURCE_TYPE   "\
                                    <?xml version='1.0' ?>\r\n \
                                    <?xml:namespace ns='DAV:' prefix='D' ?>\r\n \
                                    <D:propfind>\r\n \
                                        <D:prop>\r\n \
                                            <D:resourcetype/>\r\n \
                                        </D:prop>\r\n \
                                    </D:propfind>\r\n"
    DWORD cbReqSize;
    cbReqSize = lstrlen(REQUEST_RESOURCE_TYPE);
                                    
    LPCSTR lpszXmlRequest;
    lpszXmlRequest = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, cbReqSize);
    
    // Perform a PROPFIND call, looking for resourcetype = DAV:collection
    hSession = InternetOpen(NULL,
						  INTERNET_OPEN_TYPE_PRECONFIG,
						  NULL,
						  NULL,
						  NULL);
	if(!hSession)
	{
		dwError = GetLastError();
	    fRet = FALSE;
		goto cleanup;
	}
	
	hConnection = InternetConnect(hSession,
								   ucUrl.lpszHostName,
								   INTERNET_DEFAULT_HTTP_PORT,
								   (LPCSTR) vszCurrentUser,
								   NULL,
								   INTERNET_SERVICE_HTTP,
								   NULL,
								   NULL);

	if(!hConnection)
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

	hHTTPReq = HttpOpenRequest(hConnection,
							   "PROPFIND",
							   ucUrl.lpszUrlPath,
							   "HTTP/1.0",
							   NULL,
							   NULL,
							   INTERNET_FLAG_PRAGMA_NOCACHE,NULL);

	if(!hHTTPReq)
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

	if (!HttpAddRequestHeaders(hHTTPReq, lpszHeaders, -1L, HTTP_ADDREQ_FLAG_ADD))
	{
		dwError = GetLastError();
		fRet = FALSE;
		goto cleanup;
	}

	if (!HttpSendRequest(hHTTPReq,NULL, 0L, (LPVOID)lpszXmlRequest, cbReqSize))
	{
		dwError = GetLastError();
		fRet = FALSE;
		goto cleanup;
	}
        
	if (HttpQueryInfo(hHTTPReq,
					  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
					  &dwStatusCode,
					  &dwStatusLength,
					  &dwIndex))
	{
        // fRet = TRUE at this point  
        // If request was denied or proxy auth required and callee has said
        // we can display UI, we put up the InternetErrorDlg and ask for
        // credentials. Otherwise, if dwStatus != success we cache that
        // this resource is not DAV compliant
        if ((hWnd) && ((dwStatusCode == HTTP_STATUS_DENIED) || (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ)))
        {
            DWORD dwRetval;
            BOOL fDone;
            fDone = FALSE;
            while (!fDone)
            {
                dwRetval = InternetErrorDlg(hWnd,
                                            hHTTPReq,
                                            ERROR_INTERNET_INCORRECT_PASSWORD,
                                            0L,
                                            NULL);
                if (dwRetval == ERROR_INTERNET_FORCE_RETRY) // User pressed ok on credentials dialog
                {   // Resend request, new credentials are cached and will be replayed by HSR()
                	if (!HttpSendRequest(hHTTPReq,NULL, 0L, NULL, NULL))
                	{
                		dwError = GetLastError();
                		fRet = FALSE;
                		goto cleanup;
                	}

                    dwStatusCode = 0;

                	if (!HttpQueryInfo(hHTTPReq,
                					  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
                					  &dwStatusCode,
                					  &dwStatusLength,
                					  &dwIndex))
                	{
                		dwError = GetLastError();
                	    fRet = FALSE;
                	    goto cleanup;
                	}

                    if ((dwStatusCode != HTTP_STATUS_DENIED) && (dwStatusCode != HTTP_STATUS_PROXY_AUTH_REQ))
                    {
                        fDone = TRUE;
                    }
                }
                else    // User pressed cancel from dialog (note ERROR_SUCCESS == ERROR_CANCELLED from IED())
                {
                    fDone = TRUE;
                }
            }
        }

        if ((dwStatusCode == HTTP_STATUS_DENIED) || (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ))
        {   // Don't want to cache this (user might have forgotten password or we may not
            // be able to show credential UI)
            goto cleanup;
        }
        else if (dwStatusCode != HTTP_STATUS_OK)
        {   // Either initial request failed for non-auth issue, cache as not compliant
            goto update_cache; //note update_cache NOT cleanup, want to cache this as non compliant
        }
	}
	else
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

    // Note, what we are doing here is allocating a single page of memory and reserving
    // the first sizeof(LPSTR) bytes to point to the next buffer fragment if required,
    // and so on until the last buffer fragment has NULL at the dwPtrOffset

    lpszBufferHead = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, READ_BUFFER_SIZE);
    if (!lpszBufferHead)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

	memset(lpszBufferHead, 0, READ_BUFFER_SIZE);
	LPSTR lpNext;
    lpNext=lpszBufferHead+sizeof(LPSTR); // Jump over the next buffer ptr space when writing data
    while(!fDone)
    {
        if (!InternetReadFile(hHTTPReq,
                              lpNext,
                              READ_BUFFER_AVAILABLE,
                              &dwRead))
    	{
    		dwError = GetLastError();
    	    fRet = FALSE;
    	    goto cleanup;
    	}
        else 
        {
            if (dwRead < READ_BUFFER_AVAILABLE)
            {
                fDone = TRUE;
            }
            else 
            {
                dwBuffers++;
                *((LPSTR*)lpNext+READ_BUFFER_AVAILABLE) = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, READ_BUFFER_SIZE);
                lpNext = *((LPSTR*)lpNext+READ_BUFFER_AVAILABLE);
                if (!lpNext) 
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanup;
                }
            	memset(lpNext, 0, READ_BUFFER_SIZE);
            }
            
        }
                          
    }

    // Done reading response, time to parse it
    
    
update_cache :

#ifdef DAVCACHING // commenting out as per bug 15696

    if (TRUE) 
    // Cache if this is a known DAV level 1 server or atleast the last time we tried
    {

        // Update visited links cache
        // We store the cached info as:
        //  CacheEntryInfo.dwExemptDelta(HiWord) = Date DAV discovery was last run
        //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_LEVEL1_STATUS = Is DAV server (*lpfFound)
        //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_COLLECTION_STATUS = Is DAV collection (set in HttpCheckDavCollection)

        // Assemble the URL to the visited links container "VISITED: username@URL"
        DWORD cbNeededBuf = lstrlen("Visited: ") + lstrlen(vszCurrentUser) + lstrlen(lpszUrl) + 32;
        lpszVisitedUrl = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, cbNeededBuf);
    	if (!lpszVisitedUrl)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        lstrcpy(lpszVisitedUrl, "Visited: "); // For compatibility with urlhist.c visited URLs
        lstrcat(lpszVisitedUrl, vszCurrentUser);
        lstrcat(lpszVisitedUrl, "@");
        lstrcat(lpszVisitedUrl, lpszUrl);

        lpCEI = (LPCACHE_ENTRY_INFO) ALLOCATE_MEMORY(LMEM_FIXED, CEI_BUFFER_SIZE);
    	if (!lpCEI)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        GetSystemTimeAsFileTime(&ftNow);
        if (!FileTimeToDosDateTime(&ftNow,
                                   &wDate,
                                   &wTime
                                   ))
        {                                   
            INET_ASSERT(FALSE); // Should "never" hit this
            goto cleanup;                              
        }

        // Stuff our 16-bit Date into the upper 16-bits of dwExemptDelta
        lpCEI->dwExemptDelta = (DWORD)wDate <<16;

        // Set the DAV_LEVEL1_STATUS_BIT if the resource was found compliant above
        if (*lpfFound) 
        {
            lpCEI->dwExemptDelta |= (DWORD) DAV_LEVEL1_STATUS;
        }
    

        if (!SetUrlCacheEntryInfo (lpszVisitedUrl, 
	  	    					   lpCEI,
		        				   CACHE_ENTRY_EXEMPT_DELTA_FC
			        				))
        {
	       	if (GetLastError() == ERROR_FILE_NOT_FOUND)
	   	    // No existing cache entry, so create one and try again
    	    {
	            FILETIME ftNone;
                if (CommitUrlCacheEntry (lpszVisitedUrl,
                                         NULL,
                                         ftNone,
                                         ftNone,
                                         0,
                                         NULL,
                                         0,
                                         NULL,
                                         0
                                         ))
                {
                    // Entry is now created, so try one more time
                    SetUrlCacheEntryInfo (lpszVisitedUrl, 
	       			    			      lpCEI,
                		    			  CACHE_ENTRY_EXEMPT_DELTA_FC
			               	    		 );
                }
  	    	}
        }
    }
#endif //DAVCACHING
    
cleanup:    
    // Free memory
    // Walk buffer chain
    if (lpszBufferHead)
    {
        lpNext = (LPSTR)*(lpszBufferHead+READ_BUFFER_AVAILABLE);
        FREE_MEMORY(lpszBufferHead);
        while (lpNext)
        {
            lpszBufferHead = lpNext;
            lpNext = (LPSTR)*(lpszBufferHead+READ_BUFFER_AVAILABLE);
            FREE_MEMORY(lpszBufferHead);
        }
    }
    if (lpszXmlRequest) FREE_MEMORY(lpszXmlRequest);
    if (lpCEI) FREE_MEMORY (lpCEI);
    if (lpszVisitedUrl) FREE_MEMORY (lpszVisitedUrl);

    // Close the handles
	if (hHTTPReq) InternetCloseHandle(hHTTPReq);
	if (hConnection) InternetCloseHandle(hConnection);

    SetLastError(dwError);
    DEBUG_LEAVE_API(fRet);
	return fRet;
}

#ifdef DAVCACHING // commenting out as per bug 15696
INTERNETAPI_(BOOL) HttpCheckCachedDavStatusA(
    IN LPCSTR lpszUrl,
    IN OUT LPDWORD lpdwStatus
    )

/*++

Routine Description:

    Checks if there is cached DAV information for this site or if detection is required, After a successfull call,
    *lpdwStatus will contain a bitfield as described in arguments below.

    Checks HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\DaysBetweenDavDetection for time in days
    to pass between performing detection. If this key is missing, a default of 10 is used.

Arguments:

    lpszUrl             - Url of the resource to check

    lpdwStatus          - address of a DWORD (which must contain zero initially!!) that on return may contain a
                          combination of the following staus bits:
        DAV_LEVEL1_STATUS       - If this bit is set, the site is known to support DAV level 1
        DAV_COLLECTION_STATUS   - If this bit is set, the resource is a collection.
        DAV_DETECTION_REQUIRED  - Either no information is available or information is stale and detection should be performed. 

                          
Return Value:

    TRUE - Success, check lpdwStatus for results.
    FALSE - failure, GetLastError returns the error code

--*/

{
    BOOL            fRet = TRUE;

    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckCachedDavStatusA",
                 "%sq, %#x",
                 lpszUrl,
                 lpdwStatus
                 ));


    DWORD           dwError;
   	LPCACHE_ENTRY_INFO lpCEI = NULL;
    FILETIME        ftNow, ftNext, ftWork;
    WORD            wDate;
    LPSTR           lpszVisitedUrl=NULL;
    DWORD           cbCEI = 512, dwDays = 0;
    #define DEFAULT_DAV_DAYS 10
    #define FILE_SEC_TICKS (10000000)
    // SECS PER DAY
    #define DAY_SECS (24*60*60)
    // Debug param checking
    INET_ASSERT(lpszUrl && lpdwStatus && (*lpdwStatus==0));

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpCheckCachedDavStatusA",
                     "%s %x %x",
                     (lpszUrl)?lpszUrl :"NULL Url",
                     lpdwStatus,
                     *lpdwStatus
                     ));

    // non-debug param checking
    if (!lpszUrl || !lpdwStatus || (*lpdwStatus != 0)) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    // Ensures the global vszCurrentUser is set
    GetWininetUserName();   
    INET_ASSERT(vszCurrentUser);

    // Check visited links cache
    // We store the cached info as:
    //  CacheEntryInfo.dwExemptDelta(HiWord) = Date DAV discovery was last run
    //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_LEVEL1_STATUS = Is DAV server (*lpfFound)
    //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_COLLECTION_STATUS = Is DAV collection (set in HttpCheckDavCollection)

    // Assemble the URL to the visited links container "VISITED: username@URL"
    DWORD cbNeededBuf = lstrlen("Visited: ") + lstrlen(vszCurrentUser) + lstrlen(lpszUrl) + 32;
    lpszVisitedUrl = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, cbNeededBuf);
	if (!lpszVisitedUrl)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    lstrcpy(lpszVisitedUrl, "Visited: "); // For compatibility with urlhist.c visited URLs
    lstrcat(lpszVisitedUrl, vszCurrentUser);
    lstrcat(lpszVisitedUrl, "@");
    lstrcat(lpszVisitedUrl, lpszUrl);

    lpCEI = (LPCACHE_ENTRY_INFO) ALLOCATE_MEMORY(LMEM_FIXED, cbCEI);
	if (!lpCEI)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if (!GetUrlCacheEntryInfo (lpszVisitedUrl, 
  	    					   lpCEI,
	        				   &cbCEI
		        				))
    {
       	if (GetLastError() == ERROR_FILE_NOT_FOUND)
   	    // No existing cache entry, so return DAV_DETECTION_REQUIRED
	    {
            *lpdwStatus = DAV_DETECTION_REQUIRED;
            goto cleanup;
    
	    }
	    else
	    {
	        dwError = GetLastError();
	        fRet = FALSE;
	        goto cleanup;
	    }
    }

    // Get registry setting for # of days between detection or use default if not found
    if ((dwError = InternetReadRegistryDword("DaysBetweenDavDetection", &dwDays)) != ERROR_SUCCESS)
    {
        dwDays = DEFAULT_DAV_DAYS;
    }

    // Get the last date we checked this URL
    wDate = HIWORD(lpCEI->dwExemptDelta);
    DosDateTimeToFileTime(wDate, WORD(0), &ftWork);

    _int64 i64Base;

    i64Base = (((_int64)ftWork.dwHighDateTime) << 32) | ftWork.dwLowDateTime;
    i64Base /= FILE_SEC_TICKS;
    i64Base /= DAY_SECS;
    i64Base += dwDays;
    i64Base *= FILE_SEC_TICKS;
    i64Base *= DAY_SECS;
    ftNext.dwHighDateTime = (DWORD) ((i64Base >> 32) & 0xFFFFFFFF);
    ftNext.dwLowDateTime = (DWORD) (i64Base & 0xFFFFFFFF);

    GetSystemTimeAsFileTime(&ftNow);
    if (CompareFileTime(ftNow, ftNext) >= 0)    // If Now >= Next detect date
    {
        *lpdwStatus = DAV_DETECTION_REQUIRED;
    }

    *lpdwStatus |= LOWORD(lpCEI->dwExemptDelta);
    dwError = ERROR_SUCCESS;
    
cleanup:    
    // Free memory
    if (lpCEI) FREE_MEMORY (lpCEI);
    if (lpszVisitedUrl) FREE_MEMORY (lpszVisitedUrl);

    SetLastError(dwError);
    DEBUG_LEAVE_API(fRet);
	return fRet;
}

#endif //DAVCACHING


INTERNETAPI_(BOOL) HttpCheckDavComplianceW(
    IN LPCWSTR lpszUrlW,
    IN LPCWSTR lpszComplianceTokenW,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    )

/*++

Routine Description:

    Determines the level of DAV compliance of the server. Currently just checks for level 1
    compliance and returns TRUE in lpfFound if detected.
    
Arguments:

    lpszServer          - name of server to check

    lpszPath            - path to resource on the server to check

    lpszComplianceToken - DAV compliance class identifier (i.e. "1") BUGBUG MUST NOT CONTAIN INTERNAL WHITE SPACE "foo bar" = bad, "  foo  " = ok
    
    lpfFound            - address of a BOOL to receive TRUE if DAV compliance is found or FALSE otherwise.

    hWnd                - Handle to window for displaying authentication dialog if needed. May be NULL indicating
                          no UI is to be displayed and authentication failures should be quietly handled.
                          
    lpvReserved         - Reserved, must be NULL
    
Return Value:

    TRUE - Success, check lpfFound for results.
    FALSE - failure, GetLastError returns the error code

--*/

{

    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckDavComplianceW",
                 "%wq, %wq, %#x, %#x, %#x",
                 lpszUrlW,
                 lpszComplianceTokenW,
                 lpfFound,
                 hWnd,
                 lpvReserved
                 ));

    MEMORYPACKET mpUrlA, mpComplianceTokenA;
    BOOL            fRet = TRUE;
    DWORD           dwError = ERROR_SUCCESS;
    
    // Debug param checking
    INET_ASSERT(lpszUrlW && lpszComplianceTokenW && lpfFound && !lpvReserved);

    // non-debug param checking
    if (!lpszUrlW || !lpszComplianceTokenW || !lpfFound || lpvReserved) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    ALLOC_MB(lpszUrlW, 0, mpUrlA);
    if (!mpUrlA.psStr)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
	    fRet = FALSE;
	    goto cleanup;
    }
    UNICODE_TO_ANSI(lpszUrlW, mpUrlA);

    //  MAKE_ANSI(lpszComplianceTokenW, 0, mpComplianceTokenA);
    ALLOC_MB(lpszComplianceTokenW, 0, mpComplianceTokenA);
    if (!mpComplianceTokenA.psStr)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
	    fRet = FALSE;
	    goto cleanup;
    }
    UNICODE_TO_ANSI(lpszComplianceTokenW, mpComplianceTokenA);

    fRet =  HttpCheckDavComplianceA(mpUrlA.psStr, mpComplianceTokenA.psStr, lpfFound, hWnd, lpvReserved);

cleanup:    
    DEBUG_LEAVE_API(fRet);
    return(fRet);


}


#ifdef DAVCACHING //commenting out as per bug 15696
INTERNETAPI_(BOOL) HttpCheckCachedDavStatusW(
    IN LPCWSTR lpszUrlW,
    IN OUT LPDWORD lpdwStatus
    )

/*++

Routine Description:

    Checks if there is cached DAV information for this site or if detection is required, 
Arguments:

    lpszUrl             - Url of the resource to check

    lpdwStatus          - address of a DWORD (which must contain zero initially!!) that on return may contain a
                          combination of the following staus bits:
        DAV_LEVEL1_STATUS       - If this bit is set, the site is known to support DAV level 1
        DAV_COLLECTION_STATUS   - If this bit is set, the resource is a collection.
        DAV_DETECTION_REQUIRED  - Either no information is available or information is stale and detection should be performed. 

                          
Return Value:

    TRUE - Success, check lpdwStatus for results.
    FALSE - failure, GetLastError returns the error code

--*/

{

    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckCachedDavStatusW",
                 "%wq, %#x",
                 lpszUrlW,
                 lpdwStatus
                 ));

    MEMORYPACKET mpUrlA;
    BOOL            fRet = TRUE;
    DWORD           dwError = ERROR_SUCCESS;
    // Debug param checking
    INET_ASSERT(lpszUrlW && lpdwStatus && (*lpdwStatus==0));

    // non-debug param checking
    if (!lpszUrlW || !lpdwStatus || (*lpdwStatus!=0)) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    ALLOC_MB(lpszUrlW, 0, mpUrlA);
    if (!mpUrlA.psStr)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
	    fRet = FALSE;
	    goto cleanup;
    }
    UNICODE_TO_ANSI(lpszUrlW, mpUrlA);

    fRet = HttpCheckCachedDavStatusA(mpUrlA.psStr, lpdwStatus);

cleanup:
    DEBUG_LEAVE_API(fRet);
    return(fRet);

}
#endif //DAVCACHING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\headers.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    headers.cxx

Abstract:

    Methods for HTTP_HEADERS (..\inc\http.hxx) classes

    Contents:

        HEADER_STRING::CreateHash
        HTTP_HEADERS::HeaderMatch
        HTTP_HEADERS::AllocateHeaders
        HTTP_HEADERS::FreeHeaders
        HTTP_HEADERS::CopyHeaders
        HTTP_HEADERS::FindFreeSlot
        HTTP_HEADERS::AddHeader
        HTTP_HEADERS::ReplaceHeader
        HTTP_HEADERS::FindHeader
        HTTP_HEADERS::QueryRawHeaders
        HTTP_HEADERS::AddRequest
        HTTP_HEADERS::ModifyRequest
        HTTP_HEADERS::SetRequestVersion
        HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer
        HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader
        HTTP_REQUEST_HANDLE_OBJECT::AddInternalResponseHeader
        HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::QueryResponseVersion
        HTTP_REQUEST_HANDLE_OBJECT::QueryStatusCode
        HTTP_REQUEST_HANDLE_OBJECT::QueryStatusText
        HTTP_REQUEST_HANDLE_OBJECT::QueryRawResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::RemoveAllRequestHeadersByName
        HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders
        MapHttpMethodType
        CreateEscapedUrlPath
        (CalculateHashNoCase)
Author:

    Richard L Firth (rfirth) 20-Dec-1995

Revision History:

    20-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private manifests
//

#define DATE_AND_TIME_STRING_BUFFER_LENGTH  128

#ifdef COMPRESSED_HEADERS

typedef struct tagHEADER_MAP {

    LPSTR   lpszLongHeader;
    DWORD   dwLenLongHeader;
    LPSTR   lpszShortHeader;
    DWORD   dwLenShortHeader;

}
HEADER_MAP;


// Sorted Compression map

HEADER_MAP rgsHeaderMap[] = {
{"",                    0,                                 "",    0              },
{"Accept",             sizeof("Accept")-1,               "#A", sizeof("#A")-1},
{"Accept-Charset",     sizeof("Accept-Charset")-1,       "#B", sizeof("#B")-1},
{"Accept-Encoding",    sizeof("Accept-Encoding")-1,      "#C", sizeof("#C")-1},
{"Accept-Language",    sizeof("Accept-Language")-1,      "#D", sizeof("#D")-1},
{"Accept-Ranges",      sizeof("Accept-Ranges")-1,        "#E", sizeof("#E")-1},
{"Age",                sizeof("Age")-1,                  "#F", sizeof("#F")-1},
{"Allow",              sizeof("Allow")-1,                "#G", sizeof("#G")-1},
{"Authorization",      sizeof("Authorization")-1,        "#H", sizeof("#H")-1},
{"Cache-Control",      sizeof("Cache-Control")-1,        "#I", sizeof("#I")-1},
{"Connection",         sizeof("Connection")-1,           "#J", sizeof("#J")-1},
{"Content-Base",       sizeof("Content-Base")-1,         "#K", sizeof("#K")-1},
{"Content-Encoding",   sizeof("Content-Encoding")-1,     "#L", sizeof("#L")-1},
{"Content-Language",   sizeof("Content-Language")-1,     "#M", sizeof("#M")-1},
{"Content-Length",     sizeof("Content-Length")-1,       "#N", sizeof("#N")-1},
{"Content-Location",   sizeof("Content-Location")-1,     "#O", sizeof("#O")-1},
{"Content-MD5",        sizeof("Content-MD5")-1,          "#P", sizeof("#P")-1},
{"Content-Range",      sizeof("Content-Range")-1,        "#Q", sizeof("#Q")-1},
{"Content-Type",       sizeof("Content-Type")-1,         "#R", sizeof("#R")-1},

{"Cookie",             sizeof("Cookie")-1,               "#5", sizeof("#5")-1},

{"Date",               sizeof("Date")-1,                 "#S", sizeof("#S")-1},
{"ETag",               sizeof("ETag")-1,                 "#T", sizeof("#T")-1},
{"Expires",            sizeof("Expires")-1,              "#U", sizeof("#U")-1},
{"From",               sizeof("From")-1,                 "#V", sizeof("#V")-1},
{"Host",               sizeof("Host")-1,                 "#W", sizeof("#W")-1},
{"If-Modified-Since",  sizeof("If-Modified-Since")-1,    "#X", sizeof("#X")-1},
{"If-Match",           sizeof("If-Match")-1,             "#Y", sizeof("#Y")-1},
{"If-None-Match",      sizeof("If-None-Match")-1,        "#Z", sizeof("#Z")-1},
{"If-Range",           sizeof("If-Range")-1,             "#a", sizeof("#a")-1},
{"If-Unmodified-Since",sizeof("If-Unmodified-Since")-1,  "#b", sizeof("#b")-1},
{"Last-Modified",      sizeof("Last-Modified")-1,        "#c", sizeof("#c")-1},
{"Location",           sizeof("Location")-1,             "#d", sizeof("#d")-1},
{"Max-Forwards",       sizeof("Max-Forwards")-1,         "#e", sizeof("#e")-1},
{"Pragma",             sizeof("Pragma")-1,               "#f", sizeof("#f")-1},
{"Proxy-Authenticate", sizeof("Proxy-Authenticate")-1,   "#g", sizeof("#g")-1},
{"Proxy-Authorization",sizeof("Proxy-Authorization")-1,  "#h", sizeof("#h")-1},
{"Public",             sizeof("Public")-1,               "#I", sizeof("#I")-1},
{"Range",              sizeof("Range")-1,                "#j", sizeof("#j")-1},
{"Referer",            sizeof("Referer")-1,              "#k", sizeof("#k")-1},
{"Retry-After",        sizeof("Retry-After")-1,          "#l", sizeof("#l")-1},
{"Server",             sizeof("Server")-1,               "#m", sizeof("#m")-1},
{"Transfer-Encoding",  sizeof("Transfer-Encoding")-1,    "#n", sizeof("#n")-1},

{"UA-color",           sizeof("UA-color")-1,             "#1", sizeof("#1")-1},
{"UA-cpu",             sizeof("UA-cpu")-1,               "#2", sizeof("#2")-1},
{"UA-OS",              sizeof("UA-OS")-1,                "#3", sizeof("#3")-1},
{"UA-pixels",          sizeof("UA-pixels")-1,            "#4", sizeof("#4")-1},

{"Upgrade",            sizeof("Upgrade")-1,              "#o", sizeof("#o")-1},
{"User-Agent",         sizeof("User-Agent")-1,           "#p", sizeof("#p")-1},
{"Vary",               sizeof("Vary")-1,                 "#q", sizeof("#q")-1},
{"Via",                sizeof("Via")-1,                  "#r", sizeof("#r")-1},
{"Warning",            sizeof("Warning")-1,              "#s", sizeof("#s")-1},
{"WWW-Authenticate",   sizeof("WWW-Authenticate")-1,     "#t", sizeof("#t")-1}
};


#endif //COMPRESSED_HEADERS





//
// Private functions
//

PRIVATE
BOOL
FMatchList(
    LPSTR *lplpList,
    DWORD cListLen,
    HEADER_STRING *lpHeader,
    LPSTR    lpBase
    );




//
// external functions
//

extern
BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    );

#ifdef COMPRESSED_HEADERS
DWORD
LookupHeadermap(
    LPSTR   lpszHeader
);

extern BOOL vfCompressedHeaders;
#endif //COMPRESSED_HEADERS


DWORD
FASTCALL
CalculateHashNoCase(
    IN LPSTR lpszString,
    IN DWORD dwStringLength
    )

/*++

Routine Description:

    Calculate a case-insensitive hash number given a string. Assumes input is
    7-bit ASCII

Arguments:

    lpszString      - string to hash

    dwStringLength  - length of lpszString, or -1 if we need to calculate

Return Value:

    DWORD - a generated hash value

--*/

{
    DWORD dwHash = HEADER_HASH_SEED;

    while (dwStringLength != 0) {
        CHAR ch = *lpszString;

        if ((ch >= 'A') && (ch <= 'Z')) {
            ch = MAKE_LOWER(ch);
        }
        dwHash += (DWORD)(dwHash << 5) + ch; /*+ *pszName++;*/

        ++lpszString;
        --dwStringLength;
    }
    return dwHash;
}

//
// methods
//

VOID
inline
HEADER_STRING::CreateHash(
    LPSTR lpszBase
    )
{
    DWORD i = 0;
    LPSTR string = StringAddress(lpszBase);

    while ((i < (DWORD)StringLength())
           && !((string[i] == ':')
                || (string[i] == ' ')
                || (string[i] == '\r')
                || (string[i] == '\n'))) {
        ++i;
    }
    m_Hash = CalculateHashNoCase(string, i);
}



DWORD
HTTP_HEADERS::AllocateHeaders(
    IN DWORD dwNumberOfHeaders
    )

/*++

Routine Description:

    Allocates or grows the array of header pointers (HEADER_STRING objects)

Arguments:

    dwNumberOfHeaders   - number of additional header slots to create

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AllocateHeaders",
                 "%d",
                 dwNumberOfHeaders
                 ));

    PERF_ENTER(AllocateHeaders);

    //
    // we really need to be able to realloc an array of HEADER_STRING objects
    // (see below)
    //

    DWORD error;
    DWORD slots = _TotalSlots;


    if ( (_TotalSlots + dwNumberOfHeaders) >  (INVALID_HEADER_INDEX-1))
    {
        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    _lpHeaders = (HEADER_STRING *)ResizeBuffer((HLOCAL)_lpHeaders,
                                               (_TotalSlots + dwNumberOfHeaders)
                                                    * sizeof(HEADER_STRING),
                                               FALSE // not moveable
                                               );
    if (_lpHeaders != NULL) {
        _NextOpenSlot = _TotalSlots;
        _TotalSlots += dwNumberOfHeaders;
        _FreeSlots += dwNumberOfHeaders;

        //
        // this is slightly ugly, but it seems there's no easy C++ way to
        // do this - we need to be able to realloc() an array of objects
        // created by new(), but so far, it can't be done
        //

        for (; slots < _TotalSlots; ++slots) {
            _lpHeaders[slots].Clear();
        }
        error = ERROR_SUCCESS;
    } else {

        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    INET_ASSERT(_FreeSlots <= _TotalSlots);

    PERF_LEAVE(AllocateHeaders);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::FreeHeaders(
    VOID
    )

/*++

Routine Description:

    Free the headers strings and the headers array

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "FreeHeaders",
                 NULL
                 ));

    LockHeaders();

    //
    // free up each individual entry (free string buffers)
    //

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        _lpHeaders[i] = (LPSTR)NULL;
    }

    //
    // followed by the array itself
    //

    if (_lpHeaders) {
        _lpHeaders = (HEADER_STRING *)FREE_MEMORY((HLOCAL)_lpHeaders);

        INET_ASSERT(_lpHeaders == NULL);
    }

    _TotalSlots = 0;
    _FreeSlots = 0;
    _HeadersLength = 0;
    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    UnlockHeaders();

    DEBUG_LEAVE(0);
}


VOID
HTTP_HEADERS::CopyHeaders(
    IN OUT LPSTR * lpBuffer,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength
    )

/*++

Routine Description:

    Copy the headers to the caller's buffer. Each header is terminated by CR-LF.
    This method is called to convert the request headers list to a buffer that
    we can send to the server

    N.B. This function MUST be called with the headers already locked

Arguments:

    lpBuffer            - pointer to pointer to buffer where headers are
                          written. We update the pointer

    lpszObjectName      - optional object name

    dwObjectNameLength  - optional object name length

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "CopyHeaders",
                 "%#x, %#x [%q], %d",
                 lpBuffer,
                 lpszObjectName,
                 lpszObjectName,
                 dwObjectNameLength
                 ));

    LockHeaders();

    DWORD i = 0;

    if (lpszObjectName != NULL) {
        memcpy(*lpBuffer, _lpszVerb, _dwVerbLength);
        *lpBuffer += _dwVerbLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, lpszObjectName, dwObjectNameLength);
        *lpBuffer += dwObjectNameLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, _lpszVersion, _dwVersionLength);
        *lpBuffer += _dwVersionLength;
        *(*lpBuffer)++ = '\r';
        *(*lpBuffer)++ = '\n';
        i = 1;
    }
    for (; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {
            _lpHeaders[i].CopyTo(*lpBuffer);
            *lpBuffer += _lpHeaders[i].StringLength();
            *(*lpBuffer)++ = '\r';
            *(*lpBuffer)++ = '\n';
        }
    }

    UnlockHeaders();

    DEBUG_LEAVE(0);
}

#ifdef COMPRESSED_HEADERS

VOID
HTTP_HEADERS::CopyCompressedHeaders(
    IN OUT LPSTR * lpBuffer
    )

/*++

Routine Description:

    Copy the headers to the caller's buffer. Each header is terminated by CR-LF.
    This method is called to convert the request headers list to a buffer that
    we can send to the server

    N.B. This function MUST be called with the headers already locked

Arguments:

    lpBuffer    - pointer to pointer to buffer where headers are written. We
                  update the pointer

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "CopyCompressedHeaders",
                 "%#x",
                 lpBuffer
                 ));
    LPSTR   lpszHeaderString;
    DWORD j;
    LockHeaders();

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {

            lpszHeaderString = _lpHeaders[i].StringAddress(NULL);

            j = LookupHeadermap(lpszHeaderString);

            if (j) {
                // copy the corresponding short header and bump the pointer
                // ahead


                DEBUG_PRINT(
                    HTTP,
                    INFO,
                    ("Compressed:%s using %s\n",
                        lpszHeaderString,
                        rgsHeaderMap[j].lpszShortHeader
                    )
                );

                strcpy(*lpBuffer, rgsHeaderMap[j].lpszShortHeader);

                *lpBuffer += rgsHeaderMap[j].dwLenShortHeader;

                // then copy the value of the header
                // and bump the destination further by the right amount
                strncpy(*lpBuffer,
                        lpszHeaderString + rgsHeaderMap[j].dwLenLongHeader,
                        _lpHeaders[i].StringLength() - rgsHeaderMap[j].dwLenLongHeader
                );

                *lpBuffer += (_lpHeaders[i].StringLength() - rgsHeaderMap[j].dwLenLongHeader);

            }
            else {

                // No match found, must be a header we don't know about
                DEBUG_PRINT(
                    HTTP,
                    INFO,
                    ("Couldn't compress header for %s\n",
                        lpszHeaderString
                    )
                );

                _lpHeaders[i].CopyTo(*lpBuffer);
                *lpBuffer += _lpHeaders[i].StringLength();

            }

            *(*lpBuffer)++ = '\r';
            *(*lpBuffer)++ = '\n';

        }
    }

    UnlockHeaders();

    DEBUG_LEAVE(0);
}
#endif //COMPRESSED_HEADERS


HEADER_STRING *
FASTCALL
HTTP_HEADERS::FindFreeSlot(
    DWORD* piSlot
    )

/*++

Routine Description:

    Finds the next free slot in the headers list, or adds some new slots

    N.B. This function MUST be called with the headers already locked

Arguments:

    piSlot: returns index of slot found

Return Value:

    HEADER_STRING *  - pointer to next free slot

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "FindFreeSlot",
                 NULL
                 ));

    PERF_ENTER(FindFreeSlot);

    DWORD i;
    DWORD error;
    HEADER_STRING * header = NULL;

    //
    // if there are no free slots, allocate some more
    //

    if (_FreeSlots == 0) {
        i = _TotalSlots;
        error = AllocateHeaders(HEADERS_INCREMENT);
    } else {
        i = 0;
        error = ERROR_SUCCESS;
        if (!_lpHeaders[_NextOpenSlot].HaveString())
        {
            --_FreeSlots;
            header = &_lpHeaders[_NextOpenSlot];
            *piSlot = _NextOpenSlot;
            _NextOpenSlot = (_NextOpenSlot == (_TotalSlots-1)) ? (_TotalSlots-1) : _NextOpenSlot++;
            goto quit;
        }
    }
    if (error == ERROR_SUCCESS) {
        for (; i < _TotalSlots; ++i) {
            if (!_lpHeaders[i].HaveString()) {
                --_FreeSlots;
                header = &_lpHeaders[i];
                *piSlot = i;
                _NextOpenSlot = (i == (_TotalSlots-1)) ? (_TotalSlots-1) : (i+1);
                break;
            }
        }
        if (header == NULL) {

            //
            // we would have just allocated extra slots if we didn't have
            // any, so we shouldn't be here
            //

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
    }

quit:
    _Error = error;

    PERF_LEAVE(FindFreeSlot);

    DEBUG_LEAVE(header);

    return header;
}


VOID
HTTP_HEADERS::ShrinkHeader(
    IN LPBYTE pbBase,
    IN DWORD  iSlot,
    IN DWORD  dwOldQueryIndex,
    IN DWORD  dwNewQueryIndex,
    IN DWORD  cbNewSize
    )

/*++

Routine Description:

    Low level function that does a surgical replace of one header with another.
    This code updates internal structures such as bKnownHeaders and the stored
    hash value for the new Header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    None.

--*/

{
    HEADER_STRING* pHeader = _lpHeaders + iSlot;

    INET_ASSERT(_bKnownHeaders[dwOldQueryIndex] == (BYTE) iSlot ||
                dwNewQueryIndex == dwOldQueryIndex );

    //
    // Swap in the new header.  Update Length, Hash, and its cached position
    //  in the known header array.
    //

    _bKnownHeaders[dwOldQueryIndex] = INVALID_HEADER_INDEX;
    _bKnownHeaders[dwNewQueryIndex] = (BYTE) iSlot;

    pHeader->SetLength (cbNewSize);
    pHeader->SetHash (GlobalKnownHeaders[dwNewQueryIndex].HashVal);
}

DWORD
inline
HTTP_HEADERS::SlowFind(
    IN LPSTR lpBase,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwIndex,
    IN DWORD dwHash,
    OUT DWORD *lpdwQueryIndex,
    OUT BYTE  **lplpbPrevIndex
    )

/*++

Routine Description:

    Finds the next occurance of lpszHeaderName in the header array, uses
    a cached table of well known headers to accerlate the search if the
    string is a known header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{

    //
    // Now see if this is a known header passed in as a string,
    //   If it is, we save ourselves the loop, and just map it right in to a known header
    //

    DWORD dwKnownQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    *lpdwQueryIndex = INVALID_HEADER_SLOT;

    if ( dwKnownQueryIndex != 0 )
    {
        dwKnownQueryIndex--;

        if ( ((int)dwHeaderNameLength >= GlobalKnownHeaders[dwKnownQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[dwKnownQueryIndex].Text,
                      GlobalKnownHeaders[dwKnownQueryIndex].Length) == 0)
        {
            *lpdwQueryIndex = dwKnownQueryIndex;

            INET_ASSERT((int)(dwHeaderNameLength) == GlobalKnownHeaders[dwKnownQueryIndex].Length);

            if ( lplpbPrevIndex )
            {
                return FastNukeFind(
                        dwKnownQueryIndex,
                        dwIndex,
                        lplpbPrevIndex
                        );
            }
            else
            {
                return FastFind(
                        dwKnownQueryIndex,
                        dwIndex
                        );
            }
        }
    }

    //
    // Otherwise we painfully enumerate the whole array of headers
    //

    for (DWORD i = 0; i < _TotalSlots; ++i)
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[i];

        if (!pString->HaveString()) {
            continue;
        }

        if (pString->HashStrnicmp(lpBase,
                                  lpszHeaderName,
                                  dwHeaderNameLength,
                                  dwHash) == 0)
        {

            //
            // if we haven't reached the required index yet, continue
            //

            if (dwIndex != 0) {
                --dwIndex;
                continue;
            }

            return i; // found index/slot
        }
    }

    return INVALID_HEADER_SLOT; // not found
}


DWORD
inline
HTTP_HEADERS::FastFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    DWORD dwSlot;

    dwSlot = _bKnownHeaders[dwQueryIndex];

    while ( (dwIndex > 0) && (dwSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[dwSlot];
        dwSlot  = pString->GetNextKnownIndex();

        dwIndex--;
    }

    if ( dwSlot >= INVALID_HEADER_INDEX)
    {
        return INVALID_HEADER_SLOT;
    }

    return dwSlot; // found it.
}


DWORD
inline
HTTP_HEADERS::FastNukeFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex,
    OUT BYTE **lplpbPrevIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.
    Also provides a ptr to ptr to the slot which directs us to the one found.
    This is needed for deletion purposes.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    BYTE *lpbSlot;

    *lplpbPrevIndex = lpbSlot = &_bKnownHeaders[dwQueryIndex];
    dwIndex++;

    while ( (dwIndex > 0) && (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[*lpbSlot];
        *lplpbPrevIndex = lpbSlot;
        lpbSlot  = pString->GetNextKnownIndexPtr();

        dwIndex--;
    }

    if ( **lplpbPrevIndex >= INVALID_HEADER_INDEX ||
         dwIndex > 0 )
    {
        return INVALID_HEADER_SLOT;
    }

    return ((DWORD) **lplpbPrevIndex); // found it.
}

VOID
HTTP_HEADERS::RemoveAllByIndex(
    IN DWORD dwQueryIndex
    )
/*++

Routine Description:

    Removes all Known Headers found in the header array.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

Return Value:

    None.

--*/


{
    BYTE bSlot;
    BYTE bPrevSlot;

    bSlot = bPrevSlot  = _bKnownHeaders[dwQueryIndex];

    while (bSlot < INVALID_HEADER_INDEX)
    {
        HEADER_STRING * pString;

        bPrevSlot   = bSlot;
        pString     = &_lpHeaders[bSlot];
        bSlot       = (BYTE) pString->GetNextKnownIndex();

        RemoveHeader(bPrevSlot, dwQueryIndex, &_bKnownHeaders[dwQueryIndex]);
    }

    _bKnownHeaders[dwQueryIndex] = INVALID_HEADER_INDEX;

    return;
}


BOOL
inline
HTTP_HEADERS::HeaderMatch(
    IN DWORD dwHash,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    OUT DWORD *lpdwQueryIndex
    )

/*++

Routine Description:

    Looks up a Known HTTP header string using its Hash value and
     string contained the name of the header.

Arguments:

    dwHash              - Hash value of header name string

    lpszHeaderName      - name of header we are matching

    dwHeaderNameLength  - length of header name string

    lpdwQueryIndex      - If found, this is the HTTP_QUERY_* based index to the header.

Return Value:

    BOOL
        Success - The string and hash matched againsted a known header

        Failure - There is no known header for that hash & string pair.

--*/

{
    *lpdwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    if ( *lpdwQueryIndex != 0 )
    {
        (*lpdwQueryIndex)--;

        if ( ((int)dwHeaderNameLength == GlobalKnownHeaders[*lpdwQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[*lpdwQueryIndex].Text,
                      GlobalKnownHeaders[*lpdwQueryIndex].Length) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BYTE
inline
HTTP_HEADERS::FastAdd(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwSlot
    )
/*++

Routine Description:

    Rapidly adds a known string to the header array, this function
     is used to matain coherency of the _bKnownHeaders which
     contained indexed offsets into the header array for known headers.

    Note that this function is used instead of latter listed below
     in order to maintain proper order in headers received.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

    dwSlot - Slot in which this header is being added.

Return Value:

    None.

--*/


{
    BYTE *lpbSlot;

    lpbSlot = &_bKnownHeaders[dwQueryIndex];

    while ( (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString  = &_lpHeaders[*lpbSlot];
        lpbSlot  = pString->GetNextKnownIndexPtr();
    }

    INET_ASSERT(*lpbSlot == INVALID_HEADER_INDEX);

    *lpbSlot = (BYTE) dwSlot;
    return INVALID_HEADER_INDEX;
}


//BYTE
//inline
//HTTP_HEADERS::FastAdd(
//    IN DWORD  dwQueryIndex,
//    IN DWORD  dwSlot
//    )
//{
//    BYTE bOldSlot;
//
//    bOldSlot = _bKnownHeaders[dwQueryIndex];
//    _bKnownHeaders[dwQueryIndex] = (BYTE) dwSlot;
//
//    return bOldSlot;
//}




DWORD
HTTP_HEADERS::AddHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    lpszHeaderName      - pointer to name of header to add, e.g. "Accept:"

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    LockHeaders();

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(*lpszHeaderName != '\0');
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderValue != NULL);
    INET_ASSERT(*lpszHeaderValue != '\0');
    INET_ASSERT(dwHeaderValueLength != 0);
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    //
    // we may have been handed a header with a trailing colon. We don't care
    // for such nasty imagery
    //

    if (lpszHeaderName[dwHeaderNameLength - 1] == ':') {
        --dwHeaderNameLength;
    }

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    DWORD i = 0;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = SlowFind(
                    NULL,
                    lpszHeaderName,
                    dwHeaderNameLength,
                    dwIndex,
                    dwHash,
                    &dwQueryIndex,
                    NULL
                    );

        if (dwSlot != ((DWORD) -1))
        {

            HEADER_STRING * pString;

            pString = &_lpHeaders[dwSlot];

            //
            // found what we are looking for. Coalesce it
            //

            pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

            pString->Strncat(
                             (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                 "; " :
                                 ", ",
                              2);

            pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
            _HeadersLength += 2 + dwHeaderValueLength;
            error = ERROR_SUCCESS;

        }
    }
    else
    {

        //
        // Check to verify that the header we're adding is a known header,
        //   If its a known header we use dwQueryIndex to update the known header array
        //   otherwise, IF ITS NOT, we make sure to set dwQueryIndex to INVALID_...
        //

        if (! HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwQueryIndex) )
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }

        /*
        // Perhaps this more efficent ???
        dwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

        if ( dwQueryIndex != 0 )
        {
            dwQueryIndex--;

            if ( ((int)dwHeaderNameLength < GlobalKnownHeaders[dwQueryIndex].Length) ||
                 strnicmp(lpszHeaderName,
                          GlobalKnownHeaders[dwQueryIndex].Text,
                          GlobalKnownHeaders[dwQueryIndex].Length) != 0)
            {
                dwQueryIndex = INVALID_HEADER_SLOT;
            }
        }
        else
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }
        */
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);

        if ( dwQueryIndex != INVALID_HEADER_SLOT )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));
        }

        error = ERROR_SUCCESS;
    }

quit:

    UnlockHeaders();

    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::AddHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    INET_ASSERT(dwQueryIndex <= HTTP_QUERY_MAX);
    INET_ASSERT(lpszHeaderValue != NULL);
    INET_ASSERT(*lpszHeaderValue != '\0');
    INET_ASSERT(dwHeaderValueLength != 0);
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD i = 0;
    LPSTR lpszHeaderName;
    DWORD dwHeaderNameLength;
    DWORD dwHash;

    dwHash             = GlobalKnownHeaders[dwQueryIndex].HashVal;
    lpszHeaderName     = GlobalKnownHeaders[dwQueryIndex].Text;
    dwHeaderNameLength = GlobalKnownHeaders[dwQueryIndex].Length;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = FastFind(
                    dwQueryIndex,
                    dwIndex
                    );

        if (dwSlot != INVALID_HEADER_SLOT)
        {

            HEADER_STRING * pString;

            pString = &_lpHeaders[dwSlot];

            //
            // found what we are looking for. Coalesce it
            //

            pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

            pString->Strncat(
                             (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                 "; " :
                                 ", ",
                              2);

            pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
            _HeadersLength += 2 + dwHeaderValueLength;
            error = ERROR_SUCCESS;

        }
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);
        freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));

        error = ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderName      - pointer to the header name

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to the header value

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderName[dwHeaderNameLength - 1] != ':');

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);
    DWORD dwSlot;
    DWORD dwQueryIndex;
    BYTE *pbPrevByte;

    LockHeaders();

    dwSlot = SlowFind(
                NULL,
                lpszHeaderName,
                dwHeaderNameLength,
                dwIndex,
                dwHash,
                &dwQueryIndex,
                &pbPrevByte
                );

    if ( dwSlot != ((DWORD) -1))
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto quit;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            if ( dwQueryIndex != ((DWORD) -1) )
            {
                error = AddHeader(dwQueryIndex,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }
            else
            {
                error = AddHeader(lpszHeaderName,
                                  dwHeaderNameLength,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }


        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        if ( dwQueryIndex != ((DWORD) -1) )
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        }
        else
        {
            error = AddHeader(lpszHeaderName,
                              dwHeaderNameLength,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );

        }
    }

quit:

    UnlockHeaders();

    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderValue     - pointer to the header value

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    BYTE *pbPrevByte;

    LockHeaders();

    dwSlot = FastNukeFind(
                dwQueryIndex,
                dwIndex,
                &pbPrevByte
                );

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto quit;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        error = AddHeader(dwQueryIndex,
                          lpszHeaderValue,
                          dwHeaderValueLength,
                          0,
                          dwFlags
                          );
    }

quit:

    UnlockHeaders();

    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Finds a request or response header

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FindHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));


    PERF_ENTER(FindHeader);



    INET_ASSERT(lpdwIndex != NULL);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    HEADER_STRING * pString;
    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    LockHeaders();

    dwSlot = SlowFind(
                lpBase,
                lpszHeaderName,
                dwHeaderNameLength,
                *lpdwIndex,
                dwHash,
                &dwQueryIndex,
                NULL
                );

    if ( dwSlot != ((DWORD) -1) )
    {
        pString = &_lpHeaders[dwSlot];

        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        stringLen = pString->StringLength();

        INET_ASSERT(stringLen > dwHeaderNameLength);

        //
        // get a pointer to the value string
        //

        value = pString->StringAddress(lpBase) + dwHeaderNameLength;
        stringLen -= dwHeaderNameLength;

        //
        // the input string could be a substring of a different header
        //

        //INET_ASSERT(*value != ':');

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        do {
            ++value;
            --stringLen;
        } while ((stringLen > 0) && (*value == ' '));

        //
        // get the data in the format requested by the app
        //

        LPVOID lpData;
        DWORD dwDataSize;
        DWORD dwRequiredSize;
        SYSTEMTIME systemTime;
        DWORD number;

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME) {

            char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

            if (stringLen < sizeof(buf)) {

                //
                // value probably does not point at a zero-terminated string
                // which HttpDateToSystemTime() expects, so we make a copy
                // and terminate it
                //

                memcpy((LPVOID)buf, (LPVOID)value, stringLen);
                buf[stringLen] = '\0';
                if (HttpDateToSystemTime(buf, &systemTime)) {
                    lpData = (LPVOID)&systemTime;
                    dwRequiredSize = dwDataSize = sizeof(systemTime);
                } else {

                    //
                    // couldn't convert date/time. Presume header must be bogus
                    //

                    error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                    DEBUG_PRINT(HTTP,
                                ERROR,
                                ("cannot convert %.40q to SYSTEMTIME\n",
                                value
                                ));

                }
            } else {

                //
                // we would break the date/time buffer!
                //

                error = ERROR_INTERNET_INTERNAL_ERROR;
            }
        } else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
            if (isdigit(*value)) {
                number = 0;
                for (int i = 0;
                    (stringLen > 0) && isdigit(value[i]);
                    ++i, --stringLen) {

                    number = number * 10 + (DWORD)(value[i] - '0');
                }
                lpData = (LPVOID)&number;
                dwRequiredSize = dwDataSize = sizeof(number);
            } else {

                //
                // not a numeric field. Request must be bogus for this header
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.20q to NUMBER\n",
                            value
                            ));

            }
        } else {
            lpData = (LPVOID)value;
            dwDataSize = stringLen;
            dwRequiredSize = dwDataSize + 1;
        }

        //
        // if error == ERROR_SUCCESS then we can attempt to copy the data
        //

        if (error == ERROR_SUCCESS) {
            if (*lpdwBufferLength < dwRequiredSize) {
                *lpdwBufferLength = dwRequiredSize;
                error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                memcpy(lpBuffer, lpData, dwDataSize);
                *lpdwBufferLength = dwDataSize;

                //
                // if dwRequiredSize > dwDataSize, then this is a variable-
                // length item (i.e. a STRING!) so we add a terminating '\0'
                //

                if (dwRequiredSize > dwDataSize) {

                    INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                    ((LPSTR)lpBuffer)[dwDataSize] = '\0';
                }

                //
                // successfully retrieved the requested header - bump the
                // index
                //

                ++*lpdwIndex;
            }
        }
    }

    UnlockHeaders();

    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )
/*++

Routine Description:

    Finds a request or response header, based on index to the header name we are searching for.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/
{

    DWORD error;
    LPSTR lpData;
    DWORD dwDataSize = 0;
    DWORD dwRequiredSize;
    SYSTEMTIME systemTime;
    DWORD number;

    error = FastFindHeader(
                lpBase,
                dwQueryIndex,
                (LPVOID *)&lpData,
                &dwDataSize,
                *lpdwIndex
                );

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    //
    // get the data in the format requested by the app
    //

    if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME)
    {
        char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

        if (dwDataSize < sizeof(buf))
        {

            //
            // value probably does not point at a zero-terminated string
            // which HttpDateToSystemTime() expects, so we make a copy
            // and terminate it
            //

            memcpy((LPVOID)buf, (LPVOID)lpData, dwDataSize);
            buf[dwDataSize] = '\0';
            if (HttpDateToSystemTime(buf, &systemTime)) {
                lpData = (LPSTR)&systemTime;
                dwRequiredSize = dwDataSize = sizeof(systemTime);
            } else {

                //
                // couldn't convert date/time. Presume header must be bogus
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.40q to SYSTEMTIME\n",
                            lpData
                            ));

            }
        }
        else
        {

            //
            // we would break the date/time buffer!
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
    }
    else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER)
    {
        if (isdigit(*lpData)) {
            number = 0;
            for (int i = 0;
                (dwDataSize > 0) && isdigit(lpData[i]);
                ++i, --dwDataSize) {

                number = number * 10 + (DWORD)(lpData[i] - '0');
            }
            lpData = (LPSTR)&number;
            dwRequiredSize = dwDataSize = sizeof(number);
        } else {

            //
            // not a numeric field. Request must be bogus for this header
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("cannot convert %.20q to NUMBER\n",
                        lpData
                        ));

        }
    }
    else
    {
        dwRequiredSize = dwDataSize + 1;
    }

    //
    // if error == ERROR_SUCCESS then we can attempt to copy the data
    //

    if (error == ERROR_SUCCESS)
    {
        if (*lpdwBufferLength < dwRequiredSize)
        {
            *lpdwBufferLength = dwRequiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            memcpy(lpBuffer, lpData, dwDataSize);
            *lpdwBufferLength = dwDataSize;

            //
            // if dwRequiredSize > dwDataSize, then this is a variable-
            // length item (i.e. a STRING!) so we add a terminating '\0'
            //

            if (dwRequiredSize > dwDataSize)
            {
                INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                ((LPSTR)lpBuffer)[dwDataSize] = '\0';
            }

            //
            // successfully retrieved the requested header - bump the
            // index
            //

            ++*lpdwIndex;
        }
    }
quit:

    return error;
}



DWORD
HTTP_HEADERS::FastFindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    OUT LPVOID *lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Finds a request or response header slightly quicker than its higher level
     cousin, FindHeader.   Unlike FindHeader this function simply returns
     a pointer and length, and does not copy header data.


    lpBase              - base address of strings

    dwQueryIndex        - a index into a array known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lplpBuffer          - pointer to pointer of the actual header to be returned in.

    lpdwBufferLength    - OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

    dwIndex             - a index of which header we're asking for, as there can be multiple headers
                          under the same name.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FastFindHeader",
                 "%q, %#x, %#x [%#x], %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwIndex
                 ));

    PERF_ENTER(FindHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    HEADER_STRING * curHeader;
    DWORD dwSlot;

    dwSlot = FastFind(dwQueryIndex, dwIndex);

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        curHeader = GetSlot(dwSlot);

        //
        // get a pointer to the value string
        //

        value     = curHeader->StringAddress(lpBase) + (GlobalKnownHeaders[dwQueryIndex].Length+1);
        stringLen = curHeader->StringLength() - (GlobalKnownHeaders[dwQueryIndex].Length+1);

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        while ((stringLen > 0) && (*value == ' '))
        {
            ++value;
            --stringLen;
        }

        //
        // get the data in the format requested by the app
        //

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        *lplpBuffer = (LPVOID)value;
        *lpdwBufferLength = stringLen;
    }

    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::QueryRawHeaders(
    IN LPSTR lpBase,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryRawHeaders);

    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;

    LockHeaders();

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {

            DWORD length;

            length = _lpHeaders[i].StringLength();

            requiredLength += length + (bCrLfTerminated ? 2 : 1);
            if (*lpdwBufferLength > requiredLength) {
                _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                lpszBuffer += length;
                if (bCrLfTerminated) {
                    *lpszBuffer++ = '\r';
                    *lpszBuffer++ = '\n';
                } else {
                    *lpszBuffer++ = '\0';
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    UnlockHeaders();

    ++requiredLength;

    DWORD error;

    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
        error = ERROR_SUCCESS;
    }
    *lpdwBufferLength = requiredLength;

    PERF_LEAVE(QueryRawHeaders);

    return error;
}


DWORD
HTTP_HEADERS::QueryFilteredRawHeaders(
    IN LPSTR lpBase,
    IN LPSTR *lplpFilterList,
    IN DWORD cListElements,
    IN BOOL  fExclude,
    IN BOOL  fSkipVerb,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error = ERROR_NOT_SUPPORTED;

    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;
    BOOL fCopy;

    DWORD i = fSkipVerb ? 1 : 0;
    for (; i < _TotalSlots; ++i) {
       if (_lpHeaders[i].HaveString()) {
          fCopy = TRUE;
          if (lplpFilterList
             && FMatchList(lplpFilterList, cListElements, _lpHeaders+i, lpBase)) {
             fCopy = fExclude?FALSE:TRUE;
          }
          if (fCopy) {
              DWORD length;

              length = _lpHeaders[i].StringLength();
              requiredLength += length + (bCrLfTerminated ? 2 : 1);
              if (*lpdwBufferLength > requiredLength) {
                    _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                   lpszBuffer += length;
                   if (bCrLfTerminated) {
                       *lpszBuffer++ = '\r';
                       *lpszBuffer++ = '\n';
                    } else {
                       *lpszBuffer++ = '\0';
                   }
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    ++requiredLength;


    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
        error = ERROR_SUCCESS;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
HTTP_HEADERS::AddRequest(
    IN LPSTR lpszVerb,
    IN LPSTR lpszObject,
    IN LPSTR lpszVersion
    )

/*++

Routine Description:

    Builds the request line from its constituent parts. The request line is the
    first (0th) header in the request headers

    Assumes:    1. This is the one-and-only call to this method
                2. lpszObject must already be escaped if necessary

Arguments:

    lpszVerb    - pointer to HTTP verb, e.g. "GET"

    lpszObject  - pointer to HTTP object name, e.g. "/users/albert/~emc2.htm".

    lpszVersion - pointer to HTTP version string, e.g. "HTTP/1.0"

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    PERF_ENTER(AddRequest);

    //
    // there must not be a header when this method is called
    //

    INET_ASSERT(_HeadersLength == 0);

    DWORD error = ERROR_SUCCESS;
    int verbLen = lstrlen(lpszVerb);
    int objectLen = lstrlen(lpszObject);
    int versionLen = lstrlen(lpszVersion);
    int len = verbLen       // "GET"
            + 1             //     ' '
            + objectLen     //        "/users/albert/~emc2.htm"
            + 1             //                                 ' '
            + versionLen    //                                    "HTTP/1.0"
            + 1             //                                              '\0'
            ;

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(!request.HaveString());

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    request.CreateStringBuffer((LPVOID)lpszVerb, verbLen, len);
    if (request.IsError()) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {
        request += ' ';
        request.Strncat((LPVOID)lpszObject, objectLen);
        request += ' ';
        request.Strncat((LPVOID)lpszVersion, versionLen);

        _HeadersLength = len - 1 + (sizeof("\r\n") - 1);

        //
        // we have used the first free slot in the headers array
        //

        --_FreeSlots;

        //
        // update the component variables in case of a ModifyRequest()
        //

        _lpszVerb = request.StringAddress();
        _dwVerbLength = verbLen;
        _lpszObjectName = _lpszVerb + verbLen + 1;
        _dwObjectNameLength = objectLen;
        _lpszVersion = _lpszObjectName + objectLen + 1;
        _dwVersionLength = versionLen;
        SetRequestVersion();
        error = request.IsError() ? ::GetLastError() : ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddRequest);

    return error;
}


DWORD
HTTP_HEADERS::ModifyRequest(
    IN HTTP_METHOD_TYPE tMethod,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength,
    IN LPSTR lpszVersion OPTIONAL,
    IN DWORD dwVersionLength
    )

/*++

Routine Description:

    Updates the request line. Used in redirection

Arguments:

    tMethod             - type of new method

    lpszObjectName      - pointer to new object name

    dwObjectNameLength  - length of new object name

    lpszVersion         - optional pointer to version string

    dwVersionLength     - length of lpszVersion string if present

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ModifyRequest",
                 "%s, %q, %d, %q, %d",
                 MapHttpMethodType(tMethod),
                 lpszObjectName,
                 dwObjectNameLength,
                 lpszVersion,
                 dwVersionLength
                 ));

    PERF_ENTER(ModifyRequest);

    INET_ASSERT(lpszObjectName != NULL);
    INET_ASSERT(dwObjectNameLength != 0);

    //
    // there must already be a header when this method is called
    //

    INET_ASSERT(_HeadersLength != 0);

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    //
    // BUGBUG [arthurbi] using two HEADER_STRINGs here causes an extra
    //  ReAlloc when use the Copy operator between the two.
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;
    HEADER_STRING newRequest;
    LPCSTR lpcszVerb;
    DWORD verbLength;
    DWORD error = ERROR_SUCCESS;
    DWORD length;

    //
    // there must already be a request line
    //

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(request.HaveString());

    //
    // get the verb/method to use.
    //

    if (tMethod == HTTP_METHOD_TYPE_UNKNOWN) {

        //
        // the method is unknown, read the old one out of the string
        //  and save off, basically we're reusing the previous one.
        //

        lpcszVerb = request.StringAddress();

        for (DWORD i = 0; i < request.StringLength(); i++) {
            if (lpcszVerb[i] == ' ') {
                break;
            }
        }

        INET_ASSERT((i > 0) && (i < request.StringLength()));

        verbLength = i;
    } else {

        //
        // its one of the normal kind, just map it.
        //

        verbLength = MapHttpMethodType(tMethod, &lpcszVerb);
    }
    if (lpszVersion == NULL) {
        lpszVersion = _lpszVersion;
        dwVersionLength = _dwVersionLength;
    }

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    //
    // calculate the new length from the component lengths we originally set
    // in AddRequest(), and the new object name
    //

    length = verbLength + 1 + dwObjectNameLength + 1 + dwVersionLength + 1;

    //
    // create a new request line
    //

    newRequest.CreateStringBuffer((LPVOID)lpcszVerb, verbLength, length);
    if (newRequest.IsError()) {
        error = GetLastError();
    } else {
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszObjectName, dwObjectNameLength);
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszVersion, dwVersionLength);

        //
        // remove the current request line length from the header buffer
        // aggregate
        //

        _HeadersLength -= request.StringLength();

        //
        // make the current request line the new one
        //

        request = newRequest.StringAddress();

        //
        // and update the address and length variables (version length is the
        // only thing that stays the same)
        //

        if (!request.IsError()) {
            _lpszVerb = request.StringAddress();
            _dwVerbLength = verbLength;
            _lpszObjectName = _lpszVerb + verbLength + 1;
            _dwObjectNameLength = dwObjectNameLength;
            _lpszVersion = _lpszObjectName + dwObjectNameLength + 1;
            _dwVersionLength = dwVersionLength;
            SetRequestVersion();

        //
        // and the new request line length to the aggregate header length
        //

            _HeadersLength += request.StringLength();
        } else {
            error = GetLastError();
        }
    }

quit:

    PERF_LEAVE(ModifyRequest);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::SetRequestVersion(
    VOID
    )

/*++

Routine Description:

    Set _RequestVersionMajor and _RequestVersionMinor based on the HTTP
    version string

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_HEADERS::SetRequestVersion",
                 NULL
                 ));

    INET_ASSERT(_lpszVersion != NULL);

    _RequestVersionMajor = 0;
    _RequestVersionMinor = 0;
    if (strncmp(_lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR pNum = _lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMajor);
        while (!isdigit(*pNum) && (*pNum != '\0')) {
            ++pNum;
        }
        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMinor);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("request version = %d.%d\n",
                    _RequestVersionMajor,
                    _RequestVersionMinor
                    ));

    } else {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("\"HTTP/\" not found in %q\n",
                    _lpszVersion
                    ));

    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_HEADERS::QueryRequestVersion(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Get HtttpVersion used in request.
    
Arguments:

    lpBuffer            - pointer to buffer to copy version string into

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: size of version string excluding terminating '\0'
                               if successful, else required buffer length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_HEADERS::QueryRequestVersion",
                 NULL
                 ));

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    LockHeaders();
    
    if (_lpszVersion != NULL)
    {
        DWORD dwLen = lstrlen(_lpszVersion);

        if (*lpdwBufferLength > dwLen) {
            memcpy(lpBuffer, _lpszVersion, dwLen);
            ((LPSTR)lpBuffer)[dwLen] = '\0';
            *lpdwBufferLength = dwLen;
            error = ERROR_SUCCESS;
        } else {
            *lpdwBufferLength = dwLen + 1;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    UnlockHeaders();

    DEBUG_LEAVE(0);
    return error;
}


LPSTR
HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer(
    OUT LPDWORD lpdwRequestLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength,
    IN BOOL bExtraCrLf,
    IN DWORD dwMaxPacketLength,
    OUT LPBOOL lpbCombinedData
    )

/*++

Routine Description:

    Creates a request buffer from the HTTP request and headers

Arguments:

    lpdwRequestLength   - pointer to returned buffer length

    lpOptional          - pointer to optional data

    dwOptionalLength    - length of optional data

    bExtraCrLf          - TRUE if we need to add additional CR-LF to buffer

    dwMaxPacketLength   - maximum length of buffer

    lpbCombinedData     - output TRUE if data successfully combined into one

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer",
                 "%#x, %#x, %d, %B, %d, %#x",
                 lpdwRequestLength,
                 lpOptional,
                 dwOptionalLength,
                 bExtraCrLf,
                 dwMaxPacketLength,
                 lpbCombinedData
                 ));

    PERF_ENTER(CreateRequestBuffer);

    *lpbCombinedData = FALSE;

    _RequestHeaders.LockHeaders();

    DWORD headersLength;
    DWORD requestLength;
    DWORD optionalLength;
    HEADER_STRING * pRequest = _RequestHeaders.GetFirstHeader();
    HEADER_STRING & request = *pRequest;
    LPSTR requestBuffer = NULL;
/*
    WCHAR wszUrl[1024];
    LPWSTR pwszUrl = NULL;
    BYTE utf8Url[2048];
    LPBYTE pbUrl = NULL;
*/
    LPSTR pszObject = _RequestHeaders.ObjectName();
    DWORD dwObjectLength = _RequestHeaders.ObjectNameLength();

    if (pRequest == NULL) {
        goto quit;
    }

    INET_ASSERT(request.HaveString());

    headersLength = _RequestHeaders.HeadersLength();
    requestLength = headersLength + (sizeof("\r\n") - 1);

/*------------------------------------------------------------------
    GlobalEnableUtf8Encoding = FALSE;
    if (GlobalEnableUtf8Encoding
        && StringContainsHighAnsi(pszObject, dwObjectLength)) {

        pwszUrl = wszUrl;

        DWORD arrayElements = ARRAY_ELEMENTS(wszUrl);

        if (dwObjectLength > ARRAY_ELEMENTS(wszUrl)) {
            arrayElements = dwObjectLength;
            pwszUrl = (LPWSTR)ALLOCATE_FIXED_MEMORY(arrayElements * sizeof(*pwszUrl));
            if (pwszUrl == NULL) {
                goto utf8_cleanup;
            }
        }



        PFNINETMULTIBYTETOUNICODE pfnMBToUnicode;
        pfnMBToUnicode = GetInetMultiByteToUnicode( );
        if (pfnMBToUnicode == NULL) {
            goto utf8_cleanup;
        }

        HRESULT hr;
        DWORD dwMode;
        INT nMBChars;
        INT nWChars;

        nMBChars = dwObjectLength;
        nWChars = arrayElements;
        dwMode = 0;

        hr = pfnMBToUnicode(&dwMode,
                                GetCodePage(),
                                pszObject,
                                &nMBChars,
                                pwszUrl,
                                &nWChars
                               );
        if (hr != S_OK || nWChars == 0) {
            goto utf8_cleanup;
        }

        DWORD nBytes;

        nBytes = CountUnicodeToUtf8(pwszUrl, (DWORD)nWChars, TRUE);
        pbUrl = utf8Url;
        if (nBytes > ARRAY_ELEMENTS(utf8Url)) {
            pbUrl = (LPBYTE)ALLOCATE_FIXED_MEMORY(nBytes);
            if (pbUrl == NULL) {
                goto utf8_cleanup;
            }
        }

        DWORD error;

        error = ConvertUnicodeToUtf8(pwszUrl,
                                     (DWORD)nWChars,
                                     pbUrl,
                                     nBytes,
                                     TRUE
                                     );

        INET_ASSERT(error == ERROR_SUCCESS);

        if (error != ERROR_SUCCESS) {
            goto utf8_cleanup;
        }

        requestLength = requestLength - dwObjectLength + nBytes;
        headersLength = headersLength - dwObjectLength + nBytes;
        pszObject = (LPSTR)pbUrl;
        dwObjectLength = nBytes;
        goto after_utf8;

utf8_cleanup:

        if ((pwszUrl != wszUrl) && (pwszUrl != NULL)) {
            FREE_MEMORY(pwszUrl);
        }
        pwszUrl = NULL;
        if ((pbUrl != utf8Url) && (pbUrl != NULL)) {
            FREE_MEMORY(pbUrl);
        }
        pbUrl = NULL;
        pszObject = NULL;
        dwObjectLength = 0;
    }

after_utf8:
------------------------------------------------------------------*/

    optionalLength = (DWORD)(dwOptionalLength + (bExtraCrLf ? (sizeof("\r\n") - 1) : 0));
    if (requestLength + optionalLength <= dwMaxPacketLength) {
        requestLength += optionalLength;
    } else {
        optionalLength = 0;
        bExtraCrLf = FALSE;
    }

    requestBuffer = (LPSTR)ResizeBuffer(NULL, requestLength, FALSE);
    if (requestBuffer != NULL) {
        if (optionalLength != 0) {
            *lpbCombinedData = TRUE;
        }
    } else if (optionalLength != 0) {
        requestLength = headersLength + (sizeof("\r\n") - 1);
        optionalLength = 0;
        bExtraCrLf = FALSE;
        requestBuffer = (LPSTR)ResizeBuffer(NULL, requestLength, FALSE);
    }
    if (requestBuffer != NULL) {

        LPSTR buffer = requestBuffer;

        //
        // copy the headers. Remember: header 0 is the request
        //

//#ifdef COMPRESSED_HEADERS
//        if (vfCompressedHeaders) {
//            DEBUG_PRINT(HTTP,
//                        INFO,
//                        ("Compressing Headers")
//                        );
//            _RequestHeaders.CopyCompressedHeaders(&buffer);
//
//        }
//        else
//#endif //COMPRESSED_HEADERS
        {
            _RequestHeaders.CopyHeaders(&buffer, pszObject, dwObjectLength);
        }

        //
        // terminate the request
        //

        *buffer++ = '\r';
        *buffer++ = '\n';

//#ifdef COMPRESSED_HEADERS
//        if (vfCompressedHeaders) {
//
//            *lpdwRequestLength = ((DWORD)buffer - (DWORD)requestBuffer);
//
//            DEBUG_PRINT(HTTP,
//                        INFO,
//                        ("Compressed Headers: Old Length=%d, New Length = %d, Saved=%d\n",
//                        requestLength,
//                        *lpdwRequestLength,
//                        requestLength - *lpdwRequestLength
//                        )
//                        );
//        } else {
//#endif //COMPRESSED_HEADERS

        if (optionalLength != 0) {
            if (dwOptionalLength != 0) {
                memcpy(buffer, lpOptional, dwOptionalLength);
                buffer += dwOptionalLength;
            }
            if (bExtraCrLf) {
                *buffer++ = '\r';
                *buffer++ = '\n';
            }
        }

        INET_ASSERT((SIZE_T)(buffer-requestBuffer) == requestLength);

        *lpdwRequestLength = requestLength;

//#ifdef COMPRESSED_HEADERS
//        }
//#endif
    }

quit:

    _RequestHeaders.UnlockHeaders();

    DEBUG_PRINT(HTTP,
                INFO,
                ("request length = %d, combined = %B\n",
                *lpdwRequestLength,
                *lpbCombinedData
                ));

/*
    if ((pbUrl != NULL) && (pbUrl != utf8Url)) {
        FREE_MEMORY(pbUrl);
    }
    if ((pwszUrl != NULL) && (pwszUrl != wszUrl)) {
        FREE_MEMORY(pwszUrl);
    }
*/

    PERF_LEAVE(CreateRequestBuffer);

    DEBUG_LEAVE(requestBuffer);

    return requestBuffer;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Searches for an arbitrary request header and if found, returns its value

Arguments:

    lpszHeaderName      - pointer to the name of the header to find

    dwHeaderNameLength  - length of the header

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of the returned header value, or required
                               length of lpBuffer

    dwModifiers         - how to return the data: as number, as SYSTEMTIME
                          structure, etc.

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer not large enough for results

                  ERROR_INTERNET_INCORRECT_FORMAT
                    Can't convert the data to the requested format

                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRequestHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));

    PERF_ENTER(QueryRequestHeader);

    DWORD error;

    error = _RequestHeaders.FindHeader(NULL,
                                       lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwModifiers,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       lpdwIndex
                                       );

    PERF_LEAVE(QueryRequestHeader);

    DEBUG_LEAVE(error);

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader(
    IN DWORD dwQueryIndex,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Searches for an arbitrary request header and if found, returns its value

Arguments:

    lpszHeaderName      - pointer to the name of the header to find

    dwHeaderNameLength  - length of the header

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of the returned header value, or required
                               length of lpBuffer

    dwModifiers         - how to return the data: as number, as SYSTEMTIME
                          structure, etc.

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer not large enough for results

                  ERROR_INTERNET_INCORRECT_FORMAT
                    Can't convert the data to the requested format

                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRequestHeader",
                 "%u, %#x [%#x], %#x, %#x [%d]",
                 dwQueryIndex,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));

    PERF_ENTER(QueryRequestHeader);

    DWORD error;

    error = _RequestHeaders.FindHeader(NULL,
                                       dwQueryIndex,
                                       dwModifiers,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       lpdwIndex
                                       );

    PERF_LEAVE(QueryRequestHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::AddInternalResponseHeader(
    IN DWORD dwHeaderIndex,
    IN LPSTR lpszHeader,
    IN DWORD dwHeaderLength
    )

/*++

Routine Description:

    Adds a created response header to the response header array. Unlike normal
    response headers, this will be a pointer to an actual string, not an offset
    into the response buffer.

    Even if the address of the response buffer changes, created response headers
    will remain fixed

    N.B. The header MUST NOT have a CR-LF terminator
    N.B.-2 This function must be called under the header lock.

Arguments:

    dwHeaderIndex   - index into header value we are actually creating

    lpszHeader      - pointer to created (internal) header to add

    dwHeaderLength  - length of response header, or -1 if ASCIIZ

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddInternalResponseHeader",
                 "%u [%q], %q, %d",
                 dwHeaderIndex,
                 GlobalKnownHeaders[dwHeaderIndex].Text,
                 lpszHeader,
                 dwHeaderLength
                 ));

    DWORD error;

    if (dwHeaderLength == (DWORD)-1) {
        dwHeaderLength = lstrlen(lpszHeader);
    }

    INET_ASSERT((lpszHeader[dwHeaderLength - 1] != '\r')
                && (lpszHeader[dwHeaderLength - 1] != '\n'));

    //
    // find the next slot for this header
    //

    HEADER_STRING * freeHeader;

    //
    // if we already have all the headers (the 'empty' header is the last one
    // in the array) then change the last header to be the one we are adding
    // and add a new empty header, else just add this one
    //

    DWORD iSlot;
    freeHeader = _ResponseHeaders.FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        error = _ResponseHeaders.GetError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {

        HEADER_STRING * lastHeader;

        lastHeader = _ResponseHeaders.GetEmptyHeader();
        if (lastHeader != NULL) {

            //
            // make copy of last header - its an offset string
            //

            *freeHeader = *lastHeader;

            //
            // use what was last header as free header
            //

            freeHeader = lastHeader;
        }
        freeHeader->MakeCopy(lpszHeader, dwHeaderLength);
        freeHeader->SetNextKnownIndex(_ResponseHeaders.FastAdd(dwHeaderIndex, iSlot));
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders(
    IN OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Given the next chunk of the response, updates the response headers. The
    buffer pointer, buffer length and number of bytes received values are all
    maintained in this object (_ResponseBuffer, _ResponseBufferLength and
    _BytesReceived, resp.)

Arguments:

    lpbEof  - IN: TRUE if we have reached the end of the response
              OUT: TRUE if we have reached the end of the response or the end
                   of the headers

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders",
                 "%#x [%.*q], %d, %d, %#x [%B]",
                 _ResponseBuffer + _ResponseScanned,
                 min(_ResponseBufferLength + 1, 80),
                 _ResponseBuffer + _ResponseScanned,
                 _ResponseBufferLength,
                 _BytesReceived,
                 lpbEof,
                 *lpbEof
                 ));

    PERF_ENTER(UpdateResponseHeaders);

    LPSTR lpszBuffer = (LPSTR)_ResponseBuffer + _ResponseScanned;
    DWORD dwBytesReceived = _BytesReceived - _ResponseScanned;
    DWORD error = ERROR_SUCCESS;
    BOOL  success = TRUE;
    HEADER_STRING * statusLine;

    //
    // if input EOF is set then the caller is telling us that the end of the
    // response has been reached at transport level (the server closed the
    // connectiion)
    //

    if (*lpbEof) {
        SetEof(TRUE);
    }

    //
    // lock down the response headers for the duration of this request. The only
    // way another thread is going to wait on this lock is if the reference on
    // the HTTP request object goes to zero, which *shouldn't* happen
    //

    _ResponseHeaders.LockHeaders();

    //
    // if input EOF is set then the caller is telling us that the end of the
    // response has been reached at transport level (the server closed the
    // connectiion)
    //

    if (*lpbEof) {
        SetEof(TRUE);
    }

    //
    // if we don't yet know whether we have a HTTP/1.0 (or greater) or HTTP/0.9
    // response yet, then try to find out.
    //
    // Only responses greater than HTTP/0.9 start with the "HTTP/#.#" string
    //

    if (!IsDownLevel() && !IsUpLevel()) {

#define MAKE_VERSION_ENTRY(string)  string, sizeof(string) - 1

        static struct {
            LPSTR Version;
            DWORD Length;
        } KnownVersionsStrings[] = {
            MAKE_VERSION_ENTRY("HTTP/"),
            MAKE_VERSION_ENTRY("S-HTTP/"),
            MAKE_VERSION_ENTRY("SHTTP/"),
            MAKE_VERSION_ENTRY("Secure-HTTP/"),

            //
            // allow for servers generating slightly off-the-wall responses
            //

            MAKE_VERSION_ENTRY("HTTP /")
        };

#define NUM_HTTP_VERSIONS   ARRAY_ELEMENTS(KnownVersionsStrings)

        //
        // We know this is the start of a HTTP response, but there may be some
        // noise at the start from bad HTML authoring, or bad content-length on
        // the previous response on a keep-alive connection. We will try to sync
        // up to the HTTP header (we will only look for this - I have never seen
        // any of the others, and I doubt its worth the increased complexity and
        // processing time)
        //

        //
        //  Due to possible DoS attacks outlined in RAID item 510295 we are to
        //be more stringent as to what sort of 'noise' is allowed before the start
        //of an HTTP response.  We now allow the noise to consist of at most
        //8 characters of whitespace or '\0'.  If the content-length is slightly
        //off because of a sloppy server, this should skip whatever terminators
        //the server expected us to use.
        //

        const DWORD c_dwSmallestAcceptableStatusLength = ARRAY_ELEMENTS("HTTP/1.1 100\r\n") - 1;
        const DWORD c_dwMaxNoiseAllowed = 8;
        const DWORD c_dwMaxPreHTTPLength = ARRAY_ELEMENTS("Secure-HTTP/")-1;

        LPSTR lpszBuf;
        DWORD bytesLeft;

        lpszBuf = lpszBuffer;
        bytesLeft = dwBytesReceived;

        //
        //  Check that we've read enough bytes for a status line to be ready.
        //
        if ((dwBytesReceived < c_dwSmallestAcceptableStatusLength) && !IsEof())
        {
            goto done;
        }

        //
        //  Allow up to c_dwMaxNoiseAllowed bytes worth of noise
        //
        int noiseBytesLeft = min(bytesLeft, c_dwMaxNoiseAllowed);
        int noiseBytesScanned = 0;
        while ((noiseBytesLeft > 0) 
               && (isspace((unsigned char)*lpszBuf)
                   || *lpszBuffer == '\0'))
        {
            ++lpszBuf;
            --bytesLeft;
            --noiseBytesLeft;
            ++noiseBytesScanned;
        }

        //
        // scan for the known version strings
        //

        for (int i = 0; i < NUM_HTTP_VERSIONS; ++i) {

            LPSTR version = KnownVersionsStrings[i].Version;
            DWORD length = KnownVersionsStrings[i].Length;

            if ((bytesLeft >= length)

            //
            // try the most common case as a direct comparison. memcmp()
            // should expand to cmpsd && cmpsb on x86 (most common platform
            // and one on which we are most interested in improving perf)
            //

            && (((i == 0)
                && (memcmp(lpszBuf, "HTTP/", sizeof("HTTP/") - 1) == 0))
                //&& (lpszBuf[0] == 'H')
                //&& (lpszBuf[1] == 'T')
                //&& (lpszBuf[2] == 'T')
                //&& (lpszBuf[3] == 'P')
                //&& (lpszBuf[4] == '/'))

                //
                //  "Clients should be tolerant in parsing the Status-Line"
                //  quote from HTTP/1.1 spec, therefore we perform a
                //  case-insensitive string comparison here
                //

                || (_strnicmp(lpszBuf, version, length) == 0))) {

                //
                // it starts with one of the recognized protocol version strings.
                // We assume its not a down-level server, although it could be,
                // sending back a plain text document that has e.g. "HTTP/1.0..."
                // at its start
                //
                // According to the HTTP "spec", though, it is mentioned that 0.9
                // servers typically only return HTML, hence we shouldn't see
                // even a 0.9 response start with non-HTML data
                //

                SetUpLevel(TRUE);
                _ResponseScanned += noiseBytesScanned;

                //
                // we have start of this response
                //

                lpszBuffer = lpszBuf;
                break;
            }
        }

        if (!IsUpLevel())
        {
            //
            // if we didn't find the start of a valid HTTP response and we have
            // not filled the response buffer sufficiently then allow
            // re-entry to retry.
            //
            // if we didn't find the start of a valid HTTP response and we
            //have filled the buffer sufficiently to expect the response,
            //report the response as invalid.
            //

            if ((bytesLeft < c_dwMaxPreHTTPLength ) && !IsEof())
            {
                goto done;
            }
            else
            {
                //
                // this may be a real down-level server, or it may be the response
                // from an FTP or gopher server via a proxy, in which case there
                // will be no headers. We will add some default headers to make
                // life easier for higher level software
                //

                AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                          "HTTP/1.0 200 OK",
                                          sizeof("HTTP/1.0 200 OK") - 1
                                          );
                _StatusCode = HTTP_STATUS_OK;
                //SetDownLevel(TRUE);

                //
                // we're now ready for the app to start reading data out
                //

                SetData(TRUE);

                //
                // down-level server: we're done
                //

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Server is down-level\n"
                            ));

                goto done;
            }
        }
    }

    //
    //  WinHTTP only accepts IsUpLevel() type responses.
    //

    INET_ASSERT(IsUpLevel());

    //
    // Note: at this point we can't store pointers into the response buffer
    // because it might move during a subsequent reallocation. We have to
    // maintain offsets into the buffer and convert to pointers when we come to
    // read the data out of the buffer (when the response is complete, or at
    // least we've finished receiving headers)
    //

    //
    // if we haven't checked the response yet, then the first thing to
    // get is the status line
    //

    statusLine = GetStatusLine();

    if (statusLine == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (!statusLine->HaveString())
    {
        BOOL fNeedMoreBuffer;
        int majorVersion = 0;
        int minorVersion = 0;
        BOOL fSupportsHttp1_1;

        _StatusCode = 0;

        //
        // Parse the status line.  It has already been checked up to the first '/'
        //

        error = _ResponseHeaders.ParseStatusLine(
            (LPSTR)_ResponseBuffer,
            _BytesReceived,
            IsEof(),
            &_ResponseScanned,
            &fNeedMoreBuffer,
            &_StatusCode,
            (LPDWORD)&majorVersion,
            (LPDWORD)&minorVersion
            );

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        if (fNeedMoreBuffer)
        {
            error = ERROR_SUCCESS;
            goto quit;
        }


        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Version = %d.%d\n",
                    majorVersion,
                    minorVersion
                    ));

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("_StatusCode = %d\n",
                    _StatusCode
                    ));

        fSupportsHttp1_1 = FALSE;

        if ( majorVersion > 1 )
        {
            //
            // for higher version servers, the 1.1 spec dictates
            //  that we return the highest version the client
            //  supports, and in our case that is 1.1.
            //

            fSupportsHttp1_1 = TRUE;
        }
        else if (majorVersion == 1
                 && minorVersion >= 1)
        {
            fSupportsHttp1_1 = TRUE;
        }

        SetResponseHttp1_1(fSupportsHttp1_1);

        //
        // record the server HTTP version in the server info object
        //

        CServerInfo * pServerInfo = GetServerInfo();

        if (pServerInfo != NULL)
        {
            if (fSupportsHttp1_1)
            {
                pServerInfo->SetHttp1_1();

                //
                // Set the max connections per HTTP 1.1 server.
                //
                pServerInfo->SetNewLimit(GlobalMaxConnectionsPerServer);
            } else {
                pServerInfo->SetHttp1_0();

                //
                // up the connection limit from HTTP 1.1 (default 2) to
                // HTTP 1.0 (default 4)
                //

                pServerInfo->SetNewLimit(GlobalMaxConnectionsPer1_0Server);
            }
        }
    }

    //
    // continue scanning headers here until we have tested all the current
    // buffer, or we have found the start of the data
    //

    BOOL fFoundEndOfHeaders;

    error = _ResponseHeaders.ParseHeaders(
                (LPSTR)_ResponseBuffer,
                _BytesReceived,
                IsEof(),
                &_ResponseScanned,
                &success,
                &fFoundEndOfHeaders
                );

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }


    if ( fFoundEndOfHeaders )
    {
        //
        // we found the end of the headers
        //

        SetEof(TRUE);

        //
        // and the start of the data
        //

        SetData(TRUE);
        _DataOffset = _ResponseScanned;

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of headers. _DataOffset = %d\n",
                    _DataOffset
                    ));

    }

done:

    //
    // if we have reached the end of the headers then we communicate this fact
    // to the caller
    //

    if (IsData() || IsEof()) {
        CheckWellKnownHeaders();
        if (ERROR_SUCCESS != error)
        {
            goto quit;
        }
        *lpbEof = TRUE;

        /*

        Set connection persistency based on these rules:

        persistent = (1.0Request && Con: K-A && 1.0Response && Con: K-A)
                     || (1.1Request && Con: K-A && 1.0Response && Con: K-A)
                     || (1.0Request && Con: K-A && 1.1Response && Con: K-A)
                     || (1.1Request && !Con: Close && 1.1Response && !Con: Close)

        therefore,

        persistent = 1.1Request && 1.1Response
                        ? (!Con: Close in request || response)
                        : Con: K-A in request && response

        */

        if (IsRequestHttp1_1() && IsResponseHttp1_1()) {

            BOOL bHaveConnCloseRequest;

            bHaveConnCloseRequest = FindConnCloseRequestHeader(
                                        IsRequestUsingProxy()
                                            ? HTTP_QUERY_PROXY_CONNECTION
                                            : HTTP_QUERY_CONNECTION
                                            );
            if (!(IsConnCloseResponse() || bHaveConnCloseRequest)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("HTTP/1.1 persistent connection\n"
                            ));

                SetKeepAlive(TRUE);
                SetPersistentConnection(IsRequestUsingProxy()
                                        && !IsTalkingToSecureServerViaProxy()
                                        );
            } else {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("HTTP/1.1 non-persistent connection: close on: request: %B; response: %B\n",
                            bHaveConnCloseRequest,
                            IsConnCloseResponse()
                            ));

                SetKeepAlive(FALSE);
                SetNoLongerKeepAlive();
                ClearPersistentConnection();
            }
        }
    }

    error = ERROR_SUCCESS;

quit:

    //
    // we are finished updating the response headers (no other thread should be
    // waiting for this if the reference count and object state is correct)
    //

    _ResponseHeaders.UnlockHeaders();

    PERF_LEAVE(UpdateResponseHeaders);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders(
    IN OUT LPSTR* ppszBuffer,
    IN DWORD      dwBufferLength
    )

/*++

Routine Description:

    Create the response headers given a buffer containing concatenated headers.
    Called when we are creating this object from the cache

Arguments:

    lpszBuffer      - pointer to buffer containing headers

    dwBufferLength  - length of lpszBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create headers

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders",
                 "%.32q, %d",
                 ppszBuffer,
                 dwBufferLength
                 ));

    //
    // there SHOULD NOT already be a response buffer if we're adding an
    // external buffer
    //

    INET_ASSERT(_ResponseBuffer == NULL);

    DWORD error;
    BOOL eof = FALSE;

    _ResponseBuffer = (LPBYTE) *ppszBuffer;
    _ResponseBufferLength = dwBufferLength;
    _BytesReceived = dwBufferLength;
    error = UpdateResponseHeaders(&eof);
    if (error != ERROR_SUCCESS) {

        //
        // if we failed, we will clean up our variables including clearing
        // out the response buffer address and length, but leave freeing
        // the buffer to the caller
        //

        _ResponseBuffer = NULL;
        _ResponseBufferLength = 0;
        ResetResponseVariables();

    } else {

        //
        // Success - the object owns the buffer so the caller should not free.
        //

        *ppszBuffer = NULL;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryResponseVersion(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the HTTP version string from the status line

Arguments:

    lpBuffer            - pointer to buffer to copy version string into

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: size of version string excluding terminating '\0'
                               if successful, else required buffer length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryResponseVersion);

    DWORD error;

    HEADER_STRING * statusLine = GetStatusLine();

    if ((statusLine == NULL) || statusLine->IsError()) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPSTR string;
    DWORD length;

    //
    // get a pointer into the response buffer where the status line starts
    // and its length
    //

    string = statusLine->StringAddress((LPSTR)_ResponseBuffer);
    length = (DWORD)statusLine->StringLength();

    //
    // the version string is the first token on the line, delimited by spaces
    //

    DWORD index;

    for (index = 0; index < length; ++index) {

        //
        // we'll also check for CR and LF, although just space should be
        // sufficient
        //

        if ((string[index] == ' ')
        || (string[index] == '\r')
        || (string[index] == '\n')) {
            break;
        }
    }
    if (*lpdwBufferLength > index) {
        memcpy(lpBuffer, (LPVOID)string, index);
        ((LPSTR)lpBuffer)[index] = '\0';
        *lpdwBufferLength = index;
        error = ERROR_SUCCESS;
    } else {
        *lpdwBufferLength = index + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:

    PERF_LEAVE(QueryResponseVersion);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryStatusCode(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Returns the status code as a string or a number

Arguments:

    lpBuffer            - pointer to buffer where results written

    lpdwBufferLength    - IN: length of buffer
                          OUT: size of returned information, or required size'
                               of buffer

    dwModifiers         - flags which modify returned value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryStatusCode);

    DWORD error;
    DWORD requiredSize;

    if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
        requiredSize = sizeof(_StatusCode);
        if (*lpdwBufferLength >= requiredSize) {
            *(LPDWORD)lpBuffer = _StatusCode;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        //
        // the number should always be only 3 characters long, but we'll be
        // flexible (just in case)
        //

        char numBuf[sizeof("4294967296")];

        requiredSize = wsprintf(numBuf, "%u", _StatusCode) + 1;

#ifdef DEBUG
        // Debug check to make sure everything is good because the above
        // used to be ultoa.
        char debugBuf[sizeof("4294967296")];
        ultoa(_StatusCode, debugBuf, 10);
        if (strcmp(debugBuf,numBuf))
        {
            INET_ASSERT(FALSE);
        }

        INET_ASSERT(requiredSize == lstrlen(numBuf) + 1);
#endif

        if (*lpdwBufferLength >= requiredSize) {
            memcpy(lpBuffer, (LPVOID)numBuf, requiredSize);
            *lpdwBufferLength = requiredSize - 1;
            error = ERROR_SUCCESS;
        } else {
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    PERF_LEAVE(QueryStatusCode);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryStatusText(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the status text - if any - returned by the server in the status line

Arguments:

    lpBuffer            - pointer to buffer where status text is written

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: length of the status text string minus 1 for the
                               '\0', or the required buffer length if we return
                               ERROR_INSUFFICIENT_BUFFER

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryStatusText);

    DWORD error;

    HEADER_STRING * statusLine = GetStatusLine();

    if ((statusLine == NULL) || statusLine->IsError()) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPSTR str;
    DWORD len;

    //
    // find the third token on the status line. The status line has the form
    //
    //  "HTTP/1.0 302 Try again\r\n"
    //
    //   ^        ^   ^
    //   |        |   |
    //   |        |   +- status text
    //   |        +- status code
    //   +- version
    //

    str = statusLine->StringAddress((LPSTR)_ResponseBuffer);
    len = statusLine->StringLength();

    DWORD i;

    i = 0;

    int j;

    for (j = 0; j < 2; ++j) {
        while ((i < len) && (str[i] != ' ')) {
            ++i;
        }
        while ((i < len) && (str[i] == ' ')) {
            ++i;
        }
    }
    len -= i;
    if (*lpdwBufferLength > len) {
        memcpy(lpBuffer, (LPVOID)&str[i], len);
        ((LPSTR)lpBuffer)[len] = '\0';
        *lpdwBufferLength = len;
        error = ERROR_SUCCESS;
    } else {
        *lpdwBufferLength = len + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:

    PERF_LEAVE(QueryStatusText);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRawResponseHeaders(
    IN BOOL bCrLfTerminated,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the raw response headers

Arguments:

    bCrLfTerminated     - TRUE if we want RAW_HEADERS_CRLF else RAW_HEADERS

    lpBuffer            - pointer to buffer where headers returned

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: returned length of lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRawHeaders",
                 "%B, %#x, %#x [%d]",
                 bCrLfTerminated,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength
                 ));

    PERF_ENTER(QueryRawHeaders);

    DWORD error = _ResponseHeaders.QueryRawHeaders(
                    (LPSTR)_ResponseBuffer,
                    bCrLfTerminated,
                    lpBuffer,
                    lpdwBufferLength
                    );

    IF_DEBUG_CODE() {
        if (error == ERROR_INSUFFICIENT_BUFFER) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("*lpdwBufferLength = %d\n",
                        *lpdwBufferLength
                        ));

        }
    }

    PERF_LEAVE(QueryRawHeaders);

    DEBUG_LEAVE(error);

    return error;

}


VOID
HTTP_REQUEST_HANDLE_OBJECT::RemoveAllRequestHeadersByName(
    IN DWORD dwQueryIndex
    )

/*++

Routine Description:

    Removes all headers of a particular type from the request object

Arguments:

    lpszHeaderName  - name of header to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "RemoveAllRequestHeadersByName",
                 "%q, %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex
                 ));

    PERF_ENTER(RemoveAllRequestHeadersByName);

    _RequestHeaders.RemoveAllByIndex(dwQueryIndex);

    PERF_LEAVE(RemoveAllRequestHeadersByName);

    DEBUG_LEAVE(0);
}

//
// private methods
//


PRIVATE
VOID
HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders(
    VOID
    )

/*++

Routine Description:

    Tests for a couple of well-known headers that are important to us as well as
    the app:

        "Connection: Keep-Alive"
        "Proxy-Connection: Keep-Alive"
        "Connection: Close"
        "Proxy-Connection: Close"
        "Transfer-Encoding: chunked"
        "Content-Length: ####"
        "Content-Range: bytes ####-####/####"

    The header DOES NOT contain CR-LF. That is, dwHeaderLength will not include
    any counts for line termination

    We need to know if the server honoured a request for a keep-alive connection
    so that we don't try to receive until we hit the end of the connection. The
    server will keep it open.

    We need to know the content length if we are talking over a persistent (keep
    alive) connection.

    If either header is found, we set the corresponding flag in the HTTP_HEADERS
    object, and in the case of "Content-Length:" we parse out the length.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders",
                 NULL
                 ));

    //
    // check for "Content-Length:" and "Content-Range"
    //

    if ( IsResponseHeaderPresent(HTTP_QUERY_CONTENT_RANGE) )
    {
        _iSlotContentRange = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONTENT_RANGE];
    }

    if ( IsResponseHeaderPresent(HTTP_QUERY_CONTENT_LENGTH) )
    {
        HEADER_STRING * curHeader;
        DWORD dwHeaderLength;
        LPSTR lpszHeader;

        _iSlotContentLength = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONTENT_LENGTH];
        curHeader = _ResponseHeaders.GetSlot(_iSlotContentLength);

        lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
        dwHeaderLength = curHeader->StringLength();

        dwHeaderLength -= GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Length+1;
        lpszHeader     += GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Length+1;

        while (dwHeaderLength && (*lpszHeader == ' ')) {
            --dwHeaderLength;
            ++lpszHeader;
        }
        while (dwHeaderLength && isdigit(*lpszHeader)) {
            _ContentLength = _ContentLength * 10 + (*lpszHeader - '0');
            --dwHeaderLength;
            ++lpszHeader;
        }

        //
        // once we have _ContentLength, we don't modify it (unless
        // we fix it up when using a 206 partial response to resume
        // a partial download.)  The header value should be returned
        // by HttpQueryInfo().  Instead, we keep account of the
        // amount of keep-alive data left to copy in _BytesRemaining
        //

        _BytesRemaining = _ContentLength;

        //
        // although we said we may be one past the end of the header, in
        // reality, if we received a buffer with "Content-Length:" then we
        // expect it to be terminated by CR-LF (or CR-CR-LF or just LF,
        // depending on the wackiness quotient of the server)
        //

        // darrenmi - commenting out because we're hitting it in stress.
        // headers coming from the cache have an extra space in them in
        // some circumstances.  Investigating seperately.
        // 2/25/00

        // INET_ASSERT((*lpszHeader == '\r') || (*lpszHeader == '\n'));


        SetHaveContentLength(TRUE);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("_ContentLength = %d\n",
                    _ContentLength
                    ));

        _BytesInSocket = (_ContentLength != 0)
                ? (_ContentLength - (_BytesReceived - _DataOffset))
                : 0;

        //
        // we could have multiple responses in the same buffer. If
        // the amount received is greater than the content length
        // then we have all the data; there are no bytes left in
        // the socket for the current response
        //

        if ((int)_BytesInSocket < 0) {
            _BytesInSocket = 0;
        }

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("bytes left in socket = %d\n",
                    _BytesInSocket
                    ));

    }


    if ( IsResponseHeaderPresent(HTTP_QUERY_CONNECTION) ||
         IsResponseHeaderPresent(HTTP_QUERY_PROXY_CONNECTION) )
    {
        //
        // check for "Connection: Keep-Alive" or "Proxy-Connection: Keep-Alive".
        // This test protects us against the unlikely
        // event of a server returning to us a keep-alive response header (because
        // that would cause problems for the proxy)
        //

        if (IsWantKeepAlive() && (!IsKeepAlive() || IsResponseHttp1_1()))
        {
            HEADER_STRING * curHeader;
            DWORD dwHeaderLength, headerNameLength;
            LPSTR lpszHeader;


            DWORD iSlot;

            char ch;

            if (IsRequestUsingProxy() &&
                IsResponseHeaderPresent(HTTP_QUERY_PROXY_CONNECTION))
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_PROXY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Length+1;
            }
            else if (IsResponseHeaderPresent(HTTP_QUERY_CONNECTION))
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_CONNECTION].Length+1;
            }
            else
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_PROXY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Length+1;
                INET_ASSERT(FALSE);
            }

            curHeader      = _ResponseHeaders.GetSlot(iSlot);
            lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
            dwHeaderLength = curHeader->StringLength();

            dwHeaderLength -= headerNameLength;
            lpszHeader     += headerNameLength;

            while (dwHeaderLength && (*lpszHeader == ' ')) {
                ++lpszHeader;
                --dwHeaderLength;
            }

            //
            // both headers use "Keep-Alive" as header-value ONLY for HTTP 1.0 servers
            //

            if (((int)dwHeaderLength >= KEEP_ALIVE_LEN)
            && !strnicmp(lpszHeader, KEEP_ALIVE_SZ, KEEP_ALIVE_LEN)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Connection: Keep-Alive\n"
                            ));

                //
                // BUGBUG - we are setting k-a when coming from cache!
                //

                SetKeepAlive(TRUE);
                SetPersistentConnection(headerNameLength == HTTP_PROXY_CONNECTION_LEN);
            }

            //
            // also check for "Close" as header-value ONLY for HTTP 1.1 servers
            //

            else if ((*lpszHeader == 'C' || *lpszHeader == 'c')
                     && ((int)dwHeaderLength >= CLOSE_LEN)
                     && IsResponseHttp1_1()
                     && !strnicmp(lpszHeader, CLOSE_SZ, CLOSE_LEN)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Connection: Close (HTTP/1.1)\n"
                            ));

                SetConnCloseResponse(TRUE);
            }
        }
    }

    //
    // check for "Refresh"
    //

    if ( IsResponseHeaderPresent(HTTP_QUERY_REFRESH)
        && !IsRefresh() )
    {

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("have \"Refresh:\" header\n"
                    ));

        SetRefresh(TRUE);
    }


    //
    // check for "Transfer-Encoding:"
    //

    if (IsResponseHeaderPresent(HTTP_QUERY_TRANSFER_ENCODING) &&
        IsResponseHttp1_1())
    {

        //
        // If Http 1.1, check for Chunked Transfer
        //

        HEADER_STRING * curHeader;
        DWORD dwHeaderLength;
        LPSTR lpszHeader;
        DWORD iSlot;

        iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING];
        curHeader = _ResponseHeaders.GetSlot(iSlot);

        lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
        dwHeaderLength = curHeader->StringLength();

        dwHeaderLength -= GlobalKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING].Length+1;
        lpszHeader     += GlobalKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING].Length+1;

        while (dwHeaderLength && (*lpszHeader == ' ')) {
            ++lpszHeader;
            --dwHeaderLength;
        }

        //
        // look for "chunked" entry that confirms that we're doing chunked transfer encoding
        //

        if (((int)dwHeaderLength >= CHUNKED_LEN)
        && !strnicmp(lpszHeader, C